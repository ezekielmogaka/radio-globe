{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/apps/web/src/app/api/stations/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport fs from 'fs';\nimport path from 'path';\n\nconst CACHE_FILE = path.join(process.cwd(), 'data', 'stations-cache.json');\nconst CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours\n\ninterface CacheData {\n  stations: any[];\n  timestamp: number;\n  version: string;\n}\n\n/**\n * GET /api/stations - Returns cached stations or fetches fresh data\n * Uses proper cache headers for CDN/browser caching\n */\nexport async function GET() {\n  try {\n    // Check if cache file exists and is fresh\n    if (fs.existsSync(CACHE_FILE)) {\n      const cacheData: CacheData = JSON.parse(fs.readFileSync(CACHE_FILE, 'utf-8'));\n      const age = Date.now() - cacheData.timestamp;\n\n      // Return cache if fresh\n      if (age < CACHE_DURATION) {\n        console.log(`Serving ${cacheData.stations.length} stations from cache (age: ${Math.round(age / 1000 / 60)} min)`);\n        \n        // Calculate cache control headers\n        const maxAge = Math.floor((CACHE_DURATION - age) / 1000); // seconds until stale\n        const staleWhileRevalidate = 86400; // 24 hours - serve stale while revalidating\n        \n        return NextResponse.json({\n          stations: cacheData.stations,\n          cached: true,\n          timestamp: cacheData.timestamp,\n          count: cacheData.stations.length,\n        }, {\n          headers: {\n            'Cache-Control': `public, max-age=${maxAge}, stale-while-revalidate=${staleWhileRevalidate}`,\n            'X-Cache-Age': `${Math.round(age / 1000)}`,\n            'X-Cache-Status': 'HIT',\n          },\n        });\n      }\n\n      // Cache is stale, trigger background refresh but return stale data\n      console.log('Cache stale, triggering background refresh...');\n      refreshCacheInBackground();\n      \n      return NextResponse.json({\n        stations: cacheData.stations,\n        cached: true,\n        stale: true,\n        timestamp: cacheData.timestamp,\n        count: cacheData.stations.length,\n      }, {\n        headers: {\n          'Cache-Control': 'public, max-age=0, stale-while-revalidate=86400',\n          'X-Cache-Age': `${Math.round(age / 1000)}`,\n          'X-Cache-Status': 'STALE',\n        },\n      });\n    }\n\n    // No cache exists, fetch fresh data\n    console.log('No cache found, fetching fresh data...');\n    const stations = await fetchAndCacheStations();\n    \n    return NextResponse.json({\n      stations,\n      cached: false,\n      timestamp: Date.now(),\n      count: stations.length,\n    }, {\n      headers: {\n        'Cache-Control': `public, max-age=${CACHE_DURATION / 1000}, stale-while-revalidate=86400`,\n        'X-Cache-Status': 'MISS',\n      },\n    });\n  } catch (error) {\n    console.error('Error in /api/stations:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch stations' },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * POST /api/stations/refresh - Force refresh cache\n */\nexport async function POST() {\n  try {\n    console.log('Manual refresh requested...');\n    const stations = await fetchAndCacheStations();\n    \n    return NextResponse.json({\n      success: true,\n      count: stations.length,\n      timestamp: Date.now(),\n    });\n  } catch (error) {\n    console.error('Error refreshing cache:', error);\n    return NextResponse.json(\n      { error: 'Failed to refresh cache' },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * Fetch stations from Radio Browser API and cache to JSON file\n */\nasync function fetchAndCacheStations(): Promise<any[]> {\n  const baseUrl = 'https://de1.api.radio-browser.info/json';\n  \n  console.log('Fetching stations from Radio Browser API...');\n  const response = await fetch(\n    `${baseUrl}/stations?limit=50000&hidebroken=true&order=clickcount&reverse=true`\n  );\n\n  if (!response.ok) {\n    throw new Error('Failed to fetch from Radio Browser API');\n  }\n\n  const stations = await response.json();\n  console.log(`Fetched ${stations.length} stations from API`);\n\n  // Ensure data directory exists\n  const dataDir = path.dirname(CACHE_FILE);\n  if (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n  }\n\n  // Save to cache file\n  const cacheData: CacheData = {\n    stations,\n    timestamp: Date.now(),\n    version: '1.0.0',\n  };\n\n  fs.writeFileSync(CACHE_FILE, JSON.stringify(cacheData, null, 2));\n  console.log(`Cached ${stations.length} stations to ${CACHE_FILE}`);\n\n  return stations;\n}\n\n/**\n * Background refresh (non-blocking)\n */\nfunction refreshCacheInBackground() {\n  fetchAndCacheStations().catch(err => {\n    console.error('Background refresh failed:', err);\n  });\n}\n"],"names":["CACHE_FILE","join","process","cwd","CACHE_DURATION","GET","existsSync","cacheData","JSON","parse","readFileSync","age","Date","now","timestamp","console","log","stations","length","Math","round","maxAge","floor","staleWhileRevalidate","json","cached","count","headers","refreshCacheInBackground","stale","fetchAndCacheStations","error","status","POST","success","baseUrl","response","fetch","ok","Error","dataDir","dirname","mkdirSync","recursive","version","writeFileSync","stringify","catch","err"],"mappings":"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"}}]
}