{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Expression.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport jsep from \"jsep\";\nimport ExpressionNodeType from \"./ExpressionNodeType.js\";\n\n/**\n * An expression for a style applied to a {@link Cesium3DTileset}.\n * <p>\n * Evaluates an expression defined using the\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}.\n * </p>\n * <p>\n * Implements the {@link StyleExpression} interface.\n * </p>\n *\n * @alias Expression\n * @constructor\n *\n * @param {string} [expression] The expression defined using the 3D Tiles Styling language.\n * @param {object} [defines] Defines in the style.\n *\n * @example\n * const expression = new Cesium.Expression('(regExp(\"^Chest\").test(${County})) && (${YearBuilt} >= 1970)');\n * expression.evaluate(feature); // returns true or false depending on the feature's properties\n *\n * @example\n * const expression = new Cesium.Expression('(${Temperature} > 90) ? color(\"red\") : color(\"white\")');\n * expression.evaluateColor(feature, result); // returns a Cesium.Color object\n */\nfunction Expression(expression, defines) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"expression\", expression);\n  //>>includeEnd('debug');\n\n  this._expression = expression;\n  expression = replaceDefines(expression, defines);\n  expression = replaceVariables(removeBackslashes(expression));\n\n  // customize jsep operators\n  jsep.addBinaryOp(\"=~\", 0);\n  jsep.addBinaryOp(\"!~\", 0);\n\n  let ast;\n  try {\n    ast = jsep(expression);\n  } catch (e) {\n    throw new RuntimeError(e);\n  }\n\n  this._runtimeAst = createRuntimeAst(this, ast);\n}\n\nObject.defineProperties(Expression.prototype, {\n  /**\n   * Gets the expression defined in the 3D Tiles Styling language.\n   *\n   * @memberof Expression.prototype\n   *\n   * @type {string}\n   * @readonly\n   *\n   * @default undefined\n   */\n  expression: {\n    get: function () {\n      return this._expression;\n    },\n  },\n});\n\n// Scratch storage manager while evaluating deep expressions.\n// For example, an expression like dot(vec4(${red}), vec4(${green}) * vec4(${blue}) requires 3 scratch Cartesian4's\nconst scratchStorage = {\n  arrayIndex: 0,\n  arrayArray: [[]],\n  cartesian2Index: 0,\n  cartesian3Index: 0,\n  cartesian4Index: 0,\n  cartesian2Array: [new Cartesian2()],\n  cartesian3Array: [new Cartesian3()],\n  cartesian4Array: [new Cartesian4()],\n  reset: function () {\n    this.arrayIndex = 0;\n    this.cartesian2Index = 0;\n    this.cartesian3Index = 0;\n    this.cartesian4Index = 0;\n  },\n  getArray: function () {\n    if (this.arrayIndex >= this.arrayArray.length) {\n      this.arrayArray.push([]);\n    }\n    const array = this.arrayArray[this.arrayIndex++];\n    array.length = 0;\n    return array;\n  },\n  getCartesian2: function () {\n    if (this.cartesian2Index >= this.cartesian2Array.length) {\n      this.cartesian2Array.push(new Cartesian2());\n    }\n    return this.cartesian2Array[this.cartesian2Index++];\n  },\n  getCartesian3: function () {\n    if (this.cartesian3Index >= this.cartesian3Array.length) {\n      this.cartesian3Array.push(new Cartesian3());\n    }\n    return this.cartesian3Array[this.cartesian3Index++];\n  },\n  getCartesian4: function () {\n    if (this.cartesian4Index >= this.cartesian4Array.length) {\n      this.cartesian4Array.push(new Cartesian4());\n    }\n    return this.cartesian4Array[this.cartesian4Index++];\n  },\n};\n\n/**\n * Evaluates the result of an expression, optionally using the provided feature's properties. If the result of\n * the expression in the\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}\n * is of type <code>Boolean</code>, <code>Number</code>, or <code>String</code>, the corresponding JavaScript\n * primitive type will be returned. If the result is a <code>RegExp</code>, a Javascript <code>RegExp</code>\n * object will be returned. If the result is a <code>Cartesian2</code>, <code>Cartesian3</code>, or <code>Cartesian4</code>,\n * a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} object will be returned. If the <code>result</code> argument is\n * a {@link Color}, the {@link Cartesian4} value is converted to a {@link Color} and then returned.\n *\n * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.\n * @param {object} [result] The object onto which to store the result.\n * @returns {boolean|number|string|RegExp|Cartesian2|Cartesian3|Cartesian4|Color} The result of evaluating the expression.\n */\nExpression.prototype.evaluate = function (feature, result) {\n  scratchStorage.reset();\n  const value = this._runtimeAst.evaluate(feature);\n  if (result instanceof Color && value instanceof Cartesian4) {\n    return Color.fromCartesian4(value, result);\n  }\n  if (\n    value instanceof Cartesian2 ||\n    value instanceof Cartesian3 ||\n    value instanceof Cartesian4\n  ) {\n    return value.clone(result);\n  }\n  return value;\n};\n\n/**\n * Evaluates the result of a Color expression, optionally using the provided feature's properties.\n * <p>\n * This is equivalent to {@link Expression#evaluate} but always returns a {@link Color} object.\n * </p>\n *\n * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.\n * @param {Color} [result] The object in which to store the result\n * @returns {Color} The modified result parameter or a new Color instance if one was not provided.\n */\nExpression.prototype.evaluateColor = function (feature, result) {\n  scratchStorage.reset();\n  const color = this._runtimeAst.evaluate(feature);\n  return Color.fromCartesian4(color, result);\n};\n\n/**\n * Gets the shader function for this expression.\n * Returns undefined if the shader function can't be generated from this expression.\n *\n * @param {string} functionSignature Signature of the generated function.\n * @param {object} variableSubstitutionMap Maps variable names to shader variable names.\n * @param {object} shaderState Stores information about the generated shader function, including whether it is translucent.\n * @param {string} returnType The return type of the generated function.\n *\n * @returns {string} The shader function.\n *\n * @private\n */\nExpression.prototype.getShaderFunction = function (\n  functionSignature,\n  variableSubstitutionMap,\n  shaderState,\n  returnType,\n) {\n  let shaderExpression = this.getShaderExpression(\n    variableSubstitutionMap,\n    shaderState,\n  );\n\n  shaderExpression =\n    `${returnType} ${functionSignature}\\n` +\n    `{\\n` +\n    `    return ${shaderExpression};\\n` +\n    `}\\n`;\n\n  return shaderExpression;\n};\n\n/**\n * Gets the shader expression for this expression.\n * Returns undefined if the shader expression can't be generated from this expression.\n *\n * @param {object} variableSubstitutionMap Maps variable names to shader variable names.\n * @param {object} shaderState Stores information about the generated shader function, including whether it is translucent.\n *\n * @returns {string} The shader expression.\n *\n * @private\n */\nExpression.prototype.getShaderExpression = function (\n  variableSubstitutionMap,\n  shaderState,\n) {\n  return this._runtimeAst.getShaderExpression(\n    variableSubstitutionMap,\n    shaderState,\n  );\n};\n\n/**\n * Gets the variables used by the expression.\n *\n * @returns {string[]} The variables used by the expression.\n *\n * @private\n */\nExpression.prototype.getVariables = function () {\n  let variables = [];\n\n  this._runtimeAst.getVariables(variables);\n\n  // Remove duplicates\n  variables = variables.filter(function (variable, index, variables) {\n    return variables.indexOf(variable) === index;\n  });\n\n  return variables;\n};\n\nconst unaryOperators = [\"!\", \"-\", \"+\"];\nconst binaryOperators = [\n  \"+\",\n  \"-\",\n  \"*\",\n  \"/\",\n  \"%\",\n  \"===\",\n  \"!==\",\n  \">\",\n  \">=\",\n  \"<\",\n  \"<=\",\n  \"&&\",\n  \"||\",\n  \"!~\",\n  \"=~\",\n];\n\nconst variableRegex = /\\${(.*?)}/g; // Matches ${variable_name}\nconst backslashRegex = /\\\\/g;\nconst backslashReplacement = \"@#%\";\nconst replacementRegex = /@#%/g;\n\nconst scratchColor = new Color();\n\nconst unaryFunctions = {\n  abs: getEvaluateUnaryComponentwise(Math.abs),\n  sqrt: getEvaluateUnaryComponentwise(Math.sqrt),\n  cos: getEvaluateUnaryComponentwise(Math.cos),\n  sin: getEvaluateUnaryComponentwise(Math.sin),\n  tan: getEvaluateUnaryComponentwise(Math.tan),\n  acos: getEvaluateUnaryComponentwise(Math.acos),\n  asin: getEvaluateUnaryComponentwise(Math.asin),\n  atan: getEvaluateUnaryComponentwise(Math.atan),\n  radians: getEvaluateUnaryComponentwise(CesiumMath.toRadians),\n  degrees: getEvaluateUnaryComponentwise(CesiumMath.toDegrees),\n  sign: getEvaluateUnaryComponentwise(CesiumMath.sign),\n  floor: getEvaluateUnaryComponentwise(Math.floor),\n  ceil: getEvaluateUnaryComponentwise(Math.ceil),\n  round: getEvaluateUnaryComponentwise(Math.round),\n  exp: getEvaluateUnaryComponentwise(Math.exp),\n  exp2: getEvaluateUnaryComponentwise(exp2),\n  log: getEvaluateUnaryComponentwise(Math.log),\n  log2: getEvaluateUnaryComponentwise(log2),\n  fract: getEvaluateUnaryComponentwise(fract),\n  length: length,\n  normalize: normalize,\n};\n\nconst binaryFunctions = {\n  atan2: getEvaluateBinaryComponentwise(Math.atan2, false),\n  pow: getEvaluateBinaryComponentwise(Math.pow, false),\n  min: getEvaluateBinaryComponentwise(Math.min, true),\n  max: getEvaluateBinaryComponentwise(Math.max, true),\n  distance: distance,\n  dot: dot,\n  cross: cross,\n};\n\nconst ternaryFunctions = {\n  clamp: getEvaluateTernaryComponentwise(CesiumMath.clamp, true),\n  mix: getEvaluateTernaryComponentwise(CesiumMath.lerp, true),\n};\n\nfunction fract(number) {\n  return number - Math.floor(number);\n}\n\nfunction exp2(exponent) {\n  return Math.pow(2.0, exponent);\n}\n\nfunction log2(number) {\n  return CesiumMath.log2(number);\n}\n\nfunction getEvaluateUnaryComponentwise(operation) {\n  return function (call, left) {\n    if (typeof left === \"number\") {\n      return operation(left);\n    } else if (left instanceof Cartesian2) {\n      return Cartesian2.fromElements(\n        operation(left.x),\n        operation(left.y),\n        scratchStorage.getCartesian2(),\n      );\n    } else if (left instanceof Cartesian3) {\n      return Cartesian3.fromElements(\n        operation(left.x),\n        operation(left.y),\n        operation(left.z),\n        scratchStorage.getCartesian3(),\n      );\n    } else if (left instanceof Cartesian4) {\n      return Cartesian4.fromElements(\n        operation(left.x),\n        operation(left.y),\n        operation(left.z),\n        operation(left.w),\n        scratchStorage.getCartesian4(),\n      );\n    }\n    throw new RuntimeError(\n      `Function \"${call}\" requires a vector or number argument. Argument is ${left}.`,\n    );\n  };\n}\n\nfunction getEvaluateBinaryComponentwise(operation, allowScalar) {\n  return function (call, left, right) {\n    if (allowScalar && typeof right === \"number\") {\n      if (typeof left === \"number\") {\n        return operation(left, right);\n      } else if (left instanceof Cartesian2) {\n        return Cartesian2.fromElements(\n          operation(left.x, right),\n          operation(left.y, right),\n          scratchStorage.getCartesian2(),\n        );\n      } else if (left instanceof Cartesian3) {\n        return Cartesian3.fromElements(\n          operation(left.x, right),\n          operation(left.y, right),\n          operation(left.z, right),\n          scratchStorage.getCartesian3(),\n        );\n      } else if (left instanceof Cartesian4) {\n        return Cartesian4.fromElements(\n          operation(left.x, right),\n          operation(left.y, right),\n          operation(left.z, right),\n          operation(left.w, right),\n          scratchStorage.getCartesian4(),\n        );\n      }\n    }\n\n    if (typeof left === \"number\" && typeof right === \"number\") {\n      return operation(left, right);\n    } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n      return Cartesian2.fromElements(\n        operation(left.x, right.x),\n        operation(left.y, right.y),\n        scratchStorage.getCartesian2(),\n      );\n    } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n      return Cartesian3.fromElements(\n        operation(left.x, right.x),\n        operation(left.y, right.y),\n        operation(left.z, right.z),\n        scratchStorage.getCartesian3(),\n      );\n    } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n      return Cartesian4.fromElements(\n        operation(left.x, right.x),\n        operation(left.y, right.y),\n        operation(left.z, right.z),\n        operation(left.w, right.w),\n        scratchStorage.getCartesian4(),\n      );\n    }\n\n    throw new RuntimeError(\n      `Function \"${call}\" requires vector or number arguments of matching types. Arguments are ${left} and ${right}.`,\n    );\n  };\n}\n\nfunction getEvaluateTernaryComponentwise(operation, allowScalar) {\n  return function (call, left, right, test) {\n    if (allowScalar && typeof test === \"number\") {\n      if (typeof left === \"number\" && typeof right === \"number\") {\n        return operation(left, right, test);\n      } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n        return Cartesian2.fromElements(\n          operation(left.x, right.x, test),\n          operation(left.y, right.y, test),\n          scratchStorage.getCartesian2(),\n        );\n      } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n        return Cartesian3.fromElements(\n          operation(left.x, right.x, test),\n          operation(left.y, right.y, test),\n          operation(left.z, right.z, test),\n          scratchStorage.getCartesian3(),\n        );\n      } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n        return Cartesian4.fromElements(\n          operation(left.x, right.x, test),\n          operation(left.y, right.y, test),\n          operation(left.z, right.z, test),\n          operation(left.w, right.w, test),\n          scratchStorage.getCartesian4(),\n        );\n      }\n    }\n\n    if (\n      typeof left === \"number\" &&\n      typeof right === \"number\" &&\n      typeof test === \"number\"\n    ) {\n      return operation(left, right, test);\n    } else if (\n      left instanceof Cartesian2 &&\n      right instanceof Cartesian2 &&\n      test instanceof Cartesian2\n    ) {\n      return Cartesian2.fromElements(\n        operation(left.x, right.x, test.x),\n        operation(left.y, right.y, test.y),\n        scratchStorage.getCartesian2(),\n      );\n    } else if (\n      left instanceof Cartesian3 &&\n      right instanceof Cartesian3 &&\n      test instanceof Cartesian3\n    ) {\n      return Cartesian3.fromElements(\n        operation(left.x, right.x, test.x),\n        operation(left.y, right.y, test.y),\n        operation(left.z, right.z, test.z),\n        scratchStorage.getCartesian3(),\n      );\n    } else if (\n      left instanceof Cartesian4 &&\n      right instanceof Cartesian4 &&\n      test instanceof Cartesian4\n    ) {\n      return Cartesian4.fromElements(\n        operation(left.x, right.x, test.x),\n        operation(left.y, right.y, test.y),\n        operation(left.z, right.z, test.z),\n        operation(left.w, right.w, test.w),\n        scratchStorage.getCartesian4(),\n      );\n    }\n\n    throw new RuntimeError(\n      `Function \"${call}\" requires vector or number arguments of matching types. Arguments are ${left}, ${right}, and ${test}.`,\n    );\n  };\n}\n\nfunction length(call, left) {\n  if (typeof left === \"number\") {\n    return Math.abs(left);\n  } else if (left instanceof Cartesian2) {\n    return Cartesian2.magnitude(left);\n  } else if (left instanceof Cartesian3) {\n    return Cartesian3.magnitude(left);\n  } else if (left instanceof Cartesian4) {\n    return Cartesian4.magnitude(left);\n  }\n\n  throw new RuntimeError(\n    `Function \"${call}\" requires a vector or number argument. Argument is ${left}.`,\n  );\n}\n\nfunction normalize(call, left) {\n  if (typeof left === \"number\") {\n    return 1.0;\n  } else if (left instanceof Cartesian2) {\n    return Cartesian2.normalize(left, scratchStorage.getCartesian2());\n  } else if (left instanceof Cartesian3) {\n    return Cartesian3.normalize(left, scratchStorage.getCartesian3());\n  } else if (left instanceof Cartesian4) {\n    return Cartesian4.normalize(left, scratchStorage.getCartesian4());\n  }\n\n  throw new RuntimeError(\n    `Function \"${call}\" requires a vector or number argument. Argument is ${left}.`,\n  );\n}\n\nfunction distance(call, left, right) {\n  if (typeof left === \"number\" && typeof right === \"number\") {\n    return Math.abs(left - right);\n  } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n    return Cartesian2.distance(left, right);\n  } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n    return Cartesian3.distance(left, right);\n  } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n    return Cartesian4.distance(left, right);\n  }\n\n  throw new RuntimeError(\n    `Function \"${call}\" requires vector or number arguments of matching types. Arguments are ${left} and ${right}.`,\n  );\n}\n\nfunction dot(call, left, right) {\n  if (typeof left === \"number\" && typeof right === \"number\") {\n    return left * right;\n  } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n    return Cartesian2.dot(left, right);\n  } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n    return Cartesian3.dot(left, right);\n  } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n    return Cartesian4.dot(left, right);\n  }\n\n  throw new RuntimeError(\n    `Function \"${call}\" requires vector or number arguments of matching types. Arguments are ${left} and ${right}.`,\n  );\n}\n\nfunction cross(call, left, right) {\n  if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n    return Cartesian3.cross(left, right, scratchStorage.getCartesian3());\n  }\n\n  throw new RuntimeError(\n    `Function \"${call}\" requires vec3 arguments. Arguments are ${left} and ${right}.`,\n  );\n}\n\nfunction Node(type, value, left, right, test) {\n  this._type = type;\n  this._value = value;\n  this._left = left;\n  this._right = right;\n  this._test = test;\n  this.evaluate = undefined;\n\n  setEvaluateFunction(this);\n}\n\nfunction replaceDefines(expression, defines) {\n  if (!defined(defines)) {\n    return expression;\n  }\n  for (const key in defines) {\n    if (defines.hasOwnProperty(key)) {\n      const definePlaceholder = new RegExp(`\\\\$\\\\{${key}\\\\}`, \"g\");\n      const defineReplace = `(${defines[key]})`;\n      if (defined(defineReplace)) {\n        expression = expression.replace(definePlaceholder, defineReplace);\n      }\n    }\n  }\n  return expression;\n}\n\nfunction removeBackslashes(expression) {\n  return expression.replace(backslashRegex, backslashReplacement);\n}\n\nfunction replaceBackslashes(expression) {\n  return expression.replace(replacementRegex, \"\\\\\");\n}\n\nfunction replaceVariables(expression) {\n  let exp = expression;\n  let result = \"\";\n  let i = exp.indexOf(\"${\");\n  while (i >= 0) {\n    // Check if string is inside quotes\n    const openSingleQuote = exp.indexOf(\"'\");\n    const openDoubleQuote = exp.indexOf('\"');\n    let closeQuote;\n    if (openSingleQuote >= 0 && openSingleQuote < i) {\n      closeQuote = exp.indexOf(\"'\", openSingleQuote + 1);\n      result += exp.substr(0, closeQuote + 1);\n      exp = exp.substr(closeQuote + 1);\n      i = exp.indexOf(\"${\");\n    } else if (openDoubleQuote >= 0 && openDoubleQuote < i) {\n      closeQuote = exp.indexOf('\"', openDoubleQuote + 1);\n      result += exp.substr(0, closeQuote + 1);\n      exp = exp.substr(closeQuote + 1);\n      i = exp.indexOf(\"${\");\n    } else {\n      result += exp.substr(0, i);\n      const j = exp.indexOf(\"}\");\n      if (j < 0) {\n        throw new RuntimeError(\"Unmatched {.\");\n      }\n      result += `czm_${exp.substr(i + 2, j - (i + 2))}`;\n      exp = exp.substr(j + 1);\n      i = exp.indexOf(\"${\");\n    }\n  }\n  result += exp;\n  return result;\n}\n\nfunction parseLiteral(ast) {\n  const type = typeof ast.value;\n  if (ast.value === null) {\n    return new Node(ExpressionNodeType.LITERAL_NULL, null);\n  } else if (type === \"boolean\") {\n    return new Node(ExpressionNodeType.LITERAL_BOOLEAN, ast.value);\n  } else if (type === \"number\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, ast.value);\n  } else if (type === \"string\") {\n    if (ast.value.indexOf(\"${\") >= 0) {\n      return new Node(ExpressionNodeType.VARIABLE_IN_STRING, ast.value);\n    }\n    return new Node(\n      ExpressionNodeType.LITERAL_STRING,\n      replaceBackslashes(ast.value),\n    );\n  }\n}\n\nfunction parseCall(expression, ast) {\n  const args = ast.arguments;\n  const argsLength = args.length;\n  let call;\n  let val, left, right;\n\n  // Member function calls\n  if (ast.callee.type === \"MemberExpression\") {\n    call = ast.callee.property.name;\n    const object = ast.callee.object;\n    if (call === \"test\" || call === \"exec\") {\n      // Make sure this is called on a valid type\n      if (!defined(object.callee) || object.callee.name !== \"regExp\") {\n        throw new RuntimeError(`${call} is not a function.`);\n      }\n      if (argsLength === 0) {\n        if (call === \"test\") {\n          return new Node(ExpressionNodeType.LITERAL_BOOLEAN, false);\n        }\n        return new Node(ExpressionNodeType.LITERAL_NULL, null);\n      }\n      left = createRuntimeAst(expression, object);\n      right = createRuntimeAst(expression, args[0]);\n      return new Node(ExpressionNodeType.FUNCTION_CALL, call, left, right);\n    } else if (call === \"toString\") {\n      val = createRuntimeAst(expression, object);\n      return new Node(ExpressionNodeType.FUNCTION_CALL, call, val);\n    }\n\n    throw new RuntimeError(`Unexpected function call \"${call}\".`);\n  }\n\n  // Non-member function calls\n  call = ast.callee.name;\n  if (call === \"color\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_COLOR, call);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    if (defined(args[1])) {\n      const alpha = createRuntimeAst(expression, args[1]);\n      return new Node(ExpressionNodeType.LITERAL_COLOR, call, [val, alpha]);\n    }\n    return new Node(ExpressionNodeType.LITERAL_COLOR, call, [val]);\n  } else if (call === \"rgb\" || call === \"hsl\") {\n    if (argsLength < 3) {\n      throw new RuntimeError(`${call} requires three arguments.`);\n    }\n    val = [\n      createRuntimeAst(expression, args[0]),\n      createRuntimeAst(expression, args[1]),\n      createRuntimeAst(expression, args[2]),\n    ];\n    return new Node(ExpressionNodeType.LITERAL_COLOR, call, val);\n  } else if (call === \"rgba\" || call === \"hsla\") {\n    if (argsLength < 4) {\n      throw new RuntimeError(`${call} requires four arguments.`);\n    }\n    val = [\n      createRuntimeAst(expression, args[0]),\n      createRuntimeAst(expression, args[1]),\n      createRuntimeAst(expression, args[2]),\n      createRuntimeAst(expression, args[3]),\n    ];\n    return new Node(ExpressionNodeType.LITERAL_COLOR, call, val);\n  } else if (call === \"vec2\" || call === \"vec3\" || call === \"vec4\") {\n    // Check for invalid constructors at evaluation time\n    val = new Array(argsLength);\n    for (let i = 0; i < argsLength; ++i) {\n      val[i] = createRuntimeAst(expression, args[i]);\n    }\n    return new Node(ExpressionNodeType.LITERAL_VECTOR, call, val);\n  } else if (call === \"isNaN\" || call === \"isFinite\") {\n    if (argsLength === 0) {\n      if (call === \"isNaN\") {\n        return new Node(ExpressionNodeType.LITERAL_BOOLEAN, true);\n      }\n      return new Node(ExpressionNodeType.LITERAL_BOOLEAN, false);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"isExactClass\" || call === \"isClass\") {\n    if (argsLength < 1 || argsLength > 1) {\n      throw new RuntimeError(`${call} requires exactly one argument.`);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"getExactClassName\") {\n    if (argsLength > 0) {\n      throw new RuntimeError(`${call} does not take any argument.`);\n    }\n    return new Node(ExpressionNodeType.UNARY, call);\n  } else if (defined(unaryFunctions[call])) {\n    if (argsLength !== 1) {\n      throw new RuntimeError(`${call} requires exactly one argument.`);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (defined(binaryFunctions[call])) {\n    if (argsLength !== 2) {\n      throw new RuntimeError(`${call} requires exactly two arguments.`);\n    }\n    left = createRuntimeAst(expression, args[0]);\n    right = createRuntimeAst(expression, args[1]);\n    return new Node(ExpressionNodeType.BINARY, call, left, right);\n  } else if (defined(ternaryFunctions[call])) {\n    if (argsLength !== 3) {\n      throw new RuntimeError(`${call} requires exactly three arguments.`);\n    }\n    left = createRuntimeAst(expression, args[0]);\n    right = createRuntimeAst(expression, args[1]);\n    const test = createRuntimeAst(expression, args[2]);\n    return new Node(ExpressionNodeType.TERNARY, call, left, right, test);\n  } else if (call === \"Boolean\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_BOOLEAN, false);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"Number\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_NUMBER, 0);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"String\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_STRING, \"\");\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"regExp\") {\n    return parseRegex(expression, ast);\n  }\n\n  throw new RuntimeError(`Unexpected function call \"${call}\".`);\n}\n\nfunction parseRegex(expression, ast) {\n  const args = ast.arguments;\n  // no arguments, return default regex\n  if (args.length === 0) {\n    return new Node(ExpressionNodeType.LITERAL_REGEX, new RegExp());\n  }\n\n  const pattern = createRuntimeAst(expression, args[0]);\n  let exp;\n\n  // optional flag argument supplied\n  if (args.length > 1) {\n    const flags = createRuntimeAst(expression, args[1]);\n    if (isLiteralType(pattern) && isLiteralType(flags)) {\n      try {\n        exp = new RegExp(\n          replaceBackslashes(String(pattern._value)),\n          flags._value,\n        );\n      } catch (e) {\n        throw new RuntimeError(e);\n      }\n      return new Node(ExpressionNodeType.LITERAL_REGEX, exp);\n    }\n    return new Node(ExpressionNodeType.REGEX, pattern, flags);\n  }\n\n  // only pattern argument supplied\n  if (isLiteralType(pattern)) {\n    try {\n      exp = new RegExp(replaceBackslashes(String(pattern._value)));\n    } catch (e) {\n      throw new RuntimeError(e);\n    }\n    return new Node(ExpressionNodeType.LITERAL_REGEX, exp);\n  }\n  return new Node(ExpressionNodeType.REGEX, pattern);\n}\n\nfunction parseKeywordsAndVariables(ast) {\n  if (isVariable(ast.name)) {\n    const name = getPropertyName(ast.name);\n    if (name.substr(0, 8) === \"tiles3d_\") {\n      return new Node(ExpressionNodeType.BUILTIN_VARIABLE, name);\n    }\n    return new Node(ExpressionNodeType.VARIABLE, name);\n  } else if (ast.name === \"NaN\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, NaN);\n  } else if (ast.name === \"Infinity\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Infinity);\n  } else if (ast.name === \"undefined\") {\n    return new Node(ExpressionNodeType.LITERAL_UNDEFINED, undefined);\n  }\n\n  throw new RuntimeError(`${ast.name} is not defined.`);\n}\n\nfunction parseMathConstant(ast) {\n  const name = ast.property.name;\n  if (name === \"PI\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Math.PI);\n  } else if (name === \"E\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Math.E);\n  }\n}\n\nfunction parseNumberConstant(ast) {\n  const name = ast.property.name;\n  if (name === \"POSITIVE_INFINITY\") {\n    return new Node(\n      ExpressionNodeType.LITERAL_NUMBER,\n      Number.POSITIVE_INFINITY,\n    );\n  }\n}\n\nfunction parseMemberExpression(expression, ast) {\n  if (ast.object.name === \"Math\") {\n    return parseMathConstant(ast);\n  } else if (ast.object.name === \"Number\") {\n    return parseNumberConstant(ast);\n  }\n\n  let val;\n  const obj = createRuntimeAst(expression, ast.object);\n  if (ast.computed) {\n    val = createRuntimeAst(expression, ast.property);\n    return new Node(ExpressionNodeType.MEMBER, \"brackets\", obj, val);\n  }\n\n  val = new Node(ExpressionNodeType.LITERAL_STRING, ast.property.name);\n  return new Node(ExpressionNodeType.MEMBER, \"dot\", obj, val);\n}\n\nfunction isLiteralType(node) {\n  return node._type >= ExpressionNodeType.LITERAL_NULL;\n}\n\nfunction isVariable(name) {\n  return name.substr(0, 4) === \"czm_\";\n}\n\nfunction getPropertyName(variable) {\n  return variable.substr(4);\n}\n\nfunction createRuntimeAst(expression, ast) {\n  let node;\n  let op;\n  let left;\n  let right;\n\n  if (ast.type === \"Literal\") {\n    node = parseLiteral(ast);\n  } else if (ast.type === \"CallExpression\") {\n    node = parseCall(expression, ast);\n  } else if (ast.type === \"Identifier\") {\n    node = parseKeywordsAndVariables(ast);\n  } else if (ast.type === \"UnaryExpression\") {\n    op = ast.operator;\n    const child = createRuntimeAst(expression, ast.argument);\n    if (unaryOperators.indexOf(op) > -1) {\n      node = new Node(ExpressionNodeType.UNARY, op, child);\n    } else {\n      throw new RuntimeError(`Unexpected operator \"${op}\".`);\n    }\n  } else if (ast.type === \"BinaryExpression\") {\n    op = ast.operator;\n    left = createRuntimeAst(expression, ast.left);\n    right = createRuntimeAst(expression, ast.right);\n    if (binaryOperators.indexOf(op) > -1) {\n      node = new Node(ExpressionNodeType.BINARY, op, left, right);\n    } else {\n      throw new RuntimeError(`Unexpected operator \"${op}\".`);\n    }\n  } else if (ast.type === \"LogicalExpression\") {\n    op = ast.operator;\n    left = createRuntimeAst(expression, ast.left);\n    right = createRuntimeAst(expression, ast.right);\n    if (binaryOperators.indexOf(op) > -1) {\n      node = new Node(ExpressionNodeType.BINARY, op, left, right);\n    }\n  } else if (ast.type === \"ConditionalExpression\") {\n    const test = createRuntimeAst(expression, ast.test);\n    left = createRuntimeAst(expression, ast.consequent);\n    right = createRuntimeAst(expression, ast.alternate);\n    node = new Node(ExpressionNodeType.CONDITIONAL, \"?\", left, right, test);\n  } else if (ast.type === \"MemberExpression\") {\n    node = parseMemberExpression(expression, ast);\n  } else if (ast.type === \"ArrayExpression\") {\n    const val = [];\n    for (let i = 0; i < ast.elements.length; i++) {\n      val[i] = createRuntimeAst(expression, ast.elements[i]);\n    }\n    node = new Node(ExpressionNodeType.ARRAY, val);\n  } else if (ast.type === \"Compound\") {\n    // empty expression or multiple expressions\n    throw new RuntimeError(\"Provide exactly one expression.\");\n  } else {\n    throw new RuntimeError(\"Cannot parse expression.\");\n  }\n\n  return node;\n}\n\nfunction setEvaluateFunction(node) {\n  if (node._type === ExpressionNodeType.CONDITIONAL) {\n    node.evaluate = node._evaluateConditional;\n  } else if (node._type === ExpressionNodeType.FUNCTION_CALL) {\n    if (node._value === \"test\") {\n      node.evaluate = node._evaluateRegExpTest;\n    } else if (node._value === \"exec\") {\n      node.evaluate = node._evaluateRegExpExec;\n    } else if (node._value === \"toString\") {\n      node.evaluate = node._evaluateToString;\n    }\n  } else if (node._type === ExpressionNodeType.UNARY) {\n    if (node._value === \"!\") {\n      node.evaluate = node._evaluateNot;\n    } else if (node._value === \"-\") {\n      node.evaluate = node._evaluateNegative;\n    } else if (node._value === \"+\") {\n      node.evaluate = node._evaluatePositive;\n    } else if (node._value === \"isNaN\") {\n      node.evaluate = node._evaluateNaN;\n    } else if (node._value === \"isFinite\") {\n      node.evaluate = node._evaluateIsFinite;\n    } else if (node._value === \"isExactClass\") {\n      node.evaluate = node._evaluateIsExactClass;\n    } else if (node._value === \"isClass\") {\n      node.evaluate = node._evaluateIsClass;\n    } else if (node._value === \"getExactClassName\") {\n      node.evaluate = node._evaluateGetExactClassName;\n    } else if (node._value === \"Boolean\") {\n      node.evaluate = node._evaluateBooleanConversion;\n    } else if (node._value === \"Number\") {\n      node.evaluate = node._evaluateNumberConversion;\n    } else if (node._value === \"String\") {\n      node.evaluate = node._evaluateStringConversion;\n    } else if (defined(unaryFunctions[node._value])) {\n      node.evaluate = getEvaluateUnaryFunction(node._value);\n    }\n  } else if (node._type === ExpressionNodeType.BINARY) {\n    if (node._value === \"+\") {\n      node.evaluate = node._evaluatePlus;\n    } else if (node._value === \"-\") {\n      node.evaluate = node._evaluateMinus;\n    } else if (node._value === \"*\") {\n      node.evaluate = node._evaluateTimes;\n    } else if (node._value === \"/\") {\n      node.evaluate = node._evaluateDivide;\n    } else if (node._value === \"%\") {\n      node.evaluate = node._evaluateMod;\n    } else if (node._value === \"===\") {\n      node.evaluate = node._evaluateEqualsStrict;\n    } else if (node._value === \"!==\") {\n      node.evaluate = node._evaluateNotEqualsStrict;\n    } else if (node._value === \"<\") {\n      node.evaluate = node._evaluateLessThan;\n    } else if (node._value === \"<=\") {\n      node.evaluate = node._evaluateLessThanOrEquals;\n    } else if (node._value === \">\") {\n      node.evaluate = node._evaluateGreaterThan;\n    } else if (node._value === \">=\") {\n      node.evaluate = node._evaluateGreaterThanOrEquals;\n    } else if (node._value === \"&&\") {\n      node.evaluate = node._evaluateAnd;\n    } else if (node._value === \"||\") {\n      node.evaluate = node._evaluateOr;\n    } else if (node._value === \"=~\") {\n      node.evaluate = node._evaluateRegExpMatch;\n    } else if (node._value === \"!~\") {\n      node.evaluate = node._evaluateRegExpNotMatch;\n    } else if (defined(binaryFunctions[node._value])) {\n      node.evaluate = getEvaluateBinaryFunction(node._value);\n    }\n  } else if (node._type === ExpressionNodeType.TERNARY) {\n    node.evaluate = getEvaluateTernaryFunction(node._value);\n  } else if (node._type === ExpressionNodeType.MEMBER) {\n    if (node._value === \"brackets\") {\n      node.evaluate = node._evaluateMemberBrackets;\n    } else {\n      node.evaluate = node._evaluateMemberDot;\n    }\n  } else if (node._type === ExpressionNodeType.ARRAY) {\n    node.evaluate = node._evaluateArray;\n  } else if (node._type === ExpressionNodeType.VARIABLE) {\n    node.evaluate = node._evaluateVariable;\n  } else if (node._type === ExpressionNodeType.VARIABLE_IN_STRING) {\n    node.evaluate = node._evaluateVariableString;\n  } else if (node._type === ExpressionNodeType.LITERAL_COLOR) {\n    node.evaluate = node._evaluateLiteralColor;\n  } else if (node._type === ExpressionNodeType.LITERAL_VECTOR) {\n    node.evaluate = node._evaluateLiteralVector;\n  } else if (node._type === ExpressionNodeType.LITERAL_STRING) {\n    node.evaluate = node._evaluateLiteralString;\n  } else if (node._type === ExpressionNodeType.REGEX) {\n    node.evaluate = node._evaluateRegExp;\n  } else if (node._type === ExpressionNodeType.BUILTIN_VARIABLE) {\n    if (node._value === \"tiles3d_tileset_time\") {\n      node.evaluate = evaluateTilesetTime;\n    }\n  } else {\n    node.evaluate = node._evaluateLiteral;\n  }\n}\n\nfunction evaluateTilesetTime(feature) {\n  if (!defined(feature)) {\n    return 0.0;\n  }\n  return feature.content.tileset.timeSinceLoad;\n}\n\nfunction getEvaluateUnaryFunction(call) {\n  const evaluate = unaryFunctions[call];\n  return function (feature) {\n    const left = this._left.evaluate(feature);\n    return evaluate(call, left);\n  };\n}\n\nfunction getEvaluateBinaryFunction(call) {\n  const evaluate = binaryFunctions[call];\n  return function (feature) {\n    const left = this._left.evaluate(feature);\n    const right = this._right.evaluate(feature);\n    return evaluate(call, left, right);\n  };\n}\n\nfunction getEvaluateTernaryFunction(call) {\n  const evaluate = ternaryFunctions[call];\n  return function (feature) {\n    const left = this._left.evaluate(feature);\n    const right = this._right.evaluate(feature);\n    const test = this._test.evaluate(feature);\n    return evaluate(call, left, right, test);\n  };\n}\n\nfunction getFeatureProperty(feature, name) {\n  // Returns undefined if the feature is not defined or the property name is not defined for that feature\n  if (defined(feature)) {\n    return feature.getPropertyInherited(name);\n  }\n}\n\nNode.prototype._evaluateLiteral = function () {\n  return this._value;\n};\n\nNode.prototype._evaluateLiteralColor = function (feature) {\n  const color = scratchColor;\n  const args = this._left;\n  if (this._value === \"color\") {\n    if (!defined(args)) {\n      Color.fromBytes(255, 255, 255, 255, color);\n    } else if (args.length > 1) {\n      Color.fromCssColorString(args[0].evaluate(feature), color);\n      color.alpha = args[1].evaluate(feature);\n    } else {\n      Color.fromCssColorString(args[0].evaluate(feature), color);\n    }\n  } else if (this._value === \"rgb\") {\n    Color.fromBytes(\n      args[0].evaluate(feature),\n      args[1].evaluate(feature),\n      args[2].evaluate(feature),\n      255,\n      color,\n    );\n  } else if (this._value === \"rgba\") {\n    // convert between css alpha (0 to 1) and cesium alpha (0 to 255)\n    const a = args[3].evaluate(feature) * 255;\n    Color.fromBytes(\n      args[0].evaluate(feature),\n      args[1].evaluate(feature),\n      args[2].evaluate(feature),\n      a,\n      color,\n    );\n  } else if (this._value === \"hsl\") {\n    Color.fromHsl(\n      args[0].evaluate(feature),\n      args[1].evaluate(feature),\n      args[2].evaluate(feature),\n      1.0,\n      color,\n    );\n  } else if (this._value === \"hsla\") {\n    Color.fromHsl(\n      args[0].evaluate(feature),\n      args[1].evaluate(feature),\n      args[2].evaluate(feature),\n      args[3].evaluate(feature),\n      color,\n    );\n  }\n  return Cartesian4.fromColor(color, scratchStorage.getCartesian4());\n};\n\nNode.prototype._evaluateLiteralVector = function (feature) {\n  // Gather the components that make up the vector, which includes components from interior vectors.\n  // For example vec3(1, 2, 3) or vec3(vec2(1, 2), 3) are both valid.\n  //\n  // If the number of components does not equal the vector's size, then a RuntimeError is thrown - with two exceptions:\n  // 1. A vector may be constructed from a larger vector and drop the extra components.\n  // 2. A vector may be constructed from a single component - vec3(1) will become vec3(1, 1, 1).\n  //\n  // Examples of invalid constructors include:\n  // vec4(1, 2)        // not enough components\n  // vec3(vec2(1, 2))  // not enough components\n  // vec3(1, 2, 3, 4)  // too many components\n  // vec2(vec4(1), 1)  // too many components\n\n  const components = scratchStorage.getArray();\n  const call = this._value;\n  const args = this._left;\n  const argsLength = args.length;\n  for (let i = 0; i < argsLength; ++i) {\n    const value = args[i].evaluate(feature);\n    if (typeof value === \"number\") {\n      components.push(value);\n    } else if (value instanceof Cartesian2) {\n      components.push(value.x, value.y);\n    } else if (value instanceof Cartesian3) {\n      components.push(value.x, value.y, value.z);\n    } else if (value instanceof Cartesian4) {\n      components.push(value.x, value.y, value.z, value.w);\n    } else {\n      throw new RuntimeError(\n        `${call} argument must be a vector or number. Argument is ${value}.`,\n      );\n    }\n  }\n\n  const componentsLength = components.length;\n  const vectorLength = parseInt(call.charAt(3));\n\n  if (componentsLength === 0) {\n    throw new RuntimeError(`Invalid ${call} constructor. No valid arguments.`);\n  } else if (componentsLength < vectorLength && componentsLength > 1) {\n    throw new RuntimeError(\n      `Invalid ${call} constructor. Not enough arguments.`,\n    );\n  } else if (componentsLength > vectorLength && argsLength > 1) {\n    throw new RuntimeError(`Invalid ${call} constructor. Too many arguments.`);\n  }\n\n  if (componentsLength === 1) {\n    // Add the same component 3 more times\n    const component = components[0];\n    components.push(component, component, component);\n  }\n\n  if (call === \"vec2\") {\n    return Cartesian2.fromArray(components, 0, scratchStorage.getCartesian2());\n  } else if (call === \"vec3\") {\n    return Cartesian3.fromArray(components, 0, scratchStorage.getCartesian3());\n  } else if (call === \"vec4\") {\n    return Cartesian4.fromArray(components, 0, scratchStorage.getCartesian4());\n  }\n};\n\nNode.prototype._evaluateLiteralString = function () {\n  return this._value;\n};\n\nNode.prototype._evaluateVariableString = function (feature) {\n  let result = this._value;\n  let match = variableRegex.exec(result);\n  while (match !== null) {\n    const placeholder = match[0];\n    const variableName = match[1];\n    let property = getFeatureProperty(feature, variableName);\n    if (!defined(property)) {\n      property = \"\";\n    }\n    result = result.replace(placeholder, property);\n    variableRegex.lastIndex += property.length - placeholder.length;\n    match = variableRegex.exec(result);\n  }\n  return result;\n};\n\nNode.prototype._evaluateVariable = function (feature) {\n  // evaluates to undefined if the property name is not defined for that feature\n  return getFeatureProperty(feature, this._value);\n};\n\nfunction checkFeature(ast) {\n  return ast._value === \"feature\";\n}\n\n// PERFORMANCE_IDEA: Determine if parent property needs to be computed before runtime\nNode.prototype._evaluateMemberDot = function (feature) {\n  if (checkFeature(this._left)) {\n    return getFeatureProperty(feature, this._right.evaluate(feature));\n  }\n  const property = this._left.evaluate(feature);\n  if (!defined(property)) {\n    return undefined;\n  }\n\n  const member = this._right.evaluate(feature);\n  if (\n    property instanceof Cartesian2 ||\n    property instanceof Cartesian3 ||\n    property instanceof Cartesian4\n  ) {\n    // Vector components may be accessed with .r, .g, .b, .a and implicitly with .x, .y, .z, .w\n    if (member === \"r\") {\n      return property.x;\n    } else if (member === \"g\") {\n      return property.y;\n    } else if (member === \"b\") {\n      return property.z;\n    } else if (member === \"a\") {\n      return property.w;\n    }\n  }\n  return property[member];\n};\n\nNode.prototype._evaluateMemberBrackets = function (feature) {\n  if (checkFeature(this._left)) {\n    return getFeatureProperty(feature, this._right.evaluate(feature));\n  }\n  const property = this._left.evaluate(feature);\n  if (!defined(property)) {\n    return undefined;\n  }\n\n  const member = this._right.evaluate(feature);\n  if (\n    property instanceof Cartesian2 ||\n    property instanceof Cartesian3 ||\n    property instanceof Cartesian4\n  ) {\n    // Vector components may be accessed with [0][1][2][3], ['r']['g']['b']['a'] and implicitly with ['x']['y']['z']['w']\n    // For Cartesian2 and Cartesian3 out-of-range components will just return undefined\n    if (member === 0 || member === \"r\") {\n      return property.x;\n    } else if (member === 1 || member === \"g\") {\n      return property.y;\n    } else if (member === 2 || member === \"b\") {\n      return property.z;\n    } else if (member === 3 || member === \"a\") {\n      return property.w;\n    }\n  }\n  return property[member];\n};\n\nNode.prototype._evaluateArray = function (feature) {\n  const array = [];\n  for (let i = 0; i < this._value.length; i++) {\n    array[i] = this._value[i].evaluate(feature);\n  }\n  return array;\n};\n\n// PERFORMANCE_IDEA: Have \"fast path\" functions that deal only with specific types\n// that we can assign if we know the types before runtime\n\nNode.prototype._evaluateNot = function (feature) {\n  const left = this._left.evaluate(feature);\n  if (typeof left !== \"boolean\") {\n    throw new RuntimeError(\n      `Operator \"!\" requires a boolean argument. Argument is ${left}.`,\n    );\n  }\n  return !left;\n};\n\nNode.prototype._evaluateNegative = function (feature) {\n  const left = this._left.evaluate(feature);\n  if (left instanceof Cartesian2) {\n    return Cartesian2.negate(left, scratchStorage.getCartesian2());\n  } else if (left instanceof Cartesian3) {\n    return Cartesian3.negate(left, scratchStorage.getCartesian3());\n  } else if (left instanceof Cartesian4) {\n    return Cartesian4.negate(left, scratchStorage.getCartesian4());\n  } else if (typeof left === \"number\") {\n    return -left;\n  }\n\n  throw new RuntimeError(\n    `Operator \"-\" requires a vector or number argument. Argument is ${left}.`,\n  );\n};\n\nNode.prototype._evaluatePositive = function (feature) {\n  const left = this._left.evaluate(feature);\n\n  if (\n    !(\n      left instanceof Cartesian2 ||\n      left instanceof Cartesian3 ||\n      left instanceof Cartesian4 ||\n      typeof left === \"number\"\n    )\n  ) {\n    throw new RuntimeError(\n      `Operator \"+\" requires a vector or number argument. Argument is ${left}.`,\n    );\n  }\n\n  return left;\n};\n\nNode.prototype._evaluateLessThan = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError(\n      `Operator \"<\" requires number arguments. Arguments are ${left} and ${right}.`,\n    );\n  }\n\n  return left < right;\n};\n\nNode.prototype._evaluateLessThanOrEquals = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError(\n      `Operator \"<=\" requires number arguments. Arguments are ${left} and ${right}.`,\n    );\n  }\n\n  return left <= right;\n};\n\nNode.prototype._evaluateGreaterThan = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError(\n      `Operator \">\" requires number arguments. Arguments are ${left} and ${right}.`,\n    );\n  }\n\n  return left > right;\n};\n\nNode.prototype._evaluateGreaterThanOrEquals = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError(\n      `Operator \">=\" requires number arguments. Arguments are ${left} and ${right}.`,\n    );\n  }\n\n  return left >= right;\n};\n\nNode.prototype._evaluateOr = function (feature) {\n  const left = this._left.evaluate(feature);\n  if (typeof left !== \"boolean\") {\n    throw new RuntimeError(\n      `Operator \"||\" requires boolean arguments. First argument is ${left}.`,\n    );\n  }\n\n  // short circuit the expression\n  if (left) {\n    return true;\n  }\n\n  const right = this._right.evaluate(feature);\n  if (typeof right !== \"boolean\") {\n    throw new RuntimeError(\n      `Operator \"||\" requires boolean arguments. Second argument is ${right}.`,\n    );\n  }\n\n  return left || right;\n};\n\nNode.prototype._evaluateAnd = function (feature) {\n  const left = this._left.evaluate(feature);\n  if (typeof left !== \"boolean\") {\n    throw new RuntimeError(\n      `Operator \"&&\" requires boolean arguments. First argument is ${left}.`,\n    );\n  }\n\n  // short circuit the expression\n  if (!left) {\n    return false;\n  }\n\n  const right = this._right.evaluate(feature);\n  if (typeof right !== \"boolean\") {\n    throw new RuntimeError(\n      `Operator \"&&\" requires boolean arguments. Second argument is ${right}.`,\n    );\n  }\n\n  return left && right;\n};\n\nNode.prototype._evaluatePlus = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.add(left, right, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.add(left, right, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.add(left, right, scratchStorage.getCartesian4());\n  } else if (typeof left === \"string\" || typeof right === \"string\") {\n    // If only one argument is a string the other argument calls its toString function.\n    return left + right;\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left + right;\n  }\n\n  throw new RuntimeError(\n    `Operator \"+\" requires vector or number arguments of matching types, or at least one string argument. Arguments are ${left} and ${right}.`,\n  );\n};\n\nNode.prototype._evaluateMinus = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.subtract(left, right, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.subtract(left, right, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.subtract(left, right, scratchStorage.getCartesian4());\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left - right;\n  }\n\n  throw new RuntimeError(\n    `Operator \"-\" requires vector or number arguments of matching types. Arguments are ${left} and ${right}.`,\n  );\n};\n\nNode.prototype._evaluateTimes = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.multiplyComponents(\n      left,\n      right,\n      scratchStorage.getCartesian2(),\n    );\n  } else if (right instanceof Cartesian2 && typeof left === \"number\") {\n    return Cartesian2.multiplyByScalar(\n      right,\n      left,\n      scratchStorage.getCartesian2(),\n    );\n  } else if (left instanceof Cartesian2 && typeof right === \"number\") {\n    return Cartesian2.multiplyByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian2(),\n    );\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.multiplyComponents(\n      left,\n      right,\n      scratchStorage.getCartesian3(),\n    );\n  } else if (right instanceof Cartesian3 && typeof left === \"number\") {\n    return Cartesian3.multiplyByScalar(\n      right,\n      left,\n      scratchStorage.getCartesian3(),\n    );\n  } else if (left instanceof Cartesian3 && typeof right === \"number\") {\n    return Cartesian3.multiplyByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian3(),\n    );\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.multiplyComponents(\n      left,\n      right,\n      scratchStorage.getCartesian4(),\n    );\n  } else if (right instanceof Cartesian4 && typeof left === \"number\") {\n    return Cartesian4.multiplyByScalar(\n      right,\n      left,\n      scratchStorage.getCartesian4(),\n    );\n  } else if (left instanceof Cartesian4 && typeof right === \"number\") {\n    return Cartesian4.multiplyByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian4(),\n    );\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left * right;\n  }\n\n  throw new RuntimeError(\n    `Operator \"*\" requires vector or number arguments. If both arguments are vectors they must be matching types. Arguments are ${left} and ${right}.`,\n  );\n};\n\nNode.prototype._evaluateDivide = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.divideComponents(\n      left,\n      right,\n      scratchStorage.getCartesian2(),\n    );\n  } else if (left instanceof Cartesian2 && typeof right === \"number\") {\n    return Cartesian2.divideByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian2(),\n    );\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.divideComponents(\n      left,\n      right,\n      scratchStorage.getCartesian3(),\n    );\n  } else if (left instanceof Cartesian3 && typeof right === \"number\") {\n    return Cartesian3.divideByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian3(),\n    );\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.divideComponents(\n      left,\n      right,\n      scratchStorage.getCartesian4(),\n    );\n  } else if (left instanceof Cartesian4 && typeof right === \"number\") {\n    return Cartesian4.divideByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian4(),\n    );\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left / right;\n  }\n\n  throw new RuntimeError(\n    `Operator \"/\" requires vector or number arguments of matching types, or a number as the second argument. Arguments are ${left} and ${right}.`,\n  );\n};\n\nNode.prototype._evaluateMod = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.fromElements(\n      left.x % right.x,\n      left.y % right.y,\n      scratchStorage.getCartesian2(),\n    );\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.fromElements(\n      left.x % right.x,\n      left.y % right.y,\n      left.z % right.z,\n      scratchStorage.getCartesian3(),\n    );\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.fromElements(\n      left.x % right.x,\n      left.y % right.y,\n      left.z % right.z,\n      left.w % right.w,\n      scratchStorage.getCartesian4(),\n    );\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left % right;\n  }\n\n  throw new RuntimeError(\n    `Operator \"%\" requires vector or number arguments of matching types. Arguments are ${left} and ${right}.`,\n  );\n};\n\nNode.prototype._evaluateEqualsStrict = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (\n    (right instanceof Cartesian2 && left instanceof Cartesian2) ||\n    (right instanceof Cartesian3 && left instanceof Cartesian3) ||\n    (right instanceof Cartesian4 && left instanceof Cartesian4)\n  ) {\n    return left.equals(right);\n  }\n  return left === right;\n};\n\nNode.prototype._evaluateNotEqualsStrict = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (\n    (right instanceof Cartesian2 && left instanceof Cartesian2) ||\n    (right instanceof Cartesian3 && left instanceof Cartesian3) ||\n    (right instanceof Cartesian4 && left instanceof Cartesian4)\n  ) {\n    return !left.equals(right);\n  }\n  return left !== right;\n};\n\nNode.prototype._evaluateConditional = function (feature) {\n  const test = this._test.evaluate(feature);\n\n  if (typeof test !== \"boolean\") {\n    throw new RuntimeError(\n      `Conditional argument of conditional expression must be a boolean. Argument is ${test}.`,\n    );\n  }\n\n  if (test) {\n    return this._left.evaluate(feature);\n  }\n  return this._right.evaluate(feature);\n};\n\nNode.prototype._evaluateNaN = function (feature) {\n  return isNaN(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateIsFinite = function (feature) {\n  return isFinite(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateIsExactClass = function (feature) {\n  if (defined(feature)) {\n    return feature.isExactClass(this._left.evaluate(feature));\n  }\n  return false;\n};\n\nNode.prototype._evaluateIsClass = function (feature) {\n  if (defined(feature)) {\n    return feature.isClass(this._left.evaluate(feature));\n  }\n  return false;\n};\n\nNode.prototype._evaluateGetExactClassName = function (feature) {\n  if (defined(feature)) {\n    return feature.getExactClassName();\n  }\n};\n\nNode.prototype._evaluateBooleanConversion = function (feature) {\n  return Boolean(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateNumberConversion = function (feature) {\n  return Number(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateStringConversion = function (feature) {\n  return String(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateRegExp = function (feature) {\n  const pattern = this._value.evaluate(feature);\n  let flags = \"\";\n\n  if (defined(this._left)) {\n    flags = this._left.evaluate(feature);\n  }\n\n  let exp;\n  try {\n    exp = new RegExp(pattern, flags);\n  } catch (e) {\n    throw new RuntimeError(e);\n  }\n  return exp;\n};\n\nNode.prototype._evaluateRegExpTest = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n\n  if (!(left instanceof RegExp && typeof right === \"string\")) {\n    throw new RuntimeError(\n      `RegExp.test requires the first argument to be a RegExp and the second argument to be a string. Arguments are ${left} and ${right}.`,\n    );\n  }\n\n  return left.test(right);\n};\n\nNode.prototype._evaluateRegExpMatch = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n\n  if (left instanceof RegExp && typeof right === \"string\") {\n    return left.test(right);\n  } else if (right instanceof RegExp && typeof left === \"string\") {\n    return right.test(left);\n  }\n\n  throw new RuntimeError(\n    `Operator \"=~\" requires one RegExp argument and one string argument. Arguments are ${left} and ${right}.`,\n  );\n};\n\nNode.prototype._evaluateRegExpNotMatch = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n\n  if (left instanceof RegExp && typeof right === \"string\") {\n    return !left.test(right);\n  } else if (right instanceof RegExp && typeof left === \"string\") {\n    return !right.test(left);\n  }\n\n  throw new RuntimeError(\n    `Operator \"!~\" requires one RegExp argument and one string argument. Arguments are ${left} and ${right}.`,\n  );\n};\n\nNode.prototype._evaluateRegExpExec = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n\n  if (!(left instanceof RegExp && typeof right === \"string\")) {\n    throw new RuntimeError(\n      `RegExp.exec requires the first argument to be a RegExp and the second argument to be a string. Arguments are ${left} and ${right}.`,\n    );\n  }\n\n  const exec = left.exec(right);\n  if (!defined(exec)) {\n    return null;\n  }\n  return exec[1];\n};\n\nNode.prototype._evaluateToString = function (feature) {\n  const left = this._left.evaluate(feature);\n  if (\n    left instanceof RegExp ||\n    left instanceof Cartesian2 ||\n    left instanceof Cartesian3 ||\n    left instanceof Cartesian4\n  ) {\n    return String(left);\n  }\n\n  throw new RuntimeError(`Unexpected function call \"${this._value}\".`);\n};\n\nfunction convertHSLToRGB(ast) {\n  // Check if the color contains any nested expressions to see if the color can be converted here.\n  // E.g. \"hsl(0.9, 0.6, 0.7)\" is able to convert directly to rgb, \"hsl(0.9, 0.6, ${Height})\" is not.\n  const channels = ast._left;\n  const length = channels.length;\n  for (let i = 0; i < length; ++i) {\n    if (channels[i]._type !== ExpressionNodeType.LITERAL_NUMBER) {\n      return undefined;\n    }\n  }\n  const h = channels[0]._value;\n  const s = channels[1]._value;\n  const l = channels[2]._value;\n  const a = length === 4 ? channels[3]._value : 1.0;\n  return Color.fromHsl(h, s, l, a, scratchColor);\n}\n\nfunction convertRGBToColor(ast) {\n  // Check if the color contains any nested expressions to see if the color can be converted here.\n  // E.g. \"rgb(255, 255, 255)\" is able to convert directly to Color, \"rgb(255, 255, ${Height})\" is not.\n  const channels = ast._left;\n  const length = channels.length;\n  for (let i = 0; i < length; ++i) {\n    if (channels[i]._type !== ExpressionNodeType.LITERAL_NUMBER) {\n      return undefined;\n    }\n  }\n  const color = scratchColor;\n  color.red = channels[0]._value / 255.0;\n  color.green = channels[1]._value / 255.0;\n  color.blue = channels[2]._value / 255.0;\n  color.alpha = length === 4 ? channels[3]._value : 1.0;\n  return color;\n}\n\nfunction numberToString(number) {\n  if (number % 1 === 0) {\n    // Add a .0 to whole numbers\n    return number.toFixed(1);\n  }\n\n  return number.toString();\n}\n\nfunction colorToVec3(color) {\n  const r = numberToString(color.red);\n  const g = numberToString(color.green);\n  const b = numberToString(color.blue);\n  return `vec3(${r}, ${g}, ${b})`;\n}\n\nfunction colorToVec4(color) {\n  const r = numberToString(color.red);\n  const g = numberToString(color.green);\n  const b = numberToString(color.blue);\n  const a = numberToString(color.alpha);\n  return `vec4(${r}, ${g}, ${b}, ${a})`;\n}\n\nfunction getExpressionArray(\n  array,\n  variableSubstitutionMap,\n  shaderState,\n  parent,\n) {\n  const length = array.length;\n  const expressions = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    expressions[i] = array[i].getShaderExpression(\n      variableSubstitutionMap,\n      shaderState,\n      parent,\n    );\n  }\n  return expressions;\n}\n\nfunction getVariableName(variableName, variableSubstitutionMap) {\n  if (!defined(variableSubstitutionMap[variableName])) {\n    return Expression.NULL_SENTINEL;\n  }\n\n  return variableSubstitutionMap[variableName];\n}\n\n/**\n * @private\n */\nExpression.NULL_SENTINEL = \"czm_infinity\"; // null just needs to be some sentinel value that will cause \"[expression] === null\" to be false in nearly all cases. GLSL doesn't have a NaN constant so use czm_infinity.\n\nNode.prototype.getShaderExpression = function (\n  variableSubstitutionMap,\n  shaderState,\n  parent,\n) {\n  let color;\n  let left;\n  let right;\n  let test;\n\n  const type = this._type;\n  let value = this._value;\n\n  if (defined(this._left)) {\n    if (Array.isArray(this._left)) {\n      // Left can be an array if the type is LITERAL_COLOR or LITERAL_VECTOR\n      left = getExpressionArray(\n        this._left,\n        variableSubstitutionMap,\n        shaderState,\n        this,\n      );\n    } else {\n      left = this._left.getShaderExpression(\n        variableSubstitutionMap,\n        shaderState,\n        this,\n      );\n    }\n  }\n\n  if (defined(this._right)) {\n    right = this._right.getShaderExpression(\n      variableSubstitutionMap,\n      shaderState,\n      this,\n    );\n  }\n\n  if (defined(this._test)) {\n    test = this._test.getShaderExpression(\n      variableSubstitutionMap,\n      shaderState,\n      this,\n    );\n  }\n\n  if (Array.isArray(this._value)) {\n    // For ARRAY type\n    value = getExpressionArray(\n      this._value,\n      variableSubstitutionMap,\n      shaderState,\n      this,\n    );\n  }\n\n  let args;\n  let length;\n  let vectorExpression;\n  switch (type) {\n    case ExpressionNodeType.VARIABLE:\n      if (checkFeature(this)) {\n        return undefined;\n      }\n      return getVariableName(value, variableSubstitutionMap);\n    case ExpressionNodeType.UNARY:\n      // Supported types: +, -, !, Boolean, Number\n      if (value === \"Boolean\") {\n        return `bool(${left})`;\n      } else if (value === \"Number\") {\n        return `float(${left})`;\n      } else if (value === \"round\") {\n        return `floor(${left} + 0.5)`;\n      } else if (defined(unaryFunctions[value])) {\n        return `${value}(${left})`;\n      } else if (value === \"isNaN\") {\n        // In GLSL 2.0 use isnan instead\n        return `(${left} != ${left})`;\n      } else if (value === \"isFinite\") {\n        // In GLSL 2.0 use isinf instead. GLSL doesn't have an infinity constant so use czm_infinity which is an arbitrarily big enough number.\n        return `(abs(${left}) < czm_infinity)`;\n      } else if (\n        value === \"String\" ||\n        value === \"isExactClass\" ||\n        value === \"isClass\" ||\n        value === \"getExactClassName\"\n      ) {\n        throw new RuntimeError(\n          `Error generating style shader: \"${value}\" is not supported.`,\n        );\n      }\n      return value + left;\n    case ExpressionNodeType.BINARY:\n      // Supported types: ||, &&, ===, !==, <, >, <=, >=, +, -, *, /, %\n      if (value === \"%\") {\n        return `mod(${left}, ${right})`;\n      } else if (value === \"===\") {\n        return `(${left} == ${right})`;\n      } else if (value === \"!==\") {\n        return `(${left} != ${right})`;\n      } else if (value === \"atan2\") {\n        return `atan(${left}, ${right})`;\n      } else if (defined(binaryFunctions[value])) {\n        return `${value}(${left}, ${right})`;\n      }\n      return `(${left} ${value} ${right})`;\n    case ExpressionNodeType.TERNARY:\n      if (defined(ternaryFunctions[value])) {\n        return `${value}(${left}, ${right}, ${test})`;\n      }\n      break;\n    case ExpressionNodeType.CONDITIONAL:\n      return `(${test} ? ${left} : ${right})`;\n    case ExpressionNodeType.MEMBER:\n      if (checkFeature(this._left)) {\n        return getVariableName(right, variableSubstitutionMap);\n      }\n      // This is intended for accessing the components of vector properties. String members aren't supported.\n      // Check for 0.0 rather than 0 because all numbers are previously converted to decimals.\n      if (right === \"r\" || right === \"x\" || right === \"0.0\") {\n        return `${left}[0]`;\n      } else if (right === \"g\" || right === \"y\" || right === \"1.0\") {\n        return `${left}[1]`;\n      } else if (right === \"b\" || right === \"z\" || right === \"2.0\") {\n        return `${left}[2]`;\n      } else if (right === \"a\" || right === \"w\" || right === \"3.0\") {\n        return `${left}[3]`;\n      }\n      return `${left}[int(${right})]`;\n    case ExpressionNodeType.FUNCTION_CALL:\n      throw new RuntimeError(\n        `Error generating style shader: \"${value}\" is not supported.`,\n      );\n    case ExpressionNodeType.ARRAY:\n      if (value.length === 4) {\n        return `vec4(${value[0]}, ${value[1]}, ${value[2]}, ${value[3]})`;\n      } else if (value.length === 3) {\n        return `vec3(${value[0]}, ${value[1]}, ${value[2]})`;\n      } else if (value.length === 2) {\n        return `vec2(${value[0]}, ${value[1]})`;\n      }\n      throw new RuntimeError(\n        \"Error generating style shader: Invalid array length. Array length should be 2, 3, or 4.\",\n      );\n    case ExpressionNodeType.REGEX:\n      throw new RuntimeError(\n        \"Error generating style shader: Regular expressions are not supported.\",\n      );\n    case ExpressionNodeType.VARIABLE_IN_STRING:\n      throw new RuntimeError(\n        \"Error generating style shader: Converting a variable to a string is not supported.\",\n      );\n    case ExpressionNodeType.LITERAL_NULL:\n      return Expression.NULL_SENTINEL;\n    case ExpressionNodeType.LITERAL_BOOLEAN:\n      return value ? \"true\" : \"false\";\n    case ExpressionNodeType.LITERAL_NUMBER:\n      return numberToString(value);\n    case ExpressionNodeType.LITERAL_STRING:\n      if (defined(parent) && parent._type === ExpressionNodeType.MEMBER) {\n        if (\n          value === \"r\" ||\n          value === \"g\" ||\n          value === \"b\" ||\n          value === \"a\" ||\n          value === \"x\" ||\n          value === \"y\" ||\n          value === \"z\" ||\n          value === \"w\" ||\n          checkFeature(parent._left)\n        ) {\n          return value;\n        }\n      }\n      // Check for css color strings\n      color = Color.fromCssColorString(value, scratchColor);\n      if (defined(color)) {\n        return colorToVec3(color);\n      }\n      throw new RuntimeError(\n        \"Error generating style shader: String literals are not supported.\",\n      );\n    case ExpressionNodeType.LITERAL_COLOR:\n      args = left;\n      if (value === \"color\") {\n        if (!defined(args)) {\n          return \"vec4(1.0)\";\n        } else if (args.length > 1) {\n          const rgb = args[0];\n          const alpha = args[1];\n          if (alpha !== \"1.0\") {\n            shaderState.translucent = true;\n          }\n          return `vec4(${rgb}, ${alpha})`;\n        }\n        return `vec4(${args[0]}, 1.0)`;\n      } else if (value === \"rgb\") {\n        color = convertRGBToColor(this);\n        if (defined(color)) {\n          return colorToVec4(color);\n        }\n        return `vec4(${args[0]} / 255.0, ${args[1]} / 255.0, ${args[2]} / 255.0, 1.0)`;\n      } else if (value === \"rgba\") {\n        if (args[3] !== \"1.0\") {\n          shaderState.translucent = true;\n        }\n        color = convertRGBToColor(this);\n        if (defined(color)) {\n          return colorToVec4(color);\n        }\n        return `vec4(${args[0]} / 255.0, ${args[1]} / 255.0, ${args[2]} / 255.0, ${args[3]})`;\n      } else if (value === \"hsl\") {\n        color = convertHSLToRGB(this);\n        if (defined(color)) {\n          return colorToVec4(color);\n        }\n        return `vec4(czm_HSLToRGB(vec3(${args[0]}, ${args[1]}, ${args[2]})), 1.0)`;\n      } else if (value === \"hsla\") {\n        color = convertHSLToRGB(this);\n        if (defined(color)) {\n          if (color.alpha !== 1.0) {\n            shaderState.translucent = true;\n          }\n          return colorToVec4(color);\n        }\n        if (args[3] !== \"1.0\") {\n          shaderState.translucent = true;\n        }\n        return `vec4(czm_HSLToRGB(vec3(${args[0]}, ${args[1]}, ${args[2]})), ${args[3]})`;\n      }\n      break;\n    case ExpressionNodeType.LITERAL_VECTOR:\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(left)) {\n        throw new DeveloperError(\n          \"left should always be defined for type ExpressionNodeType.LITERAL_VECTOR\",\n        );\n      }\n      //>>includeEnd('debug');\n      length = left.length;\n      vectorExpression = `${value}(`;\n      for (let i = 0; i < length; ++i) {\n        vectorExpression += left[i];\n        if (i < length - 1) {\n          vectorExpression += \", \";\n        }\n      }\n      vectorExpression += \")\";\n      return vectorExpression;\n    case ExpressionNodeType.LITERAL_REGEX:\n      throw new RuntimeError(\n        \"Error generating style shader: Regular expressions are not supported.\",\n      );\n    case ExpressionNodeType.LITERAL_UNDEFINED:\n      return Expression.NULL_SENTINEL;\n    case ExpressionNodeType.BUILTIN_VARIABLE:\n      if (value === \"tiles3d_tileset_time\") {\n        return value;\n      }\n  }\n};\n\nNode.prototype.getVariables = function (variables, parent) {\n  let array;\n  let length;\n  let i;\n\n  const type = this._type;\n  const value = this._value;\n\n  if (defined(this._left)) {\n    if (Array.isArray(this._left)) {\n      // Left can be an array if the type is LITERAL_COLOR or LITERAL_VECTOR\n      array = this._left;\n      length = array.length;\n      for (i = 0; i < length; ++i) {\n        array[i].getVariables(variables, this);\n      }\n    } else {\n      this._left.getVariables(variables, this);\n    }\n  }\n\n  if (defined(this._right)) {\n    this._right.getVariables(variables, this);\n  }\n\n  if (defined(this._test)) {\n    this._test.getVariables(variables, this);\n  }\n\n  if (Array.isArray(this._value)) {\n    // For ARRAY type\n    array = this._value;\n    length = array.length;\n    for (i = 0; i < length; ++i) {\n      array[i].getVariables(variables, this);\n    }\n  }\n\n  let match;\n  switch (type) {\n    case ExpressionNodeType.VARIABLE:\n      if (!checkFeature(this)) {\n        variables.push(value);\n      }\n      break;\n    case ExpressionNodeType.VARIABLE_IN_STRING:\n      match = variableRegex.exec(value);\n      while (match !== null) {\n        variables.push(match[1]);\n        match = variableRegex.exec(value);\n      }\n      break;\n    case ExpressionNodeType.LITERAL_STRING:\n      if (\n        defined(parent) &&\n        parent._type === ExpressionNodeType.MEMBER &&\n        checkFeature(parent._left)\n      ) {\n        variables.push(value);\n      }\n      break;\n  }\n};\n\nexport default Expression;\n"],"names":["Expression","expression","defines","typeOf","string","_expression","replaceDefines","replaceVariables","removeBackslashes","addBinaryOp","ast","e","_runtimeAst","createRuntimeAst","Object","defineProperties","prototype","get","scratchStorage","arrayIndex","arrayArray","cartesian2Index","cartesian3Index","cartesian4Index","cartesian2Array","cartesian3Array","cartesian4Array","reset","getArray","length","push","array","getCartesian2","getCartesian3","getCartesian4","evaluate","feature","result","value","fromCartesian4","clone","evaluateColor","color","getShaderFunction","functionSignature","variableSubstitutionMap","shaderState","returnType","shaderExpression","getShaderExpression","getVariables","variables","filter","variable","index","indexOf","unaryOperators","binaryOperators","variableRegex","backslashRegex","backslashReplacement","replacementRegex","scratchColor","unaryFunctions","abs","getEvaluateUnaryComponentwise","Math","sqrt","cos","sin","tan","acos","asin","atan","radians","toRadians","degrees","toDegrees","sign","floor","ceil","round","exp","exp2","log","log2","fract","normalize","binaryFunctions","atan2","getEvaluateBinaryComponentwise","pow","min","max","distance","dot","cross","ternaryFunctions","clamp","getEvaluateTernaryComponentwise","mix","lerp","number","exponent","operation","call","left","fromElements","x","y","z","w","allowScalar","right","test","magnitude","Node","type","_type","_value","_left","_right","_test","undefined","setEvaluateFunction","key","hasOwnProperty","definePlaceholder","RegExp","defineReplace","replace","replaceBackslashes","i","openSingleQuote","openDoubleQuote","closeQuote","substr","j","parseLiteral","LITERAL_NULL","LITERAL_BOOLEAN","LITERAL_NUMBER","VARIABLE_IN_STRING","LITERAL_STRING","parseCall","args","arguments","argsLength","val","callee","property","name","object","FUNCTION_CALL","LITERAL_COLOR","alpha","Array","LITERAL_VECTOR","UNARY","BINARY","TERNARY","parseRegex","LITERAL_REGEX","pattern","flags","isLiteralType","String","REGEX","parseKeywordsAndVariables","isVariable","getPropertyName","BUILTIN_VARIABLE","VARIABLE","NaN","Infinity","LITERAL_UNDEFINED","parseMathConstant","PI","E","parseNumberConstant","Number","POSITIVE_INFINITY","parseMemberExpression","obj","computed","MEMBER","node","op","operator","child","argument","consequent","alternate","CONDITIONAL","elements","ARRAY","_evaluateConditional","_evaluateRegExpTest","_evaluateRegExpExec","_evaluateToString","_evaluateNot","_evaluateNegative","_evaluatePositive","_evaluateNaN","_evaluateIsFinite","_evaluateIsExactClass","_evaluateIsClass","_evaluateGetExactClassName","_evaluateBooleanConversion","_evaluateNumberConversion","_evaluateStringConversion","getEvaluateUnaryFunction","_evaluatePlus","_evaluateMinus","_evaluateTimes","_evaluateDivide","_evaluateMod","_evaluateEqualsStrict","_evaluateNotEqualsStrict","_evaluateLessThan","_evaluateLessThanOrEquals","_evaluateGreaterThan","_evaluateGreaterThanOrEquals","_evaluateAnd","_evaluateOr","_evaluateRegExpMatch","_evaluateRegExpNotMatch","getEvaluateBinaryFunction","getEvaluateTernaryFunction","_evaluateMemberBrackets","_evaluateMemberDot","_evaluateArray","_evaluateVariable","_evaluateVariableString","_evaluateLiteralColor","_evaluateLiteralVector","_evaluateLiteralString","_evaluateRegExp","evaluateTilesetTime","_evaluateLiteral","content","tileset","timeSinceLoad","getFeatureProperty","getPropertyInherited","fromBytes","fromCssColorString","a","fromHsl","fromColor","components","componentsLength","vectorLength","parseInt","charAt","component","fromArray","match","exec","placeholder","variableName","lastIndex","checkFeature","member","negate","add","subtract","multiplyComponents","multiplyByScalar","divideComponents","divideByScalar","equals","isNaN","isFinite","isExactClass","isClass","getExactClassName","Boolean","convertHSLToRGB","channels","h","s","l","convertRGBToColor","red","green","blue","numberToString","toFixed","toString","colorToVec3","r","g","b","colorToVec4","getExpressionArray","parent","expressions","getVariableName","NULL_SENTINEL","isArray","vectorExpression","rgb","translucent"],"mappings":"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","ignoreList":[0]}}]
}