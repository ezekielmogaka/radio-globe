(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@cesium/engine/Source/Scene/Camera.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoundingSphere$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/BoundingSphere.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartesian2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartesian3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartesian4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartographic.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$EasingFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/EasingFunction.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Ellipsoid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Ellipsoid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$EllipsoidGeodesic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/EllipsoidGeodesic.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Event.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$getTimestamp$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/getTimestamp.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$HeadingPitchRange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/HeadingPitchRange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$HeadingPitchRoll$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/HeadingPitchRoll.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Intersect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Intersect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$IntersectionTests$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/IntersectionTests.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Matrix3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Matrix4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$OrthographicFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/OrthographicFrustum.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$OrthographicOffCenterFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/OrthographicOffCenterFrustum.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PerspectiveFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/PerspectiveFrustum.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Quaternion.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Ray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Ray.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Rectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Transforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Transforms.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$CameraFlightPath$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Scene/CameraFlightPath.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$MapMode2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Scene/MapMode2D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Scene/SceneMode.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @typedef {object} DirectionUp
 *
 * An orientation given by a pair of unit vectors
 *
 * @property {Cartesian3} direction The unit "direction" vector
 * @property {Cartesian3} up The unit "up" vector
 **/ /**
 * @typedef {object} HeadingPitchRollValues
 *
 * An orientation given by numeric heading, pitch, and roll
 *
 * @property {number} [heading=0.0] The heading in radians
 * @property {number} [pitch=-CesiumMath.PI_OVER_TWO] The pitch in radians
 * @property {number} [roll=0.0] The roll in radians
 **/ /**
 * The camera is defined by a position, orientation, and view frustum.
 * <br /><br />
 * The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.
 * <br /><br />
 * The viewing frustum is defined by 6 planes.
 * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
 * define the unit vector normal to the plane, and the w component is the distance of the
 * plane from the origin/camera position.
 *
 * @alias Camera
 *
 * @constructor
 *
 * @param {Scene} scene The scene.
 *
 * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera.html|Cesium Sandcastle Camera Demo}
 * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera%20Tutorial.html|Cesium Sandcastle Camera Tutorial Example}
 * @demo {@link https://cesium.com/learn/cesiumjs-learn/cesiumjs-camera|Camera Tutorial}
 *
 * @example
 * // Create a camera looking down the negative z-axis, positioned at the origin,
 * // with a field of view of 60 degrees, and 1:1 aspect ratio.
 * const camera = new Cesium.Camera(scene);
 * camera.position = new Cesium.Cartesian3();
 * camera.direction = Cesium.Cartesian3.negate(Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());
 * camera.up = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Y);
 * camera.frustum.fov = Cesium.Math.PI_OVER_THREE;
 * camera.frustum.near = 1.0;
 * camera.frustum.far = 2.0;
 */ function Camera(scene) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(scene)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("scene is required.");
    }
    //>>includeEnd('debug');
    this._scene = scene;
    this._transform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY);
    this._invTransform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY);
    this._actualTransform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY);
    this._actualInvTransform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY);
    this._transformChanged = false;
    /**
   * The position of the camera.
   *
   * @type {Cartesian3}
   */ this.position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._positionWC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._positionCartographic = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._oldPositionWC = undefined;
    /**
   * The position delta magnitude.
   *
   * @private
   */ this.positionWCDeltaMagnitude = 0.0;
    /**
   * The position delta magnitude last frame.
   *
   * @private
   */ this.positionWCDeltaMagnitudeLastFrame = 0.0;
    /**
   * How long in seconds since the camera has stopped moving
   *
   * @private
   */ this.timeSinceMoved = 0.0;
    this._lastMovedTimestamp = 0.0;
    /**
   * The view direction of the camera.
   *
   * @type {Cartesian3}
   */ this.direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._directionWC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    /**
   * The up direction of the camera.
   *
   * @type {Cartesian3}
   */ this.up = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._up = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._upWC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    /**
   * The right direction of the camera.
   *
   * @type {Cartesian3}
   */ this.right = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._right = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._rightWC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    /**
   * The region of space in view.
   *
   * @type {PerspectiveFrustum|PerspectiveOffCenterFrustum|OrthographicFrustum}
   * @default PerspectiveFrustum()
   *
   * @see PerspectiveFrustum
   * @see PerspectiveOffCenterFrustum
   * @see OrthographicFrustum
   */ this.frustum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PerspectiveFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this.frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;
    this.frustum.fov = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toRadians(60.0);
    /**
   * The default amount to move the camera when an argument is not
   * provided to the move methods.
   * @type {number}
   * @default 100000.0;
   */ this.defaultMoveAmount = 100000.0;
    /**
   * The default amount to rotate the camera when an argument is not
   * provided to the look methods.
   * @type {number}
   * @default Math.PI / 60.0
   */ this.defaultLookAmount = Math.PI / 60.0;
    /**
   * The default amount to rotate the camera when an argument is not
   * provided to the rotate methods.
   * @type {number}
   * @default Math.PI / 3600.0
   */ this.defaultRotateAmount = Math.PI / 3600.0;
    /**
   * The default amount to move the camera when an argument is not
   * provided to the zoom methods.
   * @type {number}
   * @default 100000.0;
   */ this.defaultZoomAmount = 100000.0;
    /**
   * If set, the camera will not be able to rotate past this axis in either direction.
   * @type {Cartesian3 | undefined}
   * @default undefined
   */ this.constrainedAxis = undefined;
    /**
   * The factor multiplied by the the map size used to determine where to clamp the camera position
   * when zooming out from the surface. The default is 1.5. Only valid for 2D and the map is rotatable.
   * @type {number}
   * @default 1.5
   */ this.maximumZoomFactor = 1.5;
    this._moveStart = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._moveEnd = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._changed = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Event$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._changedPosition = undefined;
    this._changedDirection = undefined;
    this._changedFrustum = undefined;
    this._changedHeading = undefined;
    this._changedRoll = undefined;
    /**
   * The amount the camera has to change before the <code>changed</code> event is raised. The value is a percentage in the [0, 1] range.
   * @type {number}
   * @default 0.5
   */ this.percentageChanged = 0.5;
    this._viewMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._invViewMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    updateViewMatrix(this);
    this._mode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE3D;
    this._modeChanged = true;
    const projection = scene.mapProjection;
    this._projection = projection;
    this._maxCoord = projection.project(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](Math.PI, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO));
    this._max2Dfrustum = undefined;
    // set default view
    rectangleCameraPosition3D(this, Camera.DEFAULT_VIEW_RECTANGLE, this.position, true);
    let mag = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].magnitude(this.position);
    mag += mag * Camera.DEFAULT_VIEW_FACTOR;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(this.position, this.position);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(this.position, mag, this.position);
}
/**
 * @private
 */ Camera.TRANSFORM_2D = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0);
/**
 * @private
 */ Camera.TRANSFORM_2D_INVERSE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].inverseTransformation(Camera.TRANSFORM_2D, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]());
/**
 * The default rectangle the camera will view on creation.
 * @type Rectangle
 */ Camera.DEFAULT_VIEW_RECTANGLE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromDegrees(-95.0, -20.0, -70.0, 90.0);
/**
 * A scalar to multiply to the camera position and add it back after setting the camera to view the rectangle.
 * A value of zero means the camera will view the entire {@link Camera#DEFAULT_VIEW_RECTANGLE}, a value greater than zero
 * will move it further away from the extent, and a value less than zero will move it close to the extent.
 * @type {number}
 */ Camera.DEFAULT_VIEW_FACTOR = 0.5;
/**
 * The default heading/pitch/range that is used when the camera flies to a location that contains a bounding sphere.
 * @type HeadingPitchRange
 */ Camera.DEFAULT_OFFSET = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$HeadingPitchRange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0.0, -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_FOUR, 0.0);
function updateViewMatrix(camera) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].computeView(camera._position, camera._direction, camera._up, camera._right, camera._viewMatrix);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiply(camera._viewMatrix, camera._actualInvTransform, camera._viewMatrix);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].inverseTransformation(camera._viewMatrix, camera._invViewMatrix);
}
function updateCameraDeltas(camera) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(camera._oldPositionWC)) {
        camera._oldPositionWC = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.positionWC, camera._oldPositionWC);
    } else {
        camera.positionWCDeltaMagnitudeLastFrame = camera.positionWCDeltaMagnitude;
        const delta = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(camera.positionWC, camera._oldPositionWC, camera._oldPositionWC);
        camera.positionWCDeltaMagnitude = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].magnitude(delta);
        camera._oldPositionWC = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.positionWC, camera._oldPositionWC);
        // Update move timers
        if (camera.positionWCDeltaMagnitude > 0.0) {
            camera.timeSinceMoved = 0.0;
            camera._lastMovedTimestamp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$getTimestamp$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
        } else {
            camera.timeSinceMoved = Math.max((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$getTimestamp$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])() - camera._lastMovedTimestamp, 0.0) / 1000.0;
        }
    }
}
/**
 * Checks if there's a camera flight with preload for this camera.
 *
 * @returns {boolean} Whether or not this camera has a current flight with a valid preloadFlightCamera in scene.
 *
 * @private
 *
 */ Camera.prototype.canPreloadFlight = function() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._currentFlight) && this._mode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D;
};
Camera.prototype._updateCameraChanged = function() {
    const camera = this;
    updateCameraDeltas(camera);
    if (camera._changed.numberOfListeners === 0) {
        return;
    }
    const percentageChanged = camera.percentageChanged;
    // check heading
    const currentHeading = camera.heading;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(camera._changedHeading)) {
        camera._changedHeading = currentHeading;
    }
    let headingDelta = Math.abs(camera._changedHeading - currentHeading) % __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TWO_PI;
    headingDelta = headingDelta > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TWO_PI - headingDelta : headingDelta;
    // Since delta is computed as the shortest distance between two angles
    // the percentage is relative to the half circle.
    const headingChangedPercentage = headingDelta / Math.PI;
    if (headingChangedPercentage > percentageChanged) {
        camera._changedHeading = currentHeading;
    }
    // check roll
    const currentRoll = camera.roll;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(camera._changedRoll)) {
        camera._changedRoll = currentRoll;
    }
    let rollDelta = Math.abs(camera._changedRoll - currentRoll) % __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TWO_PI;
    rollDelta = rollDelta > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TWO_PI - rollDelta : rollDelta;
    // Since delta is computed as the shortest distance between two angles
    // the percentage is relative to the half circle.
    const rollChangedPercentage = rollDelta / Math.PI;
    if (rollChangedPercentage > percentageChanged) {
        camera._changedRoll = currentRoll;
    }
    if (rollChangedPercentage > percentageChanged || headingChangedPercentage > percentageChanged) {
        camera._changed.raiseEvent(Math.max(rollChangedPercentage, headingChangedPercentage));
    }
    if (camera._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(camera._changedFrustum)) {
            camera._changedPosition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.position, camera._changedPosition);
            camera._changedFrustum = camera.frustum.clone();
            return;
        }
        const position = camera.position;
        const lastPosition = camera._changedPosition;
        const frustum = camera.frustum;
        const lastFrustum = camera._changedFrustum;
        const x0 = position.x + frustum.left;
        const x1 = position.x + frustum.right;
        const x2 = lastPosition.x + lastFrustum.left;
        const x3 = lastPosition.x + lastFrustum.right;
        const y0 = position.y + frustum.bottom;
        const y1 = position.y + frustum.top;
        const y2 = lastPosition.y + lastFrustum.bottom;
        const y3 = lastPosition.y + lastFrustum.top;
        const leftX = Math.max(x0, x2);
        const rightX = Math.min(x1, x3);
        const bottomY = Math.max(y0, y2);
        const topY = Math.min(y1, y3);
        let areaPercentage;
        if (leftX >= rightX || bottomY >= y1) {
            areaPercentage = 1.0;
        } else {
            let areaRef = lastFrustum;
            if (x0 < x2 && x1 > x3 && y0 < y2 && y1 > y3) {
                areaRef = frustum;
            }
            areaPercentage = 1.0 - (rightX - leftX) * (topY - bottomY) / ((areaRef.right - areaRef.left) * (areaRef.top - areaRef.bottom));
        }
        if (areaPercentage > percentageChanged) {
            camera._changed.raiseEvent(areaPercentage);
            camera._changedPosition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.position, camera._changedPosition);
            camera._changedFrustum = camera.frustum.clone(camera._changedFrustum);
        }
        return;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(camera._changedDirection)) {
        camera._changedPosition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.positionWC, camera._changedPosition);
        camera._changedDirection = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.directionWC, camera._changedDirection);
        return;
    }
    const dirAngle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].acosClamped(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dot(camera.directionWC, camera._changedDirection));
    let dirPercentage;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(camera.frustum.fovy)) {
        dirPercentage = dirAngle / (camera.frustum.fovy * 0.5);
    } else {
        dirPercentage = dirAngle;
    }
    const distance = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(camera.positionWC, camera._changedPosition);
    const heightPercentage = distance / camera.positionCartographic.height;
    if (dirPercentage > percentageChanged || heightPercentage > percentageChanged) {
        camera._changed.raiseEvent(Math.max(dirPercentage, heightPercentage));
        camera._changedPosition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.positionWC, camera._changedPosition);
        camera._changedDirection = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.directionWC, camera._changedDirection);
    }
};
function convertTransformForColumbusView(camera) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Transforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].basisTo2D(camera._projection, camera._transform, camera._actualTransform);
}
const scratchCartographic = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchCartesian3Projection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchCartesian3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchCartesian4Origin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchCartesian4NewOrigin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchCartesian4NewXAxis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchCartesian4NewYAxis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchCartesian4NewZAxis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function convertTransformFor2D(camera) {
    const projection = camera._projection;
    const ellipsoid = projection.ellipsoid;
    const origin = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getColumn(camera._transform, 3, scratchCartesian4Origin);
    const cartographic = ellipsoid.cartesianToCartographic(origin, scratchCartographic);
    const projectedPosition = projection.project(cartographic, scratchCartesian3Projection);
    const newOrigin = scratchCartesian4NewOrigin;
    newOrigin.x = projectedPosition.z;
    newOrigin.y = projectedPosition.x;
    newOrigin.z = projectedPosition.y;
    newOrigin.w = 1.0;
    const newZAxis = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_X, scratchCartesian4NewZAxis);
    const xAxis = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getColumn(camera._transform, 0, scratchCartesian3), origin, scratchCartesian3);
    ellipsoid.cartesianToCartographic(xAxis, cartographic);
    projection.project(cartographic, projectedPosition);
    const newXAxis = scratchCartesian4NewXAxis;
    newXAxis.x = projectedPosition.z;
    newXAxis.y = projectedPosition.x;
    newXAxis.z = projectedPosition.y;
    newXAxis.w = 0.0;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(newXAxis, newOrigin, newXAxis);
    newXAxis.x = 0.0;
    const newYAxis = scratchCartesian4NewYAxis;
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].magnitudeSquared(newXAxis) > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EPSILON10) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(newZAxis, newXAxis, newYAxis);
    } else {
        const yAxis = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getColumn(camera._transform, 1, scratchCartesian3), origin, scratchCartesian3);
        ellipsoid.cartesianToCartographic(yAxis, cartographic);
        projection.project(cartographic, projectedPosition);
        newYAxis.x = projectedPosition.z;
        newYAxis.y = projectedPosition.x;
        newYAxis.z = projectedPosition.y;
        newYAxis.w = 0.0;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(newYAxis, newOrigin, newYAxis);
        newYAxis.x = 0.0;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].magnitudeSquared(newYAxis) < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EPSILON10) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_Y, newXAxis);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_Z, newYAxis);
        }
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(newYAxis, newZAxis, newXAxis);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(newXAxis, newXAxis);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(newZAxis, newXAxis, newYAxis);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(newYAxis, newYAxis);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].setColumn(camera._actualTransform, 0, newXAxis, camera._actualTransform);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].setColumn(camera._actualTransform, 1, newYAxis, camera._actualTransform);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].setColumn(camera._actualTransform, 2, newZAxis, camera._actualTransform);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].setColumn(camera._actualTransform, 3, newOrigin, camera._actualTransform);
}
const scratchCartesian = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function updateMembers(camera) {
    const mode = camera._mode;
    let heightChanged = false;
    let height = 0.0;
    if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        height = camera.frustum.right - camera.frustum.left;
        heightChanged = height !== camera._positionCartographic.height;
    }
    let position = camera._position;
    const positionChanged = !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(position, camera.position) || heightChanged;
    if (positionChanged) {
        position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.position, camera._position);
    }
    let direction = camera._direction;
    const directionChanged = !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(direction, camera.direction);
    if (directionChanged) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(camera.direction, camera.direction);
        direction = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.direction, camera._direction);
    }
    let up = camera._up;
    const upChanged = !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(up, camera.up);
    if (upChanged) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(camera.up, camera.up);
        up = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.up, camera._up);
    }
    let right = camera._right;
    const rightChanged = !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(right, camera.right);
    if (rightChanged) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(camera.right, camera.right);
        right = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.right, camera._right);
    }
    const transformChanged = camera._transformChanged || camera._modeChanged;
    camera._transformChanged = false;
    if (transformChanged) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].inverseTransformation(camera._transform, camera._invTransform);
        if (camera._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COLUMBUS_VIEW || camera._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY, camera._transform)) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(Camera.TRANSFORM_2D, camera._actualTransform);
            } else if (camera._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COLUMBUS_VIEW) {
                convertTransformForColumbusView(camera);
            } else {
                convertTransformFor2D(camera);
            }
        } else {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera._transform, camera._actualTransform);
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].inverseTransformation(camera._actualTransform, camera._actualInvTransform);
        camera._modeChanged = false;
    }
    const transform = camera._actualTransform;
    if (positionChanged || transformChanged) {
        camera._positionWC = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPoint(transform, position, camera._positionWC);
        // Compute the Cartographic position of the camera.
        if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE3D || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MORPHING) {
            camera._positionCartographic = camera._projection.ellipsoid.cartesianToCartographic(camera._positionWC, camera._positionCartographic);
        } else {
            // The camera position is expressed in the 2D coordinate system where the Y axis is to the East,
            // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where
            // X is to the East, Y is to the North, and Z is out of the local horizontal plane.
            const positionENU = scratchCartesian;
            positionENU.x = camera._positionWC.y;
            positionENU.y = camera._positionWC.z;
            positionENU.z = camera._positionWC.x;
            // In 2D, the camera height is always 12.7 million meters.
            // The apparent height is equal to half the frustum width.
            if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
                positionENU.z = height;
            }
            camera._projection.unproject(positionENU, camera._positionCartographic);
        }
    }
    if (directionChanged || upChanged || rightChanged) {
        const det = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dot(direction, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(up, right, scratchCartesian));
        if (Math.abs(1.0 - det) > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EPSILON2) {
            //orthonormalize axes
            const invUpMag = 1.0 / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].magnitudeSquared(up);
            const scalar = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dot(up, direction) * invUpMag;
            const w0 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(direction, scalar, scratchCartesian);
            up = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(up, w0, camera._up), camera._up);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(up, camera.up);
            right = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(direction, up, camera._right);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(right, camera.right);
        }
    }
    if (directionChanged || transformChanged) {
        camera._directionWC = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPointAsVector(transform, direction, camera._directionWC);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(camera._directionWC, camera._directionWC);
    }
    if (upChanged || transformChanged) {
        camera._upWC = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPointAsVector(transform, up, camera._upWC);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(camera._upWC, camera._upWC);
    }
    if (rightChanged || transformChanged) {
        camera._rightWC = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPointAsVector(transform, right, camera._rightWC);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(camera._rightWC, camera._rightWC);
    }
    if (positionChanged || directionChanged || upChanged || rightChanged || transformChanged) {
        updateViewMatrix(camera);
    }
}
function getHeading(direction, up) {
    let heading;
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsEpsilon(Math.abs(direction.z), 1.0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EPSILON3)) {
        heading = Math.atan2(direction.y, direction.x) - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO;
    } else {
        heading = Math.atan2(up.y, up.x) - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO;
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TWO_PI - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].zeroToTwoPi(heading);
}
function getPitch(direction) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].acosClamped(direction.z);
}
function getRoll(direction, up, right) {
    let roll = 0.0;
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsEpsilon(Math.abs(direction.z), 1.0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EPSILON3)) {
        roll = Math.atan2(-right.z, up.z);
        roll = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].zeroToTwoPi(roll + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TWO_PI);
    }
    return roll;
}
const scratchHPRMatrix1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchHPRMatrix2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
Object.defineProperties(Camera.prototype, {
    /**
   * Gets the camera's reference frame. The inverse of this transformation is appended to the view matrix.
   * @memberof Camera.prototype
   *
   * @type {Matrix4}
   * @readonly
   *
   * @default {@link Matrix4.IDENTITY}
   */ transform: {
        get: function() {
            return this._transform;
        }
    },
    /**
   * Gets the inverse camera transform.
   * @memberof Camera.prototype
   *
   * @type {Matrix4}
   * @readonly
   *
   * @default {@link Matrix4.IDENTITY}
   */ inverseTransform: {
        get: function() {
            updateMembers(this);
            return this._invTransform;
        }
    },
    /**
   * Gets the view matrix.
   * @memberof Camera.prototype
   *
   * @type {Matrix4}
   * @readonly
   *
   * @see Camera#inverseViewMatrix
   */ viewMatrix: {
        get: function() {
            updateMembers(this);
            return this._viewMatrix;
        }
    },
    /**
   * Gets the inverse view matrix.
   * @memberof Camera.prototype
   *
   * @type {Matrix4}
   * @readonly
   *
   * @see Camera#viewMatrix
   */ inverseViewMatrix: {
        get: function() {
            updateMembers(this);
            return this._invViewMatrix;
        }
    },
    /**
   * Gets the {@link Cartographic} position of the camera, with longitude and latitude
   * expressed in radians and height in meters.  In 2D and Columbus View, it is possible
   * for the returned longitude and latitude to be outside the range of valid longitudes
   * and latitudes when the camera is outside the map.
   * @memberof Camera.prototype
   *
   * @type {Cartographic}
   * @readonly
   */ positionCartographic: {
        get: function() {
            updateMembers(this);
            return this._positionCartographic;
        }
    },
    /**
   * Gets the position of the camera in world coordinates.
   * @memberof Camera.prototype
   *
   * @type {Cartesian3}
   * @readonly
   */ positionWC: {
        get: function() {
            updateMembers(this);
            return this._positionWC;
        }
    },
    /**
   * Gets the view direction of the camera in world coordinates.
   * @memberof Camera.prototype
   *
   * @type {Cartesian3}
   * @readonly
   */ directionWC: {
        get: function() {
            updateMembers(this);
            return this._directionWC;
        }
    },
    /**
   * Gets the up direction of the camera in world coordinates.
   * @memberof Camera.prototype
   *
   * @type {Cartesian3}
   * @readonly
   */ upWC: {
        get: function() {
            updateMembers(this);
            return this._upWC;
        }
    },
    /**
   * Gets the right direction of the camera in world coordinates.
   * @memberof Camera.prototype
   *
   * @type {Cartesian3}
   * @readonly
   */ rightWC: {
        get: function() {
            updateMembers(this);
            return this._rightWC;
        }
    },
    /**
   * Gets the camera heading in radians.
   * @memberof Camera.prototype
   *
   * @type {number}
   * @readonly
   */ heading: {
        get: function() {
            if (this._mode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MORPHING) {
                const ellipsoid = this._projection.ellipsoid;
                const oldTransform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(this._transform, scratchHPRMatrix1);
                const transform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Transforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eastNorthUpToFixedFrame(this.positionWC, ellipsoid, scratchHPRMatrix2);
                this._setTransform(transform);
                const heading = getHeading(this.direction, this.up);
                this._setTransform(oldTransform);
                return heading;
            }
            return undefined;
        }
    },
    /**
   * Gets the camera pitch in radians.
   * @memberof Camera.prototype
   *
   * @type {number}
   * @readonly
   */ pitch: {
        get: function() {
            if (this._mode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MORPHING) {
                const ellipsoid = this._projection.ellipsoid;
                const oldTransform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(this._transform, scratchHPRMatrix1);
                const transform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Transforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eastNorthUpToFixedFrame(this.positionWC, ellipsoid, scratchHPRMatrix2);
                this._setTransform(transform);
                const pitch = getPitch(this.direction);
                this._setTransform(oldTransform);
                return pitch;
            }
            return undefined;
        }
    },
    /**
   * Gets the camera roll in radians.
   * @memberof Camera.prototype
   *
   * @type {number}
   * @readonly
   */ roll: {
        get: function() {
            if (this._mode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MORPHING) {
                const ellipsoid = this._projection.ellipsoid;
                const oldTransform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(this._transform, scratchHPRMatrix1);
                const transform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Transforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eastNorthUpToFixedFrame(this.positionWC, ellipsoid, scratchHPRMatrix2);
                this._setTransform(transform);
                const roll = getRoll(this.direction, this.up, this.right);
                this._setTransform(oldTransform);
                return roll;
            }
            return undefined;
        }
    },
    /**
   * Gets the event that will be raised at when the camera starts to move.
   * @memberof Camera.prototype
   * @type {Event}
   * @readonly
   */ moveStart: {
        get: function() {
            return this._moveStart;
        }
    },
    /**
   * Gets the event that will be raised when the camera has stopped moving.
   * @memberof Camera.prototype
   * @type {Event}
   * @readonly
   */ moveEnd: {
        get: function() {
            return this._moveEnd;
        }
    },
    /**
   * Gets the event that will be raised when the camera has changed by <code>percentageChanged</code>.
   * @memberof Camera.prototype
   * @type {Event}
   * @readonly
   */ changed: {
        get: function() {
            return this._changed;
        }
    }
});
/**
 * @private
 */ Camera.prototype.update = function(mode) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(mode)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("mode is required.");
    }
    if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D && !(this.frustum instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$OrthographicOffCenterFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("An OrthographicOffCenterFrustum is required in 2D.");
    }
    if ((mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE3D || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COLUMBUS_VIEW) && !(this.frustum instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PerspectiveFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) && !(this.frustum instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$OrthographicFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("A PerspectiveFrustum or OrthographicFrustum is required in 3D and Columbus view");
    }
    //>>includeEnd('debug');
    let updateFrustum = false;
    if (mode !== this._mode) {
        this._mode = mode;
        this._modeChanged = mode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MORPHING;
        updateFrustum = this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D;
    }
    if (updateFrustum) {
        const frustum = this._max2Dfrustum = this.frustum.clone();
        //>>includeStart('debug', pragmas.debug);
        if (!(frustum instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$OrthographicOffCenterFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("The camera frustum is expected to be orthographic for 2D camera control.");
        }
        //>>includeEnd('debug');
        const maxZoomOut = 2.0;
        const ratio = frustum.top / frustum.right;
        frustum.right = this._maxCoord.x * maxZoomOut;
        frustum.left = -frustum.right;
        frustum.top = ratio * frustum.right;
        frustum.bottom = -frustum.top;
    }
    if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        clampMove2D(this, this.position);
    }
};
const setTransformPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const setTransformUp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const setTransformDirection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
Camera.prototype._setTransform = function(transform) {
    const position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(this.positionWC, setTransformPosition);
    const up = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(this.upWC, setTransformUp);
    const direction = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(this.directionWC, setTransformDirection);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(transform, this._transform);
    this._transformChanged = true;
    updateMembers(this);
    const inverse = this._actualInvTransform;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPoint(inverse, position, this.position);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPointAsVector(inverse, direction, this.direction);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPointAsVector(inverse, up, this.up);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(this.direction, this.up, this.right);
    updateMembers(this);
};
const scratchAdjustOrthographicFrustumMousePosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchPickRay = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Ray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchRayIntersection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchDepthIntersection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function calculateOrthographicFrustumWidth(camera) {
    // Camera is fixed to an object, so keep frustum width constant.
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY, camera.transform)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].magnitude(camera.position);
    }
    const scene = camera._scene;
    const globe = scene.globe;
    const mousePosition = scratchAdjustOrthographicFrustumMousePosition;
    mousePosition.x = scene.drawingBufferWidth / scene.pixelRatio / 2.0;
    mousePosition.y = scene.drawingBufferHeight / scene.pixelRatio / 2.0;
    let rayIntersection;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(globe)) {
        const ray = camera.getPickRay(mousePosition, scratchPickRay);
        rayIntersection = globe.pickWorldCoordinates(ray, scene, true, scratchRayIntersection);
    }
    let depthIntersection;
    if (scene.pickPositionSupported) {
        depthIntersection = scene.pickPositionWorldCoordinates(mousePosition, scratchDepthIntersection);
    }
    let distance;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(rayIntersection) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(depthIntersection)) {
        const depthDistance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(depthIntersection) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(depthIntersection, camera.positionWC) : Number.POSITIVE_INFINITY;
        const rayDistance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(rayIntersection) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(rayIntersection, camera.positionWC) : Number.POSITIVE_INFINITY;
        distance = Math.min(depthDistance, rayDistance);
    } else {
        distance = Math.max(camera.positionCartographic.height, 0.0);
    }
    return distance;
}
Camera.prototype._adjustOrthographicFrustum = function(zooming) {
    if (!(this.frustum instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$OrthographicFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])) {
        return;
    }
    if (!zooming && this._positionCartographic.height < 150000.0) {
        return;
    }
    this.frustum.width = calculateOrthographicFrustumWidth(this);
};
const scratchSetViewCartesian = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchSetViewTransform1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchSetViewTransform2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchSetViewQuaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchSetViewMatrix3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchSetViewCartographic = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function setView3D(camera, position, hpr) {
    //>>includeStart('debug', pragmas.debug);
    if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("position has a NaN component");
    }
    //>>includeEnd('debug');
    const currentTransform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.transform, scratchSetViewTransform1);
    const localTransform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Transforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eastNorthUpToFixedFrame(position, camera._projection.ellipsoid, scratchSetViewTransform2);
    camera._setTransform(localTransform);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ZERO, camera.position);
    hpr.heading = hpr.heading - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO;
    const rotQuat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromHeadingPitchRoll(hpr, scratchSetViewQuaternion);
    const rotMat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromQuaternion(rotQuat, scratchSetViewMatrix3);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getColumn(rotMat, 0, camera.direction);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getColumn(rotMat, 2, camera.up);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(camera.direction, camera.up, camera.right);
    camera._setTransform(currentTransform);
    camera._adjustOrthographicFrustum(true);
}
function setViewCV(camera, position, hpr, convert) {
    const currentTransform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.transform, scratchSetViewTransform1);
    camera._setTransform(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY);
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(position, camera.positionWC)) {
        if (convert) {
            const projection = camera._projection;
            const cartographic = projection.ellipsoid.cartesianToCartographic(position, scratchSetViewCartographic);
            position = projection.project(cartographic, scratchSetViewCartesian);
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(position, camera.position);
    }
    hpr.heading = hpr.heading - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO;
    const rotQuat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromHeadingPitchRoll(hpr, scratchSetViewQuaternion);
    const rotMat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromQuaternion(rotQuat, scratchSetViewMatrix3);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getColumn(rotMat, 0, camera.direction);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getColumn(rotMat, 2, camera.up);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(camera.direction, camera.up, camera.right);
    camera._setTransform(currentTransform);
    camera._adjustOrthographicFrustum(true);
}
function setView2D(camera, position, hpr, convert) {
    const currentTransform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.transform, scratchSetViewTransform1);
    camera._setTransform(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY);
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(position, camera.positionWC)) {
        if (convert) {
            const projection = camera._projection;
            const cartographic = projection.ellipsoid.cartesianToCartographic(position, scratchSetViewCartographic);
            position = projection.project(cartographic, scratchSetViewCartesian);
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(position, camera.position);
        const newLeft = -position.z * 0.5;
        const newRight = -newLeft;
        const frustum = camera.frustum;
        if (newRight > newLeft) {
            const ratio = frustum.top / frustum.right;
            frustum.right = newRight;
            frustum.left = newLeft;
            frustum.top = frustum.right * ratio;
            frustum.bottom = -frustum.top;
        }
    }
    if (camera._scene.mapMode2D === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$MapMode2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ROTATE) {
        hpr.heading = hpr.heading - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO;
        hpr.pitch = -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO;
        hpr.roll = 0.0;
        const rotQuat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromHeadingPitchRoll(hpr, scratchSetViewQuaternion);
        const rotMat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromQuaternion(rotQuat, scratchSetViewMatrix3);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getColumn(rotMat, 2, camera.up);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(camera.direction, camera.up, camera.right);
    }
    camera._setTransform(currentTransform);
}
const scratchToHPRDirection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchToHPRUp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchToHPRRight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function directionUpToHeadingPitchRoll(camera, position, orientation, result) {
    const direction = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(orientation.direction, scratchToHPRDirection);
    const up = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(orientation.up, scratchToHPRUp);
    if (camera._scene.mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE3D) {
        const ellipsoid = camera._projection.ellipsoid;
        const transform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Transforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eastNorthUpToFixedFrame(position, ellipsoid, scratchHPRMatrix1);
        const invTransform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].inverseTransformation(transform, scratchHPRMatrix2);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPointAsVector(invTransform, direction, direction);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPointAsVector(invTransform, up, up);
    }
    const right = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(direction, up, scratchToHPRRight);
    result.heading = getHeading(direction, up);
    result.pitch = getPitch(direction);
    result.roll = getRoll(direction, up, right);
    return result;
}
const scratchSetViewOptions = {
    destination: undefined,
    orientation: {
        direction: undefined,
        up: undefined,
        heading: undefined,
        pitch: undefined,
        roll: undefined
    },
    convert: undefined,
    endTransform: undefined
};
const scratchHpr = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$HeadingPitchRoll$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
/**
 * Sets the camera position, orientation and transform.
 *
 * @param {object} options Object with the following properties:
 * @param {Cartesian3|Rectangle} [options.destination] The final position of the camera in world coordinates or a rectangle that would be visible from a top-down view.
 * @param {HeadingPitchRollValues|DirectionUp} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point
 * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive
 * y direction in Columbus view. Orientation is not used in 2D when in infinite scrolling mode.
 * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame of the camera.
 * @param {boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.
 *
 * @example
 * // 1. Set position with a top-down view
 * viewer.camera.setView({
 *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)
 * });
 *
 * // 2 Set view with heading, pitch and roll
 * viewer.camera.setView({
 *     destination : cartesianPosition,
 *     orientation: {
 *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)
 *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)
 *         roll : 0.0                             // default value
 *     }
 * });
 *
 * // 3. Change heading, pitch and roll with the camera position remaining the same.
 * viewer.camera.setView({
 *     orientation: {
 *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)
 *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)
 *         roll : 0.0                             // default value
 *     }
 * });
 *
 *
 * // 4. View rectangle with a top-down view
 * viewer.camera.setView({
 *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)
 * });
 *
 * // 5. Set position with an orientation using unit vectors.
 * viewer.camera.setView({
 *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),
 *     orientation : {
 *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),
 *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)
 *     }
 * });
 */ Camera.prototype.setView = function(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    let orientation = options.orientation ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const mode = this._mode;
    if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MORPHING) {
        return;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.endTransform)) {
        this._setTransform(options.endTransform);
    }
    let convert = options.convert ?? true;
    let destination = options.destination ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(this.positionWC, scratchSetViewCartesian);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(destination) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(destination.west)) {
        destination = this.getRectangleCameraCoordinates(destination, scratchSetViewCartesian);
        //>>includeStart('debug', pragmas.debug);
        // destination.z may be null in 2D, but .x and .y should be numeric
        if (isNaN(destination.x) || isNaN(destination.y)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`destination has a NaN component`);
        }
        //>>includeEnd('debug');
        convert = false;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(orientation.direction)) {
        orientation = directionUpToHeadingPitchRoll(this, destination, orientation, scratchSetViewOptions.orientation);
    }
    scratchHpr.heading = orientation.heading ?? 0.0;
    scratchHpr.pitch = orientation.pitch ?? -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO;
    scratchHpr.roll = orientation.roll ?? 0.0;
    if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE3D) {
        setView3D(this, destination, scratchHpr);
    } else if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        setView2D(this, destination, scratchHpr, convert);
    } else {
        setViewCV(this, destination, scratchHpr, convert);
    }
};
const pitchScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
/**
 * Fly the camera to the home view.  Use {@link Camera#.DEFAULT_VIEW_RECTANGLE} to set
 * the default view for the 3D scene.  The home view for 2D and columbus view shows the
 * entire map.
 *
 * @param {number} [duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight. See {@link Camera#flyTo}
 */ Camera.prototype.flyHome = function(duration) {
    const mode = this._mode;
    if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MORPHING) {
        this._scene.completeMorph();
    }
    if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        this.flyTo({
            destination: Camera.DEFAULT_VIEW_RECTANGLE,
            duration: duration,
            endTransform: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY
        });
    } else if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE3D) {
        const destination = this.getRectangleCameraCoordinates(Camera.DEFAULT_VIEW_RECTANGLE);
        let mag = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].magnitude(destination);
        mag += mag * Camera.DEFAULT_VIEW_FACTOR;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(destination, destination);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(destination, mag, destination);
        this.flyTo({
            destination: destination,
            duration: duration,
            endTransform: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY
        });
    } else if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COLUMBUS_VIEW) {
        const maxRadii = this._projection.ellipsoid.maximumRadius;
        let position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0.0, -1.0, 1.0);
        position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(position, position), 5.0 * maxRadii, position);
        this.flyTo({
            destination: position,
            duration: duration,
            orientation: {
                heading: 0.0,
                pitch: -Math.acos(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(position, pitchScratch).z),
                roll: 0.0
            },
            endTransform: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY,
            convert: false
        });
    }
};
/**
 * Transform a vector or point from world coordinates to the camera's reference frame.
 *
 * @param {Cartesian4} cartesian The vector or point to transform.
 * @param {Cartesian4} [result] The object onto which to store the result.
 * @returns {Cartesian4} The transformed vector or point.
 */ Camera.prototype.worldToCameraCoordinates = function(cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(cartesian)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("cartesian is required.");
    }
    //>>includeEnd('debug');
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result)) {
        result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    }
    updateMembers(this);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByVector(this._actualInvTransform, cartesian, result);
};
/**
 * Transform a point from world coordinates to the camera's reference frame.
 *
 * @param {Cartesian3} cartesian The point to transform.
 * @param {Cartesian3} [result] The object onto which to store the result.
 * @returns {Cartesian3} The transformed point.
 */ Camera.prototype.worldToCameraCoordinatesPoint = function(cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(cartesian)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("cartesian is required.");
    }
    //>>includeEnd('debug');
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result)) {
        result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    }
    updateMembers(this);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPoint(this._actualInvTransform, cartesian, result);
};
/**
 * Transform a vector from world coordinates to the camera's reference frame.
 *
 * @param {Cartesian3} cartesian The vector to transform.
 * @param {Cartesian3} [result] The object onto which to store the result.
 * @returns {Cartesian3} The transformed vector.
 */ Camera.prototype.worldToCameraCoordinatesVector = function(cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(cartesian)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("cartesian is required.");
    }
    //>>includeEnd('debug');
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result)) {
        result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    }
    updateMembers(this);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPointAsVector(this._actualInvTransform, cartesian, result);
};
/**
 * Transform a vector or point from the camera's reference frame to world coordinates.
 *
 * @param {Cartesian4} cartesian The vector or point to transform.
 * @param {Cartesian4} [result] The object onto which to store the result.
 * @returns {Cartesian4} The transformed vector or point.
 */ Camera.prototype.cameraToWorldCoordinates = function(cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(cartesian)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("cartesian is required.");
    }
    //>>includeEnd('debug');
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result)) {
        result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    }
    updateMembers(this);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByVector(this._actualTransform, cartesian, result);
};
/**
 * Transform a point from the camera's reference frame to world coordinates.
 *
 * @param {Cartesian3} cartesian The point to transform.
 * @param {Cartesian3} [result] The object onto which to store the result.
 * @returns {Cartesian3} The transformed point.
 */ Camera.prototype.cameraToWorldCoordinatesPoint = function(cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(cartesian)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("cartesian is required.");
    }
    //>>includeEnd('debug');
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result)) {
        result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    }
    updateMembers(this);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPoint(this._actualTransform, cartesian, result);
};
/**
 * Transform a vector from the camera's reference frame to world coordinates.
 *
 * @param {Cartesian3} cartesian The vector to transform.
 * @param {Cartesian3} [result] The object onto which to store the result.
 * @returns {Cartesian3} The transformed vector.
 */ Camera.prototype.cameraToWorldCoordinatesVector = function(cartesian, result) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(cartesian)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("cartesian is required.");
    }
    //>>includeEnd('debug');
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result)) {
        result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    }
    updateMembers(this);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPointAsVector(this._actualTransform, cartesian, result);
};
function clampMove2D(camera, position) {
    const rotatable2D = camera._scene.mapMode2D === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$MapMode2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ROTATE;
    const maxProjectedX = camera._maxCoord.x;
    const maxProjectedY = camera._maxCoord.y;
    let minX;
    let maxX;
    if (rotatable2D) {
        maxX = maxProjectedX;
        minX = -maxX;
    } else {
        maxX = position.x - maxProjectedX * 2.0;
        minX = position.x + maxProjectedX * 2.0;
    }
    if (position.x > maxProjectedX) {
        position.x = maxX;
    }
    if (position.x < -maxProjectedX) {
        position.x = minX;
    }
    if (position.y > maxProjectedY) {
        position.y = maxProjectedY;
    }
    if (position.y < -maxProjectedY) {
        position.y = -maxProjectedY;
    }
}
const moveScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
/**
 * Translates the camera's position by <code>amount</code> along <code>direction</code>.
 *
 * @param {Cartesian3} direction The direction to move.
 * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
 *
 * @see Camera#moveBackward
 * @see Camera#moveForward
 * @see Camera#moveLeft
 * @see Camera#moveRight
 * @see Camera#moveUp
 * @see Camera#moveDown
 */ Camera.prototype.move = function(direction, amount) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(direction)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("direction is required.");
    }
    //>>includeEnd('debug');
    const cameraPosition = this.position;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(direction, amount, moveScratch);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].add(cameraPosition, moveScratch, cameraPosition);
    if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        clampMove2D(this, cameraPosition);
    }
    this._adjustOrthographicFrustum(true);
};
/**
 * Translates the camera's position by <code>amount</code> along the camera's view vector.
 * When in 2D mode, this will zoom in the camera instead of translating the camera's position.
 *
 * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
 *
 * @see Camera#moveBackward
 */ Camera.prototype.moveForward = function(amount) {
    amount = amount ?? this.defaultMoveAmount;
    if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        // 2D mode
        zoom2D(this, amount);
    } else {
        // 3D or Columbus view mode
        this.move(this.direction, amount);
    }
};
/**
 * Translates the camera's position by <code>amount</code> along the opposite direction
 * of the camera's view vector.
 * When in 2D mode, this will zoom out the camera instead of translating the camera's position.
 *
 * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
 *
 * @see Camera#moveForward
 */ Camera.prototype.moveBackward = function(amount) {
    amount = amount ?? this.defaultMoveAmount;
    if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        // 2D mode
        zoom2D(this, -amount);
    } else {
        // 3D or Columbus view mode
        this.move(this.direction, -amount);
    }
};
/**
 * Translates the camera's position by <code>amount</code> along the camera's up vector.
 *
 * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
 *
 * @see Camera#moveDown
 */ Camera.prototype.moveUp = function(amount) {
    amount = amount ?? this.defaultMoveAmount;
    this.move(this.up, amount);
};
/**
 * Translates the camera's position by <code>amount</code> along the opposite direction
 * of the camera's up vector.
 *
 * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
 *
 * @see Camera#moveUp
 */ Camera.prototype.moveDown = function(amount) {
    amount = amount ?? this.defaultMoveAmount;
    this.move(this.up, -amount);
};
/**
 * Translates the camera's position by <code>amount</code> along the camera's right vector.
 *
 * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
 *
 * @see Camera#moveLeft
 */ Camera.prototype.moveRight = function(amount) {
    amount = amount ?? this.defaultMoveAmount;
    this.move(this.right, amount);
};
/**
 * Translates the camera's position by <code>amount</code> along the opposite direction
 * of the camera's right vector.
 *
 * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
 *
 * @see Camera#moveRight
 */ Camera.prototype.moveLeft = function(amount) {
    amount = amount ?? this.defaultMoveAmount;
    this.move(this.right, -amount);
};
/**
 * Rotates the camera around its up vector by amount, in radians, in the opposite direction
 * of its right vector if not in 2D mode.
 *
 * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
 *
 * @see Camera#lookRight
 */ Camera.prototype.lookLeft = function(amount) {
    amount = amount ?? this.defaultLookAmount;
    // only want view of map to change in 3D mode, 2D visual is incorrect when look changes
    if (this._mode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        this.look(this.up, -amount);
    }
};
/**
 * Rotates the camera around its up vector by amount, in radians, in the direction
 * of its right vector if not in 2D mode.
 *
 * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
 *
 * @see Camera#lookLeft
 */ Camera.prototype.lookRight = function(amount) {
    amount = amount ?? this.defaultLookAmount;
    // only want view of map to change in 3D mode, 2D visual is incorrect when look changes
    if (this._mode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        this.look(this.up, amount);
    }
};
/**
 * Rotates the camera around its right vector by amount, in radians, in the direction
 * of its up vector if not in 2D mode.
 *
 * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
 *
 * @see Camera#lookDown
 */ Camera.prototype.lookUp = function(amount) {
    amount = amount ?? this.defaultLookAmount;
    // only want view of map to change in 3D mode, 2D visual is incorrect when look changes
    if (this._mode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        this.look(this.right, -amount);
    }
};
/**
 * Rotates the camera around its right vector by amount, in radians, in the opposite direction
 * of its up vector if not in 2D mode.
 *
 * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
 *
 * @see Camera#lookUp
 */ Camera.prototype.lookDown = function(amount) {
    amount = amount ?? this.defaultLookAmount;
    // only want view of map to change in 3D mode, 2D visual is incorrect when look changes
    if (this._mode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        this.look(this.right, amount);
    }
};
const lookScratchQuaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const lookScratchMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
/**
 * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>
 *
 * @param {Cartesian3} axis The axis to rotate around.
 * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
 *
 * @see Camera#lookUp
 * @see Camera#lookDown
 * @see Camera#lookLeft
 * @see Camera#lookRight
 */ Camera.prototype.look = function(axis, angle) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(axis)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("axis is required.");
    }
    //>>includeEnd('debug');
    const turnAngle = angle ?? this.defaultLookAmount;
    const quaternion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromAxisAngle(axis, -turnAngle, lookScratchQuaternion);
    const rotation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromQuaternion(quaternion, lookScratchMatrix);
    const direction = this.direction;
    const up = this.up;
    const right = this.right;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByVector(rotation, direction, direction);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByVector(rotation, up, up);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByVector(rotation, right, right);
};
/**
 * Rotate the camera counter-clockwise around its direction vector by amount, in radians.
 *
 * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
 *
 * @see Camera#twistRight
 */ Camera.prototype.twistLeft = function(amount) {
    amount = amount ?? this.defaultLookAmount;
    this.look(this.direction, amount);
};
/**
 * Rotate the camera clockwise around its direction vector by amount, in radians.
 *
 * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
 *
 * @see Camera#twistLeft
 */ Camera.prototype.twistRight = function(amount) {
    amount = amount ?? this.defaultLookAmount;
    this.look(this.direction, -amount);
};
const rotateScratchQuaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const rotateScratchMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
/**
 * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance
 * of the camera's position to the center of the camera's reference frame remains the same.
 *
 * @param {Cartesian3} axis The axis to rotate around given in world coordinates.
 * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
 *
 * @see Camera#rotateUp
 * @see Camera#rotateDown
 * @see Camera#rotateLeft
 * @see Camera#rotateRight
 */ Camera.prototype.rotate = function(axis, angle) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(axis)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("axis is required.");
    }
    //>>includeEnd('debug');
    const turnAngle = angle ?? this.defaultRotateAmount;
    const quaternion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromAxisAngle(axis, -turnAngle, rotateScratchQuaternion);
    const rotation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromQuaternion(quaternion, rotateScratchMatrix);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByVector(rotation, this.position, this.position);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByVector(rotation, this.direction, this.direction);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByVector(rotation, this.up, this.up);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(this.direction, this.up, this.right);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(this.right, this.direction, this.up);
    this._adjustOrthographicFrustum(false);
};
/**
 * Rotates the camera around the center of the camera's reference frame by angle downwards.
 *
 * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
 *
 * @see Camera#rotateUp
 * @see Camera#rotate
 */ Camera.prototype.rotateDown = function(angle) {
    angle = angle ?? this.defaultRotateAmount;
    rotateVertical(this, angle);
};
/**
 * Rotates the camera around the center of the camera's reference frame by angle upwards.
 *
 * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
 *
 * @see Camera#rotateDown
 * @see Camera#rotate
 */ Camera.prototype.rotateUp = function(angle) {
    angle = angle ?? this.defaultRotateAmount;
    rotateVertical(this, -angle);
};
const rotateVertScratchP = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const rotateVertScratchA = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const rotateVertScratchTan = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const rotateVertScratchNegate = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function rotateVertical(camera, angle) {
    const position = camera.position;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(camera.constrainedAxis) && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsEpsilon(camera.position, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ZERO, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EPSILON2)) {
        const p = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(position, rotateVertScratchP);
        const northParallel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsEpsilon(p, camera.constrainedAxis, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EPSILON2);
        const southParallel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsEpsilon(p, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].negate(camera.constrainedAxis, rotateVertScratchNegate), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EPSILON2);
        if (!northParallel && !southParallel) {
            const constrainedAxis = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(camera.constrainedAxis, rotateVertScratchA);
            let dot = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dot(p, constrainedAxis);
            let angleToAxis = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].acosClamped(dot);
            if (angle > 0 && angle > angleToAxis) {
                angle = angleToAxis - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EPSILON4;
            }
            dot = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dot(p, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].negate(constrainedAxis, rotateVertScratchNegate));
            angleToAxis = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].acosClamped(dot);
            if (angle < 0 && -angle > angleToAxis) {
                angle = -angleToAxis + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EPSILON4;
            }
            const tangent = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(constrainedAxis, p, rotateVertScratchTan);
            camera.rotate(tangent, angle);
        } else if (northParallel && angle < 0 || southParallel && angle > 0) {
            camera.rotate(camera.right, angle);
        }
    } else {
        camera.rotate(camera.right, angle);
    }
}
/**
 * Rotates the camera around the center of the camera's reference frame by angle to the right.
 *
 * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
 *
 * @see Camera#rotateLeft
 * @see Camera#rotate
 */ Camera.prototype.rotateRight = function(angle) {
    angle = angle ?? this.defaultRotateAmount;
    rotateHorizontal(this, -angle);
};
/**
 * Rotates the camera around the center of the camera's reference frame by angle to the left.
 *
 * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
 *
 * @see Camera#rotateRight
 * @see Camera#rotate
 */ Camera.prototype.rotateLeft = function(angle) {
    angle = angle ?? this.defaultRotateAmount;
    rotateHorizontal(this, angle);
};
function rotateHorizontal(camera, angle) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(camera.constrainedAxis)) {
        camera.rotate(camera.constrainedAxis, angle);
    } else {
        camera.rotate(camera.up, angle);
    }
}
function zoom2D(camera, amount) {
    const frustum = camera.frustum;
    //>>includeStart('debug', pragmas.debug);
    if (!(frustum instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$OrthographicOffCenterFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(frustum.left) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(frustum.right) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(frustum.bottom) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(frustum.top)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("The camera frustum is expected to be orthographic for 2D camera control.");
    }
    //>>includeEnd('debug');
    let ratio;
    amount = amount * 0.5;
    if (Math.abs(frustum.top) + Math.abs(frustum.bottom) > Math.abs(frustum.left) + Math.abs(frustum.right)) {
        let newTop = frustum.top - amount;
        let newBottom = frustum.bottom + amount;
        let maxBottom = camera._maxCoord.y;
        if (camera._scene.mapMode2D === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$MapMode2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ROTATE) {
            maxBottom *= camera.maximumZoomFactor;
        }
        if (newBottom > maxBottom) {
            newBottom = maxBottom;
            newTop = -maxBottom;
        }
        if (newTop <= newBottom) {
            newTop = 1.0;
            newBottom = -1.0;
        }
        ratio = frustum.right / frustum.top;
        frustum.top = newTop;
        frustum.bottom = newBottom;
        frustum.right = frustum.top * ratio;
        frustum.left = -frustum.right;
    } else {
        let newRight = frustum.right - amount;
        let newLeft = frustum.left + amount;
        let maxRight = camera._maxCoord.x;
        if (camera._scene.mapMode2D === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$MapMode2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ROTATE) {
            maxRight *= camera.maximumZoomFactor;
        }
        if (newRight > maxRight) {
            newRight = maxRight;
            newLeft = -maxRight;
        }
        if (newRight <= newLeft) {
            newRight = 1.0;
            newLeft = -1.0;
        }
        ratio = frustum.top / frustum.right;
        frustum.right = newRight;
        frustum.left = newLeft;
        frustum.top = frustum.right * ratio;
        frustum.bottom = -frustum.top;
    }
}
function zoom3D(camera, amount) {
    camera.move(camera.direction, amount);
}
/**
 * Zooms <code>amount</code> along the camera's view vector.
 *
 * @param {number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.
 *
 * @see Camera#zoomOut
 */ Camera.prototype.zoomIn = function(amount) {
    amount = amount ?? this.defaultZoomAmount;
    if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        zoom2D(this, amount);
    } else {
        zoom3D(this, amount);
    }
};
/**
 * Zooms <code>amount</code> along the opposite direction of
 * the camera's view vector.
 *
 * @param {number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.
 *
 * @see Camera#zoomIn
 */ Camera.prototype.zoomOut = function(amount) {
    amount = amount ?? this.defaultZoomAmount;
    if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        zoom2D(this, -amount);
    } else {
        zoom3D(this, -amount);
    }
};
/**
 * Gets the magnitude of the camera position. In 3D, this is the vector magnitude. In 2D and
 * Columbus view, this is the distance to the map.
 *
 * @returns {number} The magnitude of the position.
 */ Camera.prototype.getMagnitude = function() {
    if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE3D) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].magnitude(this.position);
    } else if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COLUMBUS_VIEW) {
        return Math.abs(this.position.z);
    } else if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        return Math.max(this.frustum.right - this.frustum.left, this.frustum.top - this.frustum.bottom);
    }
};
const scratchLookAtMatrix4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
/**
 * Sets the camera position and orientation using a target and offset. The target must be given in
 * world coordinates. The offset can be either a cartesian or heading/pitch/range in the local east-north-up reference frame centered at the target.
 * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset
 * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.
 * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
 * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.
 *
 * In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the
 * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be
 * determined from the offset, the heading will be north.
 *
 * @param {Cartesian3} target The target position in world coordinates.
 * @param {Cartesian3|HeadingPitchRange} offset The offset from the target in the local east-north-up reference frame centered at the target.
 *
 * @exception {DeveloperError} lookAt is not supported while morphing.
 *
 * @example
 * // 1. Using a cartesian offset
 * const center = Cesium.Cartesian3.fromDegrees(-98.0, 40.0);
 * viewer.camera.lookAt(center, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));
 *
 * // 2. Using a HeadingPitchRange offset
 * const center = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);
 * const heading = Cesium.Math.toRadians(50.0);
 * const pitch = Cesium.Math.toRadians(-20.0);
 * const range = 5000.0;
 * viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range));
 */ Camera.prototype.lookAt = function(target, offset) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(target)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("target is required");
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(offset)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("offset is required");
    }
    if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MORPHING) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("lookAt is not supported while morphing.");
    }
    //>>includeEnd('debug');
    const scene = this._scene;
    const ellipsoid = scene.ellipsoid ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Ellipsoid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].default;
    const transform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Transforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eastNorthUpToFixedFrame(target, ellipsoid, scratchLookAtMatrix4);
    this.lookAtTransform(transform, offset);
};
const scratchLookAtHeadingPitchRangeOffset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchLookAtHeadingPitchRangeQuaternion1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchLookAtHeadingPitchRangeQuaternion2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchHeadingPitchRangeMatrix3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function offsetFromHeadingPitchRange(heading, pitch, range) {
    pitch = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clamp(pitch, -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO);
    heading = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].zeroToTwoPi(heading) - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO;
    const pitchQuat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromAxisAngle(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_Y, -pitch, scratchLookAtHeadingPitchRangeQuaternion1);
    const headingQuat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromAxisAngle(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_Z, -heading, scratchLookAtHeadingPitchRangeQuaternion2);
    const rotQuat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiply(headingQuat, pitchQuat, headingQuat);
    const rotMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromQuaternion(rotQuat, scratchHeadingPitchRangeMatrix3);
    const offset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_X, scratchLookAtHeadingPitchRangeOffset);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByVector(rotMatrix, offset, offset);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].negate(offset, offset);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(offset, range, offset);
    return offset;
}
/**
 * Sets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range.
 * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset
 * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.
 * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
 * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.
 *
 * In 2D, there must be a top down view. The camera will be placed above the center of the reference frame. The height above the
 * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be
 * determined from the offset, the heading will be north.
 *
 * @param {Matrix4} transform The transformation matrix defining the reference frame.
 * @param {Cartesian3|HeadingPitchRange} [offset] The offset from the target in a reference frame centered at the target.
 *
 * @exception {DeveloperError} lookAtTransform is not supported while morphing.
 *
 * @example
 * // 1. Using a cartesian offset
 * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-98.0, 40.0));
 * viewer.camera.lookAtTransform(transform, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));
 *
 * // 2. Using a HeadingPitchRange offset
 * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-72.0, 40.0));
 * const heading = Cesium.Math.toRadians(50.0);
 * const pitch = Cesium.Math.toRadians(-20.0);
 * const range = 5000.0;
 * viewer.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(heading, pitch, range));
 */ Camera.prototype.lookAtTransform = function(transform, offset) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(transform)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("transform is required");
    }
    if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MORPHING) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("lookAtTransform is not supported while morphing.");
    }
    //>>includeEnd('debug');
    this._setTransform(transform);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(offset)) {
        return;
    }
    let cartesianOffset;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(offset.heading)) {
        cartesianOffset = offsetFromHeadingPitchRange(offset.heading, offset.pitch, offset.range);
    } else {
        cartesianOffset = offset;
    }
    if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ZERO, this.position);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].negate(cartesianOffset, this.up);
        this.up.z = 0.0;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].magnitudeSquared(this.up) < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EPSILON10) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_Y, this.up);
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(this.up, this.up);
        this._setTransform(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].negate(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_Z, this.direction);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(this.direction, this.up, this.right);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(this.right, this.right);
        const frustum = this.frustum;
        const ratio = frustum.top / frustum.right;
        frustum.right = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].magnitude(cartesianOffset) * 0.5;
        frustum.left = -frustum.right;
        frustum.top = ratio * frustum.right;
        frustum.bottom = -frustum.top;
        this._setTransform(transform);
        return;
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(cartesianOffset, this.position);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].negate(this.position, this.direction);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(this.direction, this.direction);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(this.direction, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_Z, this.right);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].magnitudeSquared(this.right) < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EPSILON10) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_X, this.right);
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(this.right, this.right);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(this.right, this.direction, this.up);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(this.up, this.up);
    this._adjustOrthographicFrustum(true);
};
const viewRectangle3DCartographic1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const viewRectangle3DCartographic2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const viewRectangle3DNorthEast = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const viewRectangle3DSouthWest = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const viewRectangle3DNorthWest = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const viewRectangle3DSouthEast = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const viewRectangle3DNorthCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const viewRectangle3DSouthCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const viewRectangle3DCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const viewRectangle3DEquator = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const defaultRF = {
    direction: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](),
    right: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](),
    up: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]()
};
let viewRectangle3DEllipsoidGeodesic;
function computeD(direction, upOrRight, corner, tanThetaOrPhi) {
    const opposite = Math.abs(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dot(upOrRight, corner));
    return opposite / tanThetaOrPhi - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dot(direction, corner);
}
function rectangleCameraPosition3D(camera, rectangle, result, updateCamera) {
    const ellipsoid = camera._projection.ellipsoid;
    const cameraRF = updateCamera ? camera : defaultRF;
    const { north, south, west } = rectangle;
    let { east } = rectangle;
    // If we go across the International Date Line
    if (west > east) {
        east += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TWO_PI;
    }
    // Find the midpoint latitude.
    //
    // EllipsoidGeodesic will fail if the north and south edges are very close to being on opposite sides of the ellipsoid.
    // Ideally we'd just call EllipsoidGeodesic.setEndPoints and let it throw when it detects this case, but sadly it doesn't
    // even look for this case in optimized builds, so we have to test for it here instead.
    //
    // Fortunately, this case can only happen (here) when north is very close to the north pole and south is very close to the south pole,
    // so handle it just by using 0 latitude as the center.  It's certainliy possible to use a smaller tolerance
    // than one degree here, but one degree is safe and putting the center at 0 latitude should be good enough for any
    // rectangle that spans 178+ of the 180 degrees of latitude.
    const longitude = (west + east) * 0.5;
    let latitude;
    if (south < -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RADIANS_PER_DEGREE && north > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RADIANS_PER_DEGREE) {
        latitude = 0.0;
    } else {
        const northCartographic = viewRectangle3DCartographic1;
        northCartographic.longitude = longitude;
        northCartographic.latitude = north;
        northCartographic.height = 0.0;
        const southCartographic = viewRectangle3DCartographic2;
        southCartographic.longitude = longitude;
        southCartographic.latitude = south;
        southCartographic.height = 0.0;
        let ellipsoidGeodesic = viewRectangle3DEllipsoidGeodesic;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(ellipsoidGeodesic) || ellipsoidGeodesic.ellipsoid !== ellipsoid) {
            viewRectangle3DEllipsoidGeodesic = ellipsoidGeodesic = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$EllipsoidGeodesic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](undefined, undefined, ellipsoid);
        }
        ellipsoidGeodesic.setEndPoints(northCartographic, southCartographic);
        latitude = ellipsoidGeodesic.interpolateUsingFraction(0.5, viewRectangle3DCartographic1).latitude;
    }
    const centerCartographic = viewRectangle3DCartographic1;
    centerCartographic.longitude = longitude;
    centerCartographic.latitude = latitude;
    centerCartographic.height = 0.0;
    const center = ellipsoid.cartographicToCartesian(centerCartographic, viewRectangle3DCenter);
    const cart = viewRectangle3DCartographic1;
    cart.longitude = east;
    cart.latitude = north;
    const northEast = ellipsoid.cartographicToCartesian(cart, viewRectangle3DNorthEast);
    cart.longitude = west;
    const northWest = ellipsoid.cartographicToCartesian(cart, viewRectangle3DNorthWest);
    cart.longitude = longitude;
    const northCenter = ellipsoid.cartographicToCartesian(cart, viewRectangle3DNorthCenter);
    cart.latitude = south;
    const southCenter = ellipsoid.cartographicToCartesian(cart, viewRectangle3DSouthCenter);
    cart.longitude = east;
    const southEast = ellipsoid.cartographicToCartesian(cart, viewRectangle3DSouthEast);
    cart.longitude = west;
    const southWest = ellipsoid.cartographicToCartesian(cart, viewRectangle3DSouthWest);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(northWest, center, northWest);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(southEast, center, southEast);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(northEast, center, northEast);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(southWest, center, southWest);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(northCenter, center, northCenter);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(southCenter, center, southCenter);
    const direction = ellipsoid.geodeticSurfaceNormal(center, cameraRF.direction);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].negate(direction, direction);
    const right = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(direction, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_Z, cameraRF.right);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(right, right);
    const up = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(right, direction, cameraRF.up);
    let d;
    if (camera.frustum instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$OrthographicFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
        const width = Math.max(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(northEast, northWest), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(southEast, southWest));
        const height = Math.max(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(northEast, southEast), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].distance(northWest, southWest));
        let rightScalar;
        let topScalar;
        const offCenterFrustum = camera.frustum._offCenterFrustum;
        const ratio = offCenterFrustum.right / offCenterFrustum.top;
        const heightRatio = height * ratio;
        if (width > heightRatio) {
            rightScalar = width;
            topScalar = rightScalar / ratio;
        } else {
            topScalar = height;
            rightScalar = heightRatio;
        }
        d = Math.max(rightScalar, topScalar);
    } else {
        const tanPhi = Math.tan(camera.frustum.fovy * 0.5);
        const tanTheta = camera.frustum.aspectRatio * tanPhi;
        d = Math.max(computeD(direction, up, northWest, tanPhi), computeD(direction, up, southEast, tanPhi), computeD(direction, up, northEast, tanPhi), computeD(direction, up, southWest, tanPhi), computeD(direction, up, northCenter, tanPhi), computeD(direction, up, southCenter, tanPhi), computeD(direction, right, northWest, tanTheta), computeD(direction, right, southEast, tanTheta), computeD(direction, right, northEast, tanTheta), computeD(direction, right, southWest, tanTheta), computeD(direction, right, northCenter, tanTheta), computeD(direction, right, southCenter, tanTheta));
        // If the rectangle crosses the equator, compute D at the equator, too, because that's the
        // widest part of the rectangle when projected onto the globe.
        if (south < 0 && north > 0) {
            const equatorCartographic = viewRectangle3DCartographic1;
            equatorCartographic.longitude = west;
            equatorCartographic.latitude = 0.0;
            equatorCartographic.height = 0.0;
            let equatorPosition = ellipsoid.cartographicToCartesian(equatorCartographic, viewRectangle3DEquator);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(equatorPosition, center, equatorPosition);
            d = Math.max(d, computeD(direction, up, equatorPosition, tanPhi), computeD(direction, right, equatorPosition, tanTheta));
            equatorCartographic.longitude = east;
            equatorPosition = ellipsoid.cartographicToCartesian(equatorCartographic, viewRectangle3DEquator);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(equatorPosition, center, equatorPosition);
            d = Math.max(d, computeD(direction, up, equatorPosition, tanPhi), computeD(direction, right, equatorPosition, tanTheta));
        }
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].add(center, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(direction, -d, viewRectangle3DEquator), result);
}
const viewRectangleCVCartographic = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const viewRectangleCVNorthEast = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const viewRectangleCVSouthWest = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function rectangleCameraPositionColumbusView(camera, rectangle, result) {
    const projection = camera._projection;
    if (rectangle.west > rectangle.east) {
        rectangle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MAX_VALUE;
    }
    const transform = camera._actualTransform;
    const invTransform = camera._actualInvTransform;
    const cart = viewRectangleCVCartographic;
    cart.longitude = rectangle.east;
    cart.latitude = rectangle.north;
    const northEast = projection.project(cart, viewRectangleCVNorthEast);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPoint(transform, northEast, northEast);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPoint(invTransform, northEast, northEast);
    cart.longitude = rectangle.west;
    cart.latitude = rectangle.south;
    const southWest = projection.project(cart, viewRectangleCVSouthWest);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPoint(transform, southWest, southWest);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPoint(invTransform, southWest, southWest);
    result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;
    result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(camera.frustum.fovy)) {
        const tanPhi = Math.tan(camera.frustum.fovy * 0.5);
        const tanTheta = camera.frustum.aspectRatio * tanPhi;
        result.z = Math.max((northEast.x - southWest.x) / tanTheta, (northEast.y - southWest.y) / tanPhi) * 0.5;
    } else {
        const width = northEast.x - southWest.x;
        const height = northEast.y - southWest.y;
        result.z = Math.max(width, height);
    }
    return result;
}
const viewRectangle2DCartographic = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const viewRectangle2DNorthEast = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const viewRectangle2DSouthWest = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function rectangleCameraPosition2D(camera, rectangle, result) {
    const projection = camera._projection;
    // Account for the rectangle crossing the International Date Line in 2D mode
    let east = rectangle.east;
    if (rectangle.west > rectangle.east) {
        if (camera._scene.mapMode2D === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$MapMode2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].INFINITE_SCROLL) {
            east += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TWO_PI;
        } else {
            rectangle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MAX_VALUE;
            east = rectangle.east;
        }
    }
    let cart = viewRectangle2DCartographic;
    cart.longitude = east;
    cart.latitude = rectangle.north;
    const northEast = projection.project(cart, viewRectangle2DNorthEast);
    cart.longitude = rectangle.west;
    cart.latitude = rectangle.south;
    const southWest = projection.project(cart, viewRectangle2DSouthWest);
    const width = Math.abs(northEast.x - southWest.x) * 0.5;
    let height = Math.abs(northEast.y - southWest.y) * 0.5;
    let right, top;
    const ratio = camera.frustum.right / camera.frustum.top;
    const heightRatio = height * ratio;
    if (width > heightRatio) {
        right = width;
        top = right / ratio;
    } else {
        top = height;
        right = heightRatio;
    }
    height = Math.max(2.0 * right, 2.0 * top);
    result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;
    result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;
    cart = projection.unproject(result, cart);
    cart.height = height;
    result = projection.project(cart, result);
    return result;
}
/**
 * Get the camera position needed to view a rectangle on an ellipsoid or map
 *
 * @param {Rectangle} rectangle The rectangle to view.
 * @param {Cartesian3} [result] The camera position needed to view the rectangle
 * @returns {Cartesian3} The camera position needed to view the rectangle
 */ Camera.prototype.getRectangleCameraCoordinates = function(rectangle, result) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(rectangle)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("rectangle is required");
    }
    //>>includeEnd('debug');
    const mode = this._mode;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result)) {
        result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    }
    if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE3D) {
        return rectangleCameraPosition3D(this, rectangle, result);
    } else if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COLUMBUS_VIEW) {
        return rectangleCameraPositionColumbusView(this, rectangle, result);
    } else if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        return rectangleCameraPosition2D(this, rectangle, result);
    }
    return undefined;
};
const pickEllipsoid3DRay = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Ray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function pickEllipsoid3D(camera, windowPosition, ellipsoid, result) {
    ellipsoid = ellipsoid ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Ellipsoid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].default;
    const ray = camera.getPickRay(windowPosition, pickEllipsoid3DRay);
    const intersection = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$IntersectionTests$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].rayEllipsoid(ray, ellipsoid);
    if (!intersection) {
        return undefined;
    }
    const t = intersection.start > 0.0 ? intersection.start : intersection.stop;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Ray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getPoint(ray, t, result);
}
const pickEllipsoid2DRay = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Ray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function pickMap2D(camera, windowPosition, projection, result) {
    const ray = camera.getPickRay(windowPosition, pickEllipsoid2DRay);
    let position = ray.origin;
    position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromElements(position.y, position.z, 0.0, position);
    const cart = projection.unproject(position);
    if (cart.latitude < -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO || cart.latitude > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO) {
        return undefined;
    }
    return projection.ellipsoid.cartographicToCartesian(cart, result);
}
const pickEllipsoidCVRay = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Ray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function pickMapColumbusView(camera, windowPosition, projection, result) {
    const ray = camera.getPickRay(windowPosition, pickEllipsoidCVRay);
    const scalar = -ray.origin.x / ray.direction.x;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Ray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getPoint(ray, scalar, result);
    const cart = projection.unproject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](result.y, result.z, 0.0));
    if (cart.latitude < -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO || cart.latitude > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO || cart.longitude < -Math.PI || cart.longitude > Math.PI) {
        return undefined;
    }
    return projection.ellipsoid.cartographicToCartesian(cart, result);
}
/**
 * Pick an ellipsoid or map.
 *
 * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.
 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to pick.
 * @param {Cartesian3} [result] The object onto which to store the result.
 * @returns {Cartesian3 | undefined} If the ellipsoid or map was picked,
 * returns the point on the surface of the ellipsoid or map in world
 * coordinates. If the ellipsoid or map was not picked, returns undefined.
 *
 * @example
 * const canvas = viewer.scene.canvas;
 * const center = new Cesium.Cartesian2(canvas.clientWidth / 2.0, canvas.clientHeight / 2.0);
 * const ellipsoid = viewer.scene.ellipsoid;
 * const result = viewer.camera.pickEllipsoid(center, ellipsoid);
 */ Camera.prototype.pickEllipsoid = function(windowPosition, ellipsoid, result) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(windowPosition)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("windowPosition is required.");
    }
    //>>includeEnd('debug');
    const canvas = this._scene.canvas;
    if (canvas.clientWidth === 0 || canvas.clientHeight === 0) {
        return undefined;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result)) {
        result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    }
    ellipsoid = ellipsoid ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Ellipsoid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].default;
    if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE3D) {
        result = pickEllipsoid3D(this, windowPosition, ellipsoid, result);
    } else if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        result = pickMap2D(this, windowPosition, this._projection, result);
    } else if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COLUMBUS_VIEW) {
        result = pickMapColumbusView(this, windowPosition, this._projection, result);
    } else {
        return undefined;
    }
    return result;
};
const pickPerspCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const pickPerspXDir = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const pickPerspYDir = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function getPickRayPerspective(camera, windowPosition, result) {
    const canvas = camera._scene.canvas;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const tanPhi = Math.tan(camera.frustum.fovy * 0.5);
    const tanTheta = camera.frustum.aspectRatio * tanPhi;
    const near = camera.frustum.near;
    const x = 2.0 / width * windowPosition.x - 1.0;
    const y = 2.0 / height * (height - windowPosition.y) - 1.0;
    const position = camera.positionWC;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(position, result.origin);
    const nearCenter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(camera.directionWC, near, pickPerspCenter);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].add(position, nearCenter, nearCenter);
    const xDir = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(camera.rightWC, x * near * tanTheta, pickPerspXDir);
    const yDir = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(camera.upWC, y * near * tanPhi, pickPerspYDir);
    const direction = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].add(nearCenter, xDir, result.direction);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].add(direction, yDir, direction);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(direction, position, direction);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(direction, direction);
    return result;
}
const scratchDirection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function getPickRayOrthographic(camera, windowPosition, result) {
    const canvas = camera._scene.canvas;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    let frustum = camera.frustum;
    const offCenterFrustum = frustum.offCenterFrustum;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(offCenterFrustum)) {
        frustum = offCenterFrustum;
    }
    let x = 2.0 / width * windowPosition.x - 1.0;
    x *= (frustum.right - frustum.left) * 0.5;
    let y = 2.0 / height * (height - windowPosition.y) - 1.0;
    y *= (frustum.top - frustum.bottom) * 0.5;
    const origin = result.origin;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.positionWC, origin);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(camera.rightWC, x, scratchDirection);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].add(scratchDirection, origin, origin);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(camera.upWC, y, scratchDirection);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].add(scratchDirection, origin, origin);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.directionWC, result.direction);
    return result;
}
/**
 * Create a ray from the camera position through the pixel at <code>windowPosition</code>
 * in world coordinates.
 *
 * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.
 * @param {Ray} [result] The object onto which to store the result.
 * @returns {Ray|undefined} Returns the {@link Cartesian3} position and direction of the ray, or undefined if the pick ray cannot be determined.
 */ Camera.prototype.getPickRay = function(windowPosition, result) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(windowPosition)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("windowPosition is required.");
    }
    //>>includeEnd('debug');
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result)) {
        result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Ray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    }
    const canvas = this._scene.canvas;
    if (canvas.clientWidth <= 0 || canvas.clientHeight <= 0) {
        return undefined;
    }
    const frustum = this.frustum;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(frustum.aspectRatio) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(frustum.fov) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(frustum.near)) {
        return getPickRayPerspective(this, windowPosition, result);
    }
    return getPickRayOrthographic(this, windowPosition, result);
};
const scratchToCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchProj = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
/**
 * Return the distance from the camera to the front of the bounding sphere.
 *
 * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.
 * @returns {number} The distance to the bounding sphere.
 */ Camera.prototype.distanceToBoundingSphere = function(boundingSphere) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(boundingSphere)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("boundingSphere is required.");
    }
    //>>includeEnd('debug');
    const toCenter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(this.positionWC, boundingSphere.center, scratchToCenter);
    const proj = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(this.directionWC, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dot(toCenter, this.directionWC), scratchProj);
    return Math.max(0.0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].magnitude(proj) - boundingSphere.radius);
};
const scratchPixelSize = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
/**
 * Return the pixel size in meters.
 *
 * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.
 * @param {number} drawingBufferWidth The drawing buffer width.
 * @param {number} drawingBufferHeight The drawing buffer height.
 * @returns {number} The pixel size in meters.
 */ Camera.prototype.getPixelSize = function(boundingSphere, drawingBufferWidth, drawingBufferHeight) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(boundingSphere)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("boundingSphere is required.");
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(drawingBufferWidth)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("drawingBufferWidth is required.");
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(drawingBufferHeight)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("drawingBufferHeight is required.");
    }
    //>>includeEnd('debug');
    const distance = this.distanceToBoundingSphere(boundingSphere);
    const pixelSize = this.frustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, this._scene.pixelRatio, scratchPixelSize);
    return Math.max(pixelSize.x, pixelSize.y);
};
function createAnimationTemplateCV(camera, position, center, maxX, maxY, duration) {
    const newPosition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(position);
    if (center.y > maxX) {
        newPosition.y -= center.y - maxX;
    } else if (center.y < -maxX) {
        newPosition.y += -maxX - center.y;
    }
    if (center.z > maxY) {
        newPosition.z -= center.z - maxY;
    } else if (center.z < -maxY) {
        newPosition.z += -maxY - center.z;
    }
    function updateCV(value) {
        const interp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].lerp(position, newPosition, value.time, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]());
        camera.worldToCameraCoordinatesPoint(interp, camera.position);
    }
    return {
        easingFunction: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$EasingFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EXPONENTIAL_OUT,
        startObject: {
            time: 0.0
        },
        stopObject: {
            time: 1.0
        },
        duration: duration,
        update: updateCV
    };
}
const normalScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const centerScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const posScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchCartesian3Subtract = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function createAnimationCV(camera, duration) {
    let position = camera.position;
    const direction = camera.direction;
    const normal = camera.worldToCameraCoordinatesVector(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_X, normalScratch);
    const scalar = -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dot(normal, position) / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dot(normal, direction);
    const center = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].add(position, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(direction, scalar, centerScratch), centerScratch);
    camera.cameraToWorldCoordinatesPoint(center, center);
    position = camera.cameraToWorldCoordinatesPoint(camera.position, posScratch);
    const tanPhi = Math.tan(camera.frustum.fovy * 0.5);
    const tanTheta = camera.frustum.aspectRatio * tanPhi;
    const distToC = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].magnitude(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(position, center, scratchCartesian3Subtract));
    const dWidth = tanTheta * distToC;
    const dHeight = tanPhi * distToC;
    const mapWidth = camera._maxCoord.x;
    const mapHeight = camera._maxCoord.y;
    const maxX = Math.max(dWidth - mapWidth, mapWidth);
    const maxY = Math.max(dHeight - mapHeight, mapHeight);
    if (position.z < -maxX || position.z > maxX || position.y < -maxY || position.y > maxY) {
        const translateX = center.y < -maxX || center.y > maxX;
        const translateY = center.z < -maxY || center.z > maxY;
        if (translateX || translateY) {
            return createAnimationTemplateCV(camera, position, center, maxX, maxY, duration);
        }
    }
    return undefined;
}
/**
 * Create an animation to move the map into view. This method is only valid for 2D and Columbus modes.
 *
 * @param {number} duration The duration, in seconds, of the animation.
 * @returns {object} The animation or undefined if the scene mode is 3D or the map is already ion view.
 *
 * @private
 */ Camera.prototype.createCorrectPositionTween = function(duration) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(duration)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("duration is required.");
    }
    //>>includeEnd('debug');
    if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COLUMBUS_VIEW) {
        return createAnimationCV(this, duration);
    }
    return undefined;
};
const scratchFlyToDestination = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const newOptions = {
    destination: undefined,
    heading: undefined,
    pitch: undefined,
    roll: undefined,
    duration: undefined,
    complete: undefined,
    cancel: undefined,
    endTransform: undefined,
    maximumHeight: undefined,
    easingFunction: undefined
};
/**
 * Cancels the current camera flight and leaves the camera at its current location.
 * If no flight is in progress, this function does nothing.
 */ Camera.prototype.cancelFlight = function() {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._currentFlight)) {
        this._currentFlight.cancelTween();
        this._currentFlight = undefined;
    }
};
/**
 * Completes the current camera flight and moves the camera immediately to its final destination.
 * If no flight is in progress, this function does nothing.
 */ Camera.prototype.completeFlight = function() {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._currentFlight)) {
        this._currentFlight.cancelTween();
        const options = {
            destination: undefined,
            orientation: {
                heading: undefined,
                pitch: undefined,
                roll: undefined
            }
        };
        options.destination = newOptions.destination;
        options.orientation.heading = newOptions.heading;
        options.orientation.pitch = newOptions.pitch;
        options.orientation.roll = newOptions.roll;
        this.setView(options);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._currentFlight.complete)) {
            this._currentFlight.complete();
        }
        this._currentFlight = undefined;
    }
};
/**
 * Flies the camera from its current position to a new position.
 *
 * @param {object} options Object with the following properties:
 * @param {Cartesian3|Rectangle} options.destination The final position of the camera in world coordinates or a rectangle that would be visible from a top-down view.
 * @param {object} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point
 * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive
 * y direction in Columbus view.  Orientation is not used in 2D when in infinite scrolling mode.
 * @param {number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.
 * @param {Camera.FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.
 * @param {Camera.FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.
 * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.
 * @param {number} [options.maximumHeight] The maximum height at the peak of the flight.
 * @param {number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.
 * @param {number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.
 * @param {number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.
 * @param {boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.
 * @param {EasingFunction.Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.
 *
 * @exception {DeveloperError} If either direction or up is given, then both are required.
 *
 * @example
 * // 1. Fly to a position with a top-down view
 * viewer.camera.flyTo({
 *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)
 * });
 *
 * // 2. Fly to a Rectangle with a top-down view
 * viewer.camera.flyTo({
 *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)
 * });
 *
 * // 3. Fly to a position with an orientation using unit vectors.
 * viewer.camera.flyTo({
 *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),
 *     orientation : {
 *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),
 *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)
 *     }
 * });
 *
 * // 4. Fly to a position with an orientation using heading, pitch and roll.
 * viewer.camera.flyTo({
 *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),
 *     orientation : {
 *         heading : Cesium.Math.toRadians(175.0),
 *         pitch : Cesium.Math.toRadians(-35.0),
 *         roll : 0.0
 *     }
 * });
 */ Camera.prototype.flyTo = function(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    let destination = options.destination;
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(destination)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("destination is required.");
    }
    //>>includeEnd('debug');
    const mode = this._mode;
    if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MORPHING) {
        return;
    }
    this.cancelFlight();
    const isRectangle = destination instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    if (isRectangle) {
        destination = this.getRectangleCameraCoordinates(destination, scratchFlyToDestination);
    }
    let orientation = options.orientation ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(orientation.direction)) {
        orientation = directionUpToHeadingPitchRoll(this, destination, orientation, scratchSetViewOptions.orientation);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.duration) && options.duration <= 0.0) {
        const setViewOptions = scratchSetViewOptions;
        setViewOptions.destination = options.destination;
        setViewOptions.orientation.heading = orientation.heading;
        setViewOptions.orientation.pitch = orientation.pitch;
        setViewOptions.orientation.roll = orientation.roll;
        setViewOptions.convert = options.convert;
        setViewOptions.endTransform = options.endTransform;
        this.setView(setViewOptions);
        if (typeof options.complete === "function") {
            options.complete();
        }
        return;
    }
    const that = this;
    /* eslint-disable-next-line prefer-const */ let flightTween;
    newOptions.destination = destination;
    newOptions.heading = orientation.heading;
    newOptions.pitch = orientation.pitch;
    newOptions.roll = orientation.roll;
    newOptions.duration = options.duration;
    newOptions.complete = function() {
        if (flightTween === that._currentFlight) {
            that._currentFlight = undefined;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.complete)) {
            options.complete();
        }
    };
    newOptions.cancel = options.cancel;
    newOptions.endTransform = options.endTransform;
    newOptions.convert = isRectangle ? false : options.convert;
    newOptions.maximumHeight = options.maximumHeight;
    newOptions.pitchAdjustHeight = options.pitchAdjustHeight;
    newOptions.flyOverLongitude = options.flyOverLongitude;
    newOptions.flyOverLongitudeWeight = options.flyOverLongitudeWeight;
    newOptions.easingFunction = options.easingFunction;
    const scene = this._scene;
    const tweenOptions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$CameraFlightPath$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createTween(scene, newOptions);
    // If the camera doesn't actually need to go anywhere, duration
    // will be 0 and we can just complete the current flight.
    if (tweenOptions.duration === 0) {
        if (typeof tweenOptions.complete === "function") {
            tweenOptions.complete();
        }
        return;
    }
    flightTween = scene.tweens.add(tweenOptions);
    this._currentFlight = flightTween;
    // Save the final destination view information for the PRELOAD_FLIGHT pass.
    let preloadFlightCamera = this._scene.preloadFlightCamera;
    if (this._mode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(preloadFlightCamera)) {
            preloadFlightCamera = Camera.clone(this);
        }
        preloadFlightCamera.setView({
            destination: destination,
            orientation: orientation
        });
        this._scene.preloadFlightCullingVolume = preloadFlightCamera.frustum.computeCullingVolume(preloadFlightCamera.positionWC, preloadFlightCamera.directionWC, preloadFlightCamera.upWC);
    }
};
function distanceToBoundingSphere3D(camera, radius) {
    const frustum = camera.frustum;
    const tanPhi = Math.tan(frustum.fovy * 0.5);
    const tanTheta = frustum.aspectRatio * tanPhi;
    return Math.max(radius / tanTheta, radius / tanPhi);
}
function distanceToBoundingSphere2D(camera, radius) {
    let frustum = camera.frustum;
    const offCenterFrustum = frustum.offCenterFrustum;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(offCenterFrustum)) {
        frustum = offCenterFrustum;
    }
    let right, top;
    const ratio = frustum.right / frustum.top;
    const heightRatio = radius * ratio;
    if (radius > heightRatio) {
        right = radius;
        top = right / ratio;
    } else {
        top = radius;
        right = heightRatio;
    }
    return Math.max(right, top) * 1.5;
}
const MINIMUM_ZOOM = 100.0;
function adjustBoundingSphereOffset(camera, boundingSphere, offset) {
    offset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$HeadingPitchRange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(offset) ? offset : Camera.DEFAULT_OFFSET);
    const minimumZoom = camera._scene.screenSpaceCameraController.minimumZoomDistance;
    const maximumZoom = camera._scene.screenSpaceCameraController.maximumZoomDistance;
    const range = offset.range;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(range) || range === 0.0) {
        const radius = boundingSphere.radius;
        if (radius === 0.0) {
            offset.range = MINIMUM_ZOOM;
        } else if (camera.frustum instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$OrthographicFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] || camera._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
            offset.range = distanceToBoundingSphere2D(camera, radius);
        } else {
            offset.range = distanceToBoundingSphere3D(camera, radius);
        }
        offset.range = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clamp(offset.range, minimumZoom, maximumZoom);
    }
    return offset;
}
/**
 * Sets the camera so that the current view contains the provided bounding sphere.
 *
 * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.
 * The heading and the pitch angles are defined in the local east-north-up reference frame.
 * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
 * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is
 * zero, a range will be computed such that the whole bounding sphere is visible.</p>
 *
 * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the
 * target will be the range. The heading will be determined from the offset. If the heading cannot be
 * determined from the offset, the heading will be north.</p>
 *
 * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.
 * @param {HeadingPitchRange} [offset] The offset from the target in the local east-north-up reference frame centered at the target.
 *
 * @exception {DeveloperError} viewBoundingSphere is not supported while morphing.
 */ Camera.prototype.viewBoundingSphere = function(boundingSphere, offset) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(boundingSphere)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("boundingSphere is required.");
    }
    if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MORPHING) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("viewBoundingSphere is not supported while morphing.");
    }
    //>>includeEnd('debug');
    offset = adjustBoundingSphereOffset(this, boundingSphere, offset);
    this.lookAt(boundingSphere.center, offset);
};
const scratchflyToBoundingSphereTransform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchflyToBoundingSphereDestination = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchflyToBoundingSphereDirection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchflyToBoundingSphereUp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchflyToBoundingSphereRight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchFlyToBoundingSphereCart4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchFlyToBoundingSphereQuaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchFlyToBoundingSphereMatrix3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
/**
 * Flies the camera to a location where the current view contains the provided bounding sphere.
 *
 * <p> The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.
 * The heading and the pitch angles are defined in the local east-north-up reference frame.
 * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
 * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is
 * zero, a range will be computed such that the whole bounding sphere is visible.</p>
 *
 * <p>In 2D and Columbus View, there must be a top down view. The camera will be placed above the target looking down. The height above the
 * target will be the range. The heading will be aligned to local north.</p>
 *
 * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.
 * @param {object} [options] Object with the following properties:
 * @param {number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.
 * @param {HeadingPitchRange} [options.offset] The offset from the target in the local east-north-up reference frame centered at the target.
 * @param {Camera.FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.
 * @param {Camera.FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.
 * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.
 * @param {number} [options.maximumHeight] The maximum height at the peak of the flight.
 * @param {number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.
 * @param {number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.
 * @param {number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.
 * @param {EasingFunction.Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.
 */ Camera.prototype.flyToBoundingSphere = function(boundingSphere, options) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(boundingSphere)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("boundingSphere is required.");
    }
    //>>includeEnd('debug');
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const scene2D = this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D || this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COLUMBUS_VIEW;
    this._setTransform(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY);
    const offset = adjustBoundingSphereOffset(this, boundingSphere, options.offset);
    let position;
    if (scene2D) {
        position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_Z, offset.range, scratchflyToBoundingSphereDestination);
    } else {
        position = offsetFromHeadingPitchRange(offset.heading, offset.pitch, offset.range);
    }
    const scene = this._scene;
    const ellipsoid = scene.ellipsoid ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Ellipsoid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].default;
    const transform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Transforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eastNorthUpToFixedFrame(boundingSphere.center, ellipsoid, scratchflyToBoundingSphereTransform);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPoint(transform, position, position);
    let direction;
    let up;
    if (!scene2D) {
        direction = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(boundingSphere.center, position, scratchflyToBoundingSphereDirection);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(direction, direction);
        up = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPointAsVector(transform, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_Z, scratchflyToBoundingSphereUp);
        if (1.0 - Math.abs(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dot(direction, up)) < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EPSILON6) {
            const rotateQuat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromAxisAngle(direction, offset.heading, scratchFlyToBoundingSphereQuaternion);
            const rotation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromQuaternion(rotateQuat, scratchFlyToBoundingSphereMatrix3);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromCartesian4(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getColumn(transform, 1, scratchFlyToBoundingSphereCart4), up);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByVector(rotation, up, up);
        }
        const right = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(direction, up, scratchflyToBoundingSphereRight);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(right, direction, up);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(up, up);
    }
    this.flyTo({
        destination: position,
        orientation: {
            direction: direction,
            up: up
        },
        duration: options.duration,
        complete: options.complete,
        cancel: options.cancel,
        endTransform: options.endTransform,
        maximumHeight: options.maximumHeight,
        easingFunction: options.easingFunction,
        flyOverLongitude: options.flyOverLongitude,
        flyOverLongitudeWeight: options.flyOverLongitudeWeight,
        pitchAdjustHeight: options.pitchAdjustHeight
    });
};
const scratchCartesian3_1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchCartesian3_2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchCartesian3_3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchCartesian3_4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const horizonPoints = [
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]()
];
function computeHorizonQuad(camera, ellipsoid) {
    const radii = ellipsoid.radii;
    const p = camera.positionWC;
    // Find the corresponding position in the scaled space of the ellipsoid.
    const q = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyComponents(ellipsoid.oneOverRadii, p, scratchCartesian3_1);
    const qMagnitude = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].magnitude(q);
    const qUnit = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(q, scratchCartesian3_2);
    // Determine the east and north directions at q.
    let eUnit;
    let nUnit;
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsEpsilon(qUnit, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_Z, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EPSILON10)) {
        eUnit = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 1, 0);
        nUnit = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0, 1);
    } else {
        eUnit = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_Z, qUnit, scratchCartesian3_3), scratchCartesian3_3);
        nUnit = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross(qUnit, eUnit, scratchCartesian3_4), scratchCartesian3_4);
    }
    // Determine the radius of the 'limb' of the ellipsoid.
    const wMagnitude = Math.sqrt(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].magnitudeSquared(q) - 1.0);
    // Compute the center and offsets.
    const center = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(qUnit, 1.0 / qMagnitude, scratchCartesian3_1);
    const scalar = wMagnitude / qMagnitude;
    const eastOffset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(eUnit, scalar, scratchCartesian3_2);
    const northOffset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(nUnit, scalar, scratchCartesian3_3);
    // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.
    const upperLeft = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].add(center, northOffset, horizonPoints[0]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(upperLeft, eastOffset, upperLeft);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyComponents(radii, upperLeft, upperLeft);
    const lowerLeft = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(center, northOffset, horizonPoints[1]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(lowerLeft, eastOffset, lowerLeft);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyComponents(radii, lowerLeft, lowerLeft);
    const lowerRight = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].subtract(center, northOffset, horizonPoints[2]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].add(lowerRight, eastOffset, lowerRight);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyComponents(radii, lowerRight, lowerRight);
    const upperRight = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].add(center, northOffset, horizonPoints[3]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].add(upperRight, eastOffset, upperRight);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyComponents(radii, upperRight, upperRight);
    return horizonPoints;
}
const scratchPickCartesian2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const scratchRectCartesian = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const cartoArray = [
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]()
];
function addToResult(x, y, index, camera, ellipsoid, computedHorizonQuad) {
    scratchPickCartesian2.x = x;
    scratchPickCartesian2.y = y;
    const r = camera.pickEllipsoid(scratchPickCartesian2, ellipsoid, scratchRectCartesian);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(r)) {
        cartoArray[index] = ellipsoid.cartesianToCartographic(r, cartoArray[index]);
        return 1;
    }
    cartoArray[index] = ellipsoid.cartesianToCartographic(computedHorizonQuad[index], cartoArray[index]);
    return 0;
}
/**
 * Computes the approximate visible rectangle on the ellipsoid.
 *
 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid that you want to know the visible region.
 * @param {Rectangle} [result] The rectangle in which to store the result
 *
 * @returns {Rectangle|undefined} The visible rectangle or undefined if the ellipsoid isn't visible at all.
 */ Camera.prototype.computeViewRectangle = function(ellipsoid, result) {
    ellipsoid = ellipsoid ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Ellipsoid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].default;
    const cullingVolume = this.frustum.computeCullingVolume(this.positionWC, this.directionWC, this.upWC);
    const boundingSphere = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoundingSphere$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ZERO, ellipsoid.maximumRadius);
    const visibility = cullingVolume.computeVisibility(boundingSphere);
    if (visibility === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Intersect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OUTSIDE) {
        return undefined;
    }
    const canvas = this._scene.canvas;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    let successfulPickCount = 0;
    const computedHorizonQuad = computeHorizonQuad(this, ellipsoid);
    successfulPickCount += addToResult(0, 0, 0, this, ellipsoid, computedHorizonQuad);
    successfulPickCount += addToResult(0, height, 1, this, ellipsoid, computedHorizonQuad);
    successfulPickCount += addToResult(width, height, 2, this, ellipsoid, computedHorizonQuad);
    successfulPickCount += addToResult(width, 0, 3, this, ellipsoid, computedHorizonQuad);
    if (successfulPickCount < 2) {
        // If we have space non-globe in 3 or 4 corners then return the whole globe
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MAX_VALUE;
    }
    result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromCartographicArray(cartoArray, result);
    // Detect if we go over the poles
    let distance = 0;
    let lastLon = cartoArray[3].longitude;
    for(let i = 0; i < 4; ++i){
        const lon = cartoArray[i].longitude;
        const diff = Math.abs(lon - lastLon);
        if (diff > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI) {
            // Crossed the dateline
            distance += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TWO_PI - diff;
        } else {
            distance += diff;
        }
        lastLon = lon;
    }
    // We are over one of the poles so adjust the rectangle accordingly
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsEpsilon(Math.abs(distance), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TWO_PI, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EPSILON9)) {
        result.west = -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI;
        result.east = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI;
        if (cartoArray[0].latitude >= 0.0) {
            result.north = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO;
        } else {
            result.south = -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO;
        }
    }
    return result;
};
/**
 * Switches the frustum/projection to perspective.
 *
 * This function is a no-op in 2D which must always be orthographic.
 */ Camera.prototype.switchToPerspectiveFrustum = function() {
    if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D || this.frustum instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PerspectiveFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
        return;
    }
    const scene = this._scene;
    this.frustum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PerspectiveFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this.frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;
    this.frustum.fov = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toRadians(60.0);
};
/**
 * Switches the frustum/projection to orthographic.
 *
 * This function is a no-op in 2D which will always be orthographic.
 */ Camera.prototype.switchToOrthographicFrustum = function() {
    if (this._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D || this.frustum instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$OrthographicFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
        return;
    }
    // This must be called before changing the frustum because it uses the previous
    // frustum to reconstruct the world space position from the depth buffer.
    const frustumWidth = calculateOrthographicFrustumWidth(this);
    const scene = this._scene;
    this.frustum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$OrthographicFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this.frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;
    this.frustum.width = frustumWidth;
};
/**
 * @private
 */ Camera.clone = function(camera, result) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result)) {
        result = new Camera(camera._scene);
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.position, result.position);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.direction, result.direction);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.up, result.up);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.right, result.right);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera._transform, result.transform);
    result._transformChanged = true;
    result.frustum = camera.frustum.clone();
    return result;
};
const __TURBOPACK__default__export__ = Camera;
}),
]);

//# sourceMappingURL=node_modules_%40cesium_engine_Source_Scene_Camera_3234deee.js.map