{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/numberOfComponentsForType.js"],"sourcesContent":["\n\n/**\n * Utility function for retrieving the number of components in a given type.\n *\n * @param {string} type glTF type\n * @returns {number} The number of components in that type.\n *\n * @private\n */\nfunction numberOfComponentsForType(type) {\n  switch (type) {\n    case \"SCALAR\":\n      return 1;\n    case \"VEC2\":\n      return 2;\n    case \"VEC3\":\n      return 3;\n    case \"VEC4\":\n    case \"MAT2\":\n      return 4;\n    case \"MAT3\":\n      return 9;\n    case \"MAT4\":\n      return 16;\n  }\n}\n\nexport default numberOfComponentsForType;\n"],"names":["numberOfComponentsForType","type"],"mappings":";;;;AAEA;;;;;;;CAOC,GACD,SAASA,0BAA0BC,IAAI;IACrC,OAAQA;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;QACL,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;IACX;AACF;uCAEeD","ignoreList":[0]}},
    {"offset": {"line": 37, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/getAccessorByteStride.js"],"sourcesContent":["import numberOfComponentsForType from \"./numberOfComponentsForType.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Returns the byte stride of the provided accessor.\n * If the byteStride is 0, it is calculated based on type and componentType\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {object} accessor The accessor.\n * @returns {number} The byte stride of the accessor.\n *\n * @private\n */\nfunction getAccessorByteStride(gltf, accessor) {\n  const bufferViewId = accessor.bufferView;\n  if (defined(bufferViewId)) {\n    const bufferView = gltf.bufferViews[bufferViewId];\n    if (defined(bufferView.byteStride) && bufferView.byteStride > 0) {\n      return bufferView.byteStride;\n    }\n  }\n  return (\n    ComponentDatatype.getSizeInBytes(accessor.componentType) *\n    numberOfComponentsForType(accessor.type)\n  );\n}\n\nexport default getAccessorByteStride;\n"],"names":["getAccessorByteStride","gltf","accessor","bufferViewId","bufferView","bufferViews","byteStride","getSizeInBytes","componentType","type"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;;CASC,GACD,SAASA,sBAAsBC,IAAI,EAAEC,QAAQ;IAC3C,MAAMC,eAAeD,SAASE,UAAU;IACxC,IAAI,IAAA,6KAAO,EAACD,eAAe;QACzB,MAAMC,aAAaH,KAAKI,WAAW,CAACF,aAAa;QACjD,IAAI,IAAA,6KAAO,EAACC,WAAWE,UAAU,KAAKF,WAAWE,UAAU,GAAG,GAAG;YAC/D,OAAOF,WAAWE,UAAU;QAC9B;IACF;IACA,OACE,uLAAiB,CAACC,cAAc,CAACL,SAASM,aAAa,IACvD,IAAA,gNAAyB,EAACN,SAASO,IAAI;AAE3C;uCAEeT","ignoreList":[0]}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/getComponentReader.js"],"sourcesContent":["import ComponentDatatype from \"../../Core/ComponentDatatype.js\";\n\n/**\n * Returns a function to read and convert data from a DataView into an array.\n *\n * @param {number} componentType Type to convert the data to.\n * @returns {ComponentReader} Function that reads and converts data.\n *\n * @private\n */\nfunction getComponentReader(componentType) {\n  switch (componentType) {\n    case ComponentDatatype.BYTE:\n      return function (\n        dataView,\n        byteOffset,\n        numberOfComponents,\n        componentTypeByteLength,\n        result,\n      ) {\n        for (let i = 0; i < numberOfComponents; ++i) {\n          result[i] = dataView.getInt8(\n            byteOffset + i * componentTypeByteLength,\n          );\n        }\n      };\n    case ComponentDatatype.UNSIGNED_BYTE:\n      return function (\n        dataView,\n        byteOffset,\n        numberOfComponents,\n        componentTypeByteLength,\n        result,\n      ) {\n        for (let i = 0; i < numberOfComponents; ++i) {\n          result[i] = dataView.getUint8(\n            byteOffset + i * componentTypeByteLength,\n          );\n        }\n      };\n    case ComponentDatatype.SHORT:\n      return function (\n        dataView,\n        byteOffset,\n        numberOfComponents,\n        componentTypeByteLength,\n        result,\n      ) {\n        for (let i = 0; i < numberOfComponents; ++i) {\n          result[i] = dataView.getInt16(\n            byteOffset + i * componentTypeByteLength,\n            true,\n          );\n        }\n      };\n    case ComponentDatatype.UNSIGNED_SHORT:\n      return function (\n        dataView,\n        byteOffset,\n        numberOfComponents,\n        componentTypeByteLength,\n        result,\n      ) {\n        for (let i = 0; i < numberOfComponents; ++i) {\n          result[i] = dataView.getUint16(\n            byteOffset + i * componentTypeByteLength,\n            true,\n          );\n        }\n      };\n    case ComponentDatatype.INT:\n      return function (\n        dataView,\n        byteOffset,\n        numberOfComponents,\n        componentTypeByteLength,\n        result,\n      ) {\n        for (let i = 0; i < numberOfComponents; ++i) {\n          result[i] = dataView.getInt32(\n            byteOffset + i * componentTypeByteLength,\n            true,\n          );\n        }\n      };\n    case ComponentDatatype.UNSIGNED_INT:\n      return function (\n        dataView,\n        byteOffset,\n        numberOfComponents,\n        componentTypeByteLength,\n        result,\n      ) {\n        for (let i = 0; i < numberOfComponents; ++i) {\n          result[i] = dataView.getUint32(\n            byteOffset + i * componentTypeByteLength,\n            true,\n          );\n        }\n      };\n    case ComponentDatatype.FLOAT:\n      return function (\n        dataView,\n        byteOffset,\n        numberOfComponents,\n        componentTypeByteLength,\n        result,\n      ) {\n        for (let i = 0; i < numberOfComponents; ++i) {\n          result[i] = dataView.getFloat32(\n            byteOffset + i * componentTypeByteLength,\n            true,\n          );\n        }\n      };\n    case ComponentDatatype.DOUBLE:\n      return function (\n        dataView,\n        byteOffset,\n        numberOfComponents,\n        componentTypeByteLength,\n        result,\n      ) {\n        for (let i = 0; i < numberOfComponents; ++i) {\n          result[i] = dataView.getFloat64(\n            byteOffset + i * componentTypeByteLength,\n            true,\n          );\n        }\n      };\n  }\n}\n\n/**\n * A callback function that logs messages.\n * @callback ComponentReader\n *\n * @param {DataView} dataView The data view to read from.\n * @param {number} byteOffset The byte offset applied when reading from the data view.\n * @param {number} numberOfComponents The number of components to read.\n * @param {number} componentTypeByteLength The byte length of each component.\n * @param {number} result An array storing the components that are read.\n *\n * @private\n */\n\nexport default getComponentReader;\n"],"names":["getComponentReader","componentType","BYTE","dataView","byteOffset","numberOfComponents","componentTypeByteLength","result","i","getInt8","UNSIGNED_BYTE","getUint8","SHORT","getInt16","UNSIGNED_SHORT","getUint16","INT","getInt32","UNSIGNED_INT","getUint32","FLOAT","getFloat32","DOUBLE","getFloat64"],"mappings":";;;;AAAA;;AAEA;;;;;;;CAOC,GACD,SAASA,mBAAmBC,aAAa;IACvC,OAAQA;QACN,KAAK,uLAAiB,CAACC,IAAI;YACzB,OAAO,SACLC,QAAQ,EACRC,UAAU,EACVC,kBAAkB,EAClBC,uBAAuB,EACvBC,MAAM;gBAEN,IAAK,IAAIC,IAAI,GAAGA,IAAIH,oBAAoB,EAAEG,EAAG;oBAC3CD,MAAM,CAACC,EAAE,GAAGL,SAASM,OAAO,CAC1BL,aAAaI,IAAIF;gBAErB;YACF;QACF,KAAK,uLAAiB,CAACI,aAAa;YAClC,OAAO,SACLP,QAAQ,EACRC,UAAU,EACVC,kBAAkB,EAClBC,uBAAuB,EACvBC,MAAM;gBAEN,IAAK,IAAIC,IAAI,GAAGA,IAAIH,oBAAoB,EAAEG,EAAG;oBAC3CD,MAAM,CAACC,EAAE,GAAGL,SAASQ,QAAQ,CAC3BP,aAAaI,IAAIF;gBAErB;YACF;QACF,KAAK,uLAAiB,CAACM,KAAK;YAC1B,OAAO,SACLT,QAAQ,EACRC,UAAU,EACVC,kBAAkB,EAClBC,uBAAuB,EACvBC,MAAM;gBAEN,IAAK,IAAIC,IAAI,GAAGA,IAAIH,oBAAoB,EAAEG,EAAG;oBAC3CD,MAAM,CAACC,EAAE,GAAGL,SAASU,QAAQ,CAC3BT,aAAaI,IAAIF,yBACjB;gBAEJ;YACF;QACF,KAAK,uLAAiB,CAACQ,cAAc;YACnC,OAAO,SACLX,QAAQ,EACRC,UAAU,EACVC,kBAAkB,EAClBC,uBAAuB,EACvBC,MAAM;gBAEN,IAAK,IAAIC,IAAI,GAAGA,IAAIH,oBAAoB,EAAEG,EAAG;oBAC3CD,MAAM,CAACC,EAAE,GAAGL,SAASY,SAAS,CAC5BX,aAAaI,IAAIF,yBACjB;gBAEJ;YACF;QACF,KAAK,uLAAiB,CAACU,GAAG;YACxB,OAAO,SACLb,QAAQ,EACRC,UAAU,EACVC,kBAAkB,EAClBC,uBAAuB,EACvBC,MAAM;gBAEN,IAAK,IAAIC,IAAI,GAAGA,IAAIH,oBAAoB,EAAEG,EAAG;oBAC3CD,MAAM,CAACC,EAAE,GAAGL,SAASc,QAAQ,CAC3Bb,aAAaI,IAAIF,yBACjB;gBAEJ;YACF;QACF,KAAK,uLAAiB,CAACY,YAAY;YACjC,OAAO,SACLf,QAAQ,EACRC,UAAU,EACVC,kBAAkB,EAClBC,uBAAuB,EACvBC,MAAM;gBAEN,IAAK,IAAIC,IAAI,GAAGA,IAAIH,oBAAoB,EAAEG,EAAG;oBAC3CD,MAAM,CAACC,EAAE,GAAGL,SAASgB,SAAS,CAC5Bf,aAAaI,IAAIF,yBACjB;gBAEJ;YACF;QACF,KAAK,uLAAiB,CAACc,KAAK;YAC1B,OAAO,SACLjB,QAAQ,EACRC,UAAU,EACVC,kBAAkB,EAClBC,uBAAuB,EACvBC,MAAM;gBAEN,IAAK,IAAIC,IAAI,GAAGA,IAAIH,oBAAoB,EAAEG,EAAG;oBAC3CD,MAAM,CAACC,EAAE,GAAGL,SAASkB,UAAU,CAC7BjB,aAAaI,IAAIF,yBACjB;gBAEJ;YACF;QACF,KAAK,uLAAiB,CAACgB,MAAM;YAC3B,OAAO,SACLnB,QAAQ,EACRC,UAAU,EACVC,kBAAkB,EAClBC,uBAAuB,EACvBC,MAAM;gBAEN,IAAK,IAAIC,IAAI,GAAGA,IAAIH,oBAAoB,EAAEG,EAAG;oBAC3CD,MAAM,CAACC,EAAE,GAAGL,SAASoB,UAAU,CAC7BnB,aAAaI,IAAIF,yBACjB;gBAEJ;YACF;IACJ;AACF;uCAeeN","ignoreList":[0]}},
    {"offset": {"line": 141, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/addToArray.js"],"sourcesContent":["\n\n/**\n * Adds an element to an array and returns the element's index.\n *\n * @param {Array} array The array to add to.\n * @param {object} element The element to add.\n * @param {boolean} [checkDuplicates=false] When <code>true</code>, if a duplicate element is found its index is returned and <code>element</code> is not added to the array.\n *\n * @private\n */\nfunction addToArray(array, element, checkDuplicates) {\n  checkDuplicates = checkDuplicates ?? false;\n  if (checkDuplicates) {\n    const index = array.indexOf(element);\n    if (index > -1) {\n      return index;\n    }\n  }\n\n  array.push(element);\n  return array.length - 1;\n}\n\nexport default addToArray;\n"],"names":["addToArray","array","element","checkDuplicates","index","indexOf","push","length"],"mappings":";;;;AAEA;;;;;;;;CAQC,GACD,SAASA,WAAWC,KAAK,EAAEC,OAAO,EAAEC,eAAe;IACjDA,kBAAkBA,mBAAmB;IACrC,IAAIA,iBAAiB;QACnB,MAAMC,QAAQH,MAAMI,OAAO,CAACH;QAC5B,IAAIE,QAAQ,CAAC,GAAG;YACd,OAAOA;QACT;IACF;IAEAH,MAAMK,IAAI,CAACJ;IACX,OAAOD,MAAMM,MAAM,GAAG;AACxB;uCAEeP","ignoreList":[0]}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/usesExtension.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\n\n/**\n * Checks whether the glTF uses the given extension.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {string} extension The name of the extension.\n * @returns {boolean} Whether the glTF uses the given extension.\n *\n * @private\n */\nfunction usesExtension(gltf, extension) {\n  return (\n    defined(gltf.extensionsUsed) && gltf.extensionsUsed.indexOf(extension) >= 0\n  );\n}\n\nexport default usesExtension;\n"],"names":["usesExtension","gltf","extension","extensionsUsed","indexOf"],"mappings":";;;;AAAA;;AAEA;;;;;;;;CAQC,GACD,SAASA,cAAcC,IAAI,EAAEC,SAAS;IACpC,OACE,IAAA,6KAAO,EAACD,KAAKE,cAAc,KAAKF,KAAKE,cAAc,CAACC,OAAO,CAACF,cAAc;AAE9E;uCAEeF","ignoreList":[0]}},
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/ForEach.js"],"sourcesContent":["import usesExtension from \"./usesExtension.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Contains traversal functions for processing elements of the glTF hierarchy.\n * @constructor\n *\n * @private\n */\nfunction ForEach() {}\n\n/**\n * Fallback for glTF 1.0\n * @private\n */\nForEach.objectLegacy = function (objects, handler) {\n  if (defined(objects)) {\n    for (const objectId in objects) {\n      if (Object.prototype.hasOwnProperty.call(objects, objectId)) {\n        const object = objects[objectId];\n        const value = handler(object, objectId);\n\n        if (defined(value)) {\n          return value;\n        }\n      }\n    }\n  }\n};\n\n/**\n * @private\n */\nForEach.object = function (arrayOfObjects, handler) {\n  if (defined(arrayOfObjects)) {\n    const length = arrayOfObjects.length;\n    for (let i = 0; i < length; i++) {\n      const object = arrayOfObjects[i];\n      const value = handler(object, i);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\n/**\n * Supports glTF 1.0 and 2.0\n * @private\n */\nForEach.topLevel = function (gltf, name, handler) {\n  const gltfProperty = gltf[name];\n  if (defined(gltfProperty) && !Array.isArray(gltfProperty)) {\n    return ForEach.objectLegacy(gltfProperty, handler);\n  }\n\n  return ForEach.object(gltfProperty, handler);\n};\n\nForEach.accessor = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"accessors\", handler);\n};\n\nForEach.accessorWithSemantic = function (gltf, semantic, handler) {\n  const visited = {};\n  return ForEach.mesh(gltf, function (mesh) {\n    return ForEach.meshPrimitive(mesh, function (primitive) {\n      const valueForEach = ForEach.meshPrimitiveAttribute(\n        primitive,\n        function (accessorId, attributeSemantic) {\n          if (\n            attributeSemantic.indexOf(semantic) === 0 &&\n            !defined(visited[accessorId])\n          ) {\n            visited[accessorId] = true;\n            const value = handler(accessorId);\n\n            if (defined(value)) {\n              return value;\n            }\n          }\n        },\n      );\n\n      if (defined(valueForEach)) {\n        return valueForEach;\n      }\n\n      return ForEach.meshPrimitiveTarget(primitive, function (target) {\n        return ForEach.meshPrimitiveTargetAttribute(\n          target,\n          function (accessorId, attributeSemantic) {\n            if (\n              attributeSemantic.indexOf(semantic) === 0 &&\n              !defined(visited[accessorId])\n            ) {\n              visited[accessorId] = true;\n              const value = handler(accessorId);\n\n              if (defined(value)) {\n                return value;\n              }\n            }\n          },\n        );\n      });\n    });\n  });\n};\n\nForEach.accessorContainingVertexAttributeData = function (gltf, handler) {\n  const visited = {};\n  return ForEach.mesh(gltf, function (mesh) {\n    return ForEach.meshPrimitive(mesh, function (primitive) {\n      const valueForEach = ForEach.meshPrimitiveAttribute(\n        primitive,\n        function (accessorId) {\n          if (!defined(visited[accessorId])) {\n            visited[accessorId] = true;\n            const value = handler(accessorId);\n\n            if (defined(value)) {\n              return value;\n            }\n          }\n        },\n      );\n\n      if (defined(valueForEach)) {\n        return valueForEach;\n      }\n\n      return ForEach.meshPrimitiveTarget(primitive, function (target) {\n        return ForEach.meshPrimitiveTargetAttribute(\n          target,\n          function (accessorId) {\n            if (!defined(visited[accessorId])) {\n              visited[accessorId] = true;\n              const value = handler(accessorId);\n\n              if (defined(value)) {\n                return value;\n              }\n            }\n          },\n        );\n      });\n    });\n  });\n};\n\nForEach.accessorContainingIndexData = function (gltf, handler) {\n  const visited = {};\n  return ForEach.mesh(gltf, function (mesh) {\n    return ForEach.meshPrimitive(mesh, function (primitive) {\n      const indices = primitive.indices;\n      if (defined(indices) && !defined(visited[indices])) {\n        visited[indices] = true;\n        const value = handler(indices);\n\n        if (defined(value)) {\n          return value;\n        }\n      }\n    });\n  });\n};\n\nForEach.animation = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"animations\", handler);\n};\n\nForEach.animationChannel = function (animation, handler) {\n  const channels = animation.channels;\n  return ForEach.object(channels, handler);\n};\n\nForEach.animationSampler = function (animation, handler) {\n  const samplers = animation.samplers;\n  return ForEach.object(samplers, handler);\n};\n\nForEach.buffer = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"buffers\", handler);\n};\n\nForEach.bufferView = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"bufferViews\", handler);\n};\n\nForEach.camera = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"cameras\", handler);\n};\n\nForEach.image = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"images\", handler);\n};\n\nForEach.material = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"materials\", handler);\n};\n\nForEach.materialValue = function (material, handler) {\n  let values = material.values;\n  if (\n    defined(material.extensions) &&\n    defined(material.extensions.KHR_techniques_webgl)\n  ) {\n    values = material.extensions.KHR_techniques_webgl.values;\n  }\n\n  for (const name in values) {\n    if (Object.prototype.hasOwnProperty.call(values, name)) {\n      const value = handler(values[name], name);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.mesh = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"meshes\", handler);\n};\n\nForEach.meshPrimitive = function (mesh, handler) {\n  const primitives = mesh.primitives;\n  if (defined(primitives)) {\n    const primitivesLength = primitives.length;\n    for (let i = 0; i < primitivesLength; i++) {\n      const primitive = primitives[i];\n      const value = handler(primitive, i);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.meshPrimitiveAttribute = function (primitive, handler) {\n  const attributes = primitive.attributes;\n  for (const semantic in attributes) {\n    if (Object.prototype.hasOwnProperty.call(attributes, semantic)) {\n      const value = handler(attributes[semantic], semantic);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.meshPrimitiveTarget = function (primitive, handler) {\n  const targets = primitive.targets;\n  if (defined(targets)) {\n    const length = targets.length;\n    for (let i = 0; i < length; ++i) {\n      const value = handler(targets[i], i);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.meshPrimitiveTargetAttribute = function (target, handler) {\n  for (const semantic in target) {\n    if (Object.prototype.hasOwnProperty.call(target, semantic)) {\n      const accessorId = target[semantic];\n      const value = handler(accessorId, semantic);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.node = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"nodes\", handler);\n};\n\nForEach.nodeInTree = function (gltf, nodeIds, handler) {\n  const nodes = gltf.nodes;\n  if (defined(nodes)) {\n    const length = nodeIds.length;\n    for (let i = 0; i < length; i++) {\n      const nodeId = nodeIds[i];\n      const node = nodes[nodeId];\n      if (defined(node)) {\n        let value = handler(node, nodeId);\n\n        if (defined(value)) {\n          return value;\n        }\n\n        const children = node.children;\n        if (defined(children)) {\n          value = ForEach.nodeInTree(gltf, children, handler);\n\n          if (defined(value)) {\n            return value;\n          }\n        }\n      }\n    }\n  }\n};\n\nForEach.nodeInScene = function (gltf, scene, handler) {\n  const sceneNodeIds = scene.nodes;\n  if (defined(sceneNodeIds)) {\n    return ForEach.nodeInTree(gltf, sceneNodeIds, handler);\n  }\n};\n\nForEach.program = function (gltf, handler) {\n  if (usesExtension(gltf, \"KHR_techniques_webgl\")) {\n    return ForEach.object(\n      gltf.extensions.KHR_techniques_webgl.programs,\n      handler,\n    );\n  }\n\n  return ForEach.topLevel(gltf, \"programs\", handler);\n};\n\nForEach.sampler = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"samplers\", handler);\n};\n\nForEach.scene = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"scenes\", handler);\n};\n\nForEach.shader = function (gltf, handler) {\n  if (usesExtension(gltf, \"KHR_techniques_webgl\")) {\n    return ForEach.object(\n      gltf.extensions.KHR_techniques_webgl.shaders,\n      handler,\n    );\n  }\n\n  return ForEach.topLevel(gltf, \"shaders\", handler);\n};\n\nForEach.skin = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"skins\", handler);\n};\n\nForEach.skinJoint = function (skin, handler) {\n  const joints = skin.joints;\n  if (defined(joints)) {\n    const jointsLength = joints.length;\n    for (let i = 0; i < jointsLength; i++) {\n      const joint = joints[i];\n      const value = handler(joint);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.techniqueAttribute = function (technique, handler) {\n  const attributes = technique.attributes;\n  for (const attributeName in attributes) {\n    if (Object.prototype.hasOwnProperty.call(attributes, attributeName)) {\n      const value = handler(attributes[attributeName], attributeName);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.techniqueUniform = function (technique, handler) {\n  const uniforms = technique.uniforms;\n  for (const uniformName in uniforms) {\n    if (Object.prototype.hasOwnProperty.call(uniforms, uniformName)) {\n      const value = handler(uniforms[uniformName], uniformName);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.techniqueParameter = function (technique, handler) {\n  const parameters = technique.parameters;\n  for (const parameterName in parameters) {\n    if (Object.prototype.hasOwnProperty.call(parameters, parameterName)) {\n      const value = handler(parameters[parameterName], parameterName);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.technique = function (gltf, handler) {\n  if (usesExtension(gltf, \"KHR_techniques_webgl\")) {\n    return ForEach.object(\n      gltf.extensions.KHR_techniques_webgl.techniques,\n      handler,\n    );\n  }\n\n  return ForEach.topLevel(gltf, \"techniques\", handler);\n};\n\nForEach.texture = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"textures\", handler);\n};\n\nexport default ForEach;\n"],"names":["ForEach","objectLegacy","objects","handler","objectId","Object","prototype","hasOwnProperty","call","object","value","arrayOfObjects","length","i","topLevel","gltf","name","gltfProperty","Array","isArray","accessor","accessorWithSemantic","semantic","visited","mesh","meshPrimitive","primitive","valueForEach","meshPrimitiveAttribute","accessorId","attributeSemantic","indexOf","meshPrimitiveTarget","target","meshPrimitiveTargetAttribute","accessorContainingVertexAttributeData","accessorContainingIndexData","indices","animation","animationChannel","channels","animationSampler","samplers","buffer","bufferView","camera","image","material","materialValue","values","extensions","KHR_techniques_webgl","primitives","primitivesLength","attributes","targets","node","nodeInTree","nodeIds","nodes","nodeId","children","nodeInScene","scene","sceneNodeIds","program","programs","sampler","shader","shaders","skin","skinJoint","joints","jointsLength","joint","techniqueAttribute","technique","attributeName","techniqueUniform","uniforms","uniformName","techniqueParameter","parameters","parameterName","techniques","texture"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 526, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/addDefaults.js"],"sourcesContent":["import addToArray from \"./addToArray.js\";\nimport ForEach from \"./ForEach.js\";\nimport getAccessorByteStride from \"./getAccessorByteStride.js\";\nimport defined from \"../../Core/defined.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\n\n/**\n * Adds default glTF values if they don't exist.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @returns {object} The modified glTF.\n *\n * @private\n */\nfunction addDefaults(gltf) {\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      accessor.byteOffset = accessor.byteOffset ?? 0;\n    }\n  });\n\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer)) {\n      bufferView.byteOffset = bufferView.byteOffset ?? 0;\n    }\n  });\n\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      primitive.mode = primitive.mode ?? WebGLConstants.TRIANGLES;\n      if (!defined(primitive.material)) {\n        if (!defined(gltf.materials)) {\n          gltf.materials = [];\n        }\n        const defaultMaterial = {\n          name: \"default\",\n        };\n        primitive.material = addToArray(gltf.materials, defaultMaterial);\n      }\n    });\n  });\n\n  ForEach.accessorContainingVertexAttributeData(gltf, function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    const bufferViewId = accessor.bufferView;\n    accessor.normalized = accessor.normalized ?? false;\n    if (defined(bufferViewId)) {\n      const bufferView = gltf.bufferViews[bufferViewId];\n      bufferView.byteStride = getAccessorByteStride(gltf, accessor);\n      bufferView.target = WebGLConstants.ARRAY_BUFFER;\n    }\n  });\n\n  ForEach.accessorContainingIndexData(gltf, function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    const bufferViewId = accessor.bufferView;\n    if (defined(bufferViewId)) {\n      const bufferView = gltf.bufferViews[bufferViewId];\n      bufferView.target = WebGLConstants.ELEMENT_ARRAY_BUFFER;\n    }\n  });\n\n  ForEach.material(gltf, function (material) {\n    const extensions = material.extensions ?? {};\n    const materialsCommon = extensions.KHR_materials_common;\n    if (defined(materialsCommon)) {\n      const technique = materialsCommon.technique;\n      const values = defined(materialsCommon.values)\n        ? materialsCommon.values\n        : {};\n      materialsCommon.values = values;\n\n      values.ambient = defined(values.ambient)\n        ? values.ambient\n        : [0.0, 0.0, 0.0, 1.0];\n      values.emission = defined(values.emission)\n        ? values.emission\n        : [0.0, 0.0, 0.0, 1.0];\n\n      values.transparency = values.transparency ?? 1.0;\n\n      if (technique !== \"CONSTANT\") {\n        values.diffuse = defined(values.diffuse)\n          ? values.diffuse\n          : [0.0, 0.0, 0.0, 1.0];\n        if (technique !== \"LAMBERT\") {\n          values.specular = defined(values.specular)\n            ? values.specular\n            : [0.0, 0.0, 0.0, 1.0];\n          values.shininess = values.shininess ?? 0.0;\n        }\n      }\n\n      // These actually exist on the extension object, not the values object despite what's shown in the spec\n      materialsCommon.transparent = materialsCommon.transparent ?? false;\n      materialsCommon.doubleSided = materialsCommon.doubleSided ?? false;\n\n      return;\n    }\n\n    material.emissiveFactor = material.emissiveFactor ?? [0.0, 0.0, 0.0];\n    material.alphaMode = material.alphaMode ?? \"OPAQUE\";\n    material.doubleSided = material.doubleSided ?? false;\n\n    if (material.alphaMode === \"MASK\") {\n      material.alphaCutoff = material.alphaCutoff ?? 0.5;\n    }\n\n    const techniquesExtension = extensions.KHR_techniques_webgl;\n    if (defined(techniquesExtension)) {\n      ForEach.materialValue(material, function (materialValue) {\n        // Check if material value is a TextureInfo object\n        if (defined(materialValue.index)) {\n          addTextureDefaults(materialValue);\n        }\n      });\n    }\n\n    addTextureDefaults(material.emissiveTexture);\n    addTextureDefaults(material.normalTexture);\n    addTextureDefaults(material.occlusionTexture);\n\n    const pbrMetallicRoughness = material.pbrMetallicRoughness;\n    if (defined(pbrMetallicRoughness)) {\n      pbrMetallicRoughness.baseColorFactor =\n        pbrMetallicRoughness.baseColorFactor ?? [1.0, 1.0, 1.0, 1.0];\n      pbrMetallicRoughness.metallicFactor =\n        pbrMetallicRoughness.metallicFactor ?? 1.0;\n      pbrMetallicRoughness.roughnessFactor =\n        pbrMetallicRoughness.roughnessFactor ?? 1.0;\n      addTextureDefaults(pbrMetallicRoughness.baseColorTexture);\n      addTextureDefaults(pbrMetallicRoughness.metallicRoughnessTexture);\n    }\n\n    const pbrSpecularGlossiness =\n      extensions.KHR_materials_pbrSpecularGlossiness;\n    if (defined(pbrSpecularGlossiness)) {\n      pbrSpecularGlossiness.diffuseFactor =\n        pbrSpecularGlossiness.diffuseFactor ?? [1.0, 1.0, 1.0, 1.0];\n      pbrSpecularGlossiness.specularFactor =\n        pbrSpecularGlossiness.specularFactor ?? [1.0, 1.0, 1.0];\n      pbrSpecularGlossiness.glossinessFactor =\n        pbrSpecularGlossiness.glossinessFactor ?? 1.0;\n      addTextureDefaults(pbrSpecularGlossiness.specularGlossinessTexture);\n    }\n  });\n\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      sampler.interpolation = sampler.interpolation ?? \"LINEAR\";\n    });\n  });\n\n  const animatedNodes = getAnimatedNodes(gltf);\n  ForEach.node(gltf, function (node, id) {\n    const animated = defined(animatedNodes[id]);\n    if (\n      animated ||\n      defined(node.translation) ||\n      defined(node.rotation) ||\n      defined(node.scale)\n    ) {\n      node.translation = node.translation ?? [0.0, 0.0, 0.0];\n      node.rotation = node.rotation ?? [0.0, 0.0, 0.0, 1.0];\n      node.scale = node.scale ?? [1.0, 1.0, 1.0];\n    } else {\n      node.matrix = node.matrix ?? [\n        1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0,\n      ];\n    }\n  });\n\n  ForEach.sampler(gltf, function (sampler) {\n    sampler.wrapS = sampler.wrapS ?? WebGLConstants.REPEAT;\n    sampler.wrapT = sampler.wrapT ?? WebGLConstants.REPEAT;\n  });\n\n  if (defined(gltf.scenes) && !defined(gltf.scene)) {\n    gltf.scene = 0;\n  }\n\n  return gltf;\n}\n\nfunction getAnimatedNodes(gltf) {\n  const nodes = {};\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationChannel(animation, function (channel) {\n      const target = channel.target;\n      const nodeId = target.node;\n      const path = target.path;\n      // Ignore animations that target 'weights'\n      if (path === \"translation\" || path === \"rotation\" || path === \"scale\") {\n        nodes[nodeId] = true;\n      }\n    });\n  });\n  return nodes;\n}\n\nfunction addTextureDefaults(texture) {\n  if (defined(texture)) {\n    texture.texCoord = texture.texCoord ?? 0;\n  }\n}\n\nexport default addDefaults;\n"],"names":["addDefaults","gltf","accessor","bufferView","byteOffset","buffer","mesh","meshPrimitive","primitive","mode","TRIANGLES","material","materials","defaultMaterial","name","accessorContainingVertexAttributeData","accessorId","accessors","bufferViewId","normalized","bufferViews","byteStride","target","ARRAY_BUFFER","accessorContainingIndexData","ELEMENT_ARRAY_BUFFER","extensions","materialsCommon","KHR_materials_common","technique","values","ambient","emission","transparency","diffuse","specular","shininess","transparent","doubleSided","emissiveFactor","alphaMode","alphaCutoff","techniquesExtension","KHR_techniques_webgl","materialValue","index","addTextureDefaults","emissiveTexture","normalTexture","occlusionTexture","pbrMetallicRoughness","baseColorFactor","metallicFactor","roughnessFactor","baseColorTexture","metallicRoughnessTexture","pbrSpecularGlossiness","KHR_materials_pbrSpecularGlossiness","diffuseFactor","specularFactor","glossinessFactor","specularGlossinessTexture","animation","animationSampler","sampler","interpolation","animatedNodes","getAnimatedNodes","node","id","animated","translation","rotation","scale","matrix","wrapS","REPEAT","wrapT","scenes","scene","nodes","animationChannel","channel","nodeId","path","texture","texCoord"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 764, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/addPipelineExtras.js"],"sourcesContent":["import ForEach from \"./ForEach.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Adds extras._pipeline to each object that can have extras in the glTF asset.\n * This stage runs before updateVersion and handles both glTF 1.0 and glTF 2.0 assets.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @returns {object} The glTF asset with the added pipeline extras.\n *\n * @private\n */\nfunction addPipelineExtras(gltf) {\n  ForEach.shader(gltf, function (shader) {\n    addExtras(shader);\n  });\n  ForEach.buffer(gltf, function (buffer) {\n    addExtras(buffer);\n  });\n  ForEach.image(gltf, function (image) {\n    addExtras(image);\n  });\n\n  addExtras(gltf);\n\n  return gltf;\n}\n\nfunction addExtras(object) {\n  object.extras = defined(object.extras) ? object.extras : {};\n  object.extras._pipeline = defined(object.extras._pipeline)\n    ? object.extras._pipeline\n    : {};\n}\n\nexport default addPipelineExtras;\n"],"names":["addPipelineExtras","gltf","shader","addExtras","buffer","image","object","extras","_pipeline"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;;CAQC,GACD,SAASA,kBAAkBC,IAAI;IAC7B,8LAAO,CAACC,MAAM,CAACD,MAAM,SAAUC,MAAM;QACnCC,UAAUD;IACZ;IACA,8LAAO,CAACE,MAAM,CAACH,MAAM,SAAUG,MAAM;QACnCD,UAAUC;IACZ;IACA,8LAAO,CAACC,KAAK,CAACJ,MAAM,SAAUI,KAAK;QACjCF,UAAUE;IACZ;IAEAF,UAAUF;IAEV,OAAOA;AACT;AAEA,SAASE,UAAUG,MAAM;IACvBA,OAAOC,MAAM,GAAG,IAAA,6KAAO,EAACD,OAAOC,MAAM,IAAID,OAAOC,MAAM,GAAG,CAAC;IAC1DD,OAAOC,MAAM,CAACC,SAAS,GAAG,IAAA,6KAAO,EAACF,OAAOC,MAAM,CAACC,SAAS,IACrDF,OAAOC,MAAM,CAACC,SAAS,GACvB,CAAC;AACP;uCAEeR","ignoreList":[0]}},
    {"offset": {"line": 802, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/removeExtensionsRequired.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\n\n/**\n * Removes an extension from gltf.extensionsRequired if it is present.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {string} extension The extension to remove.\n *\n * @private\n */\nfunction removeExtensionsRequired(gltf, extension) {\n  const extensionsRequired = gltf.extensionsRequired;\n  if (defined(extensionsRequired)) {\n    const index = extensionsRequired.indexOf(extension);\n    if (index >= 0) {\n      extensionsRequired.splice(index, 1);\n    }\n    if (extensionsRequired.length === 0) {\n      delete gltf.extensionsRequired;\n    }\n  }\n}\n\nexport default removeExtensionsRequired;\n"],"names":["removeExtensionsRequired","gltf","extension","extensionsRequired","index","indexOf","splice","length"],"mappings":";;;;AAAA;;AAEA;;;;;;;CAOC,GACD,SAASA,yBAAyBC,IAAI,EAAEC,SAAS;IAC/C,MAAMC,qBAAqBF,KAAKE,kBAAkB;IAClD,IAAI,IAAA,6KAAO,EAACA,qBAAqB;QAC/B,MAAMC,QAAQD,mBAAmBE,OAAO,CAACH;QACzC,IAAIE,SAAS,GAAG;YACdD,mBAAmBG,MAAM,CAACF,OAAO;QACnC;QACA,IAAID,mBAAmBI,MAAM,KAAK,GAAG;YACnC,OAAON,KAAKE,kBAAkB;QAChC;IACF;AACF;uCAEeH","ignoreList":[0]}},
    {"offset": {"line": 832, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/removeExtensionsUsed.js"],"sourcesContent":["import removeExtensionsRequired from \"./removeExtensionsRequired.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Removes an extension from gltf.extensionsUsed and gltf.extensionsRequired if it is present.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {string} extension The extension to remove.\n *\n * @private\n */\nfunction removeExtensionsUsed(gltf, extension) {\n  const extensionsUsed = gltf.extensionsUsed;\n  if (defined(extensionsUsed)) {\n    const index = extensionsUsed.indexOf(extension);\n    if (index >= 0) {\n      extensionsUsed.splice(index, 1);\n    }\n    removeExtensionsRequired(gltf, extension);\n    if (extensionsUsed.length === 0) {\n      delete gltf.extensionsUsed;\n    }\n  }\n}\n\nexport default removeExtensionsUsed;\n"],"names":["removeExtensionsUsed","gltf","extension","extensionsUsed","index","indexOf","splice","length"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;CAOC,GACD,SAASA,qBAAqBC,IAAI,EAAEC,SAAS;IAC3C,MAAMC,iBAAiBF,KAAKE,cAAc;IAC1C,IAAI,IAAA,6KAAO,EAACA,iBAAiB;QAC3B,MAAMC,QAAQD,eAAeE,OAAO,CAACH;QACrC,IAAIE,SAAS,GAAG;YACdD,eAAeG,MAAM,CAACF,OAAO;QAC/B;QACA,IAAA,+MAAwB,EAACH,MAAMC;QAC/B,IAAIC,eAAeI,MAAM,KAAK,GAAG;YAC/B,OAAON,KAAKE,cAAc;QAC5B;IACF;AACF;uCAEeH","ignoreList":[0]}},
    {"offset": {"line": 865, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/parseGlb.js"],"sourcesContent":["import addPipelineExtras from \"./addPipelineExtras.js\";\nimport removeExtensionsUsed from \"./removeExtensionsUsed.js\";\nimport defined from \"../../Core/defined.js\";\nimport getMagic from \"../../Core/getMagic.js\";\nimport getStringFromTypedArray from \"../../Core/getStringFromTypedArray.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\n\nconst sizeOfUint32 = 4;\n\n/**\n * Convert a binary glTF to glTF.\n *\n * The returned glTF has pipeline extras included. The embedded binary data is stored in gltf.buffers[0].extras._pipeline.source.\n *\n * @param {Buffer} glb The glb data to parse.\n * @returns {object} A javascript object containing a glTF asset with pipeline extras included.\n *\n * @private\n */\nfunction parseGlb(glb) {\n  // Check that the magic string is present\n  const magic = getMagic(glb);\n  if (magic !== \"glTF\") {\n    throw new RuntimeError(\"File is not valid binary glTF\");\n  }\n\n  const header = readHeader(glb, 0, 5);\n  const version = header[1];\n  if (version !== 1 && version !== 2) {\n    throw new RuntimeError(\"Binary glTF version is not 1 or 2\");\n  }\n\n  if (version === 1) {\n    return parseGlbVersion1(glb, header);\n  }\n\n  return parseGlbVersion2(glb, header);\n}\n\nfunction readHeader(glb, byteOffset, count) {\n  const dataView = new DataView(glb.buffer);\n  const header = new Array(count);\n  for (let i = 0; i < count; ++i) {\n    header[i] = dataView.getUint32(\n      glb.byteOffset + byteOffset + i * sizeOfUint32,\n      true,\n    );\n  }\n  return header;\n}\n\nfunction parseGlbVersion1(glb, header) {\n  const length = header[2];\n  const contentLength = header[3];\n  const contentFormat = header[4];\n\n  // Check that the content format is 0, indicating that it is JSON\n  if (contentFormat !== 0) {\n    throw new RuntimeError(\"Binary glTF scene format is not JSON\");\n  }\n\n  const jsonStart = 20;\n  const binaryStart = jsonStart + contentLength;\n\n  const contentString = getStringFromTypedArray(glb, jsonStart, contentLength);\n  const gltf = JSON.parse(contentString);\n  addPipelineExtras(gltf);\n\n  const binaryBuffer = glb.subarray(binaryStart, length);\n\n  const buffers = gltf.buffers;\n  if (defined(buffers) && Object.keys(buffers).length > 0) {\n    // In some older models, the binary glTF buffer is named KHR_binary_glTF\n    const binaryGltfBuffer = buffers.binary_glTF ?? buffers.KHR_binary_glTF;\n    if (defined(binaryGltfBuffer)) {\n      binaryGltfBuffer.extras._pipeline.source = binaryBuffer;\n      delete binaryGltfBuffer.uri;\n    }\n  }\n  // Remove the KHR_binary_glTF extension\n  removeExtensionsUsed(gltf, \"KHR_binary_glTF\");\n  return gltf;\n}\n\nfunction parseGlbVersion2(glb, header) {\n  const length = header[2];\n  let byteOffset = 12;\n  let gltf;\n  let binaryBuffer;\n  while (byteOffset < length) {\n    const chunkHeader = readHeader(glb, byteOffset, 2);\n    const chunkLength = chunkHeader[0];\n    const chunkType = chunkHeader[1];\n    byteOffset += 8;\n    const chunkBuffer = glb.subarray(byteOffset, byteOffset + chunkLength);\n    byteOffset += chunkLength;\n    // Load JSON chunk\n    if (chunkType === 0x4e4f534a) {\n      const jsonString = getStringFromTypedArray(chunkBuffer);\n      gltf = JSON.parse(jsonString);\n      addPipelineExtras(gltf);\n    }\n    // Load Binary chunk\n    else if (chunkType === 0x004e4942) {\n      binaryBuffer = chunkBuffer;\n    }\n  }\n  if (defined(gltf) && defined(binaryBuffer)) {\n    const buffers = gltf.buffers;\n    if (defined(buffers) && buffers.length > 0) {\n      const buffer = buffers[0];\n      buffer.extras._pipeline.source = binaryBuffer;\n    }\n  }\n  return gltf;\n}\n\nexport default parseGlb;\n"],"names":["sizeOfUint32","parseGlb","glb","magic","header","readHeader","version","parseGlbVersion1","parseGlbVersion2","byteOffset","count","dataView","DataView","buffer","Array","i","getUint32","length","contentLength","contentFormat","jsonStart","binaryStart","contentString","gltf","JSON","parse","binaryBuffer","subarray","buffers","Object","keys","binaryGltfBuffer","binary_glTF","KHR_binary_glTF","extras","_pipeline","source","uri","chunkHeader","chunkLength","chunkType","chunkBuffer","jsonString"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEA,MAAMA,eAAe;AAErB;;;;;;;;;CASC,GACD,SAASC,SAASC,GAAG;IACnB,yCAAyC;IACzC,MAAMC,QAAQ,IAAA,8KAAQ,EAACD;IACvB,IAAIC,UAAU,QAAQ;QACpB,MAAM,IAAI,kLAAY,CAAC;IACzB;IAEA,MAAMC,SAASC,WAAWH,KAAK,GAAG;IAClC,MAAMI,UAAUF,MAAM,CAAC,EAAE;IACzB,IAAIE,YAAY,KAAKA,YAAY,GAAG;QAClC,MAAM,IAAI,kLAAY,CAAC;IACzB;IAEA,IAAIA,YAAY,GAAG;QACjB,OAAOC,iBAAiBL,KAAKE;IAC/B;IAEA,OAAOI,iBAAiBN,KAAKE;AAC/B;AAEA,SAASC,WAAWH,GAAG,EAAEO,UAAU,EAAEC,KAAK;IACxC,MAAMC,WAAW,IAAIC,SAASV,IAAIW,MAAM;IACxC,MAAMT,SAAS,IAAIU,MAAMJ;IACzB,IAAK,IAAIK,IAAI,GAAGA,IAAIL,OAAO,EAAEK,EAAG;QAC9BX,MAAM,CAACW,EAAE,GAAGJ,SAASK,SAAS,CAC5Bd,IAAIO,UAAU,GAAGA,aAAaM,IAAIf,cAClC;IAEJ;IACA,OAAOI;AACT;AAEA,SAASG,iBAAiBL,GAAG,EAAEE,MAAM;IACnC,MAAMa,SAASb,MAAM,CAAC,EAAE;IACxB,MAAMc,gBAAgBd,MAAM,CAAC,EAAE;IAC/B,MAAMe,gBAAgBf,MAAM,CAAC,EAAE;IAE/B,iEAAiE;IACjE,IAAIe,kBAAkB,GAAG;QACvB,MAAM,IAAI,kLAAY,CAAC;IACzB;IAEA,MAAMC,YAAY;IAClB,MAAMC,cAAcD,YAAYF;IAEhC,MAAMI,gBAAgB,IAAA,6LAAuB,EAACpB,KAAKkB,WAAWF;IAC9D,MAAMK,OAAOC,KAAKC,KAAK,CAACH;IACxB,IAAA,wMAAiB,EAACC;IAElB,MAAMG,eAAexB,IAAIyB,QAAQ,CAACN,aAAaJ;IAE/C,MAAMW,UAAUL,KAAKK,OAAO;IAC5B,IAAI,IAAA,6KAAO,EAACA,YAAYC,OAAOC,IAAI,CAACF,SAASX,MAAM,GAAG,GAAG;QACvD,wEAAwE;QACxE,MAAMc,mBAAmBH,QAAQI,WAAW,IAAIJ,QAAQK,eAAe;QACvE,IAAI,IAAA,6KAAO,EAACF,mBAAmB;YAC7BA,iBAAiBG,MAAM,CAACC,SAAS,CAACC,MAAM,GAAGV;YAC3C,OAAOK,iBAAiBM,GAAG;QAC7B;IACF;IACA,uCAAuC;IACvC,IAAA,2MAAoB,EAACd,MAAM;IAC3B,OAAOA;AACT;AAEA,SAASf,iBAAiBN,GAAG,EAAEE,MAAM;IACnC,MAAMa,SAASb,MAAM,CAAC,EAAE;IACxB,IAAIK,aAAa;IACjB,IAAIc;IACJ,IAAIG;IACJ,MAAOjB,aAAaQ,OAAQ;QAC1B,MAAMqB,cAAcjC,WAAWH,KAAKO,YAAY;QAChD,MAAM8B,cAAcD,WAAW,CAAC,EAAE;QAClC,MAAME,YAAYF,WAAW,CAAC,EAAE;QAChC7B,cAAc;QACd,MAAMgC,cAAcvC,IAAIyB,QAAQ,CAAClB,YAAYA,aAAa8B;QAC1D9B,cAAc8B;QACd,kBAAkB;QAClB,IAAIC,cAAc,YAAY;YAC5B,MAAME,aAAa,IAAA,6LAAuB,EAACD;YAC3ClB,OAAOC,KAAKC,KAAK,CAACiB;YAClB,IAAA,wMAAiB,EAACnB;QACpB,OAEK,IAAIiB,cAAc,YAAY;YACjCd,eAAee;QACjB;IACF;IACA,IAAI,IAAA,6KAAO,EAAClB,SAAS,IAAA,6KAAO,EAACG,eAAe;QAC1C,MAAME,UAAUL,KAAKK,OAAO;QAC5B,IAAI,IAAA,6KAAO,EAACA,YAAYA,QAAQX,MAAM,GAAG,GAAG;YAC1C,MAAMJ,SAASe,OAAO,CAAC,EAAE;YACzBf,OAAOqB,MAAM,CAACC,SAAS,CAACC,MAAM,GAAGV;QACnC;IACF;IACA,OAAOH;AACT;uCAEetB","ignoreList":[0]}},
    {"offset": {"line": 977, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/removePipelineExtras.js"],"sourcesContent":["import ForEach from \"./ForEach.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Iterate through the objects within the glTF and delete their pipeline extras object.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @returns {object} glTF with no pipeline extras.\n *\n * @private\n */\nfunction removePipelineExtras(gltf) {\n  ForEach.shader(gltf, function (shader) {\n    removeExtras(shader);\n  });\n  ForEach.buffer(gltf, function (buffer) {\n    removeExtras(buffer);\n  });\n  ForEach.image(gltf, function (image) {\n    removeExtras(image);\n  });\n\n  removeExtras(gltf);\n\n  return gltf;\n}\n\nfunction removeExtras(object) {\n  if (!defined(object.extras)) {\n    return;\n  }\n\n  if (defined(object.extras._pipeline)) {\n    delete object.extras._pipeline;\n  }\n\n  if (Object.keys(object.extras).length === 0) {\n    delete object.extras;\n  }\n}\n\nexport default removePipelineExtras;\n"],"names":["removePipelineExtras","gltf","shader","removeExtras","buffer","image","object","extras","_pipeline","Object","keys","length"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;CAOC,GACD,SAASA,qBAAqBC,IAAI;IAChC,8LAAO,CAACC,MAAM,CAACD,MAAM,SAAUC,MAAM;QACnCC,aAAaD;IACf;IACA,8LAAO,CAACE,MAAM,CAACH,MAAM,SAAUG,MAAM;QACnCD,aAAaC;IACf;IACA,8LAAO,CAACC,KAAK,CAACJ,MAAM,SAAUI,KAAK;QACjCF,aAAaE;IACf;IAEAF,aAAaF;IAEb,OAAOA;AACT;AAEA,SAASE,aAAaG,MAAM;IAC1B,IAAI,CAAC,IAAA,6KAAO,EAACA,OAAOC,MAAM,GAAG;QAC3B;IACF;IAEA,IAAI,IAAA,6KAAO,EAACD,OAAOC,MAAM,CAACC,SAAS,GAAG;QACpC,OAAOF,OAAOC,MAAM,CAACC,SAAS;IAChC;IAEA,IAAIC,OAAOC,IAAI,CAACJ,OAAOC,MAAM,EAAEI,MAAM,KAAK,GAAG;QAC3C,OAAOL,OAAOC,MAAM;IACtB;AACF;uCAEeP","ignoreList":[0]}},
    {"offset": {"line": 1021, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/addExtensionsUsed.js"],"sourcesContent":["import addToArray from \"./addToArray.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Adds an extension to gltf.extensionsUsed if it does not already exist.\n * Initializes extensionsUsed if it is not defined.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {string} extension The extension to add.\n *\n * @private\n */\nfunction addExtensionsUsed(gltf, extension) {\n  let extensionsUsed = gltf.extensionsUsed;\n  if (!defined(extensionsUsed)) {\n    extensionsUsed = [];\n    gltf.extensionsUsed = extensionsUsed;\n  }\n  addToArray(extensionsUsed, extension, true);\n}\n\nexport default addExtensionsUsed;\n"],"names":["addExtensionsUsed","gltf","extension","extensionsUsed"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;;CAQC,GACD,SAASA,kBAAkBC,IAAI,EAAEC,SAAS;IACxC,IAAIC,iBAAiBF,KAAKE,cAAc;IACxC,IAAI,CAAC,IAAA,6KAAO,EAACA,iBAAiB;QAC5BA,iBAAiB,EAAE;QACnBF,KAAKE,cAAc,GAAGA;IACxB;IACA,IAAA,iMAAU,EAACA,gBAAgBD,WAAW;AACxC;uCAEeF","ignoreList":[0]}},
    {"offset": {"line": 1050, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/findAccessorMinMax.js"],"sourcesContent":["import getAccessorByteStride from \"./getAccessorByteStride.js\";\nimport getComponentReader from \"./getComponentReader.js\";\nimport numberOfComponentsForType from \"./numberOfComponentsForType.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Finds the min and max values of the accessor.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {object} accessor The accessor object from the glTF asset to read.\n * @returns {{min: Array, max: Array}} min holding the array of minimum values and max holding the array of maximum values.\n *\n * @private\n */\nfunction findAccessorMinMax(gltf, accessor) {\n  const bufferViews = gltf.bufferViews;\n  const buffers = gltf.buffers;\n  const bufferViewId = accessor.bufferView;\n  const numberOfComponents = numberOfComponentsForType(accessor.type);\n\n  // According to the spec, when bufferView is not defined, accessor must be initialized with zeros\n  if (!defined(accessor.bufferView)) {\n    return {\n      min: new Array(numberOfComponents).fill(0.0),\n      max: new Array(numberOfComponents).fill(0.0),\n    };\n  }\n\n  const min = new Array(numberOfComponents).fill(Number.POSITIVE_INFINITY);\n  const max = new Array(numberOfComponents).fill(Number.NEGATIVE_INFINITY);\n\n  const bufferView = bufferViews[bufferViewId];\n  const bufferId = bufferView.buffer;\n  const buffer = buffers[bufferId];\n  const source = buffer.extras._pipeline.source;\n\n  const count = accessor.count;\n  const byteStride = getAccessorByteStride(gltf, accessor);\n  let byteOffset =\n    accessor.byteOffset + bufferView.byteOffset + source.byteOffset;\n  const componentType = accessor.componentType;\n  const componentTypeByteLength =\n    ComponentDatatype.getSizeInBytes(componentType);\n  const dataView = new DataView(source.buffer);\n  const components = new Array(numberOfComponents);\n  const componentReader = getComponentReader(componentType);\n\n  for (let i = 0; i < count; i++) {\n    componentReader(\n      dataView,\n      byteOffset,\n      numberOfComponents,\n      componentTypeByteLength,\n      components,\n    );\n    for (let j = 0; j < numberOfComponents; j++) {\n      const value = components[j];\n      min[j] = Math.min(min[j], value);\n      max[j] = Math.max(max[j], value);\n    }\n    byteOffset += byteStride;\n  }\n\n  return {\n    min: min,\n    max: max,\n  };\n}\n\nexport default findAccessorMinMax;\n"],"names":["findAccessorMinMax","gltf","accessor","bufferViews","buffers","bufferViewId","bufferView","numberOfComponents","type","min","Array","fill","max","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","bufferId","buffer","source","extras","_pipeline","count","byteStride","byteOffset","componentType","componentTypeByteLength","getSizeInBytes","dataView","DataView","components","componentReader","i","j","value","Math"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;CAQC,GACD,SAASA,mBAAmBC,IAAI,EAAEC,QAAQ;IACxC,MAAMC,cAAcF,KAAKE,WAAW;IACpC,MAAMC,UAAUH,KAAKG,OAAO;IAC5B,MAAMC,eAAeH,SAASI,UAAU;IACxC,MAAMC,qBAAqB,IAAA,gNAAyB,EAACL,SAASM,IAAI;IAElE,iGAAiG;IACjG,IAAI,CAAC,IAAA,6KAAO,EAACN,SAASI,UAAU,GAAG;QACjC,OAAO;YACLG,KAAK,IAAIC,MAAMH,oBAAoBI,IAAI,CAAC;YACxCC,KAAK,IAAIF,MAAMH,oBAAoBI,IAAI,CAAC;QAC1C;IACF;IAEA,MAAMF,MAAM,IAAIC,MAAMH,oBAAoBI,IAAI,CAACE,OAAOC,iBAAiB;IACvE,MAAMF,MAAM,IAAIF,MAAMH,oBAAoBI,IAAI,CAACE,OAAOE,iBAAiB;IAEvE,MAAMT,aAAaH,WAAW,CAACE,aAAa;IAC5C,MAAMW,WAAWV,WAAWW,MAAM;IAClC,MAAMA,SAASb,OAAO,CAACY,SAAS;IAChC,MAAME,SAASD,OAAOE,MAAM,CAACC,SAAS,CAACF,MAAM;IAE7C,MAAMG,QAAQnB,SAASmB,KAAK;IAC5B,MAAMC,aAAa,IAAA,4MAAqB,EAACrB,MAAMC;IAC/C,IAAIqB,aACFrB,SAASqB,UAAU,GAAGjB,WAAWiB,UAAU,GAAGL,OAAOK,UAAU;IACjE,MAAMC,gBAAgBtB,SAASsB,aAAa;IAC5C,MAAMC,0BACJ,uLAAiB,CAACC,cAAc,CAACF;IACnC,MAAMG,WAAW,IAAIC,SAASV,OAAOD,MAAM;IAC3C,MAAMY,aAAa,IAAInB,MAAMH;IAC7B,MAAMuB,kBAAkB,IAAA,yMAAkB,EAACN;IAE3C,IAAK,IAAIO,IAAI,GAAGA,IAAIV,OAAOU,IAAK;QAC9BD,gBACEH,UACAJ,YACAhB,oBACAkB,yBACAI;QAEF,IAAK,IAAIG,IAAI,GAAGA,IAAIzB,oBAAoByB,IAAK;YAC3C,MAAMC,QAAQJ,UAAU,CAACG,EAAE;YAC3BvB,GAAG,CAACuB,EAAE,GAAGE,KAAKzB,GAAG,CAACA,GAAG,CAACuB,EAAE,EAAEC;YAC1BrB,GAAG,CAACoB,EAAE,GAAGE,KAAKtB,GAAG,CAACA,GAAG,CAACoB,EAAE,EAAEC;QAC5B;QACAV,cAAcD;IAChB;IAEA,OAAO;QACLb,KAAKA;QACLG,KAAKA;IACP;AACF;uCAEeZ","ignoreList":[0]}},
    {"offset": {"line": 1117, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/moveTechniqueRenderStates.js"],"sourcesContent":["import addExtensionsUsed from \"./addExtensionsUsed.js\";\nimport ForEach from \"./ForEach.js\";\nimport defined from \"../../Core/defined.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\n\nconst defaultBlendEquation = [WebGLConstants.FUNC_ADD, WebGLConstants.FUNC_ADD];\n\nconst defaultBlendFactors = [\n  WebGLConstants.ONE,\n  WebGLConstants.ZERO,\n  WebGLConstants.ONE,\n  WebGLConstants.ZERO,\n];\n\nfunction isStateEnabled(renderStates, state) {\n  const enabled = renderStates.enable;\n  if (!defined(enabled)) {\n    return false;\n  }\n\n  return enabled.indexOf(state) > -1;\n}\n\nconst supportedBlendFactors = [\n  WebGLConstants.ZERO,\n  WebGLConstants.ONE,\n  WebGLConstants.SRC_COLOR,\n  WebGLConstants.ONE_MINUS_SRC_COLOR,\n  WebGLConstants.SRC_ALPHA,\n  WebGLConstants.ONE_MINUS_SRC_ALPHA,\n  WebGLConstants.DST_ALPHA,\n  WebGLConstants.ONE_MINUS_DST_ALPHA,\n  WebGLConstants.DST_COLOR,\n  WebGLConstants.ONE_MINUS_DST_COLOR,\n];\n\n// If any of the blend factors are not supported, return the default\nfunction getSupportedBlendFactors(value, defaultValue) {\n  if (!defined(value)) {\n    return defaultValue;\n  }\n\n  for (let i = 0; i < 4; i++) {\n    if (supportedBlendFactors.indexOf(value[i]) === -1) {\n      return defaultValue;\n    }\n  }\n\n  return value;\n}\n\n/**\n * Move glTF 1.0 technique render states to glTF 2.0 materials properties and KHR_blend extension.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @returns {object} The updated glTF asset.\n *\n * @private\n */\nfunction moveTechniqueRenderStates(gltf) {\n  const blendingForTechnique = {};\n  const materialPropertiesForTechnique = {};\n  const techniquesLegacy = gltf.techniques;\n  if (!defined(techniquesLegacy)) {\n    return gltf;\n  }\n\n  ForEach.technique(gltf, function (techniqueLegacy, techniqueIndex) {\n    const renderStates = techniqueLegacy.states;\n    if (defined(renderStates)) {\n      const materialProperties = (materialPropertiesForTechnique[\n        techniqueIndex\n      ] = {});\n\n      // If BLEND is enabled, the material should have alpha mode BLEND\n      if (isStateEnabled(renderStates, WebGLConstants.BLEND)) {\n        materialProperties.alphaMode = \"BLEND\";\n\n        const blendFunctions = renderStates.functions;\n        if (\n          defined(blendFunctions) &&\n          (defined(blendFunctions.blendEquationSeparate) ||\n            defined(blendFunctions.blendFuncSeparate))\n        ) {\n          blendingForTechnique[techniqueIndex] = {\n            blendEquation:\n              blendFunctions.blendEquationSeparate ?? defaultBlendEquation,\n            blendFactors: getSupportedBlendFactors(\n              blendFunctions.blendFuncSeparate,\n              defaultBlendFactors,\n            ),\n          };\n        }\n      }\n\n      // If CULL_FACE is not enabled, the material should be doubleSided\n      if (!isStateEnabled(renderStates, WebGLConstants.CULL_FACE)) {\n        materialProperties.doubleSided = true;\n      }\n\n      delete techniqueLegacy.states;\n    }\n  });\n\n  if (Object.keys(blendingForTechnique).length > 0) {\n    if (!defined(gltf.extensions)) {\n      gltf.extensions = {};\n    }\n\n    addExtensionsUsed(gltf, \"KHR_blend\");\n  }\n\n  ForEach.material(gltf, function (material) {\n    if (defined(material.technique)) {\n      const materialProperties =\n        materialPropertiesForTechnique[material.technique];\n      ForEach.objectLegacy(materialProperties, function (value, property) {\n        material[property] = value;\n      });\n\n      const blending = blendingForTechnique[material.technique];\n      if (defined(blending)) {\n        if (!defined(material.extensions)) {\n          material.extensions = {};\n        }\n\n        material.extensions.KHR_blend = blending;\n      }\n    }\n  });\n\n  return gltf;\n}\n\nexport default moveTechniqueRenderStates;\n"],"names":["defaultBlendEquation","FUNC_ADD","defaultBlendFactors","ONE","ZERO","isStateEnabled","renderStates","state","enabled","enable","indexOf","supportedBlendFactors","SRC_COLOR","ONE_MINUS_SRC_COLOR","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","DST_ALPHA","ONE_MINUS_DST_ALPHA","DST_COLOR","ONE_MINUS_DST_COLOR","getSupportedBlendFactors","value","defaultValue","i","moveTechniqueRenderStates","gltf","blendingForTechnique","materialPropertiesForTechnique","techniquesLegacy","techniques","technique","techniqueLegacy","techniqueIndex","states","materialProperties","BLEND","alphaMode","blendFunctions","functions","blendEquationSeparate","blendFuncSeparate","blendEquation","blendFactors","CULL_FACE","doubleSided","Object","keys","length","extensions","material","objectLegacy","property","blending","KHR_blend"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1234, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/addExtensionsRequired.js"],"sourcesContent":["import addExtensionsUsed from \"./addExtensionsUsed.js\";\nimport addToArray from \"./addToArray.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Adds an extension to gltf.extensionsRequired if it does not already exist.\n * Initializes extensionsRequired if it is not defined.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {string} extension The extension to add.\n *\n * @private\n */\nfunction addExtensionsRequired(gltf, extension) {\n  let extensionsRequired = gltf.extensionsRequired;\n  if (!defined(extensionsRequired)) {\n    extensionsRequired = [];\n    gltf.extensionsRequired = extensionsRequired;\n  }\n  addToArray(extensionsRequired, extension, true);\n  addExtensionsUsed(gltf, extension);\n}\n\nexport default addExtensionsRequired;\n"],"names":["addExtensionsRequired","gltf","extension","extensionsRequired"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;CAQC,GACD,SAASA,sBAAsBC,IAAI,EAAEC,SAAS;IAC5C,IAAIC,qBAAqBF,KAAKE,kBAAkB;IAChD,IAAI,CAAC,IAAA,6KAAO,EAACA,qBAAqB;QAChCA,qBAAqB,EAAE;QACvBF,KAAKE,kBAAkB,GAAGA;IAC5B;IACA,IAAA,iMAAU,EAACA,oBAAoBD,WAAW;IAC1C,IAAA,wMAAiB,EAACD,MAAMC;AAC1B;uCAEeF","ignoreList":[0]}},
    {"offset": {"line": 1266, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/moveTechniquesToExtension.js"],"sourcesContent":["import addExtensionsUsed from \"./addExtensionsUsed.js\";\nimport addExtensionsRequired from \"./addExtensionsRequired.js\";\nimport addToArray from \"./addToArray.js\";\nimport ForEach from \"./ForEach.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Move glTF 1.0 material techniques to glTF 2.0 KHR_techniques_webgl extension.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @returns {object} The updated glTF asset.\n *\n * @private\n */\nfunction moveTechniquesToExtension(gltf) {\n  const techniquesLegacy = gltf.techniques;\n  const mappedUniforms = {};\n  const updatedTechniqueIndices = {};\n  const seenPrograms = {};\n  if (defined(techniquesLegacy)) {\n    const extension = {\n      programs: [],\n      shaders: [],\n      techniques: [],\n    };\n\n    // Some 1.1 models have a glExtensionsUsed property that can be transferred to program.glExtensions\n    const glExtensions = gltf.glExtensionsUsed;\n    delete gltf.glExtensionsUsed;\n\n    ForEach.technique(gltf, function (techniqueLegacy, techniqueId) {\n      const technique = {\n        name: techniqueLegacy.name,\n        program: undefined,\n        attributes: {},\n        uniforms: {},\n      };\n\n      let parameterLegacy;\n      ForEach.techniqueAttribute(\n        techniqueLegacy,\n        function (parameterName, attributeName) {\n          parameterLegacy = techniqueLegacy.parameters[parameterName];\n          technique.attributes[attributeName] = {\n            semantic: parameterLegacy.semantic,\n          };\n        },\n      );\n\n      ForEach.techniqueUniform(\n        techniqueLegacy,\n        function (parameterName, uniformName) {\n          parameterLegacy = techniqueLegacy.parameters[parameterName];\n          technique.uniforms[uniformName] = {\n            count: parameterLegacy.count,\n            node: parameterLegacy.node,\n            type: parameterLegacy.type,\n            semantic: parameterLegacy.semantic,\n            value: parameterLegacy.value,\n          };\n\n          // Store the name of the uniform to update material values.\n          if (!defined(mappedUniforms[techniqueId])) {\n            mappedUniforms[techniqueId] = {};\n          }\n          mappedUniforms[techniqueId][parameterName] = uniformName;\n        },\n      );\n\n      if (!defined(seenPrograms[techniqueLegacy.program])) {\n        const programLegacy = gltf.programs[techniqueLegacy.program];\n\n        const program = {\n          name: programLegacy.name,\n          fragmentShader: undefined,\n          vertexShader: undefined,\n          glExtensions: glExtensions,\n        };\n\n        const fs = gltf.shaders[programLegacy.fragmentShader];\n        program.fragmentShader = addToArray(extension.shaders, fs, true);\n\n        const vs = gltf.shaders[programLegacy.vertexShader];\n        program.vertexShader = addToArray(extension.shaders, vs, true);\n\n        technique.program = addToArray(extension.programs, program);\n        seenPrograms[techniqueLegacy.program] = technique.program;\n      } else {\n        technique.program = seenPrograms[techniqueLegacy.program];\n      }\n\n      // Store the index of the new technique to reference instead.\n      updatedTechniqueIndices[techniqueId] = addToArray(\n        extension.techniques,\n        technique,\n      );\n    });\n\n    if (extension.techniques.length > 0) {\n      if (!defined(gltf.extensions)) {\n        gltf.extensions = {};\n      }\n\n      gltf.extensions.KHR_techniques_webgl = extension;\n      addExtensionsUsed(gltf, \"KHR_techniques_webgl\");\n      addExtensionsRequired(gltf, \"KHR_techniques_webgl\");\n    }\n  }\n\n  ForEach.material(gltf, function (material) {\n    if (defined(material.technique)) {\n      const materialExtension = {\n        technique: updatedTechniqueIndices[material.technique],\n      };\n\n      ForEach.objectLegacy(material.values, function (value, parameterName) {\n        if (!defined(materialExtension.values)) {\n          materialExtension.values = {};\n        }\n\n        const uniformName = mappedUniforms[material.technique][parameterName];\n        if (defined(uniformName)) {\n          materialExtension.values[uniformName] = value;\n        }\n      });\n\n      if (!defined(material.extensions)) {\n        material.extensions = {};\n      }\n\n      material.extensions.KHR_techniques_webgl = materialExtension;\n    }\n\n    delete material.technique;\n    delete material.values;\n  });\n\n  delete gltf.techniques;\n  delete gltf.programs;\n  delete gltf.shaders;\n\n  return gltf;\n}\n\nexport default moveTechniquesToExtension;\n"],"names":["moveTechniquesToExtension","gltf","techniquesLegacy","techniques","mappedUniforms","updatedTechniqueIndices","seenPrograms","extension","programs","shaders","glExtensions","glExtensionsUsed","technique","techniqueLegacy","techniqueId","name","program","undefined","attributes","uniforms","parameterLegacy","techniqueAttribute","parameterName","attributeName","parameters","semantic","techniqueUniform","uniformName","count","node","type","value","programLegacy","fragmentShader","vertexShader","fs","vs","length","extensions","KHR_techniques_webgl","material","materialExtension","objectLegacy","values"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1391, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/forEachTextureInMaterial.js"],"sourcesContent":["import ForEach from \"./ForEach.js\";\nimport Check from \"../../Core/Check.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Calls the provider handler function on each texture used by the material.\n * Mimics the behavior of functions in gltf-pipeline ForEach.\n * @param {object} material The glTF material.\n * @param {forEachTextureInMaterial~handler} handler Function that is called for each texture in the material.\n *\n * @private\n */\nfunction forEachTextureInMaterial(material, handler) {\n  Check.typeOf.object(\"material\", material);\n  Check.defined(\"handler\", handler);\n\n  // Metallic roughness\n  const pbrMetallicRoughness = material.pbrMetallicRoughness;\n  if (defined(pbrMetallicRoughness)) {\n    if (defined(pbrMetallicRoughness.baseColorTexture)) {\n      const textureInfo = pbrMetallicRoughness.baseColorTexture;\n      const value = handler(textureInfo.index, textureInfo);\n      if (defined(value)) {\n        return value;\n      }\n    }\n    if (defined(pbrMetallicRoughness.metallicRoughnessTexture)) {\n      const textureInfo = pbrMetallicRoughness.metallicRoughnessTexture;\n      const value = handler(textureInfo.index, textureInfo);\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n\n  const { extensions } = material;\n  if (defined(extensions)) {\n    // Spec gloss extension\n    const pbrSpecularGlossiness =\n      extensions.KHR_materials_pbrSpecularGlossiness;\n    if (defined(pbrSpecularGlossiness)) {\n      if (defined(pbrSpecularGlossiness.diffuseTexture)) {\n        const textureInfo = pbrSpecularGlossiness.diffuseTexture;\n        const value = handler(textureInfo.index, textureInfo);\n        if (defined(value)) {\n          return value;\n        }\n      }\n      if (defined(pbrSpecularGlossiness.specularGlossinessTexture)) {\n        const textureInfo = pbrSpecularGlossiness.specularGlossinessTexture;\n        const value = handler(textureInfo.index, textureInfo);\n        if (defined(value)) {\n          return value;\n        }\n      }\n    }\n\n    // Specular extension\n    const specular = extensions.KHR_materials_specular;\n    if (defined(specular)) {\n      const { specularTexture, specularColorTexture } = specular;\n      if (defined(specularTexture)) {\n        const value = handler(specularTexture.index, specularTexture);\n        if (defined(value)) {\n          return value;\n        }\n      }\n      if (defined(specularColorTexture)) {\n        const value = handler(specularColorTexture.index, specularColorTexture);\n        if (defined(value)) {\n          return value;\n        }\n      }\n    }\n\n    // Materials common extension (may be present in models converted from glTF 1.0)\n    const materialsCommon = extensions.KHR_materials_common;\n    if (defined(materialsCommon) && defined(materialsCommon.values)) {\n      const { diffuse, ambient, emission, specular } = materialsCommon.values;\n      if (defined(diffuse) && defined(diffuse.index)) {\n        const value = handler(diffuse.index, diffuse);\n        if (defined(value)) {\n          return value;\n        }\n      }\n      if (defined(ambient) && defined(ambient.index)) {\n        const value = handler(ambient.index, ambient);\n        if (defined(value)) {\n          return value;\n        }\n      }\n      if (defined(emission) && defined(emission.index)) {\n        const value = handler(emission.index, emission);\n        if (defined(value)) {\n          return value;\n        }\n      }\n      if (defined(specular) && defined(specular.index)) {\n        const value = handler(specular.index, specular);\n        if (defined(value)) {\n          return value;\n        }\n      }\n    }\n  }\n\n  // KHR_techniques_webgl extension\n  const value = ForEach.materialValue(material, function (materialValue) {\n    if (defined(materialValue.index)) {\n      const value = handler(materialValue.index, materialValue);\n      if (defined(value)) {\n        return value;\n      }\n    }\n  });\n  if (defined(value)) {\n    return value;\n  }\n\n  // Top level textures\n  if (defined(material.emissiveTexture)) {\n    const textureInfo = material.emissiveTexture;\n    const value = handler(textureInfo.index, textureInfo);\n    if (defined(value)) {\n      return value;\n    }\n  }\n\n  if (defined(material.normalTexture)) {\n    const textureInfo = material.normalTexture;\n    const value = handler(textureInfo.index, textureInfo);\n    if (defined(value)) {\n      return value;\n    }\n  }\n\n  if (defined(material.occlusionTexture)) {\n    const textureInfo = material.occlusionTexture;\n    const value = handler(textureInfo.index, textureInfo);\n    if (defined(value)) {\n      return value;\n    }\n  }\n}\n\n/**\n * Function that is called for each texture in the material. If this function returns a value the for each stops and returns that value.\n * @callback forEachTextureInMaterial~handler\n * @param {number} The texture index.\n * @param {object} The texture info object.\n *\n * @private\n */\n\nexport default forEachTextureInMaterial;\n"],"names":["forEachTextureInMaterial","material","handler","typeOf","object","defined","pbrMetallicRoughness","baseColorTexture","textureInfo","value","index","metallicRoughnessTexture","extensions","pbrSpecularGlossiness","KHR_materials_pbrSpecularGlossiness","diffuseTexture","specularGlossinessTexture","specular","KHR_materials_specular","specularTexture","specularColorTexture","materialsCommon","KHR_materials_common","values","diffuse","ambient","emission","materialValue","emissiveTexture","normalTexture","occlusionTexture"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1536, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/removeUnusedElements.js"],"sourcesContent":["import ForEach from \"./ForEach.js\";\nimport forEachTextureInMaterial from \"./forEachTextureInMaterial.js\";\nimport usesExtension from \"./usesExtension.js\";\nimport defined from \"../../Core/defined.js\";\n\nconst allElementTypes = [\n  \"mesh\",\n  \"node\",\n  \"material\",\n  \"accessor\",\n  \"bufferView\",\n  \"buffer\",\n  \"texture\",\n  \"sampler\",\n  \"image\",\n];\n\n/**\n * Removes unused elements from gltf.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {string[]} [elementTypes=['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer']] Element types to be removed. Needs to be a subset of ['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer'], other items will be ignored.\n *\n * @private\n */\nfunction removeUnusedElements(gltf, elementTypes) {\n  elementTypes = elementTypes ?? allElementTypes;\n  allElementTypes.forEach(function (type) {\n    if (elementTypes.indexOf(type) > -1) {\n      removeUnusedElementsByType(gltf, type);\n    }\n  });\n  return gltf;\n}\n\nconst TypeToGltfElementName = {\n  accessor: \"accessors\",\n  buffer: \"buffers\",\n  bufferView: \"bufferViews\",\n  image: \"images\",\n  node: \"nodes\",\n  material: \"materials\",\n  mesh: \"meshes\",\n  sampler: \"samplers\",\n  texture: \"textures\",\n};\n\nfunction removeUnusedElementsByType(gltf, type) {\n  const name = TypeToGltfElementName[type];\n  const arrayOfObjects = gltf[name];\n\n  if (defined(arrayOfObjects)) {\n    let removed = 0;\n    const usedIds = getListOfElementsIdsInUse[type](gltf);\n    const length = arrayOfObjects.length;\n\n    for (let i = 0; i < length; ++i) {\n      if (!usedIds[i]) {\n        Remove[type](gltf, i - removed);\n        removed++;\n      }\n    }\n  }\n}\n\n/**\n * Contains functions for removing elements from a glTF hierarchy.\n * Since top-level glTF elements are arrays, when something is removed, referring\n * indices need to be updated.\n * @constructor\n *\n * @private\n */\nfunction Remove() {}\n\nRemove.accessor = function (gltf, accessorId) {\n  const accessors = gltf.accessors;\n\n  accessors.splice(accessorId, 1);\n\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      // Update accessor ids for the primitives.\n      ForEach.meshPrimitiveAttribute(\n        primitive,\n        function (attributeAccessorId, semantic) {\n          if (attributeAccessorId > accessorId) {\n            primitive.attributes[semantic]--;\n          }\n        },\n      );\n\n      // Update accessor ids for the targets.\n      ForEach.meshPrimitiveTarget(primitive, function (target) {\n        ForEach.meshPrimitiveTargetAttribute(\n          target,\n          function (attributeAccessorId, semantic) {\n            if (attributeAccessorId > accessorId) {\n              target[semantic]--;\n            }\n          },\n        );\n      });\n      const indices = primitive.indices;\n      if (defined(indices) && indices > accessorId) {\n        primitive.indices--;\n      }\n\n      const ext = primitive.extensions;\n      if (\n        defined(ext) &&\n        defined(ext.CESIUM_primitive_outline) &&\n        ext.CESIUM_primitive_outline.indices > accessorId\n      ) {\n        --ext.CESIUM_primitive_outline.indices;\n      }\n    });\n  });\n\n  ForEach.skin(gltf, function (skin) {\n    if (\n      defined(skin.inverseBindMatrices) &&\n      skin.inverseBindMatrices > accessorId\n    ) {\n      skin.inverseBindMatrices--;\n    }\n  });\n\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      if (defined(sampler.input) && sampler.input > accessorId) {\n        sampler.input--;\n      }\n      if (defined(sampler.output) && sampler.output > accessorId) {\n        sampler.output--;\n      }\n    });\n  });\n};\n\nRemove.buffer = function (gltf, bufferId) {\n  const buffers = gltf.buffers;\n\n  buffers.splice(bufferId, 1);\n\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer) && bufferView.buffer > bufferId) {\n      bufferView.buffer--;\n    }\n\n    if (\n      defined(bufferView.extensions) &&\n      defined(bufferView.extensions.EXT_meshopt_compression)\n    ) {\n      bufferView.extensions.EXT_meshopt_compression.buffer--;\n    }\n  });\n};\n\nRemove.bufferView = function (gltf, bufferViewId) {\n  const bufferViews = gltf.bufferViews;\n\n  bufferViews.splice(bufferViewId, 1);\n\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView) && accessor.bufferView > bufferViewId) {\n      accessor.bufferView--;\n    }\n  });\n\n  ForEach.shader(gltf, function (shader) {\n    if (defined(shader.bufferView) && shader.bufferView > bufferViewId) {\n      shader.bufferView--;\n    }\n  });\n\n  ForEach.image(gltf, function (image) {\n    if (defined(image.bufferView) && image.bufferView > bufferViewId) {\n      image.bufferView--;\n    }\n  });\n\n  if (usesExtension(gltf, \"KHR_draco_mesh_compression\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        if (\n          defined(primitive.extensions) &&\n          defined(primitive.extensions.KHR_draco_mesh_compression)\n        ) {\n          if (\n            primitive.extensions.KHR_draco_mesh_compression.bufferView >\n            bufferViewId\n          ) {\n            primitive.extensions.KHR_draco_mesh_compression.bufferView--;\n          }\n        }\n      });\n    });\n  }\n\n  if (usesExtension(gltf, \"EXT_feature_metadata\")) {\n    const extension = gltf.extensions.EXT_feature_metadata;\n    const featureTables = extension.featureTables;\n    for (const featureTableId in featureTables) {\n      if (featureTables.hasOwnProperty(featureTableId)) {\n        const featureTable = featureTables[featureTableId];\n        const properties = featureTable.properties;\n        if (defined(properties)) {\n          for (const propertyId in properties) {\n            if (properties.hasOwnProperty(propertyId)) {\n              const property = properties[propertyId];\n              if (\n                defined(property.bufferView) &&\n                property.bufferView > bufferViewId\n              ) {\n                property.bufferView--;\n              }\n              if (\n                defined(property.arrayOffsetBufferView) &&\n                property.arrayOffsetBufferView > bufferViewId\n              ) {\n                property.arrayOffsetBufferView--;\n              }\n              if (\n                defined(property.stringOffsetBufferView) &&\n                property.stringOffsetBufferView > bufferViewId\n              ) {\n                property.stringOffsetBufferView--;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (usesExtension(gltf, \"EXT_structural_metadata\")) {\n    const extension = gltf.extensions.EXT_structural_metadata;\n    const propertyTables = extension.propertyTables;\n    if (defined(propertyTables)) {\n      const propertyTablesLength = propertyTables.length;\n      for (let i = 0; i < propertyTablesLength; ++i) {\n        const propertyTable = propertyTables[i];\n        const properties = propertyTable.properties;\n        for (const propertyId in properties) {\n          if (properties.hasOwnProperty(propertyId)) {\n            const property = properties[propertyId];\n            if (defined(property.values) && property.values > bufferViewId) {\n              property.values--;\n            }\n            if (\n              defined(property.arrayOffsets) &&\n              property.arrayOffsets > bufferViewId\n            ) {\n              property.arrayOffsets--;\n            }\n            if (\n              defined(property.stringOffsets) &&\n              property.stringOffsets > bufferViewId\n            ) {\n              property.stringOffsets--;\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nRemove.image = function (gltf, imageId) {\n  const images = gltf.images;\n  images.splice(imageId, 1);\n\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.source)) {\n      if (texture.source > imageId) {\n        --texture.source;\n      }\n    }\n    const ext = texture.extensions;\n    if (\n      defined(ext) &&\n      defined(ext.EXT_texture_webp) &&\n      ext.EXT_texture_webp.source > imageId\n    ) {\n      --texture.extensions.EXT_texture_webp.source;\n    } else if (\n      defined(ext) &&\n      defined(ext.KHR_texture_basisu) &&\n      ext.KHR_texture_basisu.source > imageId\n    ) {\n      --texture.extensions.KHR_texture_basisu.source;\n    }\n  });\n};\n\nRemove.mesh = function (gltf, meshId) {\n  const meshes = gltf.meshes;\n  meshes.splice(meshId, 1);\n\n  ForEach.node(gltf, function (node) {\n    if (defined(node.mesh)) {\n      if (node.mesh > meshId) {\n        node.mesh--;\n      } else if (node.mesh === meshId) {\n        // Remove reference to deleted mesh\n        delete node.mesh;\n      }\n    }\n  });\n};\n\nRemove.node = function (gltf, nodeId) {\n  const nodes = gltf.nodes;\n  nodes.splice(nodeId, 1);\n\n  // Shift all node references\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.skeleton) && skin.skeleton > nodeId) {\n      skin.skeleton--;\n    }\n\n    skin.joints = skin.joints.map(function (x) {\n      return x > nodeId ? x - 1 : x;\n    });\n  });\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationChannel(animation, function (channel) {\n      if (\n        defined(channel.target) &&\n        defined(channel.target.node) &&\n        channel.target.node > nodeId\n      ) {\n        channel.target.node--;\n      }\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueUniform(technique, function (uniform) {\n      if (defined(uniform.node) && uniform.node > nodeId) {\n        uniform.node--;\n      }\n    });\n  });\n  ForEach.node(gltf, function (node) {\n    if (!defined(node.children)) {\n      return;\n    }\n\n    node.children = node.children\n      .filter(function (x) {\n        return x !== nodeId; // Remove\n      })\n      .map(function (x) {\n        return x > nodeId ? x - 1 : x; // Shift indices\n      });\n  });\n  ForEach.scene(gltf, function (scene) {\n    scene.nodes = scene.nodes\n      .filter(function (x) {\n        return x !== nodeId; // Remove\n      })\n      .map(function (x) {\n        return x > nodeId ? x - 1 : x; // Shift indices\n      });\n  });\n};\n\nRemove.material = function (gltf, materialId) {\n  const materials = gltf.materials;\n  materials.splice(materialId, 1);\n\n  // Shift other material ids\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      if (defined(primitive.material) && primitive.material > materialId) {\n        primitive.material--;\n      }\n    });\n  });\n};\n\nRemove.sampler = function (gltf, samplerId) {\n  const samplers = gltf.samplers;\n  samplers.splice(samplerId, 1);\n\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.sampler)) {\n      if (texture.sampler > samplerId) {\n        --texture.sampler;\n      }\n    }\n  });\n};\n\nRemove.texture = function (gltf, textureId) {\n  const textures = gltf.textures;\n  textures.splice(textureId, 1);\n\n  ForEach.material(gltf, function (material) {\n    forEachTextureInMaterial(material, function (textureIndex, textureInfo) {\n      if (textureInfo.index > textureId) {\n        --textureInfo.index;\n      }\n    });\n  });\n\n  if (usesExtension(gltf, \"EXT_feature_metadata\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (defined(extensions) && defined(extensions.EXT_feature_metadata)) {\n          const extension = extensions.EXT_feature_metadata;\n          const featureIdTextures = extension.featureIdTextures;\n          if (defined(featureIdTextures)) {\n            const featureIdTexturesLength = featureIdTextures.length;\n            for (let i = 0; i < featureIdTexturesLength; ++i) {\n              const featureIdTexture = featureIdTextures[i];\n              const textureInfo = featureIdTexture.featureIds.texture;\n              if (textureInfo.index > textureId) {\n                --textureInfo.index;\n              }\n            }\n          }\n        }\n      });\n    });\n\n    const extension = gltf.extensions.EXT_feature_metadata;\n    const featureTextures = extension.featureTextures;\n    for (const featureTextureId in featureTextures) {\n      if (featureTextures.hasOwnProperty(featureTextureId)) {\n        const featureTexture = featureTextures[featureTextureId];\n        const properties = featureTexture.properties;\n        if (defined(properties)) {\n          for (const propertyId in properties) {\n            if (properties.hasOwnProperty(propertyId)) {\n              const property = properties[propertyId];\n              const textureInfo = property.texture;\n              if (textureInfo.index > textureId) {\n                --textureInfo.index;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (usesExtension(gltf, \"EXT_mesh_features\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (defined(extensions) && defined(extensions.EXT_mesh_features)) {\n          const extension = extensions.EXT_mesh_features;\n          const featureIds = extension.featureIds;\n          if (defined(featureIds)) {\n            const featureIdsLength = featureIds.length;\n            for (let i = 0; i < featureIdsLength; ++i) {\n              const featureId = featureIds[i];\n              if (defined(featureId.texture)) {\n                if (featureId.texture.index > textureId) {\n                  --featureId.texture.index;\n                }\n              }\n            }\n          }\n        }\n      });\n    });\n  }\n\n  if (usesExtension(gltf, \"EXT_structural_metadata\")) {\n    const extension = gltf.extensions.EXT_structural_metadata;\n    const propertyTextures = extension.propertyTextures;\n    if (defined(propertyTextures)) {\n      const propertyTexturesLength = propertyTextures.length;\n      for (let i = 0; i < propertyTexturesLength; ++i) {\n        const propertyTexture = propertyTextures[i];\n        const properties = propertyTexture.properties;\n        for (const propertyId in properties) {\n          if (properties.hasOwnProperty(propertyId)) {\n            const property = properties[propertyId];\n            if (property.index > textureId) {\n              --property.index;\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\n/**\n * Contains functions for getting a list of element ids in use by the glTF asset.\n * @constructor\n *\n * @private\n */\nfunction getListOfElementsIdsInUse() {}\n\ngetListOfElementsIdsInUse.accessor = function (gltf) {\n  // Calculate accessor's that are currently in use.\n  const usedAccessorIds = {};\n\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      ForEach.meshPrimitiveAttribute(primitive, function (accessorId) {\n        usedAccessorIds[accessorId] = true;\n      });\n      ForEach.meshPrimitiveTarget(primitive, function (target) {\n        ForEach.meshPrimitiveTargetAttribute(target, function (accessorId) {\n          usedAccessorIds[accessorId] = true;\n        });\n      });\n      const indices = primitive.indices;\n      if (defined(indices)) {\n        usedAccessorIds[indices] = true;\n      }\n    });\n  });\n\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.inverseBindMatrices)) {\n      usedAccessorIds[skin.inverseBindMatrices] = true;\n    }\n  });\n\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      if (defined(sampler.input)) {\n        usedAccessorIds[sampler.input] = true;\n      }\n      if (defined(sampler.output)) {\n        usedAccessorIds[sampler.output] = true;\n      }\n    });\n  });\n\n  if (usesExtension(gltf, \"EXT_mesh_gpu_instancing\")) {\n    ForEach.node(gltf, function (node) {\n      if (\n        defined(node.extensions) &&\n        defined(node.extensions.EXT_mesh_gpu_instancing)\n      ) {\n        Object.keys(node.extensions.EXT_mesh_gpu_instancing.attributes).forEach(\n          function (key) {\n            const attributeAccessorId =\n              node.extensions.EXT_mesh_gpu_instancing.attributes[key];\n            usedAccessorIds[attributeAccessorId] = true;\n          },\n        );\n      }\n    });\n  }\n\n  if (usesExtension(gltf, \"CESIUM_primitive_outline\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (\n          defined(extensions) &&\n          defined(extensions.CESIUM_primitive_outline)\n        ) {\n          const extension = extensions.CESIUM_primitive_outline;\n          const indicesAccessorId = extension.indices;\n          if (defined(indicesAccessorId)) {\n            usedAccessorIds[indicesAccessorId] = true;\n          }\n        }\n      });\n    });\n  }\n\n  return usedAccessorIds;\n};\n\ngetListOfElementsIdsInUse.buffer = function (gltf) {\n  // Calculate buffer's that are currently in use.\n  const usedBufferIds = {};\n\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer)) {\n      usedBufferIds[bufferView.buffer] = true;\n    }\n    if (\n      defined(bufferView.extensions) &&\n      defined(bufferView.extensions.EXT_meshopt_compression)\n    ) {\n      usedBufferIds[bufferView.extensions.EXT_meshopt_compression.buffer] =\n        true;\n    }\n  });\n\n  return usedBufferIds;\n};\n\ngetListOfElementsIdsInUse.bufferView = function (gltf) {\n  // Calculate bufferView's that are currently in use.\n  const usedBufferViewIds = {};\n\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      usedBufferViewIds[accessor.bufferView] = true;\n    }\n  });\n\n  ForEach.shader(gltf, function (shader) {\n    if (defined(shader.bufferView)) {\n      usedBufferViewIds[shader.bufferView] = true;\n    }\n  });\n\n  ForEach.image(gltf, function (image) {\n    if (defined(image.bufferView)) {\n      usedBufferViewIds[image.bufferView] = true;\n    }\n  });\n\n  if (usesExtension(gltf, \"KHR_draco_mesh_compression\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        if (\n          defined(primitive.extensions) &&\n          defined(primitive.extensions.KHR_draco_mesh_compression)\n        ) {\n          usedBufferViewIds[\n            primitive.extensions.KHR_draco_mesh_compression.bufferView\n          ] = true;\n        }\n      });\n    });\n  }\n\n  if (usesExtension(gltf, \"EXT_feature_metadata\")) {\n    const extension = gltf.extensions.EXT_feature_metadata;\n    const featureTables = extension.featureTables;\n    for (const featureTableId in featureTables) {\n      if (featureTables.hasOwnProperty(featureTableId)) {\n        const featureTable = featureTables[featureTableId];\n        const properties = featureTable.properties;\n        if (defined(properties)) {\n          for (const propertyId in properties) {\n            if (properties.hasOwnProperty(propertyId)) {\n              const property = properties[propertyId];\n              if (defined(property.bufferView)) {\n                usedBufferViewIds[property.bufferView] = true;\n              }\n              if (defined(property.arrayOffsetBufferView)) {\n                usedBufferViewIds[property.arrayOffsetBufferView] = true;\n              }\n              if (defined(property.stringOffsetBufferView)) {\n                usedBufferViewIds[property.stringOffsetBufferView] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (usesExtension(gltf, \"EXT_structural_metadata\")) {\n    const extension = gltf.extensions.EXT_structural_metadata;\n    const propertyTables = extension.propertyTables;\n    if (defined(propertyTables)) {\n      const propertyTablesLength = propertyTables.length;\n      for (let i = 0; i < propertyTablesLength; ++i) {\n        const propertyTable = propertyTables[i];\n        const properties = propertyTable.properties;\n        for (const propertyId in properties) {\n          if (properties.hasOwnProperty(propertyId)) {\n            const property = properties[propertyId];\n            if (defined(property.values)) {\n              usedBufferViewIds[property.values] = true;\n            }\n            if (defined(property.arrayOffsets)) {\n              usedBufferViewIds[property.arrayOffsets] = true;\n            }\n            if (defined(property.stringOffsets)) {\n              usedBufferViewIds[property.stringOffsets] = true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return usedBufferViewIds;\n};\n\ngetListOfElementsIdsInUse.image = function (gltf) {\n  const usedImageIds = {};\n\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.source)) {\n      usedImageIds[texture.source] = true;\n    }\n\n    if (\n      defined(texture.extensions) &&\n      defined(texture.extensions.EXT_texture_webp)\n    ) {\n      usedImageIds[texture.extensions.EXT_texture_webp.source] = true;\n    } else if (\n      defined(texture.extensions) &&\n      defined(texture.extensions.KHR_texture_basisu)\n    ) {\n      usedImageIds[texture.extensions.KHR_texture_basisu.source] = true;\n    }\n  });\n  return usedImageIds;\n};\n\ngetListOfElementsIdsInUse.mesh = function (gltf) {\n  const usedMeshIds = {};\n  ForEach.node(gltf, function (node) {\n    if (defined(node.mesh && defined(gltf.meshes))) {\n      const mesh = gltf.meshes[node.mesh];\n      if (\n        defined(mesh) &&\n        defined(mesh.primitives) &&\n        mesh.primitives.length > 0\n      ) {\n        usedMeshIds[node.mesh] = true;\n      }\n    }\n  });\n\n  return usedMeshIds;\n};\n\n// Check if node is empty. It is considered empty if neither referencing\n// mesh, camera, extensions and has no children\nfunction nodeIsEmpty(gltf, nodeId, usedNodeIds) {\n  const node = gltf.nodes[nodeId];\n  if (\n    defined(node.mesh) ||\n    defined(node.camera) ||\n    defined(node.skin) ||\n    defined(node.weights) ||\n    defined(node.extras) ||\n    (defined(node.extensions) && Object.keys(node.extensions).length !== 0) ||\n    defined(usedNodeIds[nodeId])\n  ) {\n    return false;\n  }\n\n  // Empty if no children or children are all empty nodes\n  return (\n    !defined(node.children) ||\n    node.children.filter(function (n) {\n      return !nodeIsEmpty(gltf, n, usedNodeIds);\n    }).length === 0\n  );\n}\n\ngetListOfElementsIdsInUse.node = function (gltf) {\n  const usedNodeIds = {};\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.skeleton)) {\n      usedNodeIds[skin.skeleton] = true;\n    }\n\n    ForEach.skinJoint(skin, function (joint) {\n      usedNodeIds[joint] = true;\n    });\n  });\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationChannel(animation, function (channel) {\n      if (defined(channel.target) && defined(channel.target.node)) {\n        usedNodeIds[channel.target.node] = true;\n      }\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueUniform(technique, function (uniform) {\n      if (defined(uniform.node)) {\n        usedNodeIds[uniform.node] = true;\n      }\n    });\n  });\n  ForEach.node(gltf, function (node, nodeId) {\n    if (!nodeIsEmpty(gltf, nodeId, usedNodeIds)) {\n      usedNodeIds[nodeId] = true;\n    }\n  });\n\n  return usedNodeIds;\n};\n\ngetListOfElementsIdsInUse.material = function (gltf) {\n  const usedMaterialIds = {};\n\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      if (defined(primitive.material)) {\n        usedMaterialIds[primitive.material] = true;\n      }\n    });\n  });\n\n  return usedMaterialIds;\n};\n\ngetListOfElementsIdsInUse.texture = function (gltf) {\n  const usedTextureIds = {};\n\n  ForEach.material(gltf, function (material) {\n    forEachTextureInMaterial(material, function (textureId) {\n      usedTextureIds[textureId] = true;\n    });\n  });\n\n  if (usesExtension(gltf, \"EXT_feature_metadata\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (defined(extensions) && defined(extensions.EXT_feature_metadata)) {\n          const extension = extensions.EXT_feature_metadata;\n          const featureIdTextures = extension.featureIdTextures;\n          if (defined(featureIdTextures)) {\n            const featureIdTexturesLength = featureIdTextures.length;\n            for (let i = 0; i < featureIdTexturesLength; ++i) {\n              const featureIdTexture = featureIdTextures[i];\n              const textureInfo = featureIdTexture.featureIds.texture;\n              usedTextureIds[textureInfo.index] = true;\n            }\n          }\n        }\n      });\n    });\n\n    const extension = gltf.extensions.EXT_feature_metadata;\n    const featureTextures = extension.featureTextures;\n    for (const featureTextureId in featureTextures) {\n      if (featureTextures.hasOwnProperty(featureTextureId)) {\n        const featureTexture = featureTextures[featureTextureId];\n        const properties = featureTexture.properties;\n        if (defined(properties)) {\n          for (const propertyId in properties) {\n            if (properties.hasOwnProperty(propertyId)) {\n              const property = properties[propertyId];\n              const textureInfo = property.texture;\n              usedTextureIds[textureInfo.index] = true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (usesExtension(gltf, \"EXT_mesh_features\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (defined(extensions) && defined(extensions.EXT_mesh_features)) {\n          const extension = extensions.EXT_mesh_features;\n          const featureIds = extension.featureIds;\n          if (defined(featureIds)) {\n            const featureIdsLength = featureIds.length;\n            for (let i = 0; i < featureIdsLength; ++i) {\n              const featureId = featureIds[i];\n              if (defined(featureId.texture)) {\n                usedTextureIds[featureId.texture.index] = true;\n              }\n            }\n          }\n        }\n      });\n    });\n  }\n\n  if (usesExtension(gltf, \"EXT_structural_metadata\")) {\n    const extension = gltf.extensions.EXT_structural_metadata;\n    const propertyTextures = extension.propertyTextures;\n    if (defined(propertyTextures)) {\n      const propertyTexturesLength = propertyTextures.length;\n      for (let i = 0; i < propertyTexturesLength; ++i) {\n        const propertyTexture = propertyTextures[i];\n        const properties = propertyTexture.properties;\n        for (const propertyId in properties) {\n          if (properties.hasOwnProperty(propertyId)) {\n            const property = properties[propertyId];\n            usedTextureIds[property.index] = true;\n          }\n        }\n      }\n    }\n  }\n\n  return usedTextureIds;\n};\n\ngetListOfElementsIdsInUse.sampler = function (gltf) {\n  const usedSamplerIds = {};\n\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.sampler)) {\n      usedSamplerIds[texture.sampler] = true;\n    }\n  });\n\n  return usedSamplerIds;\n};\n\nexport default removeUnusedElements;\n"],"names":["allElementTypes","removeUnusedElements","gltf","elementTypes","forEach","type","indexOf","removeUnusedElementsByType","TypeToGltfElementName","accessor","buffer","bufferView","image","node","material","mesh","sampler","texture","name","arrayOfObjects","removed","usedIds","getListOfElementsIdsInUse","length","i","Remove","accessorId","accessors","splice","meshPrimitive","primitive","meshPrimitiveAttribute","attributeAccessorId","semantic","attributes","meshPrimitiveTarget","target","meshPrimitiveTargetAttribute","indices","ext","extensions","CESIUM_primitive_outline","skin","inverseBindMatrices","animation","animationSampler","input","output","bufferId","buffers","EXT_meshopt_compression","bufferViewId","bufferViews","shader","KHR_draco_mesh_compression","extension","EXT_feature_metadata","featureTables","featureTableId","hasOwnProperty","featureTable","properties","propertyId","property","arrayOffsetBufferView","stringOffsetBufferView","EXT_structural_metadata","propertyTables","propertyTablesLength","propertyTable","values","arrayOffsets","stringOffsets","imageId","images","source","EXT_texture_webp","KHR_texture_basisu","meshId","meshes","nodeId","nodes","skeleton","joints","map","x","animationChannel","channel","technique","techniqueUniform","uniform","children","filter","scene","materialId","materials","samplerId","samplers","textureId","textures","textureIndex","textureInfo","index","featureIdTextures","featureIdTexturesLength","featureIdTexture","featureIds","featureTextures","featureTextureId","featureTexture","EXT_mesh_features","featureIdsLength","featureId","propertyTextures","propertyTexturesLength","propertyTexture","usedAccessorIds","EXT_mesh_gpu_instancing","Object","keys","key","indicesAccessorId","usedBufferIds","usedBufferViewIds","usedImageIds","usedMeshIds","primitives","nodeIsEmpty","usedNodeIds","camera","weights","extras","n","skinJoint","joint","usedMaterialIds","usedTextureIds","usedSamplerIds"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2272, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/addBuffer.js"],"sourcesContent":["import addToArray from \"./addToArray.js\";\n\n/**\n * Adds buffer to gltf.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {Buffer} buffer A Buffer object which will be added to gltf.buffers.\n * @returns {number} The bufferView id of the newly added bufferView.\n *\n * @private\n */\nfunction addBuffer(gltf, buffer) {\n  const newBuffer = {\n    byteLength: buffer.length,\n    extras: {\n      _pipeline: {\n        source: buffer,\n      },\n    },\n  };\n  const bufferId = addToArray(gltf.buffers, newBuffer);\n  const bufferView = {\n    buffer: bufferId,\n    byteOffset: 0,\n    byteLength: buffer.length,\n  };\n  return addToArray(gltf.bufferViews, bufferView);\n}\n\nexport default addBuffer;\n"],"names":["addBuffer","gltf","buffer","newBuffer","byteLength","length","extras","_pipeline","source","bufferId","buffers","bufferView","byteOffset","bufferViews"],"mappings":";;;;AAAA;;AAEA;;;;;;;;CAQC,GACD,SAASA,UAAUC,IAAI,EAAEC,MAAM;IAC7B,MAAMC,YAAY;QAChBC,YAAYF,OAAOG,MAAM;QACzBC,QAAQ;YACNC,WAAW;gBACTC,QAAQN;YACV;QACF;IACF;IACA,MAAMO,WAAW,IAAA,iMAAU,EAACR,KAAKS,OAAO,EAAEP;IAC1C,MAAMQ,aAAa;QACjBT,QAAQO;QACRG,YAAY;QACZR,YAAYF,OAAOG,MAAM;IAC3B;IACA,OAAO,IAAA,iMAAU,EAACJ,KAAKY,WAAW,EAAEF;AACtC;uCAEeX","ignoreList":[0]}},
    {"offset": {"line": 2308, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/readAccessorPacked.js"],"sourcesContent":["import getAccessorByteStride from \"./getAccessorByteStride.js\";\nimport getComponentReader from \"./getComponentReader.js\";\nimport numberOfComponentsForType from \"./numberOfComponentsForType.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Returns the accessor data in a contiguous array.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {object} accessor The accessor.\n * @returns {Array} The accessor values in a contiguous array.\n *\n * @private\n */\nfunction readAccessorPacked(gltf, accessor) {\n  const byteStride = getAccessorByteStride(gltf, accessor);\n  const componentTypeByteLength = ComponentDatatype.getSizeInBytes(\n    accessor.componentType,\n  );\n  const numberOfComponents = numberOfComponentsForType(accessor.type);\n  const count = accessor.count;\n  const values = new Array(numberOfComponents * count);\n\n  if (!defined(accessor.bufferView)) {\n    return values.fill(0);\n  }\n\n  const bufferView = gltf.bufferViews[accessor.bufferView];\n  const source = gltf.buffers[bufferView.buffer].extras._pipeline.source;\n  let byteOffset =\n    accessor.byteOffset + bufferView.byteOffset + source.byteOffset;\n\n  const dataView = new DataView(source.buffer);\n  const components = new Array(numberOfComponents);\n  const componentReader = getComponentReader(accessor.componentType);\n\n  for (let i = 0; i < count; ++i) {\n    componentReader(\n      dataView,\n      byteOffset,\n      numberOfComponents,\n      componentTypeByteLength,\n      components,\n    );\n    for (let j = 0; j < numberOfComponents; ++j) {\n      values[i * numberOfComponents + j] = components[j];\n    }\n    byteOffset += byteStride;\n  }\n  return values;\n}\n\nexport default readAccessorPacked;\n"],"names":["readAccessorPacked","gltf","accessor","byteStride","componentTypeByteLength","getSizeInBytes","componentType","numberOfComponents","type","count","values","Array","bufferView","fill","bufferViews","source","buffers","buffer","extras","_pipeline","byteOffset","dataView","DataView","components","componentReader","i","j"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;CAQC,GACD,SAASA,mBAAmBC,IAAI,EAAEC,QAAQ;IACxC,MAAMC,aAAa,IAAA,4MAAqB,EAACF,MAAMC;IAC/C,MAAME,0BAA0B,uLAAiB,CAACC,cAAc,CAC9DH,SAASI,aAAa;IAExB,MAAMC,qBAAqB,IAAA,gNAAyB,EAACL,SAASM,IAAI;IAClE,MAAMC,QAAQP,SAASO,KAAK;IAC5B,MAAMC,SAAS,IAAIC,MAAMJ,qBAAqBE;IAE9C,IAAI,CAAC,IAAA,6KAAO,EAACP,SAASU,UAAU,GAAG;QACjC,OAAOF,OAAOG,IAAI,CAAC;IACrB;IAEA,MAAMD,aAAaX,KAAKa,WAAW,CAACZ,SAASU,UAAU,CAAC;IACxD,MAAMG,SAASd,KAAKe,OAAO,CAACJ,WAAWK,MAAM,CAAC,CAACC,MAAM,CAACC,SAAS,CAACJ,MAAM;IACtE,IAAIK,aACFlB,SAASkB,UAAU,GAAGR,WAAWQ,UAAU,GAAGL,OAAOK,UAAU;IAEjE,MAAMC,WAAW,IAAIC,SAASP,OAAOE,MAAM;IAC3C,MAAMM,aAAa,IAAIZ,MAAMJ;IAC7B,MAAMiB,kBAAkB,IAAA,yMAAkB,EAACtB,SAASI,aAAa;IAEjE,IAAK,IAAImB,IAAI,GAAGA,IAAIhB,OAAO,EAAEgB,EAAG;QAC9BD,gBACEH,UACAD,YACAb,oBACAH,yBACAmB;QAEF,IAAK,IAAIG,IAAI,GAAGA,IAAInB,oBAAoB,EAAEmB,EAAG;YAC3ChB,MAAM,CAACe,IAAIlB,qBAAqBmB,EAAE,GAAGH,UAAU,CAACG,EAAE;QACpD;QACAN,cAAcjB;IAChB;IACA,OAAOO;AACT;uCAEeV","ignoreList":[0]}},
    {"offset": {"line": 2359, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/updateAccessorComponentTypes.js"],"sourcesContent":["import addBuffer from \"./addBuffer.js\";\nimport ForEach from \"./ForEach.js\";\nimport readAccessorPacked from \"./readAccessorPacked.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\n\n/**\n * Update accessors referenced by JOINTS_0 and WEIGHTS_0 attributes to use correct component types.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @returns {object} The glTF asset with compressed meshes.\n *\n * @private\n */\nfunction updateAccessorComponentTypes(gltf) {\n  let componentType;\n  ForEach.accessorWithSemantic(gltf, \"JOINTS_0\", function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    componentType = accessor.componentType;\n    if (componentType === WebGLConstants.BYTE) {\n      convertType(gltf, accessor, ComponentDatatype.UNSIGNED_BYTE);\n    } else if (\n      componentType !== WebGLConstants.UNSIGNED_BYTE &&\n      componentType !== WebGLConstants.UNSIGNED_SHORT\n    ) {\n      convertType(gltf, accessor, ComponentDatatype.UNSIGNED_SHORT);\n    }\n  });\n  ForEach.accessorWithSemantic(gltf, \"WEIGHTS_0\", function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    componentType = accessor.componentType;\n    if (componentType === WebGLConstants.BYTE) {\n      convertType(gltf, accessor, ComponentDatatype.UNSIGNED_BYTE);\n    } else if (componentType === WebGLConstants.SHORT) {\n      convertType(gltf, accessor, ComponentDatatype.UNSIGNED_SHORT);\n    }\n  });\n\n  return gltf;\n}\n\nfunction convertType(gltf, accessor, updatedComponentType) {\n  const typedArray = ComponentDatatype.createTypedArray(\n    updatedComponentType,\n    readAccessorPacked(gltf, accessor),\n  );\n  const newBuffer = new Uint8Array(typedArray.buffer);\n  accessor.bufferView = addBuffer(gltf, newBuffer);\n  accessor.componentType = updatedComponentType;\n  accessor.byteOffset = 0;\n}\n\nexport default updateAccessorComponentTypes;\n"],"names":["updateAccessorComponentTypes","gltf","componentType","accessorWithSemantic","accessorId","accessor","accessors","BYTE","convertType","UNSIGNED_BYTE","UNSIGNED_SHORT","SHORT","updatedComponentType","typedArray","createTypedArray","newBuffer","Uint8Array","buffer","bufferView","byteOffset"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;CAOC,GACD,SAASA,6BAA6BC,IAAI;IACxC,IAAIC;IACJ,8LAAO,CAACC,oBAAoB,CAACF,MAAM,YAAY,SAAUG,UAAU;QACjE,MAAMC,WAAWJ,KAAKK,SAAS,CAACF,WAAW;QAC3CF,gBAAgBG,SAASH,aAAa;QACtC,IAAIA,kBAAkB,oLAAc,CAACK,IAAI,EAAE;YACzCC,YAAYP,MAAMI,UAAU,uLAAiB,CAACI,aAAa;QAC7D,OAAO,IACLP,kBAAkB,oLAAc,CAACO,aAAa,IAC9CP,kBAAkB,oLAAc,CAACQ,cAAc,EAC/C;YACAF,YAAYP,MAAMI,UAAU,uLAAiB,CAACK,cAAc;QAC9D;IACF;IACA,8LAAO,CAACP,oBAAoB,CAACF,MAAM,aAAa,SAAUG,UAAU;QAClE,MAAMC,WAAWJ,KAAKK,SAAS,CAACF,WAAW;QAC3CF,gBAAgBG,SAASH,aAAa;QACtC,IAAIA,kBAAkB,oLAAc,CAACK,IAAI,EAAE;YACzCC,YAAYP,MAAMI,UAAU,uLAAiB,CAACI,aAAa;QAC7D,OAAO,IAAIP,kBAAkB,oLAAc,CAACS,KAAK,EAAE;YACjDH,YAAYP,MAAMI,UAAU,uLAAiB,CAACK,cAAc;QAC9D;IACF;IAEA,OAAOT;AACT;AAEA,SAASO,YAAYP,IAAI,EAAEI,QAAQ,EAAEO,oBAAoB;IACvD,MAAMC,aAAa,uLAAiB,CAACC,gBAAgB,CACnDF,sBACA,IAAA,yMAAkB,EAACX,MAAMI;IAE3B,MAAMU,YAAY,IAAIC,WAAWH,WAAWI,MAAM;IAClDZ,SAASa,UAAU,GAAG,IAAA,gMAAS,EAACjB,MAAMc;IACtCV,SAASH,aAAa,GAAGU;IACzBP,SAASc,UAAU,GAAG;AACxB;uCAEenB","ignoreList":[0]}},
    {"offset": {"line": 2414, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/removeExtension.js"],"sourcesContent":["import ForEach from \"./ForEach.js\";\nimport removeExtensionsUsed from \"./removeExtensionsUsed.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Removes an extension from gltf.extensions, gltf.extensionsUsed, gltf.extensionsRequired, and any other objects in the glTF if it is present.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {string} extension The extension to remove.\n *\n * @returns {*} The extension data removed from gltf.extensions.\n */\nfunction removeExtension(gltf, extension) {\n  removeExtensionsUsed(gltf, extension); // Also removes from extensionsRequired\n\n  if (extension === \"CESIUM_RTC\") {\n    removeCesiumRTC(gltf);\n  }\n\n  return removeExtensionAndTraverse(gltf, extension);\n}\n\nfunction removeCesiumRTC(gltf) {\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueUniform(technique, function (uniform) {\n      if (uniform.semantic === \"CESIUM_RTC_MODELVIEW\") {\n        uniform.semantic = \"MODELVIEW\";\n      }\n    });\n  });\n}\n\nfunction removeExtensionAndTraverse(object, extension) {\n  if (Array.isArray(object)) {\n    const length = object.length;\n    for (let i = 0; i < length; ++i) {\n      removeExtensionAndTraverse(object[i], extension);\n    }\n  } else if (\n    object !== null &&\n    typeof object === \"object\" &&\n    object.constructor === Object\n  ) {\n    const extensions = object.extensions;\n    let extensionData;\n    if (defined(extensions)) {\n      extensionData = extensions[extension];\n      if (defined(extensionData)) {\n        delete extensions[extension];\n        if (Object.keys(extensions).length === 0) {\n          delete object.extensions;\n        }\n      }\n    }\n    for (const key in object) {\n      if (Object.prototype.hasOwnProperty.call(object, key)) {\n        removeExtensionAndTraverse(object[key], extension);\n      }\n    }\n    return extensionData;\n  }\n}\n\nexport default removeExtension;\n"],"names":["removeExtension","gltf","extension","removeCesiumRTC","removeExtensionAndTraverse","technique","techniqueUniform","uniform","semantic","object","Array","isArray","length","i","Object","extensions","extensionData","keys","key","prototype","hasOwnProperty","call"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;CAOC,GACD,SAASA,gBAAgBC,IAAI,EAAEC,SAAS;IACtC,IAAA,2MAAoB,EAACD,MAAMC,YAAY,uCAAuC;IAE9E,IAAIA,cAAc,cAAc;QAC9BC,gBAAgBF;IAClB;IAEA,OAAOG,2BAA2BH,MAAMC;AAC1C;AAEA,SAASC,gBAAgBF,IAAI;IAC3B,8LAAO,CAACI,SAAS,CAACJ,MAAM,SAAUI,SAAS;QACzC,8LAAO,CAACC,gBAAgB,CAACD,WAAW,SAAUE,OAAO;YACnD,IAAIA,QAAQC,QAAQ,KAAK,wBAAwB;gBAC/CD,QAAQC,QAAQ,GAAG;YACrB;QACF;IACF;AACF;AAEA,SAASJ,2BAA2BK,MAAM,EAAEP,SAAS;IACnD,IAAIQ,MAAMC,OAAO,CAACF,SAAS;QACzB,MAAMG,SAASH,OAAOG,MAAM;QAC5B,IAAK,IAAIC,IAAI,GAAGA,IAAID,QAAQ,EAAEC,EAAG;YAC/BT,2BAA2BK,MAAM,CAACI,EAAE,EAAEX;QACxC;IACF,OAAO,IACLO,WAAW,QACX,OAAOA,WAAW,YAClBA,OAAO,WAAW,KAAKK,QACvB;QACA,MAAMC,aAAaN,OAAOM,UAAU;QACpC,IAAIC;QACJ,IAAI,IAAA,6KAAO,EAACD,aAAa;YACvBC,gBAAgBD,UAAU,CAACb,UAAU;YACrC,IAAI,IAAA,6KAAO,EAACc,gBAAgB;gBAC1B,OAAOD,UAAU,CAACb,UAAU;gBAC5B,IAAIY,OAAOG,IAAI,CAACF,YAAYH,MAAM,KAAK,GAAG;oBACxC,OAAOH,OAAOM,UAAU;gBAC1B;YACF;QACF;QACA,IAAK,MAAMG,OAAOT,OAAQ;YACxB,IAAIK,OAAOK,SAAS,CAACC,cAAc,CAACC,IAAI,CAACZ,QAAQS,MAAM;gBACrDd,2BAA2BK,MAAM,CAACS,IAAI,EAAEhB;YAC1C;QACF;QACA,OAAOc;IACT;AACF;uCAEehB","ignoreList":[0]}},
    {"offset": {"line": 2478, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GltfPipeline/updateVersion.js"],"sourcesContent":["import addExtensionsUsed from \"./addExtensionsUsed.js\";\nimport addToArray from \"./addToArray.js\";\nimport findAccessorMinMax from \"./findAccessorMinMax.js\";\nimport ForEach from \"./ForEach.js\";\nimport getAccessorByteStride from \"./getAccessorByteStride.js\";\nimport numberOfComponentsForType from \"./numberOfComponentsForType.js\";\nimport moveTechniqueRenderStates from \"./moveTechniqueRenderStates.js\";\nimport moveTechniquesToExtension from \"./moveTechniquesToExtension.js\";\nimport removeUnusedElements from \"./removeUnusedElements.js\";\nimport updateAccessorComponentTypes from \"./updateAccessorComponentTypes.js\";\nimport removeExtension from \"./removeExtension.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport clone from \"../../Core/clone.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\n\nconst updateFunctions = {\n  0.8: glTF08to10,\n  \"1.0\": glTF10to20,\n  \"2.0\": undefined,\n};\n\n/**\n * Update the glTF version to the latest version (2.0), or targetVersion if specified.\n * Applies changes made to the glTF spec between revisions so that the core library\n * only has to handle the latest version.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {object} [options] Options for updating the glTF.\n * @param {string} [options.targetVersion] The glTF will be upgraded until it hits the specified version.\n * @param {string[]} [options.baseColorTextureNames] Names of uniforms that indicate base color textures.\n * @param {string[]} [options.baseColorFactorNames] Names of uniforms that indicate base color factors.\n * @returns {object} The updated glTF asset.\n *\n * @private\n */\nfunction updateVersion(gltf, options) {\n  options = options ?? {};\n  const targetVersion = options.targetVersion;\n  let version = gltf.version;\n\n  gltf.asset = gltf.asset ?? {\n    version: \"1.0\",\n  };\n\n  gltf.asset.version = gltf.asset.version ?? \"1.0\";\n  version = (version ?? gltf.asset.version).toString();\n\n  // Invalid version\n  if (!Object.prototype.hasOwnProperty.call(updateFunctions, version)) {\n    // Try truncating trailing version numbers, could be a number as well if it is 0.8\n    if (defined(version)) {\n      version = version.substring(0, 3);\n    }\n    // Default to 1.0 if it cannot be determined\n    if (!Object.prototype.hasOwnProperty.call(updateFunctions, version)) {\n      version = \"1.0\";\n    }\n  }\n\n  let updateFunction = updateFunctions[version];\n\n  while (defined(updateFunction)) {\n    if (version === targetVersion) {\n      break;\n    }\n    updateFunction(gltf, options);\n    version = gltf.asset.version;\n    updateFunction = updateFunctions[version];\n  }\n\n  if (!options.keepLegacyExtensions) {\n    convertTechniquesToPbr(gltf, options);\n    convertMaterialsCommonToPbr(gltf);\n  }\n\n  return gltf;\n}\n\nfunction updateInstanceTechniques(gltf) {\n  const materials = gltf.materials;\n  for (const materialId in materials) {\n    if (Object.prototype.hasOwnProperty.call(materials, materialId)) {\n      const material = materials[materialId];\n      const instanceTechnique = material.instanceTechnique;\n      if (defined(instanceTechnique)) {\n        material.technique = instanceTechnique.technique;\n        material.values = instanceTechnique.values;\n        delete material.instanceTechnique;\n      }\n    }\n  }\n}\n\nfunction setPrimitiveModes(gltf) {\n  const meshes = gltf.meshes;\n  for (const meshId in meshes) {\n    if (Object.prototype.hasOwnProperty.call(meshes, meshId)) {\n      const mesh = meshes[meshId];\n      const primitives = mesh.primitives;\n      if (defined(primitives)) {\n        const primitivesLength = primitives.length;\n        for (let i = 0; i < primitivesLength; ++i) {\n          const primitive = primitives[i];\n          const defaultMode = primitive.primitive ?? WebGLConstants.TRIANGLES;\n          primitive.mode = primitive.mode ?? defaultMode;\n          delete primitive.primitive;\n        }\n      }\n    }\n  }\n}\n\nfunction updateNodes(gltf) {\n  const nodes = gltf.nodes;\n  const axis = new Cartesian3();\n  const quat = new Quaternion();\n  for (const nodeId in nodes) {\n    if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n      const node = nodes[nodeId];\n      if (defined(node.rotation)) {\n        const rotation = node.rotation;\n        Cartesian3.fromArray(rotation, 0, axis);\n        Quaternion.fromAxisAngle(axis, rotation[3], quat);\n        node.rotation = [quat.x, quat.y, quat.z, quat.w];\n      }\n      const instanceSkin = node.instanceSkin;\n      if (defined(instanceSkin)) {\n        node.skeletons = instanceSkin.skeletons;\n        node.skin = instanceSkin.skin;\n        node.meshes = instanceSkin.meshes;\n        delete node.instanceSkin;\n      }\n    }\n  }\n}\n\nfunction updateAnimations(gltf) {\n  const animations = gltf.animations;\n  const accessors = gltf.accessors;\n  const bufferViews = gltf.bufferViews;\n  const buffers = gltf.buffers;\n  const updatedAccessors = {};\n  const axis = new Cartesian3();\n  const quat = new Quaternion();\n  for (const animationId in animations) {\n    if (Object.prototype.hasOwnProperty.call(animations, animationId)) {\n      const animation = animations[animationId];\n      const channels = animation.channels;\n      const parameters = animation.parameters;\n      const samplers = animation.samplers;\n      if (defined(channels)) {\n        const channelsLength = channels.length;\n        for (let i = 0; i < channelsLength; ++i) {\n          const channel = channels[i];\n          if (channel.target.path === \"rotation\") {\n            const accessorId = parameters[samplers[channel.sampler].output];\n            if (defined(updatedAccessors[accessorId])) {\n              continue;\n            }\n            updatedAccessors[accessorId] = true;\n            const accessor = accessors[accessorId];\n            const bufferView = bufferViews[accessor.bufferView];\n            const buffer = buffers[bufferView.buffer];\n            const source = buffer.extras._pipeline.source;\n            const byteOffset =\n              source.byteOffset + bufferView.byteOffset + accessor.byteOffset;\n            const componentType = accessor.componentType;\n            const count = accessor.count;\n            const componentsLength = numberOfComponentsForType(accessor.type);\n            const length = accessor.count * componentsLength;\n            const typedArray = ComponentDatatype.createArrayBufferView(\n              componentType,\n              source.buffer,\n              byteOffset,\n              length,\n            );\n\n            for (let j = 0; j < count; j++) {\n              const offset = j * componentsLength;\n              Cartesian3.unpack(typedArray, offset, axis);\n              const angle = typedArray[offset + 3];\n              Quaternion.fromAxisAngle(axis, angle, quat);\n              Quaternion.pack(quat, typedArray, offset);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction removeTechniquePasses(gltf) {\n  const techniques = gltf.techniques;\n  for (const techniqueId in techniques) {\n    if (Object.prototype.hasOwnProperty.call(techniques, techniqueId)) {\n      const technique = techniques[techniqueId];\n      const passes = technique.passes;\n      if (defined(passes)) {\n        const passName = technique.pass ?? \"defaultPass\";\n        if (Object.prototype.hasOwnProperty.call(passes, passName)) {\n          const pass = passes[passName];\n          const instanceProgram = pass.instanceProgram;\n          technique.attributes =\n            technique.attributes ?? instanceProgram.attributes;\n          technique.program = technique.program ?? instanceProgram.program;\n          technique.uniforms = technique.uniforms ?? instanceProgram.uniforms;\n          technique.states = technique.states ?? pass.states;\n        }\n        delete technique.passes;\n        delete technique.pass;\n      }\n    }\n  }\n}\n\nfunction glTF08to10(gltf) {\n  if (!defined(gltf.asset)) {\n    gltf.asset = {};\n  }\n  const asset = gltf.asset;\n  asset.version = \"1.0\";\n  // Profile should be an object, not a string\n  if (typeof asset.profile === \"string\") {\n    const split = asset.profile.split(\" \");\n    asset.profile = {\n      api: split[0],\n      version: split[1],\n    };\n  } else {\n    asset.profile = {};\n  }\n\n  // Version property should be in asset, not on the root element\n  if (defined(gltf.version)) {\n    delete gltf.version;\n  }\n  // material.instanceTechnique properties should be directly on the material\n  updateInstanceTechniques(gltf);\n  // primitive.primitive should be primitive.mode\n  setPrimitiveModes(gltf);\n  // Node rotation should be quaternion, not axis-angle\n  // node.instanceSkin is deprecated\n  updateNodes(gltf);\n  // Animations that target rotations should be quaternion, not axis-angle\n  updateAnimations(gltf);\n  // technique.pass and techniques.passes are deprecated\n  removeTechniquePasses(gltf);\n  // gltf.allExtensions -> extensionsUsed\n  if (defined(gltf.allExtensions)) {\n    gltf.extensionsUsed = gltf.allExtensions;\n    delete gltf.allExtensions;\n  }\n  // gltf.lights -> khrMaterialsCommon.lights\n  if (defined(gltf.lights)) {\n    const extensions = gltf.extensions ?? {};\n    gltf.extensions = extensions;\n    const materialsCommon = extensions.KHR_materials_common ?? {};\n    extensions.KHR_materials_common = materialsCommon;\n    materialsCommon.lights = gltf.lights;\n    delete gltf.lights;\n    addExtensionsUsed(gltf, \"KHR_materials_common\");\n  }\n}\n\nfunction removeAnimationSamplersIndirection(gltf) {\n  const animations = gltf.animations;\n  for (const animationId in animations) {\n    if (Object.prototype.hasOwnProperty.call(animations, animationId)) {\n      const animation = animations[animationId];\n      const parameters = animation.parameters;\n      if (defined(parameters)) {\n        const samplers = animation.samplers;\n        for (const samplerId in samplers) {\n          if (Object.prototype.hasOwnProperty.call(samplers, samplerId)) {\n            const sampler = samplers[samplerId];\n            sampler.input = parameters[sampler.input];\n            sampler.output = parameters[sampler.output];\n          }\n        }\n        delete animation.parameters;\n      }\n    }\n  }\n}\n\nfunction objectToArray(object, mapping) {\n  const array = [];\n  for (const id in object) {\n    if (Object.prototype.hasOwnProperty.call(object, id)) {\n      const value = object[id];\n      mapping[id] = array.length;\n      array.push(value);\n      if (!defined(value.name)) {\n        value.name = id;\n      }\n    }\n  }\n  return array;\n}\n\nfunction objectsToArrays(gltf) {\n  let i;\n  const globalMapping = {\n    accessors: {},\n    animations: {},\n    buffers: {},\n    bufferViews: {},\n    cameras: {},\n    images: {},\n    materials: {},\n    meshes: {},\n    nodes: {},\n    programs: {},\n    samplers: {},\n    scenes: {},\n    shaders: {},\n    skins: {},\n    textures: {},\n    techniques: {},\n  };\n\n  // Map joint names to id names\n  let jointName;\n  const jointNameToId = {};\n  const nodes = gltf.nodes;\n  for (const id in nodes) {\n    if (Object.prototype.hasOwnProperty.call(nodes, id)) {\n      jointName = nodes[id].jointName;\n      if (defined(jointName)) {\n        jointNameToId[jointName] = id;\n      }\n    }\n  }\n\n  // Convert top level objects to arrays\n  for (const topLevelId in gltf) {\n    if (\n      Object.prototype.hasOwnProperty.call(gltf, topLevelId) &&\n      defined(globalMapping[topLevelId])\n    ) {\n      const objectMapping = {};\n      const object = gltf[topLevelId];\n      gltf[topLevelId] = objectToArray(object, objectMapping);\n      globalMapping[topLevelId] = objectMapping;\n    }\n  }\n\n  // Remap joint names to array indexes\n  for (jointName in jointNameToId) {\n    if (Object.prototype.hasOwnProperty.call(jointNameToId, jointName)) {\n      jointNameToId[jointName] = globalMapping.nodes[jointNameToId[jointName]];\n    }\n  }\n\n  // Fix references\n  if (defined(gltf.scene)) {\n    gltf.scene = globalMapping.scenes[gltf.scene];\n  }\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer)) {\n      bufferView.buffer = globalMapping.buffers[bufferView.buffer];\n    }\n  });\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      accessor.bufferView = globalMapping.bufferViews[accessor.bufferView];\n    }\n  });\n  ForEach.shader(gltf, function (shader) {\n    const extensions = shader.extensions;\n    if (defined(extensions)) {\n      const binaryGltf = extensions.KHR_binary_glTF;\n      if (defined(binaryGltf)) {\n        shader.bufferView = globalMapping.bufferViews[binaryGltf.bufferView];\n        delete extensions.KHR_binary_glTF;\n      }\n      if (Object.keys(extensions).length === 0) {\n        delete shader.extensions;\n      }\n    }\n  });\n  ForEach.program(gltf, function (program) {\n    if (defined(program.vertexShader)) {\n      program.vertexShader = globalMapping.shaders[program.vertexShader];\n    }\n    if (defined(program.fragmentShader)) {\n      program.fragmentShader = globalMapping.shaders[program.fragmentShader];\n    }\n  });\n  ForEach.technique(gltf, function (technique) {\n    if (defined(technique.program)) {\n      technique.program = globalMapping.programs[technique.program];\n    }\n    ForEach.techniqueParameter(technique, function (parameter) {\n      if (defined(parameter.node)) {\n        parameter.node = globalMapping.nodes[parameter.node];\n      }\n      const value = parameter.value;\n      if (typeof value === \"string\") {\n        parameter.value = {\n          index: globalMapping.textures[value],\n        };\n      }\n    });\n  });\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      if (defined(primitive.indices)) {\n        primitive.indices = globalMapping.accessors[primitive.indices];\n      }\n      ForEach.meshPrimitiveAttribute(\n        primitive,\n        function (accessorId, semantic) {\n          primitive.attributes[semantic] = globalMapping.accessors[accessorId];\n        },\n      );\n      if (defined(primitive.material)) {\n        primitive.material = globalMapping.materials[primitive.material];\n      }\n    });\n  });\n  ForEach.node(gltf, function (node) {\n    let children = node.children;\n    if (defined(children)) {\n      const childrenLength = children.length;\n      for (i = 0; i < childrenLength; ++i) {\n        children[i] = globalMapping.nodes[children[i]];\n      }\n    }\n    if (defined(node.meshes)) {\n      // Split out meshes on nodes\n      const meshes = node.meshes;\n      const meshesLength = meshes.length;\n      if (meshesLength > 0) {\n        node.mesh = globalMapping.meshes[meshes[0]];\n        for (i = 1; i < meshesLength; ++i) {\n          const meshNode = {\n            mesh: globalMapping.meshes[meshes[i]],\n          };\n          const meshNodeId = addToArray(gltf.nodes, meshNode);\n          if (!defined(children)) {\n            children = [];\n            node.children = children;\n          }\n          children.push(meshNodeId);\n        }\n      }\n      delete node.meshes;\n    }\n    if (defined(node.camera)) {\n      node.camera = globalMapping.cameras[node.camera];\n    }\n    if (defined(node.skin)) {\n      node.skin = globalMapping.skins[node.skin];\n    }\n    if (defined(node.skeletons)) {\n      // Assign skeletons to skins\n      const skeletons = node.skeletons;\n      const skeletonsLength = skeletons.length;\n      if (skeletonsLength > 0 && defined(node.skin)) {\n        const skin = gltf.skins[node.skin];\n        skin.skeleton = globalMapping.nodes[skeletons[0]];\n      }\n      delete node.skeletons;\n    }\n    if (defined(node.jointName)) {\n      delete node.jointName;\n    }\n  });\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.inverseBindMatrices)) {\n      skin.inverseBindMatrices =\n        globalMapping.accessors[skin.inverseBindMatrices];\n    }\n    const jointNames = skin.jointNames;\n    if (defined(jointNames)) {\n      const joints = [];\n      const jointNamesLength = jointNames.length;\n      for (i = 0; i < jointNamesLength; ++i) {\n        joints[i] = jointNameToId[jointNames[i]];\n      }\n      skin.joints = joints;\n      delete skin.jointNames;\n    }\n  });\n  ForEach.scene(gltf, function (scene) {\n    const sceneNodes = scene.nodes;\n    if (defined(sceneNodes)) {\n      const sceneNodesLength = sceneNodes.length;\n      for (i = 0; i < sceneNodesLength; ++i) {\n        sceneNodes[i] = globalMapping.nodes[sceneNodes[i]];\n      }\n    }\n  });\n  ForEach.animation(gltf, function (animation) {\n    const samplerMapping = {};\n    animation.samplers = objectToArray(animation.samplers, samplerMapping);\n    ForEach.animationSampler(animation, function (sampler) {\n      sampler.input = globalMapping.accessors[sampler.input];\n      sampler.output = globalMapping.accessors[sampler.output];\n    });\n    ForEach.animationChannel(animation, function (channel) {\n      channel.sampler = samplerMapping[channel.sampler];\n      const target = channel.target;\n      if (defined(target)) {\n        target.node = globalMapping.nodes[target.id];\n        delete target.id;\n      }\n    });\n  });\n  ForEach.material(gltf, function (material) {\n    if (defined(material.technique)) {\n      material.technique = globalMapping.techniques[material.technique];\n    }\n    ForEach.materialValue(material, function (value, name) {\n      if (typeof value === \"string\") {\n        material.values[name] = {\n          index: globalMapping.textures[value],\n        };\n      }\n    });\n    const extensions = material.extensions;\n    if (defined(extensions)) {\n      const materialsCommon = extensions.KHR_materials_common;\n      if (defined(materialsCommon) && defined(materialsCommon.values)) {\n        ForEach.materialValue(materialsCommon, function (value, name) {\n          if (typeof value === \"string\") {\n            materialsCommon.values[name] = {\n              index: globalMapping.textures[value],\n            };\n          }\n        });\n      }\n    }\n  });\n  ForEach.image(gltf, function (image) {\n    const extensions = image.extensions;\n    if (defined(extensions)) {\n      const binaryGltf = extensions.KHR_binary_glTF;\n      if (defined(binaryGltf)) {\n        image.bufferView = globalMapping.bufferViews[binaryGltf.bufferView];\n        image.mimeType = binaryGltf.mimeType;\n        delete extensions.KHR_binary_glTF;\n      }\n      if (Object.keys(extensions).length === 0) {\n        delete image.extensions;\n      }\n    }\n  });\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.sampler)) {\n      texture.sampler = globalMapping.samplers[texture.sampler];\n    }\n    if (defined(texture.source)) {\n      texture.source = globalMapping.images[texture.source];\n    }\n  });\n}\n\nfunction removeAnimationSamplerNames(gltf) {\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      delete sampler.name;\n    });\n  });\n}\n\nfunction removeEmptyArrays(gltf) {\n  for (const topLevelId in gltf) {\n    if (Object.prototype.hasOwnProperty.call(gltf, topLevelId)) {\n      const array = gltf[topLevelId];\n      if (Array.isArray(array) && array.length === 0) {\n        delete gltf[topLevelId];\n      }\n    }\n  }\n  ForEach.node(gltf, function (node) {\n    if (defined(node.children) && node.children.length === 0) {\n      delete node.children;\n    }\n  });\n}\n\nfunction stripAsset(gltf) {\n  const asset = gltf.asset;\n  delete asset.profile;\n  delete asset.premultipliedAlpha;\n}\n\nconst knownExtensions = {\n  CESIUM_RTC: true,\n  KHR_materials_common: true,\n  WEB3D_quantized_attributes: true,\n};\nfunction requireKnownExtensions(gltf) {\n  const extensionsUsed = gltf.extensionsUsed;\n  gltf.extensionsRequired = gltf.extensionsRequired ?? [];\n  if (defined(extensionsUsed)) {\n    const extensionsUsedLength = extensionsUsed.length;\n    for (let i = 0; i < extensionsUsedLength; ++i) {\n      const extension = extensionsUsed[i];\n      if (defined(knownExtensions[extension])) {\n        gltf.extensionsRequired.push(extension);\n      }\n    }\n  }\n}\n\nfunction removeBufferType(gltf) {\n  ForEach.buffer(gltf, function (buffer) {\n    delete buffer.type;\n  });\n}\n\nfunction removeTextureProperties(gltf) {\n  ForEach.texture(gltf, function (texture) {\n    delete texture.format;\n    delete texture.internalFormat;\n    delete texture.target;\n    delete texture.type;\n  });\n}\n\nfunction requireAttributeSetIndex(gltf) {\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      ForEach.meshPrimitiveAttribute(\n        primitive,\n        function (accessorId, semantic) {\n          if (semantic === \"TEXCOORD\") {\n            primitive.attributes.TEXCOORD_0 = accessorId;\n          } else if (semantic === \"COLOR\") {\n            primitive.attributes.COLOR_0 = accessorId;\n          }\n        },\n      );\n      delete primitive.attributes.TEXCOORD;\n      delete primitive.attributes.COLOR;\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueParameter(technique, function (parameter) {\n      const semantic = parameter.semantic;\n      if (defined(semantic)) {\n        if (semantic === \"TEXCOORD\") {\n          parameter.semantic = \"TEXCOORD_0\";\n        } else if (semantic === \"COLOR\") {\n          parameter.semantic = \"COLOR_0\";\n        }\n      }\n    });\n  });\n}\n\nconst knownSemantics = {\n  POSITION: true,\n  NORMAL: true,\n  TANGENT: true,\n};\nconst indexedSemantics = {\n  COLOR: \"COLOR\",\n  JOINT: \"JOINTS\",\n  JOINTS: \"JOINTS\",\n  TEXCOORD: \"TEXCOORD\",\n  WEIGHT: \"WEIGHTS\",\n  WEIGHTS: \"WEIGHTS\",\n};\nfunction underscoreApplicationSpecificSemantics(gltf) {\n  const mappedSemantics = {};\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      /*eslint-disable no-unused-vars*/\n      ForEach.meshPrimitiveAttribute(\n        primitive,\n        function (accessorId, semantic) {\n          if (semantic.charAt(0) !== \"_\") {\n            const setIndex = semantic.search(/_[0-9]+/g);\n            let strippedSemantic = semantic;\n            let suffix = \"_0\";\n            if (setIndex >= 0) {\n              strippedSemantic = semantic.substring(0, setIndex);\n              suffix = semantic.substring(setIndex);\n            }\n            let newSemantic;\n            const indexedSemantic = indexedSemantics[strippedSemantic];\n            if (defined(indexedSemantic)) {\n              newSemantic = indexedSemantic + suffix;\n              mappedSemantics[semantic] = newSemantic;\n            } else if (!defined(knownSemantics[strippedSemantic])) {\n              newSemantic = `_${semantic}`;\n              mappedSemantics[semantic] = newSemantic;\n            }\n          }\n        },\n      );\n      for (const semantic in mappedSemantics) {\n        if (Object.prototype.hasOwnProperty.call(mappedSemantics, semantic)) {\n          const mappedSemantic = mappedSemantics[semantic];\n          const accessorId = primitive.attributes[semantic];\n          if (defined(accessorId)) {\n            delete primitive.attributes[semantic];\n            primitive.attributes[mappedSemantic] = accessorId;\n          }\n        }\n      }\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueParameter(technique, function (parameter) {\n      const mappedSemantic = mappedSemantics[parameter.semantic];\n      if (defined(mappedSemantic)) {\n        parameter.semantic = mappedSemantic;\n      }\n    });\n  });\n}\n\nfunction clampCameraParameters(gltf) {\n  ForEach.camera(gltf, function (camera) {\n    const perspective = camera.perspective;\n    if (defined(perspective)) {\n      const aspectRatio = perspective.aspectRatio;\n      if (defined(aspectRatio) && aspectRatio === 0.0) {\n        delete perspective.aspectRatio;\n      }\n      const yfov = perspective.yfov;\n      if (defined(yfov) && yfov === 0.0) {\n        perspective.yfov = 1.0;\n      }\n    }\n  });\n}\n\nfunction computeAccessorByteStride(gltf, accessor) {\n  return defined(accessor.byteStride) && accessor.byteStride !== 0\n    ? accessor.byteStride\n    : getAccessorByteStride(gltf, accessor);\n}\n\nfunction requireByteLength(gltf) {\n  ForEach.buffer(gltf, function (buffer) {\n    if (!defined(buffer.byteLength)) {\n      buffer.byteLength = buffer.extras._pipeline.source.length;\n    }\n  });\n  ForEach.accessor(gltf, function (accessor) {\n    const bufferViewId = accessor.bufferView;\n    if (defined(bufferViewId)) {\n      const bufferView = gltf.bufferViews[bufferViewId];\n      const accessorByteStride = computeAccessorByteStride(gltf, accessor);\n      const accessorByteEnd =\n        accessor.byteOffset + accessor.count * accessorByteStride;\n      bufferView.byteLength = Math.max(\n        bufferView.byteLength ?? 0,\n        accessorByteEnd,\n      );\n    }\n  });\n}\n\nfunction moveByteStrideToBufferView(gltf) {\n  let i;\n  let j;\n  let bufferView;\n  const bufferViews = gltf.bufferViews;\n\n  const bufferViewHasVertexAttributes = {};\n  ForEach.accessorContainingVertexAttributeData(gltf, function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    if (defined(accessor.bufferView)) {\n      bufferViewHasVertexAttributes[accessor.bufferView] = true;\n    }\n  });\n\n  // Map buffer views to a list of accessors\n  const bufferViewMap = {};\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      bufferViewMap[accessor.bufferView] =\n        bufferViewMap[accessor.bufferView] ?? [];\n      bufferViewMap[accessor.bufferView].push(accessor);\n    }\n  });\n\n  // Split accessors with different byte strides\n  for (const bufferViewId in bufferViewMap) {\n    if (Object.prototype.hasOwnProperty.call(bufferViewMap, bufferViewId)) {\n      bufferView = bufferViews[bufferViewId];\n      const accessors = bufferViewMap[bufferViewId];\n      accessors.sort(function (a, b) {\n        return a.byteOffset - b.byteOffset;\n      });\n      let currentByteOffset = 0;\n      let currentIndex = 0;\n      const accessorsLength = accessors.length;\n      for (i = 0; i < accessorsLength; ++i) {\n        let accessor = accessors[i];\n        const accessorByteStride = computeAccessorByteStride(gltf, accessor);\n        const accessorByteOffset = accessor.byteOffset;\n        const accessorByteLength = accessor.count * accessorByteStride;\n        delete accessor.byteStride;\n\n        const hasNextAccessor = i < accessorsLength - 1;\n        const nextAccessorByteStride = hasNextAccessor\n          ? computeAccessorByteStride(gltf, accessors[i + 1])\n          : undefined;\n        if (accessorByteStride !== nextAccessorByteStride) {\n          const newBufferView = clone(bufferView, true);\n          if (bufferViewHasVertexAttributes[bufferViewId]) {\n            newBufferView.byteStride = accessorByteStride;\n          }\n          newBufferView.byteOffset += currentByteOffset;\n          newBufferView.byteLength =\n            accessorByteOffset + accessorByteLength - currentByteOffset;\n          const newBufferViewId = addToArray(bufferViews, newBufferView);\n          for (j = currentIndex; j <= i; ++j) {\n            accessor = accessors[j];\n            accessor.bufferView = newBufferViewId;\n            accessor.byteOffset = accessor.byteOffset - currentByteOffset;\n          }\n          // Set current byte offset to next accessor's byte offset\n          currentByteOffset = hasNextAccessor\n            ? accessors[i + 1].byteOffset\n            : undefined;\n          currentIndex = i + 1;\n        }\n      }\n    }\n  }\n\n  // Remove unused buffer views\n  removeUnusedElements(gltf, [\"accessor\", \"bufferView\", \"buffer\"]);\n}\n\nfunction requirePositionAccessorMinMax(gltf) {\n  ForEach.accessorWithSemantic(gltf, \"POSITION\", function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    if (!defined(accessor.min) || !defined(accessor.max)) {\n      const minMax = findAccessorMinMax(gltf, accessor);\n      accessor.min = minMax.min;\n      accessor.max = minMax.max;\n    }\n  });\n}\n\nfunction isNodeEmpty(node) {\n  return (\n    (!defined(node.children) || node.children.length === 0) &&\n    (!defined(node.meshes) || node.meshes.length === 0) &&\n    !defined(node.camera) &&\n    !defined(node.skin) &&\n    !defined(node.skeletons) &&\n    !defined(node.jointName) &&\n    (!defined(node.translation) ||\n      Cartesian3.fromArray(node.translation).equals(Cartesian3.ZERO)) &&\n    (!defined(node.scale) ||\n      Cartesian3.fromArray(node.scale).equals(new Cartesian3(1.0, 1.0, 1.0))) &&\n    (!defined(node.rotation) ||\n      Cartesian4.fromArray(node.rotation).equals(\n        new Cartesian4(0.0, 0.0, 0.0, 1.0),\n      )) &&\n    (!defined(node.matrix) ||\n      Matrix4.fromColumnMajorArray(node.matrix).equals(Matrix4.IDENTITY)) &&\n    !defined(node.extensions) &&\n    !defined(node.extras)\n  );\n}\n\nfunction deleteNode(gltf, nodeId) {\n  // Remove from list of nodes in scene\n  ForEach.scene(gltf, function (scene) {\n    const sceneNodes = scene.nodes;\n    if (defined(sceneNodes)) {\n      const sceneNodesLength = sceneNodes.length;\n      for (let i = sceneNodesLength; i >= 0; --i) {\n        if (sceneNodes[i] === nodeId) {\n          sceneNodes.splice(i, 1);\n          return;\n        }\n      }\n    }\n  });\n\n  // Remove parent node's reference to this node, and delete the parent if also empty\n  ForEach.node(gltf, function (parentNode, parentNodeId) {\n    if (defined(parentNode.children)) {\n      const index = parentNode.children.indexOf(nodeId);\n      if (index > -1) {\n        parentNode.children.splice(index, 1);\n\n        if (isNodeEmpty(parentNode)) {\n          deleteNode(gltf, parentNodeId);\n        }\n      }\n    }\n  });\n\n  delete gltf.nodes[nodeId];\n}\n\nfunction removeEmptyNodes(gltf) {\n  ForEach.node(gltf, function (node, nodeId) {\n    if (isNodeEmpty(node)) {\n      deleteNode(gltf, nodeId);\n    }\n  });\n\n  return gltf;\n}\n\nfunction requireAnimationAccessorMinMax(gltf) {\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      const accessor = gltf.accessors[sampler.input];\n      if (!defined(accessor.min) || !defined(accessor.max)) {\n        const minMax = findAccessorMinMax(gltf, accessor);\n        accessor.min = minMax.min;\n        accessor.max = minMax.max;\n      }\n    });\n  });\n}\n\nfunction validatePresentAccessorMinMax(gltf) {\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.min) || defined(accessor.max)) {\n      const minMax = findAccessorMinMax(gltf, accessor);\n      if (defined(accessor.min)) {\n        accessor.min = minMax.min;\n      }\n      if (defined(accessor.max)) {\n        accessor.max = minMax.max;\n      }\n    }\n  });\n}\n\nfunction glTF10to20(gltf) {\n  gltf.asset = gltf.asset ?? {};\n  gltf.asset.version = \"2.0\";\n  // material.instanceTechnique properties should be directly on the material. instanceTechnique is a gltf 0.8 property but is seen in some 1.0 models.\n  updateInstanceTechniques(gltf);\n  // animation.samplers now refers directly to accessors and animation.parameters should be removed\n  removeAnimationSamplersIndirection(gltf);\n  // Remove empty nodes and re-assign referencing indices\n  removeEmptyNodes(gltf);\n  // Top-level objects are now arrays referenced by index instead of id\n  objectsToArrays(gltf);\n  // Animation.sampler objects cannot have names\n  removeAnimationSamplerNames(gltf);\n  // asset.profile no longer exists\n  stripAsset(gltf);\n  // Move known extensions from extensionsUsed to extensionsRequired\n  requireKnownExtensions(gltf);\n  // bufferView.byteLength and buffer.byteLength are required\n  requireByteLength(gltf);\n  // byteStride moved from accessor to bufferView\n  moveByteStrideToBufferView(gltf);\n  // accessor.min and accessor.max must be defined for accessors containing POSITION attributes\n  requirePositionAccessorMinMax(gltf);\n  // An animation sampler's input accessor must have min and max properties defined\n  requireAnimationAccessorMinMax(gltf);\n  // When an acccessor has a min- or max, then it is recomputed, to capture the actual\n  // value, and not use the (possibly imprecise) value from the input\n  validatePresentAccessorMinMax(gltf);\n  // buffer.type is unnecessary and should be removed\n  removeBufferType(gltf);\n  // Remove format, internalFormat, target, and type\n  removeTextureProperties(gltf);\n  // TEXCOORD and COLOR attributes must be written with a set index (TEXCOORD_#)\n  requireAttributeSetIndex(gltf);\n  // Add underscores to application-specific parameters\n  underscoreApplicationSpecificSemantics(gltf);\n  // Accessors referenced by JOINTS_0 and WEIGHTS_0 attributes must have correct component types\n  updateAccessorComponentTypes(gltf);\n  // Clamp camera parameters\n  clampCameraParameters(gltf);\n  // Move legacy technique render states to material properties and add KHR_blend extension blending functions\n  moveTechniqueRenderStates(gltf);\n  // Add material techniques to KHR_techniques_webgl extension, removing shaders, programs, and techniques\n  moveTechniquesToExtension(gltf);\n  // Remove empty arrays\n  removeEmptyArrays(gltf);\n}\n\n// It's not possible to upgrade glTF 1.0 shaders to 2.0 PBR materials in a generic way,\n// but we can look for certain uniform names that are commonly found in glTF 1.0 assets\n// and create PBR materials out of those.\nconst defaultBaseColorTextureNames = [\n  \"u_tex\",\n  \"u_diffuse\",\n  \"u_emission\",\n  \"u_diffuse_tex\",\n];\nconst defaultBaseColorFactorNames = [\"u_diffuse\", \"u_diffuse_mat\"];\n\nfunction initializePbrMaterial(material) {\n  material.pbrMetallicRoughness = defined(material.pbrMetallicRoughness)\n    ? material.pbrMetallicRoughness\n    : {};\n\n  material.pbrMetallicRoughness.roughnessFactor = 1.0;\n  material.pbrMetallicRoughness.metallicFactor = 0.0;\n}\n\nfunction isTexture(value) {\n  return defined(value.index);\n}\n\nfunction isVec4(value) {\n  return Array.isArray(value) && value.length === 4;\n}\n\nfunction srgbToLinear(srgb) {\n  const linear = new Array(4);\n  linear[3] = srgb[3];\n\n  for (let i = 0; i < 3; i++) {\n    const c = srgb[i];\n    if (c <= 0.04045) {\n      // eslint-disable-next-line no-loss-of-precision\n      linear[i] = srgb[i] * 0.07739938080495356037151702786378;\n    } else {\n      linear[i] = Math.pow(\n        // eslint-disable-next-line no-loss-of-precision\n        (c + 0.055) * 0.94786729857819905213270142180095,\n        2.4,\n      );\n    }\n  }\n\n  return linear;\n}\n\nfunction convertTechniquesToPbr(gltf, options) {\n  options = options ?? {};\n  const baseColorTextureNames =\n    options.baseColorTextureNames ?? defaultBaseColorTextureNames;\n  const baseColorFactorNames =\n    options.baseColorFactorNames ?? defaultBaseColorFactorNames;\n\n  // Future work: convert other values like emissive, specular, etc. Only handling diffuse right now.\n  ForEach.material(gltf, function (material) {\n    ForEach.materialValue(material, function (value, name) {\n      if (baseColorTextureNames.indexOf(name) !== -1 && isTexture(value)) {\n        initializePbrMaterial(material);\n        material.pbrMetallicRoughness.baseColorTexture = value;\n      } else if (baseColorFactorNames.indexOf(name) !== -1 && isVec4(value)) {\n        initializePbrMaterial(material);\n        material.pbrMetallicRoughness.baseColorFactor = srgbToLinear(value);\n      }\n    });\n  });\n\n  removeExtension(gltf, \"KHR_techniques_webgl\");\n  removeExtension(gltf, \"KHR_blend\");\n}\n\nfunction assignAsBaseColor(material, baseColor) {\n  if (defined(baseColor)) {\n    if (isVec4(baseColor)) {\n      material.pbrMetallicRoughness.baseColorFactor = srgbToLinear(baseColor);\n    } else if (isTexture(baseColor)) {\n      material.pbrMetallicRoughness.baseColorTexture = baseColor;\n    }\n  }\n}\n\nfunction assignAsEmissive(material, emissive) {\n  if (defined(emissive)) {\n    if (isVec4(emissive)) {\n      material.emissiveFactor = emissive.slice(0, 3);\n    } else if (isTexture(emissive)) {\n      material.emissiveTexture = emissive;\n    }\n  }\n}\n\nfunction convertMaterialsCommonToPbr(gltf) {\n  // Future work: convert KHR_materials_common lights to KHR_lights_punctual\n  ForEach.material(gltf, function (material) {\n    const materialsCommon = (material.extensions ?? {}).KHR_materials_common;\n    if (!defined(materialsCommon)) {\n      // Nothing to do\n      return;\n    }\n\n    const values = materialsCommon.values ?? {};\n    const ambient = values.ambient;\n    const diffuse = values.diffuse;\n    const emission = values.emission;\n    const transparency = values.transparency;\n\n    // These actually exist on the extension object, not the values object despite what's shown in the spec\n    const doubleSided = materialsCommon.doubleSided;\n    const transparent = materialsCommon.transparent;\n\n    // Ignore specular and shininess for now because the conversion to PBR\n    // isn't straightforward and depends on the technique\n    initializePbrMaterial(material);\n\n    const technique = materialsCommon.technique;\n    if (technique === \"CONSTANT\") {\n      // Add the KHR_materials_unlit extension\n      addExtensionsUsed(gltf, \"KHR_materials_unlit\");\n      material.extensions = defined(material.extensions)\n        ? material.extensions\n        : {};\n      material.extensions[\"KHR_materials_unlit\"] = {};\n\n      // The CONSTANT technique does not support 'diffuse', so\n      // assign either the 'emission' or the 'ambient' as the\n      // base color\n      assignAsBaseColor(material, emission);\n      assignAsBaseColor(material, ambient);\n    } else {\n      // Assign the 'diffuse' as the base color, and\n      // the 'ambient' or 'emissive' as the emissive\n      // part if they are present.\n      assignAsBaseColor(material, diffuse);\n      assignAsEmissive(material, ambient);\n      assignAsEmissive(material, emission);\n    }\n\n    if (defined(doubleSided)) {\n      material.doubleSided = doubleSided;\n    }\n    if (defined(transparency)) {\n      if (defined(material.pbrMetallicRoughness.baseColorFactor)) {\n        material.pbrMetallicRoughness.baseColorFactor[3] *= transparency;\n      } else {\n        material.pbrMetallicRoughness.baseColorFactor = [1, 1, 1, transparency];\n      }\n    }\n    if (defined(transparent)) {\n      material.alphaMode = transparent ? \"BLEND\" : \"OPAQUE\";\n    }\n  });\n\n  removeExtension(gltf, \"KHR_materials_common\");\n}\n\nexport default updateVersion;\n"],"names":["updateFunctions","glTF08to10","glTF10to20","undefined","updateVersion","gltf","options","targetVersion","version","asset","toString","Object","prototype","hasOwnProperty","call","substring","updateFunction","keepLegacyExtensions","convertTechniquesToPbr","convertMaterialsCommonToPbr","updateInstanceTechniques","materials","materialId","material","instanceTechnique","technique","values","setPrimitiveModes","meshes","meshId","mesh","primitives","primitivesLength","length","i","primitive","defaultMode","TRIANGLES","mode","updateNodes","nodes","axis","quat","nodeId","node","rotation","fromArray","fromAxisAngle","x","y","z","w","instanceSkin","skeletons","skin","updateAnimations","animations","accessors","bufferViews","buffers","updatedAccessors","animationId","animation","channels","parameters","samplers","channelsLength","channel","target","path","accessorId","sampler","output","accessor","bufferView","buffer","source","extras","_pipeline","byteOffset","componentType","count","componentsLength","type","typedArray","createArrayBufferView","j","offset","unpack","angle","pack","removeTechniquePasses","techniques","techniqueId","passes","passName","pass","instanceProgram","attributes","program","uniforms","states","profile","split","api","allExtensions","extensionsUsed","lights","extensions","materialsCommon","KHR_materials_common","removeAnimationSamplersIndirection","samplerId","input","objectToArray","object","mapping","array","id","value","push","name","objectsToArrays","globalMapping","cameras","images","programs","scenes","shaders","skins","textures","jointName","jointNameToId","topLevelId","objectMapping","scene","shader","binaryGltf","KHR_binary_glTF","keys","vertexShader","fragmentShader","techniqueParameter","parameter","index","meshPrimitive","indices","meshPrimitiveAttribute","semantic","children","childrenLength","meshesLength","meshNode","meshNodeId","camera","skeletonsLength","skeleton","inverseBindMatrices","jointNames","joints","jointNamesLength","sceneNodes","sceneNodesLength","samplerMapping","animationSampler","animationChannel","materialValue","image","mimeType","texture","removeAnimationSamplerNames","removeEmptyArrays","Array","isArray","stripAsset","premultipliedAlpha","knownExtensions","CESIUM_RTC","WEB3D_quantized_attributes","requireKnownExtensions","extensionsRequired","extensionsUsedLength","extension","removeBufferType","removeTextureProperties","format","internalFormat","requireAttributeSetIndex","TEXCOORD_0","COLOR_0","TEXCOORD","COLOR","knownSemantics","POSITION","NORMAL","TANGENT","indexedSemantics","JOINT","JOINTS","WEIGHT","WEIGHTS","underscoreApplicationSpecificSemantics","mappedSemantics","charAt","setIndex","search","strippedSemantic","suffix","newSemantic","indexedSemantic","mappedSemantic","clampCameraParameters","perspective","aspectRatio","yfov","computeAccessorByteStride","byteStride","requireByteLength","byteLength","bufferViewId","accessorByteStride","accessorByteEnd","Math","max","moveByteStrideToBufferView","bufferViewHasVertexAttributes","accessorContainingVertexAttributeData","bufferViewMap","sort","a","b","currentByteOffset","currentIndex","accessorsLength","accessorByteOffset","accessorByteLength","hasNextAccessor","nextAccessorByteStride","newBufferView","newBufferViewId","requirePositionAccessorMinMax","accessorWithSemantic","min","minMax","isNodeEmpty","translation","equals","ZERO","scale","matrix","fromColumnMajorArray","IDENTITY","deleteNode","splice","parentNode","parentNodeId","indexOf","removeEmptyNodes","requireAnimationAccessorMinMax","validatePresentAccessorMinMax","defaultBaseColorTextureNames","defaultBaseColorFactorNames","initializePbrMaterial","pbrMetallicRoughness","roughnessFactor","metallicFactor","isTexture","isVec4","srgbToLinear","srgb","linear","c","pow","baseColorTextureNames","baseColorFactorNames","baseColorTexture","baseColorFactor","assignAsBaseColor","baseColor","assignAsEmissive","emissive","emissiveFactor","slice","emissiveTexture","ambient","diffuse","emission","transparency","doubleSided","transparent","alphaMode"],"mappings":"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","ignoreList":[0]}}]
}