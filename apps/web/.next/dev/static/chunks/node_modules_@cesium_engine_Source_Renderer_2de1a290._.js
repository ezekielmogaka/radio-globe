(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@cesium/engine/Source/Renderer/DrawCommand.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PrimitiveType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/PrimitiveType.js [app-client] (ecmascript)");
;
;
;
const Flags = {
    CULL: 1,
    OCCLUDE: 2,
    EXECUTE_IN_CLOSEST_FRUSTUM: 4,
    DEBUG_SHOW_BOUNDING_VOLUME: 8,
    CAST_SHADOWS: 16,
    RECEIVE_SHADOWS: 32,
    PICK_ONLY: 64,
    DEPTH_FOR_TRANSLUCENT_CLASSIFICATION: 128
};
/**
 * Represents a command to the renderer for drawing.
 *
 * @alias DrawCommand
 * @constructor
 *
 * @private
 */ function DrawCommand(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    this._boundingVolume = options.boundingVolume;
    this._orientedBoundingBox = options.orientedBoundingBox;
    this._modelMatrix = options.modelMatrix;
    this._primitiveType = options.primitiveType ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PrimitiveType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TRIANGLES;
    this._vertexArray = options.vertexArray;
    this._count = options.count;
    this._offset = options.offset ?? 0;
    this._instanceCount = options.instanceCount ?? 0;
    this._shaderProgram = options.shaderProgram;
    this._uniformMap = options.uniformMap;
    this._renderState = options.renderState;
    this._framebuffer = options.framebuffer;
    this._pass = options.pass;
    this._owner = options.owner;
    this._debugOverlappingFrustums = 0;
    this._pickId = options.pickId;
    this._pickMetadataAllowed = options.pickMetadataAllowed === true;
    this._pickedMetadataInfo = undefined;
    // Set initial flags.
    this._flags = 0;
    this.cull = options.cull ?? true;
    this.occlude = options.occlude ?? true;
    this.executeInClosestFrustum = options.executeInClosestFrustum ?? false;
    this.debugShowBoundingVolume = options.debugShowBoundingVolume ?? false;
    this.castShadows = options.castShadows ?? false;
    this.receiveShadows = options.receiveShadows ?? false;
    this.pickOnly = options.pickOnly ?? false;
    this.depthForTranslucentClassification = options.depthForTranslucentClassification ?? false;
    this.dirty = true;
    this.lastDirtyTime = 0;
    /**
   * @private
   */ this.derivedCommands = {};
}
function hasFlag(command, flag) {
    return (command._flags & flag) === flag;
}
function setFlag(command, flag, value) {
    if (value) {
        command._flags |= flag;
    } else {
        command._flags &= ~flag;
    }
}
Object.defineProperties(DrawCommand.prototype, {
    /**
   * The bounding volume of the geometry in world space.  This is used for culling and frustum selection.
   * <p>
   * For best rendering performance, use the tightest possible bounding volume.  Although
   * <code>undefined</code> is allowed, always try to provide a bounding volume to
   * allow the tightest possible near and far planes to be computed for the scene, and
   * minimize the number of frustums needed.
   * </p>
   *
   * @memberof DrawCommand.prototype
   * @type {object}
   * @default undefined
   *
   * @see DrawCommand#debugShowBoundingVolume
   */ boundingVolume: {
        get: function() {
            return this._boundingVolume;
        },
        set: function(value) {
            if (this._boundingVolume !== value) {
                this._boundingVolume = value;
                this.dirty = true;
            }
        }
    },
    /**
   * The oriented bounding box of the geometry in world space. If this is defined, it is used instead of
   * {@link DrawCommand#boundingVolume} for plane intersection testing.
   *
   * @memberof DrawCommand.prototype
   * @type {OrientedBoundingBox}
   * @default undefined
   *
   * @see DrawCommand#debugShowBoundingVolume
   */ orientedBoundingBox: {
        get: function() {
            return this._orientedBoundingBox;
        },
        set: function(value) {
            if (this._orientedBoundingBox !== value) {
                this._orientedBoundingBox = value;
                this.dirty = true;
            }
        }
    },
    /**
   * When <code>true</code>, the renderer frustum and horizon culls the command based on its {@link DrawCommand#boundingVolume}.
   * If the command was already culled, set this to <code>false</code> for a performance improvement.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default true
   */ cull: {
        get: function() {
            return hasFlag(this, Flags.CULL);
        },
        set: function(value) {
            if (hasFlag(this, Flags.CULL) !== value) {
                setFlag(this, Flags.CULL, value);
                this.dirty = true;
            }
        }
    },
    /**
   * When <code>true</code>, the horizon culls the command based on its {@link DrawCommand#boundingVolume}.
   * {@link DrawCommand#cull} must also be <code>true</code> in order for the command to be culled.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default true
   */ occlude: {
        get: function() {
            return hasFlag(this, Flags.OCCLUDE);
        },
        set: function(value) {
            if (hasFlag(this, Flags.OCCLUDE) !== value) {
                setFlag(this, Flags.OCCLUDE, value);
                this.dirty = true;
            }
        }
    },
    /**
   * The transformation from the geometry in model space to world space.
   * <p>
   * When <code>undefined</code>, the geometry is assumed to be defined in world space.
   * </p>
   *
   * @memberof DrawCommand.prototype
   * @type {Matrix4}
   * @default undefined
   */ modelMatrix: {
        get: function() {
            return this._modelMatrix;
        },
        set: function(value) {
            if (this._modelMatrix !== value) {
                this._modelMatrix = value;
                this.dirty = true;
            }
        }
    },
    /**
   * The type of geometry in the vertex array.
   *
   * @memberof DrawCommand.prototype
   * @type {PrimitiveType}
   * @default PrimitiveType.TRIANGLES
   */ primitiveType: {
        get: function() {
            return this._primitiveType;
        },
        set: function(value) {
            if (this._primitiveType !== value) {
                this._primitiveType = value;
                this.dirty = true;
            }
        }
    },
    /**
   * The vertex array.
   *
   * @memberof DrawCommand.prototype
   * @type {VertexArray}
   * @default undefined
   */ vertexArray: {
        get: function() {
            return this._vertexArray;
        },
        set: function(value) {
            if (this._vertexArray !== value) {
                this._vertexArray = value;
                this.dirty = true;
            }
        }
    },
    /**
   * The number of vertices to draw in the vertex array.
   *
   * @memberof DrawCommand.prototype
   * @type {number}
   * @default undefined
   */ count: {
        get: function() {
            return this._count;
        },
        set: function(value) {
            if (this._count !== value) {
                this._count = value;
                this.dirty = true;
            }
        }
    },
    /**
   * The offset to start drawing in the vertex array.
   *
   * @memberof DrawCommand.prototype
   * @type {number}
   * @default 0
   */ offset: {
        get: function() {
            return this._offset;
        },
        set: function(value) {
            if (this._offset !== value) {
                this._offset = value;
                this.dirty = true;
            }
        }
    },
    /**
   * The number of instances to draw.
   *
   * @memberof DrawCommand.prototype
   * @type {number}
   * @default 0
   */ instanceCount: {
        get: function() {
            return this._instanceCount;
        },
        set: function(value) {
            if (this._instanceCount !== value) {
                this._instanceCount = value;
                this.dirty = true;
            }
        }
    },
    /**
   * The shader program to apply.
   *
   * @memberof DrawCommand.prototype
   * @type {ShaderProgram}
   * @default undefined
   */ shaderProgram: {
        get: function() {
            return this._shaderProgram;
        },
        set: function(value) {
            if (this._shaderProgram !== value) {
                this._shaderProgram = value;
                this.dirty = true;
            }
        }
    },
    /**
   * Whether this command should cast shadows when shadowing is enabled.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   */ castShadows: {
        get: function() {
            return hasFlag(this, Flags.CAST_SHADOWS);
        },
        set: function(value) {
            if (hasFlag(this, Flags.CAST_SHADOWS) !== value) {
                setFlag(this, Flags.CAST_SHADOWS, value);
                this.dirty = true;
            }
        }
    },
    /**
   * Whether this command should receive shadows when shadowing is enabled.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   */ receiveShadows: {
        get: function() {
            return hasFlag(this, Flags.RECEIVE_SHADOWS);
        },
        set: function(value) {
            if (hasFlag(this, Flags.RECEIVE_SHADOWS) !== value) {
                setFlag(this, Flags.RECEIVE_SHADOWS, value);
                this.dirty = true;
            }
        }
    },
    /**
   * An object with functions whose names match the uniforms in the shader program
   * and return values to set those uniforms.
   *
   * @memberof DrawCommand.prototype
   * @type {object}
   * @default undefined
   */ uniformMap: {
        get: function() {
            return this._uniformMap;
        },
        set: function(value) {
            if (this._uniformMap !== value) {
                this._uniformMap = value;
                this.dirty = true;
            }
        }
    },
    /**
   * The render state.
   *
   * @memberof DrawCommand.prototype
   * @type {RenderState}
   * @default undefined
   */ renderState: {
        get: function() {
            return this._renderState;
        },
        set: function(value) {
            if (this._renderState !== value) {
                this._renderState = value;
                this.dirty = true;
            }
        }
    },
    /**
   * The framebuffer to draw to.
   *
   * @memberof DrawCommand.prototype
   * @type {Framebuffer}
   * @default undefined
   */ framebuffer: {
        get: function() {
            return this._framebuffer;
        },
        set: function(value) {
            if (this._framebuffer !== value) {
                this._framebuffer = value;
                this.dirty = true;
            }
        }
    },
    /**
   * The pass when to render.
   *
   * @memberof DrawCommand.prototype
   * @type {Pass}
   * @default undefined
   */ pass: {
        get: function() {
            return this._pass;
        },
        set: function(value) {
            if (this._pass !== value) {
                this._pass = value;
                this.dirty = true;
            }
        }
    },
    /**
   * Specifies if this command is only to be executed in the frustum closest
   * to the eye containing the bounding volume. Defaults to <code>false</code>.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   */ executeInClosestFrustum: {
        get: function() {
            return hasFlag(this, Flags.EXECUTE_IN_CLOSEST_FRUSTUM);
        },
        set: function(value) {
            if (hasFlag(this, Flags.EXECUTE_IN_CLOSEST_FRUSTUM) !== value) {
                setFlag(this, Flags.EXECUTE_IN_CLOSEST_FRUSTUM, value);
                this.dirty = true;
            }
        }
    },
    /**
   * The object who created this command.  This is useful for debugging command
   * execution; it allows us to see who created a command when we only have a
   * reference to the command, and can be used to selectively execute commands
   * with {@link Scene#debugCommandFilter}.
   *
   * @memberof DrawCommand.prototype
   * @type {object}
   * @default undefined
   *
   * @see Scene#debugCommandFilter
   */ owner: {
        get: function() {
            return this._owner;
        },
        set: function(value) {
            if (this._owner !== value) {
                this._owner = value;
                this.dirty = true;
            }
        }
    },
    /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * Draws the {@link DrawCommand#boundingVolume} for this command, assuming it is a sphere, when the command executes.
   * </p>
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   *
   * @see DrawCommand#boundingVolume
   */ debugShowBoundingVolume: {
        get: function() {
            return hasFlag(this, Flags.DEBUG_SHOW_BOUNDING_VOLUME);
        },
        set: function(value) {
            if (hasFlag(this, Flags.DEBUG_SHOW_BOUNDING_VOLUME) !== value) {
                setFlag(this, Flags.DEBUG_SHOW_BOUNDING_VOLUME, value);
                this.dirty = true;
            }
        }
    },
    /**
   * Used to implement Scene.debugShowFrustums.
   * @private
   */ debugOverlappingFrustums: {
        get: function() {
            return this._debugOverlappingFrustums;
        },
        set: function(value) {
            if (this._debugOverlappingFrustums !== value) {
                this._debugOverlappingFrustums = value;
                this.dirty = true;
            }
        }
    },
    /**
   * A GLSL string that will evaluate to a pick id. When <code>undefined</code>, the command will only draw depth
   * during the pick pass.
   *
   * @memberof DrawCommand.prototype
   * @type {string|undefined}
   * @default undefined
   */ pickId: {
        get: function() {
            return this._pickId;
        },
        set: function(value) {
            if (this._pickId !== value) {
                this._pickId = value;
                this.dirty = true;
            }
        }
    },
    /**
   * Whether metadata picking is allowed.
   *
   * This is essentially only set to `true` for draw commands that are
   * part of a `ModelDrawCommand`, to check whether a derived command
   * for metadata picking has to be created.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default undefined
   * @private
   */ pickMetadataAllowed: {
        get: function() {
            return this._pickMetadataAllowed;
        }
    },
    /**
   * Information about picked metadata.
   *
   * @memberof DrawCommand.prototype
   * @type {PickedMetadataInfo|undefined}
   * @default undefined
   */ pickedMetadataInfo: {
        get: function() {
            return this._pickedMetadataInfo;
        },
        set: function(value) {
            if (this._pickedMetadataInfo !== value) {
                this._pickedMetadataInfo = value;
                this.dirty = true;
            }
        }
    },
    /**
   * Whether this command should be executed in the pick pass only.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   */ pickOnly: {
        get: function() {
            return hasFlag(this, Flags.PICK_ONLY);
        },
        set: function(value) {
            if (hasFlag(this, Flags.PICK_ONLY) !== value) {
                setFlag(this, Flags.PICK_ONLY, value);
                this.dirty = true;
            }
        }
    },
    /**
   * Whether this command should be derived to draw depth for classification of translucent primitives.
   *
   * @memberof DrawCommand.prototype
   * @type {boolean}
   * @default false
   */ depthForTranslucentClassification: {
        get: function() {
            return hasFlag(this, Flags.DEPTH_FOR_TRANSLUCENT_CLASSIFICATION);
        },
        set: function(value) {
            if (hasFlag(this, Flags.DEPTH_FOR_TRANSLUCENT_CLASSIFICATION) !== value) {
                setFlag(this, Flags.DEPTH_FOR_TRANSLUCENT_CLASSIFICATION, value);
                this.dirty = true;
            }
        }
    }
});
/**
 * @private
 */ DrawCommand.shallowClone = function(command, result) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(command)) {
        return undefined;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result)) {
        result = new DrawCommand();
    }
    result._boundingVolume = command._boundingVolume;
    result._orientedBoundingBox = command._orientedBoundingBox;
    result._modelMatrix = command._modelMatrix;
    result._primitiveType = command._primitiveType;
    result._vertexArray = command._vertexArray;
    result._count = command._count;
    result._offset = command._offset;
    result._instanceCount = command._instanceCount;
    result._shaderProgram = command._shaderProgram;
    result._uniformMap = command._uniformMap;
    result._renderState = command._renderState;
    result._framebuffer = command._framebuffer;
    result._pass = command._pass;
    result._owner = command._owner;
    result._debugOverlappingFrustums = command._debugOverlappingFrustums;
    result._pickId = command._pickId;
    result._pickMetadataAllowed = command._pickMetadataAllowed;
    result._pickedMetadataInfo = command._pickedMetadataInfo;
    result._flags = command._flags;
    result.dirty = true;
    result.lastDirtyTime = 0;
    return result;
};
/**
 * Executes the draw command.
 *
 * @param {Context} context The renderer context in which to draw.
 * @param {PassState} [passState] The state for the current render pass.
 */ DrawCommand.prototype.execute = function(context, passState) {
    context.draw(this, passState);
};
const __TURBOPACK__default__export__ = DrawCommand;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/Pass.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
/**
 * The render pass for a command.
 *
 * @private
 */ const Pass = {
    // If you add/modify/remove Pass constants, also change the automatic GLSL constants
    // that start with 'czm_pass'
    //
    // Commands are executed in order by pass up to the translucent pass.
    // Translucent geometry needs special handling (sorting/OIT). The compute pass
    // is executed first and the overlay pass is executed last. Both are not sorted
    // by frustum.
    ENVIRONMENT: 0,
    COMPUTE: 1,
    GLOBE: 2,
    TERRAIN_CLASSIFICATION: 3,
    CESIUM_3D_TILE_EDGES: 4,
    CESIUM_3D_TILE: 5,
    CESIUM_3D_TILE_CLASSIFICATION: 6,
    CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW: 7,
    OPAQUE: 8,
    TRANSLUCENT: 9,
    VOXELS: 10,
    GAUSSIAN_SPLATS: 11,
    OVERLAY: 12,
    NUMBER_OF_PASSES: 13
};
const __TURBOPACK__default__export__ = Object.freeze(Pass);
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/ContextLimits.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
/**
 * These are set in the constructor for {@link Context}
 *
 * @private
 */ const ContextLimits = {
    _maximumCombinedTextureImageUnits: 0,
    _maximumCubeMapSize: 0,
    _maximumFragmentUniformVectors: 0,
    _maximumTextureImageUnits: 0,
    _maximumRenderbufferSize: 0,
    _maximumTextureSize: 0,
    _maximumVaryingVectors: 0,
    _maximumVertexAttributes: 0,
    _maximumVertexTextureImageUnits: 0,
    _maximumVertexUniformVectors: 0,
    _minimumAliasedLineWidth: 0,
    _maximumAliasedLineWidth: 0,
    _minimumAliasedPointSize: 0,
    _maximumAliasedPointSize: 0,
    _maximumViewportWidth: 0,
    _maximumViewportHeight: 0,
    _maximumTextureFilterAnisotropy: 0,
    _maximumDrawBuffers: 0,
    _maximumColorAttachments: 0,
    _maximumSamples: 0,
    _highpFloatSupported: false,
    _highpIntSupported: false
};
Object.defineProperties(ContextLimits, {
    /**
   * The maximum number of texture units that can be used from the vertex and fragment
   * shader with this WebGL implementation.  The minimum is eight.  If both shaders access the
   * same texture unit, this counts as two texture units.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_COMBINED_TEXTURE_IMAGE_UNITS</code>.
   */ maximumCombinedTextureImageUnits: {
        get: function() {
            return ContextLimits._maximumCombinedTextureImageUnits;
        }
    },
    /**
   * The approximate maximum cube map width and height supported by this WebGL implementation.
   * The minimum is 16, but most desktop and laptop implementations will support much larger sizes like 8,192.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_CUBE_MAP_TEXTURE_SIZE</code>.
   */ maximumCubeMapSize: {
        get: function() {
            return ContextLimits._maximumCubeMapSize;
        }
    },
    /**
   * The maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code>
   * uniforms that can be used by a fragment shader with this WebGL implementation.  The minimum is 16.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_FRAGMENT_UNIFORM_VECTORS</code>.
   */ maximumFragmentUniformVectors: {
        get: function() {
            return ContextLimits._maximumFragmentUniformVectors;
        }
    },
    /**
   * The maximum number of texture units that can be used from the fragment shader with this WebGL implementation.  The minimum is eight.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_TEXTURE_IMAGE_UNITS</code>.
   */ maximumTextureImageUnits: {
        get: function() {
            return ContextLimits._maximumTextureImageUnits;
        }
    },
    /**
   * The maximum renderbuffer width and height supported by this WebGL implementation.
   * The minimum is 16, but most desktop and laptop implementations will support much larger sizes like 8,192.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_RENDERBUFFER_SIZE</code>.
   */ maximumRenderbufferSize: {
        get: function() {
            return ContextLimits._maximumRenderbufferSize;
        }
    },
    /**
   * The approximate maximum texture width and height supported by this WebGL implementation.
   * The minimum is 64, but most desktop and laptop implementations will support much larger sizes like 8,192.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_TEXTURE_SIZE</code>.
   */ maximumTextureSize: {
        get: function() {
            return ContextLimits._maximumTextureSize;
        }
    },
    /**
   * The maximum number of <code>vec4</code> varying variables supported by this WebGL implementation.
   * The minimum is eight.  Matrices and arrays count as multiple <code>vec4</code>s.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VARYING_VECTORS</code>.
   */ maximumVaryingVectors: {
        get: function() {
            return ContextLimits._maximumVaryingVectors;
        }
    },
    /**
   * The maximum number of <code>vec4</code> vertex attributes supported by this WebGL implementation.  The minimum is eight.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VERTEX_ATTRIBS</code>.
   */ maximumVertexAttributes: {
        get: function() {
            return ContextLimits._maximumVertexAttributes;
        }
    },
    /**
   * The maximum number of texture units that can be used from the vertex shader with this WebGL implementation.
   * The minimum is zero, which means the GL does not support vertex texture fetch.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VERTEX_TEXTURE_IMAGE_UNITS</code>.
   */ maximumVertexTextureImageUnits: {
        get: function() {
            return ContextLimits._maximumVertexTextureImageUnits;
        }
    },
    /**
   * The maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code>
   * uniforms that can be used by a vertex shader with this WebGL implementation.  The minimum is 16.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VERTEX_UNIFORM_VECTORS</code>.
   */ maximumVertexUniformVectors: {
        get: function() {
            return ContextLimits._maximumVertexUniformVectors;
        }
    },
    /**
   * The minimum aliased line width, in pixels, supported by this WebGL implementation.  It will be at most one.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>ALIASED_LINE_WIDTH_RANGE</code>.
   */ minimumAliasedLineWidth: {
        get: function() {
            return ContextLimits._minimumAliasedLineWidth;
        }
    },
    /**
   * The maximum aliased line width, in pixels, supported by this WebGL implementation.  It will be at least one.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>ALIASED_LINE_WIDTH_RANGE</code>.
   */ maximumAliasedLineWidth: {
        get: function() {
            return ContextLimits._maximumAliasedLineWidth;
        }
    },
    /**
   * The minimum aliased point size, in pixels, supported by this WebGL implementation.  It will be at most one.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>ALIASED_POINT_SIZE_RANGE</code>.
   */ minimumAliasedPointSize: {
        get: function() {
            return ContextLimits._minimumAliasedPointSize;
        }
    },
    /**
   * The maximum aliased point size, in pixels, supported by this WebGL implementation.  It will be at least one.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>ALIASED_POINT_SIZE_RANGE</code>.
   */ maximumAliasedPointSize: {
        get: function() {
            return ContextLimits._maximumAliasedPointSize;
        }
    },
    /**
   * The maximum supported width of the viewport.  It will be at least as large as the visible width of the associated canvas.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VIEWPORT_DIMS</code>.
   */ maximumViewportWidth: {
        get: function() {
            return ContextLimits._maximumViewportWidth;
        }
    },
    /**
   * The maximum supported height of the viewport.  It will be at least as large as the visible height of the associated canvas.
   * @memberof ContextLimits
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>MAX_VIEWPORT_DIMS</code>.
   */ maximumViewportHeight: {
        get: function() {
            return ContextLimits._maximumViewportHeight;
        }
    },
    /**
   * The maximum degree of anisotropy for texture filtering
   * @memberof ContextLimits
   * @type {number}
   */ maximumTextureFilterAnisotropy: {
        get: function() {
            return ContextLimits._maximumTextureFilterAnisotropy;
        }
    },
    /**
   * The maximum number of simultaneous outputs that may be written in a fragment shader.
   * @memberof ContextLimits
   * @type {number}
   */ maximumDrawBuffers: {
        get: function() {
            return ContextLimits._maximumDrawBuffers;
        }
    },
    /**
   * The maximum number of color attachments supported.
   * @memberof ContextLimits
   * @type {number}
   */ maximumColorAttachments: {
        get: function() {
            return ContextLimits._maximumColorAttachments;
        }
    },
    /**
   * The maximum number of samples supported for multisampling.
   * @memberof ContextLimits
   * @type {number}
   */ maximumSamples: {
        get: function() {
            return ContextLimits._maximumSamples;
        }
    },
    /**
   * High precision float supported (<code>highp</code>) in fragment shaders.
   * @memberof ContextLimits
   * @type {boolean}
   */ highpFloatSupported: {
        get: function() {
            return ContextLimits._highpFloatSupported;
        }
    },
    /**
   * High precision int supported (<code>highp</code>) in fragment shaders.
   * @memberof ContextLimits
   * @type {boolean}
   */ highpIntSupported: {
        get: function() {
            return ContextLimits._highpIntSupported;
        }
    }
});
const __TURBOPACK__default__export__ = ContextLimits;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/freezeRenderState.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
/**
 * Returns frozen renderState as well as all of the object literal properties. This function is deep object freeze
 * function ignoring properties named "_applyFunctions".
 *
 * @private
 *
 * @param {object} renderState
 * @returns {object} Returns frozen renderState.
 *
 */ function freezeRenderState(renderState) {
    if (typeof renderState !== "object" || renderState === null) {
        return renderState;
    }
    let propName;
    const propNames = Object.keys(renderState);
    for(let i = 0; i < propNames.length; i++){
        propName = propNames[i];
        if (renderState.hasOwnProperty(propName) && propName !== "_applyFunctions") {
            renderState[propName] = freezeRenderState(renderState[propName]);
        }
    }
    return Object.freeze(renderState);
}
const __TURBOPACK__default__export__ = freezeRenderState;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/RenderState.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoundingRectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/BoundingRectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/WebGLConstants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WindingOrder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/WindingOrder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ContextLimits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$freezeRenderState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/freezeRenderState.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
function validateBlendEquation(blendEquation) {
    return blendEquation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FUNC_ADD || blendEquation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FUNC_SUBTRACT || blendEquation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FUNC_REVERSE_SUBTRACT || blendEquation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MIN || blendEquation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MAX;
}
function validateBlendFunction(blendFunction) {
    return blendFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ZERO || blendFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ONE || blendFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SRC_COLOR || blendFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ONE_MINUS_SRC_COLOR || blendFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DST_COLOR || blendFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ONE_MINUS_DST_COLOR || blendFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SRC_ALPHA || blendFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ONE_MINUS_SRC_ALPHA || blendFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DST_ALPHA || blendFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ONE_MINUS_DST_ALPHA || blendFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CONSTANT_COLOR || blendFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ONE_MINUS_CONSTANT_COLOR || blendFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CONSTANT_ALPHA || blendFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ONE_MINUS_CONSTANT_ALPHA || blendFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SRC_ALPHA_SATURATE;
}
function validateCullFace(cullFace) {
    return cullFace === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FRONT || cullFace === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].BACK || cullFace === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FRONT_AND_BACK;
}
function validateDepthFunction(depthFunction) {
    return depthFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEVER || depthFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LESS || depthFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EQUAL || depthFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LEQUAL || depthFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].GREATER || depthFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NOTEQUAL || depthFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].GEQUAL || depthFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ALWAYS;
}
function validateStencilFunction(stencilFunction) {
    return stencilFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEVER || stencilFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LESS || stencilFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EQUAL || stencilFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LEQUAL || stencilFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].GREATER || stencilFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NOTEQUAL || stencilFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].GEQUAL || stencilFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ALWAYS;
}
function validateStencilOperation(stencilOperation) {
    return stencilOperation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ZERO || stencilOperation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].KEEP || stencilOperation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].REPLACE || stencilOperation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].INCR || stencilOperation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DECR || stencilOperation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].INVERT || stencilOperation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].INCR_WRAP || stencilOperation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DECR_WRAP;
}
/**
 * @private
 */ function RenderState(renderState) {
    const rs = renderState ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const cull = rs.cull ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const polygonOffset = rs.polygonOffset ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const scissorTest = rs.scissorTest ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const scissorTestRectangle = scissorTest.rectangle ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const depthRange = rs.depthRange ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const depthTest = rs.depthTest ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const colorMask = rs.colorMask ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const blending = rs.blending ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const blendingColor = blending.color ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const stencilTest = rs.stencilTest ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const stencilTestFrontOperation = stencilTest.frontOperation ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const stencilTestBackOperation = stencilTest.backOperation ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const sampleCoverage = rs.sampleCoverage ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const viewport = rs.viewport;
    this.frontFace = rs.frontFace ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WindingOrder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COUNTER_CLOCKWISE;
    this.cull = {
        enabled: cull.enabled ?? false,
        face: cull.face ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].BACK
    };
    this.lineWidth = rs.lineWidth ?? 1.0;
    this.polygonOffset = {
        enabled: polygonOffset.enabled ?? false,
        factor: polygonOffset.factor ?? 0,
        units: polygonOffset.units ?? 0
    };
    this.scissorTest = {
        enabled: scissorTest.enabled ?? false,
        rectangle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoundingRectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(scissorTestRectangle)
    };
    this.depthRange = {
        near: depthRange.near ?? 0,
        far: depthRange.far ?? 1
    };
    this.depthTest = {
        enabled: depthTest.enabled ?? false,
        func: depthTest.func ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LESS
    };
    this.colorMask = {
        red: colorMask.red ?? true,
        green: colorMask.green ?? true,
        blue: colorMask.blue ?? true,
        alpha: colorMask.alpha ?? true
    };
    this.depthMask = rs.depthMask ?? true;
    this.stencilMask = rs.stencilMask ?? ~0;
    this.blending = {
        enabled: blending.enabled ?? false,
        color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](blendingColor.red ?? 0.0, blendingColor.green ?? 0.0, blendingColor.blue ?? 0.0, blendingColor.alpha ?? 0.0),
        equationRgb: blending.equationRgb ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FUNC_ADD,
        equationAlpha: blending.equationAlpha ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FUNC_ADD,
        functionSourceRgb: blending.functionSourceRgb ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ONE,
        functionSourceAlpha: blending.functionSourceAlpha ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ONE,
        functionDestinationRgb: blending.functionDestinationRgb ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ZERO,
        functionDestinationAlpha: blending.functionDestinationAlpha ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ZERO
    };
    this.stencilTest = {
        enabled: stencilTest.enabled ?? false,
        frontFunction: stencilTest.frontFunction ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ALWAYS,
        backFunction: stencilTest.backFunction ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ALWAYS,
        reference: stencilTest.reference ?? 0,
        mask: stencilTest.mask ?? ~0,
        frontOperation: {
            fail: stencilTestFrontOperation.fail ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].KEEP,
            zFail: stencilTestFrontOperation.zFail ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].KEEP,
            zPass: stencilTestFrontOperation.zPass ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].KEEP
        },
        backOperation: {
            fail: stencilTestBackOperation.fail ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].KEEP,
            zFail: stencilTestBackOperation.zFail ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].KEEP,
            zPass: stencilTestBackOperation.zPass ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].KEEP
        }
    };
    this.sampleCoverage = {
        enabled: sampleCoverage.enabled ?? false,
        value: sampleCoverage.value ?? 1.0,
        invert: sampleCoverage.invert ?? false
    };
    this.viewport = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(viewport) ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoundingRectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](viewport.x, viewport.y, viewport.width, viewport.height) : undefined;
    //>>includeStart('debug', pragmas.debug);
    if (this.lineWidth < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].minimumAliasedLineWidth || this.lineWidth > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].maximumAliasedLineWidth) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("renderState.lineWidth is out of range.  Check minimumAliasedLineWidth and maximumAliasedLineWidth.");
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WindingOrder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(this.frontFace)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.frontFace.");
    }
    if (!validateCullFace(this.cull.face)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.cull.face.");
    }
    if (this.scissorTest.rectangle.width < 0 || this.scissorTest.rectangle.height < 0) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("renderState.scissorTest.rectangle.width and renderState.scissorTest.rectangle.height must be greater than or equal to zero.");
    }
    if (this.depthRange.near > this.depthRange.far) {
        // WebGL specific - not an error in GL ES
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("renderState.depthRange.near can not be greater than renderState.depthRange.far.");
    }
    if (this.depthRange.near < 0) {
        // Would be clamped by GL
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("renderState.depthRange.near must be greater than or equal to zero.");
    }
    if (this.depthRange.far > 1) {
        // Would be clamped by GL
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("renderState.depthRange.far must be less than or equal to one.");
    }
    if (!validateDepthFunction(this.depthTest.func)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.depthTest.func.");
    }
    if (this.blending.color.red < 0.0 || this.blending.color.red > 1.0 || this.blending.color.green < 0.0 || this.blending.color.green > 1.0 || this.blending.color.blue < 0.0 || this.blending.color.blue > 1.0 || this.blending.color.alpha < 0.0 || this.blending.color.alpha > 1.0) {
        // Would be clamped by GL
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("renderState.blending.color components must be greater than or equal to zero and less than or equal to one.");
    }
    if (!validateBlendEquation(this.blending.equationRgb)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.blending.equationRgb.");
    }
    if (!validateBlendEquation(this.blending.equationAlpha)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.blending.equationAlpha.");
    }
    if (!validateBlendFunction(this.blending.functionSourceRgb)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.blending.functionSourceRgb.");
    }
    if (!validateBlendFunction(this.blending.functionSourceAlpha)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.blending.functionSourceAlpha.");
    }
    if (!validateBlendFunction(this.blending.functionDestinationRgb)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.blending.functionDestinationRgb.");
    }
    if (!validateBlendFunction(this.blending.functionDestinationAlpha)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.blending.functionDestinationAlpha.");
    }
    if (!validateStencilFunction(this.stencilTest.frontFunction)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.stencilTest.frontFunction.");
    }
    if (!validateStencilFunction(this.stencilTest.backFunction)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.stencilTest.backFunction.");
    }
    if (!validateStencilOperation(this.stencilTest.frontOperation.fail)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.stencilTest.frontOperation.fail.");
    }
    if (!validateStencilOperation(this.stencilTest.frontOperation.zFail)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.stencilTest.frontOperation.zFail.");
    }
    if (!validateStencilOperation(this.stencilTest.frontOperation.zPass)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.stencilTest.frontOperation.zPass.");
    }
    if (!validateStencilOperation(this.stencilTest.backOperation.fail)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.stencilTest.backOperation.fail.");
    }
    if (!validateStencilOperation(this.stencilTest.backOperation.zFail)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.stencilTest.backOperation.zFail.");
    }
    if (!validateStencilOperation(this.stencilTest.backOperation.zPass)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid renderState.stencilTest.backOperation.zPass.");
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.viewport)) {
        if (this.viewport.width < 0) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("renderState.viewport.width must be greater than or equal to zero.");
        }
        if (this.viewport.height < 0) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("renderState.viewport.height must be greater than or equal to zero.");
        }
        if (this.viewport.width > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].maximumViewportWidth) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`renderState.viewport.width must be less than or equal to the maximum viewport width (${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].maximumViewportWidth.toString()}).  Check maximumViewportWidth.`);
        }
        if (this.viewport.height > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].maximumViewportHeight) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`renderState.viewport.height must be less than or equal to the maximum viewport height (${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].maximumViewportHeight.toString()}).  Check maximumViewportHeight.`);
        }
    }
    //>>includeEnd('debug');
    this.id = 0;
    this._applyFunctions = [];
}
let nextRenderStateId = 0;
let renderStateCache = {};
/**
 * Validates and then finds or creates an immutable render state, which defines the pipeline
 * state for a {@link DrawCommand} or {@link ClearCommand}.  All inputs states are optional.  Omitted states
 * use the defaults shown in the example below.
 *
 * @param {object} [renderState] The states defining the render state as shown in the example below.
 *
 * @exception {RuntimeError} renderState.lineWidth is out of range.
 * @exception {DeveloperError} Invalid renderState.frontFace.
 * @exception {DeveloperError} Invalid renderState.cull.face.
 * @exception {DeveloperError} scissorTest.rectangle.width and scissorTest.rectangle.height must be greater than or equal to zero.
 * @exception {DeveloperError} renderState.depthRange.near can't be greater than renderState.depthRange.far.
 * @exception {DeveloperError} renderState.depthRange.near must be greater than or equal to zero.
 * @exception {DeveloperError} renderState.depthRange.far must be less than or equal to zero.
 * @exception {DeveloperError} Invalid renderState.depthTest.func.
 * @exception {DeveloperError} renderState.blending.color components must be greater than or equal to zero and less than or equal to one
 * @exception {DeveloperError} Invalid renderState.blending.equationRgb.
 * @exception {DeveloperError} Invalid renderState.blending.equationAlpha.
 * @exception {DeveloperError} Invalid renderState.blending.functionSourceRgb.
 * @exception {DeveloperError} Invalid renderState.blending.functionSourceAlpha.
 * @exception {DeveloperError} Invalid renderState.blending.functionDestinationRgb.
 * @exception {DeveloperError} Invalid renderState.blending.functionDestinationAlpha.
 * @exception {DeveloperError} Invalid renderState.stencilTest.frontFunction.
 * @exception {DeveloperError} Invalid renderState.stencilTest.backFunction.
 * @exception {DeveloperError} Invalid renderState.stencilTest.frontOperation.fail.
 * @exception {DeveloperError} Invalid renderState.stencilTest.frontOperation.zFail.
 * @exception {DeveloperError} Invalid renderState.stencilTest.frontOperation.zPass.
 * @exception {DeveloperError} Invalid renderState.stencilTest.backOperation.fail.
 * @exception {DeveloperError} Invalid renderState.stencilTest.backOperation.zFail.
 * @exception {DeveloperError} Invalid renderState.stencilTest.backOperation.zPass.
 * @exception {DeveloperError} renderState.viewport.width must be greater than or equal to zero.
 * @exception {DeveloperError} renderState.viewport.width must be less than or equal to the maximum viewport width.
 * @exception {DeveloperError} renderState.viewport.height must be greater than or equal to zero.
 * @exception {DeveloperError} renderState.viewport.height must be less than or equal to the maximum viewport height.
 *
 *
 * @example
 * const defaults = {
 *     frontFace : WindingOrder.COUNTER_CLOCKWISE,
 *     cull : {
 *         enabled : false,
 *         face : CullFace.BACK
 *     },
 *     lineWidth : 1,
 *     polygonOffset : {
 *         enabled : false,
 *         factor : 0,
 *         units : 0
 *     },
 *     scissorTest : {
 *         enabled : false,
 *         rectangle : {
 *             x : 0,
 *             y : 0,
 *             width : 0,
 *             height : 0
 *         }
 *     },
 *     depthRange : {
 *         near : 0,
 *         far : 1
 *     },
 *     depthTest : {
 *         enabled : false,
 *         func : DepthFunction.LESS
 *      },
 *     colorMask : {
 *         red : true,
 *         green : true,
 *         blue : true,
 *         alpha : true
 *     },
 *     depthMask : true,
 *     stencilMask : ~0,
 *     blending : {
 *         enabled : false,
 *         color : {
 *             red : 0.0,
 *             green : 0.0,
 *             blue : 0.0,
 *             alpha : 0.0
 *         },
 *         equationRgb : BlendEquation.ADD,
 *         equationAlpha : BlendEquation.ADD,
 *         functionSourceRgb : BlendFunction.ONE,
 *         functionSourceAlpha : BlendFunction.ONE,
 *         functionDestinationRgb : BlendFunction.ZERO,
 *         functionDestinationAlpha : BlendFunction.ZERO
 *     },
 *     stencilTest : {
 *         enabled : false,
 *         frontFunction : StencilFunction.ALWAYS,
 *         backFunction : StencilFunction.ALWAYS,
 *         reference : 0,
 *         mask : ~0,
 *         frontOperation : {
 *             fail : StencilOperation.KEEP,
 *             zFail : StencilOperation.KEEP,
 *             zPass : StencilOperation.KEEP
 *         },
 *         backOperation : {
 *             fail : StencilOperation.KEEP,
 *             zFail : StencilOperation.KEEP,
 *             zPass : StencilOperation.KEEP
 *         }
 *     },
 *     sampleCoverage : {
 *         enabled : false,
 *         value : 1.0,
 *         invert : false
 *      }
 * };
 *
 * const rs = RenderState.fromCache(defaults);
 *
 * @see DrawCommand
 * @see ClearCommand
 *
 * @private
 */ RenderState.fromCache = function(renderState) {
    const partialKey = JSON.stringify(renderState);
    let cachedState = renderStateCache[partialKey];
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(cachedState)) {
        ++cachedState.referenceCount;
        return cachedState.state;
    }
    // Cache miss.  Fully define render state and try again.
    let states = new RenderState(renderState);
    const fullKey = JSON.stringify(states);
    cachedState = renderStateCache[fullKey];
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(cachedState)) {
        states.id = nextRenderStateId++;
        //>>includeStart('debug', pragmas.debug);
        states = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$freezeRenderState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(states);
        //>>includeEnd('debug');
        cachedState = {
            referenceCount: 0,
            state: states
        };
        // Cache full render state.  Multiple partially defined render states may map to this.
        renderStateCache[fullKey] = cachedState;
    }
    ++cachedState.referenceCount;
    // Cache partial render state so we can skip validation on a cache hit for a partially defined render state
    renderStateCache[partialKey] = {
        referenceCount: 1,
        state: cachedState.state
    };
    return cachedState.state;
};
/**
 * @private
 */ RenderState.removeFromCache = function(renderState) {
    const states = new RenderState(renderState);
    const fullKey = JSON.stringify(states);
    const fullCachedState = renderStateCache[fullKey];
    // decrement partial key reference count
    const partialKey = JSON.stringify(renderState);
    const cachedState = renderStateCache[partialKey];
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(cachedState)) {
        --cachedState.referenceCount;
        if (cachedState.referenceCount === 0) {
            // remove partial key
            delete renderStateCache[partialKey];
            // decrement full key reference count
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(fullCachedState)) {
                --fullCachedState.referenceCount;
            }
        }
    }
    // remove full key if reference count is zero
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(fullCachedState) && fullCachedState.referenceCount === 0) {
        delete renderStateCache[fullKey];
    }
};
/**
 * This function is for testing purposes only.
 * @private
 */ RenderState.getCache = function() {
    return renderStateCache;
};
/**
 * This function is for testing purposes only.
 * @private
 */ RenderState.clearCache = function() {
    renderStateCache = {};
};
function enableOrDisable(gl, glEnum, enable) {
    if (enable) {
        gl.enable(glEnum);
    } else {
        gl.disable(glEnum);
    }
}
function applyFrontFace(gl, renderState) {
    gl.frontFace(renderState.frontFace);
}
function applyCull(gl, renderState) {
    const cull = renderState.cull;
    const enabled = cull.enabled;
    enableOrDisable(gl, gl.CULL_FACE, enabled);
    if (enabled) {
        gl.cullFace(cull.face);
    }
}
function applyLineWidth(gl, renderState) {
    gl.lineWidth(renderState.lineWidth);
}
function applyPolygonOffset(gl, renderState) {
    const polygonOffset = renderState.polygonOffset;
    const enabled = polygonOffset.enabled;
    enableOrDisable(gl, gl.POLYGON_OFFSET_FILL, enabled);
    if (enabled) {
        gl.polygonOffset(polygonOffset.factor, polygonOffset.units);
    }
}
function applyScissorTest(gl, renderState, passState) {
    const scissorTest = renderState.scissorTest;
    const enabled = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(passState.scissorTest) ? passState.scissorTest.enabled : scissorTest.enabled;
    enableOrDisable(gl, gl.SCISSOR_TEST, enabled);
    if (enabled) {
        const rectangle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(passState.scissorTest) ? passState.scissorTest.rectangle : scissorTest.rectangle;
        gl.scissor(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
    }
}
function applyDepthRange(gl, renderState) {
    const depthRange = renderState.depthRange;
    gl.depthRange(depthRange.near, depthRange.far);
}
function applyDepthTest(gl, renderState) {
    const depthTest = renderState.depthTest;
    const enabled = depthTest.enabled;
    enableOrDisable(gl, gl.DEPTH_TEST, enabled);
    if (enabled) {
        gl.depthFunc(depthTest.func);
    }
}
function applyColorMask(gl, renderState) {
    const colorMask = renderState.colorMask;
    gl.colorMask(colorMask.red, colorMask.green, colorMask.blue, colorMask.alpha);
}
function applyDepthMask(gl, renderState) {
    gl.depthMask(renderState.depthMask);
}
function applyStencilMask(gl, renderState) {
    gl.stencilMask(renderState.stencilMask);
}
function applyBlendingColor(gl, color) {
    gl.blendColor(color.red, color.green, color.blue, color.alpha);
}
function applyBlending(gl, renderState, passState) {
    const blending = renderState.blending;
    const enabled = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(passState.blendingEnabled) ? passState.blendingEnabled : blending.enabled;
    enableOrDisable(gl, gl.BLEND, enabled);
    if (enabled) {
        applyBlendingColor(gl, blending.color);
        gl.blendEquationSeparate(blending.equationRgb, blending.equationAlpha);
        gl.blendFuncSeparate(blending.functionSourceRgb, blending.functionDestinationRgb, blending.functionSourceAlpha, blending.functionDestinationAlpha);
    }
}
function applyStencilTest(gl, renderState) {
    const stencilTest = renderState.stencilTest;
    const enabled = stencilTest.enabled;
    enableOrDisable(gl, gl.STENCIL_TEST, enabled);
    if (enabled) {
        const frontFunction = stencilTest.frontFunction;
        const backFunction = stencilTest.backFunction;
        const reference = stencilTest.reference;
        const mask = stencilTest.mask;
        // Section 6.8 of the WebGL spec requires the reference and masks to be the same for
        // front- and back-face tests.  This call prevents invalid operation errors when calling
        // stencilFuncSeparate on Firefox.  Perhaps they should delay validation to avoid requiring this.
        gl.stencilFunc(frontFunction, reference, mask);
        gl.stencilFuncSeparate(gl.BACK, backFunction, reference, mask);
        gl.stencilFuncSeparate(gl.FRONT, frontFunction, reference, mask);
        const frontOperation = stencilTest.frontOperation;
        const frontOperationFail = frontOperation.fail;
        const frontOperationZFail = frontOperation.zFail;
        const frontOperationZPass = frontOperation.zPass;
        gl.stencilOpSeparate(gl.FRONT, frontOperationFail, frontOperationZFail, frontOperationZPass);
        const backOperation = stencilTest.backOperation;
        const backOperationFail = backOperation.fail;
        const backOperationZFail = backOperation.zFail;
        const backOperationZPass = backOperation.zPass;
        gl.stencilOpSeparate(gl.BACK, backOperationFail, backOperationZFail, backOperationZPass);
    }
}
function applySampleCoverage(gl, renderState) {
    const sampleCoverage = renderState.sampleCoverage;
    const enabled = sampleCoverage.enabled;
    enableOrDisable(gl, gl.SAMPLE_COVERAGE, enabled);
    if (enabled) {
        gl.sampleCoverage(sampleCoverage.value, sampleCoverage.invert);
    }
}
const scratchViewport = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoundingRectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function applyViewport(gl, renderState, passState) {
    let viewport = renderState.viewport ?? passState.viewport;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(viewport)) {
        viewport = scratchViewport;
        viewport.width = passState.context.drawingBufferWidth;
        viewport.height = passState.context.drawingBufferHeight;
    }
    passState.context.uniformState.viewport = viewport;
    gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
}
RenderState.apply = function(gl, renderState, passState) {
    applyFrontFace(gl, renderState);
    applyCull(gl, renderState);
    applyLineWidth(gl, renderState);
    applyPolygonOffset(gl, renderState);
    applyDepthRange(gl, renderState);
    applyDepthTest(gl, renderState);
    applyColorMask(gl, renderState);
    applyDepthMask(gl, renderState);
    applyStencilMask(gl, renderState);
    applyStencilTest(gl, renderState);
    applySampleCoverage(gl, renderState);
    applyScissorTest(gl, renderState, passState);
    applyBlending(gl, renderState, passState);
    applyViewport(gl, renderState, passState);
};
function createFuncs(previousState, nextState) {
    const funcs = [];
    if (previousState.frontFace !== nextState.frontFace) {
        funcs.push(applyFrontFace);
    }
    if (previousState.cull.enabled !== nextState.cull.enabled || previousState.cull.face !== nextState.cull.face) {
        funcs.push(applyCull);
    }
    if (previousState.lineWidth !== nextState.lineWidth) {
        funcs.push(applyLineWidth);
    }
    if (previousState.polygonOffset.enabled !== nextState.polygonOffset.enabled || previousState.polygonOffset.factor !== nextState.polygonOffset.factor || previousState.polygonOffset.units !== nextState.polygonOffset.units) {
        funcs.push(applyPolygonOffset);
    }
    if (previousState.depthRange.near !== nextState.depthRange.near || previousState.depthRange.far !== nextState.depthRange.far) {
        funcs.push(applyDepthRange);
    }
    if (previousState.depthTest.enabled !== nextState.depthTest.enabled || previousState.depthTest.func !== nextState.depthTest.func) {
        funcs.push(applyDepthTest);
    }
    if (previousState.colorMask.red !== nextState.colorMask.red || previousState.colorMask.green !== nextState.colorMask.green || previousState.colorMask.blue !== nextState.colorMask.blue || previousState.colorMask.alpha !== nextState.colorMask.alpha) {
        funcs.push(applyColorMask);
    }
    if (previousState.depthMask !== nextState.depthMask) {
        funcs.push(applyDepthMask);
    }
    if (previousState.stencilMask !== nextState.stencilMask) {
        funcs.push(applyStencilMask);
    }
    if (previousState.stencilTest.enabled !== nextState.stencilTest.enabled || previousState.stencilTest.frontFunction !== nextState.stencilTest.frontFunction || previousState.stencilTest.backFunction !== nextState.stencilTest.backFunction || previousState.stencilTest.reference !== nextState.stencilTest.reference || previousState.stencilTest.mask !== nextState.stencilTest.mask || previousState.stencilTest.frontOperation.fail !== nextState.stencilTest.frontOperation.fail || previousState.stencilTest.frontOperation.zFail !== nextState.stencilTest.frontOperation.zFail || previousState.stencilTest.backOperation.fail !== nextState.stencilTest.backOperation.fail || previousState.stencilTest.backOperation.zFail !== nextState.stencilTest.backOperation.zFail || previousState.stencilTest.backOperation.zPass !== nextState.stencilTest.backOperation.zPass) {
        funcs.push(applyStencilTest);
    }
    if (previousState.sampleCoverage.enabled !== nextState.sampleCoverage.enabled || previousState.sampleCoverage.value !== nextState.sampleCoverage.value || previousState.sampleCoverage.invert !== nextState.sampleCoverage.invert) {
        funcs.push(applySampleCoverage);
    }
    return funcs;
}
RenderState.partialApply = function(gl, previousRenderState, renderState, previousPassState, passState, clear) {
    if (previousRenderState !== renderState) {
        // When a new render state is applied, instead of making WebGL calls for all the states or first
        // comparing the states one-by-one with the previous state (basically a linear search), we take
        // advantage of RenderState's immutability, and store a dynamically populated sparse data structure
        // containing functions that make the minimum number of WebGL calls when transitioning from one state
        // to the other.  In practice, this works well since state-to-state transitions generally only require a
        // few WebGL calls, especially if commands are stored by state.
        let funcs = renderState._applyFunctions[previousRenderState.id];
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(funcs)) {
            funcs = createFuncs(previousRenderState, renderState);
            renderState._applyFunctions[previousRenderState.id] = funcs;
        }
        const len = funcs.length;
        for(let i = 0; i < len; ++i){
            funcs[i](gl, renderState);
        }
    }
    const previousScissorTest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(previousPassState.scissorTest) ? previousPassState.scissorTest : previousRenderState.scissorTest;
    const scissorTest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(passState.scissorTest) ? passState.scissorTest : renderState.scissorTest;
    // Our scissor rectangle can get out of sync with the GL scissor rectangle on clears.
    // Seems to be a problem only on ANGLE. See https://github.com/CesiumGS/cesium/issues/2994
    if (previousScissorTest !== scissorTest || clear) {
        applyScissorTest(gl, renderState, passState);
    }
    const previousBlendingEnabled = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(previousPassState.blendingEnabled) ? previousPassState.blendingEnabled : previousRenderState.blending.enabled;
    const blendingEnabled = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(passState.blendingEnabled) ? passState.blendingEnabled : renderState.blending.enabled;
    if (previousBlendingEnabled !== blendingEnabled || blendingEnabled && previousRenderState.blending !== renderState.blending) {
        applyBlending(gl, renderState, passState);
    }
    if (previousRenderState !== renderState || previousPassState !== passState || previousPassState.context !== passState.context) {
        applyViewport(gl, renderState, passState);
    }
};
RenderState.getState = function(renderState) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(renderState)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("renderState is required.");
    }
    //>>includeEnd('debug');
    return {
        frontFace: renderState.frontFace,
        cull: {
            enabled: renderState.cull.enabled,
            face: renderState.cull.face
        },
        lineWidth: renderState.lineWidth,
        polygonOffset: {
            enabled: renderState.polygonOffset.enabled,
            factor: renderState.polygonOffset.factor,
            units: renderState.polygonOffset.units
        },
        scissorTest: {
            enabled: renderState.scissorTest.enabled,
            rectangle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoundingRectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(renderState.scissorTest.rectangle)
        },
        depthRange: {
            near: renderState.depthRange.near,
            far: renderState.depthRange.far
        },
        depthTest: {
            enabled: renderState.depthTest.enabled,
            func: renderState.depthTest.func
        },
        colorMask: {
            red: renderState.colorMask.red,
            green: renderState.colorMask.green,
            blue: renderState.colorMask.blue,
            alpha: renderState.colorMask.alpha
        },
        depthMask: renderState.depthMask,
        stencilMask: renderState.stencilMask,
        blending: {
            enabled: renderState.blending.enabled,
            color: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(renderState.blending.color),
            equationRgb: renderState.blending.equationRgb,
            equationAlpha: renderState.blending.equationAlpha,
            functionSourceRgb: renderState.blending.functionSourceRgb,
            functionSourceAlpha: renderState.blending.functionSourceAlpha,
            functionDestinationRgb: renderState.blending.functionDestinationRgb,
            functionDestinationAlpha: renderState.blending.functionDestinationAlpha
        },
        stencilTest: {
            enabled: renderState.stencilTest.enabled,
            frontFunction: renderState.stencilTest.frontFunction,
            backFunction: renderState.stencilTest.backFunction,
            reference: renderState.stencilTest.reference,
            mask: renderState.stencilTest.mask,
            frontOperation: {
                fail: renderState.stencilTest.frontOperation.fail,
                zFail: renderState.stencilTest.frontOperation.zFail,
                zPass: renderState.stencilTest.frontOperation.zPass
            },
            backOperation: {
                fail: renderState.stencilTest.backOperation.fail,
                zFail: renderState.stencilTest.backOperation.zFail,
                zPass: renderState.stencilTest.backOperation.zPass
            }
        },
        sampleCoverage: {
            enabled: renderState.sampleCoverage.enabled,
            value: renderState.sampleCoverage.value,
            invert: renderState.sampleCoverage.invert
        },
        viewport: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(renderState.viewport) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoundingRectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(renderState.viewport) : undefined
    };
};
const __TURBOPACK__default__export__ = RenderState;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/AutomaticUniforms.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartesian3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Matrix4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/WebGLConstants.js [app-client] (ecmascript)");
;
;
;
const viewerPositionWCScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function AutomaticUniform(options) {
    this._size = options.size;
    this._datatype = options.datatype;
    this.getValue = options.getValue;
}
const datatypeToGlsl = {};
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT] = "float";
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC2] = "vec2";
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3] = "vec3";
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC4] = "vec4";
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].INT] = "int";
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].INT_VEC2] = "ivec2";
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].INT_VEC3] = "ivec3";
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].INT_VEC4] = "ivec4";
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].BOOL] = "bool";
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].BOOL_VEC2] = "bvec2";
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].BOOL_VEC3] = "bvec3";
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].BOOL_VEC4] = "bvec4";
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT2] = "mat2";
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT3] = "mat3";
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4] = "mat4";
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SAMPLER_2D] = "sampler2D";
datatypeToGlsl[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SAMPLER_CUBE] = "samplerCube";
AutomaticUniform.prototype.getDeclaration = function(name) {
    let declaration = `uniform ${datatypeToGlsl[this._datatype]} ${name}`;
    const size = this._size;
    if (size === 1) {
        declaration += ";";
    } else {
        declaration += `[${size.toString()}];`;
    }
    return declaration;
};
/**
 * @private
 */ const AutomaticUniforms = {
    /**
   * An automatic GLSL uniform containing the viewport's <code>x</code>, <code>y</code>, <code>width</code>,
   * and <code>height</code> properties in an <code>vec4</code>'s <code>x</code>, <code>y</code>, <code>z</code>,
   * and <code>w</code> components, respectively.
   *
   * @example
   * // GLSL declaration
   * uniform vec4 czm_viewport;
   *
   * // Scale the window coordinate components to [0, 1] by dividing
   * // by the viewport's width and height.
   * vec2 v = gl_FragCoord.xy / czm_viewport.zw;
   *
   * @see Context#getViewport
   */ czm_viewport: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC4,
        getValue: function(uniformState) {
            return uniformState.viewportCartesian4;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 orthographic projection matrix that
   * transforms window coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   * <br /><br />
   * This transform is useful when a vertex shader inputs or manipulates window coordinates
   * as done by {@link BillboardCollection}.
   * <br /><br />
   * Do not confuse {@link czm_viewportTransformation} with <code>czm_viewportOrthographic</code>.
   * The former transforms from normalized device coordinates to window coordinates; the later transforms
   * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_viewportOrthographic;
   *
   * // Example
   * gl_Position = czm_viewportOrthographic * vec4(windowPosition, 0.0, 1.0);
   *
   * @see UniformState#viewportOrthographic
   * @see czm_viewport
   * @see czm_viewportTransformation
   * @see BillboardCollection
   */ czm_viewportOrthographic: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.viewportOrthographic;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 transformation matrix that
   * transforms normalized device coordinates to window coordinates.  The context's
   * full viewport is used, and the depth range is assumed to be <code>near = 0</code>
   * and <code>far = 1</code>.
   * <br /><br />
   * This transform is useful when there is a need to manipulate window coordinates
   * in a vertex shader as done by {@link BillboardCollection}.  In many cases,
   * this matrix will not be used directly; instead, {@link czm_modelToWindowCoordinates}
   * will be used to transform directly from model to window coordinates.
   * <br /><br />
   * Do not confuse <code>czm_viewportTransformation</code> with {@link czm_viewportOrthographic}.
   * The former transforms from normalized device coordinates to window coordinates; the later transforms
   * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_viewportTransformation;
   *
   * // Use czm_viewportTransformation as part of the
   * // transform from model to window coordinates.
   * vec4 q = czm_modelViewProjection * positionMC;               // model to clip coordinates
   * q.xyz /= q.w;                                                // clip to normalized device coordinates (ndc)
   * q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // ndc to window coordinates
   *
   * @see UniformState#viewportTransformation
   * @see czm_viewport
   * @see czm_viewportOrthographic
   * @see czm_modelToWindowCoordinates
   * @see BillboardCollection
   */ czm_viewportTransformation: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.viewportTransformation;
        }
    }),
    /**
   * An automatic GLSL uniform representing the depth of the scene
   * after the globe pass and then updated after the 3D Tiles pass.
   * The depth is packed into an RGBA texture.
   *
   * @example
   * // GLSL declaration
   * uniform sampler2D czm_globeDepthTexture;
   *
   * // Get the depth at the current fragment
   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;
   * float depth = czm_unpackDepth(texture(czm_globeDepthTexture, coords));
   */ czm_globeDepthTexture: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SAMPLER_2D,
        getValue: function(uniformState) {
            return uniformState.globeDepthTexture;
        }
    }),
    /**
   * An automatic GLSL uniform representing a texture containing edge IDs
   * from the 3D Tiles edge rendering pass. Used for edge detection and
   * avoiding z-fighting between edges and surfaces.
   *
   * @example
   * // GLSL declaration
   * uniform sampler2D czm_edgeIdTexture;
   *
   * // Get the edge ID at the current fragment
   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;
   * vec4 edgeId = texture(czm_edgeIdTexture, coords);
   */ czm_edgeIdTexture: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SAMPLER_2D,
        getValue: function(uniformState) {
            return uniformState.edgeIdTexture;
        }
    }),
    /**
   * An automatic GLSL uniform containing the edge color texture.
   * This texture contains the edge content rendered during the CESIUM_3D_TILE_EDGES pass.
   *
   * @example
   * // GLSL declaration
   * uniform sampler2D czm_edgeColorTexture;
   *
   * // Sample the edge color at the current fragment
   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;
   * vec4 edgeColor = texture(czm_edgeColorTexture, coords);
   */ czm_edgeColorTexture: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SAMPLER_2D,
        getValue: function(uniformState) {
            return uniformState.edgeColorTexture;
        }
    }),
    /**
   * An automatic GLSL uniform containing the packed depth texture produced by the
   * edge visibility pass. The depth is packed via czm_packDepth and should be
   * unpacked with czm_unpackDepth.
   *
   * @example
   * // GLSL declaration
   * uniform sampler2D czm_edgeDepthTexture;
   *
   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;
   * float d = czm_unpackDepth(texture(czm_edgeDepthTexture, coords));
   */ czm_edgeDepthTexture: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SAMPLER_2D,
        getValue: function(uniformState) {
            return uniformState.edgeDepthTexture;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 model transformation matrix that
   * transforms model coordinates to world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_model;
   *
   * // Example
   * vec4 worldPosition = czm_model * modelPosition;
   *
   * @see UniformState#model
   * @see czm_inverseModel
   * @see czm_modelView
   * @see czm_modelViewProjection
   */ czm_model: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.model;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 model transformation matrix that
   * transforms world coordinates to model coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseModel;
   *
   * // Example
   * vec4 modelPosition = czm_inverseModel * worldPosition;
   *
   * @see UniformState#inverseModel
   * @see czm_model
   * @see czm_inverseModelView
   */ czm_inverseModel: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.inverseModel;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 view transformation matrix that
   * transforms world coordinates to eye coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_view;
   *
   * // Example
   * vec4 eyePosition = czm_view * worldPosition;
   *
   * @see UniformState#view
   * @see czm_viewRotation
   * @see czm_modelView
   * @see czm_viewProjection
   * @see czm_modelViewProjection
   * @see czm_inverseView
   */ czm_view: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.view;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 view transformation matrix that
   * transforms 3D world coordinates to eye coordinates.  In 3D mode, this is identical to
   * {@link czm_view}, but in 2D and Columbus View it represents the view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_view3D;
   *
   * // Example
   * vec4 eyePosition3D = czm_view3D * worldPosition3D;
   *
   * @see UniformState#view3D
   * @see czm_view
   */ czm_view3D: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.view3D;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 3x3 view rotation matrix that
   * transforms vectors in world coordinates to eye coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_viewRotation;
   *
   * // Example
   * vec3 eyeVector = czm_viewRotation * worldVector;
   *
   * @see UniformState#viewRotation
   * @see czm_view
   * @see czm_inverseView
   * @see czm_inverseViewRotation
   */ czm_viewRotation: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT3,
        getValue: function(uniformState) {
            return uniformState.viewRotation;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 3x3 view rotation matrix that
   * transforms vectors in 3D world coordinates to eye coordinates.  In 3D mode, this is identical to
   * {@link czm_viewRotation}, but in 2D and Columbus View it represents the view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_viewRotation3D;
   *
   * // Example
   * vec3 eyeVector = czm_viewRotation3D * worldVector;
   *
   * @see UniformState#viewRotation3D
   * @see czm_viewRotation
   */ czm_viewRotation3D: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT3,
        getValue: function(uniformState) {
            return uniformState.viewRotation3D;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 transformation matrix that
   * transforms from eye coordinates to world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseView;
   *
   * // Example
   * vec4 worldPosition = czm_inverseView * eyePosition;
   *
   * @see UniformState#inverseView
   * @see czm_view
   * @see czm_inverseNormal
   */ czm_inverseView: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.inverseView;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 transformation matrix that
   * transforms from 3D eye coordinates to world coordinates.  In 3D mode, this is identical to
   * {@link czm_inverseView}, but in 2D and Columbus View it represents the inverse view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseView3D;
   *
   * // Example
   * vec4 worldPosition = czm_inverseView3D * eyePosition;
   *
   * @see UniformState#inverseView3D
   * @see czm_inverseView
   */ czm_inverseView3D: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.inverseView3D;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 3x3 rotation matrix that
   * transforms vectors from eye coordinates to world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_inverseViewRotation;
   *
   * // Example
   * vec4 worldVector = czm_inverseViewRotation * eyeVector;
   *
   * @see UniformState#inverseView
   * @see czm_view
   * @see czm_viewRotation
   * @see czm_inverseViewRotation
   */ czm_inverseViewRotation: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT3,
        getValue: function(uniformState) {
            return uniformState.inverseViewRotation;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 3x3 rotation matrix that
   * transforms vectors from 3D eye coordinates to world coordinates.  In 3D mode, this is identical to
   * {@link czm_inverseViewRotation}, but in 2D and Columbus View it represents the inverse view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_inverseViewRotation3D;
   *
   * // Example
   * vec4 worldVector = czm_inverseViewRotation3D * eyeVector;
   *
   * @see UniformState#inverseView3D
   * @see czm_inverseViewRotation
   */ czm_inverseViewRotation3D: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT3,
        getValue: function(uniformState) {
            return uniformState.inverseViewRotation3D;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 projection transformation matrix that
   * transforms eye coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_projection;
   *
   * // Example
   * gl_Position = czm_projection * eyePosition;
   *
   * @see UniformState#projection
   * @see czm_viewProjection
   * @see czm_modelViewProjection
   * @see czm_infiniteProjection
   */ czm_projection: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.projection;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 inverse projection transformation matrix that
   * transforms from clip coordinates to eye coordinates. Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseProjection;
   *
   * // Example
   * vec4 eyePosition = czm_inverseProjection * clipPosition;
   *
   * @see UniformState#inverseProjection
   * @see czm_projection
   */ czm_inverseProjection: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.inverseProjection;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 projection transformation matrix with the far plane at infinity,
   * that transforms eye coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.  An infinite far plane is used
   * in algorithms like shadow volumes and GPU ray casting with proxy geometry to ensure that triangles
   * are not clipped by the far plane.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_infiniteProjection;
   *
   * // Example
   * gl_Position = czm_infiniteProjection * eyePosition;
   *
   * @see UniformState#infiniteProjection
   * @see czm_projection
   * @see czm_modelViewInfiniteProjection
   */ czm_infiniteProjection: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.infiniteProjection;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that
   * transforms model coordinates to eye coordinates.
   * <br /><br />
   * Positions should be transformed to eye coordinates using <code>czm_modelView</code> and
   * normals should be transformed using {@link czm_normal}.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelView;
   *
   * // Example
   * vec4 eyePosition = czm_modelView * modelPosition;
   *
   * // The above is equivalent to, but more efficient than:
   * vec4 eyePosition = czm_view * czm_model * modelPosition;
   *
   * @see UniformState#modelView
   * @see czm_model
   * @see czm_view
   * @see czm_modelViewProjection
   * @see czm_normal
   */ czm_modelView: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.modelView;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that
   * transforms 3D model coordinates to eye coordinates.  In 3D mode, this is identical to
   * {@link czm_modelView}, but in 2D and Columbus View it represents the model-view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   * <br /><br />
   * Positions should be transformed to eye coordinates using <code>czm_modelView3D</code> and
   * normals should be transformed using {@link czm_normal3D}.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelView3D;
   *
   * // Example
   * vec4 eyePosition = czm_modelView3D * modelPosition;
   *
   * // The above is equivalent to, but more efficient than:
   * vec4 eyePosition = czm_view3D * czm_model * modelPosition;
   *
   * @see UniformState#modelView3D
   * @see czm_modelView
   */ czm_modelView3D: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.modelView3D;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that
   * transforms model coordinates, relative to the eye, to eye coordinates.  This is used
   * in conjunction with {@link czm_translateRelativeToEye}.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelViewRelativeToEye;
   *
   * // Example
   * attribute vec3 positionHigh;
   * attribute vec3 positionLow;
   *
   * void main()
   * {
   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
   *   gl_Position = czm_projection * (czm_modelViewRelativeToEye * p);
   * }
   *
   * @see czm_modelViewProjectionRelativeToEye
   * @see czm_translateRelativeToEye
   * @see EncodedCartesian3
   */ czm_modelViewRelativeToEye: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.modelViewRelativeToEye;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 transformation matrix that
   * transforms from eye coordinates to model coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseModelView;
   *
   * // Example
   * vec4 modelPosition = czm_inverseModelView * eyePosition;
   *
   * @see UniformState#inverseModelView
   * @see czm_modelView
   */ czm_inverseModelView: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.inverseModelView;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 transformation matrix that
   * transforms from eye coordinates to 3D model coordinates.  In 3D mode, this is identical to
   * {@link czm_inverseModelView}, but in 2D and Columbus View it represents the inverse model-view matrix
   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseModelView3D;
   *
   * // Example
   * vec4 modelPosition = czm_inverseModelView3D * eyePosition;
   *
   * @see UniformState#inverseModelView
   * @see czm_inverseModelView
   * @see czm_modelView3D
   */ czm_inverseModelView3D: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.inverseModelView3D;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that
   * transforms world coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_viewProjection;
   *
   * // Example
   * vec4 gl_Position = czm_viewProjection * czm_model * modelPosition;
   *
   * // The above is equivalent to, but more efficient than:
   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;
   *
   * @see UniformState#viewProjection
   * @see czm_view
   * @see czm_projection
   * @see czm_modelViewProjection
   * @see czm_inverseViewProjection
   */ czm_viewProjection: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.viewProjection;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that
   * transforms clip coordinates to world coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseViewProjection;
   *
   * // Example
   * vec4 worldPosition = czm_inverseViewProjection * clipPosition;
   *
   * @see UniformState#inverseViewProjection
   * @see czm_viewProjection
   */ czm_inverseViewProjection: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.inverseViewProjection;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
   * transforms model coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelViewProjection;
   *
   * // Example
   * vec4 gl_Position = czm_modelViewProjection * modelPosition;
   *
   * // The above is equivalent to, but more efficient than:
   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;
   *
   * @see UniformState#modelViewProjection
   * @see czm_model
   * @see czm_view
   * @see czm_projection
   * @see czm_modelView
   * @see czm_viewProjection
   * @see czm_modelViewInfiniteProjection
   * @see czm_inverseModelViewProjection
   */ czm_modelViewProjection: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.modelViewProjection;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 inverse model-view-projection transformation matrix that
   * transforms clip coordinates to model coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_inverseModelViewProjection;
   *
   * // Example
   * vec4 modelPosition = czm_inverseModelViewProjection * clipPosition;
   *
   * @see UniformState#modelViewProjection
   * @see czm_modelViewProjection
   */ czm_inverseModelViewProjection: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.inverseModelViewProjection;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
   * transforms model coordinates, relative to the eye, to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.  This is used in
   * conjunction with {@link czm_translateRelativeToEye}.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelViewProjectionRelativeToEye;
   *
   * // Example
   * attribute vec3 positionHigh;
   * attribute vec3 positionLow;
   *
   * void main()
   * {
   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
   *   gl_Position = czm_modelViewProjectionRelativeToEye * p;
   * }
   *
   * @see czm_modelViewRelativeToEye
   * @see czm_translateRelativeToEye
   * @see EncodedCartesian3
   */ czm_modelViewProjectionRelativeToEye: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.modelViewProjectionRelativeToEye;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
   * transforms model coordinates to clip coordinates.  Clip coordinates is the
   * coordinate system for a vertex shader's <code>gl_Position</code> output.  The projection matrix places
   * the far plane at infinity.  This is useful in algorithms like shadow volumes and GPU ray casting with
   * proxy geometry to ensure that triangles are not clipped by the far plane.
   *
   * @example
   * // GLSL declaration
   * uniform mat4 czm_modelViewInfiniteProjection;
   *
   * // Example
   * vec4 gl_Position = czm_modelViewInfiniteProjection * modelPosition;
   *
   * // The above is equivalent to, but more efficient than:
   * gl_Position = czm_infiniteProjection * czm_view * czm_model * modelPosition;
   *
   * @see UniformState#modelViewInfiniteProjection
   * @see czm_model
   * @see czm_view
   * @see czm_infiniteProjection
   * @see czm_modelViewProjection
   */ czm_modelViewInfiniteProjection: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.modelViewInfiniteProjection;
        }
    }),
    /**
   * An automatic GLSL uniform that indicates if the current camera is orthographic in 3D.
   *
   * @see UniformState#orthographicIn3D
   */ czm_orthographicIn3D: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.orthographicIn3D ? 1 : 0;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
   * transforms normal vectors in model coordinates to eye coordinates.
   * <br /><br />
   * Positions should be transformed to eye coordinates using {@link czm_modelView} and
   * normals should be transformed using <code>czm_normal</code>.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_normal;
   *
   * // Example
   * vec3 eyeNormal = czm_normal * normal;
   *
   * @see UniformState#normal
   * @see czm_inverseNormal
   * @see czm_modelView
   */ czm_normal: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT3,
        getValue: function(uniformState) {
            return uniformState.normal;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
   * transforms normal vectors in 3D model coordinates to eye coordinates.
   * In 3D mode, this is identical to
   * {@link czm_normal}, but in 2D and Columbus View it represents the normal transformation
   * matrix as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   * <br /><br />
   * Positions should be transformed to eye coordinates using {@link czm_modelView3D} and
   * normals should be transformed using <code>czm_normal3D</code>.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_normal3D;
   *
   * // Example
   * vec3 eyeNormal = czm_normal3D * normal;
   *
   * @see UniformState#normal3D
   * @see czm_normal
   */ czm_normal3D: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT3,
        getValue: function(uniformState) {
            return uniformState.normal3D;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
   * transforms normal vectors in eye coordinates to model coordinates.  This is
   * the opposite of the transform provided by {@link czm_normal}.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_inverseNormal;
   *
   * // Example
   * vec3 normalMC = czm_inverseNormal * normalEC;
   *
   * @see UniformState#inverseNormal
   * @see czm_normal
   * @see czm_modelView
   * @see czm_inverseView
   */ czm_inverseNormal: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT3,
        getValue: function(uniformState) {
            return uniformState.inverseNormal;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
   * transforms normal vectors in eye coordinates to 3D model coordinates.  This is
   * the opposite of the transform provided by {@link czm_normal}.
   * In 3D mode, this is identical to
   * {@link czm_inverseNormal}, but in 2D and Columbus View it represents the inverse normal transformation
   * matrix as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
   * 2D and Columbus View in the same way that 3D is lit.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_inverseNormal3D;
   *
   * // Example
   * vec3 normalMC = czm_inverseNormal3D * normalEC;
   *
   * @see UniformState#inverseNormal3D
   * @see czm_inverseNormal
   */ czm_inverseNormal3D: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT3,
        getValue: function(uniformState) {
            return uniformState.inverseNormal3D;
        }
    }),
    /**
   * An automatic GLSL uniform containing the height in meters of the
   * eye (camera) above or below the ellipsoid.
   *
   * @see UniformState#eyeHeight
   */ czm_eyeHeight: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.eyeHeight;
        }
    }),
    /**
   * An automatic GLSL uniform containing height (<code>x</code>) and height squared (<code>y</code>)
   * in meters of the eye (camera) above the 2D world plane. This uniform is only valid
   * when the {@link SceneMode} is <code>SCENE2D</code>.
   *
   * @see UniformState#eyeHeight2D
   */ czm_eyeHeight2D: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC2,
        getValue: function(uniformState) {
            return uniformState.eyeHeight2D;
        }
    }),
    /**
   * An automatic GLSL uniform containing the ellipsoid surface normal
   * at the position below the eye (camera), in eye coordinates.
   * This uniform is only valid when the {@link SceneMode} is <code>SCENE3D</code>.
   */ czm_eyeEllipsoidNormalEC: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.eyeEllipsoidNormalEC;
        }
    }),
    /**
   * An automatic GLSL uniform containing the ellipsoid radii of curvature at the camera position.
   * The .x component is the prime vertical radius of curvature (east-west direction)
   * .y is the meridional radius of curvature (north-south direction)
   * This uniform is only valid when the {@link SceneMode} is <code>SCENE3D</code>.
   */ czm_eyeEllipsoidCurvature: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC2,
        getValue: function(uniformState) {
            return uniformState.eyeEllipsoidCurvature;
        }
    }),
    /**
   * An automatic GLSL uniform containing the transform from model coordinates
   * to an east-north-up coordinate system centered at the position on the
   * ellipsoid below the camera.
   * This uniform is only valid when the {@link SceneMode} is <code>SCENE3D</code>.
   */ czm_modelToEnu: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.modelToEnu;
        }
    }),
    /**
   * An automatic GLSL uniform containing the the inverse of
   * {@link AutomaticUniforms.czm_modelToEnu}.
   * This uniform is only valid when the {@link SceneMode} is <code>SCENE3D</code>.
   */ czm_enuToModel: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT4,
        getValue: function(uniformState) {
            return uniformState.enuToModel;
        }
    }),
    /**
   * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)
   * of the frustum defined by the camera.  This is the largest possible frustum, not an individual
   * frustum used for multi-frustum rendering.
   *
   * @example
   * // GLSL declaration
   * uniform vec2 czm_entireFrustum;
   *
   * // Example
   * float frustumLength = czm_entireFrustum.y - czm_entireFrustum.x;
   *
   * @see UniformState#entireFrustum
   * @see czm_currentFrustum
   */ czm_entireFrustum: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC2,
        getValue: function(uniformState) {
            return uniformState.entireFrustum;
        }
    }),
    /**
   * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)
   * of the frustum defined by the camera.  This is the individual
   * frustum used for multi-frustum rendering.
   *
   * @example
   * // GLSL declaration
   * uniform vec2 czm_currentFrustum;
   *
   * // Example
   * float frustumLength = czm_currentFrustum.y - czm_currentFrustum.x;
   *
   * @see UniformState#currentFrustum
   * @see czm_entireFrustum
   */ czm_currentFrustum: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC2,
        getValue: function(uniformState) {
            return uniformState.currentFrustum;
        }
    }),
    /**
   * The distances to the frustum planes. The top, bottom, left and right distances are
   * the x, y, z, and w components, respectively.
   */ czm_frustumPlanes: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC4,
        getValue: function(uniformState) {
            return uniformState.frustumPlanes;
        }
    }),
    /**
   * Gets the far plane's distance from the near plane, plus 1.0.
   */ czm_farDepthFromNearPlusOne: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.farDepthFromNearPlusOne;
        }
    }),
    /**
   * Gets the log2 of {@link AutomaticUniforms#czm_farDepthFromNearPlusOne}.
   */ czm_log2FarDepthFromNearPlusOne: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.log2FarDepthFromNearPlusOne;
        }
    }),
    /**
   * Gets 1.0 divided by {@link AutomaticUniforms#czm_log2FarDepthFromNearPlusOne}.
   */ czm_oneOverLog2FarDepthFromNearPlusOne: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.oneOverLog2FarDepthFromNearPlusOne;
        }
    }),
    /**
   * An automatic GLSL uniform representing the sun position in world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_sunPositionWC;
   *
   * @see UniformState#sunPositionWC
   * @see czm_sunPositionColumbusView
   * @see czm_sunDirectionWC
   */ czm_sunPositionWC: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.sunPositionWC;
        }
    }),
    /**
   * An automatic GLSL uniform representing the sun position in Columbus view world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_sunPositionColumbusView;
   *
   * @see UniformState#sunPositionColumbusView
   * @see czm_sunPositionWC
   */ czm_sunPositionColumbusView: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.sunPositionColumbusView;
        }
    }),
    /**
   * An automatic GLSL uniform representing the normalized direction to the sun in eye coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_sunDirectionEC;
   *
   * // Example
   * float diffuse = max(dot(czm_sunDirectionEC, normalEC), 0.0);
   *
   * @see UniformState#sunDirectionEC
   * @see czm_moonDirectionEC
   * @see czm_sunDirectionWC
   */ czm_sunDirectionEC: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.sunDirectionEC;
        }
    }),
    /**
   * An automatic GLSL uniform representing the normalized direction to the sun in world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_sunDirectionWC;
   *
   * // Example
   * float diffuse = max(dot(czm_sunDirectionWC, normalWC), 0.0);
   *
   * @see UniformState#sunDirectionWC
   * @see czm_sunPositionWC
   * @see czm_sunDirectionEC
   */ czm_sunDirectionWC: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.sunDirectionWC;
        }
    }),
    /**
   * An automatic GLSL uniform representing the normalized direction to the moon in eye coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_moonDirectionEC;
   *
   * // Example
   * float diffuse = max(dot(czm_moonDirectionEC, normalEC), 0.0);
   *
   * @see UniformState#moonDirectionEC
   * @see czm_sunDirectionEC
   */ czm_moonDirectionEC: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.moonDirectionEC;
        }
    }),
    /**
   * An automatic GLSL uniform representing the normalized direction to the scene's light source in eye coordinates.
   * This is commonly used for directional lighting computations.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_lightDirectionEC;
   *
   * // Example
   * float diffuse = max(dot(czm_lightDirectionEC, normalEC), 0.0);
   *
   * @see UniformState#lightDirectionEC
   * @see czm_lightDirectionWC
   */ czm_lightDirectionEC: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.lightDirectionEC;
        }
    }),
    /**
   * An automatic GLSL uniform representing the normalized direction to the scene's light source in world coordinates.
   * This is commonly used for directional lighting computations.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_lightDirectionWC;
   *
   * // Example
   * float diffuse = max(dot(czm_lightDirectionWC, normalWC), 0.0);
   *
   * @see UniformState#lightDirectionWC
   * @see czm_lightDirectionEC
   */ czm_lightDirectionWC: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.lightDirectionWC;
        }
    }),
    /**
   * An automatic GLSL uniform that represents the color of light emitted by the scene's light source. This
   * is equivalent to the light color multiplied by the light intensity limited to a maximum luminance of 1.0
   * suitable for non-HDR lighting.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_lightColor;
   *
   * // Example
   * vec3 diffuseColor = czm_lightColor * max(dot(czm_lightDirectionWC, normalWC), 0.0);
   *
   * @see UniformState#lightColor
   * @see czm_lightColorHdr
   */ czm_lightColor: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.lightColor;
        }
    }),
    /**
   * An automatic GLSL uniform that represents the high dynamic range color of light emitted by the scene's light
   * source. This is equivalent to the light color multiplied by the light intensity suitable for HDR lighting.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_lightColorHdr;
   *
   * // Example
   * vec3 diffuseColor = czm_lightColorHdr * max(dot(czm_lightDirectionWC, normalWC), 0.0);
   *
   * @see UniformState#lightColorHdr
   * @see czm_lightColor
   */ czm_lightColorHdr: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.lightColorHdr;
        }
    }),
    /**
   * An automatic GLSL uniform representing the high bits of the camera position in model
   * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering
   * as described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_encodedCameraPositionMCHigh;
   *
   * @see czm_encodedCameraPositionMCLow
   * @see czm_modelViewRelativeToEye
   * @see czm_modelViewProjectionRelativeToEye
   */ czm_encodedCameraPositionMCHigh: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.encodedCameraPositionMCHigh;
        }
    }),
    /**
   * An automatic GLSL uniform representing the low bits of the camera position in model
   * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering
   * as described in {@linkhttp://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_encodedCameraPositionMCLow;
   *
   * @see czm_encodedCameraPositionMCHigh
   * @see czm_modelViewRelativeToEye
   * @see czm_modelViewProjectionRelativeToEye
   */ czm_encodedCameraPositionMCLow: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.encodedCameraPositionMCLow;
        }
    }),
    /**
   * An automatic GLSL uniform representing the position of the viewer (camera) in world coordinates.
   *
   * @example
   * // GLSL declaration
   * uniform vec3 czm_viewerPositionWC;
   */ czm_viewerPositionWC: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getTranslation(uniformState.inverseView, viewerPositionWCScratch);
        }
    }),
    /**
   * An automatic GLSL uniform representing the frame number. This uniform is automatically incremented
   * every frame.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_frameNumber;
   */ czm_frameNumber: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.frameState.frameNumber;
        }
    }),
    /**
   * An automatic GLSL uniform representing the current morph transition time between
   * 2D/Columbus View and 3D, with 0.0 being 2D or Columbus View and 1.0 being 3D.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_morphTime;
   *
   * // Example
   * vec4 p = czm_columbusViewMorph(position2D, position3D, czm_morphTime);
   */ czm_morphTime: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.frameState.morphTime;
        }
    }),
    /**
   * An automatic GLSL uniform representing the current {@link SceneMode}, expressed
   * as a float.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_sceneMode;
   *
   * // Example
   * if (czm_sceneMode == czm_sceneMode2D)
   * {
   *     eyeHeightSq = czm_eyeHeight2D.y;
   * }
   *
   * @see czm_sceneMode2D
   * @see czm_sceneModeColumbusView
   * @see czm_sceneMode3D
   * @see czm_sceneModeMorphing
   */ czm_sceneMode: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.frameState.mode;
        }
    }),
    /**
   * An automatic GLSL uniform representing the current rendering pass.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_pass;
   *
   * // Example
   * if ((czm_pass == czm_passTranslucent) && isOpaque())
   * {
   *     gl_Position *= 0.0; // Cull opaque geometry in the translucent pass
   * }
   */ czm_pass: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.pass;
        }
    }),
    /**
   * An automatic GLSL uniform representing the current scene background color.
   *
   * @example
   * // GLSL declaration
   * uniform vec4 czm_backgroundColor;
   *
   * // Example: If the given color's RGB matches the background color, invert it.
   * vec4 adjustColorForContrast(vec4 color)
   * {
   *     if (czm_backgroundColor.rgb == color.rgb)
   *     {
   *         color.rgb = vec3(1.0) - color.rgb;
   *     }
   *
   *     return color;
   * }
   */ czm_backgroundColor: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC4,
        getValue: function(uniformState) {
            return uniformState.backgroundColor;
        }
    }),
    /**
   * An automatic GLSL uniform containing the BRDF look up texture used for image-based lighting computations.
   *
   * @example
   * // GLSL declaration
   * uniform sampler2D czm_brdfLut;
   *
   * // Example: For a given roughness and NdotV value, find the material's BRDF information in the red and green channels
   * float roughness = 0.5;
   * float NdotV = dot(normal, view);
   * vec2 brdfLut = texture(czm_brdfLut, vec2(NdotV, roughness)).rg;
   */ czm_brdfLut: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SAMPLER_2D,
        getValue: function(uniformState) {
            return uniformState.brdfLut;
        }
    }),
    /**
   * An automatic GLSL uniform containing the environment map used within the scene.
   *
   * @example
   * // GLSL declaration
   * uniform samplerCube czm_environmentMap;
   *
   * // Example: Create a perfect reflection of the environment map on a  model
   * float reflected = reflect(view, normal);
   * vec4 reflectedColor = texture(czm_environmentMap, reflected);
   */ czm_environmentMap: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SAMPLER_CUBE,
        getValue: function(uniformState) {
            return uniformState.environmentMap;
        }
    }),
    /**
   * An automatic GLSL uniform containing the specular environment cube map used within the scene.
   *
   * @example
   * // GLSL declaration
   * uniform samplerCube czm_specularEnvironmentMaps;
   */ czm_specularEnvironmentMaps: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SAMPLER_CUBE,
        getValue: function(uniformState) {
            return uniformState.specularEnvironmentMaps;
        }
    }),
    /**
   * An automatic GLSL uniform containing the maximum valid level-of-detail of the specular environment cube map used within the scene.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_specularEnvironmentMapsMaximumLOD;
   */ czm_specularEnvironmentMapsMaximumLOD: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.specularEnvironmentMapsMaximumLOD;
        }
    }),
    /**
   * An automatic GLSL uniform containing the spherical harmonic coefficients used within the scene.
   *
   * @example
   * // GLSL declaration
   * uniform vec3[9] czm_sphericalHarmonicCoefficients;
   */ czm_sphericalHarmonicCoefficients: new AutomaticUniform({
        size: 9,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.sphericalHarmonicCoefficients;
        }
    }),
    /**
   * An automatic GLSL uniform representing a 3x3 rotation matrix that transforms
   * from True Equator Mean Equinox (TEME) axes to the pseudo-fixed axes at the current scene time.
   *
   * @example
   * // GLSL declaration
   * uniform mat3 czm_temeToPseudoFixed;
   *
   * // Example
   * vec3 pseudoFixed = czm_temeToPseudoFixed * teme;
   *
   * @see UniformState#temeToPseudoFixedMatrix
   * @see Transforms.computeTemeToPseudoFixedMatrix
   */ czm_temeToPseudoFixed: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_MAT3,
        getValue: function(uniformState) {
            return uniformState.temeToPseudoFixedMatrix;
        }
    }),
    /**
   * An automatic GLSL uniform representing the ratio of canvas coordinate space to canvas pixel space.
   *
   * @example
   * uniform float czm_pixelRatio;
   */ czm_pixelRatio: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.pixelRatio;
        }
    }),
    /**
   * An automatic GLSL uniform scalar used to mix a color with the fog color based on the distance to the camera.
   *
   * @see czm_fog
   */ czm_fogDensity: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.fogDensity;
        }
    }),
    /**
   * An automatic GLSL uniform scalar used to mix a color with the fog color based on the distance to the camera.
   *
   * @see czm_fog
   */ czm_fogVisualDensityScalar: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.fogVisualDensityScalar;
        }
    }),
    /**
   * An automatic GLSL uniform scalar used to set a minimum brightness when dynamic lighting is applied to fog.
   *
   * @see czm_fog
   */ czm_fogMinimumBrightness: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.fogMinimumBrightness;
        }
    }),
    /**
   * An automatic uniform representing the color shift for the atmosphere in HSB color space
   *
   * @example
   * uniform vec3 czm_atmosphereHsbShift;
   */ czm_atmosphereHsbShift: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.atmosphereHsbShift;
        }
    }),
    /**
   * An automatic uniform representing the intensity of the light that is used for computing the atmosphere color
   *
   * @example
   * uniform float czm_atmosphereLightIntensity;
   */ czm_atmosphereLightIntensity: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.atmosphereLightIntensity;
        }
    }),
    /**
   * An automatic uniform representing the Rayleigh scattering coefficient used when computing the atmosphere scattering
   *
   * @example
   * uniform vec3 czm_atmosphereRayleighCoefficient;
   */ czm_atmosphereRayleighCoefficient: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.atmosphereRayleighCoefficient;
        }
    }),
    /**
   * An automatic uniform representing the Rayleigh scale height in meters used for computing atmosphere scattering.
   *
   * @example
   * uniform vec3 czm_atmosphereRayleighScaleHeight;
   */ czm_atmosphereRayleighScaleHeight: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.atmosphereRayleighScaleHeight;
        }
    }),
    /**
   * An automatic uniform representing the Mie scattering coefficient used when computing atmosphere scattering.
   *
   * @example
   * uniform vec3 czm_atmosphereMieCoefficient;
   */ czm_atmosphereMieCoefficient: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.atmosphereMieCoefficient;
        }
    }),
    /**
   * An automatic uniform storign the Mie scale height used when computing atmosphere scattering.
   *
   * @example
   * uniform float czm_atmosphereMieScaleHeight;
   */ czm_atmosphereMieScaleHeight: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.atmosphereMieScaleHeight;
        }
    }),
    /**
   * An automatic uniform representing the anisotropy of the medium to consider for Mie scattering.
   *
   * @example
   * uniform float czm_atmosphereAnisotropy;
   */ czm_atmosphereMieAnisotropy: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.atmosphereMieAnisotropy;
        }
    }),
    /**
   * An automatic uniform representing which light source to use for dynamic lighting
   *
   * @example
   * uniform float czm_atmosphereDynamicLighting
   */ czm_atmosphereDynamicLighting: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.atmosphereDynamicLighting;
        }
    }),
    /**
   * An automatic GLSL uniform representing the splitter position to use when rendering with a splitter.
   * This will be in pixel coordinates relative to the canvas.
   *
   * @example
   * // GLSL declaration
   * uniform float czm_splitPosition;
   */ czm_splitPosition: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.splitPosition;
        }
    }),
    /**
   * An automatic GLSL uniform scalar representing the geometric tolerance per meter
   */ czm_geometricToleranceOverMeter: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.geometricToleranceOverMeter;
        }
    }),
    /**
   * An automatic GLSL uniform representing the distance from the camera at which to disable the depth test of billboards, labels and points
   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always be applied. When less than zero,
   * the depth test should never be applied.
   */ czm_minimumDisableDepthTestDistance: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.minimumDisableDepthTestDistance;
        }
    }),
    /**
   * An automatic GLSL uniform that will be the highlight color of unclassified 3D Tiles.
   */ czm_invertClassificationColor: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC4,
        getValue: function(uniformState) {
            return uniformState.invertClassificationColor;
        }
    }),
    /**
   * An automatic GLSL uniform that is used for gamma correction.
   */ czm_gamma: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        getValue: function(uniformState) {
            return uniformState.gamma;
        }
    }),
    /**
   * An automatic GLSL uniform that stores the ellipsoid radii.
   */ czm_ellipsoidRadii: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.ellipsoid.radii;
        }
    }),
    /**
   * An automatic GLSL uniform that stores the ellipsoid inverse radii.
   */ czm_ellipsoidInverseRadii: new AutomaticUniform({
        size: 1,
        datatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT_VEC3,
        getValue: function(uniformState) {
            return uniformState.ellipsoid.oneOverRadii;
        }
    })
};
const __TURBOPACK__default__export__ = AutomaticUniforms;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/createUniform.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartesian2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartesian3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartesian4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Matrix2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Matrix3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Matrix4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/RuntimeError.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
/**
 * @private
 * @constructor
 */ function createUniform(gl, activeUniform, uniformName, location) {
    switch(activeUniform.type){
        case gl.FLOAT:
            return new UniformFloat(gl, activeUniform, uniformName, location);
        case gl.FLOAT_VEC2:
            return new UniformFloatVec2(gl, activeUniform, uniformName, location);
        case gl.FLOAT_VEC3:
            return new UniformFloatVec3(gl, activeUniform, uniformName, location);
        case gl.FLOAT_VEC4:
            return new UniformFloatVec4(gl, activeUniform, uniformName, location);
        case gl.SAMPLER_2D:
        case gl.SAMPLER_3D:
        case gl.SAMPLER_CUBE:
            return new UniformSampler(gl, activeUniform, uniformName, location);
        case gl.UNSIGNED_INT_SAMPLER_2D:
            return new UniformSampler(gl, activeUniform, uniformName, location);
        case gl.INT:
        case gl.BOOL:
            return new UniformInt(gl, activeUniform, uniformName, location);
        case gl.INT_VEC2:
        case gl.BOOL_VEC2:
            return new UniformIntVec2(gl, activeUniform, uniformName, location);
        case gl.INT_VEC3:
        case gl.BOOL_VEC3:
            return new UniformIntVec3(gl, activeUniform, uniformName, location);
        case gl.INT_VEC4:
        case gl.BOOL_VEC4:
            return new UniformIntVec4(gl, activeUniform, uniformName, location);
        case gl.FLOAT_MAT2:
            return new UniformMat2(gl, activeUniform, uniformName, location);
        case gl.FLOAT_MAT3:
            return new UniformMat3(gl, activeUniform, uniformName, location);
        case gl.FLOAT_MAT4:
            return new UniformMat4(gl, activeUniform, uniformName, location);
        default:
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Unrecognized uniform type: ${activeUniform.type} for uniform "${uniformName}".`);
    }
}
/**
 * @private
 * @constructor
 */ function UniformFloat(gl, activeUniform, uniformName, location) {
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = undefined;
    this._value = 0.0;
    this._gl = gl;
    this._location = location;
}
UniformFloat.prototype.set = function() {
    if (this.value !== this._value) {
        this._value = this.value;
        this._gl.uniform1f(this._location, this.value);
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformFloatVec2(gl, activeUniform, uniformName, location) {
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = undefined;
    this._value = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._gl = gl;
    this._location = location;
}
UniformFloatVec2.prototype.set = function() {
    const v = this.value;
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(v, this._value)) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(v, this._value);
        this._gl.uniform2f(this._location, v.x, v.y);
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformFloatVec3(gl, activeUniform, uniformName, location) {
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = undefined;
    this._value = undefined;
    this._gl = gl;
    this._location = location;
}
UniformFloatVec3.prototype.set = function() {
    const v = this.value;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(v.red)) {
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(v, this._value)) {
            this._value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(v, this._value);
            this._gl.uniform3f(this._location, v.red, v.green, v.blue);
        }
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(v.x)) {
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(v, this._value)) {
            this._value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(v, this._value);
            this._gl.uniform3f(this._location, v.x, v.y, v.z);
        }
    } else {
        //>>includeStart('debug', pragmas.debug);
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Invalid vec3 value for uniform "${this.name}".`);
    //>>includeEnd('debug');
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformFloatVec4(gl, activeUniform, uniformName, location) {
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = undefined;
    this._value = undefined;
    this._gl = gl;
    this._location = location;
}
UniformFloatVec4.prototype.set = function() {
    const v = this.value;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(v.red)) {
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(v, this._value)) {
            this._value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(v, this._value);
            this._gl.uniform4f(this._location, v.red, v.green, v.blue, v.alpha);
        }
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(v.x)) {
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(v, this._value)) {
            this._value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(v, this._value);
            this._gl.uniform4f(this._location, v.x, v.y, v.z, v.w);
        }
    } else {
        //>>includeStart('debug', pragmas.debug);
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Invalid vec4 value for uniform "${this.name}".`);
    //>>includeEnd('debug');
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformSampler(gl, activeUniform, uniformName, location) {
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = undefined;
    this._gl = gl;
    this._location = location;
    this.textureUnitIndex = undefined;
}
UniformSampler.prototype.set = function() {
    const gl = this._gl;
    gl.activeTexture(gl.TEXTURE0 + this.textureUnitIndex);
    const v = this.value;
    gl.bindTexture(v._target, v._texture);
};
UniformSampler.prototype._setSampler = function(textureUnitIndex) {
    this.textureUnitIndex = textureUnitIndex;
    this._gl.uniform1i(this._location, textureUnitIndex);
    return textureUnitIndex + 1;
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformInt(gl, activeUniform, uniformName, location) {
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = undefined;
    this._value = 0.0;
    this._gl = gl;
    this._location = location;
}
UniformInt.prototype.set = function() {
    if (this.value !== this._value) {
        this._value = this.value;
        this._gl.uniform1i(this._location, this.value);
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformIntVec2(gl, activeUniform, uniformName, location) {
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = undefined;
    this._value = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._gl = gl;
    this._location = location;
}
UniformIntVec2.prototype.set = function() {
    const v = this.value;
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(v, this._value)) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(v, this._value);
        this._gl.uniform2i(this._location, v.x, v.y);
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformIntVec3(gl, activeUniform, uniformName, location) {
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = undefined;
    this._value = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._gl = gl;
    this._location = location;
}
UniformIntVec3.prototype.set = function() {
    const v = this.value;
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(v, this._value)) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(v, this._value);
        this._gl.uniform3i(this._location, v.x, v.y, v.z);
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformIntVec4(gl, activeUniform, uniformName, location) {
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = undefined;
    this._value = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._gl = gl;
    this._location = location;
}
UniformIntVec4.prototype.set = function() {
    const v = this.value;
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(v, this._value)) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(v, this._value);
        this._gl.uniform4i(this._location, v.x, v.y, v.z, v.w);
    }
};
///////////////////////////////////////////////////////////////////////////
const scratchUniformArray = new Float32Array(4);
/**
 * @private
 * @constructor
 */ function UniformMat2(gl, activeUniform, uniformName, location) {
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = undefined;
    this._value = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._gl = gl;
    this._location = location;
}
UniformMat2.prototype.set = function() {
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsArray(this.value, this._value, 0)) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(this.value, this._value);
        const array = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toArray(this.value, scratchUniformArray);
        this._gl.uniformMatrix2fv(this._location, false, array);
    }
};
///////////////////////////////////////////////////////////////////////////
const scratchMat3Array = new Float32Array(9);
/**
 * @private
 * @constructor
 */ function UniformMat3(gl, activeUniform, uniformName, location) {
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = undefined;
    this._value = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._gl = gl;
    this._location = location;
}
UniformMat3.prototype.set = function() {
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsArray(this.value, this._value, 0)) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(this.value, this._value);
        const array = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toArray(this.value, scratchMat3Array);
        this._gl.uniformMatrix3fv(this._location, false, array);
    }
};
///////////////////////////////////////////////////////////////////////////
const scratchMat4Array = new Float32Array(16);
/**
 * @private
 * @constructor
 */ function UniformMat4(gl, activeUniform, uniformName, location) {
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = undefined;
    this._value = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._gl = gl;
    this._location = location;
}
UniformMat4.prototype.set = function() {
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsArray(this.value, this._value, 0)) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(this.value, this._value);
        const array = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toArray(this.value, scratchMat4Array);
        this._gl.uniformMatrix4fv(this._location, false, array);
    }
};
const __TURBOPACK__default__export__ = createUniform;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/createUniformArray.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartesian2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartesian3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartesian4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Matrix2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Matrix3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Matrix4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/RuntimeError.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
/**
 * @private
 * @constructor
 */ function createUniformArray(gl, activeUniform, uniformName, locations) {
    switch(activeUniform.type){
        case gl.FLOAT:
            return new UniformArrayFloat(gl, activeUniform, uniformName, locations);
        case gl.FLOAT_VEC2:
            return new UniformArrayFloatVec2(gl, activeUniform, uniformName, locations);
        case gl.FLOAT_VEC3:
            return new UniformArrayFloatVec3(gl, activeUniform, uniformName, locations);
        case gl.FLOAT_VEC4:
            return new UniformArrayFloatVec4(gl, activeUniform, uniformName, locations);
        case gl.SAMPLER_2D:
        case gl.SAMPLER_3D:
        case gl.SAMPLER_CUBE:
            return new UniformArraySampler(gl, activeUniform, uniformName, locations);
        case gl.INT:
        case gl.BOOL:
            return new UniformArrayInt(gl, activeUniform, uniformName, locations);
        case gl.INT_VEC2:
        case gl.BOOL_VEC2:
            return new UniformArrayIntVec2(gl, activeUniform, uniformName, locations);
        case gl.INT_VEC3:
        case gl.BOOL_VEC3:
            return new UniformArrayIntVec3(gl, activeUniform, uniformName, locations);
        case gl.INT_VEC4:
        case gl.BOOL_VEC4:
            return new UniformArrayIntVec4(gl, activeUniform, uniformName, locations);
        case gl.FLOAT_MAT2:
            return new UniformArrayMat2(gl, activeUniform, uniformName, locations);
        case gl.FLOAT_MAT3:
            return new UniformArrayMat3(gl, activeUniform, uniformName, locations);
        case gl.FLOAT_MAT4:
            return new UniformArrayMat4(gl, activeUniform, uniformName, locations);
        default:
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Unrecognized uniform type: ${activeUniform.type} for uniform "${uniformName}".`);
    }
}
/**
 * @private
 * @constructor
 */ function UniformArrayFloat(gl, activeUniform, uniformName, locations) {
    const length = locations.length;
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = new Array(length);
    this._value = new Float32Array(length);
    this._gl = gl;
    this._location = locations[0];
}
UniformArrayFloat.prototype.set = function() {
    const value = this.value;
    const length = value.length;
    const arraybuffer = this._value;
    let changed = false;
    for(let i = 0; i < length; ++i){
        const v = value[i];
        if (v !== arraybuffer[i]) {
            arraybuffer[i] = v;
            changed = true;
        }
    }
    if (changed) {
        this._gl.uniform1fv(this._location, arraybuffer);
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformArrayFloatVec2(gl, activeUniform, uniformName, locations) {
    const length = locations.length;
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = new Array(length);
    this._value = new Float32Array(length * 2);
    this._gl = gl;
    this._location = locations[0];
}
UniformArrayFloatVec2.prototype.set = function() {
    const value = this.value;
    const length = value.length;
    const arraybuffer = this._value;
    let changed = false;
    let j = 0;
    for(let i = 0; i < length; ++i){
        const v = value[i];
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsArray(v, arraybuffer, j)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].pack(v, arraybuffer, j);
            changed = true;
        }
        j += 2;
    }
    if (changed) {
        this._gl.uniform2fv(this._location, arraybuffer);
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformArrayFloatVec3(gl, activeUniform, uniformName, locations) {
    const length = locations.length;
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = new Array(length);
    this._value = new Float32Array(length * 3);
    this._gl = gl;
    this._location = locations[0];
}
UniformArrayFloatVec3.prototype.set = function() {
    const value = this.value;
    const length = value.length;
    const arraybuffer = this._value;
    let changed = false;
    let j = 0;
    for(let i = 0; i < length; ++i){
        const v = value[i];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(v.red)) {
            if (v.red !== arraybuffer[j] || v.green !== arraybuffer[j + 1] || v.blue !== arraybuffer[j + 2]) {
                arraybuffer[j] = v.red;
                arraybuffer[j + 1] = v.green;
                arraybuffer[j + 2] = v.blue;
                changed = true;
            }
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(v.x)) {
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsArray(v, arraybuffer, j)) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].pack(v, arraybuffer, j);
                changed = true;
            }
        } else {
            //>>includeStart('debug', pragmas.debug);
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid vec3 value.");
        //>>includeEnd('debug');
        }
        j += 3;
    }
    if (changed) {
        this._gl.uniform3fv(this._location, arraybuffer);
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformArrayFloatVec4(gl, activeUniform, uniformName, locations) {
    const length = locations.length;
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = new Array(length);
    this._value = new Float32Array(length * 4);
    this._gl = gl;
    this._location = locations[0];
}
UniformArrayFloatVec4.prototype.set = function() {
    // PERFORMANCE_IDEA: if it is a common case that only a few elements
    // in a uniform array change, we could use heuristics to determine
    // when it is better to call uniform4f for each element that changed
    // vs. call uniform4fv once to set the entire array.  This applies
    // to all uniform array types, not just vec4.  We might not care
    // once we have uniform buffers since that will be the fast path.
    // PERFORMANCE_IDEA: Micro-optimization (I bet it works though):
    // As soon as changed is true, break into a separate loop that
    // does the copy without the equals check.
    const value = this.value;
    const length = value.length;
    const arraybuffer = this._value;
    let changed = false;
    let j = 0;
    for(let i = 0; i < length; ++i){
        const v = value[i];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(v.red)) {
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsArray(v, arraybuffer, j)) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].pack(v, arraybuffer, j);
                changed = true;
            }
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(v.x)) {
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsArray(v, arraybuffer, j)) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].pack(v, arraybuffer, j);
                changed = true;
            }
        } else {
            //>>includeStart('debug', pragmas.debug);
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid vec4 value.");
        //>>includeEnd('debug');
        }
        j += 4;
    }
    if (changed) {
        this._gl.uniform4fv(this._location, arraybuffer);
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformArraySampler(gl, activeUniform, uniformName, locations) {
    const length = locations.length;
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = new Array(length);
    this._value = new Float32Array(length);
    this._gl = gl;
    this._locations = locations;
    this.textureUnitIndex = undefined;
}
UniformArraySampler.prototype.set = function() {
    const gl = this._gl;
    const textureUnitIndex = gl.TEXTURE0 + this.textureUnitIndex;
    const value = this.value;
    const length = value.length;
    for(let i = 0; i < length; ++i){
        const v = value[i];
        gl.activeTexture(textureUnitIndex + i);
        gl.bindTexture(v._target, v._texture);
    }
};
UniformArraySampler.prototype._setSampler = function(textureUnitIndex) {
    this.textureUnitIndex = textureUnitIndex;
    const locations = this._locations;
    const length = locations.length;
    for(let i = 0; i < length; ++i){
        const index = textureUnitIndex + i;
        this._gl.uniform1i(locations[i], index);
    }
    return textureUnitIndex + length;
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformArrayInt(gl, activeUniform, uniformName, locations) {
    const length = locations.length;
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = new Array(length);
    this._value = new Int32Array(length);
    this._gl = gl;
    this._location = locations[0];
}
UniformArrayInt.prototype.set = function() {
    const value = this.value;
    const length = value.length;
    const arraybuffer = this._value;
    let changed = false;
    for(let i = 0; i < length; ++i){
        const v = value[i];
        if (v !== arraybuffer[i]) {
            arraybuffer[i] = v;
            changed = true;
        }
    }
    if (changed) {
        this._gl.uniform1iv(this._location, arraybuffer);
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformArrayIntVec2(gl, activeUniform, uniformName, locations) {
    const length = locations.length;
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = new Array(length);
    this._value = new Int32Array(length * 2);
    this._gl = gl;
    this._location = locations[0];
}
UniformArrayIntVec2.prototype.set = function() {
    const value = this.value;
    const length = value.length;
    const arraybuffer = this._value;
    let changed = false;
    let j = 0;
    for(let i = 0; i < length; ++i){
        const v = value[i];
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsArray(v, arraybuffer, j)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].pack(v, arraybuffer, j);
            changed = true;
        }
        j += 2;
    }
    if (changed) {
        this._gl.uniform2iv(this._location, arraybuffer);
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformArrayIntVec3(gl, activeUniform, uniformName, locations) {
    const length = locations.length;
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = new Array(length);
    this._value = new Int32Array(length * 3);
    this._gl = gl;
    this._location = locations[0];
}
UniformArrayIntVec3.prototype.set = function() {
    const value = this.value;
    const length = value.length;
    const arraybuffer = this._value;
    let changed = false;
    let j = 0;
    for(let i = 0; i < length; ++i){
        const v = value[i];
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsArray(v, arraybuffer, j)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].pack(v, arraybuffer, j);
            changed = true;
        }
        j += 3;
    }
    if (changed) {
        this._gl.uniform3iv(this._location, arraybuffer);
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformArrayIntVec4(gl, activeUniform, uniformName, locations) {
    const length = locations.length;
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = new Array(length);
    this._value = new Int32Array(length * 4);
    this._gl = gl;
    this._location = locations[0];
}
UniformArrayIntVec4.prototype.set = function() {
    const value = this.value;
    const length = value.length;
    const arraybuffer = this._value;
    let changed = false;
    let j = 0;
    for(let i = 0; i < length; ++i){
        const v = value[i];
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsArray(v, arraybuffer, j)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].pack(v, arraybuffer, j);
            changed = true;
        }
        j += 4;
    }
    if (changed) {
        this._gl.uniform4iv(this._location, arraybuffer);
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformArrayMat2(gl, activeUniform, uniformName, locations) {
    const length = locations.length;
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = new Array(length);
    this._value = new Float32Array(length * 4);
    this._gl = gl;
    this._location = locations[0];
}
UniformArrayMat2.prototype.set = function() {
    const value = this.value;
    const length = value.length;
    const arraybuffer = this._value;
    let changed = false;
    let j = 0;
    for(let i = 0; i < length; ++i){
        const v = value[i];
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsArray(v, arraybuffer, j)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].pack(v, arraybuffer, j);
            changed = true;
        }
        j += 4;
    }
    if (changed) {
        this._gl.uniformMatrix2fv(this._location, false, arraybuffer);
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformArrayMat3(gl, activeUniform, uniformName, locations) {
    const length = locations.length;
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = new Array(length);
    this._value = new Float32Array(length * 9);
    this._gl = gl;
    this._location = locations[0];
}
UniformArrayMat3.prototype.set = function() {
    const value = this.value;
    const length = value.length;
    const arraybuffer = this._value;
    let changed = false;
    let j = 0;
    for(let i = 0; i < length; ++i){
        const v = value[i];
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsArray(v, arraybuffer, j)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].pack(v, arraybuffer, j);
            changed = true;
        }
        j += 9;
    }
    if (changed) {
        this._gl.uniformMatrix3fv(this._location, false, arraybuffer);
    }
};
///////////////////////////////////////////////////////////////////////////
/**
 * @private
 * @constructor
 */ function UniformArrayMat4(gl, activeUniform, uniformName, locations) {
    const length = locations.length;
    /**
   * @type {string}
   * @readonly
   */ this.name = uniformName;
    this.value = new Array(length);
    this._value = new Float32Array(length * 16);
    this._gl = gl;
    this._location = locations[0];
}
UniformArrayMat4.prototype.set = function() {
    const value = this.value;
    const length = value.length;
    const arraybuffer = this._value;
    let changed = false;
    let j = 0;
    for(let i = 0; i < length; ++i){
        const v = value[i];
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsArray(v, arraybuffer, j)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].pack(v, arraybuffer, j);
            changed = true;
        }
        j += 16;
    }
    if (changed) {
        this._gl.uniformMatrix4fv(this._location, false, arraybuffer);
    }
};
const __TURBOPACK__default__export__ = createUniformArray;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/ShaderProgram.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/destroyObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/RuntimeError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$AutomaticUniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/AutomaticUniforms.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ContextLimits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$createUniform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/createUniform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$createUniformArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/createUniformArray.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
let nextShaderProgramId = 0;
/**
 * @private
 */ function ShaderProgram(options) {
    let vertexShaderText = options.vertexShaderText;
    let fragmentShaderText = options.fragmentShaderText;
    if (typeof spector !== "undefined") {
        // The #line statements common in Cesium shaders interfere with the ability of the
        // SpectorJS to show errors on the correct line. So remove them when SpectorJS
        // is active.
        vertexShaderText = vertexShaderText.replace(/^#line/gm, "//#line");
        fragmentShaderText = fragmentShaderText.replace(/^#line/gm, "//#line");
    }
    const modifiedFS = handleUniformPrecisionMismatches(vertexShaderText, fragmentShaderText);
    this._gl = options.gl;
    this._logShaderCompilation = options.logShaderCompilation;
    this._debugShaders = options.debugShaders;
    this._attributeLocations = options.attributeLocations;
    this._program = undefined;
    this._numberOfVertexAttributes = undefined;
    this._vertexAttributes = undefined;
    this._uniformsByName = undefined;
    this._uniforms = undefined;
    this._automaticUniforms = undefined;
    this._manualUniforms = undefined;
    this._duplicateUniformNames = modifiedFS.duplicateUniformNames;
    this._cachedShader = undefined; // Used by ShaderCache
    /**
   * @private
   */ this.maximumTextureUnitIndex = undefined;
    this._vertexShaderSource = options.vertexShaderSource;
    this._vertexShaderText = options.vertexShaderText;
    this._fragmentShaderSource = options.fragmentShaderSource;
    this._fragmentShaderText = modifiedFS.fragmentShaderText;
    /**
   * @private
   */ this.id = nextShaderProgramId++;
}
ShaderProgram.fromCache = function(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.context", options.context);
    //>>includeEnd('debug');
    return options.context.shaderCache.getShaderProgram(options);
};
ShaderProgram.replaceCache = function(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.context", options.context);
    //>>includeEnd('debug');
    return options.context.shaderCache.replaceShaderProgram(options);
};
Object.defineProperties(ShaderProgram.prototype, {
    /**
   * GLSL source for the shader program's vertex shader.
   * @memberof ShaderProgram.prototype
   *
   * @type {ShaderSource}
   * @readonly
   */ vertexShaderSource: {
        get: function() {
            return this._vertexShaderSource;
        }
    },
    /**
   * GLSL source for the shader program's fragment shader.
   * @memberof ShaderProgram.prototype
   *
   * @type {ShaderSource}
   * @readonly
   */ fragmentShaderSource: {
        get: function() {
            return this._fragmentShaderSource;
        }
    },
    vertexAttributes: {
        get: function() {
            initialize(this);
            return this._vertexAttributes;
        }
    },
    numberOfVertexAttributes: {
        get: function() {
            initialize(this);
            return this._numberOfVertexAttributes;
        }
    },
    allUniforms: {
        get: function() {
            initialize(this);
            return this._uniformsByName;
        }
    }
});
function extractUniforms(shaderText) {
    const uniformNames = [];
    const uniformLines = shaderText.match(/uniform.*?(?![^{]*})(?=[=\[;])/g);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(uniformLines)) {
        const len = uniformLines.length;
        for(let i = 0; i < len; i++){
            const line = uniformLines[i].trim();
            const name = line.slice(line.lastIndexOf(" ") + 1);
            uniformNames.push(name);
        }
    }
    return uniformNames;
}
function handleUniformPrecisionMismatches(vertexShaderText, fragmentShaderText) {
    // If a uniform exists in both the vertex and fragment shader but with different precision qualifiers,
    // give the fragment shader uniform a different name. This fixes shader compilation errors on devices
    // that only support mediump in the fragment shader.
    const duplicateUniformNames = {};
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].highpFloatSupported || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].highpIntSupported) {
        let i, j;
        let uniformName;
        let duplicateName;
        const vertexShaderUniforms = extractUniforms(vertexShaderText);
        const fragmentShaderUniforms = extractUniforms(fragmentShaderText);
        const vertexUniformsCount = vertexShaderUniforms.length;
        const fragmentUniformsCount = fragmentShaderUniforms.length;
        for(i = 0; i < vertexUniformsCount; i++){
            for(j = 0; j < fragmentUniformsCount; j++){
                if (vertexShaderUniforms[i] === fragmentShaderUniforms[j]) {
                    uniformName = vertexShaderUniforms[i];
                    duplicateName = `czm_mediump_${uniformName}`;
                    // Update fragmentShaderText with renamed uniforms
                    const re = new RegExp(`${uniformName}\\b`, "g");
                    fragmentShaderText = fragmentShaderText.replace(re, duplicateName);
                    duplicateUniformNames[duplicateName] = uniformName;
                }
            }
        }
    }
    return {
        fragmentShaderText: fragmentShaderText,
        duplicateUniformNames: duplicateUniformNames
    };
}
const consolePrefix = "[Cesium WebGL] ";
function createAndLinkProgram(gl, shader) {
    const vsSource = shader._vertexShaderText;
    const fsSource = shader._fragmentShaderText;
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vsSource);
    gl.compileShader(vertexShader);
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fsSource);
    gl.compileShader(fragmentShader);
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    const attributeLocations = shader._attributeLocations;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attributeLocations)) {
        for(const attribute in attributeLocations){
            if (attributeLocations.hasOwnProperty(attribute)) {
                gl.bindAttribLocation(program, attributeLocations[attribute], attribute);
            }
        }
    }
    gl.linkProgram(program);
    let log;
    // For performance: if linker succeeds, return without checking compile status
    if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
        if (shader._logShaderCompilation) {
            log = gl.getShaderInfoLog(vertexShader);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(log) && log.length > 0) {
                console.log(`${consolePrefix}Vertex shader compile log: ${log}`);
            }
            log = gl.getShaderInfoLog(fragmentShader);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(log) && log.length > 0) {
                console.log(`${consolePrefix}Fragment shader compile log: ${log}`);
            }
            log = gl.getProgramInfoLog(program);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(log) && log.length > 0) {
                console.log(`${consolePrefix}Shader program link log: ${log}`);
            }
        }
        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);
        return program;
    }
    // Program failed to link. Try to find and report the reason
    let errorMessage;
    const debugShaders = shader._debugShaders;
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        log = gl.getShaderInfoLog(fragmentShader);
        console.error(`${consolePrefix}Fragment shader compile log: ${log}`);
        console.error(`${consolePrefix} Fragment shader source:\n${fsSource}`);
        errorMessage = `Fragment shader failed to compile.  Compile log: ${log}`;
    } else if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        log = gl.getShaderInfoLog(vertexShader);
        console.error(`${consolePrefix}Vertex shader compile log: ${log}`);
        console.error(`${consolePrefix} Vertex shader source:\n${vsSource}`);
        errorMessage = `Vertex shader failed to compile.  Compile log: ${log}`;
    } else {
        log = gl.getProgramInfoLog(program);
        console.error(`${consolePrefix}Shader program link log: ${log}`);
        logTranslatedSource(vertexShader, "vertex");
        logTranslatedSource(fragmentShader, "fragment");
        errorMessage = `Program failed to link.  Link log: ${log}`;
    }
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);
    gl.deleteProgram(program);
    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](errorMessage);
    function logTranslatedSource(compiledShader, name) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(debugShaders)) {
            return;
        }
        const translation = debugShaders.getTranslatedShaderSource(compiledShader);
        if (translation === "") {
            console.error(`${consolePrefix}${name} shader translation failed.`);
            return;
        }
        console.error(`${consolePrefix}Translated ${name} shaderSource:\n${translation}`);
    }
}
function findVertexAttributes(gl, program, numberOfAttributes) {
    const attributes = {};
    for(let i = 0; i < numberOfAttributes; ++i){
        const attr = gl.getActiveAttrib(program, i);
        const location = gl.getAttribLocation(program, attr.name);
        attributes[attr.name] = {
            name: attr.name,
            type: attr.type,
            index: location
        };
    }
    return attributes;
}
function findUniforms(gl, program) {
    const uniformsByName = {};
    const uniforms = [];
    const samplerUniforms = [];
    const numberOfUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for(let i = 0; i < numberOfUniforms; ++i){
        const activeUniform = gl.getActiveUniform(program, i);
        const suffix = "[0]";
        const uniformName = activeUniform.name.indexOf(suffix, activeUniform.name.length - suffix.length) !== -1 ? activeUniform.name.slice(0, activeUniform.name.length - 3) : activeUniform.name;
        // Ignore GLSL built-in uniforms returned in Firefox.
        if (uniformName.indexOf("gl_") !== 0) {
            if (activeUniform.name.indexOf("[") < 0) {
                // Single uniform
                const location = gl.getUniformLocation(program, uniformName);
                // IE 11.0.9 needs this check since getUniformLocation can return null
                // if the uniform is not active (e.g., it is optimized out).  Looks like
                // getActiveUniform() above returns uniforms that are not actually active.
                if (location !== null) {
                    const uniform = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$createUniform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(gl, activeUniform, uniformName, location);
                    uniformsByName[uniformName] = uniform;
                    uniforms.push(uniform);
                    if (uniform._setSampler) {
                        samplerUniforms.push(uniform);
                    }
                }
            } else {
                // Uniform array
                let uniformArray;
                let locations;
                let value;
                let loc;
                // On some platforms - Nexus 4 in Firefox for one - an array of sampler2D ends up being represented
                // as separate uniforms, one for each array element.  Check for and handle that case.
                const indexOfBracket = uniformName.indexOf("[");
                if (indexOfBracket >= 0) {
                    // We're assuming the array elements show up in numerical order - it seems to be true.
                    uniformArray = uniformsByName[uniformName.slice(0, indexOfBracket)];
                    // Nexus 4 with Android 4.3 needs this check, because it reports a uniform
                    // with the strange name webgl_3467e0265d05c3c1[1] in our globe surface shader.
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(uniformArray)) {
                        continue;
                    }
                    locations = uniformArray._locations;
                    // On the Nexus 4 in Chrome, we get one uniform per sampler, just like in Firefox,
                    // but the size is not 1 like it is in Firefox.  So if we push locations here,
                    // we'll end up adding too many locations.
                    if (locations.length <= 1) {
                        value = uniformArray.value;
                        loc = gl.getUniformLocation(program, uniformName);
                        // Workaround for IE 11.0.9.  See above.
                        if (loc !== null) {
                            locations.push(loc);
                            value.push(gl.getUniform(program, loc));
                        }
                    }
                } else {
                    locations = [];
                    for(let j = 0; j < activeUniform.size; ++j){
                        loc = gl.getUniformLocation(program, `${uniformName}[${j}]`);
                        // Workaround for IE 11.0.9.  See above.
                        if (loc !== null) {
                            locations.push(loc);
                        }
                    }
                    uniformArray = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$createUniformArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(gl, activeUniform, uniformName, locations);
                    uniformsByName[uniformName] = uniformArray;
                    uniforms.push(uniformArray);
                    if (uniformArray._setSampler) {
                        samplerUniforms.push(uniformArray);
                    }
                }
            }
        }
    }
    return {
        uniformsByName: uniformsByName,
        uniforms: uniforms,
        samplerUniforms: samplerUniforms
    };
}
function partitionUniforms(shader, uniforms) {
    const automaticUniforms = [];
    const manualUniforms = [];
    for(const uniform in uniforms){
        if (uniforms.hasOwnProperty(uniform)) {
            const uniformObject = uniforms[uniform];
            let uniformName = uniform;
            // if it's a duplicate uniform, use its original name so it is updated correctly
            const duplicateUniform = shader._duplicateUniformNames[uniformName];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(duplicateUniform)) {
                uniformObject.name = duplicateUniform;
                uniformName = duplicateUniform;
            }
            const automaticUniform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$AutomaticUniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][uniformName];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(automaticUniform)) {
                automaticUniforms.push({
                    uniform: uniformObject,
                    automaticUniform: automaticUniform
                });
            } else {
                manualUniforms.push(uniformObject);
            }
        }
    }
    return {
        automaticUniforms: automaticUniforms,
        manualUniforms: manualUniforms
    };
}
function setSamplerUniforms(gl, program, samplerUniforms) {
    gl.useProgram(program);
    let textureUnitIndex = 0;
    const length = samplerUniforms.length;
    for(let i = 0; i < length; ++i){
        textureUnitIndex = samplerUniforms[i]._setSampler(textureUnitIndex);
    }
    gl.useProgram(null);
    return textureUnitIndex;
}
function initialize(shader) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(shader._program)) {
        return;
    }
    reinitialize(shader);
}
function reinitialize(shader) {
    const oldProgram = shader._program;
    const gl = shader._gl;
    const program = createAndLinkProgram(gl, shader, shader._debugShaders);
    const numberOfVertexAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    const uniforms = findUniforms(gl, program);
    const partitionedUniforms = partitionUniforms(shader, uniforms.uniformsByName);
    shader._program = program;
    shader._numberOfVertexAttributes = numberOfVertexAttributes;
    shader._vertexAttributes = findVertexAttributes(gl, program, numberOfVertexAttributes);
    shader._uniformsByName = uniforms.uniformsByName;
    shader._uniforms = uniforms.uniforms;
    shader._automaticUniforms = partitionedUniforms.automaticUniforms;
    shader._manualUniforms = partitionedUniforms.manualUniforms;
    shader.maximumTextureUnitIndex = setSamplerUniforms(gl, program, uniforms.samplerUniforms);
    if (oldProgram) {
        shader._gl.deleteProgram(oldProgram);
    }
    // If SpectorJS is active, add the hook to make the shader editor work.
    // https://github.com/BabylonJS/Spector.js/blob/master/documentation/extension.md#shader-editor
    if (typeof spector !== "undefined") {
        shader._program.__SPECTOR_rebuildProgram = function(vertexSourceCode, fragmentSourceCode, onCompiled, onError) {
            const originalVS = shader._vertexShaderText;
            const originalFS = shader._fragmentShaderText;
            // SpectorJS likes to replace `!=` with `! =` for unknown reasons,
            // and that causes glsl compile failures. So fix that up.
            const regex = / ! = /g;
            shader._vertexShaderText = vertexSourceCode.replace(regex, " != ");
            shader._fragmentShaderText = fragmentSourceCode.replace(regex, " != ");
            try {
                reinitialize(shader);
                onCompiled(shader._program);
            } catch (e) {
                shader._vertexShaderText = originalVS;
                shader._fragmentShaderText = originalFS;
                // Only pass on the WebGL error:
                const errorMatcher = /(?:Compile|Link) error: ([^]*)/;
                const match = errorMatcher.exec(e.message);
                if (match) {
                    onError(match[1]);
                } else {
                    onError(e.message);
                }
            }
        };
    }
}
ShaderProgram.prototype._bind = function() {
    initialize(this);
    this._gl.useProgram(this._program);
};
ShaderProgram.prototype._setUniforms = function(uniformMap, uniformState, validate) {
    let len;
    let i;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(uniformMap)) {
        const manualUniforms = this._manualUniforms;
        len = manualUniforms.length;
        for(i = 0; i < len; ++i){
            const mu = manualUniforms[i];
            //>>includeStart('debug', pragmas.debug);
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(uniformMap[mu.name])) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Unknown uniform: ${mu.name}`);
            }
            //>>includeEnd('debug');
            mu.value = uniformMap[mu.name]();
        }
    }
    const automaticUniforms = this._automaticUniforms;
    len = automaticUniforms.length;
    for(i = 0; i < len; ++i){
        const au = automaticUniforms[i];
        au.uniform.value = au.automaticUniform.getValue(uniformState);
    }
    ///////////////////////////////////////////////////////////////////
    // It appears that assigning the uniform values above and then setting them here
    // (which makes the GL calls) is faster than removing this loop and making
    // the GL calls above.  I suspect this is because each GL call pollutes the
    // L2 cache making our JavaScript and the browser/driver ping-pong cache lines.
    const uniforms = this._uniforms;
    len = uniforms.length;
    for(i = 0; i < len; ++i){
        uniforms[i].set();
    }
    if (validate) {
        const gl = this._gl;
        const program = this._program;
        gl.validateProgram(program);
        //>>includeStart('debug', pragmas.debug);
        if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Program validation failed.  Program info log: ${gl.getProgramInfoLog(program)}`);
        }
    //>>includeEnd('debug');
    }
};
ShaderProgram.prototype.isDestroyed = function() {
    return false;
};
ShaderProgram.prototype.destroy = function() {
    this._cachedShader.cache.releaseShaderProgram(this);
    return undefined;
};
ShaderProgram.prototype.finalDestroy = function() {
    this._gl.deleteProgram(this._program);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
};
const __TURBOPACK__default__export__ = ShaderProgram;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/demodernizeShader.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
/**
 * Transpiles a [GLSL 3.00]{@link https://registry.khronos.org/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf}
 * shader to a [GLSL 1.00]{@link https://registry.khronos.org/OpenGL/specs/es/2.0/GLSL_ES_Specification_1.00.pdf} shader.
 *
 * This function does not aim to provide a comprehensive transpilation from GLSL 3.00 to GLSL 1.00; only the functionality
 * used within the CesiumJS shaders is supported.
 *
 * @private
 *
 * @param {string} input The GLSL 3.00 shader.
 * @param {boolean} isFragmentShader True if the shader is a fragment shader.
 *
 * @return {string}
 */ function demodernizeShader(input, isFragmentShader) {
    let output = input;
    // Remove version string got GLSL 3.00.
    output = output.replaceAll(`version 300 es`, ``);
    // Replace all texture calls with texture2D
    output = output.replaceAll(/(texture\()/g, `texture2D(`);
    if (isFragmentShader) {
        // Replace the in with varying.
        output = output.replaceAll(/\n\s*(in)\s+(vec\d|mat\d|float)/g, `\nvarying $2`);
        if (/out_FragData_(\d+)/.test(output)) {
            output = `#extension GL_EXT_draw_buffers : enable\n${output}`;
            // Remove all layout declarations for out_FragData.
            output = output.replaceAll(/layout\s+\(location\s*=\s*\d+\)\s*out\s+vec4\s+out_FragData_\d+;/g, ``);
            // Replace out_FragData with gl_FragData.
            output = output.replaceAll(/out_FragData_(\d+)/g, `gl_FragData[$1]`);
        }
        // Remove all layout declarations for out_FragColor.
        output = output.replaceAll(/layout\s+\(location\s*=\s*0\)\s*out\s+vec4\s+out_FragColor;/g, ``);
        // Replace out_FragColor with gl_FragColor.
        output = output.replaceAll(/out_FragColor/g, `gl_FragColor`);
        output = output.replaceAll(/out_FragColor\[(\d+)\]/g, `gl_FragColor[$1]`);
        if (/gl_FragDepth/.test(output)) {
            output = `#extension GL_EXT_frag_depth : enable\n${output}`;
            // Replace gl_FragDepth with gl_FragDepthEXT.
            output = output.replaceAll(/gl_FragDepth/g, `gl_FragDepthEXT`);
        }
        // Enable the EXT_shader_texture_lod extension
        output = `#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n#endif\n${output}`;
        // Enable the OES_standard_derivatives extension
        output = `#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n${output}`;
    } else {
        // Replace the in with attribute.
        output = output.replaceAll(/(in)\s+(vec\d|mat\d|float)/g, `attribute $2`);
        // Replace the out with varying.
        output = output.replaceAll(/(out)\s+(vec\d|mat\d|float)\s+([\w]+);/g, `varying $2 $3;`);
    }
    // Add version string for GLSL 1.00.
    output = `#version 100\n${output}`;
    return output;
}
const __TURBOPACK__default__export__ = demodernizeShader;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/ShaderSource.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Shaders$2f$Builtin$2f$CzmBuiltins$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Shaders/Builtin/CzmBuiltins.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$AutomaticUniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/AutomaticUniforms.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$demodernizeShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/demodernizeShader.js [app-client] (ecmascript)");
;
;
;
;
;
;
function removeComments(source) {
    // remove inline comments
    source = source.replace(/\/\/.*/g, "");
    // remove multiline comment block
    return source.replace(/\/\*\*[\s\S]*?\*\//gm, function(match) {
        // preserve the number of lines in the comment block so the line numbers will be correct when debugging shaders
        const numberOfLines = match.match(/\n/gm).length;
        let replacement = "";
        for(let lineNumber = 0; lineNumber < numberOfLines; ++lineNumber){
            replacement += "\n";
        }
        return replacement;
    });
}
function getDependencyNode(name, glslSource, nodes) {
    let dependencyNode;
    // check if already loaded
    for(let i = 0; i < nodes.length; ++i){
        if (nodes[i].name === name) {
            dependencyNode = nodes[i];
        }
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(dependencyNode)) {
        // strip doc comments so we don't accidentally try to determine a dependency for something found
        // in a comment
        glslSource = removeComments(glslSource);
        // create new node
        dependencyNode = {
            name: name,
            glslSource: glslSource,
            dependsOn: [],
            requiredBy: [],
            evaluated: false
        };
        nodes.push(dependencyNode);
    }
    return dependencyNode;
}
function generateDependencies(currentNode, dependencyNodes) {
    if (currentNode.evaluated) {
        return;
    }
    currentNode.evaluated = true;
    // identify all dependencies that are referenced from this glsl source code
    let czmMatches = currentNode.glslSource.match(/\bczm_[a-zA-Z0-9_]*/g);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(czmMatches) && czmMatches !== null) {
        // remove duplicates
        czmMatches = czmMatches.filter(function(elem, pos) {
            return czmMatches.indexOf(elem) === pos;
        });
        czmMatches.forEach(function(element) {
            if (element !== currentNode.name && ShaderSource._czmBuiltinsAndUniforms.hasOwnProperty(element)) {
                const referencedNode = getDependencyNode(element, ShaderSource._czmBuiltinsAndUniforms[element], dependencyNodes);
                currentNode.dependsOn.push(referencedNode);
                referencedNode.requiredBy.push(currentNode);
                // recursive call to find any dependencies of the new node
                generateDependencies(referencedNode, dependencyNodes);
            }
        });
    }
}
function sortDependencies(dependencyNodes) {
    const nodesWithoutIncomingEdges = [];
    const allNodes = [];
    while(dependencyNodes.length > 0){
        const node = dependencyNodes.pop();
        allNodes.push(node);
        if (node.requiredBy.length === 0) {
            nodesWithoutIncomingEdges.push(node);
        }
    }
    while(nodesWithoutIncomingEdges.length > 0){
        const currentNode = nodesWithoutIncomingEdges.shift();
        dependencyNodes.push(currentNode);
        for(let i = 0; i < currentNode.dependsOn.length; ++i){
            // remove the edge from the graph
            const referencedNode = currentNode.dependsOn[i];
            const index = referencedNode.requiredBy.indexOf(currentNode);
            referencedNode.requiredBy.splice(index, 1);
            // if referenced node has no more incoming edges, add to list
            if (referencedNode.requiredBy.length === 0) {
                nodesWithoutIncomingEdges.push(referencedNode);
            }
        }
    }
    // if there are any nodes left with incoming edges, then there was a circular dependency somewhere in the graph
    const badNodes = [];
    for(let j = 0; j < allNodes.length; ++j){
        if (allNodes[j].requiredBy.length !== 0) {
            badNodes.push(allNodes[j]);
        }
    }
    //>>includeStart('debug', pragmas.debug);
    if (badNodes.length !== 0) {
        let message = "A circular dependency was found in the following built-in functions/structs/constants: \n";
        for(let k = 0; k < badNodes.length; ++k){
            message = `${message + badNodes[k].name}\n`;
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](message);
    }
//>>includeEnd('debug');
}
function getBuiltinsAndAutomaticUniforms(shaderSource) {
    // generate a dependency graph for builtin functions
    const dependencyNodes = [];
    const root = getDependencyNode("main", shaderSource, dependencyNodes);
    generateDependencies(root, dependencyNodes);
    sortDependencies(dependencyNodes);
    // Concatenate the source code for the function dependencies.
    // Iterate in reverse so that dependent items are declared before they are used.
    let builtinsSource = "";
    for(let i = dependencyNodes.length - 1; i >= 0; --i){
        builtinsSource = `${builtinsSource + dependencyNodes[i].glslSource}\n`;
    }
    return builtinsSource.replace(root.glslSource, "");
}
function combineShader(shaderSource, isFragmentShader, context) {
    let i;
    let length;
    // Combine shader sources, generally for pseudo-polymorphism, e.g., czm_getMaterial.
    let combinedSources = "";
    const sources = shaderSource.sources;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(sources)) {
        for(i = 0, length = sources.length; i < length; ++i){
            // #line needs to be on its own line.
            combinedSources += `\n#line 0\n${sources[i]}`;
        }
    }
    combinedSources = removeComments(combinedSources);
    // Extract existing shader version from sources
    let version;
    combinedSources = combinedSources.replace(/#version\s+(.*?)\n/gm, function(match, group1) {
        //>>includeStart('debug', pragmas.debug);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(version) && version !== group1) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`inconsistent versions found: ${version} and ${group1}`);
        }
        //>>includeEnd('debug');
        // Extract #version to put at the top
        version = group1;
        // Replace original #version directive with a new line so the line numbers
        // are not off by one.  There can be only one #version directive
        // and it must appear at the top of the source, only preceded by
        // whitespace and comments.
        return "\n";
    });
    // Extract shader extensions from sources
    const extensions = [];
    combinedSources = combinedSources.replace(/#extension.*\n/gm, function(match) {
        // Extract extension to put at the top
        extensions.push(match);
        // Replace original #extension directive with a new line so the line numbers
        // are not off by one.
        return "\n";
    });
    // Remove precision qualifier
    combinedSources = combinedSources.replace(/precision\s(lowp|mediump|highp)\s(float|int);/, "");
    // Replace main() for picked if desired.
    const pickColorQualifier = shaderSource.pickColorQualifier;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(pickColorQualifier)) {
        combinedSources = ShaderSource.createPickFragmentShaderSource(combinedSources, pickColorQualifier);
    }
    // combine into single string
    let result = "";
    const extensionsLength = extensions.length;
    for(i = 0; i < extensionsLength; i++){
        result += extensions[i];
    }
    if (isFragmentShader) {
        // If high precision isn't support replace occurrences of highp with mediump
        // The highp keyword is not always available on older mobile devices
        // See https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#In_WebGL_1_highp_float_support_is_optional_in_fragment_shaders
        result += "\
#ifdef GL_FRAGMENT_PRECISION_HIGH\n\
    precision highp float;\n\
    precision highp int;\n\
#else\n\
    precision mediump float;\n\
    precision mediump int;\n\
    #define highp mediump\n\
#endif\n\n";
    }
    // Prepend #defines for uber-shaders
    const defines = shaderSource.defines;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(defines)) {
        for(i = 0, length = defines.length; i < length; ++i){
            const define = defines[i];
            if (define.length !== 0) {
                result += `#define ${define}\n`;
            }
        }
    }
    // Define a constant for the OES_texture_float_linear extension since WebGL does not.
    if (context.textureFloatLinear) {
        result += "#define OES_texture_float_linear\n\n";
    }
    // Define a constant for the OES_texture_float extension since WebGL does not.
    if (context.floatingPointTexture) {
        result += "#define OES_texture_float\n\n";
    }
    // append built-ins
    let builtinSources = "";
    if (shaderSource.includeBuiltIns) {
        builtinSources = getBuiltinsAndAutomaticUniforms(combinedSources);
    }
    // reset line number
    result += "\n#line 0\n";
    // append actual source
    const combinedShader = builtinSources + combinedSources;
    if (context.webgl2 && isFragmentShader && !/layout\s*\(location\s*=\s*0\)\s*out\s+vec4\s+out_FragColor;/g.test(combinedShader) && !/czm_out_FragColor/g.test(combinedShader) && /out_FragColor/g.test(combinedShader)) {
        result += "layout(location = 0) out vec4 out_FragColor;\n\n";
    }
    result += builtinSources;
    result += combinedSources;
    // modernize the source
    if (!context.webgl2) {
        result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$demodernizeShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result, isFragmentShader);
    } else {
        result = `#version 300 es\n${result}`;
    }
    return result;
}
/**
 * An object containing various inputs that will be combined to form a final GLSL shader string.
 *
 * @param {object} [options] Object with the following properties:
 * @param {string[]} [options.sources] An array of strings to combine containing GLSL code for the shader.
 * @param {string[]} [options.defines] An array of strings containing GLSL identifiers to <code>#define</code>.
 * @param {string} [options.pickColorQualifier] The GLSL qualifier, <code>uniform</code> or <code>in</code>, for the input <code>czm_pickColor</code>.  When defined, a pick fragment shader is generated.
 * @param {boolean} [options.includeBuiltIns=true] If true, referenced built-in functions will be included with the combined shader.  Set to false if this shader will become a source in another shader, to avoid duplicating functions.
 *
 * @exception {DeveloperError} options.pickColorQualifier must be 'uniform' or 'in'.
 *
 * @example
 * // 1. Prepend #defines to a shader
 * const source = new Cesium.ShaderSource({
 *   defines : ['WHITE'],
 *   sources : ['void main() { \n#ifdef WHITE\n out_FragColor = vec4(1.0); \n#else\n out_FragColor = vec4(0.0); \n#endif\n }']
 * });
 *
 * // 2. Modify a fragment shader for picking
 * const source2 = new Cesium.ShaderSource({
 *   sources : ['void main() { out_FragColor = vec4(1.0); }'],
 *   pickColorQualifier : 'uniform'
 * });
 *
 * @private
 */ function ShaderSource(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const pickColorQualifier = options.pickColorQualifier;
    //>>includeStart('debug', pragmas.debug);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(pickColorQualifier) && pickColorQualifier !== "uniform" && pickColorQualifier !== "in") {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("options.pickColorQualifier must be 'uniform' or 'in'.");
    }
    //>>includeEnd('debug');
    this.defines = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.defines) ? options.defines.slice(0) : [];
    this.sources = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.sources) ? options.sources.slice(0) : [];
    this.pickColorQualifier = pickColorQualifier;
    this.includeBuiltIns = options.includeBuiltIns ?? true;
}
ShaderSource.prototype.clone = function() {
    return new ShaderSource({
        sources: this.sources,
        defines: this.defines,
        pickColorQualifier: this.pickColorQualifier,
        includeBuiltIns: this.includeBuiltIns
    });
};
ShaderSource.replaceMain = function(source, renamedMain) {
    renamedMain = `void ${renamedMain}()`;
    return source.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, renamedMain);
};
/**
 * Since {@link ShaderSource#createCombinedVertexShader} and
 * {@link ShaderSource#createCombinedFragmentShader} are both expensive to
 * compute, create a simpler string key for lookups in the {@link ShaderCache}.
 *
 * @returns {string} A key for identifying this shader
 *
 * @private
 */ ShaderSource.prototype.getCacheKey = function() {
    // Sort defines to make the key comparison deterministic
    const sortedDefines = this.defines.slice().sort();
    const definesKey = sortedDefines.join(",");
    const pickKey = this.pickColorQualifier;
    const builtinsKey = this.includeBuiltIns;
    const sourcesKey = this.sources.join("\n");
    return `${definesKey}:${pickKey}:${builtinsKey}:${sourcesKey}`;
};
/**
 * Create a single string containing the full, combined vertex shader with all dependencies and defines.
 *
 * @param {Context} context The current rendering context
 *
 * @returns {string} The combined shader string.
 */ ShaderSource.prototype.createCombinedVertexShader = function(context) {
    return combineShader(this, false, context);
};
/**
 * Create a single string containing the full, combined fragment shader with all dependencies and defines.
 *
 * @param {Context} context The current rendering context
 *
 * @returns {string} The combined shader string.
 */ ShaderSource.prototype.createCombinedFragmentShader = function(context) {
    return combineShader(this, true, context);
};
/**
 * For ShaderProgram testing
 * @private
 */ ShaderSource._czmBuiltinsAndUniforms = {};
// combine automatic uniforms and Cesium built-ins
for(const builtinName in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Shaders$2f$Builtin$2f$CzmBuiltins$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]){
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Shaders$2f$Builtin$2f$CzmBuiltins$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hasOwnProperty(builtinName)) {
        ShaderSource._czmBuiltinsAndUniforms[builtinName] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Shaders$2f$Builtin$2f$CzmBuiltins$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][builtinName];
    }
}
for(const uniformName in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$AutomaticUniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]){
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$AutomaticUniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].hasOwnProperty(uniformName)) {
        const uniform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$AutomaticUniforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][uniformName];
        if (typeof uniform.getDeclaration === "function") {
            ShaderSource._czmBuiltinsAndUniforms[uniformName] = uniform.getDeclaration(uniformName);
        }
    }
}
ShaderSource.createPickVertexShaderSource = function(vertexShaderSource) {
    const renamedVS = ShaderSource.replaceMain(vertexShaderSource, "czm_old_main");
    const pickMain = "in vec4 pickColor; \n" + "out vec4 czm_pickColor; \n" + "void main() \n" + "{ \n" + "    czm_old_main(); \n" + "    czm_pickColor = pickColor; \n" + "}";
    return `${renamedVS}\n${pickMain}`;
};
ShaderSource.createPickFragmentShaderSource = function(fragmentShaderSource, pickColorQualifier) {
    const renamedFS = ShaderSource.replaceMain(fragmentShaderSource, "czm_old_main");
    const pickMain = `${pickColorQualifier} vec4 czm_pickColor; \n` + `void main() \n` + `{ \n` + `    czm_old_main(); \n` + `    if (out_FragColor.a == 0.0) { \n` + `       discard; \n` + `    } \n` + `    out_FragColor = czm_pickColor; \n` + `}`;
    return `${renamedFS}\n${pickMain}`;
};
function containsDefine(shaderSource, define) {
    const defines = shaderSource.defines;
    const definesLength = defines.length;
    for(let i = 0; i < definesLength; ++i){
        if (defines[i] === define) {
            return true;
        }
    }
    return false;
}
function containsString(shaderSource, string) {
    const sources = shaderSource.sources;
    const sourcesLength = sources.length;
    for(let i = 0; i < sourcesLength; ++i){
        if (sources[i].indexOf(string) !== -1) {
            return true;
        }
    }
    return false;
}
function findFirstString(shaderSource, strings) {
    const stringsLength = strings.length;
    for(let i = 0; i < stringsLength; ++i){
        const string = strings[i];
        if (containsString(shaderSource, string)) {
            return string;
        }
    }
    return undefined;
}
const normalVaryingNames = [
    "v_normalEC",
    "v_normal"
];
ShaderSource.findNormalVarying = function(shaderSource) {
    // Fix for Model: the shader text always has the word v_normalEC
    // wrapped in an #ifdef so instead of looking for v_normalEC look for the define
    if (containsString(shaderSource, "#ifdef HAS_NORMALS")) {
        if (containsDefine(shaderSource, "HAS_NORMALS")) {
            return "v_normalEC";
        }
        return undefined;
    }
    return findFirstString(shaderSource, normalVaryingNames);
};
const positionVaryingNames = [
    "v_positionEC"
];
ShaderSource.findPositionVarying = function(shaderSource) {
    return findFirstString(shaderSource, positionVaryingNames);
};
const __TURBOPACK__default__export__ = ShaderSource;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/PixelDatatype.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/WebGLConstants.js [app-client] (ecmascript)");
;
/**
 * The data type of a pixel.
 *
 * @enum {number}
 * @see PostProcessStage
 */ const PixelDatatype = {
    UNSIGNED_BYTE: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_BYTE,
    UNSIGNED_SHORT: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_SHORT,
    UNSIGNED_INT: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_INT,
    FLOAT: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
    HALF_FLOAT: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT_OES,
    UNSIGNED_INT_24_8: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_INT_24_8,
    UNSIGNED_SHORT_4_4_4_4: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_SHORT_4_4_4_4,
    UNSIGNED_SHORT_5_5_5_1: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_SHORT_5_5_5_1,
    UNSIGNED_SHORT_5_6_5: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_SHORT_5_6_5
};
/**
  @private
*/ PixelDatatype.toWebGLConstant = function(pixelDatatype, context) {
    switch(pixelDatatype){
        case PixelDatatype.UNSIGNED_BYTE:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_BYTE;
        case PixelDatatype.UNSIGNED_SHORT:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_SHORT;
        case PixelDatatype.UNSIGNED_INT:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_INT;
        case PixelDatatype.FLOAT:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT;
        case PixelDatatype.HALF_FLOAT:
            return context.webgl2 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT_OES;
        case PixelDatatype.UNSIGNED_INT_24_8:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_INT_24_8;
        case PixelDatatype.UNSIGNED_SHORT_4_4_4_4:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_SHORT_4_4_4_4;
        case PixelDatatype.UNSIGNED_SHORT_5_5_5_1:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_SHORT_5_5_5_1;
        case PixelDatatype.UNSIGNED_SHORT_5_6_5:
            return PixelDatatype.UNSIGNED_SHORT_5_6_5;
    }
};
/**
  @private
*/ PixelDatatype.isPacked = function(pixelDatatype) {
    return pixelDatatype === PixelDatatype.UNSIGNED_INT_24_8 || pixelDatatype === PixelDatatype.UNSIGNED_SHORT_4_4_4_4 || pixelDatatype === PixelDatatype.UNSIGNED_SHORT_5_5_5_1 || pixelDatatype === PixelDatatype.UNSIGNED_SHORT_5_6_5;
};
/**
  @private
*/ PixelDatatype.sizeInBytes = function(pixelDatatype) {
    switch(pixelDatatype){
        case PixelDatatype.UNSIGNED_BYTE:
            return 1;
        case PixelDatatype.UNSIGNED_SHORT:
        case PixelDatatype.UNSIGNED_SHORT_4_4_4_4:
        case PixelDatatype.UNSIGNED_SHORT_5_5_5_1:
        case PixelDatatype.UNSIGNED_SHORT_5_6_5:
        case PixelDatatype.HALF_FLOAT:
            return 2;
        case PixelDatatype.UNSIGNED_INT:
        case PixelDatatype.FLOAT:
        case PixelDatatype.UNSIGNED_INT_24_8:
            return 4;
    }
};
/**
  @private
*/ PixelDatatype.validate = function(pixelDatatype) {
    return pixelDatatype === PixelDatatype.UNSIGNED_BYTE || pixelDatatype === PixelDatatype.UNSIGNED_SHORT || pixelDatatype === PixelDatatype.UNSIGNED_INT || pixelDatatype === PixelDatatype.FLOAT || pixelDatatype === PixelDatatype.HALF_FLOAT || pixelDatatype === PixelDatatype.UNSIGNED_INT_24_8 || pixelDatatype === PixelDatatype.UNSIGNED_SHORT_4_4_4_4 || pixelDatatype === PixelDatatype.UNSIGNED_SHORT_5_5_5_1 || pixelDatatype === PixelDatatype.UNSIGNED_SHORT_5_6_5;
};
/**
 * Determine which TypedArray class should be used for a given PixelDatatype.
 *
 * @param {PixelDatatype} pixelDatatype The pixel datatype.
 * @returns {function} The constructor for the appropriate TypedArray class.
 *
 * @private
 */ PixelDatatype.getTypedArrayConstructor = function(pixelDatatype) {
    const sizeInBytes = PixelDatatype.sizeInBytes(pixelDatatype);
    if (sizeInBytes === Uint8Array.BYTES_PER_ELEMENT) {
        return Uint8Array;
    } else if (sizeInBytes === Uint16Array.BYTES_PER_ELEMENT) {
        return Uint16Array;
    } else if (sizeInBytes === Float32Array.BYTES_PER_ELEMENT && pixelDatatype === PixelDatatype.FLOAT) {
        return Float32Array;
    }
    return Uint32Array;
};
const __TURBOPACK__default__export__ = Object.freeze(PixelDatatype);
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/BufferUsage.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/WebGLConstants.js [app-client] (ecmascript)");
;
/**
 * @private
 */ const BufferUsage = {
    STREAM_DRAW: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].STREAM_DRAW,
    STATIC_DRAW: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].STATIC_DRAW,
    DYNAMIC_DRAW: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DYNAMIC_DRAW,
    DYNAMIC_READ: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DYNAMIC_READ,
    validate: function(bufferUsage) {
        return bufferUsage === BufferUsage.STREAM_DRAW || bufferUsage === BufferUsage.STATIC_DRAW || bufferUsage === BufferUsage.DYNAMIC_DRAW || bufferUsage === BufferUsage.DYNAMIC_READ;
    }
};
const __TURBOPACK__default__export__ = Object.freeze(BufferUsage);
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/CubeMapFace.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/PixelFormat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/PixelDatatype.js [app-client] (ecmascript)");
;
;
;
;
;
/**
 * @private
 */ function CubeMapFace(context, texture, textureTarget, targetFace, internalFormat, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY, initialized) {
    this._context = context;
    this._texture = texture;
    this._textureTarget = textureTarget;
    this._targetFace = targetFace;
    this._pixelDatatype = pixelDatatype;
    this._internalFormat = internalFormat;
    this._pixelFormat = pixelFormat;
    this._size = size;
    this._preMultiplyAlpha = preMultiplyAlpha;
    this._flipY = flipY;
    this._initialized = initialized;
}
Object.defineProperties(CubeMapFace.prototype, {
    pixelFormat: {
        get: function() {
            return this._pixelFormat;
        }
    },
    pixelDatatype: {
        get: function() {
            return this._pixelDatatype;
        }
    },
    _target: {
        get: function() {
            return this._targetFace;
        }
    }
});
/**
 * Copies texels from the source to the cubemap's face.
 * @param {object} options Object with the following properties:
 * @param {object} options.source The source {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement}, {@link HTMLVideoElement},
 *                              or an object with a width, height, and arrayBufferView properties.
 * @param {number} [options.xOffset=0] An offset in the x direction in the cubemap where copying begins.
 * @param {number} [options.yOffset=0] An offset in the y direction in the cubemap where copying begins.
 * @param {boolean} [options.skipColorSpaceConversion=false] If true, any custom gamma or color profiles in the texture will be ignored.
 * @exception {DeveloperError} xOffset must be greater than or equal to zero.
 * @exception {DeveloperError} yOffset must be greater than or equal to zero.
 * @exception {DeveloperError} xOffset + source.width must be less than or equal to width.
 * @exception {DeveloperError} yOffset + source.height must be less than or equal to height.
 * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
 *
 * @example
 * // Create a cubemap with 1x1 faces, and make the +x face red.
 * const cubeMap = new CubeMap({
 *   context : context
 *   width : 1,
 *   height : 1
 * });
 * cubeMap.positiveX.copyFrom({
 *   source: {
 *     width : 1,
 *     height : 1,
 *     arrayBufferView : new Uint8Array([255, 0, 0, 255])
 *   }
 * });
 */ CubeMapFace.prototype.copyFrom = function(options) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options", options);
    //>>includeEnd('debug');
    const { xOffset = 0, yOffset = 0, source, skipColorSpaceConversion = false } = options;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.source", source);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
    if (xOffset + source.width > this._size) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("xOffset + options.source.width must be less than or equal to width.");
    }
    if (yOffset + source.height > this._size) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("yOffset + options.source.height must be less than or equal to height.");
    }
    //>>includeEnd('debug');
    const { width, height } = source;
    const gl = this._context._gl;
    const target = this._textureTarget;
    const targetFace = this._targetFace;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(target, this._texture);
    let arrayBufferView = source.arrayBufferView;
    const size = this._size;
    const pixelFormat = this._pixelFormat;
    const internalFormat = this._internalFormat;
    const pixelDatatype = this._pixelDatatype;
    const preMultiplyAlpha = this._preMultiplyAlpha;
    const flipY = this._flipY;
    let unpackAlignment = 4;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(arrayBufferView)) {
        unpackAlignment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].alignmentInBytes(pixelFormat, pixelDatatype, width);
    }
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
    if (skipColorSpaceConversion) {
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    } else {
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.BROWSER_DEFAULT_WEBGL);
    }
    let uploaded = false;
    if (!this._initialized) {
        let pixels;
        if (xOffset === 0 && yOffset === 0 && width === size && height === size) {
            // initialize the entire texture
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(arrayBufferView)) {
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
                if (flipY) {
                    arrayBufferView = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].flipY(arrayBufferView, pixelFormat, pixelDatatype, size, size);
                }
                pixels = arrayBufferView;
            } else {
                // Only valid for DOM-Element uploads
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
                pixels = source;
            }
            uploaded = true;
        } else {
            // initialize the entire texture to zero
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            pixels = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createTypedArray(pixelFormat, pixelDatatype, size, size);
        }
        gl.texImage2D(targetFace, 0, internalFormat, size, size, 0, pixelFormat, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toWebGLConstant(pixelDatatype, this._context), pixels);
        this._initialized = true;
    }
    if (!uploaded) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(arrayBufferView)) {
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            if (flipY) {
                arrayBufferView = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].flipY(arrayBufferView, pixelFormat, pixelDatatype, width, height);
            }
            gl.texSubImage2D(targetFace, 0, xOffset, yOffset, width, height, pixelFormat, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toWebGLConstant(pixelDatatype, this._context), arrayBufferView);
        } else {
            // Only valid for DOM-Element uploads
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
            // Source: ImageData, HTMLImageElement, HTMLCanvasElement, or HTMLVideoElement
            gl.texSubImage2D(targetFace, 0, xOffset, yOffset, pixelFormat, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toWebGLConstant(pixelDatatype, this._context), source);
        }
    }
    gl.bindTexture(target, null);
};
/**
 * Copies texels from the framebuffer to the cubemap's face.
 * @param {number} [xOffset=0] An offset in the x direction in the cubemap where copying begins.
 * @param {number} [yOffset=0] An offset in the y direction in the cubemap where copying begins.
 * @param {number} [framebufferXOffset=0] An offset in the x direction in the framebuffer where copying begins from.
 * @param {number} [framebufferYOffset=0] An offset in the y direction in the framebuffer where copying begins from.
 * @param {number} [width=CubeMap's width] The width of the subimage to copy.
 * @param {number} [height=CubeMap's height] The height of the subimage to copy.
 * @throws {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.
 * @throws {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.
 * @throws {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
 * @throws {DeveloperError} xOffset must be greater than or equal to zero.
 * @throws {DeveloperError} yOffset must be greater than or equal to zero.
 * @throws {DeveloperError} framebufferXOffset must be greater than or equal to zero.
 * @throws {DeveloperError} framebufferYOffset must be greater than or equal to zero.
 * @throws {DeveloperError} xOffset + source.width must be less than or equal to width.
 * @throws {DeveloperError} yOffset + source.height must be less than or equal to height.
 * @throws {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
 * @example
 * // Copy the framebuffer contents to the +x cube map face.
 * cubeMap.positiveX.copyFromFramebuffer();
 */ CubeMapFace.prototype.copyFromFramebuffer = function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
    xOffset = xOffset ?? 0;
    yOffset = yOffset ?? 0;
    framebufferXOffset = framebufferXOffset ?? 0;
    framebufferYOffset = framebufferYOffset ?? 0;
    width = width ?? this._size;
    height = height ?? this._size;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("framebufferXOffset", framebufferXOffset, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("framebufferYOffset", framebufferYOffset, 0);
    if (xOffset + width > this._size) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("xOffset + source.width must be less than or equal to width.");
    }
    if (yOffset + height > this._size) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("yOffset + source.height must be less than or equal to height.");
    }
    if (this._pixelDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.");
    }
    if (this._pixelDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.");
    }
    //>>includeEnd('debug');
    const gl = this._context._gl;
    const target = this._textureTarget;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(target, this._texture);
    gl.copyTexSubImage2D(this._targetFace, 0, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
    gl.bindTexture(target, null);
    this._initialized = true;
};
/**
 * Copies texels from the framebuffer to the cubemap's face mipmap.
 * @param {number} [xOffset=0] An offset in the x direction in the framebuffer where copying begins from.
 * @param {number} [yOffset=0] An offset in the y direction in the framebuffer where copying begins from.
 * @param {number} [width=CubeMap's width] The width of the subimage to copy.
 * @param {number} [height=CubeMap's height] The height of the subimage to copy.
 * @param {number} [level=0] The level of detail. Level 0 is the base image level and level n is the n-th mipmap reduction level.
 * @throws {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.
 * @throws {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.
 * @throws {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
 * @throws {DeveloperError} xOffset must be greater than or equal to zero.
 * @throws {DeveloperError} yOffset must be greater than or equal to zero.
 * @throws {DeveloperError} framebufferXOffset must be greater than or equal to zero.
 * @throws {DeveloperError} framebufferYOffset must be greater than or equal to zero.
 * @throws {DeveloperError} xOffset + source.width must be less than or equal to width.
 * @throws {DeveloperError} yOffset + source.height must be less than or equal to height.
 * @throws {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
 *
 * @example
 * // Copy the framebuffer contents to the +x cube map face.
 * cubeMap.positiveX.copyFromFramebuffer();
 */ CubeMapFace.prototype.copyMipmapFromFramebuffer = function(xOffset, yOffset, width, height, level) {
    xOffset = xOffset ?? 0;
    yOffset = yOffset ?? 0;
    width = width ?? this._size;
    height = height ?? this._size;
    level = level ?? 0;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
    if (xOffset + width > this._size) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("xOffset + source.width must be less than or equal to width.");
    }
    if (yOffset + height > this._size) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("yOffset + source.height must be less than or equal to height.");
    }
    if (this._pixelDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.");
    }
    if (this._pixelDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.");
    }
    //>>includeEnd('debug');
    const gl = this._context._gl;
    const target = this._textureTarget;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(target, this._texture);
    gl.copyTexImage2D(this._targetFace, level, this._internalFormat, xOffset, yOffset, width, height, 0);
    gl.bindTexture(target, null);
    this._initialized = true;
};
const __TURBOPACK__default__export__ = CubeMapFace;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/Framebuffer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/destroyObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/PixelFormat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ContextLimits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/PixelDatatype.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
function attachTexture(framebuffer, attachment, texture) {
    const gl = framebuffer._gl;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, texture._target, texture._texture, 0);
}
function attachRenderbuffer(framebuffer, attachment, renderbuffer) {
    const gl = framebuffer._gl;
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, renderbuffer._getRenderbuffer());
}
/**
 * Creates a framebuffer with optional initial color, depth, and stencil attachments.
 * Framebuffers are used for render-to-texture effects; they allow us to render to
 * textures in one pass, and read from it in a later pass.
 *
 * @param {object} options Object with the following properties:
 * @param {Context} options.context
 * @param {Texture[]} [options.colorTextures]
 * @param {Renderbuffer[]} [options.colorRenderbuffers]
 * @param {Texture} [options.depthTexture]
 * @param {Renderbuffer} [options.depthRenderbuffer]
 * @param {Renderbuffer} [options.stencilRenderbuffer]
 * @param {Texture} [options.depthStencilTexture]
 * @param {Renderbuffer} [options.depthStencilRenderbuffer]
 * @param {boolean} [options.destroyAttachments=true] When true, the framebuffer owns its attachments so they will be destroyed when {@link Framebuffer#destroy} is called or when a new attachment is assigned to an attachment point.
 *
 * @exception {DeveloperError} Cannot have both color texture and color renderbuffer attachments.
 * @exception {DeveloperError} Cannot have both a depth texture and depth renderbuffer attachment.
 * @exception {DeveloperError} Cannot have both a depth-stencil texture and depth-stencil renderbuffer attachment.
 * @exception {DeveloperError} Cannot have both a depth and depth-stencil renderbuffer.
 * @exception {DeveloperError} Cannot have both a stencil and depth-stencil renderbuffer.
 * @exception {DeveloperError} Cannot have both a depth and stencil renderbuffer.
 * @exception {DeveloperError} The color-texture pixel-format must be a color format.
 * @exception {DeveloperError} The depth-texture pixel-format must be DEPTH_COMPONENT.
 * @exception {DeveloperError} The depth-stencil-texture pixel-format must be DEPTH_STENCIL.
 * @exception {DeveloperError} The number of color attachments exceeds the number supported.
 * @exception {DeveloperError} The color-texture pixel datatype is HALF_FLOAT and the WebGL implementation does not support the EXT_color_buffer_half_float extension.
 * @exception {DeveloperError} The color-texture pixel datatype is FLOAT and the WebGL implementation does not support the EXT_color_buffer_float or WEBGL_color_buffer_float extensions.
 *
 * @example
 * // Create a framebuffer with color and depth texture attachments.
 * const width = context.canvas.clientWidth;
 * const height = context.canvas.clientHeight;
 * const framebuffer = new Framebuffer({
 *   context : context,
 *   colorTextures : [new Texture({
 *     context : context,
 *     width : width,
 *     height : height,
 *     pixelFormat : PixelFormat.RGBA
 *   })],
 *   depthTexture : new Texture({
 *     context : context,
 *     width : width,
 *     height : height,
 *     pixelFormat : PixelFormat.DEPTH_COMPONENT,
 *     pixelDatatype : PixelDatatype.UNSIGNED_SHORT
 *   })
 * });
 *
 * @private
 * @constructor
 */ function Framebuffer(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const context = options.context;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.context", context);
    //>>includeEnd('debug');
    const gl = context._gl;
    const maximumColorAttachments = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].maximumColorAttachments;
    this._gl = gl;
    this._framebuffer = gl.createFramebuffer();
    this._colorTextures = [];
    this._colorRenderbuffers = [];
    this._activeColorAttachments = [];
    this._depthTexture = undefined;
    this._depthRenderbuffer = undefined;
    this._stencilRenderbuffer = undefined;
    this._depthStencilTexture = undefined;
    this._depthStencilRenderbuffer = undefined;
    /**
   * When true, the framebuffer owns its attachments so they will be destroyed when
   * {@link Framebuffer#destroy} is called or when a new attachment is assigned
   * to an attachment point.
   *
   * @type {boolean}
   * @default true
   *
   * @see Framebuffer#destroy
   */ this.destroyAttachments = options.destroyAttachments ?? true;
    // Throw if a texture and renderbuffer are attached to the same point.  This won't
    // cause a WebGL error (because only one will be attached), but is likely a developer error.
    //>>includeStart('debug', pragmas.debug);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.colorTextures) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.colorRenderbuffers)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot have both color texture and color renderbuffer attachments.");
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.depthTexture) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.depthRenderbuffer)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot have both a depth texture and depth renderbuffer attachment.");
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.depthStencilTexture) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.depthStencilRenderbuffer)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot have both a depth-stencil texture and depth-stencil renderbuffer attachment.");
    }
    // Avoid errors defined in Section 6.5 of the WebGL spec
    const depthAttachment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.depthTexture) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.depthRenderbuffer);
    const depthStencilAttachment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.depthStencilTexture) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.depthStencilRenderbuffer);
    if (depthAttachment && depthStencilAttachment) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot have both a depth and depth-stencil attachment.");
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.stencilRenderbuffer) && depthStencilAttachment) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot have both a stencil and depth-stencil attachment.");
    }
    if (depthAttachment && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.stencilRenderbuffer)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot have both a depth and stencil attachment.");
    }
    //>>includeEnd('debug');
    this._bind();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.colorTextures)) {
        const textures = options.colorTextures;
        const length = this._colorTextures.length = this._activeColorAttachments.length = textures.length;
        //>>includeStart('debug', pragmas.debug);
        if (length > maximumColorAttachments) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("The number of color attachments exceeds the number supported.");
        }
        //>>includeEnd('debug');
        for(let i = 0; i < length; ++i){
            const texture = textures[i];
            //>>includeStart('debug', pragmas.debug);
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isColorFormat(texture.pixelFormat)) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("The color-texture pixel-format must be a color format.");
            }
            if (texture.pixelDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT && !context.colorBufferFloat) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("The color texture pixel datatype is FLOAT and the WebGL implementation does not support the EXT_color_buffer_float or WEBGL_color_buffer_float extensions. See Context.colorBufferFloat.");
            }
            if (texture.pixelDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT && !context.colorBufferHalfFloat) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("The color texture pixel datatype is HALF_FLOAT and the WebGL implementation does not support the EXT_color_buffer_half_float extension. See Context.colorBufferHalfFloat.");
            }
            //>>includeEnd('debug');
            const attachmentEnum = this._gl.COLOR_ATTACHMENT0 + i;
            attachTexture(this, attachmentEnum, texture);
            this._activeColorAttachments[i] = attachmentEnum;
            this._colorTextures[i] = texture;
        }
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.colorRenderbuffers)) {
        const renderbuffers = options.colorRenderbuffers;
        const length = this._colorRenderbuffers.length = this._activeColorAttachments.length = renderbuffers.length;
        //>>includeStart('debug', pragmas.debug);
        if (length > maximumColorAttachments) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("The number of color attachments exceeds the number supported.");
        }
        //>>includeEnd('debug');
        for(let i = 0; i < length; ++i){
            const renderbuffer = renderbuffers[i];
            const attachmentEnum = this._gl.COLOR_ATTACHMENT0 + i;
            attachRenderbuffer(this, attachmentEnum, renderbuffer);
            this._activeColorAttachments[i] = attachmentEnum;
            this._colorRenderbuffers[i] = renderbuffer;
        }
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.depthTexture)) {
        const texture = options.depthTexture;
        //>>includeStart('debug', pragmas.debug);
        if (texture.pixelFormat !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DEPTH_COMPONENT) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("The depth-texture pixel-format must be DEPTH_COMPONENT.");
        }
        //>>includeEnd('debug');
        attachTexture(this, this._gl.DEPTH_ATTACHMENT, texture);
        this._depthTexture = texture;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.depthRenderbuffer)) {
        const renderbuffer = options.depthRenderbuffer;
        attachRenderbuffer(this, this._gl.DEPTH_ATTACHMENT, renderbuffer);
        this._depthRenderbuffer = renderbuffer;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.stencilRenderbuffer)) {
        const renderbuffer = options.stencilRenderbuffer;
        attachRenderbuffer(this, this._gl.STENCIL_ATTACHMENT, renderbuffer);
        this._stencilRenderbuffer = renderbuffer;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.depthStencilTexture)) {
        const texture = options.depthStencilTexture;
        //>>includeStart('debug', pragmas.debug);
        if (texture.pixelFormat !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DEPTH_STENCIL) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("The depth-stencil pixel-format must be DEPTH_STENCIL.");
        }
        //>>includeEnd('debug');
        attachTexture(this, this._gl.DEPTH_STENCIL_ATTACHMENT, texture);
        this._depthStencilTexture = texture;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.depthStencilRenderbuffer)) {
        const renderbuffer = options.depthStencilRenderbuffer;
        attachRenderbuffer(this, this._gl.DEPTH_STENCIL_ATTACHMENT, renderbuffer);
        this._depthStencilRenderbuffer = renderbuffer;
    }
    this._unBind();
}
Object.defineProperties(Framebuffer.prototype, {
    /**
   * The status of the framebuffer. If the status is not WebGLConstants.FRAMEBUFFER_COMPLETE,
   * a {@link DeveloperError} will be thrown when attempting to render to the framebuffer.
   * @memberof Framebuffer.prototype
   * @type {number}
   */ status: {
        get: function() {
            this._bind();
            const status = this._gl.checkFramebufferStatus(this._gl.FRAMEBUFFER);
            this._unBind();
            return status;
        }
    },
    numberOfColorAttachments: {
        get: function() {
            return this._activeColorAttachments.length;
        }
    },
    depthTexture: {
        get: function() {
            return this._depthTexture;
        }
    },
    depthRenderbuffer: {
        get: function() {
            return this._depthRenderbuffer;
        }
    },
    stencilRenderbuffer: {
        get: function() {
            return this._stencilRenderbuffer;
        }
    },
    depthStencilTexture: {
        get: function() {
            return this._depthStencilTexture;
        }
    },
    depthStencilRenderbuffer: {
        get: function() {
            return this._depthStencilRenderbuffer;
        }
    },
    /**
   * True if the framebuffer has a depth attachment.  Depth attachments include
   * depth and depth-stencil textures, and depth and depth-stencil renderbuffers.  When
   * rendering to a framebuffer, a depth attachment is required for the depth test to have effect.
   * @memberof Framebuffer.prototype
   * @type {boolean}
   */ hasDepthAttachment: {
        get: function() {
            return !!(this.depthTexture || this.depthRenderbuffer || this.depthStencilTexture || this.depthStencilRenderbuffer);
        }
    }
});
Framebuffer.prototype._bind = function() {
    const gl = this._gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
};
Framebuffer.prototype._unBind = function() {
    const gl = this._gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};
Framebuffer.prototype.bindDraw = function() {
    const gl = this._gl;
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._framebuffer);
};
Framebuffer.prototype.bindRead = function() {
    const gl = this._gl;
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._framebuffer);
};
Framebuffer.prototype._getActiveColorAttachments = function() {
    return this._activeColorAttachments;
};
Framebuffer.prototype.getColorTexture = function(index) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(index) || index < 0 || index >= this._colorTextures.length) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("index is required, must be greater than or equal to zero and must be less than the number of color attachments.");
    }
    //>>includeEnd('debug');
    return this._colorTextures[index];
};
Framebuffer.prototype.getColorRenderbuffer = function(index) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(index) || index < 0 || index >= this._colorRenderbuffers.length) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("index is required, must be greater than or equal to zero and must be less than the number of color attachments.");
    }
    //>>includeEnd('debug');
    return this._colorRenderbuffers[index];
};
Framebuffer.prototype.isDestroyed = function() {
    return false;
};
Framebuffer.prototype.destroy = function() {
    if (this.destroyAttachments) {
        // If the color texture is a cube map face, it is owned by the cube map, and will not be destroyed.
        const textures = this._colorTextures;
        for(let i = 0; i < textures.length; ++i){
            const texture = textures[i];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(texture)) {
                texture.destroy();
            }
        }
        const renderbuffers = this._colorRenderbuffers;
        for(let i = 0; i < renderbuffers.length; ++i){
            const renderbuffer = renderbuffers[i];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(renderbuffer)) {
                renderbuffer.destroy();
            }
        }
        this._depthTexture = this._depthTexture && this._depthTexture.destroy();
        this._depthRenderbuffer = this._depthRenderbuffer && this._depthRenderbuffer.destroy();
        this._stencilRenderbuffer = this._stencilRenderbuffer && this._stencilRenderbuffer.destroy();
        this._depthStencilTexture = this._depthStencilTexture && this._depthStencilTexture.destroy();
        this._depthStencilRenderbuffer = this._depthStencilRenderbuffer && this._depthStencilRenderbuffer.destroy();
    }
    this._gl.deleteFramebuffer(this._framebuffer);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
};
const __TURBOPACK__default__export__ = Framebuffer;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/MipmapHint.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/WebGLConstants.js [app-client] (ecmascript)");
;
/**
 * @private
 */ const MipmapHint = {
    DONT_CARE: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DONT_CARE,
    FASTEST: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FASTEST,
    NICEST: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NICEST,
    validate: function(mipmapHint) {
        return mipmapHint === MipmapHint.DONT_CARE || mipmapHint === MipmapHint.FASTEST || mipmapHint === MipmapHint.NICEST;
    }
};
const __TURBOPACK__default__export__ = Object.freeze(MipmapHint);
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/TextureMagnificationFilter.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/WebGLConstants.js [app-client] (ecmascript)");
;
/**
 * Enumerates all possible filters used when magnifying WebGL textures.
 *
 * @enum {number}
 *
 * @see TextureMinificationFilter
 */ const TextureMagnificationFilter = {
    /**
   * Samples the texture by returning the closest pixel.
   *
   * @type {number}
   * @constant
   */ NEAREST: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST,
    /**
   * Samples the texture through bi-linear interpolation of the four nearest pixels. This produces smoother results than <code>NEAREST</code> filtering.
   *
   * @type {number}
   * @constant
   */ LINEAR: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LINEAR
};
/**
 * Validates the given <code>textureMinificationFilter</code> with respect to the possible enum values.
 * @param textureMagnificationFilter
 * @returns {boolean} <code>true</code> if <code>textureMagnificationFilter</code> is valid.
 *
 * @private
 */ TextureMagnificationFilter.validate = function(textureMagnificationFilter) {
    return textureMagnificationFilter === TextureMagnificationFilter.NEAREST || textureMagnificationFilter === TextureMagnificationFilter.LINEAR;
};
const __TURBOPACK__default__export__ = Object.freeze(TextureMagnificationFilter);
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/TextureMinificationFilter.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/WebGLConstants.js [app-client] (ecmascript)");
;
/**
 * Enumerates all possible filters used when minifying WebGL textures.
 *
 * @enum {number}
 *
 * @see TextureMagnificationFilter
 */ const TextureMinificationFilter = {
    /**
   * Samples the texture by returning the closest pixel.
   *
   * @type {number}
   * @constant
   */ NEAREST: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST,
    /**
   * Samples the texture through bi-linear interpolation of the four nearest pixels. This produces smoother results than <code>NEAREST</code> filtering.
   *
   * @type {number}
   * @constant
   */ LINEAR: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LINEAR,
    /**
   * Selects the nearest mip level and applies nearest sampling within that level.
   * <p>
   * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
   * </p>
   *
   * @type {number}
   * @constant
   */ NEAREST_MIPMAP_NEAREST: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST_MIPMAP_NEAREST,
    /**
   * Selects the nearest mip level and applies linear sampling within that level.
   * <p>
   * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
   * </p>
   *
   * @type {number}
   * @constant
   */ LINEAR_MIPMAP_NEAREST: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LINEAR_MIPMAP_NEAREST,
    /**
   * Read texture values with nearest sampling from two adjacent mip levels and linearly interpolate the results.
   * <p>
   * This option provides a good balance of visual quality and speed when sampling from a mipmapped texture.
   * </p>
   * <p>
   * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
   * </p>
   *
   * @type {number}
   * @constant
   */ NEAREST_MIPMAP_LINEAR: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST_MIPMAP_LINEAR,
    /**
   * Read texture values with linear sampling from two adjacent mip levels and linearly interpolate the results.
   * <p>
   * This option provides a good balance of visual quality and speed when sampling from a mipmapped texture.
   * </p>
   * <p>
   * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
   * </p>
   * @type {number}
   * @constant
   */ LINEAR_MIPMAP_LINEAR: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LINEAR_MIPMAP_LINEAR
};
/**
 * Validates the given <code>textureMinificationFilter</code> with respect to the possible enum values.
 *
 * @private
 *
 * @param textureMinificationFilter
 * @returns {boolean} <code>true</code> if <code>textureMinificationFilter</code> is valid.
 */ TextureMinificationFilter.validate = function(textureMinificationFilter) {
    return textureMinificationFilter === TextureMinificationFilter.NEAREST || textureMinificationFilter === TextureMinificationFilter.LINEAR || textureMinificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST || textureMinificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST || textureMinificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR || textureMinificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;
};
const __TURBOPACK__default__export__ = Object.freeze(TextureMinificationFilter);
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/TextureWrap.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/WebGLConstants.js [app-client] (ecmascript)");
;
/**
 * @private
 */ const TextureWrap = {
    CLAMP_TO_EDGE: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CLAMP_TO_EDGE,
    REPEAT: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].REPEAT,
    MIRRORED_REPEAT: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MIRRORED_REPEAT,
    validate: function(textureWrap) {
        return textureWrap === TextureWrap.CLAMP_TO_EDGE || textureWrap === TextureWrap.REPEAT || textureWrap === TextureWrap.MIRRORED_REPEAT;
    }
};
const __TURBOPACK__default__export__ = Object.freeze(TextureWrap);
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/Sampler.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMagnificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/TextureMagnificationFilter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/TextureMinificationFilter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureWrap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/TextureWrap.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
/**
 * @private
 */ function Sampler(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const { wrapR = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureWrap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CLAMP_TO_EDGE, wrapS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureWrap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CLAMP_TO_EDGE, wrapT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureWrap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CLAMP_TO_EDGE, minificationFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LINEAR, magnificationFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMagnificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LINEAR, maximumAnisotropy = 1.0 } = options;
    //>>includeStart('debug', pragmas.debug);
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureWrap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(wrapR)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid sampler.wrapR.");
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureWrap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(wrapS)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid sampler.wrapS.");
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureWrap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(wrapT)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid sampler.wrapT.");
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(minificationFilter)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid sampler.minificationFilter.");
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMagnificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(magnificationFilter)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid sampler.magnificationFilter.");
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("maximumAnisotropy", maximumAnisotropy, 1.0);
    //>>includeEnd('debug');
    this._wrapR = wrapR;
    this._wrapS = wrapS;
    this._wrapT = wrapT;
    this._minificationFilter = minificationFilter;
    this._magnificationFilter = magnificationFilter;
    this._maximumAnisotropy = maximumAnisotropy;
}
Object.defineProperties(Sampler.prototype, {
    wrapR: {
        get: function() {
            return this._wrapR;
        }
    },
    wrapS: {
        get: function() {
            return this._wrapS;
        }
    },
    wrapT: {
        get: function() {
            return this._wrapT;
        }
    },
    minificationFilter: {
        get: function() {
            return this._minificationFilter;
        }
    },
    magnificationFilter: {
        get: function() {
            return this._magnificationFilter;
        }
    },
    maximumAnisotropy: {
        get: function() {
            return this._maximumAnisotropy;
        }
    }
});
Sampler.equals = function(left, right) {
    return left === right || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(left) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(right) && left._wrapR === right._wrapR && left._wrapS === right._wrapS && left._wrapT === right._wrapT && left._minificationFilter === right._minificationFilter && left._magnificationFilter === right._magnificationFilter && left._maximumAnisotropy === right._maximumAnisotropy;
};
Sampler.NEAREST = Object.freeze(new Sampler({
    wrapR: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureWrap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CLAMP_TO_EDGE,
    wrapS: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureWrap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CLAMP_TO_EDGE,
    wrapT: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureWrap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CLAMP_TO_EDGE,
    minificationFilter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST,
    magnificationFilter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMagnificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST
}));
const __TURBOPACK__default__export__ = Sampler;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/Buffer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$createGuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/createGuid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/destroyObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$IndexDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/IndexDatatype.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/WebGLConstants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$BufferUsage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/BufferUsage.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
/**
 * @private
 */ function Buffer(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.context", options.context);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.typedArray) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.sizeInBytes)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Either options.sizeInBytes or options.typedArray is required.");
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.typedArray) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.sizeInBytes)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot pass in both options.sizeInBytes and options.typedArray.");
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.typedArray)) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.object("options.typedArray", options.typedArray);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number("options.typedArray.byteLength", options.typedArray.byteLength);
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$BufferUsage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(options.usage)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("usage is invalid.");
    }
    //>>includeEnd('debug');
    const gl = options.context._gl;
    const bufferTarget = options.bufferTarget;
    const typedArray = options.typedArray;
    let sizeInBytes = options.sizeInBytes;
    const usage = options.usage;
    const hasArray = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(typedArray);
    if (hasArray) {
        sizeInBytes = typedArray.byteLength;
    }
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThan("sizeInBytes", sizeInBytes, 0);
    //>>includeEnd('debug');
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferTarget, buffer);
    gl.bufferData(bufferTarget, hasArray ? typedArray : sizeInBytes, usage);
    gl.bindBuffer(bufferTarget, null);
    this._id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$createGuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
    this._gl = gl;
    this._webgl2 = options.context._webgl2;
    this._bufferTarget = bufferTarget;
    this._sizeInBytes = sizeInBytes;
    this._usage = usage;
    this._buffer = buffer;
    this.vertexArrayDestroyable = true;
}
Buffer.createPixelBuffer = function(options) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.context", options.context);
    //>>includeEnd('debug');
    if (!options.context._webgl2) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("A WebGL 2 context is required to create PixelBuffers.");
    }
    return new Buffer({
        context: options.context,
        bufferTarget: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PIXEL_PACK_BUFFER,
        typedArray: options.typedArray,
        sizeInBytes: options.sizeInBytes,
        usage: options.usage
    });
};
/**
 * Creates a vertex buffer, which contains untyped vertex data in GPU-controlled memory.
 * <br /><br />
 * A vertex array defines the actual makeup of a vertex, e.g., positions, normals, texture coordinates,
 * etc., by interpreting the raw data in one or more vertex buffers.
 *
 * @param {object} options An object containing the following properties:
 * @param {Context} options.context The context in which to create the buffer
 * @param {ArrayBufferView} [options.typedArray] A typed array containing the data to copy to the buffer.
 * @param {number} [options.sizeInBytes] A <code>Number</code> defining the size of the buffer in bytes. Required if options.typedArray is not given.
 * @param {BufferUsage} options.usage Specifies the expected usage pattern of the buffer. On some GL implementations, this can significantly affect performance. See {@link BufferUsage}.
 * @returns {VertexBuffer} The vertex buffer, ready to be attached to a vertex array.
 *
 * @exception {DeveloperError} Must specify either <options.typedArray> or <options.sizeInBytes>, but not both.
 * @exception {DeveloperError} The buffer size must be greater than zero.
 * @exception {DeveloperError} Invalid <code>usage</code>.
 *
 *
 * @example
 * // Example 1. Create a dynamic vertex buffer 16 bytes in size.
 * const buffer = Buffer.createVertexBuffer({
 *     context : context,
 *     sizeInBytes : 16,
 *     usage : BufferUsage.DYNAMIC_DRAW
 * });
 *
 * @example
 * // Example 2. Create a dynamic vertex buffer from three floating-point values.
 * // The data copied to the vertex buffer is considered raw bytes until it is
 * // interpreted as vertices using a vertex array.
 * const positionBuffer = buffer.createVertexBuffer({
 *     context : context,
 *     typedArray : new Float32Array([0, 0, 0]),
 *     usage : BufferUsage.STATIC_DRAW
 * });
 *
 * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGenBuffer.xml|glGenBuffer}
 * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindBuffer.xml|glBindBuffer} with <code>ARRAY_BUFFER</code>
 * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBufferData.xml|glBufferData} with <code>ARRAY_BUFFER</code>
 */ Buffer.createVertexBuffer = function(options) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.context", options.context);
    //>>includeEnd('debug');
    return new Buffer({
        context: options.context,
        bufferTarget: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ARRAY_BUFFER,
        typedArray: options.typedArray,
        sizeInBytes: options.sizeInBytes,
        usage: options.usage
    });
};
/**
 * Creates an index buffer, which contains typed indices in GPU-controlled memory.
 * <br /><br />
 * An index buffer can be attached to a vertex array to select vertices for rendering.
 * <code>Context.draw</code> can render using the entire index buffer or a subset
 * of the index buffer defined by an offset and count.
 *
 * @param {object} options An object containing the following properties:
 * @param {Context} options.context The context in which to create the buffer
 * @param {ArrayBufferView} [options.typedArray] A typed array containing the data to copy to the buffer.
 * @param {number} [options.sizeInBytes] A <code>Number</code> defining the size of the buffer in bytes. Required if options.typedArray is not given.
 * @param {BufferUsage} options.usage Specifies the expected usage pattern of the buffer. On some GL implementations, this can significantly affect performance. See {@link BufferUsage}.
 * @param {IndexDatatype} options.indexDatatype The datatype of indices in the buffer.
 * @returns {IndexBuffer} The index buffer, ready to be attached to a vertex array.
 *
 * @exception {DeveloperError} Must specify either <options.typedArray> or <options.sizeInBytes>, but not both.
 * @exception {DeveloperError} IndexDatatype.UNSIGNED_INT requires OES_element_index_uint, which is not supported on this system. Check context.elementIndexUint.
 * @exception {DeveloperError} The size in bytes must be greater than zero.
 * @exception {DeveloperError} Invalid <code>usage</code>.
 * @exception {DeveloperError} Invalid <code>indexDatatype</code>.
 *
 *
 * @example
 * // Example 1. Create a stream index buffer of unsigned shorts that is
 * // 16 bytes in size.
 * const buffer = Buffer.createIndexBuffer({
 *     context : context,
 *     sizeInBytes : 16,
 *     usage : BufferUsage.STREAM_DRAW,
 *     indexDatatype : IndexDatatype.UNSIGNED_SHORT
 * });
 *
 * @example
 * // Example 2. Create a static index buffer containing three unsigned shorts.
 * const buffer = Buffer.createIndexBuffer({
 *     context : context,
 *     typedArray : new Uint16Array([0, 1, 2]),
 *     usage : BufferUsage.STATIC_DRAW,
 *     indexDatatype : IndexDatatype.UNSIGNED_SHORT
 * });
 *
 * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGenBuffer.xml|glGenBuffer}
 * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindBuffer.xml|glBindBuffer} with <code>ELEMENT_ARRAY_BUFFER</code>
 * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBufferData.xml|glBufferData} with <code>ELEMENT_ARRAY_BUFFER</code>
 */ Buffer.createIndexBuffer = function(options) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.context", options.context);
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$IndexDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(options.indexDatatype)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid indexDatatype.");
    }
    if (options.indexDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$IndexDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_INT && !options.context.elementIndexUint) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("IndexDatatype.UNSIGNED_INT requires OES_element_index_uint, which is not supported on this system.  Check context.elementIndexUint.");
    }
    //>>includeEnd('debug');
    const context = options.context;
    const indexDatatype = options.indexDatatype;
    const bytesPerIndex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$IndexDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getSizeInBytes(indexDatatype);
    const buffer = new Buffer({
        context: context,
        bufferTarget: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ELEMENT_ARRAY_BUFFER,
        typedArray: options.typedArray,
        sizeInBytes: options.sizeInBytes,
        usage: options.usage
    });
    const numberOfIndices = buffer.sizeInBytes / bytesPerIndex;
    Object.defineProperties(buffer, {
        indexDatatype: {
            get: function() {
                return indexDatatype;
            }
        },
        bytesPerIndex: {
            get: function() {
                return bytesPerIndex;
            }
        },
        numberOfIndices: {
            get: function() {
                return numberOfIndices;
            }
        }
    });
    return buffer;
};
Object.defineProperties(Buffer.prototype, {
    sizeInBytes: {
        get: function() {
            return this._sizeInBytes;
        }
    },
    usage: {
        get: function() {
            return this._usage;
        }
    }
});
Buffer.prototype._getBuffer = function() {
    return this._buffer;
};
Buffer.prototype._bind = function() {
    const gl = this._gl;
    const target = this._bufferTarget;
    gl.bindBuffer(target, this._buffer);
};
Buffer.prototype._unBind = function() {
    const gl = this._gl;
    const target = this._bufferTarget;
    gl.bindBuffer(target, null);
};
Buffer.prototype.copyFromArrayView = function(arrayView, offsetInBytes) {
    offsetInBytes = offsetInBytes ?? 0;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("arrayView", arrayView);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.lessThanOrEquals("offsetInBytes + arrayView.byteLength", offsetInBytes + arrayView.byteLength, this._sizeInBytes);
    //>>includeEnd('debug');
    const gl = this._gl;
    const target = this._bufferTarget;
    gl.bindBuffer(target, this._buffer);
    gl.bufferSubData(target, offsetInBytes, arrayView);
    gl.bindBuffer(target, null);
};
Buffer.prototype.copyFromBuffer = function(readBuffer, readOffset, writeOffset, sizeInBytes) {
    //>>includeStart('debug', pragmas.debug);
    if (!this._webgl2) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("A WebGL 2 context is required.");
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(readBuffer)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("readBuffer must be defined.");
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(sizeInBytes) || sizeInBytes <= 0) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("sizeInBytes must be defined and be greater than zero.");
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(readOffset) || readOffset < 0 || readOffset + sizeInBytes > readBuffer._sizeInBytes) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("readOffset must be greater than or equal to zero and readOffset + sizeInBytes must be less than of equal to readBuffer.sizeInBytes.");
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(writeOffset) || writeOffset < 0 || writeOffset + sizeInBytes > this._sizeInBytes) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("writeOffset must be greater than or equal to zero and writeOffset + sizeInBytes must be less than of equal to this.sizeInBytes.");
    }
    if (this._buffer === readBuffer._buffer && (writeOffset >= readOffset && writeOffset < readOffset + sizeInBytes || readOffset > writeOffset && readOffset < writeOffset + sizeInBytes)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("When readBuffer is equal to this, the ranges [readOffset + sizeInBytes) and [writeOffset, writeOffset + sizeInBytes) must not overlap.");
    }
    if (this._bufferTarget === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ELEMENT_ARRAY_BUFFER && readBuffer._bufferTarget !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ELEMENT_ARRAY_BUFFER || this._bufferTarget !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ELEMENT_ARRAY_BUFFER && readBuffer._bufferTarget === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ELEMENT_ARRAY_BUFFER) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Can not copy an index buffer into another buffer type.");
    }
    //>>includeEnd('debug');
    const readTarget = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COPY_READ_BUFFER;
    const writeTarget = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COPY_WRITE_BUFFER;
    const gl = this._gl;
    gl.bindBuffer(writeTarget, this._buffer);
    gl.bindBuffer(readTarget, readBuffer._buffer);
    gl.copyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, sizeInBytes);
    gl.bindBuffer(writeTarget, null);
    gl.bindBuffer(readTarget, null);
};
Buffer.prototype.getBufferData = function(arrayView, sourceOffset, destinationOffset, length) {
    sourceOffset = sourceOffset ?? 0;
    destinationOffset = destinationOffset ?? 0;
    //>>includeStart('debug', pragmas.debug);
    if (!this._webgl2) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("A WebGL 2 context is required.");
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(arrayView)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("arrayView is required.");
    }
    let copyLength;
    let elementSize;
    let arrayLength = arrayView.byteLength;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(length)) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(arrayLength)) {
            copyLength = arrayLength - destinationOffset;
            elementSize = 1;
        } else {
            arrayLength = arrayView.length;
            copyLength = arrayLength - destinationOffset;
            elementSize = arrayView.BYTES_PER_ELEMENT;
        }
    } else {
        copyLength = length;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(arrayLength)) {
            elementSize = 1;
        } else {
            arrayLength = arrayView.length;
            elementSize = arrayView.BYTES_PER_ELEMENT;
        }
    }
    if (destinationOffset < 0 || destinationOffset > arrayLength) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("destinationOffset must be greater than zero and less than the arrayView length.");
    }
    if (destinationOffset + copyLength > arrayLength) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("destinationOffset + length must be less than or equal to the arrayViewLength.");
    }
    if (sourceOffset < 0 || sourceOffset > this._sizeInBytes) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("sourceOffset must be greater than zero and less than the buffers size.");
    }
    if (sourceOffset + copyLength * elementSize > this._sizeInBytes) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("sourceOffset + length must be less than the buffers size.");
    }
    //>>includeEnd('debug');
    const gl = this._gl;
    const target = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COPY_READ_BUFFER;
    gl.bindBuffer(target, this._buffer);
    gl.getBufferSubData(target, sourceOffset, arrayView, destinationOffset, length);
    gl.bindBuffer(target, null);
};
Buffer.prototype.isDestroyed = function() {
    return false;
};
Buffer.prototype.destroy = function() {
    this._gl.deleteBuffer(this._buffer);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
};
const __TURBOPACK__default__export__ = Buffer;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/VertexArray.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/ComponentDatatype.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/destroyObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$IndexDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/IndexDatatype.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/RuntimeError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$BufferUsage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/BufferUsage.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ContextLimits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$AttributeType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Scene/AttributeType.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function addAttribute(attributes, attribute, index, context) {
    const hasVertexBuffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attribute.vertexBuffer);
    const hasValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attribute.value);
    const componentsPerAttribute = attribute.value ? attribute.value.length : attribute.componentsPerAttribute;
    //>>includeStart('debug', pragmas.debug);
    if (!hasVertexBuffer && !hasValue) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("attribute must have a vertexBuffer or a value.");
    }
    if (hasVertexBuffer && hasValue) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("attribute cannot have both a vertexBuffer and a value.  It must have either a vertexBuffer property defining per-vertex data or a value property defining data for all vertices.");
    }
    if (componentsPerAttribute !== 1 && componentsPerAttribute !== 2 && componentsPerAttribute !== 3 && componentsPerAttribute !== 4) {
        if (hasValue) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("attribute.value.length must be in the range [1, 4].");
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("attribute.componentsPerAttribute must be in the range [1, 4].");
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attribute.componentDatatype) && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(attribute.componentDatatype)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("attribute must have a valid componentDatatype or not specify it.");
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attribute.strideInBytes) && attribute.strideInBytes > 255) {
        // WebGL limit.  Not in GL ES.
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("attribute must have a strideInBytes less than or equal to 255 or not specify it.");
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attribute.instanceDivisor) && attribute.instanceDivisor > 0 && !context.instancedArrays) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("instanced arrays is not supported");
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attribute.instanceDivisor) && attribute.instanceDivisor < 0) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("attribute must have an instanceDivisor greater than or equal to zero");
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attribute.instanceDivisor) && hasValue) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("attribute cannot have have an instanceDivisor if it is not backed by a buffer");
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attribute.instanceDivisor) && attribute.instanceDivisor > 0 && attribute.index === 0) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("attribute zero cannot have an instanceDivisor greater than 0");
    }
    //>>includeEnd('debug');
    // Shallow copy the attribute; we do not want to copy the vertex buffer.
    const attr = {
        index: attribute.index ?? index,
        enabled: attribute.enabled ?? true,
        vertexBuffer: attribute.vertexBuffer,
        value: hasValue ? attribute.value.slice(0) : undefined,
        componentsPerAttribute: componentsPerAttribute,
        componentDatatype: attribute.componentDatatype ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        normalize: attribute.normalize ?? false,
        offsetInBytes: attribute.offsetInBytes ?? 0,
        strideInBytes: attribute.strideInBytes ?? 0,
        instanceDivisor: attribute.instanceDivisor ?? 0
    };
    if (hasVertexBuffer) {
        // Common case: vertex buffer for per-vertex data
        attr.vertexAttrib = function(gl) {
            const index = this.index;
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer._getBuffer());
            gl.vertexAttribPointer(index, this.componentsPerAttribute, this.componentDatatype, this.normalize, this.strideInBytes, this.offsetInBytes);
            gl.enableVertexAttribArray(index);
            if (this.instanceDivisor > 0) {
                context.glVertexAttribDivisor(index, this.instanceDivisor);
                context._vertexAttribDivisors[index] = this.instanceDivisor;
                context._previousDrawInstanced = true;
            }
        };
        attr.disableVertexAttribArray = function(gl) {
            gl.disableVertexAttribArray(this.index);
            if (this.instanceDivisor > 0) {
                context.glVertexAttribDivisor(index, 0);
            }
        };
    } else {
        // Less common case: value array for the same data for each vertex
        switch(attr.componentsPerAttribute){
            case 1:
                attr.vertexAttrib = function(gl) {
                    gl.vertexAttrib1fv(this.index, this.value);
                };
                break;
            case 2:
                attr.vertexAttrib = function(gl) {
                    gl.vertexAttrib2fv(this.index, this.value);
                };
                break;
            case 3:
                attr.vertexAttrib = function(gl) {
                    gl.vertexAttrib3fv(this.index, this.value);
                };
                break;
            case 4:
                attr.vertexAttrib = function(gl) {
                    gl.vertexAttrib4fv(this.index, this.value);
                };
                break;
        }
        attr.disableVertexAttribArray = function(gl) {};
    }
    attributes.push(attr);
}
function bind(gl, attributes, indexBuffer) {
    for(let i = 0; i < attributes.length; ++i){
        const attribute = attributes[i];
        if (attribute.enabled) {
            attribute.vertexAttrib(gl);
        }
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(indexBuffer)) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer._getBuffer());
    }
}
/**
 * Creates a vertex array, which defines the attributes making up a vertex, and contains an optional index buffer
 * to select vertices for rendering.  Attributes are defined using object literals as shown in Example 1 below.
 *
 * @param {object} options Object with the following properties:
 * @param {Context} options.context The context in which the VertexArray gets created.
 * @param {object[]} options.attributes An array of attributes.
 * @param {IndexBuffer} [options.indexBuffer] An optional index buffer.
 *
 * @returns {VertexArray} The vertex array, ready for use with drawing.
 *
 * @exception {DeveloperError} Attribute must have a <code>vertexBuffer</code>.
 * @exception {DeveloperError} Attribute must have a <code>componentsPerAttribute</code>.
 * @exception {DeveloperError} Attribute must have a valid <code>componentDatatype</code> or not specify it.
 * @exception {DeveloperError} Attribute must have a <code>strideInBytes</code> less than or equal to 255 or not specify it.
 * @exception {DeveloperError} Index n is used by more than one attribute.
 *
 *
 * @example
 * // Example 1. Create a vertex array with vertices made up of three floating point
 * // values, e.g., a position, from a single vertex buffer.  No index buffer is used.
 * const positionBuffer = Buffer.createVertexBuffer({
 *     context : context,
 *     sizeInBytes : 12,
 *     usage : BufferUsage.STATIC_DRAW
 * });
 * const attributes = [
 *     {
 *         index                  : 0,
 *         enabled                : true,
 *         vertexBuffer           : positionBuffer,
 *         componentsPerAttribute : 3,
 *         componentDatatype      : ComponentDatatype.FLOAT,
 *         normalize              : false,
 *         offsetInBytes          : 0,
 *         strideInBytes          : 0 // tightly packed
 *         instanceDivisor        : 0 // not instanced
 *     }
 * ];
 * const va = new VertexArray({
 *     context : context,
 *     attributes : attributes
 * });
 *
 * @example
 * // Example 2. Create a vertex array with vertices from two different vertex buffers.
 * // Each vertex has a three-component position and three-component normal.
 * const positionBuffer = Buffer.createVertexBuffer({
 *     context : context,
 *     sizeInBytes : 12,
 *     usage : BufferUsage.STATIC_DRAW
 * });
 * const normalBuffer = Buffer.createVertexBuffer({
 *     context : context,
 *     sizeInBytes : 12,
 *     usage : BufferUsage.STATIC_DRAW
 * });
 * const attributes = [
 *     {
 *         index                  : 0,
 *         vertexBuffer           : positionBuffer,
 *         componentsPerAttribute : 3,
 *         componentDatatype      : ComponentDatatype.FLOAT
 *     },
 *     {
 *         index                  : 1,
 *         vertexBuffer           : normalBuffer,
 *         componentsPerAttribute : 3,
 *         componentDatatype      : ComponentDatatype.FLOAT
 *     }
 * ];
 * const va = new VertexArray({
 *     context : context,
 *     attributes : attributes
 * });
 *
 * @example
 * // Example 3. Creates the same vertex layout as Example 2 using a single
 * // vertex buffer, instead of two.
 * const buffer = Buffer.createVertexBuffer({
 *     context : context,
 *     sizeInBytes : 24,
 *     usage : BufferUsage.STATIC_DRAW
 * });
 * const attributes = [
 *     {
 *         vertexBuffer           : buffer,
 *         componentsPerAttribute : 3,
 *         componentDatatype      : ComponentDatatype.FLOAT,
 *         offsetInBytes          : 0,
 *         strideInBytes          : 24
 *     },
 *     {
 *         vertexBuffer           : buffer,
 *         componentsPerAttribute : 3,
 *         componentDatatype      : ComponentDatatype.FLOAT,
 *         normalize              : true,
 *         offsetInBytes          : 12,
 *         strideInBytes          : 24
 *     }
 * ];
 * const va = new VertexArray({
 *     context : context,
 *     attributes : attributes
 * });
 *
 * @see Buffer#createVertexBuffer
 * @see Buffer#createIndexBuffer
 * @see Context#draw
 *
 * @private
 */ function VertexArray(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.context", options.context);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.attributes", options.attributes);
    //>>includeEnd('debug');
    const context = options.context;
    const gl = context._gl;
    const attributes = options.attributes;
    const indexBuffer = options.indexBuffer;
    let i;
    const vaAttributes = [];
    let numberOfVertices = 1; // if every attribute is backed by a single value
    let hasInstancedAttributes = false;
    let hasConstantAttributes = false;
    let length = attributes.length;
    for(i = 0; i < length; ++i){
        addAttribute(vaAttributes, attributes[i], i, context);
    }
    length = vaAttributes.length;
    for(i = 0; i < length; ++i){
        const attribute = vaAttributes[i];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attribute.vertexBuffer) && attribute.instanceDivisor === 0) {
            // This assumes that each vertex buffer in the vertex array has the same number of vertices.
            const bytes = attribute.strideInBytes || attribute.componentsPerAttribute * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getSizeInBytes(attribute.componentDatatype);
            numberOfVertices = attribute.vertexBuffer.sizeInBytes / bytes;
            break;
        }
    }
    for(i = 0; i < length; ++i){
        if (vaAttributes[i].instanceDivisor > 0) {
            hasInstancedAttributes = true;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(vaAttributes[i].value)) {
            hasConstantAttributes = true;
        }
    }
    //>>includeStart('debug', pragmas.debug);
    // Verify all attribute names are unique
    const uniqueIndices = {};
    for(i = 0; i < length; ++i){
        const index = vaAttributes[i].index;
        if (uniqueIndices[index]) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Index ${index} is used by more than one attribute.`);
        }
        uniqueIndices[index] = true;
    }
    //>>includeEnd('debug');
    let vao;
    // Setup VAO if supported
    if (context.vertexArrayObject) {
        vao = context.glCreateVertexArray();
        context.glBindVertexArray(vao);
        bind(gl, vaAttributes, indexBuffer);
        context.glBindVertexArray(null);
    }
    this._numberOfVertices = numberOfVertices;
    this._hasInstancedAttributes = hasInstancedAttributes;
    this._hasConstantAttributes = hasConstantAttributes;
    this._context = context;
    this._gl = gl;
    this._vao = vao;
    this._attributes = vaAttributes;
    this._indexBuffer = indexBuffer;
}
function computeNumberOfVertices(attribute) {
    return attribute.values.length / attribute.componentsPerAttribute;
}
function computeAttributeSizeInBytes(attribute) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getSizeInBytes(attribute.componentDatatype) * attribute.componentsPerAttribute;
}
function interleaveAttributes(attributes) {
    let j;
    let name;
    let attribute;
    // Extract attribute names.
    const names = [];
    for(name in attributes){
        // Attribute needs to have per-vertex values; not a constant value for all vertices.
        if (attributes.hasOwnProperty(name) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attributes[name]) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attributes[name].values)) {
            names.push(name);
            if (attributes[name].componentDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DOUBLE) {
                attributes[name].componentDatatype = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT;
                attributes[name].values = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createTypedArray(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT, attributes[name].values);
            }
        }
    }
    // Validation.  Compute number of vertices.
    let numberOfVertices;
    const namesLength = names.length;
    if (namesLength > 0) {
        numberOfVertices = computeNumberOfVertices(attributes[names[0]]);
        for(j = 1; j < namesLength; ++j){
            const currentNumberOfVertices = computeNumberOfVertices(attributes[names[j]]);
            if (currentNumberOfVertices !== numberOfVertices) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`${"Each attribute list must have the same number of vertices.  " + "Attribute "}${names[j]} has a different number of vertices ` + `(${currentNumberOfVertices.toString()})` + ` than attribute ${names[0]} (${numberOfVertices.toString()}).`);
            }
        }
    }
    // Sort attributes by the size of their components.  From left to right, a vertex stores floats, shorts, and then bytes.
    names.sort(function(left, right) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getSizeInBytes(attributes[right].componentDatatype) - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getSizeInBytes(attributes[left].componentDatatype);
    });
    // Compute sizes and strides.
    let vertexSizeInBytes = 0;
    const offsetsInBytes = {};
    for(j = 0; j < namesLength; ++j){
        name = names[j];
        attribute = attributes[name];
        offsetsInBytes[name] = vertexSizeInBytes;
        vertexSizeInBytes += computeAttributeSizeInBytes(attribute);
    }
    if (vertexSizeInBytes > 0) {
        // Pad each vertex to be a multiple of the largest component datatype so each
        // attribute can be addressed using typed arrays.
        const maxComponentSizeInBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getSizeInBytes(attributes[names[0]].componentDatatype); // Sorted large to small
        const remainder = vertexSizeInBytes % maxComponentSizeInBytes;
        if (remainder !== 0) {
            vertexSizeInBytes += maxComponentSizeInBytes - remainder;
        }
        // Total vertex buffer size in bytes, including per-vertex padding.
        const vertexBufferSizeInBytes = numberOfVertices * vertexSizeInBytes;
        // Create array for interleaved vertices.  Each attribute has a different view (pointer) into the array.
        const buffer = new ArrayBuffer(vertexBufferSizeInBytes);
        const views = {};
        for(j = 0; j < namesLength; ++j){
            name = names[j];
            const sizeInBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getSizeInBytes(attributes[name].componentDatatype);
            views[name] = {
                pointer: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createTypedArray(attributes[name].componentDatatype, buffer),
                index: offsetsInBytes[name] / sizeInBytes,
                strideInComponentType: vertexSizeInBytes / sizeInBytes
            };
        }
        // Copy attributes into one interleaved array.
        // PERFORMANCE_IDEA:  Can we optimize these loops?
        for(j = 0; j < numberOfVertices; ++j){
            for(let n = 0; n < namesLength; ++n){
                name = names[n];
                attribute = attributes[name];
                const values = attribute.values;
                const view = views[name];
                const pointer = view.pointer;
                const numberOfComponents = attribute.componentsPerAttribute;
                for(let k = 0; k < numberOfComponents; ++k){
                    pointer[view.index + k] = values[j * numberOfComponents + k];
                }
                view.index += view.strideInComponentType;
            }
        }
        return {
            buffer: buffer,
            offsetsInBytes: offsetsInBytes,
            vertexSizeInBytes: vertexSizeInBytes
        };
    }
    // No attributes to interleave.
    return undefined;
}
/**
 * Creates a vertex array from a geometry.  A geometry contains vertex attributes and optional index data
 * in system memory, whereas a vertex array contains vertex buffers and an optional index buffer in WebGL
 * memory for use with rendering.
 * <br /><br />
 * The <code>geometry</code> argument should use the standard layout like the geometry returned by {@link BoxGeometry}.
 * <br /><br />
 * <code>options</code> can have four properties:
 * <ul>
 *   <li><code>geometry</code>:  The source geometry containing data used to create the vertex array.</li>
 *   <li><code>attributeLocations</code>:  An object that maps geometry attribute names to vertex shader attribute locations.</li>
 *   <li><code>bufferUsage</code>:  The expected usage pattern of the vertex array's buffers.  On some WebGL implementations, this can significantly affect performance.  See {@link BufferUsage}.  Default: <code>BufferUsage.DYNAMIC_DRAW</code>.</li>
 *   <li><code>interleave</code>:  Determines if all attributes are interleaved in a single vertex buffer or if each attribute is stored in a separate vertex buffer.  Default: <code>false</code>.</li>
 * </ul>
 * <br />
 * If <code>options</code> is not specified or the <code>geometry</code> contains no data, the returned vertex array is empty.
 *
 * @param {object} options An object defining the geometry, attribute indices, buffer usage, and vertex layout used to create the vertex array.
 *
 * @exception {RuntimeError} Each attribute list must have the same number of vertices.
 * @exception {DeveloperError} The geometry must have zero or one index lists.
 * @exception {DeveloperError} Index n is used by more than one attribute.
 *
 *
 * @example
 * // Example 1. Creates a vertex array for rendering a box.  The default dynamic draw
 * // usage is used for the created vertex and index buffer.  The attributes are not
 * // interleaved by default.
 * const geometry = new BoxGeometry();
 * const va = VertexArray.fromGeometry({
 *     context            : context,
 *     geometry           : geometry,
 *     attributeLocations : GeometryPipeline.createAttributeLocations(geometry),
 * });
 *
 * @example
 * // Example 2. Creates a vertex array with interleaved attributes in a
 * // single vertex buffer.  The vertex and index buffer have static draw usage.
 * const va = VertexArray.fromGeometry({
 *     context            : context,
 *     geometry           : geometry,
 *     attributeLocations : GeometryPipeline.createAttributeLocations(geometry),
 *     bufferUsage        : BufferUsage.STATIC_DRAW,
 *     interleave         : true
 * });
 *
 * @example
 * // Example 3.  When the caller destroys the vertex array, it also destroys the
 * // attached vertex buffer(s) and index buffer.
 * va = va.destroy();
 *
 * @see Buffer#createVertexBuffer
 * @see Buffer#createIndexBuffer
 * @see GeometryPipeline.createAttributeLocations
 * @see ShaderProgram
 */ VertexArray.fromGeometry = function(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.context", options.context);
    //>>includeEnd('debug');
    const context = options.context;
    const geometry = options.geometry ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const bufferUsage = options.bufferUsage ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$BufferUsage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DYNAMIC_DRAW;
    const attributeLocations = options.attributeLocations ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const interleave = options.interleave ?? false;
    const createdVAAttributes = options.vertexArrayAttributes;
    let name;
    let attribute;
    let vertexBuffer;
    const vaAttributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(createdVAAttributes) ? createdVAAttributes : [];
    const attributes = geometry.attributes;
    if (interleave) {
        // Use a single vertex buffer with interleaved vertices.
        const interleavedAttributes = interleaveAttributes(attributes);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(interleavedAttributes)) {
            vertexBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createVertexBuffer({
                context: context,
                typedArray: interleavedAttributes.buffer,
                usage: bufferUsage
            });
            const offsetsInBytes = interleavedAttributes.offsetsInBytes;
            const strideInBytes = interleavedAttributes.vertexSizeInBytes;
            for(name in attributes){
                if (attributes.hasOwnProperty(name) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attributes[name])) {
                    attribute = attributes[name];
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attribute.values)) {
                        // Common case: per-vertex attributes
                        vaAttributes.push({
                            index: attributeLocations[name],
                            vertexBuffer: vertexBuffer,
                            componentDatatype: attribute.componentDatatype,
                            componentsPerAttribute: attribute.componentsPerAttribute,
                            normalize: attribute.normalize,
                            offsetInBytes: offsetsInBytes[name],
                            strideInBytes: strideInBytes
                        });
                    } else {
                        // Constant attribute for all vertices
                        vaAttributes.push({
                            index: attributeLocations[name],
                            value: attribute.value,
                            componentDatatype: attribute.componentDatatype,
                            normalize: attribute.normalize
                        });
                    }
                }
            }
        }
    } else {
        // One vertex buffer per attribute.
        for(name in attributes){
            if (attributes.hasOwnProperty(name) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attributes[name])) {
                attribute = attributes[name];
                let componentDatatype = attribute.componentDatatype;
                if (componentDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DOUBLE) {
                    componentDatatype = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT;
                }
                let attrProps = {};
                vertexBuffer = undefined;
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attribute.values)) {
                    vertexBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createVertexBuffer({
                        context: context,
                        typedArray: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createTypedArray(componentDatatype, attribute.values),
                        usage: bufferUsage
                    });
                    attrProps = {
                        index: attributeLocations[name],
                        vertexBuffer: vertexBuffer,
                        value: attribute.value,
                        componentDatatype: componentDatatype,
                        componentsPerAttribute: attribute.componentsPerAttribute,
                        normalize: attribute.normalize
                    };
                }
                //if we already have a typedArray lets use it
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attribute.typedArray)) {
                    vertexBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createVertexBuffer({
                        context: context,
                        typedArray: attribute.typedArray,
                        usage: bufferUsage
                    });
                    attrProps = {
                        index: attributeLocations[name],
                        vertexBuffer: vertexBuffer,
                        value: undefined,
                        componentDatatype: componentDatatype,
                        componentsPerAttribute: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$AttributeType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getNumberOfComponents(attribute.type),
                        normalize: attribute.normalized,
                        instanceDivisor: attribute.instanceDivisor
                    };
                }
                vaAttributes.push(attrProps);
            }
        }
    }
    let indexBuffer;
    const indices = geometry.indices;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(indices)) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].computeNumberOfVertices(geometry) >= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SIXTY_FOUR_KILOBYTES && context.elementIndexUint) {
            indexBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createIndexBuffer({
                context: context,
                typedArray: new Uint32Array(indices),
                usage: bufferUsage,
                indexDatatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$IndexDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_INT
            });
        } else {
            indexBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createIndexBuffer({
                context: context,
                typedArray: new Uint16Array(indices),
                usage: bufferUsage,
                indexDatatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$IndexDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_SHORT
            });
        }
    }
    return new VertexArray({
        context: context,
        attributes: vaAttributes,
        indexBuffer: indexBuffer
    });
};
Object.defineProperties(VertexArray.prototype, {
    numberOfAttributes: {
        get: function() {
            return this._attributes.length;
        }
    },
    numberOfVertices: {
        get: function() {
            return this._numberOfVertices;
        }
    },
    indexBuffer: {
        get: function() {
            return this._indexBuffer;
        }
    }
});
/**
 * index is the location in the array of attributes, not the index property of an attribute.
 */ VertexArray.prototype.getAttribute = function(index) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("index", index);
    //>>includeEnd('debug');
    return this._attributes[index];
};
// Workaround for ANGLE, where the attribute divisor seems to be part of the global state instead
// of the VAO state. This function is called when the vao is bound, and should be removed
// once the ANGLE issue is resolved. Setting the divisor should normally happen in vertexAttrib and
// disableVertexAttribArray.
function setVertexAttribDivisor(vertexArray) {
    const context = vertexArray._context;
    const hasInstancedAttributes = vertexArray._hasInstancedAttributes;
    if (!hasInstancedAttributes && !context._previousDrawInstanced) {
        return;
    }
    context._previousDrawInstanced = hasInstancedAttributes;
    const divisors = context._vertexAttribDivisors;
    const attributes = vertexArray._attributes;
    const maxAttributes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].maximumVertexAttributes;
    let i;
    if (hasInstancedAttributes) {
        const length = attributes.length;
        for(i = 0; i < length; ++i){
            const attribute = attributes[i];
            if (attribute.enabled) {
                const divisor = attribute.instanceDivisor;
                const index = attribute.index;
                if (divisor !== divisors[index]) {
                    context.glVertexAttribDivisor(index, divisor);
                    divisors[index] = divisor;
                }
            }
        }
    } else {
        for(i = 0; i < maxAttributes; ++i){
            if (divisors[i] > 0) {
                context.glVertexAttribDivisor(i, 0);
                divisors[i] = 0;
            }
        }
    }
}
// Vertex attributes backed by a constant value go through vertexAttrib[1234]f[v]
// which is part of context state rather than VAO state.
function setConstantAttributes(vertexArray, gl) {
    const attributes = vertexArray._attributes;
    const length = attributes.length;
    for(let i = 0; i < length; ++i){
        const attribute = attributes[i];
        if (attribute.enabled && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attribute.value)) {
            attribute.vertexAttrib(gl);
        }
    }
}
VertexArray.prototype._bind = function() {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._vao)) {
        this._context.glBindVertexArray(this._vao);
        if (this._context.instancedArrays) {
            setVertexAttribDivisor(this);
        }
        if (this._hasConstantAttributes) {
            setConstantAttributes(this, this._gl);
        }
    } else {
        bind(this._gl, this._attributes, this._indexBuffer);
    }
};
VertexArray.prototype._unBind = function() {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._vao)) {
        this._context.glBindVertexArray(null);
    } else {
        const attributes = this._attributes;
        const gl = this._gl;
        for(let i = 0; i < attributes.length; ++i){
            const attribute = attributes[i];
            if (attribute.enabled) {
                attribute.disableVertexAttribArray(gl);
            }
        }
        if (this._indexBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
    }
};
VertexArray.prototype.isDestroyed = function() {
    return false;
};
VertexArray.prototype.destroy = function() {
    const attributes = this._attributes;
    for(let i = 0; i < attributes.length; ++i){
        const vertexBuffer = attributes[i].vertexBuffer;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(vertexBuffer) && !vertexBuffer.isDestroyed() && vertexBuffer.vertexArrayDestroyable) {
            vertexBuffer.destroy();
        }
    }
    const indexBuffer = this._indexBuffer;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(indexBuffer) && !indexBuffer.isDestroyed() && indexBuffer.vertexArrayDestroyable) {
        indexBuffer.destroy();
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._vao)) {
        this._context.glDeleteVertexArray(this._vao);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
};
const __TURBOPACK__default__export__ = VertexArray;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/CubeMap.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoxGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/BoxGeometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartesian3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/destroyObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$GeometryPipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/GeometryPipeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/PixelFormat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$VertexFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/VertexFormat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$BufferUsage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/BufferUsage.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ContextLimits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$CubeMapFace$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/CubeMapFace.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Framebuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$MipmapHint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/MipmapHint.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/PixelDatatype.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Sampler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMagnificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/TextureMagnificationFilter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/TextureMinificationFilter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$VertexArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/VertexArray.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @typedef CubeMap.BufferSource
 *
 * @property {TypedArray} arrayBufferView A view of a binary data buffer containing pixel values.
 * @property {number} width The width of one face of the cube map, in pixels. Must be equal to height.
 * @property {number} height The height of one face of the cube map, in pixels. Must be equal to width.
 *
 * @private
 */ /**
 * @typedef CubeMap.Source
 *
 * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} positiveX
 * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} negativeX
 * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} positiveY
 * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} negativeY
 * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} positiveZ
 * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} negativeZ
 */ /**
 * @typedef CubeMap.ConstructorOptions
 *
 * @property {Context} context
 * @property {CubeMap.Source} [source] The source for texel values to be loaded into the texture.
 * @property {PixelFormat} [pixelFormat=PixelFormat.RGBA] The format of each pixel, i.e., the number of components it has and what they represent.
 * @property {PixelDatatype} [pixelDatatype=PixelDatatype.UNSIGNED_BYTE] The data type of each pixel.
 * @property {boolean} [flipY=true] If true, the source values will be read as if the y-axis is inverted (y=0 at the top).
 * @property {boolean} [skipColorSpaceConversion=false] If true, color space conversions will be skipped when reading the texel values.
 * @property {Sampler} [sampler] Information about how to sample the cubemap texture.
 * @property {number} [width] The pixel width of the texture. If not supplied, must be available from the source. Must be equal to height.
 * @property {number} [height] The pixel height of the texture. If not supplied, must be available from the source. Must be equal to width.
 * @property {boolean} [preMultiplyAlpha] If true, the alpha channel will be multiplied into the other channels.
 *
 * @private
 */ /**
 * A wrapper for a {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture|WebGLTexture}
 * used as a cube map, to abstract away the verbose GL calls associated with setting up a texture.
 *
 * @alias CubeMap
 * @constructor
 *
 * @param {CubeMap.ConstructorOptions} options An object describing initialization options.
 * @private
 */ function CubeMap(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.context", options.context);
    //>>includeEnd('debug');
    const { context, source, pixelFormat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGBA, pixelDatatype = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_BYTE, flipY = true, skipColorSpaceConversion = false, sampler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]() } = options;
    // Use premultiplied alpha for opaque textures should perform better on Chrome:
    // http://media.tojicode.com/webglCamp4/#20
    const preMultiplyAlpha = options.preMultiplyAlpha || pixelFormat === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGB || pixelFormat === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LUMINANCE;
    let { width, height } = options;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source)) {
        //>>includeStart('debug', pragmas.debug);
        if (!Object.values(CubeMap.FaceName).every((faceName)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source[faceName]))) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`options.source requires faces ${Object.values(CubeMap.FaceName).join(", ")}.`);
        }
        //>>includeEnd('debug');
        ({ width, height } = source.positiveX);
        //>>includeStart('debug', pragmas.debug);
        for (const faceName of CubeMap.faceNames()){
            const face = source[faceName];
            if (Number(face.width) !== width || Number(face.height) !== height) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Each face in options.source must have the same width and height.");
            }
        }
    //>>includeEnd('debug');
    }
    const size = width;
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(width) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(height)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("options requires a source field to create an initialized cube map or width and height fields to create a blank cube map.");
    }
    if (width !== height) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Width must equal height.");
    }
    if (size <= 0) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Width and height must be greater than zero.");
    }
    if (size > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].maximumCubeMapSize) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Width and height must be less than or equal to the maximum cube map size (${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].maximumCubeMapSize}). Check maximumCubeMapSize.`);
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(pixelFormat)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid options.pixelFormat.");
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isDepthFormat(pixelFormat)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("options.pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL.");
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(pixelDatatype)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid options.pixelDatatype.");
    }
    if (pixelDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT && !context.floatingPointTexture) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.");
    }
    if (pixelDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT && !context.halfFloatingPointTexture) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension.");
    }
    //>>includeEnd('debug');
    const sizeInBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].textureSizeInBytes(pixelFormat, pixelDatatype, size, size) * 6;
    const internalFormat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toInternalFormat(pixelFormat, pixelDatatype, context);
    const gl = context._gl;
    const textureTarget = gl.TEXTURE_CUBE_MAP;
    const texture = gl.createTexture();
    this._context = context;
    this._textureFilterAnisotropic = context._textureFilterAnisotropic;
    this._textureTarget = textureTarget;
    this._texture = texture;
    this._pixelFormat = pixelFormat;
    this._pixelDatatype = pixelDatatype;
    this._size = size;
    this._hasMipmap = false;
    this._sizeInBytes = sizeInBytes;
    this._preMultiplyAlpha = preMultiplyAlpha;
    this._flipY = flipY;
    const initialized = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source);
    function constructFace(targetFace) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$CubeMapFace$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](context, texture, textureTarget, targetFace, internalFormat, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY, initialized);
    }
    this._positiveX = constructFace(gl.TEXTURE_CUBE_MAP_POSITIVE_X);
    this._negativeX = constructFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_X);
    this._positiveY = constructFace(gl.TEXTURE_CUBE_MAP_POSITIVE_Y);
    this._negativeY = constructFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y);
    this._positiveZ = constructFace(gl.TEXTURE_CUBE_MAP_POSITIVE_Z);
    this._negativeZ = constructFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z);
    this._sampler = sampler;
    setupSampler(this, sampler);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(textureTarget, texture);
    if (skipColorSpaceConversion) {
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    } else {
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.BROWSER_DEFAULT_WEBGL);
    }
    for (const faceName of CubeMap.faceNames()){
        loadFace(this[faceName], source?.[faceName], 0);
    }
    gl.bindTexture(textureTarget, null);
}
/**
 * Copy an existing texture to a cubemap face.
 * @param {FrameState} frameState The current rendering frameState
 * @param {Texture} texture Texture being copied
 * @param {CubeMap.FaceName} face The face to which to copy
 * @param {number} [mipLevel=0] The mip level at which to copy
 */ CubeMap.prototype.copyFace = function(frameState, texture, face, mipLevel) {
    const context = frameState.context;
    const framebuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        context: context,
        colorTextures: [
            texture
        ],
        destroyAttachments: false
    });
    framebuffer._bind();
    this[face].copyMipmapFromFramebuffer(0, 0, texture.width, texture.height, mipLevel ?? 0);
    framebuffer._unBind();
    framebuffer.destroy();
};
/**
 * An enum defining the names of the faces of a cube map.
 * @alias {CubeMap.FaceName}
 * @enum {string}
 * @private
 */ CubeMap.FaceName = Object.freeze({
    POSITIVEX: "positiveX",
    NEGATIVEX: "negativeX",
    POSITIVEY: "positiveY",
    NEGATIVEY: "negativeY",
    POSITIVEZ: "positiveZ",
    NEGATIVEZ: "negativeZ"
});
function* makeFaceNamesIterator() {
    yield CubeMap.FaceName.POSITIVEX;
    yield CubeMap.FaceName.NEGATIVEX;
    yield CubeMap.FaceName.POSITIVEY;
    yield CubeMap.FaceName.NEGATIVEY;
    yield CubeMap.FaceName.POSITIVEZ;
    yield CubeMap.FaceName.NEGATIVEZ;
}
/**
 * Creates an iterator for looping over the cubemap faces.
 * @type {Iterable<CubeMap.FaceName>}
 * @private
 */ CubeMap.faceNames = function() {
    return makeFaceNamesIterator();
};
/**
 * Load texel data into one face of a cube map.
 * @param {CubeMapFace} cubeMapFace The face to which texel values will be loaded.
 * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} [source] The source for texel values to be loaded into the texture.
 * @param {number} [mipLevel=0] The mip level to which the texel values will be loaded.
 * @private
 */ function loadFace(cubeMapFace, source, mipLevel) {
    mipLevel = mipLevel ?? 0;
    const targetFace = cubeMapFace._targetFace;
    const size = Math.max(Math.floor(cubeMapFace._size / 2 ** mipLevel), 1);
    const pixelFormat = cubeMapFace._pixelFormat;
    const pixelDatatype = cubeMapFace._pixelDatatype;
    const internalFormat = cubeMapFace._internalFormat;
    const flipY = cubeMapFace._flipY;
    const preMultiplyAlpha = cubeMapFace._preMultiplyAlpha;
    const context = cubeMapFace._context;
    const gl = context._gl;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source)) {
        gl.texImage2D(targetFace, mipLevel, internalFormat, size, size, 0, pixelFormat, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toWebGLConstant(pixelDatatype, context), null);
        return;
    }
    let { arrayBufferView } = source;
    let unpackAlignment = 4;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(arrayBufferView)) {
        unpackAlignment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].alignmentInBytes(pixelFormat, pixelDatatype, size);
    }
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(arrayBufferView)) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        if (flipY) {
            arrayBufferView = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].flipY(arrayBufferView, pixelFormat, pixelDatatype, size, size);
        }
        gl.texImage2D(targetFace, mipLevel, internalFormat, size, size, 0, pixelFormat, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toWebGLConstant(pixelDatatype, context), arrayBufferView);
    } else {
        // Only valid for DOM-Element uploads
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
        gl.texImage2D(targetFace, mipLevel, internalFormat, pixelFormat, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toWebGLConstant(pixelDatatype, context), source);
    }
}
CubeMap.loadFace = loadFace;
Object.defineProperties(CubeMap.prototype, {
    positiveX: {
        get: function() {
            return this._positiveX;
        }
    },
    negativeX: {
        get: function() {
            return this._negativeX;
        }
    },
    positiveY: {
        get: function() {
            return this._positiveY;
        }
    },
    negativeY: {
        get: function() {
            return this._negativeY;
        }
    },
    positiveZ: {
        get: function() {
            return this._positiveZ;
        }
    },
    negativeZ: {
        get: function() {
            return this._negativeZ;
        }
    },
    sampler: {
        get: function() {
            return this._sampler;
        },
        set: function(sampler) {
            setupSampler(this, sampler);
            this._sampler = sampler;
        }
    },
    pixelFormat: {
        get: function() {
            return this._pixelFormat;
        }
    },
    pixelDatatype: {
        get: function() {
            return this._pixelDatatype;
        }
    },
    width: {
        get: function() {
            return this._size;
        }
    },
    height: {
        get: function() {
            return this._size;
        }
    },
    sizeInBytes: {
        get: function() {
            if (this._hasMipmap) {
                return Math.floor(this._sizeInBytes * 4 / 3);
            }
            return this._sizeInBytes;
        }
    },
    preMultiplyAlpha: {
        get: function() {
            return this._preMultiplyAlpha;
        }
    },
    flipY: {
        get: function() {
            return this._flipY;
        }
    },
    _target: {
        get: function() {
            return this._textureTarget;
        }
    }
});
/**
 * Get a vector representing the cubemap face direction
 * @param {CubeMap.FaceName} face The relevant face
 * @param {Cartesian3} [result] The object onto which to store the result.
 * @returns {Cartesian3} The vector representing the cubemap face direction
 */ CubeMap.getDirection = function(face, result) {
    switch(face){
        case CubeMap.FaceName.POSITIVEX:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_X, result);
        case CubeMap.FaceName.NEGATIVEX:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].negate(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_X, result);
        case CubeMap.FaceName.POSITIVEY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_Y, result);
        case CubeMap.FaceName.NEGATIVEY:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].negate(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_Y, result);
        case CubeMap.FaceName.POSITIVEZ:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_Z, result);
        case CubeMap.FaceName.NEGATIVEZ:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].negate(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNIT_Z, result);
    }
};
/**
 * Set up a sampler for use with a cube map.
 * @param {CubeMap} cubeMap The cube map containing the texture to be sampled by this sampler.
 * @param {Sampler} sampler Information about how to sample the cubemap texture.
 * @private
 */ function setupSampler(cubeMap, sampler) {
    let { minificationFilter, magnificationFilter } = sampler;
    const mipmap = [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST_MIPMAP_NEAREST,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST_MIPMAP_LINEAR,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LINEAR_MIPMAP_NEAREST,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LINEAR_MIPMAP_LINEAR
    ].includes(minificationFilter);
    const context = cubeMap._context;
    const pixelDatatype = cubeMap._pixelDatatype;
    // float textures only support nearest filtering unless the linear extensions are supported
    if (pixelDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT && !context.textureFloatLinear || pixelDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT && !context.textureHalfFloatLinear) {
        // override the sampler's settings
        minificationFilter = mipmap ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST_MIPMAP_NEAREST : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST;
        magnificationFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMagnificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST;
    }
    const gl = context._gl;
    const target = cubeMap._textureTarget;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(target, cubeMap._texture);
    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minificationFilter);
    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magnificationFilter);
    gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);
    gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(cubeMap._textureFilterAnisotropic)) {
        gl.texParameteri(target, cubeMap._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, sampler.maximumAnisotropy);
    }
    gl.bindTexture(target, null);
}
/**
 * Load a complete mipmap chain for each cubemap face.
 *
 * @param {CubeMap.Source[]} source The source data for each mip level, beginning at level 1.
 * @param {boolean} [skipColorSpaceConversion=false] If true, color space conversions will be skipped when reading the texel values.
 *
 * @private
 */ CubeMap.prototype.loadMipmaps = function(source, skipColorSpaceConversion) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("source", source);
    if (!Array.isArray(source)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`source must be an array`);
    }
    const mipCount = Math.log2(this._size);
    if (source.length !== mipCount) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`all mip levels must be defined`);
    }
    //>>includeEnd('debug');
    skipColorSpaceConversion = skipColorSpaceConversion ?? false;
    const gl = this._context._gl;
    const texture = this._texture;
    const textureTarget = this._textureTarget;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(textureTarget, texture);
    if (skipColorSpaceConversion) {
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    } else {
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.BROWSER_DEFAULT_WEBGL);
    }
    for(let i = 0; i < source.length; i++){
        const mipSource = source[i];
        // mipLevel 0 was the base layer, already loaded when the CubeMap was constructed.
        const mipLevel = i + 1;
        for (const faceName of CubeMap.faceNames()){
            loadFace(this[faceName], mipSource[faceName], mipLevel);
        }
    }
    gl.bindTexture(textureTarget, null);
    this._hasMipmap = true;
};
/**
 * Generates a complete mipmap chain for each cubemap face.
 *
 * @param {MipmapHint} [hint=MipmapHint.DONT_CARE] A performance vs. quality hint.
 *
 * @exception {DeveloperError} hint is invalid.
 * @exception {DeveloperError} This CubeMap's width must be a power of two to call generateMipmap().
 * @exception {DeveloperError} This CubeMap's height must be a power of two to call generateMipmap().
 * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
 *
 * @example
 * // Generate mipmaps, and then set the sampler so mipmaps are used for
 * // minification when the cube map is sampled.
 * cubeMap.generateMipmap();
 * cubeMap.sampler = new Sampler({
 *   minificationFilter : Cesium.TextureMinificationFilter.NEAREST_MIPMAP_LINEAR
 * });
 */ CubeMap.prototype.generateMipmap = function(hint) {
    hint = hint ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$MipmapHint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DONT_CARE;
    //>>includeStart('debug', pragmas.debug);
    if (this._size > 1 && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isPowerOfTwo(this._size)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("width and height must be a power of two to call generateMipmap().");
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$MipmapHint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(hint)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("hint is invalid.");
    }
    //>>includeEnd('debug');
    this._hasMipmap = true;
    const gl = this._context._gl;
    const target = this._textureTarget;
    gl.hint(gl.GENERATE_MIPMAP_HINT, hint);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(target, this._texture);
    gl.generateMipmap(target);
    gl.bindTexture(target, null);
};
/**
 * Create a vertex array that can be used for cubemap shaders.
 * @param {Context} context The rendering context
 * @returns {VertexArray} The created vertex array
 */ CubeMap.createVertexArray = function(context) {
    const geometry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoxGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createGeometry(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoxGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromDimensions({
        dimensions: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](2.0, 2.0, 2.0),
        vertexFormat: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$VertexFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].POSITION_ONLY
    }));
    const attributeLocations = this._attributeLocations = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$GeometryPipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createAttributeLocations(geometry);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$VertexArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromGeometry({
        context: context,
        geometry: geometry,
        attributeLocations: attributeLocations,
        bufferUsage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$BufferUsage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].STATIC_DRAW
    });
};
CubeMap.prototype.isDestroyed = function() {
    return false;
};
CubeMap.prototype.destroy = function() {
    this._context._gl.deleteTexture(this._texture);
    this._positiveX = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._positiveX);
    this._negativeX = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._negativeX);
    this._positiveY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._positiveY);
    this._negativeY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._negativeY);
    this._positiveZ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._positiveZ);
    this._negativeZ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._negativeZ);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
};
const __TURBOPACK__default__export__ = CubeMap;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/Texture.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartesian2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$createGuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/createGuid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/destroyObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/PixelFormat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ContextLimits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$MipmapHint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/MipmapHint.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/PixelDatatype.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Sampler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMagnificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/TextureMagnificationFilter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/TextureMinificationFilter.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @typedef {object} Texture.ConstructorOptions
 *
 * @property {Context} context
 * @property {object} [source] The source for texel values to be loaded into the texture. A {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement},
 *                        {@link HTMLVideoElement}, {@link OffscreenCanvas}, or {@link ImageBitmap},
 *                        or an object with width, height, and arrayBufferView properties.
 * @property {PixelFormat} [pixelFormat=PixelFormat.RGBA] The format of each pixel, i.e., the number of components it has and what they represent.
 * @property {PixelDatatype} [pixelDatatype=PixelDatatype.UNSIGNED_BYTE] The data type of each pixel.
 * @property {boolean} [flipY=true] If true, the source values will be read as if the y-axis is inverted (y=0 at the top).
 * @property {boolean} [skipColorSpaceConversion=false] If true, color space conversions will be skipped when reading the texel values.
 * @property {Sampler} [sampler] Information about how to sample the texture.
 * @property {number} [width] The pixel width of the texture. If not supplied, must be available from the source.
 * @property {number} [height] The pixel height of the texture. If not supplied, must be available from the source.
 * @property {boolean} [preMultiplyAlpha] If true, the alpha channel will be multiplied into the other channels.
 * @property {string} [id] A unique identifier for the texture. If this is not given, then a GUID will be created.
 *
 * @private
 */ /**
 * A wrapper for a {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture|WebGLTexture}
 * to abstract away the verbose GL calls associated with setting up a texture.
 *
 * @alias Texture
 * @constructor
 *
 * @param {Texture.ConstructorOptions} options
 * @private
 */ function Texture(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.context", options.context);
    //>>includeEnd('debug');
    const { context, source, pixelFormat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGBA, pixelDatatype = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_BYTE, flipY = true, skipColorSpaceConversion = false, sampler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]() } = options;
    let { width, height } = options;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source)) {
        // Make sure we are using the element's intrinsic width and height where available
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(width)) {
            width = source.videoWidth ?? source.naturalWidth ?? source.width;
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(height)) {
            height = source.videoHeight ?? source.naturalHeight ?? source.height;
        }
    }
    // Use premultiplied alpha for opaque textures should perform better on Chrome:
    // http://media.tojicode.com/webglCamp4/#20
    const preMultiplyAlpha = options.preMultiplyAlpha || pixelFormat === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGB || pixelFormat === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LUMINANCE;
    const internalFormat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toInternalFormat(pixelFormat, pixelDatatype, context);
    const isCompressed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isCompressedFormat(internalFormat);
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(width) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(height)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("options requires a source field to create an initialized texture or width and height fields to create a blank texture.");
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThan("width", width, 0);
    if (width > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].maximumTextureSize) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Width must be less than or equal to the maximum texture size (${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].maximumTextureSize}).  Check maximumTextureSize.`);
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThan("height", height, 0);
    if (height > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].maximumTextureSize) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Height must be less than or equal to the maximum texture size (${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].maximumTextureSize}).  Check maximumTextureSize.`);
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(pixelFormat)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid options.pixelFormat.");
    }
    if (!isCompressed && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(pixelDatatype)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid options.pixelDatatype.");
    }
    if (pixelFormat === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DEPTH_COMPONENT && pixelDatatype !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_SHORT && pixelDatatype !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_INT) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("When options.pixelFormat is DEPTH_COMPONENT, options.pixelDatatype must be UNSIGNED_SHORT or UNSIGNED_INT.");
    }
    if (pixelFormat === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DEPTH_STENCIL && pixelDatatype !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_INT_24_8) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("When options.pixelFormat is DEPTH_STENCIL, options.pixelDatatype must be UNSIGNED_INT_24_8.");
    }
    if (pixelDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT && !context.floatingPointTexture) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.  Check context.floatingPointTexture.");
    }
    if (pixelDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT && !context.halfFloatingPointTexture) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension. Check context.halfFloatingPointTexture.");
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isDepthFormat(pixelFormat)) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, source cannot be provided.");
        }
        if (!context.depthTexture) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, this WebGL implementation must support WEBGL_depth_texture.  Check context.depthTexture.");
        }
    }
    if (isCompressed) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source.arrayBufferView)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("When options.pixelFormat is compressed, options.source.arrayBufferView must be defined.");
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isDXTFormat(internalFormat) && !context.s3tc) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("When options.pixelFormat is S3TC compressed, this WebGL implementation must support the WEBGL_compressed_texture_s3tc extension. Check context.s3tc.");
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isPVRTCFormat(internalFormat) && !context.pvrtc) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("When options.pixelFormat is PVRTC compressed, this WebGL implementation must support the WEBGL_compressed_texture_pvrtc extension. Check context.pvrtc.");
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isASTCFormat(internalFormat) && !context.astc) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("When options.pixelFormat is ASTC compressed, this WebGL implementation must support the WEBGL_compressed_texture_astc extension. Check context.astc.");
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isETC2Format(internalFormat) && !context.etc) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("When options.pixelFormat is ETC2 compressed, this WebGL implementation must support the WEBGL_compressed_texture_etc extension. Check context.etc.");
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isETC1Format(internalFormat) && !context.etc1) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("When options.pixelFormat is ETC1 compressed, this WebGL implementation must support the WEBGL_compressed_texture_etc1 extension. Check context.etc1.");
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isBC7Format(internalFormat) && !context.bc7) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("When options.pixelFormat is BC7 compressed, this WebGL implementation must support the EXT_texture_compression_bptc extension. Check context.bc7.");
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].compressedTextureSizeInBytes(internalFormat, width, height) !== source.arrayBufferView.byteLength) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("The byte length of the array buffer is invalid for the compressed texture with the given width and height.");
        }
    }
    //>>includeEnd('debug');
    const gl = context._gl;
    const sizeInBytes = isCompressed ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].compressedTextureSizeInBytes(pixelFormat, width, height) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].textureSizeInBytes(pixelFormat, pixelDatatype, width, height);
    this._id = options.id ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$createGuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
    this._context = context;
    this._textureFilterAnisotropic = context._textureFilterAnisotropic;
    this._textureTarget = gl.TEXTURE_2D;
    this._texture = gl.createTexture();
    this._internalFormat = internalFormat;
    this._pixelFormat = pixelFormat;
    this._pixelDatatype = pixelDatatype;
    this._width = width;
    this._height = height;
    this._dimensions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](width, height);
    this._hasMipmap = false;
    this._sizeInBytes = sizeInBytes;
    this._preMultiplyAlpha = preMultiplyAlpha;
    this._flipY = flipY;
    this._initialized = false;
    this._sampler = undefined;
    this._sampler = sampler;
    setupSampler(this, sampler);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(this._textureTarget, this._texture);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source)) {
        if (skipColorSpaceConversion) {
            gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
        } else {
            gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.BROWSER_DEFAULT_WEBGL);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source.arrayBufferView)) {
            const isCompressed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isCompressedFormat(internalFormat);
            if (isCompressed) {
                loadCompressedBufferSource(this, source);
            } else {
                loadBufferSource(this, source);
            }
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source.framebuffer)) {
            loadFramebufferSource(this, source);
        } else {
            loadImageSource(this, source);
        }
        this._initialized = true;
    } else {
        loadNull(this);
    }
    gl.bindTexture(this._textureTarget, null);
}
/**
 * Load compressed texel data from a buffer into a texture.
 *
 * @param {Texture} texture The texture to which texel values will be loaded.
 * @param {object} source The source for texel values to be loaded into the texture.
 *
 * @private
 */ function loadCompressedBufferSource(texture, source) {
    const context = texture._context;
    const gl = context._gl;
    const textureTarget = texture._textureTarget;
    const internalFormat = texture._internalFormat;
    const { width, height } = texture;
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.compressedTexImage2D(textureTarget, 0, internalFormat, width, height, 0, source.arrayBufferView);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source.mipLevels)) {
        let mipWidth = width;
        let mipHeight = height;
        for(let i = 0; i < source.mipLevels.length; ++i){
            mipWidth = nextMipSize(mipWidth);
            mipHeight = nextMipSize(mipHeight);
            gl.compressedTexImage2D(textureTarget, i + 1, internalFormat, mipWidth, mipHeight, 0, source.mipLevels[i]);
        }
    }
}
/**
 * Load texel data from a buffer into a texture.
 *
 * @param {Texture} texture The texture to which texel values will be loaded.
 * @param {object} source The source for texel values to be loaded into the texture.
 *
 * @private
 */ function loadBufferSource(texture, source) {
    const context = texture._context;
    const gl = context._gl;
    const textureTarget = texture._textureTarget;
    const internalFormat = texture._internalFormat;
    const { width, height, pixelFormat, pixelDatatype, flipY } = texture;
    const unpackAlignment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].alignmentInBytes(pixelFormat, pixelDatatype, width);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    let { arrayBufferView } = source;
    if (flipY) {
        arrayBufferView = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].flipY(arrayBufferView, pixelFormat, pixelDatatype, width, height);
    }
    gl.texImage2D(textureTarget, 0, internalFormat, width, height, 0, pixelFormat, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toWebGLConstant(pixelDatatype, context), arrayBufferView);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source.mipLevels)) {
        let mipWidth = width;
        let mipHeight = height;
        for(let i = 0; i < source.mipLevels.length; ++i){
            mipWidth = nextMipSize(mipWidth);
            mipHeight = nextMipSize(mipHeight);
            gl.texImage2D(textureTarget, i + 1, internalFormat, mipWidth, mipHeight, 0, pixelFormat, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toWebGLConstant(pixelDatatype, context), source.mipLevels[i]);
        }
    }
}
/**
 * Load texel data from a buffer into part of a texture
 *
 * @param {Texture} texture The texture to which texel values will be loaded.
 * @param {TypedArray} arrayBufferView The texel values to be loaded into the texture.
 * @param {number} xOffset The texel x coordinate of the lower left corner of the subregion of the texture to be updated.
 * @param {number} yOffset The texel y coordinate of the lower left corner of the subregion of the texture to be updated.
 * @param {number} width The width of the source data, in pixels.
 * @param {number} width The height of the source data, in pixels.
 *
 * @private
 */ function loadPartialBufferSource(texture, arrayBufferView, xOffset, yOffset, width, height) {
    const context = texture._context;
    const gl = context._gl;
    const { pixelFormat, pixelDatatype } = texture;
    const unpackAlignment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].alignmentInBytes(pixelFormat, pixelDatatype, width);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    if (texture.flipY) {
        arrayBufferView = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].flipY(arrayBufferView, pixelFormat, pixelDatatype, width, height);
    }
    gl.texSubImage2D(texture._textureTarget, 0, xOffset, yOffset, width, height, pixelFormat, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toWebGLConstant(pixelDatatype, context), arrayBufferView);
}
/**
 * Load texel data from a framebuffer into a texture.
 *
 * @param {Texture} texture The texture to which texel values will be loaded.
 * @param {object} source The source for texel values to be loaded into the texture.
 *
 * @private
 */ function loadFramebufferSource(texture, source) {
    const context = texture._context;
    const gl = context._gl;
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    if (source.framebuffer !== context.defaultFramebuffer) {
        source.framebuffer._bind();
    }
    gl.copyTexImage2D(texture._textureTarget, 0, texture._internalFormat, source.xOffset, source.yOffset, texture.width, texture.height, 0);
    if (source.framebuffer !== context.defaultFramebuffer) {
        source.framebuffer._unBind();
    }
}
/**
 * Load texel data from an Image into a texture.
 *
 * @param {Texture} texture The texture to which texel values will be loaded.
 * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|OffscreenCanvas|ImageBitmap} source The source for texel values to be loaded into the texture.
 *
 * @private
 */ function loadImageSource(texture, source) {
    const context = texture._context;
    const gl = context._gl;
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.preMultiplyAlpha);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
    gl.texImage2D(texture._textureTarget, 0, texture._internalFormat, texture.pixelFormat, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toWebGLConstant(texture.pixelDatatype, context), source);
}
/**
 * Load texel data from an Image into part of a texture
 *
 * @param {Texture} texture The texture to which texel values will be loaded.
 * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} source The source for texel values to be loaded into the texture.
 * @param {number} xOffset The texel x coordinate of the lower left corner of the subregion of the texture to be updated.
 * @param {number} yOffset The texel y coordinate of the lower left corner of the subregion of the texture to be updated.
 *
 * @private
 */ function loadPartialImageSource(texture, source, xOffset, yOffset) {
    const context = texture._context;
    const gl = context._gl;
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.preMultiplyAlpha);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
    gl.texSubImage2D(texture._textureTarget, 0, xOffset, yOffset, texture.pixelFormat, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toWebGLConstant(texture.pixelDatatype, context), source);
}
/**
 * Compute a dimension of the image for the next mip level.
 *
 * @param {number} currentSize The size of the current mip level.
 * @returns {number} The size of the next mip level.
 *
 * @private
 */ function nextMipSize(currentSize) {
    const nextSize = Math.floor(currentSize / 2) | 0;
    return Math.max(nextSize, 1);
}
/**
 * Allocate a texture in GPU memory, without providing any image data.
 *
 * @param {Texture} texture The texture to be initialized with null values.
 *
 * @private
 */ function loadNull(texture) {
    const context = texture._context;
    context._gl.texImage2D(texture._textureTarget, 0, texture._internalFormat, texture._width, texture._height, 0, texture._pixelFormat, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toWebGLConstant(texture._pixelDatatype, context), null);
}
/**
 * This function is identical to using the Texture constructor except that it can be
 * replaced with a mock/spy in tests.
 * @private
 */ Texture.create = function(options) {
    return new Texture(options);
};
/**
 * Creates a texture, and copies a subimage of the framebuffer to it.  When called without arguments,
 * the texture is the same width and height as the framebuffer and contains its contents.
 *
 * @param {object} options Object with the following properties:
 * @param {Context} options.context The context in which the Texture gets created.
 * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGB] The texture's internal pixel format.
 * @param {number} [options.framebufferXOffset=0] An offset in the x direction in the framebuffer where copying begins from.
 * @param {number} [options.framebufferYOffset=0] An offset in the y direction in the framebuffer where copying begins from.
 * @param {number} [options.width=canvas.clientWidth] The width of the texture in texels.
 * @param {number} [options.height=canvas.clientHeight] The height of the texture in texels.
 * @param {Framebuffer} [options.framebuffer=defaultFramebuffer] The framebuffer from which to create the texture.  If this
 *        parameter is not specified, the default framebuffer is used.
 * @returns {Texture} A texture with contents from the framebuffer.
 *
 * @exception {DeveloperError} Invalid pixelFormat.
 * @exception {DeveloperError} pixelFormat cannot be DEPTH_COMPONENT, DEPTH_STENCIL or a compressed format.
 * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.
 * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.
 * @exception {DeveloperError} framebufferXOffset + width must be less than or equal to canvas.clientWidth.
 * @exception {DeveloperError} framebufferYOffset + height must be less than or equal to canvas.clientHeight.
 *
 *
 * @example
 * // Create a texture with the contents of the framebuffer.
 * const t = Texture.fromFramebuffer({
 *     context : context
 * });
 *
 * @see Sampler
 *
 * @private
 */ Texture.fromFramebuffer = function(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.context", options.context);
    //>>includeEnd('debug');
    const context = options.context;
    const { pixelFormat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGB, framebufferXOffset = 0, framebufferYOffset = 0, width = context.drawingBufferWidth, height = context.drawingBufferHeight, framebuffer } = options;
    //>>includeStart('debug', pragmas.debug);
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(pixelFormat)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid pixelFormat.");
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isDepthFormat(pixelFormat) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isCompressedFormat(pixelFormat)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("pixelFormat cannot be DEPTH_COMPONENT, DEPTH_STENCIL or a compressed format.");
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.context", context);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("framebufferXOffset", framebufferXOffset, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("framebufferYOffset", framebufferYOffset, 0);
    if (framebufferXOffset + width > context.drawingBufferWidth) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("framebufferXOffset + width must be less than or equal to drawingBufferWidth");
    }
    if (framebufferYOffset + height > context.drawingBufferHeight) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("framebufferYOffset + height must be less than or equal to drawingBufferHeight.");
    }
    //>>includeEnd('debug');
    const texture = new Texture({
        context: context,
        width: width,
        height: height,
        pixelFormat: pixelFormat,
        source: {
            framebuffer: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(framebuffer) ? framebuffer : context.defaultFramebuffer,
            xOffset: framebufferXOffset,
            yOffset: framebufferYOffset,
            width: width,
            height: height
        }
    });
    return texture;
};
Object.defineProperties(Texture.prototype, {
    /**
   * A unique id for the texture
   * @memberof Texture.prototype
   * @type {string}
   * @readonly
   * @private
   */ id: {
        get: function() {
            return this._id;
        }
    },
    /**
   * The sampler to use when sampling this texture.
   * Create a sampler by calling {@link Sampler}.  If this
   * parameter is not specified, a default sampler is used.  The default sampler clamps texture
   * coordinates in both directions, uses linear filtering for both magnification and minification,
   * and uses a maximum anisotropy of 1.0.
   * @memberof Texture.prototype
   * @type {Sampler}
   * @private
   */ sampler: {
        get: function() {
            return this._sampler;
        },
        set: function(sampler) {
            setupSampler(this, sampler);
            this._sampler = sampler;
        }
    },
    pixelFormat: {
        get: function() {
            return this._pixelFormat;
        }
    },
    pixelDatatype: {
        get: function() {
            return this._pixelDatatype;
        }
    },
    dimensions: {
        get: function() {
            return this._dimensions;
        }
    },
    preMultiplyAlpha: {
        get: function() {
            return this._preMultiplyAlpha;
        }
    },
    flipY: {
        get: function() {
            return this._flipY;
        }
    },
    width: {
        get: function() {
            return this._width;
        }
    },
    height: {
        get: function() {
            return this._height;
        }
    },
    sizeInBytes: {
        get: function() {
            if (this._hasMipmap) {
                return Math.floor(this._sizeInBytes * 4 / 3);
            }
            return this._sizeInBytes;
        }
    },
    _target: {
        get: function() {
            return this._textureTarget;
        }
    }
});
/**
 * Set up a sampler for use with a texture
 * @param {Texture} texture The texture to be sampled by this sampler
 * @param {Sampler} sampler Information about how to sample the texture
 * @private
 */ function setupSampler(texture, sampler) {
    let { minificationFilter, magnificationFilter } = sampler;
    const mipmap = [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST_MIPMAP_NEAREST,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST_MIPMAP_LINEAR,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LINEAR_MIPMAP_NEAREST,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LINEAR_MIPMAP_LINEAR
    ].includes(minificationFilter);
    const context = texture._context;
    const pixelFormat = texture._pixelFormat;
    const pixelDatatype = texture._pixelDatatype;
    // float textures only support nearest filtering unless the linear extensions are supported
    if (pixelDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT && !context.textureFloatLinear || pixelDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT && !context.textureHalfFloatLinear) {
        // override the sampler's settings
        minificationFilter = mipmap ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST_MIPMAP_NEAREST : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST;
        magnificationFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMagnificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST;
    }
    // WebGL 2 depth texture only support nearest filtering. See section 3.8.13 OpenGL ES 3 spec
    if (context.webgl2) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isDepthFormat(pixelFormat)) {
            minificationFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMinificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST;
            magnificationFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureMagnificationFilter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST;
        }
    }
    const gl = context._gl;
    const target = texture._textureTarget;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(target, texture._texture);
    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minificationFilter);
    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magnificationFilter);
    gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);
    gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(texture._textureFilterAnisotropic)) {
        gl.texParameteri(target, texture._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, sampler.maximumAnisotropy);
    }
    gl.bindTexture(target, null);
}
/**
 * Copy new image data into this texture, from a source {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement}, or {@link HTMLVideoElement}.
 * or an object with width, height, and arrayBufferView properties.
 * @param {object} options Object with the following properties:
 * @param {object} options.source The source {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement}, {@link HTMLVideoElement},
 *                        {@link OffscreenCanvas}, or {@link ImageBitmap},
 *                        or an object with width, height, and arrayBufferView properties.
 * @param {number} [options.xOffset=0] The offset in the x direction within the texture to copy into.
 * @param {number} [options.yOffset=0] The offset in the y direction within the texture to copy into.
 * @param {boolean} [options.skipColorSpaceConversion=false] If true, any custom gamma or color profiles in the texture will be ignored.
 *
 * @exception {DeveloperError} Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.
 * @exception {DeveloperError} Cannot call copyFrom with a compressed texture pixel format.
 * @exception {DeveloperError} xOffset must be greater than or equal to zero.
 * @exception {DeveloperError} yOffset must be greater than or equal to zero.
 * @exception {DeveloperError} xOffset + source.width must be less than or equal to width.
 * @exception {DeveloperError} yOffset + source.height must be less than or equal to height.
 * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
 * @private
 * @example
 * texture.copyFrom({
 *  source: {
 *   width : 1,
 *   height : 1,
 *   arrayBufferView : new Uint8Array([255, 0, 0, 255])
 *  }
 * });
 */ Texture.prototype.copyFrom = function(options) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options", options);
    //>>includeEnd('debug');
    const { xOffset = 0, yOffset = 0, source, skipColorSpaceConversion = false } = options;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.source", source);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isDepthFormat(this._pixelFormat)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.");
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isCompressedFormat(this._pixelFormat)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot call copyFrom with a compressed texture pixel format.");
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.lessThanOrEquals("xOffset + options.source.width", xOffset + source.width, this._width);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.lessThanOrEquals("yOffset + options.source.height", yOffset + source.height, this._height);
    //>>includeEnd('debug');
    const context = this._context;
    const gl = context._gl;
    const target = this._textureTarget;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(target, this._texture);
    let { width, height } = source;
    // Make sure we are using the element's intrinsic width and height where available
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source.videoWidth) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source.videoHeight)) {
        width = source.videoWidth;
        height = source.videoHeight;
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source.naturalWidth) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source.naturalHeight)) {
        width = source.naturalWidth;
        height = source.naturalHeight;
    }
    if (skipColorSpaceConversion) {
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    } else {
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.BROWSER_DEFAULT_WEBGL);
    }
    let uploaded = false;
    if (!this._initialized) {
        if (xOffset === 0 && yOffset === 0 && width === this._width && height === this._height) {
            // initialize the entire texture
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source.arrayBufferView)) {
                loadBufferSource(this, source);
            } else {
                loadImageSource(this, source);
            }
            uploaded = true;
        } else {
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            loadNull(this);
        }
        this._initialized = true;
    }
    if (!uploaded) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(source.arrayBufferView)) {
            loadPartialBufferSource(this, source.arrayBufferView, xOffset, yOffset, width, height);
        } else {
            loadPartialImageSource(this, source, xOffset, yOffset);
        }
    }
    gl.bindTexture(target, null);
};
/**
 * @param {number} [xOffset=0] The offset in the x direction within the texture to copy into.
 * @param {number} [yOffset=0] The offset in the y direction within the texture to copy into.
 * @param {number} [framebufferXOffset=0] optional
 * @param {number} [framebufferYOffset=0] optional
 * @param {number} [width=width] optional
 * @param {number} [height=height] optional
 * @private
 * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.
 * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.
 * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.
 * @exception {DeveloperError} Cannot call copyFrom with a compressed texture pixel format.
 * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
 * @exception {DeveloperError} xOffset must be greater than or equal to zero.
 * @exception {DeveloperError} yOffset must be greater than or equal to zero.
 * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.
 * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.
 * @exception {DeveloperError} xOffset + width must be less than or equal to width.
 * @exception {DeveloperError} yOffset + height must be less than or equal to height.
 */ Texture.prototype.copyFromFramebuffer = function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
    xOffset = xOffset ?? 0;
    yOffset = yOffset ?? 0;
    framebufferXOffset = framebufferXOffset ?? 0;
    framebufferYOffset = framebufferYOffset ?? 0;
    width = width ?? this._width;
    height = height ?? this._height;
    //>>includeStart('debug', pragmas.debug);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isDepthFormat(this._pixelFormat)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.");
    }
    if (this._pixelDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.");
    }
    if (this._pixelDatatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.");
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isCompressedFormat(this._pixelFormat)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot call copyFrom with a compressed texture pixel format.");
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("framebufferXOffset", framebufferXOffset, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("framebufferYOffset", framebufferYOffset, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.lessThanOrEquals("xOffset + width", xOffset + width, this._width);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.lessThanOrEquals("yOffset + height", yOffset + height, this._height);
    //>>includeEnd('debug');
    const gl = this._context._gl;
    const target = this._textureTarget;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(target, this._texture);
    gl.copyTexSubImage2D(target, 0, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
    gl.bindTexture(target, null);
    this._initialized = true;
};
/**
 * @param {MipmapHint} [hint=MipmapHint.DONT_CARE] optional.
 * @private
 * @exception {DeveloperError} Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.
 * @exception {DeveloperError} Cannot call generateMipmap when the texture pixel format is a compressed format.
 * @exception {DeveloperError} hint is invalid.
 * @exception {DeveloperError} This texture's width must be a power of two to call generateMipmap() in a WebGL1 context.
 * @exception {DeveloperError} This texture's height must be a power of two to call generateMipmap() in a WebGL1 context.
 * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
 */ Texture.prototype.generateMipmap = function(hint) {
    hint = hint ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$MipmapHint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DONT_CARE;
    //>>includeStart('debug', pragmas.debug);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isDepthFormat(this._pixelFormat)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.");
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isCompressedFormat(this._pixelFormat)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot call generateMipmap with a compressed pixel format.");
    }
    if (!this._context.webgl2) {
        if (this._width > 1 && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isPowerOfTwo(this._width)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("width must be a power of two to call generateMipmap() in a WebGL1 context.");
        }
        if (this._height > 1 && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isPowerOfTwo(this._height)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("height must be a power of two to call generateMipmap() in a WebGL1 context.");
        }
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$MipmapHint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(hint)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("hint is invalid.");
    }
    //>>includeEnd('debug');
    this._hasMipmap = true;
    const gl = this._context._gl;
    const target = this._textureTarget;
    gl.hint(gl.GENERATE_MIPMAP_HINT, hint);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(target, this._texture);
    gl.generateMipmap(target);
    gl.bindTexture(target, null);
};
Texture.prototype.isDestroyed = function() {
    return false;
};
Texture.prototype.destroy = function() {
    this._context._gl.deleteTexture(this._texture);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
};
const __TURBOPACK__default__export__ = Texture;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/VertexArrayFacade.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/ComponentDatatype.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/destroyObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$BufferUsage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/BufferUsage.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$VertexArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/VertexArray.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
/**
 * @private
 */ function VertexArrayFacade(context, attributes, sizeInVertices, instanced) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("context", context);
    if (!attributes || attributes.length === 0) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("At least one attribute is required.");
    }
    //>>includeEnd('debug');
    const attrs = VertexArrayFacade._verifyAttributes(attributes);
    sizeInVertices = sizeInVertices ?? 0;
    const precreatedAttributes = [];
    const attributesByUsage = {};
    let attributesForUsage;
    let usage;
    // Bucket the attributes by usage.
    const length = attrs.length;
    for(let i = 0; i < length; ++i){
        const attribute = attrs[i];
        // If the attribute already has a vertex buffer, we do not need
        // to manage a vertex buffer or typed array for it.
        if (attribute.vertexBuffer) {
            precreatedAttributes.push(attribute);
            continue;
        }
        usage = attribute.usage;
        attributesForUsage = attributesByUsage[usage];
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attributesForUsage)) {
            attributesForUsage = attributesByUsage[usage] = [];
        }
        attributesForUsage.push(attribute);
    }
    // A function to sort attributes by the size of their components.  From left to right, a vertex
    // stores floats, shorts, and then bytes.
    function compare(left, right) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getSizeInBytes(right.componentDatatype) - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getSizeInBytes(left.componentDatatype);
    }
    this._allBuffers = [];
    for(usage in attributesByUsage){
        if (attributesByUsage.hasOwnProperty(usage)) {
            attributesForUsage = attributesByUsage[usage];
            attributesForUsage.sort(compare);
            const vertexSizeInBytes = VertexArrayFacade._vertexSizeInBytes(attributesForUsage);
            const bufferUsage = attributesForUsage[0].usage;
            const buffer = {
                vertexSizeInBytes: vertexSizeInBytes,
                vertexBuffer: undefined,
                usage: bufferUsage,
                needsCommit: false,
                arrayBuffer: undefined,
                arrayViews: VertexArrayFacade._createArrayViews(attributesForUsage, vertexSizeInBytes)
            };
            this._allBuffers.push(buffer);
        }
    }
    this._size = 0;
    this._instanced = instanced ?? false;
    this._precreated = precreatedAttributes;
    this._context = context;
    this.writers = undefined;
    this.va = undefined;
    this.resize(sizeInVertices);
}
VertexArrayFacade._verifyAttributes = function(attributes) {
    const attrs = [];
    for(let i = 0; i < attributes.length; ++i){
        const attribute = attributes[i];
        const attr = {
            index: attribute.index ?? i,
            enabled: attribute.enabled ?? true,
            componentsPerAttribute: attribute.componentsPerAttribute,
            componentDatatype: attribute.componentDatatype ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
            normalize: attribute.normalize ?? false,
            // There will be either a vertexBuffer or an [optional] usage.
            vertexBuffer: attribute.vertexBuffer,
            usage: attribute.usage ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$BufferUsage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].STATIC_DRAW
        };
        attrs.push(attr);
        //>>includeStart('debug', pragmas.debug);
        if (attr.componentsPerAttribute !== 1 && attr.componentsPerAttribute !== 2 && attr.componentsPerAttribute !== 3 && attr.componentsPerAttribute !== 4) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("attribute.componentsPerAttribute must be in the range [1, 4].");
        }
        const datatype = attr.componentDatatype;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(datatype)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Attribute must have a valid componentDatatype or not specify it.");
        }
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$BufferUsage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(attr.usage)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Attribute must have a valid usage or not specify it.");
        }
    //>>includeEnd('debug');
    }
    // Verify all attribute names are unique.
    const uniqueIndices = new Array(attrs.length);
    for(let j = 0; j < attrs.length; ++j){
        const currentAttr = attrs[j];
        const index = currentAttr.index;
        //>>includeStart('debug', pragmas.debug);
        if (uniqueIndices[index]) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Index ${index} is used by more than one attribute.`);
        }
        //>>includeEnd('debug');
        uniqueIndices[index] = true;
    }
    return attrs;
};
VertexArrayFacade._vertexSizeInBytes = function(attributes) {
    let sizeInBytes = 0;
    const length = attributes.length;
    for(let i = 0; i < length; ++i){
        const attribute = attributes[i];
        sizeInBytes += attribute.componentsPerAttribute * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getSizeInBytes(attribute.componentDatatype);
    }
    const maxComponentSizeInBytes = length > 0 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getSizeInBytes(attributes[0].componentDatatype) : 0; // Sorted by size
    const remainder = maxComponentSizeInBytes > 0 ? sizeInBytes % maxComponentSizeInBytes : 0;
    const padding = remainder === 0 ? 0 : maxComponentSizeInBytes - remainder;
    sizeInBytes += padding;
    return sizeInBytes;
};
VertexArrayFacade._createArrayViews = function(attributes, vertexSizeInBytes) {
    const views = [];
    let offsetInBytes = 0;
    const length = attributes.length;
    for(let i = 0; i < length; ++i){
        const attribute = attributes[i];
        const componentDatatype = attribute.componentDatatype;
        views.push({
            index: attribute.index,
            enabled: attribute.enabled,
            componentsPerAttribute: attribute.componentsPerAttribute,
            componentDatatype: componentDatatype,
            normalize: attribute.normalize,
            offsetInBytes: offsetInBytes,
            vertexSizeInComponentType: vertexSizeInBytes / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getSizeInBytes(componentDatatype),
            view: undefined
        });
        offsetInBytes += attribute.componentsPerAttribute * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getSizeInBytes(componentDatatype);
    }
    return views;
};
/**
 * Invalidates writers.  Can't render again until commit is called.
 */ VertexArrayFacade.prototype.resize = function(sizeInVertices) {
    this._size = sizeInVertices;
    const allBuffers = this._allBuffers;
    this.writers = [];
    for(let i = 0, len = allBuffers.length; i < len; ++i){
        const buffer = allBuffers[i];
        VertexArrayFacade._resize(buffer, this._size);
        // Reserving invalidates the writers, so if client's cache them, they need to invalidate their cache.
        VertexArrayFacade._appendWriters(this.writers, buffer);
    }
    // VAs are recreated next time commit is called.
    destroyVA(this);
};
VertexArrayFacade._resize = function(buffer, size) {
    if (buffer.vertexSizeInBytes > 0) {
        // Create larger array buffer
        const arrayBuffer = new ArrayBuffer(size * buffer.vertexSizeInBytes);
        // Copy contents from previous array buffer
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(buffer.arrayBuffer)) {
            const destView = new Uint8Array(arrayBuffer);
            const sourceView = new Uint8Array(buffer.arrayBuffer);
            const sourceLength = sourceView.length;
            for(let j = 0; j < sourceLength; ++j){
                destView[j] = sourceView[j];
            }
        }
        // Create typed views into the new array buffer
        const views = buffer.arrayViews;
        const length = views.length;
        for(let i = 0; i < length; ++i){
            const view = views[i];
            view.view = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createArrayBufferView(view.componentDatatype, arrayBuffer, view.offsetInBytes);
        }
        buffer.arrayBuffer = arrayBuffer;
    }
};
const createWriters = [
    // 1 component per attribute
    function(buffer, view, vertexSizeInComponentType) {
        return function(index, attribute) {
            view[index * vertexSizeInComponentType] = attribute;
            buffer.needsCommit = true;
        };
    },
    // 2 component per attribute
    function(buffer, view, vertexSizeInComponentType) {
        return function(index, component0, component1) {
            const i = index * vertexSizeInComponentType;
            view[i] = component0;
            view[i + 1] = component1;
            buffer.needsCommit = true;
        };
    },
    // 3 component per attribute
    function(buffer, view, vertexSizeInComponentType) {
        return function(index, component0, component1, component2) {
            const i = index * vertexSizeInComponentType;
            view[i] = component0;
            view[i + 1] = component1;
            view[i + 2] = component2;
            buffer.needsCommit = true;
        };
    },
    // 4 component per attribute
    function(buffer, view, vertexSizeInComponentType) {
        return function(index, component0, component1, component2, component3) {
            const i = index * vertexSizeInComponentType;
            view[i] = component0;
            view[i + 1] = component1;
            view[i + 2] = component2;
            view[i + 3] = component3;
            buffer.needsCommit = true;
        };
    }
];
VertexArrayFacade._appendWriters = function(writers, buffer) {
    const arrayViews = buffer.arrayViews;
    const length = arrayViews.length;
    for(let i = 0; i < length; ++i){
        const arrayView = arrayViews[i];
        writers[arrayView.index] = createWriters[arrayView.componentsPerAttribute - 1](buffer, arrayView.view, arrayView.vertexSizeInComponentType);
    }
};
VertexArrayFacade.prototype.commit = function(indexBuffer) {
    let recreateVA = false;
    const allBuffers = this._allBuffers;
    let buffer;
    let i;
    let length;
    for(i = 0, length = allBuffers.length; i < length; ++i){
        buffer = allBuffers[i];
        recreateVA = commit(this, buffer) || recreateVA;
    }
    ///////////////////////////////////////////////////////////////////////
    if (recreateVA || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.va)) {
        destroyVA(this);
        const va = this.va = [];
        const chunkSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SIXTY_FOUR_KILOBYTES - 4; // The 65535 index is reserved for primitive restart. Reserve the last 4 indices so that billboard quads are not broken up.
        const numberOfVertexArrays = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(indexBuffer) && !this._instanced ? Math.ceil(this._size / chunkSize) : 1;
        for(let k = 0; k < numberOfVertexArrays; ++k){
            let attributes = [];
            for(i = 0, length = allBuffers.length; i < length; ++i){
                buffer = allBuffers[i];
                const offset = k * (buffer.vertexSizeInBytes * chunkSize);
                VertexArrayFacade._appendAttributes(attributes, buffer, offset, this._instanced);
            }
            attributes = attributes.concat(this._precreated);
            va.push({
                va: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$VertexArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    context: this._context,
                    attributes: attributes,
                    indexBuffer: indexBuffer
                }),
                indicesCount: 1.5 * (k !== numberOfVertexArrays - 1 ? chunkSize : this._size % chunkSize)
            });
        }
    }
};
function commit(vertexArrayFacade, buffer) {
    if (buffer.needsCommit && buffer.vertexSizeInBytes > 0) {
        buffer.needsCommit = false;
        const vertexBuffer = buffer.vertexBuffer;
        const vertexBufferSizeInBytes = vertexArrayFacade._size * buffer.vertexSizeInBytes;
        const vertexBufferDefined = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(vertexBuffer);
        if (!vertexBufferDefined || vertexBuffer.sizeInBytes < vertexBufferSizeInBytes) {
            if (vertexBufferDefined) {
                vertexBuffer.destroy();
            }
            buffer.vertexBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createVertexBuffer({
                context: vertexArrayFacade._context,
                typedArray: buffer.arrayBuffer,
                usage: buffer.usage
            });
            buffer.vertexBuffer.vertexArrayDestroyable = false;
            return true; // Created new vertex buffer
        }
        buffer.vertexBuffer.copyFromArrayView(buffer.arrayBuffer);
    }
    return false; // Did not create new vertex buffer
}
VertexArrayFacade._appendAttributes = function(attributes, buffer, vertexBufferOffset, instanced) {
    const arrayViews = buffer.arrayViews;
    const length = arrayViews.length;
    for(let i = 0; i < length; ++i){
        const view = arrayViews[i];
        attributes.push({
            index: view.index,
            enabled: view.enabled,
            componentsPerAttribute: view.componentsPerAttribute,
            componentDatatype: view.componentDatatype,
            normalize: view.normalize,
            vertexBuffer: buffer.vertexBuffer,
            offsetInBytes: vertexBufferOffset + view.offsetInBytes,
            strideInBytes: buffer.vertexSizeInBytes,
            instanceDivisor: instanced ? 1 : 0
        });
    }
};
VertexArrayFacade.prototype.subCommit = function(offsetInVertices, lengthInVertices) {
    //>>includeStart('debug', pragmas.debug);
    if (offsetInVertices < 0 || offsetInVertices >= this._size) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("offsetInVertices must be greater than or equal to zero and less than the vertex array size.");
    }
    if (offsetInVertices + lengthInVertices > this._size) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("offsetInVertices + lengthInVertices cannot exceed the vertex array size.");
    }
    //>>includeEnd('debug');
    const allBuffers = this._allBuffers;
    for(let i = 0, len = allBuffers.length; i < len; ++i){
        subCommit(allBuffers[i], offsetInVertices, lengthInVertices);
    }
};
function subCommit(buffer, offsetInVertices, lengthInVertices) {
    if (buffer.needsCommit && buffer.vertexSizeInBytes > 0) {
        const byteOffset = buffer.vertexSizeInBytes * offsetInVertices;
        const byteLength = buffer.vertexSizeInBytes * lengthInVertices;
        // PERFORMANCE_IDEA: If we want to get really crazy, we could consider updating
        // individual attributes instead of the entire (sub-)vertex.
        //
        // PERFORMANCE_IDEA: Does creating the typed view add too much GC overhead?
        buffer.vertexBuffer.copyFromArrayView(new Uint8Array(buffer.arrayBuffer, byteOffset, byteLength), byteOffset);
    }
}
VertexArrayFacade.prototype.endSubCommits = function() {
    const allBuffers = this._allBuffers;
    for(let i = 0, len = allBuffers.length; i < len; ++i){
        allBuffers[i].needsCommit = false;
    }
};
function destroyVA(vertexArrayFacade) {
    const va = vertexArrayFacade.va;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(va)) {
        return;
    }
    const length = va.length;
    for(let i = 0; i < length; ++i){
        va[i].va.destroy();
    }
    vertexArrayFacade.va = undefined;
}
VertexArrayFacade.prototype.isDestroyed = function() {
    return false;
};
VertexArrayFacade.prototype.destroy = function() {
    const allBuffers = this._allBuffers;
    for(let i = 0, len = allBuffers.length; i < len; ++i){
        const buffer = allBuffers[i];
        buffer.vertexBuffer = buffer.vertexBuffer && buffer.vertexBuffer.destroy();
    }
    destroyVA(this);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
};
const __TURBOPACK__default__export__ = VertexArrayFacade;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/TextureAtlas.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoundingRectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/BoundingRectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartesian2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$createGuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/createGuid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/destroyObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/PixelFormat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Resource.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/RuntimeError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$TexturePacker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/TexturePacker.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Framebuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Texture.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const defaultInitialDimensions = 16;
/**
 * A TextureAtlas stores multiple images in one texture and keeps
 * track of the texture coordinates for each image. A TextureAtlas is dynamic,
 * meaning new images can be added at any point in time.
 * Texture coordinates are subject to change if the texture atlas resizes, so it's
 * important to check {@link TextureAtlas#guid} before using old values.
 *
 * @alias TextureAtlas
 * @constructor
 *
 * @param {object} options Object with the following properties:
 * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGBA] The pixel format of the texture.
 * @param {Sampler} [options.sampler=new Sampler()] Information about how to sample the texture.
 * @param {number} [options.borderWidthInPixels=1] The amount of spacing between adjacent images in pixels.
 * @param {Cartesian2} [options.initialSize=new Cartesian2(16.0, 16.0)] The initial side lengths of the texture.
 *
 * @exception {DeveloperError} borderWidthInPixels must be greater than or equal to zero.
 * @exception {DeveloperError} initialSize must be greater than zero.
 *
 * @private
 */ function TextureAtlas(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const borderWidthInPixels = options.borderWidthInPixels ?? 1.0;
    const initialSize = options.initialSize ?? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](defaultInitialDimensions, defaultInitialDimensions);
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("options.borderWidthInPixels", borderWidthInPixels, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThan("options.initialSize.x", initialSize.x, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThan("options.initialSize.y", initialSize.y, 0);
    //>>includeEnd('debug');
    this._pixelFormat = options.pixelFormat ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGBA;
    this._sampler = options.sampler;
    this._borderWidthInPixels = borderWidthInPixels;
    this._initialSize = initialSize;
    this._texturePacker = undefined;
    /** @type {BoundingRectangle[]} */ this._rectangles = [];
    /** @type {Map<number, number>} */ this._subRegions = new Map();
    this._guid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$createGuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
    this._imagesToAddQueue = [];
    /** @type {Map<string, number>} */ this._indexById = new Map();
    /** @type {Map<string, Promise<number>>} */ this._indexPromiseById = new Map();
    this._nextIndex = 0;
}
Object.defineProperties(TextureAtlas.prototype, {
    /**
   * The amount of spacing between adjacent images in pixels.
   * @memberof TextureAtlas.prototype
   * @type {number}
   * @readonly
   * @private
   */ borderWidthInPixels: {
        get: function() {
            return this._borderWidthInPixels;
        }
    },
    /**
   * An array of {@link BoundingRectangle} pixel offset and dimensions for all the images in the texture atlas.
   * The x and y values of the rectangle correspond to the bottom-left corner of the texture coordinate.
   * If the index is a subregion of an existing image, thea and y values are specified as offsets relative to the parent.
   * The coordinates are in the order that the corresponding images were added to the atlas.
   * @memberof TextureAtlas.prototype
   * @type {BoundingRectangle[]}
   * @readonly
   * @private
   */ rectangles: {
        get: function() {
            return this._rectangles;
        }
    },
    /**
   * The texture that all of the images are being written to. The value will be <code>undefined</code> until the first update.
   * @memberof TextureAtlas.prototype
   * @type {Texture|undefined}
   * @readonly
   * @private
   */ texture: {
        get: function() {
            return this._texture;
        }
    },
    /**
   * The pixel format of the texture.
   * @memberof TextureAtlas.prototype
   * @type {PixelFormat}
   * @readonly
   * @private
   */ pixelFormat: {
        get: function() {
            return this._pixelFormat;
        }
    },
    /**
   * The sampler to use when sampling this texture. If <code>undefined</code>, the default sampler is used.
   * @memberof TextureAtlas.prototype
   * @type {Sampler|undefined}
   * @readonly
   * @private
   */ sampler: {
        get: function() {
            return this._sampler;
        }
    },
    /**
   * The number of images in the texture atlas. This value increases
   * every time addImage or addImageSubRegion is called.
   * Texture coordinates are subject to change if the texture atlas resizes, so it is
   * important to check {@link TextureAtlas#guid} before using old values.
   * @memberof TextureAtlas.prototype
   * @type {number}
   * @readonly
   * @private
   */ numberOfImages: {
        get: function() {
            return this._nextIndex;
        }
    },
    /**
   * The atlas' globally unique identifier (GUID).
   * The GUID changes whenever the texture atlas is modified.
   * Classes that use a texture atlas should check if the GUID
   * has changed before processing the atlas data.
   * @memberof TextureAtlas.prototype
   * @type {string}
   * @readonly
   * @private
   */ guid: {
        get: function() {
            return this._guid;
        }
    },
    /**
   * Returns the size in bytes of the texture.
   * @memberof TextureAtlas.prototype
   * @type {number}
   * @readonly
   * @private
   */ sizeInBytes: {
        get: function() {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._texture)) {
                return 0;
            }
            return this._texture.sizeInBytes;
        }
    }
});
/**
 * Get the texture coordinates for reading the associated image in shaders.
 * @param {number} index The index of the image region.
 * @param {BoundingRectangle} [result] The object into which to store the result.
 * @return {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.
 * @private
 * @example
 * const index = await atlas.addImage("myImage", image);
 * const rectangle = atlas.computeTextureCoordinates(index);
 * BoundingRectangle.pack(rectangle, bufferView);
 */ TextureAtlas.prototype.computeTextureCoordinates = function(index, result) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("index", index, 0);
    //>>includeEnd('debug');
    const texture = this._texture;
    const rectangle = this._rectangles[index];
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result)) {
        result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoundingRectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(rectangle)) {
        result.x = 0;
        result.y = 0;
        result.width = 0;
        result.height = 0;
        return result;
    }
    const atlasWidth = texture.width;
    const atlasHeight = texture.height;
    const width = rectangle.width;
    const height = rectangle.height;
    let x = rectangle.x;
    let y = rectangle.y;
    const parentIndex = this._subRegions.get(index);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(parentIndex)) {
        const parentRectangle = this._rectangles[parentIndex];
        x += parentRectangle.x;
        y += parentRectangle.y;
    }
    result.x = x / atlasWidth;
    result.y = y / atlasHeight;
    result.width = width / atlasWidth;
    result.height = height / atlasHeight;
    return result;
};
/**
 * Perform a WebGL texture copy for each existing image from its previous packed position to its new packed position in the new texture.
 * @param {Context} context The rendering context
 * @param {number} width The pixel width of the texture
 * @param {number} height The pixel height of the texture
 * @param {BoundingRectangle[]} rectangles The packed bounding rectangles for the reszied texture
 * @param {number} queueOffset Index of the last queued item that was successfully packed
 * @private
 */ TextureAtlas.prototype._copyFromTexture = function(context, width, height, rectangles) {
    const pixelFormat = this._pixelFormat;
    const sampler = this._sampler;
    const newTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        context,
        height,
        width,
        pixelFormat,
        sampler
    });
    const gl = context._gl;
    const target = newTexture._textureTarget;
    const oldTexture = this._texture;
    const framebuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        context,
        colorTextures: [
            oldTexture
        ],
        destroyAttachments: false
    });
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(target, newTexture._texture);
    framebuffer._bind();
    // Copy any textures from the old atlas to its new position in the new atlas
    const oldRectangles = this.rectangles;
    const subRegions = this._subRegions;
    for(let index = 0; index < oldRectangles.length; ++index){
        const rectangle = rectangles[index];
        const frameBufferOffset = oldRectangles[index];
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(rectangle) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(frameBufferOffset) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(subRegions.get(index)) // The rectangle corresponds to a subregion of a parent image
        ) {
            continue;
        }
        const { x, y, width, height } = rectangle;
        gl.copyTexSubImage2D(target, 0, x, y, frameBufferOffset.x, frameBufferOffset.y, width, height);
    }
    gl.bindTexture(target, null);
    newTexture._initialized = true;
    framebuffer._unBind();
    framebuffer.destroy();
    return newTexture;
};
/**
 * Recreates the texture atlas texture with new dimensions and repacks images as needed.
 * @param {Context} context The rendering context
 * @param {number} [queueOffset = 0] Index of the last queued item that was successfully packed
 * @private
 */ TextureAtlas.prototype._resize = function(context, queueOffset = 0) {
    const borderPadding = this._borderWidthInPixels;
    const oldRectangles = this._rectangles;
    const queue = this._imagesToAddQueue;
    const oldTexture = this._texture;
    let width = oldTexture.width;
    let height = oldTexture.height;
    // Get the rectangles (width and height) of the current set of images,
    // ignoring the subregions, which don't get packed
    const subRegions = this._subRegions;
    const toPack = oldRectangles.map((image, index)=>{
        return new AddImageRequest({
            index,
            image
        });
    }).filter((request, index)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(request.image) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(subRegions.get(index)));
    // Add the new set of images
    let maxWidth = 0;
    let maxHeight = 0;
    let areaQueued = 0;
    for(let i = queueOffset; i < queue.length; ++i){
        const { width, height } = queue[i].image;
        maxWidth = Math.max(maxWidth, width);
        maxHeight = Math.max(maxHeight, height);
        areaQueued += width * height;
        toPack.push(queue[i]);
    }
    // At minimum, atlas must fit its largest input images. Texture coordinates are
    // compressed to 01 with 12-bit precision, so use power-of-two size to align pixels.
    width = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextPowerOfTwo(Math.max(maxWidth, width));
    height = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextPowerOfTwo(Math.max(maxHeight, height));
    // Iteratively double the smallest dimension until atlas area is (approximately) sufficient.
    while(areaQueued >= width * height){
        if (width > height) {
            height *= 2;
        } else {
            width *= 2;
        }
    }
    toPack.sort(({ image: imageA }, { image: imageB })=>imageB.height * imageB.width - imageA.height * imageA.width);
    const newRectangles = new Array(this._nextIndex);
    for (const index of this._subRegions.keys()){
        // Subregions are specified relative to their parents,
        // so we can copy them directly
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(subRegions.get(index))) {
            newRectangles[index] = oldRectangles[index];
        }
    }
    let texturePacker, packed = false;
    while(!packed){
        texturePacker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$TexturePacker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            height,
            width,
            borderPadding
        });
        let i;
        for(i = 0; i < toPack.length; ++i){
            const { index, image } = toPack[i];
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(image)) {
                continue;
            }
            const repackedNode = texturePacker.pack(index, image);
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(repackedNode)) {
                // Could not fit everything into the new texture.
                // Scale texture size and try again
                if (width > height) {
                    // Resize height
                    height *= 2.0;
                } else {
                    // Resize width
                    width *= 2.0;
                }
                break;
            }
            newRectangles[index] = repackedNode.rectangle;
        }
        packed = i === toPack.length;
    }
    this._texturePacker = texturePacker;
    this._texture = this._copyFromTexture(context, width, height, newRectangles);
    oldTexture.destroy();
    this._rectangles = newRectangles;
    this._guid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$createGuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
};
/**
 * Return the index of the image region for the specified ID. If the image is already in the atlas, the existing index is returned. Otherwise, the result is undefined.
 * @param {string} id An identifier to detect whether the image already exists in the atlas.
 * @returns {number|undefined} The image index, or undefined if the image does not exist in the atlas.
 * @private
 */ TextureAtlas.prototype.getImageIndex = function(id) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("id", id);
    //>>includeEnd('debug');
    return this._indexById.get(id);
};
/**
 * Copy image data into the underlying texture atlas.
 * @param {AddImageRequest} imageRequest The data needed to resolve the call to addImage in the queue
 * @private
 */ TextureAtlas.prototype._copyImageToTexture = function({ index, image, resolve, reject }) {
    const texture = this._texture;
    const rectangle = this._rectangles[index];
    try {
        texture.copyFrom({
            source: image,
            xOffset: rectangle.x,
            yOffset: rectangle.y
        });
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(resolve)) {
            resolve(index);
        }
    } catch (e) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(reject)) {
            reject(e);
            return;
        }
    }
};
/**
 * Info needed to add a queued image to the texture atlas when update operatons are executed, typically at the end of a frame.
 * @constructor
 * @private
 * @param {object} options Object with the following properties:
 * @param {number} options.index An identifier
 * @param {TexturePacker.PackableObject} options.image An object, such as an <code>Image</code> with <code>width</code> and <code>height</code> properties in pixels
 * @param {function} [options.resolve] The promise resolver
 * @param {function} [options.reject] The promise rejecter
 */ function AddImageRequest({ index, image, resolve, reject }) {
    this.index = index;
    this.image = image;
    this.resolve = resolve;
    this.reject = reject;
    this.rectangle = undefined;
}
/**
 * Adds an image to the queue for this frame.
 * The image will be copied to the texture at the end of the frame, resizing the texture if needed.
 *
 * @private
 * @param {number} index An identifier
 * @param {TexturePacker.PackableObject} image An object, such as an <code>Image</code> with <code>width</code> and <code>height</code> properties in pixels
 * @returns {Promise<number>} Promise which resolves to the image index once the image has been added, or rejects if there was an error. The promise resolves to <code>-1</code> if the texture atlas is destoyed in the interim.
 */ TextureAtlas.prototype._addImage = function(index, image) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("index", index, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("image", image);
    //>>includeEnd('debug');
    return new Promise((resolve, reject)=>{
        this._imagesToAddQueue.push(new AddImageRequest({
            index,
            image,
            resolve,
            reject
        }));
        this._imagesToAddQueue.sort(({ image: imageA }, { image: imageB })=>imageB.height * imageB.width - imageA.height * imageA.width);
    });
};
/**
 * Process the image queue for this frame, copying to the texture atlas and resizing the texture as needed.
 * @private
 * @param {Context} context The rendering context
 * @return {boolean} true if the texture was updated this frame
 */ TextureAtlas.prototype._processImageQueue = function(context) {
    const queue = this._imagesToAddQueue;
    if (queue.length === 0) {
        return false;
    }
    this._rectangles.length = this._nextIndex;
    let i, error;
    for(i = 0; i < queue.length; ++i){
        const imageRequest = queue[i];
        const { image, index } = imageRequest;
        const node = this._texturePacker.pack(index, image);
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(node)) {
            // Atlas cannot fit all images in the queue
            // Bail early and resize
            try {
                this._resize(context, i);
            } catch (e) {
                error = e;
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(imageRequest.reject)) {
                    imageRequest.reject(error);
                }
            }
            break;
        }
        this._rectangles[index] = node.rectangle;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(error)) {
        for(i = i + 1; i < queue.length; ++i){
            const { resolve } = queue[i];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(resolve)) {
                resolve(-1);
            }
        }
        queue.length = 0;
        return false;
    }
    for(let i = 0; i < queue.length; ++i){
        this._copyImageToTexture(queue[i]);
    }
    queue.length = 0;
    return true;
};
/**
 * Processes any updates queued this frame, and updates rendering resources accordingly. Call before or after a frame has been rendered to avoid any race conditions for any dependant render commands.
 * @private
 * @param {Context} context The rendering context
 * @return {boolean} true if rendering resources were updated.
 */ TextureAtlas.prototype.update = function(context) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._texture)) {
        const width = this._initialSize.x;
        const height = this._initialSize.y;
        const pixelFormat = this._pixelFormat;
        const sampler = this._sampler;
        const borderPadding = this._borderWidthInPixels;
        this._texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            context,
            width,
            height,
            pixelFormat,
            sampler
        });
        this._texturePacker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$TexturePacker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            height,
            width,
            borderPadding
        });
    }
    return this._processImageQueue(context);
};
async function resolveImage(image, id) {
    if (typeof image === "function") {
        image = image(id);
    }
    if (typeof image === "string" || image instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
        // Fetch the resource
        const resource = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createIfNeeded(image);
        image = resource.fetchImage();
    }
    return image;
}
/**
 * Adds an image to the atlas.  If the image is already in the atlas, the atlas is unchanged and
 * the existing index is used.
 * @private
 * @param {string} id An identifier to detect whether the image already exists in the atlas.
 * @param {HTMLImageElement|HTMLCanvasElement|string|Resource|Promise|TextureAtlas.CreateImageCallback} image An image or canvas to add to the texture atlas,
 *        or a URL to an Image, or a Promise for an image, or a function that creates an image.
 * @param {number} width A number specifying the width of the texture. If undefined, the image width will be used.
 * @param {number} height A number specifying the height of the texture. If undefined, the image height will be used.
 * @returns {Promise<number>} A Promise that resolves to the image region index, or -1 if resources are in the process of being destroyed.
 */ TextureAtlas.prototype.addImage = function(id, image, width, height) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("id", id);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("image", image);
    //>>includeEnd('debug');
    let promise = this._indexPromiseById.get(id);
    let index = this._indexById.get(id);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(promise)) {
        // This image is already being added
        return promise;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(index)) {
        // This image has already been added and resolved
        return Promise.resolve(index);
    }
    index = this._nextIndex++;
    this._indexById.set(id, index);
    const resolveAndAddImage = async ()=>{
        const resolvedImage = await resolveImage(image, id);
        //>>includeStart('debug', pragmas.debug);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("image", resolvedImage);
        //>>includeEnd('debug');
        if (this.isDestroyed() || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(resolvedImage)) {
            this._indexPromiseById.delete(id);
            return -1;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(width)) {
            resolvedImage.width = width;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(height)) {
            resolvedImage.height = height;
        }
        const imageIndex = await this._addImage(index, resolvedImage);
        this._indexPromiseById.delete(id);
        return imageIndex;
    };
    promise = resolveAndAddImage();
    this._indexPromiseById.set(id, promise);
    return promise;
};
/**
 * Get an existing sub-region of an existing atlas image as additional image indices.
 * @private
 * @param {string} id The identifier of the existing image.
 * @param {BoundingRectangle} subRegion An {@link BoundingRectangle} defining a region of an existing image, measured in pixels from the bottom-left of the image.
 * @param {number} imageIndex The index of the image.
 * @returns {Promise<number> | number | undefined} The existing subRegion index, or undefined if not yet added.
 */ TextureAtlas.prototype.getCachedImageSubRegion = function(id, subRegion, imageIndex) {
    const imagePromise = this._indexPromiseById.get(id);
    for (const [index, parentIndex] of this._subRegions.entries()){
        if (imageIndex === parentIndex) {
            const boundingRegion = this._rectangles[index];
            if (boundingRegion.equals(subRegion)) {
                // The subregion is already being tracked
                if (imagePromise) {
                    return imagePromise.then((resolvedImageIndex)=>resolvedImageIndex === -1 ? -1 : index);
                }
                return index;
            }
        }
    }
};
/**
 * Add a sub-region of an existing atlas image as additional image indices.
 * @private
 * @param {string} id The identifier of the existing image.
 * @param {BoundingRectangle} subRegion An {@link BoundingRectangle} defining a region of an existing image, measured in pixels from the bottom-left of the image.
 * @returns {number | Promise<number>} The resolved image region index, or a Promise that resolves to it. -1 is returned if resources are in the process of being destroyed.
 */ TextureAtlas.prototype.addImageSubRegion = function(id, subRegion) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("id", id);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("subRegion", subRegion);
    //>>includeEnd('debug');
    const imageIndex = this._indexById.get(id);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(imageIndex)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`image with id "${id}" not found in the atlas.`);
    }
    let index = this.getCachedImageSubRegion(id, subRegion, imageIndex);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(index)) {
        return index;
    }
    index = this._nextIndex++;
    this._subRegions.set(index, imageIndex);
    this._rectangles[index] = subRegion.clone();
    const indexPromise = this._indexPromiseById.get(id) ?? Promise.resolve(imageIndex);
    return indexPromise.then((imageIndex)=>{
        if (imageIndex === -1) {
            // The atlas has been destroyed
            return -1;
        }
        const rectangle = this._rectangles[imageIndex];
        //>>includeStart('debug', pragmas.debug);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.lessThanOrEquals("subRegion.x", subRegion.x, rectangle.width);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.lessThanOrEquals("subRegion.x + subRegion.width", subRegion.x + subRegion.width, rectangle.width);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.lessThanOrEquals("subRegion.y", subRegion.y, rectangle.height);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.lessThanOrEquals("subRegion.y + subRegion.height", subRegion.y + subRegion.height, rectangle.height);
        //>>includeEnd('debug');
        return index;
    });
};
/**
 * Returns true if this object was destroyed; otherwise, false.
 * <br /><br />
 * If this object was destroyed, it should not be used; calling any function other than
 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
 * @private
 * @returns {boolean} True if this object was destroyed; otherwise, false.
 * @see TextureAtlas#destroy
 */ TextureAtlas.prototype.isDestroyed = function() {
    return false;
};
/**
 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
 * <br /><br />
 * Once an object is destroyed, it should not be used; calling any function other than
 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
 * assign the return value (<code>undefined</code>) to the object as done in the example.
 * @private
 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
 * @example
 * atlas = atlas && atlas.destroy();
 * @see TextureAtlas#isDestroyed
 */ TextureAtlas.prototype.destroy = function() {
    this._texture = this._texture && this._texture.destroy();
    this._imagesToAddQueue.forEach(({ resolve })=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(resolve)) {
            resolve(-1);
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
};
const __TURBOPACK__default__export__ = TextureAtlas;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/ComputeCommand.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Pass.js [app-client] (ecmascript)");
;
;
/**
 * Represents a command to the renderer for GPU Compute (using old-school GPGPU).
 *
 * @private
 * @constructor
 */ function ComputeCommand(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    /**
   * The vertex array. If none is provided, a viewport quad will be used.
   *
   * @type {VertexArray}
   * @default undefined
   */ this.vertexArray = options.vertexArray;
    /**
   * The fragment shader source. The default vertex shader is ViewportQuadVS.
   *
   * @type {ShaderSource}
   * @default undefined
   */ this.fragmentShaderSource = options.fragmentShaderSource;
    /**
   * The shader program to apply.
   *
   * @type {ShaderProgram}
   * @default undefined
   */ this.shaderProgram = options.shaderProgram;
    /**
   * An object with functions whose names match the uniforms in the shader program
   * and return values to set those uniforms.
   *
   * @type {object}
   * @default undefined
   */ this.uniformMap = options.uniformMap;
    /**
   * Texture to use for offscreen rendering.
   *
   * @type {Texture}
   * @default undefined
   */ this.outputTexture = options.outputTexture;
    /**
   * Function that is called immediately before the ComputeCommand is executed. Used to
   * update any renderer resources. Takes the ComputeCommand as its single argument.
   *
   * @type {Function}
   * @default undefined
   */ this.preExecute = options.preExecute;
    /**
   * Function that is called after the ComputeCommand is executed. Takes the output
   * texture as its single argument.
   *
   * @type {Function}
   * @default undefined
   */ this.postExecute = options.postExecute;
    /**
   * Function that is called when the command is canceled
   *
   * @type {Function}
   * @default undefined
   */ this.canceled = options.canceled;
    /**
   * Whether the renderer resources will persist beyond this call. If not, they
   * will be destroyed after completion.
   *
   * @type {boolean}
   * @default false
   */ this.persists = options.persists ?? false;
    /**
   * The pass when to render. Always compute pass.
   *
   * @type {Pass}
   * @default Pass.COMPUTE;
   */ this.pass = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COMPUTE;
    /**
   * The object who created this command.  This is useful for debugging command
   * execution; it allows us to see who created a command when we only have a
   * reference to the command, and can be used to selectively execute commands
   * with {@link Scene#debugCommandFilter}.
   *
   * @type {object}
   * @default undefined
   *
   * @see Scene#debugCommandFilter
   */ this.owner = options.owner;
}
/**
 * Executes the compute command.
 *
 * @param {ComputeEngine} computeEngine The context that processes the compute command.
 */ ComputeCommand.prototype.execute = function(computeEngine) {
    computeEngine.execute(this);
};
const __TURBOPACK__default__export__ = ComputeCommand;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/ClearCommand.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
;
;
/**
 * Represents a command to the renderer for clearing a framebuffer.
 *
 * @private
 * @constructor
 */ function ClearCommand(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    /**
   * The value to clear the color buffer to.  When <code>undefined</code>, the color buffer is not cleared.
   *
   * @type {Color}
   *
   * @default undefined
   */ this.color = options.color;
    /**
   * The value to clear the depth buffer to.  When <code>undefined</code>, the depth buffer is not cleared.
   *
   * @type {number}
   *
   * @default undefined
   */ this.depth = options.depth;
    /**
   * The value to clear the stencil buffer to.  When <code>undefined</code>, the stencil buffer is not cleared.
   *
   * @type {number}
   *
   * @default undefined
   */ this.stencil = options.stencil;
    /**
   * The render state to apply when executing the clear command.  The following states affect clearing:
   * scissor test, color mask, depth mask, and stencil mask.  When the render state is
   * <code>undefined</code>, the default render state is used.
   *
   * @type {RenderState}
   *
   * @default undefined
   */ this.renderState = options.renderState;
    /**
   * The framebuffer to clear.
   *
   * @type {Framebuffer}
   *
   * @default undefined
   */ this.framebuffer = options.framebuffer;
    /**
   * The object who created this command.  This is useful for debugging command
   * execution; it allows you to see who created a command when you only have a
   * reference to the command, and can be used to selectively execute commands
   * with {@link Scene#debugCommandFilter}.
   *
   * @type {object}
   *
   * @default undefined
   *
   * @see Scene#debugCommandFilter
   */ this.owner = options.owner;
    /**
   * The pass in which to run this command.
   *
   * @type {Pass}
   *
   * @default undefined
   */ this.pass = options.pass;
}
/**
 * Clears color to (0.0, 0.0, 0.0, 0.0); depth to 1.0; and stencil to 0.
 *
 * @type {ClearCommand}
 *
 * @constant
 */ ClearCommand.ALL = Object.freeze(new ClearCommand({
    color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0.0, 0.0, 0.0, 0.0),
    depth: 1.0,
    stencil: 0.0
}));
ClearCommand.prototype.execute = function(context, passState) {
    context.clear(this, passState);
};
const __TURBOPACK__default__export__ = ClearCommand;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/MultisampleFramebuffer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/destroyObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Framebuffer.js [app-client] (ecmascript)");
;
;
;
;
;
;
/**
 * Creates a multisampling wrapper around two framebuffers with optional initial
 * color and depth-stencil attachments. The first framebuffer has multisampled
 * renderbuffer attachments and is bound to READ_FRAMEBUFFER during the blit. The
 * second is bound to DRAW_FRAMEBUFFER during the blit, and has texture attachments
 * to store the copied pixels.
 *
 * @param {object} options Object with the following properties:
 * @param {Context} options.context
 * @param {number} options.width
 * @param {number} options.height
 * @param {Texture[]} [options.colorTextures]
 * @param {Renderbuffer[]} [options.colorRenderbuffers]
 * @param {Texture} [options.depthStencilTexture]
 * @param {Renderbuffer} [options.depthStencilRenderbuffer]
 * @param {boolean} [options.destroyAttachments]
 *
 * @exception {DeveloperError} Both color renderbuffer and texture attachments must be provided.
 * @exception {DeveloperError} Both depth-stencil renderbuffer and texture attachments must be provided.
 *
 * @private
 * @constructor
 */ function MultisampleFramebuffer(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const { context, width, height, colorRenderbuffers, colorTextures, depthStencilRenderbuffer, depthStencilTexture, destroyAttachments } = options;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.context", context);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.width", width);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.height", height);
    //>>includeEnd('debug');
    this._width = width;
    this._height = height;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(colorRenderbuffers) !== (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(colorTextures)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Both color renderbuffer and texture attachments must be provided.");
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(depthStencilRenderbuffer) !== (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(depthStencilTexture)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Both depth-stencil renderbuffer and texture attachments must be provided.");
    }
    this._renderFramebuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        context: context,
        colorRenderbuffers: colorRenderbuffers,
        depthStencilRenderbuffer: depthStencilRenderbuffer,
        destroyAttachments: destroyAttachments
    });
    this._colorFramebuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        context: context,
        colorTextures: colorTextures,
        depthStencilTexture: depthStencilTexture,
        destroyAttachments: destroyAttachments
    });
}
MultisampleFramebuffer.prototype.getRenderFramebuffer = function() {
    return this._renderFramebuffer;
};
MultisampleFramebuffer.prototype.getColorFramebuffer = function() {
    return this._colorFramebuffer;
};
/**
 * Copy from the render framebuffer to the color framebuffer, resolving the stencil.
 *
 * @param {Context} context
 * @param {boolean} blitStencil <code>true</code> if the stencil mask should be applied.
 *
 * @private
 */ MultisampleFramebuffer.prototype.blitFramebuffers = function(context, blitStencil) {
    this._renderFramebuffer.bindRead();
    this._colorFramebuffer.bindDraw();
    const gl = context._gl;
    let mask = 0;
    if (this._colorFramebuffer._colorTextures.length > 0) {
        mask |= gl.COLOR_BUFFER_BIT;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._colorFramebuffer.depthStencilTexture)) {
        mask |= gl.DEPTH_BUFFER_BIT | (blitStencil ? gl.STENCIL_BUFFER_BIT : 0);
    }
    gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, mask, gl.NEAREST);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
};
MultisampleFramebuffer.prototype.isDestroyed = function() {
    return false;
};
MultisampleFramebuffer.prototype.destroy = function() {
    this._renderFramebuffer.destroy();
    this._colorFramebuffer.destroy();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
};
const __TURBOPACK__default__export__ = MultisampleFramebuffer;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/RenderbufferFormat.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/WebGLConstants.js [app-client] (ecmascript)");
;
/**
 * @private
 */ const RenderbufferFormat = {
    RGBA4: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGBA4,
    RGBA8: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGBA8,
    RGBA16F: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGBA16F,
    RGBA32F: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGBA32F,
    RGB5_A1: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGB5_A1,
    RGB565: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGB565,
    DEPTH_COMPONENT16: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DEPTH_COMPONENT16,
    STENCIL_INDEX8: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].STENCIL_INDEX8,
    DEPTH_STENCIL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DEPTH_STENCIL,
    DEPTH24_STENCIL8: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DEPTH24_STENCIL8,
    validate: function(renderbufferFormat) {
        return renderbufferFormat === RenderbufferFormat.RGBA4 || renderbufferFormat === RenderbufferFormat.RGBA8 || renderbufferFormat === RenderbufferFormat.RGBA16F || renderbufferFormat === RenderbufferFormat.RGBA32F || renderbufferFormat === RenderbufferFormat.RGB5_A1 || renderbufferFormat === RenderbufferFormat.RGB565 || renderbufferFormat === RenderbufferFormat.DEPTH_COMPONENT16 || renderbufferFormat === RenderbufferFormat.STENCIL_INDEX8 || renderbufferFormat === RenderbufferFormat.DEPTH_STENCIL || renderbufferFormat === RenderbufferFormat.DEPTH24_STENCIL8;
    },
    getColorFormat: function(datatype) {
        if (datatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT) {
            return RenderbufferFormat.RGBA32F;
        } else if (datatype === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT_OES) {
            return RenderbufferFormat.RGBA16F;
        }
        return RenderbufferFormat.RGBA8;
    }
};
const __TURBOPACK__default__export__ = Object.freeze(RenderbufferFormat);
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/Renderbuffer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/destroyObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ContextLimits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$RenderbufferFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/RenderbufferFormat.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
/**
 * @private
 */ function Renderbuffer(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.context", options.context);
    //>>includeEnd('debug');
    const context = options.context;
    const gl = context._gl;
    const maximumRenderbufferSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].maximumRenderbufferSize;
    const format = options.format ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$RenderbufferFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGBA4;
    const width = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.width) ? options.width : context.drawingBufferWidth;
    const height = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.height) ? options.height : context.drawingBufferHeight;
    const numSamples = options.numSamples ?? 1;
    //>>includeStart('debug', pragmas.debug);
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$RenderbufferFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(format)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Invalid format.");
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThan("width", width, 0);
    if (width > maximumRenderbufferSize) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Width must be less than or equal to the maximum renderbuffer size (${maximumRenderbufferSize}).  Check maximumRenderbufferSize.`);
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThan("height", height, 0);
    if (height > maximumRenderbufferSize) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Height must be less than or equal to the maximum renderbuffer size (${maximumRenderbufferSize}).  Check maximumRenderbufferSize.`);
    }
    //>>includeEnd('debug');
    this._gl = gl;
    this._format = format;
    this._width = width;
    this._height = height;
    this._renderbuffer = this._gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, this._renderbuffer);
    if (numSamples > 1) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, numSamples, format, width, height);
    } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);
    }
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
}
Object.defineProperties(Renderbuffer.prototype, {
    format: {
        get: function() {
            return this._format;
        }
    },
    width: {
        get: function() {
            return this._width;
        }
    },
    height: {
        get: function() {
            return this._height;
        }
    }
});
Renderbuffer.prototype._getRenderbuffer = function() {
    return this._renderbuffer;
};
Renderbuffer.prototype.isDestroyed = function() {
    return false;
};
Renderbuffer.prototype.destroy = function() {
    this._gl.deleteRenderbuffer(this._renderbuffer);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
};
const __TURBOPACK__default__export__ = Renderbuffer;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/FramebufferManager.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Framebuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$MultisampleFramebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/MultisampleFramebuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/PixelDatatype.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Renderbuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Renderbuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$RenderbufferFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/RenderbufferFormat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Sampler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/PixelFormat.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
/**
 * Creates a wrapper object around a framebuffer and its resources.
 *
 * @param {object} options Object with the following properties:
 * @param {number} [options.numSamples=1] The multisampling rate of the render targets. Requires a WebGL2 context.
 * @param {number} [options.colorAttachmentsLength=1] The number of color attachments this FramebufferManager will create.
 * @param {boolean} [options.color=true] Whether the FramebufferManager will use color attachments.
 * @param {boolean} [options.depth=false] Whether the FramebufferManager will use depth attachments.
 * @param {boolean} [options.depthStencil=false] Whether the FramebufferManager will use depth-stencil attachments.
 * @param {boolean} [options.supportsDepthTexture=false] Whether the FramebufferManager will create a depth texture when the extension is supported.
 * @param {boolean} [options.createColorAttachments=true] Whether the FramebufferManager will construct its own color attachments.
 * @param {boolean} [options.createDepthAttachments=true] Whether the FramebufferManager will construct its own depth attachments.
 * @param {PixelDatatype} [options.pixelDatatype=undefined] The default pixel datatype to use when creating color attachments.
 * @param {PixelFormat} [options.pixelFormat=undefined] The default pixel format to use when creating color attachments.
 *
 * @exception {DeveloperError} Must enable at least one type of framebuffer attachment.
 * @exception {DeveloperError} Cannot have both a depth and depth-stencil attachment.
 *
 * @private
 * @constructor
 */ function FramebufferManager(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    this._numSamples = options.numSamples ?? 1;
    this._colorAttachmentsLength = options.colorAttachmentsLength ?? 1;
    this._color = options.color ?? true;
    this._depth = options.depth ?? false;
    this._depthStencil = options.depthStencil ?? false;
    this._supportsDepthTexture = options.supportsDepthTexture ?? false;
    //>>includeStart('debug', pragmas.debug);
    if (!this._color && !this._depth && !this._depthStencil) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Must enable at least one type of framebuffer attachment.");
    }
    if (this._depth && this._depthStencil) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Cannot have both a depth and depth-stencil attachment.");
    }
    //>>includeEnd('debug');
    this._createColorAttachments = options.createColorAttachments ?? true;
    this._createDepthAttachments = options.createDepthAttachments ?? true;
    this._pixelDatatype = options.pixelDatatype;
    this._pixelFormat = options.pixelFormat;
    this._width = undefined;
    this._height = undefined;
    this._framebuffer = undefined;
    this._multisampleFramebuffer = undefined;
    this._colorTextures = undefined;
    if (this._color) {
        this._colorTextures = new Array(this._colorAttachmentsLength);
        this._colorRenderbuffers = new Array(this._colorAttachmentsLength);
    }
    this._colorRenderbuffer = undefined;
    this._depthStencilRenderbuffer = undefined;
    this._depthStencilTexture = undefined;
    this._depthRenderbuffer = undefined;
    this._depthTexture = undefined;
    this._attachmentsDirty = false;
}
Object.defineProperties(FramebufferManager.prototype, {
    framebuffer: {
        get: function() {
            if (this._numSamples > 1) {
                return this._multisampleFramebuffer.getRenderFramebuffer();
            }
            return this._framebuffer;
        }
    },
    numSamples: {
        get: function() {
            return this._numSamples;
        }
    },
    status: {
        get: function() {
            return this.framebuffer.status;
        }
    }
});
FramebufferManager.prototype.isDirty = function(width, height, numSamples, pixelDatatype, pixelFormat) {
    numSamples = numSamples ?? 1;
    const dimensionChanged = this._width !== width || this._height !== height;
    const samplesChanged = this._numSamples !== numSamples;
    const pixelChanged = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(pixelDatatype) && this._pixelDatatype !== pixelDatatype || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(pixelFormat) && this._pixelFormat !== pixelFormat;
    const framebufferDefined = numSamples === 1 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._framebuffer) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._multisampleFramebuffer);
    return this._attachmentsDirty || dimensionChanged || samplesChanged || pixelChanged || !framebufferDefined || this._color && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._colorTextures[0]);
};
FramebufferManager.prototype.update = function(context, width, height, numSamples, pixelDatatype, pixelFormat) {
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(width) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(height)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("width and height must be defined.");
    }
    //>>includeEnd('debug');
    numSamples = context.msaa ? numSamples ?? 1 : 1;
    pixelDatatype = pixelDatatype ?? (this._color ? this._pixelDatatype ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_BYTE : undefined);
    pixelFormat = pixelFormat ?? (this._color ? this._pixelFormat ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGBA : undefined);
    if (this.isDirty(width, height, numSamples, pixelDatatype, pixelFormat)) {
        this.destroy();
        this._width = width;
        this._height = height;
        this._numSamples = numSamples;
        this._pixelDatatype = pixelDatatype;
        this._pixelFormat = pixelFormat;
        this._attachmentsDirty = false;
        // Create color texture
        if (this._color && this._createColorAttachments) {
            for(let i = 0; i < this._colorAttachmentsLength; ++i){
                this._colorTextures[i] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    context: context,
                    width: width,
                    height: height,
                    pixelFormat: pixelFormat,
                    pixelDatatype: pixelDatatype,
                    sampler: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST
                });
                if (this._numSamples > 1) {
                    const format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$RenderbufferFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getColorFormat(pixelDatatype);
                    this._colorRenderbuffers[i] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Renderbuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                        context: context,
                        width: width,
                        height: height,
                        format: format,
                        numSamples: this._numSamples
                    });
                }
            }
        }
        // Create depth stencil texture or renderbuffer
        if (this._depthStencil && this._createDepthAttachments) {
            if (this._supportsDepthTexture && context.depthTexture) {
                this._depthStencilTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    context: context,
                    width: width,
                    height: height,
                    pixelFormat: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DEPTH_STENCIL,
                    pixelDatatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_INT_24_8,
                    sampler: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST
                });
                if (this._numSamples > 1) {
                    this._depthStencilRenderbuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Renderbuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                        context: context,
                        width: width,
                        height: height,
                        format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$RenderbufferFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DEPTH24_STENCIL8,
                        numSamples: this._numSamples
                    });
                }
            } else {
                this._depthStencilRenderbuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Renderbuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    context: context,
                    width: width,
                    height: height,
                    format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$RenderbufferFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DEPTH_STENCIL
                });
            }
        }
        // Create depth texture
        if (this._depth && this._createDepthAttachments) {
            if (this._supportsDepthTexture && context.depthTexture) {
                this._depthTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    context: context,
                    width: width,
                    height: height,
                    pixelFormat: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DEPTH_COMPONENT,
                    pixelDatatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_INT,
                    sampler: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST
                });
            } else {
                this._depthRenderbuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Renderbuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    context: context,
                    width: width,
                    height: height,
                    format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$RenderbufferFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DEPTH_COMPONENT16
                });
            }
        }
        if (this._numSamples > 1) {
            this._multisampleFramebuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$MultisampleFramebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                context: context,
                width: this._width,
                height: this._height,
                colorTextures: this._colorTextures,
                colorRenderbuffers: this._colorRenderbuffers,
                depthStencilTexture: this._depthStencilTexture,
                depthStencilRenderbuffer: this._depthStencilRenderbuffer,
                destroyAttachments: false
            });
        } else {
            this._framebuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                context: context,
                colorTextures: this._colorTextures,
                depthTexture: this._depthTexture,
                depthRenderbuffer: this._depthRenderbuffer,
                depthStencilTexture: this._depthStencilTexture,
                depthStencilRenderbuffer: this._depthStencilRenderbuffer,
                destroyAttachments: false
            });
        }
    }
};
FramebufferManager.prototype.getColorTexture = function(index) {
    index = index ?? 0;
    //>>includeStart('debug', pragmas.debug);
    if (index >= this._colorAttachmentsLength) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("index must be smaller than total number of color attachments.");
    }
    //>>includeEnd('debug');
    return this._colorTextures[index];
};
FramebufferManager.prototype.setColorTexture = function(texture, index) {
    index = index ?? 0;
    //>>includeStart('debug', pragmas.debug);
    if (this._createColorAttachments) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("createColorAttachments must be false if setColorTexture is called.");
    }
    if (index >= this._colorAttachmentsLength) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("index must be smaller than total number of color attachments.");
    }
    //>>includeEnd('debug');
    this._attachmentsDirty = texture !== this._colorTextures[index];
    this._colorTextures[index] = texture;
};
FramebufferManager.prototype.getColorRenderbuffer = function(index) {
    index = index ?? 0;
    //>>includeStart('debug', pragmas.debug);
    if (index >= this._colorAttachmentsLength) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("index must be smaller than total number of color attachments.");
    }
    //>>includeEnd('debug');
    return this._colorRenderbuffers[index];
};
FramebufferManager.prototype.setColorRenderbuffer = function(renderbuffer, index) {
    index = index ?? 0;
    //>>includeStart('debug', pragmas.debug);
    if (this._createColorAttachments) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("createColorAttachments must be false if setColorRenderbuffer is called.");
    }
    if (index >= this._colorAttachmentsLength) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("index must be smaller than total number of color attachments.");
    }
    //>>includeEnd('debug');
    this._attachmentsDirty = renderbuffer !== this._colorRenderbuffers[index];
    this._colorRenderbuffers[index] = renderbuffer;
};
FramebufferManager.prototype.getDepthRenderbuffer = function() {
    return this._depthRenderbuffer;
};
FramebufferManager.prototype.setDepthRenderbuffer = function(renderbuffer) {
    //>>includeStart('debug', pragmas.debug);
    if (this._createDepthAttachments) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("createDepthAttachments must be false if setDepthRenderbuffer is called.");
    }
    //>>includeEnd('debug');
    this._attachmentsDirty = renderbuffer !== this._depthRenderbuffer;
    this._depthRenderbuffer = renderbuffer;
};
FramebufferManager.prototype.getDepthTexture = function() {
    return this._depthTexture;
};
FramebufferManager.prototype.setDepthTexture = function(texture) {
    //>>includeStart('debug', pragmas.debug);
    if (this._createDepthAttachments) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("createDepthAttachments must be false if setDepthTexture is called.");
    }
    //>>includeEnd('debug');
    this._attachmentsDirty = texture !== this._depthTexture;
    this._depthTexture = texture;
};
FramebufferManager.prototype.getDepthStencilRenderbuffer = function() {
    return this._depthStencilRenderbuffer;
};
FramebufferManager.prototype.setDepthStencilRenderbuffer = function(renderbuffer) {
    //>>includeStart('debug', pragmas.debug);
    if (this._createDepthAttachments) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("createDepthAttachments must be false if setDepthStencilRenderbuffer is called.");
    }
    //>>includeEnd('debug');
    this._attachmentsDirty = renderbuffer !== this._depthStencilRenderbuffer;
    this._depthStencilRenderbuffer = renderbuffer;
};
FramebufferManager.prototype.getDepthStencilTexture = function() {
    return this._depthStencilTexture;
};
FramebufferManager.prototype.setDepthStencilTexture = function(texture) {
    //>>includeStart('debug', pragmas.debug);
    if (this._createDepthAttachments) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("createDepthAttachments must be false if setDepthStencilTexture is called.");
    }
    //>>includeEnd('debug');
    this._attachmentsDirty = texture !== this._depthStencilTexture;
    this._depthStencilTexture = texture;
};
/**
 * If using MSAA, resolve the stencil.
 *
 * @param {Context} context
 * @param {boolean} blitStencil
 *
 * @private
 */ FramebufferManager.prototype.prepareTextures = function(context, blitStencil) {
    if (this._numSamples > 1) {
        this._multisampleFramebuffer.blitFramebuffers(context, blitStencil);
    }
};
FramebufferManager.prototype.clear = function(context, clearCommand, passState) {
    const framebuffer = clearCommand.framebuffer;
    clearCommand.framebuffer = this.framebuffer;
    clearCommand.execute(context, passState);
    clearCommand.framebuffer = framebuffer;
};
FramebufferManager.prototype.destroyFramebuffer = function() {
    this._framebuffer = this._framebuffer && this._framebuffer.destroy();
    this._multisampleFramebuffer = this._multisampleFramebuffer && this._multisampleFramebuffer.destroy();
};
FramebufferManager.prototype.destroy = function() {
    if (this._color) {
        const colorTextures = this._colorTextures;
        const colorRenderbuffers = this._colorRenderbuffers;
        for(let i = 0; i < colorTextures.length; ++i){
            const texture = colorTextures[i];
            if (this._createColorAttachments) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(texture) && !texture.isDestroyed()) {
                    texture.destroy();
                }
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(texture) && texture.isDestroyed()) {
                colorTextures[i] = undefined;
            }
            const renderbuffer = colorRenderbuffers[i];
            if (this._createColorAttachments) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(renderbuffer) && !renderbuffer.isDestroyed()) {
                    renderbuffer.destroy();
                }
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(renderbuffer) && renderbuffer.isDestroyed()) {
                colorRenderbuffers[i] = undefined;
            }
        }
    }
    if (this._depthStencil) {
        if (this._createDepthAttachments) {
            this._depthStencilTexture = this._depthStencilTexture && this._depthStencilTexture.destroy();
            this._depthStencilRenderbuffer = this._depthStencilRenderbuffer && this._depthStencilRenderbuffer.destroy();
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._depthStencilTexture) && this._depthStencilTexture.isDestroyed()) {
            this._depthStencilTexture = undefined;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._depthStencilRenderbuffer) && this._depthStencilRenderbuffer.isDestroyed()) {
            this._depthStencilRenderbuffer = undefined;
        }
    }
    if (this._depth) {
        if (this._createDepthAttachments) {
            this._depthTexture = this._depthTexture && this._depthTexture.destroy();
            this._depthRenderbuffer = this._depthRenderbuffer && this._depthRenderbuffer.destroy();
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._depthTexture) && this._depthTexture.isDestroyed()) {
            this._depthTexture = undefined;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._depthRenderbuffer) && this._depthRenderbuffer.isDestroyed()) {
            this._depthRenderbuffer = undefined;
        }
    }
    this.destroyFramebuffer();
};
const __TURBOPACK__default__export__ = FramebufferManager;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/ShaderDestination.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
;
/**
 * An enum describing whether a variable should be added to the
 * vertex shader, the fragment shader, or both.
 *
 * @private
 */ const ShaderDestination = {
    VERTEX: 0,
    FRAGMENT: 1,
    BOTH: 2
};
/**
 * Check if a variable should be included in the vertex shader.
 *
 * @param {ShaderDestination} destination The ShaderDestination to check
 * @return {boolean} <code>true</code> if the variable appears in the vertex shader, or <code>false</code> otherwise
 * @private
 */ ShaderDestination.includesVertexShader = function(destination) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number("destination", destination);
    //>>includeEnd('debug');
    return destination === ShaderDestination.VERTEX || destination === ShaderDestination.BOTH;
};
/**
 * Check if a variable should be included in the vertex shader.
 *
 * @param {ShaderDestination} destination The ShaderDestination to check
 * @return {boolean} <code>true</code> if the variable appears in the vertex shader, or <code>false</code> otherwise
 * @private
 */ ShaderDestination.includesFragmentShader = function(destination) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number("destination", destination);
    //>>includeEnd('debug');
    //
    return destination === ShaderDestination.FRAGMENT || destination === ShaderDestination.BOTH;
};
const __TURBOPACK__default__export__ = Object.freeze(ShaderDestination);
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/ShaderStruct.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
/**
 * A utility for dynamically-generating a GLSL struct.
 *
 * @alias ShaderStruct
 * @constructor
 *
 * @see {@link ShaderBuilder}
 * @param {string} name The name of the struct as it will appear in the shader.
 * @example
 * // Generate the struct:
 * //
 * // struct Attributes
 * // {
 * //     vec3 position;
 * //     vec3 normal;
 * //     vec2 texCoord;
 * // };
 * const struct = new ShaderStruct("Attributes");
 * struct.addField("vec3", "position");
 * struct.addField("vec3", "normal");
 * struct.addField("vec2", "texCoord");
 * const generatedLines = struct.generateGlslLines();
 *
 * @private
 */ function ShaderStruct(name) {
    this.name = name;
    this.fields = [];
}
/**
 * Add a field to the struct
 * @param {string} type The type of the struct field
 * @param {string} identifier The identifier of the struct field
 */ ShaderStruct.prototype.addField = function(type, identifier) {
    const field = `    ${type} ${identifier};`;
    this.fields.push(field);
};
/**
 * Generate a list of lines of GLSL code for use with {@link ShaderBuilder}
 * @return {string[]} The generated GLSL code.
 */ ShaderStruct.prototype.generateGlslLines = function() {
    let fields = this.fields;
    if (fields.length === 0) {
        // GLSL requires structs to have at least one field
        fields = [
            "    float _empty;"
        ];
    }
    return [].concat(`struct ${this.name}`, "{", fields, "};");
};
const __TURBOPACK__default__export__ = ShaderStruct;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/ShaderFunction.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
;
/**
 * A utility for dynamically-generating a GLSL function
 *
 * @alias ShaderFunction
 * @constructor
 *
 * @see {@link ShaderBuilder}
 * @param {string} signature The full signature of the function as it will appear in the shader. Do not include the curly braces.
 * @example
 * // generate the following function
 * //
 * // void assignVaryings(vec3 position)
 * // {
 * //    v_positionEC = (czm_modelView * vec4(a_position, 1.0)).xyz;
 * //    v_texCoord = a_texCoord;
 * // }
 * const signature = "void assignVaryings(vec3 position)";
 * const func = new ShaderFunction(signature);
 * func.addLine("v_positionEC = (czm_modelView * vec4(a_position, 1.0)).xyz;");
 * func.addLine("v_texCoord = a_texCoord;");
 * const generatedLines = func.generateGlslLines();
 *
 * @private
 */ function ShaderFunction(signature) {
    this.signature = signature;
    this.body = [];
}
/**
 * Adds one or more lines to the body of the function
 * @param {string|string[]} lines One or more lines of GLSL code to add to the function body. Do not include any preceding or ending whitespace, but do include the semicolon for each line.
 */ ShaderFunction.prototype.addLines = function(lines) {
    //>>includeStart('debug', pragmas.debug);
    if (typeof lines !== "string" && !Array.isArray(lines)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Expected lines to be a string or an array of strings, actual value was ${lines}`);
    }
    //>>includeEnd('debug');
    const body = this.body;
    // Indent the body of the function by 4 spaces
    if (Array.isArray(lines)) {
        const length = lines.length;
        for(let i = 0; i < length; i++){
            body.push(`    ${lines[i]}`);
        }
    } else {
        // Single string case
        body.push(`    ${lines}`);
    }
};
/**
 * Generate lines of GLSL code for use with {@link ShaderBuilder}
 * @return {string[]}
 */ ShaderFunction.prototype.generateGlslLines = function() {
    return [].concat(this.signature, "{", this.body, "}");
};
const __TURBOPACK__default__export__ = ShaderFunction;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/ShaderBuilder.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$clone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/clone.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderDestination$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ShaderDestination.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderProgram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ShaderProgram.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ShaderSource.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderStruct$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ShaderStruct.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ShaderFunction.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$addAllToArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/addAllToArray.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
/**
 * An object that makes it easier to build the text of a {@link ShaderProgram}. This tracks GLSL code for both the vertex shader and the fragment shader.
 * <p>
 * For vertex shaders, the shader builder tracks a list of <code>#defines</code>,
 * a list of attributes, a list of uniforms, and a list of shader lines. It also
 * tracks the location of each attribute so the caller can easily build the {@link VertexArray}
 * </p>
 * <p>
 * For fragment shaders, the shader builder tracks a list of <code>#defines</code>,
 * a list of attributes, a list of uniforms, and a list of shader lines.
 * </p>
 *
 * @alias ShaderBuilder
 * @constructor
 *
 * @example
 * const shaderBuilder = new ShaderBuilder();
 * shaderBuilder.addDefine("SOLID_COLOR", undefined, ShaderDestination.FRAGMENT);
 * shaderBuilder.addUniform("vec3", "u_color", ShaderDestination.FRAGMENT);
 * shaderBuilder.addVarying("vec3", v_color");
 * // These locations can be used when creating the VertexArray
 * const positionLocation = shaderBuilder.addPositionAttribute("vec3", "a_position");
 * const colorLocation = shaderBuilder.addAttribute("vec3", "a_color");
 * shaderBuilder.addVertexLines([
 *  "void main()",
 *  "{",
 *  "    v_color = a_color;",
 *  "    gl_Position = vec4(a_position, 1.0);",
 *  "}"
 * ]);
 * shaderBuilder.addFragmentLines([
 *  "void main()",
 *  "{",
 *  "    #ifdef SOLID_COLOR",
 *  "    out_FragColor = vec4(u_color, 1.0);",
 *  "    #else",
 *  "    out_FragColor = vec4(v_color, 1.0);",
 *  "    #endif",
 *  "}"
 * ]);
 * const shaderProgram = shaderBuilder.build(context);
 *
 * @private
 */ function ShaderBuilder() {
    // Some WebGL implementations require attribute 0 to always
    // be active, so the position attribute is tracked separately
    this._positionAttributeLine = undefined;
    this._nextAttributeLocation = 1;
    this._attributeLocations = {};
    this._attributeLines = [];
    // Dynamically-generated structs and functions
    // these are dictionaries of id -> ShaderStruct or ShaderFunction respectively
    this._structs = {};
    this._functions = {};
    this._vertexShaderParts = {
        defineLines: [],
        uniformLines: [],
        shaderLines: [],
        varyingLines: [],
        // identifiers of structs/functions to include, listed in insertion order
        structIds: [],
        functionIds: []
    };
    this._fragmentShaderParts = {
        defineLines: [],
        uniformLines: [],
        shaderLines: [],
        varyingLines: [],
        // identifiers of structs/functions to include, listed in insertion order
        structIds: [],
        functionIds: []
    };
}
Object.defineProperties(ShaderBuilder.prototype, {
    /**
   * Get a dictionary of attribute names to the integer location in
   * the vertex shader.
   *
   * @memberof ShaderBuilder.prototype
   * @type {Object<string, number>}
   * @readonly
   * @private
   */ attributeLocations: {
        get: function() {
            return this._attributeLocations;
        }
    }
});
/**
 * Add a <code>#define</code> macro to one or both of the shaders. These lines
 * will appear at the top of the final shader source.
 *
 * @param {string} identifier An identifier for the macro. Identifiers must use uppercase letters with underscores to be consistent with Cesium's style guide.
 * @param {string} [value] The value of the macro. If undefined, the define will not include a value. The value will be converted to GLSL code via <code>toString()</code>
 * @param {ShaderDestination} [destination=ShaderDestination.BOTH] Whether the define appears in the vertex shader, the fragment shader, or both.
 *
 * @example
 * // creates the line "#define ENABLE_LIGHTING" in both shaders
 * shaderBuilder.addDefine("ENABLE_LIGHTING");
 * // creates the line "#define PI 3.141592" in the fragment shader
 * shaderBuilder.addDefine("PI", 3.141593, ShaderDestination.FRAGMENT);
 */ ShaderBuilder.prototype.addDefine = function(identifier, value, destination) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("identifier", identifier);
    //>>includeEnd('debug');
    destination = destination ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderDestination$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].BOTH;
    // The ShaderSource created in build() will add the #define part
    let line = identifier;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(value)) {
        line += ` ${value.toString()}`;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderDestination$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].includesVertexShader(destination)) {
        this._vertexShaderParts.defineLines.push(line);
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderDestination$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].includesFragmentShader(destination)) {
        this._fragmentShaderParts.defineLines.push(line);
    }
};
/**
 * Add a new dynamically-generated struct to the shader
 * @param {string} structId A unique ID to identify this struct in {@link ShaderBuilder#addStructField}
 * @param {string} structName The name of the struct as it will appear in the shader.
 * @param {ShaderDestination} destination Whether the struct will appear in the vertex shader, the fragment shader, or both.
 *
 * @example
 * // generates the following struct in the fragment shader
 * // struct TestStruct
 * // {
 * // };
 * shaderBuilder.addStruct("testStructId", "TestStruct", ShaderDestination.FRAGMENT);
 */ ShaderBuilder.prototype.addStruct = function(structId, structName, destination) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("structId", structId);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("structName", structName);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number("destination", destination);
    //>>includeEnd('debug');
    this._structs[structId] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderStruct$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](structName);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderDestination$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].includesVertexShader(destination)) {
        this._vertexShaderParts.structIds.push(structId);
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderDestination$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].includesFragmentShader(destination)) {
        this._fragmentShaderParts.structIds.push(structId);
    }
};
/**
 * Add a field to a dynamically-generated struct.
 * @param {string} structId The ID of the struct. This must be created first with {@link ShaderBuilder#addStruct}
 * @param {string} type The GLSL type of the field
 * @param {string} identifier The identifier of the field.
 *
 * @example
 * // generates the following struct in the fragment shader
 * // struct TestStruct
 * // {
 * //    float minimum;
 * //    float maximum;
 * // };
 * shaderBuilder.addStruct("testStructId", "TestStruct", ShaderDestination.FRAGMENT);
 * shaderBuilder.addStructField("testStructId", "float", "maximum");
 * shaderBuilder.addStructField("testStructId", "float", "minimum");
 */ ShaderBuilder.prototype.addStructField = function(structId, type, identifier) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("structId", structId);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("type", type);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("identifier", identifier);
    //>>includeEnd('debug');
    this._structs[structId].addField(type, identifier);
};
/**
 * Add a new dynamically-generated function to the shader.
 * @param {string} functionName The name of the function. This will be used to identify the function in {@link ShaderBuilder#addFunctionLines}.
 * @param {string} signature The full signature of the function as it will appear in the shader. Do not include the curly braces.
 * @param {ShaderDestination} destination Whether the struct will appear in the vertex shader, the fragment shader, or both.
 * @example
 * // generates the following function in the vertex shader
 * // vec3 testFunction(float parameter)
 * // {
 * // }
 * shaderBuilder.addStruct("testFunction", "vec3 testFunction(float parameter)", ShaderDestination.VERTEX);
 */ ShaderBuilder.prototype.addFunction = function(functionName, signature, destination) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("functionName", functionName);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("signature", signature);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number("destination", destination);
    //>>includeEnd('debug');
    this._functions[functionName] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderFunction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](signature);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderDestination$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].includesVertexShader(destination)) {
        this._vertexShaderParts.functionIds.push(functionName);
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderDestination$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].includesFragmentShader(destination)) {
        this._fragmentShaderParts.functionIds.push(functionName);
    }
};
/**
 * Add lines to a dynamically-generated function
 * @param {string} functionName The name of the function. This must be created beforehand using {@link ShaderBuilder#addFunction}
 * @param {string|string[]} lines One or more lines of GLSL code to add to the function body. Do not include any preceding or ending whitespace, but do include the semicolon for each line.
 *
 * @example
 * // generates the following function in the vertex shader
 * // vec3 testFunction(float parameter)
 * // {
 * //   float signed = 2.0 * parameter - 1.0;
 * //   return vec3(signed, 0.0, 0.0);
 * // }
 * shaderBuilder.addStruct("testFunction", "vec3 testFunction(float parameter)", ShaderDestination.VERTEX);
 * shaderBuilder.addFunctionLines("testFunction", [
 *   "float signed = 2.0 * parameter - 1.0;",
 *   "return vec3(parameter);"
 * ]);
 */ ShaderBuilder.prototype.addFunctionLines = function(functionName, lines) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("functionName", functionName);
    if (typeof lines !== "string" && !Array.isArray(lines)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Expected lines to be a string or an array of strings, actual value was ${lines}`);
    }
    //>>includeEnd('debug');
    this._functions[functionName].addLines(lines);
};
/**
 * Add a uniform declaration to one or both of the shaders. These lines
 * will appear grouped near the top of the final shader source.
 *
 * @param {string} type The GLSL type of the uniform.
 * @param {string} identifier An identifier for the uniform. Identifiers must begin with <code>u_</code> to be consistent with Cesium's style guide.
 * @param {ShaderDestination} [destination=ShaderDestination.BOTH] Whether the uniform appears in the vertex shader, the fragment shader, or both.
 *
 * @example
 * // creates the line "uniform vec3 u_resolution;"
 * shaderBuilder.addUniform("vec3", "u_resolution", ShaderDestination.FRAGMENT);
 * // creates the line "uniform float u_time;" in both shaders
 * shaderBuilder.addUniform("float", "u_time", ShaderDestination.BOTH);
 */ ShaderBuilder.prototype.addUniform = function(type, identifier, destination) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("type", type);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("identifier", identifier);
    //>>includeEnd('debug');
    destination = destination ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderDestination$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].BOTH;
    const line = `uniform ${type} ${identifier};`;
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderDestination$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].includesVertexShader(destination)) {
        this._vertexShaderParts.uniformLines.push(line);
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderDestination$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].includesFragmentShader(destination)) {
        this._fragmentShaderParts.uniformLines.push(line);
    }
};
/**
 * Add a position attribute declaration to the vertex shader. These lines
 * will appear grouped near the top of the final shader source.
 * <p>
 * Some WebGL implementations require attribute 0 to be enabled, so this is
 * reserved for the position attribute. For all other attributes, see
 * {@link ShaderBuilder#addAttribute}
 * </p>
 *
 * @param {string} type The GLSL type of the attribute
 * @param {string} identifier An identifier for the attribute. Identifiers must begin with <code>a_</code> to be consistent with Cesium's style guide.
 * @return {number} The integer location of the attribute. This location can be used when creating attributes for a {@link VertexArray}. This will always be 0.
 *
 * @example
 * // creates the line "in vec3 a_position;"
 * shaderBuilder.setPositionAttribute("vec3", "a_position");
 */ ShaderBuilder.prototype.setPositionAttribute = function(type, identifier) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("type", type);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("identifier", identifier);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._positionAttributeLine)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("setPositionAttribute() must be called exactly once for the attribute used for gl_Position. For other attributes, use addAttribute()");
    }
    //>>includeEnd('debug');
    this._positionAttributeLine = `in ${type} ${identifier};`;
    // Some WebGL implementations require attribute 0 to always be active, so
    // this builder assumes the position will always go in location 0
    this._attributeLocations[identifier] = 0;
    return 0;
};
/**
 * Add an attribute declaration to the vertex shader. These lines
 * will appear grouped near the top of the final shader source.
 * <p>
 * Some WebGL implementations require attribute 0 to be enabled, so this is
 * reserved for the position attribute. See {@link ShaderBuilder#setPositionAttribute}
 * </p>
 *
 * @param {string} type The GLSL type of the attribute
 * @param {string} identifier An identifier for the attribute. Identifiers must begin with <code>a_</code> to be consistent with Cesium's style guide.
 * @return {number} The integer location of the attribute. This location can be used when creating attributes for a {@link VertexArray}
 *
 * @example
 * // creates the line "in vec2 a_texCoord0;" in the vertex shader
 * shaderBuilder.addAttribute("vec2", "a_texCoord0");
 */ ShaderBuilder.prototype.addAttribute = function(type, identifier) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("type", type);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("identifier", identifier);
    //>>includeEnd('debug');
    const line = `in ${type} ${identifier};`;
    this._attributeLines.push(line);
    const location = this._nextAttributeLocation;
    this._attributeLocations[identifier] = location;
    // Most attributes only require a single attribute location, but matrices
    // require more.
    this._nextAttributeLocation += getAttributeLocationCount(type);
    return location;
};
/**
 * Add a varying declaration to both the vertex and fragment shaders.
 *
 * @param {string} type The GLSL type of the varying
 * @param {string} identifier An identifier for the varying. Identifiers must begin with <code>v_</code> to be consistent with Cesium's style guide.
 * @param {string} [qualifier] A qualifier for the varying, such as <code>flat</code>.
 *
 * @example
 * // creates the line "in vec3 v_color;" in the vertex shader
 * // creates the line "out vec3 v_color;" in the fragment shader
 * shaderBuilder.addVarying("vec3", "v_color");
 */ ShaderBuilder.prototype.addVarying = function(type, identifier, qualifier) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("type", type);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.string("identifier", identifier);
    //>>includeEnd('debug');
    qualifier = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(qualifier) ? `${qualifier} ` : "";
    const line = `${type} ${identifier};`;
    this._vertexShaderParts.varyingLines.push(`${qualifier}out ${line}`);
    this._fragmentShaderParts.varyingLines.push(`${qualifier}in ${line}`);
};
/**
 * Appends lines of GLSL code to the vertex shader
 *
 * @param {string|string[]} lines One or more lines to add to the end of the vertex shader source
 *
 * @example
 * shaderBuilder.addVertexLines([
 *  "void main()",
 *  "{",
 *  "    v_color = a_color;",
 *  "    gl_Position = vec4(a_position, 1.0);",
 *  "}"
 * ]);
 */ ShaderBuilder.prototype.addVertexLines = function(lines) {
    //>>includeStart('debug', pragmas.debug);
    if (typeof lines !== "string" && !Array.isArray(lines)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Expected lines to be a string or an array of strings, actual value was ${lines}`);
    }
    //>>includeEnd('debug');
    const vertexLines = this._vertexShaderParts.shaderLines;
    if (Array.isArray(lines)) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$addAllToArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(vertexLines, lines);
    } else {
        // Single string case
        vertexLines.push(lines);
    }
};
/**
 * Appends lines of GLSL code to the fragment shader
 *
 * @param {string[]} lines The lines to add to the end of the fragment shader source
 *
 * @example
 * shaderBuilder.addFragmentLines([
 *  "void main()",
 *  "{",
 *  "    #ifdef SOLID_COLOR",
 *  "    out_FragColor = vec4(u_color, 1.0);",
 *  "    #else",
 *  "    out_FragColor = vec4(v_color, 1.0);",
 *  "    #endif",
 *  "}"
 * ]);
 */ ShaderBuilder.prototype.addFragmentLines = function(lines) {
    //>>includeStart('debug', pragmas.debug);
    if (typeof lines !== "string" && !Array.isArray(lines)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`Expected lines to be a string or an array of strings, actual value was ${lines}`);
    }
    //>>includeEnd('debug');
    const fragmentLines = this._fragmentShaderParts.shaderLines;
    if (Array.isArray(lines)) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$addAllToArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(fragmentLines, lines);
    } else {
        // Single string case
        fragmentLines.push(lines);
    }
};
/**
 * Builds the {@link ShaderProgram} from the pieces added by the other methods.
 * Call this one time at the end of modifying the shader through the other
 * methods in this class.
 *
 * @param {Context} context The context to use for creating the shader.
 * @return {ShaderProgram} A shader program to use for rendering.
 *
 * @example
 * const shaderProgram = shaderBuilder.buildShaderProgram(context);
 */ ShaderBuilder.prototype.buildShaderProgram = function(context) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.object("context", context);
    //>>includeEnd('debug');
    const positionAttribute = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._positionAttributeLine) ? [
        this._positionAttributeLine
    ] : [];
    const structLines = generateStructLines(this);
    const functionLines = generateFunctionLines(this);
    // Lines are joined here so the ShaderSource
    // generates a single #line 0 directive
    const vertexLines = positionAttribute.concat(this._attributeLines, this._vertexShaderParts.uniformLines, this._vertexShaderParts.varyingLines, structLines.vertexLines, functionLines.vertexLines, this._vertexShaderParts.shaderLines).join("\n");
    const vertexShaderSource = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        defines: this._vertexShaderParts.defineLines,
        sources: [
            vertexLines
        ]
    });
    const fragmentLines = this._fragmentShaderParts.uniformLines.concat(this._fragmentShaderParts.varyingLines, structLines.fragmentLines, functionLines.fragmentLines, this._fragmentShaderParts.shaderLines).join("\n");
    const fragmentShaderSource = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        defines: this._fragmentShaderParts.defineLines,
        sources: [
            fragmentLines
        ]
    });
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderProgram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromCache({
        context: context,
        vertexShaderSource: vertexShaderSource,
        fragmentShaderSource: fragmentShaderSource,
        attributeLocations: this._attributeLocations
    });
};
ShaderBuilder.prototype.clone = function() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$clone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this, true);
};
function generateStructLines(shaderBuilder) {
    const vertexLines = [];
    const fragmentLines = [];
    let i;
    let structIds = shaderBuilder._vertexShaderParts.structIds;
    let structId;
    let struct;
    let structLines;
    for(i = 0; i < structIds.length; i++){
        structId = structIds[i];
        struct = shaderBuilder._structs[structId];
        structLines = struct.generateGlslLines();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$addAllToArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(vertexLines, structLines);
    }
    structIds = shaderBuilder._fragmentShaderParts.structIds;
    for(i = 0; i < structIds.length; i++){
        structId = structIds[i];
        struct = shaderBuilder._structs[structId];
        structLines = struct.generateGlslLines();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$addAllToArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(fragmentLines, structLines);
    }
    return {
        vertexLines: vertexLines,
        fragmentLines: fragmentLines
    };
}
function getAttributeLocationCount(glslType) {
    switch(glslType){
        case "mat2":
            return 2;
        case "mat3":
            return 3;
        case "mat4":
            return 4;
        default:
            return 1;
    }
}
function generateFunctionLines(shaderBuilder) {
    const vertexLines = [];
    const fragmentLines = [];
    let i;
    let functionIds = shaderBuilder._vertexShaderParts.functionIds;
    let functionId;
    let func;
    let functionLines;
    for(i = 0; i < functionIds.length; i++){
        functionId = functionIds[i];
        func = shaderBuilder._functions[functionId];
        functionLines = func.generateGlslLines();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$addAllToArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(vertexLines, functionLines);
    }
    functionIds = shaderBuilder._fragmentShaderParts.functionIds;
    for(i = 0; i < functionIds.length; i++){
        functionId = functionIds[i];
        func = shaderBuilder._functions[functionId];
        functionLines = func.generateGlslLines();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$addAllToArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(fragmentLines, functionLines);
    }
    return {
        vertexLines: vertexLines,
        fragmentLines: fragmentLines
    };
}
const __TURBOPACK__default__export__ = ShaderBuilder;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/ComputeEngine.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoundingRectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/BoundingRectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/destroyObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PrimitiveType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/PrimitiveType.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Shaders$2f$ViewportQuadVS$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Shaders/ViewportQuadVS.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ClearCommand$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ClearCommand.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$DrawCommand$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/DrawCommand.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Framebuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$RenderState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/RenderState.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderProgram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ShaderProgram.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @private
 */ function ComputeEngine(context) {
    this._context = context;
}
let renderStateScratch;
const drawCommandScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$DrawCommand$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
    primitiveType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PrimitiveType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TRIANGLES
});
const clearCommandScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ClearCommand$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
    color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0.0, 0.0, 0.0, 0.0)
});
function createFramebuffer(context, outputTexture) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Framebuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        context: context,
        colorTextures: [
            outputTexture
        ],
        destroyAttachments: false
    });
}
function createViewportQuadShader(context, fragmentShaderSource) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderProgram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromCache({
        context: context,
        vertexShaderSource: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Shaders$2f$ViewportQuadVS$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
        fragmentShaderSource: fragmentShaderSource,
        attributeLocations: {
            position: 0,
            textureCoordinates: 1
        }
    });
}
function createRenderState(width, height) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(renderStateScratch) || renderStateScratch.viewport.width !== width || renderStateScratch.viewport.height !== height) {
        renderStateScratch = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$RenderState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromCache({
            viewport: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoundingRectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0, width, height)
        });
    }
    return renderStateScratch;
}
ComputeEngine.prototype.execute = function(computeCommand) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("computeCommand", computeCommand);
    //>>includeEnd('debug');
    // This may modify the command's resources, so do error checking afterwards
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(computeCommand.preExecute)) {
        computeCommand.preExecute(computeCommand);
    }
    //>>includeStart('debug', pragmas.debug);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(computeCommand.fragmentShaderSource) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(computeCommand.shaderProgram)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("computeCommand.fragmentShaderSource or computeCommand.shaderProgram is required.");
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("computeCommand.outputTexture", computeCommand.outputTexture);
    //>>includeEnd('debug');
    const outputTexture = computeCommand.outputTexture;
    const width = outputTexture.width;
    const height = outputTexture.height;
    const context = this._context;
    const vertexArray = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(computeCommand.vertexArray) ? computeCommand.vertexArray : context.getViewportQuadVertexArray();
    const shaderProgram = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(computeCommand.shaderProgram) ? computeCommand.shaderProgram : createViewportQuadShader(context, computeCommand.fragmentShaderSource);
    const framebuffer = createFramebuffer(context, outputTexture);
    const renderState = createRenderState(width, height);
    const uniformMap = computeCommand.uniformMap;
    const clearCommand = clearCommandScratch;
    clearCommand.framebuffer = framebuffer;
    clearCommand.renderState = renderState;
    clearCommand.execute(context);
    const drawCommand = drawCommandScratch;
    drawCommand.vertexArray = vertexArray;
    drawCommand.renderState = renderState;
    drawCommand.shaderProgram = shaderProgram;
    drawCommand.uniformMap = uniformMap;
    drawCommand.framebuffer = framebuffer;
    drawCommand.execute(context);
    framebuffer.destroy();
    if (!computeCommand.persists) {
        shaderProgram.destroy();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(computeCommand.vertexArray)) {
            vertexArray.destroy();
        }
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(computeCommand.postExecute)) {
        computeCommand.postExecute(outputTexture);
    }
};
ComputeEngine.prototype.isDestroyed = function() {
    return false;
};
ComputeEngine.prototype.destroy = function() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
};
const __TURBOPACK__default__export__ = ComputeEngine;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/PassState.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
/**
 * The state for a particular rendering pass.  This is used to supplement the state
 * in a command being executed.
 *
 * @private
 * @constructor
 */ function PassState(context) {
    /**
   * The context used to execute commands for this pass.
   *
   * @type {Context}
   */ this.context = context;
    /**
   * The framebuffer to render to.  This framebuffer is used unless a {@link DrawCommand}
   * or {@link ClearCommand} explicitly define a framebuffer, which is used for off-screen
   * rendering.
   *
   * @type {Framebuffer}
   * @default undefined
   */ this.framebuffer = undefined;
    /**
   * When defined, this overrides the blending property of a {@link DrawCommand}'s render state.
   * This is used to, for example, to allow the renderer to turn off blending during the picking pass.
   * <p>
   * When this is <code>undefined</code>, the {@link DrawCommand}'s property is used.
   * </p>
   *
   * @type {boolean}
   * @default undefined
   */ this.blendingEnabled = undefined;
    /**
   * When defined, this overrides the scissor test property of a {@link DrawCommand}'s render state.
   * This is used to, for example, to allow the renderer to scissor out the pick region during the picking pass.
   * <p>
   * When this is <code>undefined</code>, the {@link DrawCommand}'s property is used.
   * </p>
   *
   * @type {object}
   * @default undefined
   */ this.scissorTest = undefined;
    /**
   * The viewport used when one is not defined by a {@link DrawCommand}'s render state.
   * @type {BoundingRectangle}
   * @default undefined
   */ this.viewport = undefined;
}
const __TURBOPACK__default__export__ = PassState;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/ShaderCache.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/destroyObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderProgram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ShaderProgram.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ShaderSource.js [app-client] (ecmascript)");
;
;
;
;
/**
 * @private
 */ function ShaderCache(context) {
    this._context = context;
    this._shaders = {};
    this._numberOfShaders = 0;
    this._shadersToRelease = {};
}
Object.defineProperties(ShaderCache.prototype, {
    numberOfShaders: {
        get: function() {
            return this._numberOfShaders;
        }
    }
});
/**
     * Returns a shader program from the cache, or creates and caches a new shader program,
     * given the GLSL vertex and fragment shader source and attribute locations.
     * <p>
     * The difference between this and {@link ShaderCache#getShaderProgram}, is this is used to
     * replace an existing reference to a shader program, which is passed as the first argument.
     * </p>
     *
     * @param {object} options Object with the following properties:
     * @param {ShaderProgram} [options.shaderProgram] The shader program that is being reassigned.
     * @param {string|ShaderSource} options.vertexShaderSource The GLSL source for the vertex shader.
     * @param {string|ShaderSource} options.fragmentShaderSource The GLSL source for the fragment shader.
     * @param {object} options.attributeLocations Indices for the attribute inputs to the vertex shader.

     * @returns {ShaderProgram} The cached or newly created shader program.
     *
     *
     * @example
     * this._shaderProgram = context.shaderCache.replaceShaderProgram({
     *     shaderProgram : this._shaderProgram,
     *     vertexShaderSource : vs,
     *     fragmentShaderSource : fs,
     *     attributeLocations : attributeLocations
     * });
     *
     * @see ShaderCache#getShaderProgram
     */ ShaderCache.prototype.replaceShaderProgram = function(options) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.shaderProgram)) {
        options.shaderProgram.destroy();
    }
    return this.getShaderProgram(options);
};
function toSortedJson(dictionary) {
    const sortedKeys = Object.keys(dictionary).sort();
    return JSON.stringify(dictionary, sortedKeys);
}
/**
 * Returns a shader program from the cache, or creates and caches a new shader program,
 * given the GLSL vertex and fragment shader source and attribute locations.
 *
 * @param {object} options Object with the following properties:
 * @param {string|ShaderSource} options.vertexShaderSource The GLSL source for the vertex shader.
 * @param {string|ShaderSource} options.fragmentShaderSource The GLSL source for the fragment shader.
 * @param {object} options.attributeLocations Indices for the attribute inputs to the vertex shader.
 *
 * @returns {ShaderProgram} The cached or newly created shader program.
 */ ShaderCache.prototype.getShaderProgram = function(options) {
    // convert shaders which are provided as strings into ShaderSource objects
    // because ShaderSource handles all the automatic including of built-in functions, etc.
    let vertexShaderSource = options.vertexShaderSource;
    let fragmentShaderSource = options.fragmentShaderSource;
    const attributeLocations = options.attributeLocations;
    if (typeof vertexShaderSource === "string") {
        vertexShaderSource = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            sources: [
                vertexShaderSource
            ]
        });
    }
    if (typeof fragmentShaderSource === "string") {
        fragmentShaderSource = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            sources: [
                fragmentShaderSource
            ]
        });
    }
    // Since ShaderSource.createCombinedXxxShader() can be expensive, use a
    // simpler key for caching. This way, the function does not have to be called
    // for each cache lookup.
    const vertexShaderKey = vertexShaderSource.getCacheKey();
    const fragmentShaderKey = fragmentShaderSource.getCacheKey();
    // Sort the keys in the JSON to ensure a consistent order
    const attributeLocationKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(attributeLocations) ? toSortedJson(attributeLocations) : "";
    const keyword = `${vertexShaderKey}:${fragmentShaderKey}:${attributeLocationKey}`;
    let cachedShader;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this._shaders[keyword])) {
        cachedShader = this._shaders[keyword];
        // No longer want to release this if it was previously released.
        delete this._shadersToRelease[keyword];
    } else {
        const context = this._context;
        const vertexShaderText = vertexShaderSource.createCombinedVertexShader(context);
        const fragmentShaderText = fragmentShaderSource.createCombinedFragmentShader(context);
        const shaderProgram = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderProgram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            gl: context._gl,
            logShaderCompilation: context.logShaderCompilation,
            debugShaders: context.debugShaders,
            vertexShaderSource: vertexShaderSource,
            vertexShaderText: vertexShaderText,
            fragmentShaderSource: fragmentShaderSource,
            fragmentShaderText: fragmentShaderText,
            attributeLocations: attributeLocations
        });
        cachedShader = {
            cache: this,
            shaderProgram: shaderProgram,
            keyword: keyword,
            derivedKeywords: [],
            count: 0
        };
        // A shader can't be in more than one cache.
        shaderProgram._cachedShader = cachedShader;
        this._shaders[keyword] = cachedShader;
        ++this._numberOfShaders;
    }
    ++cachedShader.count;
    return cachedShader.shaderProgram;
};
ShaderCache.prototype.replaceDerivedShaderProgram = function(shaderProgram, keyword, options) {
    const cachedShader = shaderProgram._cachedShader;
    const derivedKeyword = keyword + cachedShader.keyword;
    const cachedDerivedShader = this._shaders[derivedKeyword];
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(cachedDerivedShader)) {
        destroyShader(this, cachedDerivedShader);
        const index = cachedShader.derivedKeywords.indexOf(keyword);
        if (index > -1) {
            cachedShader.derivedKeywords.splice(index, 1);
        }
    }
    return this.createDerivedShaderProgram(shaderProgram, keyword, options);
};
ShaderCache.prototype.getDerivedShaderProgram = function(shaderProgram, keyword) {
    const cachedShader = shaderProgram._cachedShader;
    const derivedKeyword = keyword + cachedShader.keyword;
    const cachedDerivedShader = this._shaders[derivedKeyword];
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(cachedDerivedShader)) {
        return undefined;
    }
    return cachedDerivedShader.shaderProgram;
};
ShaderCache.prototype.createDerivedShaderProgram = function(shaderProgram, keyword, options) {
    const cachedShader = shaderProgram._cachedShader;
    const derivedKeyword = keyword + cachedShader.keyword;
    let vertexShaderSource = options.vertexShaderSource;
    let fragmentShaderSource = options.fragmentShaderSource;
    const attributeLocations = options.attributeLocations;
    if (typeof vertexShaderSource === "string") {
        vertexShaderSource = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            sources: [
                vertexShaderSource
            ]
        });
    }
    if (typeof fragmentShaderSource === "string") {
        fragmentShaderSource = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            sources: [
                fragmentShaderSource
            ]
        });
    }
    const context = this._context;
    const vertexShaderText = vertexShaderSource.createCombinedVertexShader(context);
    const fragmentShaderText = fragmentShaderSource.createCombinedFragmentShader(context);
    const derivedShaderProgram = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderProgram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        gl: context._gl,
        logShaderCompilation: context.logShaderCompilation,
        debugShaders: context.debugShaders,
        vertexShaderSource: vertexShaderSource,
        vertexShaderText: vertexShaderText,
        fragmentShaderSource: fragmentShaderSource,
        fragmentShaderText: fragmentShaderText,
        attributeLocations: attributeLocations
    });
    const derivedCachedShader = {
        cache: this,
        shaderProgram: derivedShaderProgram,
        keyword: derivedKeyword,
        derivedKeywords: [],
        count: 0
    };
    cachedShader.derivedKeywords.push(keyword);
    derivedShaderProgram._cachedShader = derivedCachedShader;
    this._shaders[derivedKeyword] = derivedCachedShader;
    return derivedShaderProgram;
};
function destroyShader(cache, cachedShader) {
    const derivedKeywords = cachedShader.derivedKeywords;
    const length = derivedKeywords.length;
    for(let i = 0; i < length; ++i){
        const keyword = derivedKeywords[i] + cachedShader.keyword;
        const derivedCachedShader = cache._shaders[keyword];
        destroyShader(cache, derivedCachedShader);
    }
    delete cache._shaders[cachedShader.keyword];
    cachedShader.shaderProgram.finalDestroy();
}
ShaderCache.prototype.destroyReleasedShaderPrograms = function() {
    const shadersToRelease = this._shadersToRelease;
    for(const keyword in shadersToRelease){
        if (shadersToRelease.hasOwnProperty(keyword)) {
            const cachedShader = shadersToRelease[keyword];
            destroyShader(this, cachedShader);
            --this._numberOfShaders;
        }
    }
    this._shadersToRelease = {};
};
ShaderCache.prototype.releaseShaderProgram = function(shaderProgram) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(shaderProgram)) {
        const cachedShader = shaderProgram._cachedShader;
        if (cachedShader && --cachedShader.count === 0) {
            this._shadersToRelease[cachedShader.keyword] = cachedShader;
        }
    }
};
ShaderCache.prototype.isDestroyed = function() {
    return false;
};
ShaderCache.prototype.destroy = function() {
    const shaders = this._shaders;
    for(const keyword in shaders){
        if (shaders.hasOwnProperty(keyword)) {
            shaders[keyword].shaderProgram.finalDestroy();
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
};
const __TURBOPACK__default__export__ = ShaderCache;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/TextureCache.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/destroyObject.js [app-client] (ecmascript)");
;
;
/**
 * @private
 */ function TextureCache() {
    this._textures = {};
    this._numberOfTextures = 0;
    this._texturesToRelease = {};
}
Object.defineProperties(TextureCache.prototype, {
    numberOfTextures: {
        get: function() {
            return this._numberOfTextures;
        }
    }
});
TextureCache.prototype.getTexture = function(keyword) {
    const cachedTexture = this._textures[keyword];
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(cachedTexture)) {
        return undefined;
    }
    // No longer want to release this if it was previously released.
    delete this._texturesToRelease[keyword];
    ++cachedTexture.count;
    return cachedTexture.texture;
};
TextureCache.prototype.addTexture = function(keyword, texture) {
    const cachedTexture = {
        texture: texture,
        count: 1
    };
    texture.finalDestroy = texture.destroy;
    const that = this;
    texture.destroy = function() {
        if (--cachedTexture.count === 0) {
            that._texturesToRelease[keyword] = cachedTexture;
        }
    };
    this._textures[keyword] = cachedTexture;
    ++this._numberOfTextures;
};
TextureCache.prototype.destroyReleasedTextures = function() {
    const texturesToRelease = this._texturesToRelease;
    for(const keyword in texturesToRelease){
        if (texturesToRelease.hasOwnProperty(keyword)) {
            const cachedTexture = texturesToRelease[keyword];
            delete this._textures[keyword];
            cachedTexture.texture.finalDestroy();
            --this._numberOfTextures;
        }
    }
    this._texturesToRelease = {};
};
TextureCache.prototype.isDestroyed = function() {
    return false;
};
TextureCache.prototype.destroy = function() {
    const textures = this._textures;
    for(const keyword in textures){
        if (textures.hasOwnProperty(keyword)) {
            textures[keyword].texture.finalDestroy();
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
};
const __TURBOPACK__default__export__ = TextureCache;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/UniformState.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoundingRectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/BoundingRectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartesian2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartesian3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartesian4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Cartographic.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Ellipsoid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Ellipsoid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$EncodedCartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/EncodedCartesian3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Matrix3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Matrix4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$OrthographicFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/OrthographicFrustum.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Simon1994PlanetaryPositions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Simon1994PlanetaryPositions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Transforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Transforms.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Scene/SceneMode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SunLight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Scene/SunLight.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @private
 * @constructor
 */ function UniformState() {
    /**
   * @type {Texture}
   */ this.globeDepthTexture = undefined;
    /**
   * @type {Texture}
   */ this.edgeIdTexture = undefined;
    /**
   * @type {Texture}
   */ this.edgeColorTexture = undefined;
    /**
   * @type {Texture}
   */ this.edgeDepthTexture = undefined; // packed depth color attachment from edge pass
    /**
   * @type {number}
   */ this.gamma = undefined;
    this._viewport = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoundingRectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._viewportCartesian4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._viewportDirty = false;
    this._viewportOrthographicMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY);
    this._viewportTransformation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY);
    this._model = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY);
    this._view = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY);
    this._inverseView = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY);
    this._projection = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY);
    this._infiniteProjection = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY);
    this._entireFrustum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._currentFrustum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._frustumPlanes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._farDepthFromNearPlusOne = undefined;
    this._log2FarDepthFromNearPlusOne = undefined;
    this._oneOverLog2FarDepthFromNearPlusOne = undefined;
    this._frameState = undefined;
    this._temeToPseudoFixed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY);
    // Derived members
    this._view3DDirty = true;
    this._view3D = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._inverseView3DDirty = true;
    this._inverseView3D = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._inverseModelDirty = true;
    this._inverseModel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._inverseTransposeModelDirty = true;
    this._inverseTransposeModel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._viewRotation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._inverseViewRotation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._viewRotation3D = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._inverseViewRotation3D = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._inverseProjectionDirty = true;
    this._inverseProjection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._modelViewDirty = true;
    this._modelView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._modelView3DDirty = true;
    this._modelView3D = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._modelViewRelativeToEyeDirty = true;
    this._modelViewRelativeToEye = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._inverseModelViewDirty = true;
    this._inverseModelView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._inverseModelView3DDirty = true;
    this._inverseModelView3D = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._viewProjectionDirty = true;
    this._viewProjection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._inverseViewProjectionDirty = true;
    this._inverseViewProjection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._modelViewProjectionDirty = true;
    this._modelViewProjection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._inverseModelViewProjectionDirty = true;
    this._inverseModelViewProjection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._modelViewProjectionRelativeToEyeDirty = true;
    this._modelViewProjectionRelativeToEye = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._modelViewInfiniteProjectionDirty = true;
    this._modelViewInfiniteProjection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._normalDirty = true;
    this._normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._normal3DDirty = true;
    this._normal3D = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._inverseNormalDirty = true;
    this._inverseNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._inverseNormal3DDirty = true;
    this._inverseNormal3D = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._encodedCameraPositionMCDirty = true;
    this._encodedCameraPositionMC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$EncodedCartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._cameraPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._sunPositionWC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._sunPositionColumbusView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._sunDirectionWC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._sunDirectionEC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._moonDirectionEC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._lightDirectionWC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._lightDirectionEC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._lightColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._lightColorHdr = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._pass = undefined;
    this._mode = undefined;
    this._mapProjection = undefined;
    this._ellipsoid = undefined;
    this._cameraDirection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._cameraRight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._cameraUp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._frustum2DWidth = 0.0;
    this._eyeHeight = 0.0;
    this._eyeHeight2D = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._eyeEllipsoidNormalEC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._eyeEllipsoidCurvature = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._modelToEnu = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._enuToModel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._pixelRatio = 1.0;
    this._orthographicIn3D = false;
    this._backgroundColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._brdfLut = undefined;
    this._environmentMap = undefined;
    this._sphericalHarmonicCoefficients = undefined;
    this._specularEnvironmentMaps = undefined;
    this._specularEnvironmentMapsMaximumLOD = undefined;
    this._fogDensity = undefined;
    this._fogVisualDensityScalar = undefined;
    this._fogMinimumBrightness = undefined;
    this._atmosphereHsbShift = undefined;
    this._atmosphereLightIntensity = undefined;
    this._atmosphereRayleighCoefficient = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._atmosphereRayleighScaleHeight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._atmosphereMieCoefficient = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._atmosphereMieScaleHeight = undefined;
    this._atmosphereMieAnisotropy = undefined;
    this._atmosphereDynamicLighting = undefined;
    this._invertClassificationColor = undefined;
    this._splitPosition = 0.0;
    this._pixelSizePerMeter = undefined;
    this._geometricToleranceOverMeter = undefined;
    this._minimumDisableDepthTestDistance = undefined;
}
Object.defineProperties(UniformState.prototype, {
    /**
   * @memberof UniformState.prototype
   * @type {FrameState}
   * @readonly
   */ frameState: {
        get: function() {
            return this._frameState;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {BoundingRectangle}
   */ viewport: {
        get: function() {
            return this._viewport;
        },
        set: function(viewport) {
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoundingRectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(viewport, this._viewport)) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$BoundingRectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(viewport, this._viewport);
                const v = this._viewport;
                const vc = this._viewportCartesian4;
                vc.x = v.x;
                vc.y = v.y;
                vc.z = v.width;
                vc.w = v.height;
                this._viewportDirty = true;
            }
        }
    },
    /**
   * @memberof UniformState.prototype
   * @private
   */ viewportCartesian4: {
        get: function() {
            return this._viewportCartesian4;
        }
    },
    viewportOrthographic: {
        get: function() {
            cleanViewport(this);
            return this._viewportOrthographicMatrix;
        }
    },
    viewportTransformation: {
        get: function() {
            cleanViewport(this);
            return this._viewportTransformation;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ model: {
        get: function() {
            return this._model;
        },
        set: function(matrix) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(matrix, this._model);
            this._modelView3DDirty = true;
            this._inverseModelView3DDirty = true;
            this._inverseModelDirty = true;
            this._inverseTransposeModelDirty = true;
            this._modelViewDirty = true;
            this._inverseModelViewDirty = true;
            this._modelViewRelativeToEyeDirty = true;
            this._inverseModelViewDirty = true;
            this._modelViewProjectionDirty = true;
            this._inverseModelViewProjectionDirty = true;
            this._modelViewProjectionRelativeToEyeDirty = true;
            this._modelViewInfiniteProjectionDirty = true;
            this._normalDirty = true;
            this._inverseNormalDirty = true;
            this._normal3DDirty = true;
            this._inverseNormal3DDirty = true;
            this._encodedCameraPositionMCDirty = true;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ inverseModel: {
        get: function() {
            if (this._inverseModelDirty) {
                this._inverseModelDirty = false;
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].inverse(this._model, this._inverseModel);
            }
            return this._inverseModel;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @private
   */ inverseTransposeModel: {
        get: function() {
            const m = this._inverseTransposeModel;
            if (this._inverseTransposeModelDirty) {
                this._inverseTransposeModelDirty = false;
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getMatrix3(this.inverseModel, m);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transpose(m, m);
            }
            return m;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ view: {
        get: function() {
            return this._view;
        }
    },
    /**
   * The 3D view matrix.  In 3D mode, this is identical to {@link UniformState#view},
   * but in 2D and Columbus View it is a synthetic matrix based on the equivalent position
   * of the camera in the 3D world.
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ view3D: {
        get: function() {
            updateView3D(this);
            return this._view3D;
        }
    },
    /**
   * The 3x3 rotation matrix of the current view matrix ({@link UniformState#view}).
   * @memberof UniformState.prototype
   * @type {Matrix3}
   */ viewRotation: {
        get: function() {
            updateView3D(this);
            return this._viewRotation;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Matrix3}
   */ viewRotation3D: {
        get: function() {
            updateView3D(this);
            return this._viewRotation3D;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ inverseView: {
        get: function() {
            return this._inverseView;
        }
    },
    /**
   * the 4x4 inverse-view matrix that transforms from eye to 3D world coordinates.  In 3D mode, this is
   * identical to {@link UniformState#inverseView}, but in 2D and Columbus View it is a synthetic matrix
   * based on the equivalent position of the camera in the 3D world.
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ inverseView3D: {
        get: function() {
            updateInverseView3D(this);
            return this._inverseView3D;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Matrix3}
   */ inverseViewRotation: {
        get: function() {
            return this._inverseViewRotation;
        }
    },
    /**
   * The 3x3 rotation matrix of the current 3D inverse-view matrix ({@link UniformState#inverseView3D}).
   * @memberof UniformState.prototype
   * @type {Matrix3}
   */ inverseViewRotation3D: {
        get: function() {
            updateInverseView3D(this);
            return this._inverseViewRotation3D;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ projection: {
        get: function() {
            return this._projection;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ inverseProjection: {
        get: function() {
            cleanInverseProjection(this);
            return this._inverseProjection;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ infiniteProjection: {
        get: function() {
            return this._infiniteProjection;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ modelView: {
        get: function() {
            cleanModelView(this);
            return this._modelView;
        }
    },
    /**
   * The 3D model-view matrix.  In 3D mode, this is equivalent to {@link UniformState#modelView}.  In 2D and
   * Columbus View, however, it is a synthetic matrix based on the equivalent position of the camera in the 3D world.
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ modelView3D: {
        get: function() {
            cleanModelView3D(this);
            return this._modelView3D;
        }
    },
    /**
   * Model-view relative to eye matrix.
   *
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ modelViewRelativeToEye: {
        get: function() {
            cleanModelViewRelativeToEye(this);
            return this._modelViewRelativeToEye;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ inverseModelView: {
        get: function() {
            cleanInverseModelView(this);
            return this._inverseModelView;
        }
    },
    /**
   * The inverse of the 3D model-view matrix.  In 3D mode, this is equivalent to {@link UniformState#inverseModelView}.
   * In 2D and Columbus View, however, it is a synthetic matrix based on the equivalent position of the camera in the 3D world.
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ inverseModelView3D: {
        get: function() {
            cleanInverseModelView3D(this);
            return this._inverseModelView3D;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ viewProjection: {
        get: function() {
            cleanViewProjection(this);
            return this._viewProjection;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ inverseViewProjection: {
        get: function() {
            cleanInverseViewProjection(this);
            return this._inverseViewProjection;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ modelViewProjection: {
        get: function() {
            cleanModelViewProjection(this);
            return this._modelViewProjection;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ inverseModelViewProjection: {
        get: function() {
            cleanInverseModelViewProjection(this);
            return this._inverseModelViewProjection;
        }
    },
    /**
   * Model-view-projection relative to eye matrix.
   *
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ modelViewProjectionRelativeToEye: {
        get: function() {
            cleanModelViewProjectionRelativeToEye(this);
            return this._modelViewProjectionRelativeToEye;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ modelViewInfiniteProjection: {
        get: function() {
            cleanModelViewInfiniteProjection(this);
            return this._modelViewInfiniteProjection;
        }
    },
    /**
   * A 3x3 normal transformation matrix that transforms normal vectors in model coordinates to
   * eye coordinates.
   * @memberof UniformState.prototype
   * @type {Matrix3}
   */ normal: {
        get: function() {
            cleanNormal(this);
            return this._normal;
        }
    },
    /**
   * A 3x3 normal transformation matrix that transforms normal vectors in 3D model
   * coordinates to eye coordinates.  In 3D mode, this is identical to
   * {@link UniformState#normal}, but in 2D and Columbus View it represents the normal transformation
   * matrix as if the camera were at an equivalent location in 3D mode.
   * @memberof UniformState.prototype
   * @type {Matrix3}
   */ normal3D: {
        get: function() {
            cleanNormal3D(this);
            return this._normal3D;
        }
    },
    /**
   * An inverse 3x3 normal transformation matrix that transforms normal vectors in model coordinates
   * to eye coordinates.
   * @memberof UniformState.prototype
   * @type {Matrix3}
   */ inverseNormal: {
        get: function() {
            cleanInverseNormal(this);
            return this._inverseNormal;
        }
    },
    /**
   * An inverse 3x3 normal transformation matrix that transforms normal vectors in eye coordinates
   * to 3D model coordinates.  In 3D mode, this is identical to
   * {@link UniformState#inverseNormal}, but in 2D and Columbus View it represents the normal transformation
   * matrix as if the camera were at an equivalent location in 3D mode.
   * @memberof UniformState.prototype
   * @type {Matrix3}
   */ inverseNormal3D: {
        get: function() {
            cleanInverseNormal3D(this);
            return this._inverseNormal3D;
        }
    },
    /**
   * The near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.
   * This is the largest possible frustum, not an individual frustum used for multi-frustum rendering.
   * @memberof UniformState.prototype
   * @type {Cartesian2}
   */ entireFrustum: {
        get: function() {
            return this._entireFrustum;
        }
    },
    /**
   * The near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.
   * This is the individual frustum used for multi-frustum rendering.
   * @memberof UniformState.prototype
   * @type {Cartesian2}
   */ currentFrustum: {
        get: function() {
            return this._currentFrustum;
        }
    },
    /**
   * The distances to the frustum planes. The top, bottom, left and right distances are
   * the x, y, z, and w components, respectively.
   * @memberof UniformState.prototype
   * @type {Cartesian4}
   */ frustumPlanes: {
        get: function() {
            return this._frustumPlanes;
        }
    },
    /**
   * The far plane's distance from the near plane, plus 1.0.
   *
   * @memberof UniformState.prototype
   * @type {number}
   */ farDepthFromNearPlusOne: {
        get: function() {
            return this._farDepthFromNearPlusOne;
        }
    },
    /**
   * The log2 of {@link UniformState#farDepthFromNearPlusOne}.
   *
   * @memberof UniformState.prototype
   * @type {number}
   */ log2FarDepthFromNearPlusOne: {
        get: function() {
            return this._log2FarDepthFromNearPlusOne;
        }
    },
    /**
   * 1.0 divided by {@link UniformState#log2FarDepthFromNearPlusOne}.
   *
   * @memberof UniformState.prototype
   * @type {number}
   */ oneOverLog2FarDepthFromNearPlusOne: {
        get: function() {
            return this._oneOverLog2FarDepthFromNearPlusOne;
        }
    },
    /**
   * The height in meters of the eye (camera) above or below the ellipsoid.
   * @memberof UniformState.prototype
   * @type {number}
   */ eyeHeight: {
        get: function() {
            return this._eyeHeight;
        }
    },
    /**
   * The height (<code>x</code>) and the height squared (<code>y</code>)
   * in meters of the eye (camera) above the 2D world plane. This uniform is only valid
   * when the {@link SceneMode} is <code>SCENE2D</code>.
   * @memberof UniformState.prototype
   * @type {Cartesian2}
   */ eyeHeight2D: {
        get: function() {
            return this._eyeHeight2D;
        }
    },
    /**
   * The ellipsoid surface normal at the camera position, in model coordinates.
   * @memberof UniformState.prototype
   * @type {Cartesian3}
   */ eyeEllipsoidNormalEC: {
        get: function() {
            return this._eyeEllipsoidNormalEC;
        }
    },
    /**
   * The ellipsoid radii of curvature at the camera position.
   * The .x component is the prime vertical radius, .y is the meridional.
   * @memberof UniformState.prototype
   * @type {Cartesian2}
   */ eyeEllipsoidCurvature: {
        get: function() {
            return this._eyeEllipsoidCurvature;
        }
    },
    /**
   * A transform from model coordinates to an east-north-up coordinate system
   * centered at the position on the ellipsoid below the camera
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ modelToEnu: {
        get: function() {
            return this._modelToEnu;
        }
    },
    /**
   * The inverse of {@link UniformState.prototype.modelToEnu}
   * @memberof UniformState.prototype
   * @type {Matrix4}
   */ enuToModel: {
        get: function() {
            return this._enuToModel;
        }
    },
    /**
   * The sun position in 3D world coordinates at the current scene time.
   * @memberof UniformState.prototype
   * @type {Cartesian3}
   */ sunPositionWC: {
        get: function() {
            return this._sunPositionWC;
        }
    },
    /**
   * The sun position in 2D world coordinates at the current scene time.
   * @memberof UniformState.prototype
   * @type {Cartesian3}
   */ sunPositionColumbusView: {
        get: function() {
            return this._sunPositionColumbusView;
        }
    },
    /**
   * A normalized vector to the sun in 3D world coordinates at the current scene time.  Even in 2D or
   * Columbus View mode, this returns the direction to the sun in the 3D scene.
   * @memberof UniformState.prototype
   * @type {Cartesian3}
   */ sunDirectionWC: {
        get: function() {
            return this._sunDirectionWC;
        }
    },
    /**
   * A normalized vector to the sun in eye coordinates at the current scene time.  In 3D mode, this
   * returns the actual vector from the camera position to the sun position.  In 2D and Columbus View, it returns
   * the vector from the equivalent 3D camera position to the position of the sun in the 3D scene.
   * @memberof UniformState.prototype
   * @type {Cartesian3}
   */ sunDirectionEC: {
        get: function() {
            return this._sunDirectionEC;
        }
    },
    /**
   * A normalized vector to the moon in eye coordinates at the current scene time.  In 3D mode, this
   * returns the actual vector from the camera position to the moon position.  In 2D and Columbus View, it returns
   * the vector from the equivalent 3D camera position to the position of the moon in the 3D scene.
   * @memberof UniformState.prototype
   * @type {Cartesian3}
   */ moonDirectionEC: {
        get: function() {
            return this._moonDirectionEC;
        }
    },
    /**
   * A normalized vector to the scene's light source in 3D world coordinates.  Even in 2D or
   * Columbus View mode, this returns the direction to the light in the 3D scene.
   * @memberof UniformState.prototype
   * @type {Cartesian3}
   */ lightDirectionWC: {
        get: function() {
            return this._lightDirectionWC;
        }
    },
    /**
   * A normalized vector to the scene's light source in eye coordinates.  In 3D mode, this
   * returns the actual vector from the camera position to the light.  In 2D and Columbus View, it returns
   * the vector from the equivalent 3D camera position in the 3D scene.
   * @memberof UniformState.prototype
   * @type {Cartesian3}
   */ lightDirectionEC: {
        get: function() {
            return this._lightDirectionEC;
        }
    },
    /**
   * The color of light emitted by the scene's light source. This is equivalent to the light
   * color multiplied by the light intensity limited to a maximum luminance of 1.0 suitable
   * for non-HDR lighting.
   * @memberof UniformState.prototype
   * @type {Cartesian3}
   */ lightColor: {
        get: function() {
            return this._lightColor;
        }
    },
    /**
   * The high dynamic range color of light emitted by the scene's light source. This is equivalent to
   * the light color multiplied by the light intensity suitable for HDR lighting.
   * @memberof UniformState.prototype
   * @type {Cartesian3}
   */ lightColorHdr: {
        get: function() {
            return this._lightColorHdr;
        }
    },
    /**
   * The high bits of the camera position.
   * @memberof UniformState.prototype
   * @type {Cartesian3}
   */ encodedCameraPositionMCHigh: {
        get: function() {
            cleanEncodedCameraPositionMC(this);
            return this._encodedCameraPositionMC.high;
        }
    },
    /**
   * The low bits of the camera position.
   * @memberof UniformState.prototype
   * @type {Cartesian3}
   */ encodedCameraPositionMCLow: {
        get: function() {
            cleanEncodedCameraPositionMC(this);
            return this._encodedCameraPositionMC.low;
        }
    },
    /**
   * A 3x3 matrix that transforms from True Equator Mean Equinox (TEME) axes to the
   * pseudo-fixed axes at the Scene's current time.
   * @memberof UniformState.prototype
   * @type {Matrix3}
   */ temeToPseudoFixedMatrix: {
        get: function() {
            return this._temeToPseudoFixed;
        }
    },
    /**
   * Gets the scaling factor for transforming from the canvas
   * pixel space to canvas coordinate space.
   * @memberof UniformState.prototype
   * @type {number}
   */ pixelRatio: {
        get: function() {
            return this._pixelRatio;
        }
    },
    /**
   * A scalar used to mix a color with the fog color based on the distance to the camera.
   * @memberof UniformState.prototype
   * @type {number}
   */ fogDensity: {
        get: function() {
            return this._fogDensity;
        }
    },
    /**
   * A scalar used to mix a color with the fog color based on the distance to the camera.
   * @memberof UniformState.prototype
   * @type {number}
   */ fogVisualDensityScalar: {
        get: function() {
            return this._fogVisualDensityScalar;
        }
    },
    /**
   * A scalar used as a minimum value when brightening fog
   * @memberof UniformState.prototype
   * @type {number}
   */ fogMinimumBrightness: {
        get: function() {
            return this._fogMinimumBrightness;
        }
    },
    /**
   * A color shift to apply to the atmosphere color in HSB.
   * @memberof UniformState.prototype
   * @type {Cartesian3}
   */ atmosphereHsbShift: {
        get: function() {
            return this._atmosphereHsbShift;
        }
    },
    /**
   * The intensity of the light that is used for computing the atmosphere color
   * @memberof UniformState.prototype
   * @type {number}
   */ atmosphereLightIntensity: {
        get: function() {
            return this._atmosphereLightIntensity;
        }
    },
    /**
   * The Rayleigh scattering coefficient used in the atmospheric scattering equations for the sky atmosphere.
   * @memberof UniformState.prototype
   * @type {Cartesian3}
   */ atmosphereRayleighCoefficient: {
        get: function() {
            return this._atmosphereRayleighCoefficient;
        }
    },
    /**
   * The Rayleigh scale height used in the atmospheric scattering equations for the sky atmosphere, in meters.
   * @memberof UniformState.prototype
   * @type {number}
   */ atmosphereRayleighScaleHeight: {
        get: function() {
            return this._atmosphereRayleighScaleHeight;
        }
    },
    /**
   * The Mie scattering coefficient used in the atmospheric scattering equations for the sky atmosphere.
   * @memberof UniformState.prototype
   * @type {Cartesian3}
   */ atmosphereMieCoefficient: {
        get: function() {
            return this._atmosphereMieCoefficient;
        }
    },
    /**
   * The Mie scale height used in the atmospheric scattering equations for the sky atmosphere, in meters.
   * @memberof UniformState.prototype
   * @type {number}
   */ atmosphereMieScaleHeight: {
        get: function() {
            return this._atmosphereMieScaleHeight;
        }
    },
    /**
   * The anisotropy of the medium to consider for Mie scattering.
   * @memberof UniformState.prototype
   * @type {number}
   */ atmosphereMieAnisotropy: {
        get: function() {
            return this._atmosphereMieAnisotropy;
        }
    },
    /**
   * Which light source to use for dynamically lighting the atmosphere
   *
   * @memberof UniformState.prototype
   * @type {DynamicAtmosphereLightingType}
   */ atmosphereDynamicLighting: {
        get: function() {
            return this._atmosphereDynamicLighting;
        }
    },
    /**
   * A scalar that represents the geometric tolerance per meter
   * @memberof UniformState.prototype
   * @type {number}
   */ geometricToleranceOverMeter: {
        get: function() {
            return this._geometricToleranceOverMeter;
        }
    },
    /**
   * @memberof UniformState.prototype
   * @type {Pass}
   */ pass: {
        get: function() {
            return this._pass;
        }
    },
    /**
   * The current background color
   * @memberof UniformState.prototype
   * @type {Color}
   */ backgroundColor: {
        get: function() {
            return this._backgroundColor;
        }
    },
    /**
   * The look up texture used to find the BRDF for a material
   * @memberof UniformState.prototype
   * @type {Texture}
   */ brdfLut: {
        get: function() {
            return this._brdfLut;
        }
    },
    /**
   * The environment map of the scene
   * @memberof UniformState.prototype
   * @type {CubeMap}
   */ environmentMap: {
        get: function() {
            return this._environmentMap;
        }
    },
    /**
   * The spherical harmonic coefficients of the scene.
   * @memberof UniformState.prototype
   * @type {Cartesian3[]}
   */ sphericalHarmonicCoefficients: {
        get: function() {
            return this._sphericalHarmonicCoefficients;
        }
    },
    /**
   * The specular environment cube map of the scene.
   * @memberof UniformState.prototype
   * @type {Texture}
   */ specularEnvironmentMaps: {
        get: function() {
            return this._specularEnvironmentMaps;
        }
    },
    /**
   * The maximum level-of-detail of the specular environment cube map of the scene.
   * @memberof UniformState.prototype
   * @type {number}
   */ specularEnvironmentMapsMaximumLOD: {
        get: function() {
            return this._specularEnvironmentMapsMaximumLOD;
        }
    },
    /**
   * The splitter position to use when rendering with a splitter. This will be in pixel coordinates relative to the canvas.
   * @memberof UniformState.prototype
   * @type {number}
   */ splitPosition: {
        get: function() {
            return this._splitPosition;
        }
    },
    /**
   * The distance from the camera at which to disable the depth test of billboards, labels and points
   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always
   * be applied. When less than zero, the depth test should never be applied.
   *
   * @memberof UniformState.prototype
   * @type {number}
   */ minimumDisableDepthTestDistance: {
        get: function() {
            return this._minimumDisableDepthTestDistance;
        }
    },
    /**
   * The highlight color of unclassified 3D Tiles.
   *
   * @memberof UniformState.prototype
   * @type {Color}
   */ invertClassificationColor: {
        get: function() {
            return this._invertClassificationColor;
        }
    },
    /**
   * Whether or not the current projection is orthographic in 3D.
   *
   * @memberOf UniformState.prototype
   * @type {boolean}
   */ orthographicIn3D: {
        get: function() {
            return this._orthographicIn3D;
        }
    },
    /**
   * The current ellipsoid.
   *
   * @memberOf UniformState.prototype
   * @type {Ellipsoid}
   */ ellipsoid: {
        get: function() {
            return this._ellipsoid ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Ellipsoid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].default;
        }
    }
});
function setView(uniformState, matrix) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(matrix, uniformState._view);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getMatrix3(matrix, uniformState._viewRotation);
    uniformState._view3DDirty = true;
    uniformState._inverseView3DDirty = true;
    uniformState._modelViewDirty = true;
    uniformState._modelView3DDirty = true;
    uniformState._modelViewRelativeToEyeDirty = true;
    uniformState._inverseModelViewDirty = true;
    uniformState._inverseModelView3DDirty = true;
    uniformState._viewProjectionDirty = true;
    uniformState._inverseViewProjectionDirty = true;
    uniformState._modelViewProjectionDirty = true;
    uniformState._modelViewProjectionRelativeToEyeDirty = true;
    uniformState._modelViewInfiniteProjectionDirty = true;
    uniformState._normalDirty = true;
    uniformState._inverseNormalDirty = true;
    uniformState._normal3DDirty = true;
    uniformState._inverseNormal3DDirty = true;
}
function setInverseView(uniformState, matrix) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(matrix, uniformState._inverseView);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getMatrix3(matrix, uniformState._inverseViewRotation);
}
function setProjection(uniformState, matrix) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(matrix, uniformState._projection);
    uniformState._inverseProjectionDirty = true;
    uniformState._viewProjectionDirty = true;
    uniformState._inverseViewProjectionDirty = true;
    uniformState._modelViewProjectionDirty = true;
    uniformState._modelViewProjectionRelativeToEyeDirty = true;
}
function setInfiniteProjection(uniformState, matrix) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(matrix, uniformState._infiniteProjection);
    uniformState._modelViewInfiniteProjectionDirty = true;
}
const surfacePositionScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const enuTransformScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function setCamera(uniformState, camera) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.positionWC, uniformState._cameraPosition);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.directionWC, uniformState._cameraDirection);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.rightWC, uniformState._cameraRight);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(camera.upWC, uniformState._cameraUp);
    const ellipsoid = uniformState._ellipsoid;
    let surfacePosition;
    const positionCartographic = camera.positionCartographic;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(positionCartographic)) {
        uniformState._eyeHeight = -ellipsoid.maximumRadius;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].magnitude(camera.positionWC) > 0.0) {
            uniformState._eyeEllipsoidNormalEC = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(camera.positionWC, uniformState._eyeEllipsoidNormalEC);
        }
        surfacePosition = ellipsoid.scaleToGeodeticSurface(camera.positionWC, surfacePositionScratch);
    } else {
        uniformState._eyeHeight = positionCartographic.height;
        uniformState._eyeEllipsoidNormalEC = ellipsoid.geodeticSurfaceNormalCartographic(positionCartographic, uniformState._eyeEllipsoidNormalEC);
        surfacePosition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromRadians(positionCartographic.longitude, positionCartographic.latitude, 0.0, ellipsoid, surfacePositionScratch);
    }
    uniformState._encodedCameraPositionMCDirty = true;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(surfacePosition)) {
        return;
    }
    uniformState._eyeEllipsoidNormalEC = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByVector(uniformState._viewRotation, uniformState._eyeEllipsoidNormalEC, uniformState._eyeEllipsoidNormalEC);
    const enuToWorld = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Transforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eastNorthUpToFixedFrame(surfacePosition, ellipsoid, enuTransformScratch);
    uniformState._enuToModel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyTransformation(uniformState.inverseModel, enuToWorld, uniformState._enuToModel);
    uniformState._modelToEnu = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].inverseTransformation(uniformState._enuToModel, uniformState._modelToEnu);
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equalsEpsilon(ellipsoid._radii.x, ellipsoid._radii.y, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EPSILON15)) {
        // Ellipsoid curvature calculations assume radii.x === radii.y as is true for WGS84
        return;
    }
    uniformState._eyeEllipsoidCurvature = ellipsoid.getLocalCurvature(surfacePosition, uniformState._eyeEllipsoidCurvature);
}
const transformMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const sunCartographicScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function setSunAndMoonDirections(uniformState, frameState) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Transforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].computeIcrfToCentralBodyFixedMatrix(frameState.time, transformMatrix);
    let position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Simon1994PlanetaryPositions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].computeSunPositionInEarthInertialFrame(frameState.time, uniformState._sunPositionWC);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByVector(transformMatrix, position, position);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(position, uniformState._sunDirectionWC);
    position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByVector(uniformState.viewRotation3D, position, uniformState._sunDirectionEC);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(position, position);
    position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Simon1994PlanetaryPositions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].computeMoonPositionInEarthInertialFrame(frameState.time, uniformState._moonDirectionEC);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByVector(transformMatrix, position, position);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByVector(uniformState.viewRotation3D, position, position);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(position, position);
    const projection = frameState.mapProjection;
    const ellipsoid = projection.ellipsoid;
    const sunCartographic = ellipsoid.cartesianToCartographic(uniformState._sunPositionWC, sunCartographicScratch);
    projection.project(sunCartographic, uniformState._sunPositionColumbusView);
}
/**
 * Synchronizes the frustum's state with the camera state.  This is called
 * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms
 * are set to the right value.
 *
 * @param {object} camera The camera to synchronize with.
 */ UniformState.prototype.updateCamera = function(camera) {
    setView(this, camera.viewMatrix);
    setInverseView(this, camera.inverseViewMatrix);
    setCamera(this, camera);
    this._entireFrustum.x = camera.frustum.near;
    this._entireFrustum.y = camera.frustum.far;
    this.updateFrustum(camera.frustum);
    this._orthographicIn3D = this._mode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D && camera.frustum instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$OrthographicFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
};
/**
 * Synchronizes the frustum's state with the uniform state.  This is called
 * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms
 * are set to the right value.
 *
 * @param {object} frustum The frustum to synchronize with.
 */ UniformState.prototype.updateFrustum = function(frustum) {
    // If any frustum parameters have changed, calling the frustum.projectionMatrix
    // getter will recompute the projection before it is copied.
    setProjection(this, frustum.projectionMatrix);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(frustum.infiniteProjectionMatrix)) {
        setInfiniteProjection(this, frustum.infiniteProjectionMatrix);
    }
    this._currentFrustum.x = frustum.near;
    this._currentFrustum.y = frustum.far;
    this._farDepthFromNearPlusOne = frustum.far - frustum.near + 1.0;
    this._log2FarDepthFromNearPlusOne = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].log2(this._farDepthFromNearPlusOne);
    this._oneOverLog2FarDepthFromNearPlusOne = 1.0 / this._log2FarDepthFromNearPlusOne;
    const offCenterFrustum = frustum.offCenterFrustum;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(offCenterFrustum)) {
        frustum = offCenterFrustum;
    }
    this._frustumPlanes.x = frustum.top;
    this._frustumPlanes.y = frustum.bottom;
    this._frustumPlanes.z = frustum.left;
    this._frustumPlanes.w = frustum.right;
};
UniformState.prototype.updatePass = function(pass) {
    this._pass = pass;
};
const EMPTY_ARRAY = [];
const defaultLight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SunLight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
/**
 * Synchronizes frame state with the uniform state.  This is called
 * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms
 * are set to the right value.
 *
 * @param {FrameState} frameState The frameState to synchronize with.
 */ UniformState.prototype.update = function(frameState) {
    this._mode = frameState.mode;
    this._mapProjection = frameState.mapProjection;
    this._ellipsoid = frameState.mapProjection.ellipsoid;
    this._pixelRatio = frameState.pixelRatio;
    const camera = frameState.camera;
    this.updateCamera(camera);
    if (frameState.mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        this._frustum2DWidth = camera.frustum.right - camera.frustum.left;
        this._eyeHeight2D.x = this._frustum2DWidth * 0.5;
        this._eyeHeight2D.y = this._eyeHeight2D.x * this._eyeHeight2D.x;
    } else {
        this._frustum2DWidth = 0.0;
        this._eyeHeight2D.x = 0.0;
        this._eyeHeight2D.y = 0.0;
    }
    setSunAndMoonDirections(this, frameState);
    const light = frameState.light ?? defaultLight;
    if (light instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SunLight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
        this._lightDirectionWC = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(this._sunDirectionWC, this._lightDirectionWC);
        this._lightDirectionEC = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(this._sunDirectionEC, this._lightDirectionEC);
    } else {
        this._lightDirectionWC = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalize(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].negate(light.direction, this._lightDirectionWC), this._lightDirectionWC);
        this._lightDirectionEC = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByVector(this.viewRotation3D, this._lightDirectionWC, this._lightDirectionEC);
    }
    const lightColor = light.color;
    let lightColorHdr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromElements(lightColor.red, lightColor.green, lightColor.blue, this._lightColorHdr);
    lightColorHdr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByScalar(lightColorHdr, light.intensity, lightColorHdr);
    const maximumComponent = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].maximumComponent(lightColorHdr);
    if (maximumComponent > 1.0) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].divideByScalar(lightColorHdr, maximumComponent, this._lightColor);
    } else {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(lightColorHdr, this._lightColor);
    }
    const brdfLutGenerator = frameState.brdfLutGenerator;
    const brdfLut = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(brdfLutGenerator) ? brdfLutGenerator.colorTexture : undefined;
    this._brdfLut = brdfLut;
    this._environmentMap = frameState.environmentMap ?? frameState.context.defaultCubeMap;
    // IE 11 doesn't optimize out uniforms that are #ifdef'd out. So undefined values for the spherical harmonic
    // coefficients cause a crash.
    this._sphericalHarmonicCoefficients = frameState.sphericalHarmonicCoefficients ?? EMPTY_ARRAY;
    this._specularEnvironmentMaps = frameState.specularEnvironmentMaps;
    this._specularEnvironmentMapsMaximumLOD = frameState.specularEnvironmentMapsMaximumLOD;
    this._fogDensity = frameState.fog.density;
    this._fogVisualDensityScalar = frameState.fog.visualDensityScalar;
    this._fogMinimumBrightness = frameState.fog.minimumBrightness;
    const atmosphere = frameState.atmosphere;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(atmosphere)) {
        this._atmosphereHsbShift = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromElements(atmosphere.hueShift, atmosphere.saturationShift, atmosphere.brightnessShift, this._atmosphereHsbShift);
        this._atmosphereLightIntensity = atmosphere.lightIntensity;
        this._atmosphereRayleighCoefficient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(atmosphere.rayleighCoefficient, this._atmosphereRayleighCoefficient);
        this._atmosphereRayleighScaleHeight = atmosphere.rayleighScaleHeight;
        this._atmosphereMieCoefficient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(atmosphere.mieCoefficient, this._atmosphereMieCoefficient);
        this._atmosphereMieScaleHeight = atmosphere.mieScaleHeight;
        this._atmosphereMieAnisotropy = atmosphere.mieAnisotropy;
        this._atmosphereDynamicLighting = atmosphere.dynamicLighting;
    }
    this._invertClassificationColor = frameState.invertClassificationColor;
    this._frameState = frameState;
    this._temeToPseudoFixed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Transforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].computeTemeToPseudoFixedMatrix(frameState.time, this._temeToPseudoFixed);
    // Convert the relative splitPosition to absolute pixel coordinates
    this._splitPosition = frameState.splitPosition * frameState.context.drawingBufferWidth;
    const fov = camera.frustum.fov;
    const viewport = this._viewport;
    let pixelSizePerMeter;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(fov)) {
        if (viewport.height > viewport.width) {
            pixelSizePerMeter = Math.tan(0.5 * fov) * 2.0 / viewport.height;
        } else {
            pixelSizePerMeter = Math.tan(0.5 * fov) * 2.0 / viewport.width;
        }
    } else {
        pixelSizePerMeter = 1.0 / Math.max(viewport.width, viewport.height);
    }
    this._geometricToleranceOverMeter = pixelSizePerMeter * frameState.maximumScreenSpaceError;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(frameState.backgroundColor, this._backgroundColor);
    this._minimumDisableDepthTestDistance = frameState.minimumDisableDepthTestDistance;
    this._minimumDisableDepthTestDistance *= this._minimumDisableDepthTestDistance;
    if (this._minimumDisableDepthTestDistance === Number.POSITIVE_INFINITY) {
        this._minimumDisableDepthTestDistance = -1.0;
    }
};
function cleanViewport(uniformState) {
    if (uniformState._viewportDirty) {
        const v = uniformState._viewport;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].computeOrthographicOffCenter(v.x, v.x + v.width, v.y, v.y + v.height, 0.0, 1.0, uniformState._viewportOrthographicMatrix);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].computeViewportTransformation(v, 0.0, 1.0, uniformState._viewportTransformation);
        uniformState._viewportDirty = false;
    }
}
function cleanInverseProjection(uniformState) {
    if (uniformState._inverseProjectionDirty) {
        uniformState._inverseProjectionDirty = false;
        if (uniformState._mode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D && uniformState._mode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MORPHING && !uniformState._orthographicIn3D) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].inverse(uniformState._projection, uniformState._inverseProjection);
        } else {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ZERO, uniformState._inverseProjection);
        }
    }
}
// Derived
function cleanModelView(uniformState) {
    if (uniformState._modelViewDirty) {
        uniformState._modelViewDirty = false;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyTransformation(uniformState._view, uniformState._model, uniformState._modelView);
    }
}
function cleanModelView3D(uniformState) {
    if (uniformState._modelView3DDirty) {
        uniformState._modelView3DDirty = false;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyTransformation(uniformState.view3D, uniformState._model, uniformState._modelView3D);
    }
}
function cleanInverseModelView(uniformState) {
    if (uniformState._inverseModelViewDirty) {
        uniformState._inverseModelViewDirty = false;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].inverse(uniformState.modelView, uniformState._inverseModelView);
    }
}
function cleanInverseModelView3D(uniformState) {
    if (uniformState._inverseModelView3DDirty) {
        uniformState._inverseModelView3DDirty = false;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].inverse(uniformState.modelView3D, uniformState._inverseModelView3D);
    }
}
function cleanViewProjection(uniformState) {
    if (uniformState._viewProjectionDirty) {
        uniformState._viewProjectionDirty = false;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiply(uniformState._projection, uniformState._view, uniformState._viewProjection);
    }
}
function cleanInverseViewProjection(uniformState) {
    if (uniformState._inverseViewProjectionDirty) {
        uniformState._inverseViewProjectionDirty = false;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].inverse(uniformState.viewProjection, uniformState._inverseViewProjection);
    }
}
function cleanModelViewProjection(uniformState) {
    if (uniformState._modelViewProjectionDirty) {
        uniformState._modelViewProjectionDirty = false;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiply(uniformState._projection, uniformState.modelView, uniformState._modelViewProjection);
    }
}
function cleanModelViewRelativeToEye(uniformState) {
    if (uniformState._modelViewRelativeToEyeDirty) {
        uniformState._modelViewRelativeToEyeDirty = false;
        const mv = uniformState.modelView;
        const mvRte = uniformState._modelViewRelativeToEye;
        mvRte[0] = mv[0];
        mvRte[1] = mv[1];
        mvRte[2] = mv[2];
        mvRte[3] = mv[3];
        mvRte[4] = mv[4];
        mvRte[5] = mv[5];
        mvRte[6] = mv[6];
        mvRte[7] = mv[7];
        mvRte[8] = mv[8];
        mvRte[9] = mv[9];
        mvRte[10] = mv[10];
        mvRte[11] = mv[11];
        mvRte[12] = 0.0;
        mvRte[13] = 0.0;
        mvRte[14] = 0.0;
        mvRte[15] = mv[15];
    }
}
function cleanInverseModelViewProjection(uniformState) {
    if (uniformState._inverseModelViewProjectionDirty) {
        uniformState._inverseModelViewProjectionDirty = false;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].inverse(uniformState.modelViewProjection, uniformState._inverseModelViewProjection);
    }
}
function cleanModelViewProjectionRelativeToEye(uniformState) {
    if (uniformState._modelViewProjectionRelativeToEyeDirty) {
        uniformState._modelViewProjectionRelativeToEyeDirty = false;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiply(uniformState._projection, uniformState.modelViewRelativeToEye, uniformState._modelViewProjectionRelativeToEye);
    }
}
function cleanModelViewInfiniteProjection(uniformState) {
    if (uniformState._modelViewInfiniteProjectionDirty) {
        uniformState._modelViewInfiniteProjectionDirty = false;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiply(uniformState._infiniteProjection, uniformState.modelView, uniformState._modelViewInfiniteProjection);
    }
}
function cleanNormal(uniformState) {
    if (uniformState._normalDirty) {
        uniformState._normalDirty = false;
        const m = uniformState._normal;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getMatrix3(uniformState.inverseModelView, m);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transpose(m, m);
    }
}
function cleanNormal3D(uniformState) {
    if (uniformState._normal3DDirty) {
        uniformState._normal3DDirty = false;
        const m = uniformState._normal3D;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getMatrix3(uniformState.inverseModelView3D, m);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transpose(m, m);
    }
}
function cleanInverseNormal(uniformState) {
    if (uniformState._inverseNormalDirty) {
        uniformState._inverseNormalDirty = false;
        const m = uniformState._inverseNormal;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getMatrix3(uniformState.modelView, m);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transpose(m, m);
    }
}
function cleanInverseNormal3D(uniformState) {
    if (uniformState._inverseNormal3DDirty) {
        uniformState._inverseNormal3DDirty = false;
        const m = uniformState._inverseNormal3D;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getMatrix3(uniformState.modelView3D, m);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transpose(m, m);
    }
}
const cameraPositionMC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function cleanEncodedCameraPositionMC(uniformState) {
    if (uniformState._encodedCameraPositionMCDirty) {
        uniformState._encodedCameraPositionMCDirty = false;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPoint(uniformState.inverseModel, uniformState._cameraPosition, cameraPositionMC);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$EncodedCartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromCartesian(cameraPositionMC, uniformState._encodedCameraPositionMC);
    }
}
const view2Dto3DPScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const view2Dto3DRScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const view2Dto3DUScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const view2Dto3DDScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const view2Dto3DCartographicScratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const view2Dto3DCartesian3Scratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
const view2Dto3DMatrix4Scratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
function view2Dto3D(position2D, direction2D, right2D, up2D, frustum2DWidth, mode, projection, result) {
    // The camera position and directions are expressed in the 2D coordinate system where the Y axis is to the East,
    // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where
    // X is to the East, Y is to the North, and Z is out of the local horizontal plane.
    const p = view2Dto3DPScratch;
    p.x = position2D.y;
    p.y = position2D.z;
    p.z = position2D.x;
    const r = view2Dto3DRScratch;
    r.x = right2D.y;
    r.y = right2D.z;
    r.z = right2D.x;
    const u = view2Dto3DUScratch;
    u.x = up2D.y;
    u.y = up2D.z;
    u.z = up2D.x;
    const d = view2Dto3DDScratch;
    d.x = direction2D.y;
    d.y = direction2D.z;
    d.z = direction2D.x;
    // In 2D, the camera height is always 12.7 million meters.
    // The apparent height is equal to half the frustum width.
    if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE2D) {
        p.z = frustum2DWidth * 0.5;
    }
    // Compute the equivalent camera position in the real (3D) world.
    // In 2D and Columbus View, the camera can travel outside the projection, and when it does so
    // there's not really any corresponding location in the real world.  So clamp the unprojected
    // longitude and latitude to their valid ranges.
    const cartographic = projection.unproject(p, view2Dto3DCartographicScratch);
    cartographic.longitude = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clamp(cartographic.longitude, -Math.PI, Math.PI);
    cartographic.latitude = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clamp(cartographic.latitude, -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PI_OVER_TWO);
    const ellipsoid = projection.ellipsoid;
    const position3D = ellipsoid.cartographicToCartesian(cartographic, view2Dto3DCartesian3Scratch);
    // Compute the rotation from the local ENU at the real world camera position to the fixed axes.
    const enuToFixed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Transforms$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].eastNorthUpToFixedFrame(position3D, ellipsoid, view2Dto3DMatrix4Scratch);
    // Transform each camera direction to the fixed axes.
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPointAsVector(enuToFixed, r, r);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPointAsVector(enuToFixed, u, u);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiplyByPointAsVector(enuToFixed, d, d);
    // Compute the view matrix based on the new fixed-frame camera position and directions.
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result)) {
        result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    }
    result[0] = r.x;
    result[1] = u.x;
    result[2] = -d.x;
    result[3] = 0.0;
    result[4] = r.y;
    result[5] = u.y;
    result[6] = -d.y;
    result[7] = 0.0;
    result[8] = r.z;
    result[9] = u.z;
    result[10] = -d.z;
    result[11] = 0.0;
    result[12] = -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dot(r, position3D);
    result[13] = -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dot(u, position3D);
    result[14] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Cartesian3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dot(d, position3D);
    result[15] = 1.0;
    return result;
}
function updateView3D(that) {
    if (that._view3DDirty) {
        if (that._mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Scene$2f$SceneMode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCENE3D) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(that._view, that._view3D);
        } else {
            view2Dto3D(that._cameraPosition, that._cameraDirection, that._cameraRight, that._cameraUp, that._frustum2DWidth, that._mode, that._mapProjection, that._view3D);
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getMatrix3(that._view3D, that._viewRotation3D);
        that._view3DDirty = false;
    }
}
function updateInverseView3D(that) {
    if (that._inverseView3DDirty) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].inverseTransformation(that.view3D, that._inverseView3D);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getMatrix3(that._inverseView3D, that._inverseViewRotation3D);
        that._inverseView3DDirty = false;
    }
}
const __TURBOPACK__default__export__ = UniformState;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/Context.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/ComponentDatatype.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$createGuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/createGuid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/destroyObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$GeometryAttribute$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/GeometryAttribute.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$loadKTX2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/loadKTX2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Matrix4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/PixelFormat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PrimitiveType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/PrimitiveType.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/RuntimeError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/WebGLConstants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Shaders$2f$ViewportQuadVS$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Shaders/ViewportQuadVS.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$BufferUsage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/BufferUsage.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ClearCommand$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ClearCommand.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ContextLimits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$CubeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/CubeMap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$DrawCommand$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/DrawCommand.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PassState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/PassState.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/PixelDatatype.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$RenderState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/RenderState.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderCache$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ShaderCache.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderProgram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/ShaderProgram.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureCache$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/TextureCache.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$UniformState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/UniformState.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$VertexArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/VertexArray.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @private
 * @constructor
 *
 * @param {HTMLCanvasElement} canvas The canvas element to which the context will be associated
 * @param {ContextOptions} [options] Options to control WebGL settings for the context
 */ function Context(canvas, options) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("canvas", canvas);
    //>>includeEnd('debug');
    const { getWebGLStub, requestWebgl1, webgl: webglOptions = {}, allowTextureFilterAnisotropic = true } = options ?? {};
    // Override select WebGL defaults
    webglOptions.alpha = webglOptions.alpha ?? false; // WebGL default is true
    webglOptions.stencil = webglOptions.stencil ?? true; // WebGL default is false
    webglOptions.powerPreference = webglOptions.powerPreference ?? "high-performance"; // WebGL default is "default"
    const glContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(getWebGLStub) ? getWebGLStub(canvas, webglOptions) : getWebGLContext(canvas, webglOptions, requestWebgl1);
    // Get context type. instanceof will throw if WebGL2 is not supported
    const webgl2Supported = typeof WebGL2RenderingContext !== "undefined";
    const webgl2 = webgl2Supported && glContext instanceof WebGL2RenderingContext;
    this._canvas = canvas;
    this._originalGLContext = glContext;
    this._gl = glContext;
    this._webgl2 = webgl2;
    this._id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$createGuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
    // Validation and logging disabled by default for speed.
    this.validateFramebuffer = false;
    this.validateShaderProgram = false;
    this.logShaderCompilation = false;
    this._throwOnWebGLError = false;
    this._shaderCache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderCache$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this);
    this._textureCache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$TextureCache$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    const gl = glContext;
    this._stencilBits = gl.getParameter(gl.STENCIL_BITS);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumCombinedTextureImageUnits = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS); // min: 8
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE); // min: 16
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS); // min: 16
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS); // min: 8
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumRenderbufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE); // min: 1
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE); // min: 64
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumVaryingVectors = gl.getParameter(gl.MAX_VARYING_VECTORS); // min: 8
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS); // min: 8
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumVertexTextureImageUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS); // min: 0
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS); // min: 128
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumSamples = this._webgl2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
    const aliasedLineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE); // must include 1
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._minimumAliasedLineWidth = aliasedLineWidthRange[0];
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumAliasedLineWidth = aliasedLineWidthRange[1];
    const aliasedPointSizeRange = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE); // must include 1
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._minimumAliasedPointSize = aliasedPointSizeRange[0];
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumAliasedPointSize = aliasedPointSizeRange[1];
    const maximumViewportDimensions = gl.getParameter(gl.MAX_VIEWPORT_DIMS);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumViewportWidth = maximumViewportDimensions[0];
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumViewportHeight = maximumViewportDimensions[1];
    const highpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._highpFloatSupported = highpFloat.precision !== 0;
    const highpInt = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._highpIntSupported = highpInt.rangeMax !== 0;
    this._antialias = gl.getContextAttributes().antialias;
    // Query and initialize extensions
    this._standardDerivatives = !!getExtension(gl, [
        "OES_standard_derivatives"
    ]);
    this._blendMinmax = !!getExtension(gl, [
        "EXT_blend_minmax"
    ]);
    this._elementIndexUint = !!getExtension(gl, [
        "OES_element_index_uint"
    ]);
    this._depthTexture = !!getExtension(gl, [
        "WEBGL_depth_texture",
        "WEBKIT_WEBGL_depth_texture"
    ]);
    this._fragDepth = !!getExtension(gl, [
        "EXT_frag_depth"
    ]);
    this._debugShaders = getExtension(gl, [
        "WEBGL_debug_shaders"
    ]);
    this._textureFloat = !!getExtension(gl, [
        "OES_texture_float"
    ]);
    this._textureHalfFloat = !!getExtension(gl, [
        "OES_texture_half_float"
    ]);
    this._textureFloatLinear = !!getExtension(gl, [
        "OES_texture_float_linear"
    ]);
    this._textureHalfFloatLinear = !!getExtension(gl, [
        "OES_texture_half_float_linear"
    ]);
    this._supportsTextureLod = !!getExtension(gl, [
        "EXT_shader_texture_lod"
    ]);
    this._colorBufferFloat = !!getExtension(gl, [
        "EXT_color_buffer_float",
        "WEBGL_color_buffer_float"
    ]);
    this._floatBlend = !!getExtension(gl, [
        "EXT_float_blend"
    ]);
    this._colorBufferHalfFloat = !!getExtension(gl, [
        "EXT_color_buffer_half_float"
    ]);
    this._s3tc = !!getExtension(gl, [
        "WEBGL_compressed_texture_s3tc",
        "MOZ_WEBGL_compressed_texture_s3tc",
        "WEBKIT_WEBGL_compressed_texture_s3tc"
    ]);
    this._pvrtc = !!getExtension(gl, [
        "WEBGL_compressed_texture_pvrtc",
        "WEBKIT_WEBGL_compressed_texture_pvrtc"
    ]);
    this._astc = !!getExtension(gl, [
        "WEBGL_compressed_texture_astc"
    ]);
    this._etc = !!getExtension(gl, [
        "WEBG_compressed_texture_etc"
    ]);
    this._etc1 = !!getExtension(gl, [
        "WEBGL_compressed_texture_etc1"
    ]);
    this._bc7 = !!getExtension(gl, [
        "EXT_texture_compression_bptc"
    ]);
    // It is necessary to pass supported formats to loadKTX2
    // because imagery layers don't have access to the context.
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$loadKTX2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].setKTX2SupportedFormats(this._s3tc, this._pvrtc, this._astc, this._etc, this._etc1, this._bc7);
    const textureFilterAnisotropic = allowTextureFilterAnisotropic ? getExtension(gl, [
        "EXT_texture_filter_anisotropic",
        "WEBKIT_EXT_texture_filter_anisotropic"
    ]) : undefined;
    this._textureFilterAnisotropic = textureFilterAnisotropic;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumTextureFilterAnisotropy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(textureFilterAnisotropic) ? gl.getParameter(textureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1.0;
    let glCreateVertexArray;
    let glBindVertexArray;
    let glDeleteVertexArray;
    let glDrawElementsInstanced;
    let glDrawArraysInstanced;
    let glVertexAttribDivisor;
    let glDrawBuffers;
    let vertexArrayObject;
    let instancedArrays;
    let drawBuffers;
    if (webgl2) {
        const that = this;
        glCreateVertexArray = function() {
            return that._gl.createVertexArray();
        };
        glBindVertexArray = function(vao) {
            that._gl.bindVertexArray(vao);
        };
        glDeleteVertexArray = function(vao) {
            that._gl.deleteVertexArray(vao);
        };
        glDrawElementsInstanced = function(mode, count, type, offset, instanceCount) {
            gl.drawElementsInstanced(mode, count, type, offset, instanceCount);
        };
        glDrawArraysInstanced = function(mode, first, count, instanceCount) {
            gl.drawArraysInstanced(mode, first, count, instanceCount);
        };
        glVertexAttribDivisor = function(index, divisor) {
            gl.vertexAttribDivisor(index, divisor);
        };
        glDrawBuffers = function(buffers) {
            gl.drawBuffers(buffers);
        };
    } else {
        vertexArrayObject = getExtension(gl, [
            "OES_vertex_array_object"
        ]);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(vertexArrayObject)) {
            glCreateVertexArray = function() {
                return vertexArrayObject.createVertexArrayOES();
            };
            glBindVertexArray = function(vertexArray) {
                vertexArrayObject.bindVertexArrayOES(vertexArray);
            };
            glDeleteVertexArray = function(vertexArray) {
                vertexArrayObject.deleteVertexArrayOES(vertexArray);
            };
        }
        instancedArrays = getExtension(gl, [
            "ANGLE_instanced_arrays"
        ]);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(instancedArrays)) {
            glDrawElementsInstanced = function(mode, count, type, offset, instanceCount) {
                instancedArrays.drawElementsInstancedANGLE(mode, count, type, offset, instanceCount);
            };
            glDrawArraysInstanced = function(mode, first, count, instanceCount) {
                instancedArrays.drawArraysInstancedANGLE(mode, first, count, instanceCount);
            };
            glVertexAttribDivisor = function(index, divisor) {
                instancedArrays.vertexAttribDivisorANGLE(index, divisor);
            };
        }
        drawBuffers = getExtension(gl, [
            "WEBGL_draw_buffers"
        ]);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(drawBuffers)) {
            glDrawBuffers = function(buffers) {
                drawBuffers.drawBuffersWEBGL(buffers);
            };
        }
    }
    this.glCreateVertexArray = glCreateVertexArray;
    this.glBindVertexArray = glBindVertexArray;
    this.glDeleteVertexArray = glDeleteVertexArray;
    this.glDrawElementsInstanced = glDrawElementsInstanced;
    this.glDrawArraysInstanced = glDrawArraysInstanced;
    this.glVertexAttribDivisor = glVertexAttribDivisor;
    this.glDrawBuffers = glDrawBuffers;
    this._vertexArrayObject = !!vertexArrayObject;
    this._instancedArrays = !!instancedArrays;
    this._drawBuffers = !!drawBuffers;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumDrawBuffers = this.drawBuffers ? gl.getParameter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MAX_DRAW_BUFFERS) : 1;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumColorAttachments = this.drawBuffers ? gl.getParameter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MAX_COLOR_ATTACHMENTS) : 1;
    this._clearColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0.0, 0.0, 0.0, 0.0);
    this._clearDepth = 1.0;
    this._clearStencil = 0;
    const us = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$UniformState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    const ps = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PassState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this);
    const rs = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$RenderState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromCache();
    this._defaultPassState = ps;
    this._defaultRenderState = rs;
    // default texture has a value of (1, 1, 1)
    // default emissive texture has a value of (0, 0, 0)
    // default normal texture is +z which is encoded as (0.5, 0.5, 1)
    this._defaultTexture = undefined;
    this._defaultEmissiveTexture = undefined;
    this._defaultNormalTexture = undefined;
    this._defaultCubeMap = undefined;
    this._us = us;
    this._currentRenderState = rs;
    this._currentPassState = ps;
    this._currentFramebuffer = undefined;
    this._maxFrameTextureUnitIndex = 0;
    // Vertex attribute divisor state cache. Workaround for ANGLE (also look at VertexArray.setVertexAttribDivisor)
    this._vertexAttribDivisors = [];
    this._previousDrawInstanced = false;
    for(let i = 0; i < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ContextLimits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._maximumVertexAttributes; i++){
        this._vertexAttribDivisors.push(0);
    }
    this._pickObjects = new Map();
    this._nextPickColor = new Uint32Array(1);
    /**
   * The options used to construct this context
   *
   * @type {ContextOptions}
   */ this.options = {
        getWebGLStub: getWebGLStub,
        requestWebgl1: requestWebgl1,
        webgl: webglOptions,
        allowTextureFilterAnisotropic: allowTextureFilterAnisotropic
    };
    /**
   * A cache of objects tied to this context.  Just before the Context is destroyed,
   * <code>destroy</code> will be invoked on each object in this object literal that has
   * such a method.  This is useful for caching any objects that might otherwise
   * be stored globally, except they're tied to a particular context, and to manage
   * their lifetime.
   *
   * @type {object}
   */ this.cache = {};
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$RenderState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].apply(gl, rs, ps);
}
/**
 * @typedef {object} ContextOptions
 *
 * Options to control the setting up of a WebGL Context.
 * <p>
 * <code>allowTextureFilterAnisotropic</code> defaults to true, which enables
 * anisotropic texture filtering when the WebGL extension is supported.
 * Setting this to false will improve performance, but hurt visual quality,
 * especially for horizon views.
 * </p>
 *
 * @property {boolean} [requestWebgl1=false] If true and the browser supports it, use a WebGL 1 rendering context
 * @property {boolean} [allowTextureFilterAnisotropic=true] If true, use anisotropic filtering during texture sampling
 * @property {WebGLOptions} [webgl] WebGL options to be passed on to canvas.getContext
 * @property {Function} [getWebGLStub] A function to create a WebGL stub for testing
 */ /**
 * @private
 * @param {HTMLCanvasElement} canvas The canvas element to which the context will be associated
 * @param {WebGLOptions} webglOptions WebGL options to be passed on to HTMLCanvasElement.getContext()
 * @param {boolean} requestWebgl1 Whether to request a WebGLRenderingContext or a WebGL2RenderingContext.
 * @returns {WebGLRenderingContext|WebGL2RenderingContext}
 */ function getWebGLContext(canvas, webglOptions, requestWebgl1) {
    if (typeof WebGLRenderingContext === "undefined") {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("The browser does not support WebGL.  Visit http://get.webgl.org.");
    }
    // Ensure that WebGL 2 is supported when it is requested. Otherwise, fall back to WebGL 1.
    const webgl2Supported = typeof WebGL2RenderingContext !== "undefined";
    if (!requestWebgl1 && !webgl2Supported) {
        requestWebgl1 = true;
    }
    const contextType = requestWebgl1 ? "webgl" : "webgl2";
    const glContext = canvas.getContext(contextType, webglOptions);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(glContext)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("The browser supports WebGL, but initialization failed.");
    }
    return glContext;
}
/**
 * @typedef {object} WebGLOptions
 *
 * WebGL options to be passed on to HTMLCanvasElement.getContext().
 * See {@link https://registry.khronos.org/webgl/specs/latest/1.0/#5.2|WebGLContextAttributes}
 * but note the modified defaults for 'alpha', 'stencil', and 'powerPreference'
 *
 * <p>
 * <code>alpha</code> defaults to false, which can improve performance
 * compared to the standard WebGL default of true.  If an application needs
 * to composite Cesium above other HTML elements using alpha-blending, set
 * <code>alpha</code> to true.
 * </p>
 *
 * @property {boolean} [alpha=false]
 * @property {boolean} [depth=true]
 * @property {boolean} [stencil=false]
 * @property {boolean} [antialias=true]
 * @property {boolean} [premultipliedAlpha=true]
 * @property {boolean} [preserveDrawingBuffer=false]
 * @property {("default"|"low-power"|"high-performance")} [powerPreference="high-performance"]
 * @property {boolean} [failIfMajorPerformanceCaveat=false]
 */ function errorToString(gl, error) {
    let message = "WebGL Error:  ";
    switch(error){
        case gl.INVALID_ENUM:
            message += "INVALID_ENUM";
            break;
        case gl.INVALID_VALUE:
            message += "INVALID_VALUE";
            break;
        case gl.INVALID_OPERATION:
            message += "INVALID_OPERATION";
            break;
        case gl.OUT_OF_MEMORY:
            message += "OUT_OF_MEMORY";
            break;
        case gl.CONTEXT_LOST_WEBGL:
            message += "CONTEXT_LOST_WEBGL lost";
            break;
        default:
            message += `Unknown (${error})`;
    }
    return message;
}
function createErrorMessage(gl, glFunc, glFuncArguments, error) {
    let message = `${errorToString(gl, error)}: ${glFunc.name}(`;
    for(let i = 0; i < glFuncArguments.length; ++i){
        if (i !== 0) {
            message += ", ";
        }
        message += glFuncArguments[i];
    }
    message += ");";
    return message;
}
function throwOnError(gl, glFunc, glFuncArguments) {
    const error = gl.getError();
    if (error !== gl.NO_ERROR) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](createErrorMessage(gl, glFunc, glFuncArguments, error));
    }
}
function makeGetterSetter(gl, propertyName, logFunction) {
    return {
        get: function() {
            const value = gl[propertyName];
            logFunction(gl, `get: ${propertyName}`, value);
            return gl[propertyName];
        },
        set: function(value) {
            gl[propertyName] = value;
            logFunction(gl, `set: ${propertyName}`, value);
        }
    };
}
function wrapGL(gl, logFunction) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(logFunction)) {
        return gl;
    }
    function wrapFunction(property) {
        return function() {
            const result = property.apply(gl, arguments);
            logFunction(gl, property, arguments);
            return result;
        };
    }
    const glWrapper = {};
    // JavaScript linters normally demand that a for..in loop must directly contain an if,
    // but in our loop below, we actually intend to iterate all properties, including
    // those in the prototype.
    /*eslint-disable guard-for-in*/ for(const propertyName in gl){
        const property = gl[propertyName];
        // wrap any functions we encounter, otherwise just copy the property to the wrapper.
        if (property instanceof Function) {
            glWrapper[propertyName] = wrapFunction(property);
        } else {
            Object.defineProperty(glWrapper, propertyName, makeGetterSetter(gl, propertyName, logFunction));
        }
    }
    /*eslint-enable guard-for-in*/ return glWrapper;
}
function getExtension(gl, names) {
    const length = names.length;
    for(let i = 0; i < length; ++i){
        const extension = gl.getExtension(names[i]);
        if (extension) {
            return extension;
        }
    }
    return undefined;
}
const defaultFramebufferMarker = {};
Object.defineProperties(Context.prototype, {
    id: {
        get: function() {
            return this._id;
        }
    },
    webgl2: {
        get: function() {
            return this._webgl2;
        }
    },
    canvas: {
        get: function() {
            return this._canvas;
        }
    },
    shaderCache: {
        get: function() {
            return this._shaderCache;
        }
    },
    textureCache: {
        get: function() {
            return this._textureCache;
        }
    },
    uniformState: {
        get: function() {
            return this._us;
        }
    },
    /**
   * The number of stencil bits per pixel in the default bound framebuffer.  The minimum is eight bits.
   * @memberof Context.prototype
   * @type {number}
   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>STENCIL_BITS</code>.
   */ stencilBits: {
        get: function() {
            return this._stencilBits;
        }
    },
    /**
   * <code>true</code> if the WebGL context supports stencil buffers.
   * Stencil buffers are not supported by all systems.
   * @memberof Context.prototype
   * @type {boolean}
   */ stencilBuffer: {
        get: function() {
            return this._stencilBits >= 8;
        }
    },
    /**
   * <code>true</code> if the WebGL context supports antialiasing.  By default
   * antialiasing is requested, but it is not supported by all systems.
   * @memberof Context.prototype
   * @type {boolean}
   */ antialias: {
        get: function() {
            return this._antialias;
        }
    },
    /**
   * <code>true</code> if the WebGL context supports multisample antialiasing. Requires
   * WebGL2.
   * @memberof Context.prototype
   * @type {boolean}
   */ msaa: {
        get: function() {
            return this._webgl2;
        }
    },
    /**
   * <code>true</code> if the OES_standard_derivatives extension is supported.  This
   * extension provides access to <code>dFdx</code>, <code>dFdy</code>, and <code>fwidth</code>
   * functions from GLSL.  A shader using these functions still needs to explicitly enable the
   * extension with <code>#extension GL_OES_standard_derivatives : enable</code>.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link http://www.khronos.org/registry/gles/extensions/OES/OES_standard_derivatives.txt|OES_standard_derivatives}
   */ standardDerivatives: {
        get: function() {
            return this._standardDerivatives || this._webgl2;
        }
    },
    /**
   * <code>true</code> if the EXT_float_blend extension is supported. This
   * extension enables blending with 32-bit float values.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/EXT_float_blend/}
   */ floatBlend: {
        get: function() {
            return this._floatBlend;
        }
    },
    /**
   * <code>true</code> if the EXT_blend_minmax extension is supported.  This
   * extension extends blending capabilities by adding two new blend equations:
   * the minimum or maximum color components of the source and destination colors.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/EXT_blend_minmax/}
   */ blendMinmax: {
        get: function() {
            return this._blendMinmax || this._webgl2;
        }
    },
    /**
   * <code>true</code> if the OES_element_index_uint extension is supported.  This
   * extension allows the use of unsigned int indices, which can improve performance by
   * eliminating batch breaking caused by unsigned short indices.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link http://www.khronos.org/registry/webgl/extensions/OES_element_index_uint/|OES_element_index_uint}
   */ elementIndexUint: {
        get: function() {
            return this._elementIndexUint || this._webgl2;
        }
    },
    /**
   * <code>true</code> if WEBGL_depth_texture is supported.  This extension provides
   * access to depth textures that, for example, can be attached to framebuffers for shadow mapping.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}
   */ depthTexture: {
        get: function() {
            return this._depthTexture || this._webgl2;
        }
    },
    /**
   * <code>true</code> if OES_texture_float is supported. This extension provides
   * access to floating point textures that, for example, can be attached to framebuffers for high dynamic range.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/OES_texture_float/}
   */ floatingPointTexture: {
        get: function() {
            return this._webgl2 || this._textureFloat;
        }
    },
    /**
   * <code>true</code> if OES_texture_half_float is supported. This extension provides
   * access to floating point textures that, for example, can be attached to framebuffers for high dynamic range.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/OES_texture_half_float/}
   */ halfFloatingPointTexture: {
        get: function() {
            return this._webgl2 || this._textureHalfFloat;
        }
    },
    /**
   * <code>true</code> if OES_texture_float_linear is supported. This extension provides
   * access to linear sampling methods for minification and magnification filters of floating-point textures.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/OES_texture_float_linear/}
   */ textureFloatLinear: {
        get: function() {
            return this._textureFloatLinear;
        }
    },
    /**
   * <code>true</code> if OES_texture_half_float_linear is supported. This extension provides
   * access to linear sampling methods for minification and magnification filters of half floating-point textures.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/OES_texture_half_float_linear/}
   */ textureHalfFloatLinear: {
        get: function() {
            return this._webgl2 && this._textureFloatLinear || !this._webgl2 && this._textureHalfFloatLinear;
        }
    },
    /**
   * <code>true</code> if EXT_shader_texture_lod is supported. This extension provides
   * access to explicit LOD selection in texture sampling functions.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://registry.khronos.org/webgl/extensions/EXT_shader_texture_lod/}
   */ supportsTextureLod: {
        get: function() {
            return this._webgl2 || this._supportsTextureLod;
        }
    },
    /**
   * <code>true</code> if EXT_texture_filter_anisotropic is supported. This extension provides
   * access to anisotropic filtering for textured surfaces at an oblique angle from the viewer.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/EXT_texture_filter_anisotropic/}
   */ textureFilterAnisotropic: {
        get: function() {
            return !!this._textureFilterAnisotropic;
        }
    },
    /**
   * <code>true</code> if WEBGL_compressed_texture_s3tc is supported.  This extension provides
   * access to DXT compressed textures.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/}
   */ s3tc: {
        get: function() {
            return this._s3tc;
        }
    },
    /**
   * <code>true</code> if WEBGL_compressed_texture_pvrtc is supported.  This extension provides
   * access to PVR compressed textures.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/}
   */ pvrtc: {
        get: function() {
            return this._pvrtc;
        }
    },
    /**
   * <code>true</code> if WEBGL_compressed_texture_astc is supported.  This extension provides
   * access to ASTC compressed textures.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/}
   */ astc: {
        get: function() {
            return this._astc;
        }
    },
    /**
   * <code>true</code> if WEBGL_compressed_texture_etc is supported.  This extension provides
   * access to ETC compressed textures.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/}
   */ etc: {
        get: function() {
            return this._etc;
        }
    },
    /**
   * <code>true</code> if WEBGL_compressed_texture_etc1 is supported.  This extension provides
   * access to ETC1 compressed textures.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1/}
   */ etc1: {
        get: function() {
            return this._etc1;
        }
    },
    /**
   * <code>true</code> if EXT_texture_compression_bptc is supported.  This extension provides
   * access to BC7 compressed textures.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/EXT_texture_compression_bptc/}
   */ bc7: {
        get: function() {
            return this._bc7;
        }
    },
    /**
   * <code>true</code> if S3TC, PVRTC, ASTC, ETC, ETC1, or BC7 compression is supported.
   * @memberof Context.prototype
   * @type {boolean}
   */ supportsBasis: {
        get: function() {
            return this._s3tc || this._pvrtc || this._astc || this._etc || this._etc1 || this._bc7;
        }
    },
    /**
   * <code>true</code> if the OES_vertex_array_object extension is supported.  This
   * extension can improve performance by reducing the overhead of switching vertex arrays.
   * When enabled, this extension is automatically used by {@link VertexArray}.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link http://www.khronos.org/registry/webgl/extensions/OES_vertex_array_object/|OES_vertex_array_object}
   */ vertexArrayObject: {
        get: function() {
            return this._vertexArrayObject || this._webgl2;
        }
    },
    /**
   * <code>true</code> if the EXT_frag_depth extension is supported.  This
   * extension provides access to the <code>gl_FragDepthEXT</code> built-in output variable
   * from GLSL fragment shaders.  A shader using these functions still needs to explicitly enable the
   * extension with <code>#extension GL_EXT_frag_depth : enable</code>.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link http://www.khronos.org/registry/webgl/extensions/EXT_frag_depth/|EXT_frag_depth}
   */ fragmentDepth: {
        get: function() {
            return this._fragDepth || this._webgl2;
        }
    },
    /**
   * <code>true</code> if the ANGLE_instanced_arrays extension is supported.  This
   * extension provides access to instanced rendering.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/ANGLE_instanced_arrays}
   */ instancedArrays: {
        get: function() {
            return this._instancedArrays || this._webgl2;
        }
    },
    /**
   * <code>true</code> if the EXT_color_buffer_float extension is supported.  This
   * extension makes the gl.RGBA32F format color renderable.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/WEBGL_color_buffer_float/}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/EXT_color_buffer_float/}
   */ colorBufferFloat: {
        get: function() {
            return this._colorBufferFloat;
        }
    },
    /**
   * <code>true</code> if the EXT_color_buffer_half_float extension is supported.  This
   * extension makes the format gl.RGBA16F format color renderable.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/EXT_color_buffer_half_float/}
   * @see {@link https://www.khronos.org/registry/webgl/extensions/EXT_color_buffer_float/}
   */ colorBufferHalfFloat: {
        get: function() {
            return this._webgl2 && this._colorBufferFloat || !this._webgl2 && this._colorBufferHalfFloat;
        }
    },
    /**
   * <code>true</code> if the WEBGL_draw_buffers extension is supported. This
   * extensions provides support for multiple render targets. The framebuffer object can have mutiple
   * color attachments and the GLSL fragment shader can write to the built-in output array <code>gl_FragData</code>.
   * A shader using this feature needs to explicitly enable the extension with
   * <code>#extension GL_EXT_draw_buffers : enable</code>.
   * @memberof Context.prototype
   * @type {boolean}
   * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_draw_buffers/|WEBGL_draw_buffers}
   */ drawBuffers: {
        get: function() {
            return this._drawBuffers || this._webgl2;
        }
    },
    debugShaders: {
        get: function() {
            return this._debugShaders;
        }
    },
    throwOnWebGLError: {
        get: function() {
            return this._throwOnWebGLError;
        },
        set: function(value) {
            this._throwOnWebGLError = value;
            this._gl = wrapGL(this._originalGLContext, value ? throwOnError : undefined);
        }
    },
    /**
   * A 1x1 RGBA texture initialized to [255, 255, 255, 255].  This can
   * be used as a placeholder texture while other textures are downloaded.
   * @memberof Context.prototype
   * @type {Texture}
   */ defaultTexture: {
        get: function() {
            if (this._defaultTexture === undefined) {
                this._defaultTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    context: this,
                    source: {
                        width: 1,
                        height: 1,
                        arrayBufferView: new Uint8Array([
                            255,
                            255,
                            255,
                            255
                        ])
                    },
                    flipY: false
                });
            }
            return this._defaultTexture;
        }
    },
    /**
   * A 1x1 RGB texture initialized to [0, 0, 0] representing a material that is
   * not emissive. This can be used as a placeholder texture for emissive
   * textures while other textures are downloaded.
   * @memberof Context.prototype
   * @type {Texture}
   */ defaultEmissiveTexture: {
        get: function() {
            if (this._defaultEmissiveTexture === undefined) {
                this._defaultEmissiveTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    context: this,
                    pixelFormat: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGB,
                    source: {
                        width: 1,
                        height: 1,
                        arrayBufferView: new Uint8Array([
                            0,
                            0,
                            0
                        ])
                    },
                    flipY: false
                });
            }
            return this._defaultEmissiveTexture;
        }
    },
    /**
   * A 1x1 RGBA texture initialized to [128, 128, 255] to encode a tangent
   * space normal pointing in the +z direction, i.e. (0, 0, 1). This can
   * be used as a placeholder normal texture while other textures are
   * downloaded.
   * @memberof Context.prototype
   * @type {Texture}
   */ defaultNormalTexture: {
        get: function() {
            if (this._defaultNormalTexture === undefined) {
                this._defaultNormalTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    context: this,
                    pixelFormat: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGB,
                    source: {
                        width: 1,
                        height: 1,
                        arrayBufferView: new Uint8Array([
                            128,
                            128,
                            255
                        ])
                    },
                    flipY: false
                });
            }
            return this._defaultNormalTexture;
        }
    },
    /**
   * A cube map, where each face is a 1x1 RGBA texture initialized to
   * [255, 255, 255, 255].  This can be used as a placeholder cube map while
   * other cube maps are downloaded.
   * @memberof Context.prototype
   * @type {CubeMap}
   */ defaultCubeMap: {
        get: function() {
            if (this._defaultCubeMap === undefined) {
                const face = {
                    width: 1,
                    height: 1,
                    arrayBufferView: new Uint8Array([
                        255,
                        255,
                        255,
                        255
                    ])
                };
                this._defaultCubeMap = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$CubeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    context: this,
                    source: {
                        positiveX: face,
                        negativeX: face,
                        positiveY: face,
                        negativeY: face,
                        positiveZ: face,
                        negativeZ: face
                    },
                    flipY: false
                });
            }
            return this._defaultCubeMap;
        }
    },
    /**
   * The drawingBufferHeight of the underlying GL context.
   * @memberof Context.prototype
   * @type {number}
   * @see {@link https://www.khronos.org/registry/webgl/specs/1.0/#DOM-WebGLRenderingContext-drawingBufferHeight|drawingBufferHeight}
   */ drawingBufferHeight: {
        get: function() {
            return this._gl.drawingBufferHeight;
        }
    },
    /**
   * The drawingBufferWidth of the underlying GL context.
   * @memberof Context.prototype
   * @type {number}
   * @see {@link https://www.khronos.org/registry/webgl/specs/1.0/#DOM-WebGLRenderingContext-drawingBufferWidth|drawingBufferWidth}
   */ drawingBufferWidth: {
        get: function() {
            return this._gl.drawingBufferWidth;
        }
    },
    /**
   * Gets an object representing the currently bound framebuffer.  While this instance is not an actual
   * {@link Framebuffer}, it is used to represent the default framebuffer in calls to
   * {@link Texture.fromFramebuffer}.
   * @memberof Context.prototype
   * @type {object}
   */ defaultFramebuffer: {
        get: function() {
            return defaultFramebufferMarker;
        }
    }
});
/**
 * Validates a framebuffer.
 * Available in debug builds only.
 * @private
 */ function validateFramebuffer(context) {
    //>>includeStart('debug', pragmas.debug);
    if (context.validateFramebuffer) {
        const gl = context._gl;
        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (status !== gl.FRAMEBUFFER_COMPLETE) {
            let message;
            switch(status){
                case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    message = "Framebuffer is not complete.  Incomplete attachment: at least one attachment point with a renderbuffer or texture attached has its attached object no longer in existence or has an attached image with a width or height of zero, or the color attachment point has a non-color-renderable image attached, or the depth attachment point has a non-depth-renderable image attached, or the stencil attachment point has a non-stencil-renderable image attached.  Color-renderable formats include GL_RGBA4, GL_RGB5_A1, and GL_RGB565. GL_DEPTH_COMPONENT16 is the only depth-renderable format. GL_STENCIL_INDEX8 is the only stencil-renderable format.";
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    message = "Framebuffer is not complete.  Incomplete dimensions: not all attached images have the same width and height.";
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    message = "Framebuffer is not complete.  Missing attachment: no images are attached to the framebuffer.";
                    break;
                case gl.FRAMEBUFFER_UNSUPPORTED:
                    message = "Framebuffer is not complete.  Unsupported: the combination of internal formats of the attached images violates an implementation-dependent set of restrictions.";
                    break;
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](message);
        }
    }
//>>includeEnd('debug');
}
function applyRenderState(context, renderState, passState, clear) {
    const previousRenderState = context._currentRenderState;
    const previousPassState = context._currentPassState;
    context._currentRenderState = renderState;
    context._currentPassState = passState;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$RenderState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].partialApply(context._gl, previousRenderState, renderState, previousPassState, passState, clear);
}
let scratchBackBufferArray;
// this check must use typeof, not defined, because defined doesn't work with undeclared variables.
if (typeof WebGLRenderingContext !== "undefined") {
    scratchBackBufferArray = [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].BACK
    ];
}
function bindFramebuffer(context, framebuffer) {
    if (framebuffer !== context._currentFramebuffer) {
        context._currentFramebuffer = framebuffer;
        let buffers = scratchBackBufferArray;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(framebuffer)) {
            framebuffer._bind();
            validateFramebuffer(context);
            // TODO: Need a way for a command to give what draw buffers are active.
            buffers = framebuffer._getActiveColorAttachments();
        } else {
            const gl = context._gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        if (context.drawBuffers) {
            context.glDrawBuffers(buffers);
        }
    }
}
const defaultClearCommand = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ClearCommand$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
Context.prototype.clear = function(clearCommand, passState) {
    clearCommand = clearCommand ?? defaultClearCommand;
    passState = passState ?? this._defaultPassState;
    const gl = this._gl;
    let bitmask = 0;
    const c = clearCommand.color;
    const d = clearCommand.depth;
    const s = clearCommand.stencil;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(c)) {
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].equals(this._clearColor, c)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].clone(c, this._clearColor);
            gl.clearColor(c.red, c.green, c.blue, c.alpha);
        }
        bitmask |= gl.COLOR_BUFFER_BIT;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(d)) {
        if (d !== this._clearDepth) {
            this._clearDepth = d;
            gl.clearDepth(d);
        }
        bitmask |= gl.DEPTH_BUFFER_BIT;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(s)) {
        if (s !== this._clearStencil) {
            this._clearStencil = s;
            gl.clearStencil(s);
        }
        bitmask |= gl.STENCIL_BUFFER_BIT;
    }
    const rs = clearCommand.renderState ?? this._defaultRenderState;
    applyRenderState(this, rs, passState, true);
    // The command's framebuffer takes presidence over the pass' framebuffer, e.g., for off-screen rendering.
    const framebuffer = clearCommand.framebuffer ?? passState.framebuffer;
    bindFramebuffer(this, framebuffer);
    gl.clear(bitmask);
};
function beginDraw(context, framebuffer, passState, shaderProgram, renderState) {
    //>>includeStart('debug', pragmas.debug);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(framebuffer) && renderState.depthTest) {
        if (renderState.depthTest.enabled && !framebuffer.hasDepthAttachment) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("The depth test can not be enabled (drawCommand.renderState.depthTest.enabled) because the framebuffer (drawCommand.framebuffer) does not have a depth or depth-stencil renderbuffer.");
        }
    }
    //>>includeEnd('debug');
    bindFramebuffer(context, framebuffer);
    applyRenderState(context, renderState, passState, false);
    shaderProgram._bind();
    context._maxFrameTextureUnitIndex = Math.max(context._maxFrameTextureUnitIndex, shaderProgram.maximumTextureUnitIndex);
}
function continueDraw(context, drawCommand, shaderProgram, uniformMap) {
    const primitiveType = drawCommand._primitiveType;
    const va = drawCommand._vertexArray;
    let offset = drawCommand._offset;
    let count = drawCommand._count;
    const instanceCount = drawCommand.instanceCount;
    //>>includeStart('debug', pragmas.debug);
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PrimitiveType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].validate(primitiveType)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("drawCommand.primitiveType is required and must be valid.");
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("drawCommand.vertexArray", va);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("drawCommand.offset", offset, 0);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(count)) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("drawCommand.count", count, 0);
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThanOrEquals("drawCommand.instanceCount", instanceCount, 0);
    if (instanceCount > 0 && !context.instancedArrays) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Instanced arrays extension is not supported");
    }
    //>>includeEnd('debug');
    context._us.model = drawCommand._modelMatrix ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IDENTITY;
    shaderProgram._setUniforms(uniformMap, context._us, context.validateShaderProgram);
    va._bind();
    const indexBuffer = va.indexBuffer;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(indexBuffer)) {
        offset = offset * indexBuffer.bytesPerIndex; // offset in vertices to offset in bytes
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(count)) {
            count = Math.min(count, indexBuffer.numberOfIndices);
        } else {
            count = indexBuffer.numberOfIndices;
        }
        if (instanceCount === 0) {
            context._gl.drawElements(primitiveType, count, indexBuffer.indexDatatype, offset);
        } else {
            context.glDrawElementsInstanced(primitiveType, count, indexBuffer.indexDatatype, offset, instanceCount);
        }
    } else {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(count)) {
            count = Math.min(count, va.numberOfVertices);
        } else {
            count = va.numberOfVertices;
        }
        if (instanceCount === 0) {
            context._gl.drawArrays(primitiveType, offset, count);
        } else {
            context.glDrawArraysInstanced(primitiveType, offset, count, instanceCount);
        }
    }
    va._unBind();
}
Context.prototype.draw = function(drawCommand, passState, shaderProgram, uniformMap) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("drawCommand", drawCommand);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("drawCommand.shaderProgram", drawCommand._shaderProgram);
    //>>includeEnd('debug');
    passState = passState ?? this._defaultPassState;
    // The command's framebuffer takes precedence over the pass' framebuffer, e.g., for off-screen rendering.
    const framebuffer = drawCommand._framebuffer ?? passState.framebuffer;
    const renderState = drawCommand._renderState ?? this._defaultRenderState;
    shaderProgram = shaderProgram ?? drawCommand._shaderProgram;
    uniformMap = uniformMap ?? drawCommand._uniformMap;
    beginDraw(this, framebuffer, passState, shaderProgram, renderState);
    continueDraw(this, drawCommand, shaderProgram, uniformMap);
};
Context.prototype.beginFrame = function() {
// A no-op. Overridden when drawing to a SharedContext.
};
Context.prototype.endFrame = function() {
    const gl = this._gl;
    gl.useProgram(null);
    this._currentFramebuffer = undefined;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    const buffers = scratchBackBufferArray;
    if (this.drawBuffers) {
        this.glDrawBuffers(buffers);
    }
    const length = this._maxFrameTextureUnitIndex;
    this._maxFrameTextureUnitIndex = 0;
    for(let i = 0; i < length; ++i){
        gl.activeTexture(gl.TEXTURE0 + i);
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
    }
};
/**
 * @typedef {object} ReadState
 *
 * Options defining a rectangle to read pixels from.
 *
 * @private
 * @property {number} [x=0] The x offset of the rectangle to read from.
 * @property {number} [y=0] The y offset of the rectangle to read from.
 * @property {number} [width=this.drawingBufferWidth] The width of the rectangle to read from.
 * @property {number} [height=this.drawingBufferHeight] The height of the rectangle to read from.
 * @property {FrameBuffer|undefined} [framebuffer] The framebuffer to read from. If undefined, the read will be from the default framebuffer.
 */ /**
 * Read pixels from a framebuffer into a Pixel Buffer Object (PBO).
 *
 * @private
 * @param {ReadState} readState Options defining a rectangle to read pixels from.
 * @returns {Buffer} A PixelBuffer containing the pixels read from the specified rectangle.
 *
 * @exception {DeveloperError} A WebGL 2 context is required to read pixels using a PBO.
 */ Context.prototype.readPixelsToPBO = function(readState) {
    const gl = this._gl;
    readState = readState ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const x = Math.max(readState.x ?? 0, 0);
    const y = Math.max(readState.y ?? 0, 0);
    const width = readState.width ?? this.drawingBufferWidth;
    const height = readState.height ?? this.drawingBufferHeight;
    const framebuffer = readState.framebuffer;
    if (!this._webgl2) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("A WebGL 2 context is required to read pixels using a PBO.");
    }
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThan("readState.width", width, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThan("readState.height", height, 0);
    //>>includeEnd('debug');
    let pixelDatatype = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_BYTE;
    let pixelFormat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGBA;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(framebuffer) && framebuffer.numberOfColorAttachments > 0) {
        pixelDatatype = framebuffer.getColorTexture(0).pixelDatatype;
        pixelFormat = framebuffer.getColorTexture(0).pixelFormat;
    }
    const pixels = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createPixelBuffer({
        context: this,
        sizeInBytes: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].textureSizeInBytes(pixelFormat, pixelDatatype, width, height),
        usage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$BufferUsage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DYNAMIC_READ
    });
    bindFramebuffer(this, framebuffer);
    pixels._bind();
    gl.readPixels(x, y, width, height, pixelFormat, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toWebGLConstant(pixelDatatype, this), 0);
    pixels._unBind();
    return pixels;
};
/**
 * Read pixels from a framebuffer into a typed array.
 *
 * @private
 * @param {ReadState} readState Options defining a rectangle to read pixels from.
 * @returns {Uint8Array|Uint16Array|Float32Array|Uint32Array} The pixels in the specified rectangle.
 */ Context.prototype.readPixels = function(readState) {
    const gl = this._gl;
    readState = readState ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const x = Math.max(readState.x ?? 0, 0);
    const y = Math.max(readState.y ?? 0, 0);
    const width = readState.width ?? this.drawingBufferWidth;
    const height = readState.height ?? this.drawingBufferHeight;
    const framebuffer = readState.framebuffer;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThan("readState.width", width, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].typeOf.number.greaterThan("readState.height", height, 0);
    //>>includeEnd('debug');
    let pixelDatatype = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_BYTE;
    let pixelFormat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGBA;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(framebuffer) && framebuffer.numberOfColorAttachments > 0) {
        pixelDatatype = framebuffer.getColorTexture(0).pixelDatatype;
        pixelFormat = framebuffer.getColorTexture(0).pixelFormat;
    }
    const pixels = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createTypedArray(pixelFormat, pixelDatatype, width, height);
    bindFramebuffer(this, framebuffer);
    gl.readPixels(x, y, width, height, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PixelFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RGBA, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$PixelDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toWebGLConstant(pixelDatatype, this), pixels);
    return pixels;
};
const viewportQuadAttributeLocations = {
    position: 0,
    textureCoordinates: 1
};
Context.prototype.getViewportQuadVertexArray = function() {
    // Per-context cache for viewport quads
    let vertexArray = this.cache.viewportQuad_vertexArray;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(vertexArray)) {
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            attributes: {
                position: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$GeometryAttribute$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    componentDatatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
                    componentsPerAttribute: 2,
                    values: [
                        -1.0,
                        -1.0,
                        1.0,
                        -1.0,
                        1.0,
                        1.0,
                        -1.0,
                        1.0
                    ]
                }),
                textureCoordinates: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$GeometryAttribute$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    componentDatatype: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$ComponentDatatype$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
                    componentsPerAttribute: 2,
                    values: [
                        0.0,
                        0.0,
                        1.0,
                        0.0,
                        1.0,
                        1.0,
                        0.0,
                        1.0
                    ]
                })
            },
            // Workaround Internet Explorer 11.0.8 lack of TRIANGLE_FAN
            indices: new Uint16Array([
                0,
                1,
                2,
                0,
                2,
                3
            ]),
            primitiveType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PrimitiveType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TRIANGLES
        });
        vertexArray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$VertexArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromGeometry({
            context: this,
            geometry: geometry,
            attributeLocations: viewportQuadAttributeLocations,
            bufferUsage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$BufferUsage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].STATIC_DRAW,
            interleave: true
        });
        this.cache.viewportQuad_vertexArray = vertexArray;
    }
    return vertexArray;
};
Context.prototype.createViewportQuadCommand = function(fragmentShaderSource, overrides) {
    overrides = overrides ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$DrawCommand$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        vertexArray: this.getViewportQuadVertexArray(),
        primitiveType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$PrimitiveType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TRIANGLES,
        renderState: overrides.renderState,
        shaderProgram: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$ShaderProgram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromCache({
            context: this,
            vertexShaderSource: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Shaders$2f$ViewportQuadVS$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
            fragmentShaderSource: fragmentShaderSource,
            attributeLocations: viewportQuadAttributeLocations
        }),
        uniformMap: overrides.uniformMap,
        owner: overrides.owner,
        framebuffer: overrides.framebuffer,
        pass: overrides.pass
    });
};
/**
 * Gets the object associated with a pick color.
 *
 * @param {number} pickColor The unsigned 32-bit RGBA pick color
 * @returns {object} The object associated with the pick color, or undefined if no object is associated with that color.
 *
 * @example
 * const object = context.getObjectByPickColor(pickColor);
 *
 * @see Context#createPickId
 */ Context.prototype.getObjectByPickColor = function(pickColor) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("pickColor", pickColor);
    //>>includeEnd('debug');
    return this._pickObjects.get(pickColor);
};
/**
 *
 * @param {Map<number, object>} pickObjects
 * @param {number} key
 * @param {Color} color
 */ function PickId(pickObjects, key, color) {
    this._pickObjects = pickObjects;
    this.key = key;
    this.color = color;
}
Object.defineProperties(PickId.prototype, {
    object: {
        get: function() {
            return this._pickObjects.get(this.key);
        },
        set: function(value) {
            this._pickObjects.set(this.key, value);
        }
    }
});
PickId.prototype.destroy = function() {
    this._pickObjects.delete(this.key);
    return undefined;
};
/**
 * Creates a unique ID associated with the input object for use with color-buffer picking.
 * The ID has an RGBA color value unique to this context.  You must call destroy()
 * on the pick ID when destroying the input object.
 *
 * @param {object} object The object to associate with the pick ID.
 * @returns {object} A PickId object with a <code>color</code> property.
 *
 * @exception {RuntimeError} Out of unique Pick IDs.
 *
 *
 * @example
 * this._pickId = context.createPickId({
 *   primitive : this,
 *   id : this.id
 * });
 *
 * @see Context#getObjectByPickColor
 */ Context.prototype.createPickId = function(object) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("object", object);
    //>>includeEnd('debug');
    // the increment and assignment have to be separate statements to
    // actually detect overflow in the Uint32 value
    ++this._nextPickColor[0];
    const key = this._nextPickColor[0];
    if (key === 0) {
        // In case of overflow
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Out of unique Pick IDs.");
    }
    this._pickObjects.set(key, object);
    return new PickId(this._pickObjects, key, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromRgba(key));
};
Context.prototype.isDestroyed = function() {
    return false;
};
Context.prototype.destroy = function() {
    // Destroy all objects in the cache that have a destroy method.
    const cache = this.cache;
    for(const property in cache){
        if (cache.hasOwnProperty(property)) {
            const propertyValue = cache[property];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(propertyValue.destroy)) {
                propertyValue.destroy();
            }
        }
    }
    this._shaderCache = this._shaderCache.destroy();
    this._textureCache = this._textureCache.destroy();
    this._defaultTexture = this._defaultTexture && this._defaultTexture.destroy();
    this._defaultEmissiveTexture = this._defaultEmissiveTexture && this._defaultEmissiveTexture.destroy();
    this._defaultNormalTexture = this._defaultNormalTexture && this._defaultNormalTexture.destroy();
    this._defaultCubeMap = this._defaultCubeMap && this._defaultCubeMap.destroy();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
};
const __TURBOPACK__default__export__ = Context;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/Sync.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/destroyObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Frozen.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/RuntimeError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/WebGLConstants.js [app-client] (ecmascript)");
;
;
;
;
;
;
/**
 * The WebGLSync interface is part of the WebGL 2 API and is used to synchronize activities between the GPU and the application.
 *
 * @param {object} options Object with the following properties:
 * @param {Context} context
 *
 * @exception {DeveloperError} A WebGL 2 context is required to use Sync operations.
 *
 * @private
 * @constructor
 */ function Sync(options) {
    options = options ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Frozen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EMPTY_OBJECT;
    const context = options.context;
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("options.context", context);
    //>>includeEnd('debug');
    if (!context._webgl2) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("A WebGL 2 context is required to use Sync operations.");
    }
    const gl = context._gl;
    const sync = gl.fenceSync(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SYNC_GPU_COMMANDS_COMPLETE, 0);
    this._gl = gl;
    this._sync = sync;
}
Sync.create = function(options) {
    return new Sync(options);
};
/**
 * Query the sync status of this Sync object.
 *
 * @returns {number} Returns a WebGLConstants indicating the status of the sync object (WebGLConstants.SIGNALED or WebGLConstants.UNSIGNALED).
 *
 * @private
 */ Sync.prototype.getStatus = function() {
    const status = this._gl.getSyncParameter(this._sync, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SYNC_STATUS);
    return status;
};
Sync.prototype.isDestroyed = function() {
    return false;
};
Sync.prototype.destroy = function() {
    this._gl.deleteSync(this._sync);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
};
/**
 * Incremantally polls the status of the Sync object until signaled then resolves.
 * Usually polling should be done once per frame.
 *
 * @example
 * try {
 *  await sync.waitForSignal(function (next) {
 *    setTimeout(next, 100);
 *  });
 *} catch (e) {
 *  throw "Signal timeout";
 *} finally {
 *  sync.destroy();
 *}
 *
 * @param {function} scheduleFunction Function for scheduling the next poll. Receives a callback as its only parameter.
 * @param {number} [ttl=10] Max number of iterations to poll until timeout.
 *
 * @exception {RuntimeError} Wait for signal timeout.
 */ Sync.prototype.waitForSignal = async function(scheduleFunction, ttl) {
    const self = this;
    ttl = ttl ?? 10;
    function waitForSignal0(resolve, reject, ttl) {
        return ()=>{
            const syncStatus = self.getStatus();
            const signaled = syncStatus === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$WebGLConstants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SIGNALED;
            if (signaled) {
                resolve();
            } else if (ttl <= 0) {
                reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$RuntimeError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("Wait for signal timeout"));
            } else {
                scheduleFunction(waitForSignal0(resolve, reject, ttl - 1));
            }
        };
    }
    return new Promise((resolve, reject)=>{
        scheduleFunction(waitForSignal0(resolve, reject, ttl));
    });
};
const __TURBOPACK__default__export__ = Sync;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/SharedContext.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$clone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/clone.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/destroyObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/Context.js [app-client] (ecmascript)");
;
;
;
;
/**
 * Enables a single WebGL context to be used by any number of {@link Scene}s.
 * You can pass a SharedContext in place of a {@link ContextOptions} to the constructors of {@link Scene}, {@link CesiumWidget}, and {@link Viewer}.
 * {@link Primitive}s associated with the shared WebGL context can be displayed in any Scene that uses the same context.
 * The context renders each Scene to an off-screen canvas, then blits the result to that Scene's on-screen canvas.
 *
 * @private
 * @alias SharedContext
 * @constructor
 *
 * @param {object} [options] Object with the following properties:
 * @param {ContextOptions} [options.contextOptions] Context and WebGL creation properties.
 * @param {boolean} [options.autoDestroy=true] Destroys this context and all of its WebGL resources after all Scenes using the context are destroyed.

 * @see {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}
 *
 * @example
 * // Create two Scenes sharing a single WebGL context
 * const context = new Cesium.SharedContext();
 * const scene1 = new Cesium.Scene({
 *   canvas: canvas1,
 *   contextOptions: context,
 * });
 * const scene2 = new Cesium.Scene({
 *   canvas: canvas2,
 *   contextOptions: context,
 * });
 */ function SharedContext(options) {
    this._autoDestroy = options?.autoDestroy ?? true;
    this._canvas = document.createElement("canvas");
    this._context = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$Context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this._canvas, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$clone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options?.contextOptions));
    this._canvases = [];
}
/**
 * Creates an instance of {@link Context} that manages the shared WebGL context for a specific canvas.
 * @param {HTMLCanvasElement} canvas The canvas element to which the context will be associated
 * @returns {Context} The created context instance
 * @private
 */ SharedContext.prototype.createSceneContext = function(canvas) {
    const context2d = canvas.getContext("2d", {
        alpha: true
    });
    //>>includeStart('debug', pragmas.debug);
    if (!context2d) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("canvas used with SharedContext must provide a 2d context");
    }
    if (this._canvases.includes(canvas)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("canvas is already associated with a scene");
    }
    //>>includeEnd('debug');
    const sharedContext = this;
    sharedContext._canvases.push(canvas);
    let isDestroyed = false;
    const destroy = function() {
        isDestroyed = true;
        const index = sharedContext._canvases.indexOf(canvas);
        if (-1 !== index) {
            sharedContext._canvases.splice(index, 1);
            if (sharedContext._autoDestroy && sharedContext._canvases.length === 0) {
                sharedContext.destroy();
            }
        }
    };
    const beginFrame = function() {
        // Ensure the off-screen canvas is at least as large as the on-screen canvas.
        const sharedCanvas = sharedContext._context.canvas;
        const width = this.drawingBufferWidth;
        if (sharedCanvas.width < width) {
            sharedCanvas.width = width;
        }
        const height = this.drawingBufferHeight;
        if (sharedCanvas.height < height) {
            sharedCanvas.height = height;
        }
    };
    const endFrame = function() {
        // Blit the image from the off-screen canvas to the on-screen canvas.
        const w = this.drawingBufferWidth;
        const h = this.drawingBufferHeight;
        const yOffset = sharedContext._context.canvas.height - h; // drawImage has top as Y=0, GL has bottom as Y=0
        context2d.drawImage(sharedContext._context.canvas, 0, yOffset, w, h, 0, 0, w, h);
        // Do normal post-frame cleanup.
        sharedContext._context.endFrame();
    };
    const proxy = new Proxy(this._context, {
        get (target, prop, receiver) {
            if (prop === "isDestroyed") {
                return function() {
                    return isDestroyed;
                };
            } else if (isDestroyed) {
                //>>includeStart('debug', pragmas.debug);
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("This object was destroyed, i.e., destroy() was called.");
            //>>includeEnd('debug');
            }
            switch(prop){
                case "_canvas":
                    return canvas;
                case "destroy":
                    return destroy;
                case "drawingBufferWidth":
                    return canvas.width;
                case "drawingBufferHeight":
                    return canvas.height;
                case "beginFrame":
                    return beginFrame;
                case "endFrame":
                    return endFrame;
                default:
                    return Reflect.get(target, prop, receiver);
            }
        }
    });
    return proxy;
};
/**
 * Destroys the WebGL resources held by this object. Destroying an object allows for deterministic
 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
 * <br /><br />
 * Once an object is destroyed, it should not be used; calling any function other than
 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception. Therefore,
 * assign the return value (<code>undefined</code>) to the object as done in the example.
 * <br /><br />
 * By default, a SharedContext is destroyed automatically once the last Scene using it is destroyed, in which case it
 * is not necessary to call this method directly.
 *
 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
 *
 * @example
 * context = context && context.destroy();
 *
 * @see SharedContext#isDestroyed
 */ SharedContext.prototype.destroy = function() {
    this._context.destroy();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$destroyObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
};
/**
 * Returns true if this object was destroyed; otherwise, false.
 * <br /><br />
 * If this object was destroyed, it should not be used; calling any function other than
 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
 *
 * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
 *
 * @see SharedContext#destroy
 */ SharedContext.prototype.isDestroyed = function() {
    return false;
};
const __TURBOPACK__default__export__ = SharedContext;
}),
"[project]/node_modules/@cesium/engine/Source/Renderer/loadCubeMap.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/defined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/DeveloperError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Core/Resource.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$CubeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cesium/engine/Source/Renderer/CubeMap.js [app-client] (ecmascript)");
;
;
;
;
;
/**
 * Asynchronously loads six images and creates a cube map.  Returns a promise that
 * will resolve to a {@link CubeMap} once loaded, or reject if any image fails to load.
 *
 * @function loadCubeMap
 *
 * @param {Context} context The context to use to create the cube map.
 * @param {object} urls The source URL of each image.  See the example below.
 * @param {boolean} [skipColorSpaceConversion=false] If true, any custom gamma or color profiles in the images will be ignored.
 * @returns {Promise<CubeMap>} a promise that will resolve to the requested {@link CubeMap} when loaded.
 *
 * @exception {DeveloperError} context is required.
 * @exception {DeveloperError} urls is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.
 *
 *
 * @example
 * Cesium.loadCubeMap(context, {
 *     positiveX : 'skybox_px.png',
 *     negativeX : 'skybox_nx.png',
 *     positiveY : 'skybox_py.png',
 *     negativeY : 'skybox_ny.png',
 *     positiveZ : 'skybox_pz.png',
 *     negativeZ : 'skybox_nz.png'
 * }).then(function(cubeMap) {
 *     // use the cubemap
 * }).catch(function(error) {
 *     // an error occurred
 * });
 *
 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
 *
 * @private
 */ function loadCubeMap(context, urls, skipColorSpaceConversion) {
    //>>includeStart('debug', pragmas.debug);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("context", context);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].defined("urls", urls);
    if (Object.values(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$CubeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FaceName).some((faceName)=>!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$defined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(urls[faceName]))) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$DeveloperError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("urls must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.");
    }
    //>>includeEnd('debug');
    // PERFORMANCE_IDEA: Given the size of some cube maps, we should consider tiling them, which
    // would prevent hiccups when uploading, for example, six 4096x4096 textures to the GPU.
    //
    // Also, it is perhaps acceptable to use the context here in the callbacks, but
    // ideally, we would do it in the primitive's update function.
    const flipOptions = {
        flipY: true,
        skipColorSpaceConversion: skipColorSpaceConversion,
        preferImageBitmap: true
    };
    const facePromises = [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createIfNeeded(urls.positiveX).fetchImage(flipOptions),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createIfNeeded(urls.negativeX).fetchImage(flipOptions),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createIfNeeded(urls.positiveY).fetchImage(flipOptions),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createIfNeeded(urls.negativeY).fetchImage(flipOptions),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createIfNeeded(urls.positiveZ).fetchImage(flipOptions),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Core$2f$Resource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createIfNeeded(urls.negativeZ).fetchImage(flipOptions)
    ];
    return Promise.all(facePromises).then(function(images) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cesium$2f$engine$2f$Source$2f$Renderer$2f$CubeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            context: context,
            source: {
                positiveX: images[0],
                negativeX: images[1],
                positiveY: images[2],
                negativeY: images[3],
                positiveZ: images[4],
                negativeZ: images[5]
            }
        });
    });
}
const __TURBOPACK__default__export__ = loadCubeMap;
}),
]);

//# sourceMappingURL=node_modules_%40cesium_engine_Source_Renderer_2de1a290._.js.map