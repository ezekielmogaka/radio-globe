{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelUtility.js"],"sourcesContent":["import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport Axis from \"../Axis.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport CullFace from \"../CullFace.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\n\n/**\n * Utility functions for {@link Model}.\n *\n * @private\n */\nfunction ModelUtility() {}\n\n/**\n * Create a function for reporting when a model fails to load\n *\n * @param {string} type The type of object to report about\n * @param {string} path The URI of the model file\n * @param {Error} [error] The error which caused the failure\n * @returns {RuntimeError} An error for the failed model\n *\n * @private\n */\nModelUtility.getError = function (type, path, error) {\n  let message = `Failed to load ${type}: ${path}`;\n  if (defined(error) && defined(error.message)) {\n    message += `\\n${error.message}`;\n  }\n\n  const runtimeError = new RuntimeError(message);\n  if (defined(error)) {\n    // the original call stack is often more useful than the new error's stack,\n    // so add the information here\n    runtimeError.stack = `Original stack:\\n${error.stack}\\nHandler stack:\\n${runtimeError.stack}`;\n  }\n\n  return runtimeError;\n};\n\n/**\n * Get a transformation matrix from a node in the model.\n *\n * @param {ModelComponents.Node} node The node components\n * @returns {Matrix4} The computed transformation matrix. If no transformation matrix or parameters are specified, this will be the identity matrix.\n *\n * @private\n */\nModelUtility.getNodeTransform = function (node) {\n  if (defined(node.matrix)) {\n    return node.matrix;\n  }\n\n  return Matrix4.fromTranslationQuaternionRotationScale(\n    defined(node.translation) ? node.translation : Cartesian3.ZERO,\n    defined(node.rotation) ? node.rotation : Quaternion.IDENTITY,\n    defined(node.scale) ? node.scale : Cartesian3.ONE,\n  );\n};\n\n/**\n * Find an attribute by semantic such as POSITION or TANGENT.\n *\n * @param {ModelComponents.Primitive|ModelComponents.Instances} object The primitive components or instances object\n * @param {VertexAttributeSemantic|InstanceAttributeSemantic} semantic The semantic to search for\n * @param {number} [setIndex] The set index of the semantic. May be undefined for some semantics (POSITION, NORMAL, TRANSLATION, ROTATION, for example)\n * @return {ModelComponents.Attribute} The selected attribute, or undefined if not found.\n *\n * @private\n */\nModelUtility.getAttributeBySemantic = function (object, semantic, setIndex) {\n  const attributes = object.attributes;\n  const attributesLength = attributes.length;\n  for (let i = 0; i < attributesLength; ++i) {\n    const attribute = attributes[i];\n    const matchesSetIndex = defined(setIndex)\n      ? attribute.setIndex === setIndex\n      : true;\n    if (attribute.semantic === semantic && matchesSetIndex) {\n      return attribute;\n    }\n  }\n\n  return undefined;\n};\n\n/**\n * Similar to getAttributeBySemantic, but search using the name field only,\n * as custom attributes do not have a semantic.\n *\n * @param {ModelComponents.Primitive|ModelComponents.Instances} object The primitive components or instances object\n * @param {string} name The name of the attribute as it appears in the model file.\n * @return {ModelComponents.Attribute} The selected attribute, or undefined if not found.\n *\n * @private\n */\nModelUtility.getAttributeByName = function (object, name) {\n  const attributes = object.attributes;\n  const attributesLength = attributes.length;\n  for (let i = 0; i < attributesLength; ++i) {\n    const attribute = attributes[i];\n    if (attribute.name === name) {\n      return attribute;\n    }\n  }\n\n  return undefined;\n};\n\n/**\n * Find a feature ID from an array with label or positionalLabel matching the\n * given label\n * @param {ModelComponents.FeatureIdAttribute[]|ModelComponents.FeatureIdImplicitRange[]|ModelComponents.FeatureIdTexture[]} featureIds\n * @param {string} label the label to search for\n * @returns {ModelComponents.FeatureIdAttribute|ModelComponents.FeatureIdImplicitRange|ModelComponents.FeatureIdTexture} The feature ID set if found, otherwise <code>undefined</code>\n *\n * @private\n */\nModelUtility.getFeatureIdsByLabel = function (featureIds, label) {\n  for (let i = 0; i < featureIds.length; i++) {\n    const featureIdSet = featureIds[i];\n    if (\n      featureIdSet.positionalLabel === label ||\n      featureIdSet.label === label\n    ) {\n      return featureIdSet;\n    }\n  }\n\n  return undefined;\n};\n\nModelUtility.hasQuantizedAttributes = function (attributes) {\n  if (!defined(attributes)) {\n    return false;\n  }\n\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    if (defined(attribute.quantization)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @param {ModelComponents.Attribute} attribute\n *\n * @private\n */\nModelUtility.getAttributeInfo = function (attribute) {\n  const semantic = attribute.semantic;\n  const setIndex = attribute.setIndex;\n\n  let variableName;\n  let hasSemantic = false;\n  if (defined(semantic)) {\n    variableName = VertexAttributeSemantic.getVariableName(semantic, setIndex);\n    hasSemantic = true;\n  } else {\n    variableName = attribute.name;\n    // According to the glTF 2.0 spec, custom attributes must be prepended with\n    // an underscore.\n    variableName = variableName.replace(/^_/, \"\");\n    variableName = variableName.toLowerCase();\n  }\n\n  const isVertexColor = /^color_\\d+$/.test(variableName);\n  const attributeType = attribute.type;\n  let glslType = AttributeType.getGlslType(attributeType);\n\n  // color_n can be either a vec3 or a vec4. But in GLSL we can always use\n  // attribute vec4 since GLSL promotes vec3 attribute data to vec4 with\n  // the .a channel set to 1.0.\n  if (isVertexColor) {\n    glslType = \"vec4\";\n  }\n\n  const isQuantized = defined(attribute.quantization);\n  let quantizedGlslType;\n  if (isQuantized) {\n    // The quantized color_n attribute also is promoted to a vec4 in the shader\n    quantizedGlslType = isVertexColor\n      ? \"vec4\"\n      : AttributeType.getGlslType(attribute.quantization.type);\n  }\n\n  return {\n    attribute: attribute,\n    isQuantized: isQuantized,\n    variableName: variableName,\n    hasSemantic: hasSemantic,\n    glslType: glslType,\n    quantizedGlslType: quantizedGlslType,\n  };\n};\n\nconst cartesianMaxScratch = new Cartesian3();\nconst cartesianMinScratch = new Cartesian3();\n\n/**\n * Get the minimum and maximum values for a primitive's POSITION attribute.\n * This is used to compute the bounding sphere of the primitive, as well as\n * the bounding sphere of the whole model.\n *\n * @param {ModelComponents.Primitive} primitive The primitive components.\n * @param {Cartesian3} [instancingTranslationMin] The component-wise minimum value of the instancing translation attribute.\n * @param {Cartesian3} [instancingTranslationMax] The component-wise maximum value of the instancing translation attribute.\n *\n * @returns {object} An object containing the minimum and maximum position values.\n *\n * @private\n */\nModelUtility.getPositionMinMax = function (\n  primitive,\n  instancingTranslationMin,\n  instancingTranslationMax,\n) {\n  const positionGltfAttribute = ModelUtility.getAttributeBySemantic(\n    primitive,\n    \"POSITION\",\n  );\n\n  let positionMax = positionGltfAttribute.max;\n  let positionMin = positionGltfAttribute.min;\n\n  if (defined(instancingTranslationMax) && defined(instancingTranslationMin)) {\n    positionMin = Cartesian3.add(\n      positionMin,\n      instancingTranslationMin,\n      cartesianMinScratch,\n    );\n    positionMax = Cartesian3.add(\n      positionMax,\n      instancingTranslationMax,\n      cartesianMaxScratch,\n    );\n  }\n\n  return {\n    min: positionMin,\n    max: positionMax,\n  };\n};\n\n/**\n * Model matrices in a model file (e.g. glTF) are typically in a different\n * coordinate system, such as with y-up instead of z-up in 3D Tiles.\n * This function returns a matrix that will correct this such that z is up,\n * and x is forward.\n *\n * @param {Axis} upAxis The original up direction\n * @param {Axis} forwardAxis The original forward direction\n * @param {Matrix4} result The matrix in which to store the result.\n * @returns {Matrix4} The axis correction matrix\n *\n * @private\n */\nModelUtility.getAxisCorrectionMatrix = function (upAxis, forwardAxis, result) {\n  result = Matrix4.clone(Matrix4.IDENTITY, result);\n\n  if (upAxis === Axis.Y) {\n    result = Matrix4.clone(Axis.Y_UP_TO_Z_UP, result);\n  } else if (upAxis === Axis.X) {\n    result = Matrix4.clone(Axis.X_UP_TO_Z_UP, result);\n  }\n\n  if (forwardAxis === Axis.Z) {\n    // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.\n    result = Matrix4.multiplyTransformation(result, Axis.Z_UP_TO_X_UP, result);\n  }\n\n  return result;\n};\n\nconst scratchMatrix3 = new Matrix3();\n\n/**\n * Get the cull face to use in the command's render state.\n * <p>\n * From the glTF spec section 3.7.4:\n * When a mesh primitive uses any triangle-based topology (i.e., triangles,\n * triangle strip, or triangle fan), the determinant of the nodeâ€™s global\n * transform defines the winding order of that primitive. If the determinant\n * is a positive value, the winding order triangle faces is counterclockwise;\n * in the opposite case, the winding order is clockwise.\n * </p>\n *\n * @param {Matrix4} modelMatrix The model matrix\n * @param {PrimitiveType} primitiveType The primitive type\n * @returns {CullFace} The cull face\n *\n * @private\n */\nModelUtility.getCullFace = function (modelMatrix, primitiveType) {\n  if (!PrimitiveType.isTriangles(primitiveType)) {\n    return CullFace.BACK;\n  }\n\n  const matrix3 = Matrix4.getMatrix3(modelMatrix, scratchMatrix3);\n  return Matrix3.determinant(matrix3) < 0.0 ? CullFace.FRONT : CullFace.BACK;\n};\n\n/**\n * Sanitize the identifier to be used in a GLSL shader. The identifier\n * is sanitized as follows:\n * - Replace all sequences of non-alphanumeric characters with a single `_`.\n * - If the gl_ prefix is present, remove it. The prefix is reserved in GLSL.\n * - If the identifier starts with a digit, prefix it with an underscore.\n *\n * @example\n * // Returns \"customProperty\"\n * ModelUtility.sanitizeGlslIdentifier(\"gl_customProperty\");\n *\n * @example\n * // Returns \"_1234\"\n * ModelUtility.sanitizeGlslIdentifier(\"1234\");\n *\n * @param {string} identifier The original identifier.\n *\n * @returns {string} The sanitized version of the identifier.\n */\nModelUtility.sanitizeGlslIdentifier = function (identifier) {\n  // Remove non-alphanumeric characters and replace with a single underscore.\n  // This regex is designed so that the result won't have multiple underscores\n  // in a row.\n  let sanitizedIdentifier = identifier.replaceAll(/[^A-Za-z0-9]+/g, \"_\");\n  // Remove the gl_ prefix if present.\n  sanitizedIdentifier = sanitizedIdentifier.replace(/^gl_/, \"\");\n  // Add an underscore if first character is a digit.\n  if (/^\\d/.test(sanitizedIdentifier)) {\n    sanitizedIdentifier = `_${sanitizedIdentifier}`;\n  }\n\n  return sanitizedIdentifier;\n};\n\nModelUtility.supportedExtensions = {\n  AGI_articulations: true,\n  CESIUM_primitive_outline: true,\n  CESIUM_RTC: true,\n  EXT_feature_metadata: true,\n  EXT_implicit_cylinder_region: true,\n  EXT_implicit_ellipsoid_region: true,\n  EXT_instance_features: true,\n  EXT_mesh_features: true,\n  EXT_mesh_gpu_instancing: true,\n  EXT_meshopt_compression: true,\n  EXT_primitive_voxels: true,\n  EXT_structural_metadata: true,\n  EXT_texture_webp: true,\n  KHR_blend: true,\n  KHR_draco_mesh_compression: true,\n  KHR_implicit_shapes: true,\n  KHR_materials_common: true,\n  KHR_materials_pbrSpecularGlossiness: true,\n  KHR_materials_specular: true,\n  KHR_materials_anisotropy: true,\n  KHR_materials_clearcoat: true,\n  KHR_materials_unlit: true,\n  KHR_mesh_quantization: true,\n  KHR_techniques_webgl: true,\n  KHR_texture_basisu: true,\n  KHR_texture_transform: true,\n  KHR_gaussian_splatting: true,\n  KHR_gaussian_splatting_compression_spz_2: true,\n  WEB3D_quantized_attributes: true,\n};\n\n/**\n * Checks whether or not the extensions required by the glTF are\n * supported. If an unsupported extension is found, this throws\n * a {@link RuntimeError} with the extension name.\n *\n * @param {string[]} extensionsRequired The extensionsRequired array in the glTF.\n *\n * @exception {RuntimeError} Unsupported glTF Extension\n */\nModelUtility.checkSupportedExtensions = function (extensionsRequired) {\n  const length = extensionsRequired.length;\n  for (let i = 0; i < length; i++) {\n    const extension = extensionsRequired[i];\n    if (!ModelUtility.supportedExtensions[extension]) {\n      throw new RuntimeError(`Unsupported glTF Extension: ${extension}`);\n    }\n  }\n};\n\nexport default ModelUtility;\n"],"names":["ModelUtility","getError","type","path","error","message","runtimeError","stack","getNodeTransform","node","matrix","fromTranslationQuaternionRotationScale","translation","ZERO","rotation","IDENTITY","scale","ONE","getAttributeBySemantic","object","semantic","setIndex","attributes","attributesLength","length","i","attribute","matchesSetIndex","undefined","getAttributeByName","name","getFeatureIdsByLabel","featureIds","label","featureIdSet","positionalLabel","hasQuantizedAttributes","quantization","getAttributeInfo","variableName","hasSemantic","getVariableName","replace","toLowerCase","isVertexColor","test","attributeType","glslType","getGlslType","isQuantized","quantizedGlslType","cartesianMaxScratch","cartesianMinScratch","getPositionMinMax","primitive","instancingTranslationMin","instancingTranslationMax","positionGltfAttribute","positionMax","max","positionMin","min","add","getAxisCorrectionMatrix","upAxis","forwardAxis","result","clone","Y","Y_UP_TO_Z_UP","X","X_UP_TO_Z_UP","Z","multiplyTransformation","Z_UP_TO_X_UP","scratchMatrix3","getCullFace","modelMatrix","primitiveType","isTriangles","BACK","matrix3","getMatrix3","determinant","FRONT","sanitizeGlslIdentifier","identifier","sanitizedIdentifier","replaceAll","supportedExtensions","AGI_articulations","CESIUM_primitive_outline","CESIUM_RTC","EXT_feature_metadata","EXT_implicit_cylinder_region","EXT_implicit_ellipsoid_region","EXT_instance_features","EXT_mesh_features","EXT_mesh_gpu_instancing","EXT_meshopt_compression","EXT_primitive_voxels","EXT_structural_metadata","EXT_texture_webp","KHR_blend","KHR_draco_mesh_compression","KHR_implicit_shapes","KHR_materials_common","KHR_materials_pbrSpecularGlossiness","KHR_materials_specular","KHR_materials_anisotropy","KHR_materials_clearcoat","KHR_materials_unlit","KHR_mesh_quantization","KHR_techniques_webgl","KHR_texture_basisu","KHR_texture_transform","KHR_gaussian_splatting","KHR_gaussian_splatting_compression_spz_2","WEB3D_quantized_attributes","checkSupportedExtensions","extensionsRequired","extension"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAEA;;;;CAIC,GACD,SAASA,gBAAgB;AAEzB;;;;;;;;;CASC,GACDA,aAAaC,QAAQ,GAAG,SAAUC,IAAI,EAAEC,IAAI,EAAEC,KAAK;IACjD,IAAIC,UAAU,CAAC,eAAe,EAAEH,KAAK,EAAE,EAAEC,MAAM;IAC/C,IAAI,IAAA,6KAAO,EAACC,UAAU,IAAA,6KAAO,EAACA,MAAMC,OAAO,GAAG;QAC5CA,WAAW,CAAC,EAAE,EAAED,MAAMC,OAAO,EAAE;IACjC;IAEA,MAAMC,eAAe,IAAI,kLAAY,CAACD;IACtC,IAAI,IAAA,6KAAO,EAACD,QAAQ;QAClB,2EAA2E;QAC3E,8BAA8B;QAC9BE,aAAaC,KAAK,GAAG,CAAC,iBAAiB,EAAEH,MAAMG,KAAK,CAAC,kBAAkB,EAAED,aAAaC,KAAK,EAAE;IAC/F;IAEA,OAAOD;AACT;AAEA;;;;;;;CAOC,GACDN,aAAaQ,gBAAgB,GAAG,SAAUC,IAAI;IAC5C,IAAI,IAAA,6KAAO,EAACA,KAAKC,MAAM,GAAG;QACxB,OAAOD,KAAKC,MAAM;IACpB;IAEA,OAAO,6KAAO,CAACC,sCAAsC,CACnD,IAAA,6KAAO,EAACF,KAAKG,WAAW,IAAIH,KAAKG,WAAW,GAAG,gLAAU,CAACC,IAAI,EAC9D,IAAA,6KAAO,EAACJ,KAAKK,QAAQ,IAAIL,KAAKK,QAAQ,GAAG,gLAAU,CAACC,QAAQ,EAC5D,IAAA,6KAAO,EAACN,KAAKO,KAAK,IAAIP,KAAKO,KAAK,GAAG,gLAAU,CAACC,GAAG;AAErD;AAEA;;;;;;;;;CASC,GACDjB,aAAakB,sBAAsB,GAAG,SAAUC,MAAM,EAAEC,QAAQ,EAAEC,QAAQ;IACxE,MAAMC,aAAaH,OAAOG,UAAU;IACpC,MAAMC,mBAAmBD,WAAWE,MAAM;IAC1C,IAAK,IAAIC,IAAI,GAAGA,IAAIF,kBAAkB,EAAEE,EAAG;QACzC,MAAMC,YAAYJ,UAAU,CAACG,EAAE;QAC/B,MAAME,kBAAkB,IAAA,6KAAO,EAACN,YAC5BK,UAAUL,QAAQ,KAAKA,WACvB;QACJ,IAAIK,UAAUN,QAAQ,KAAKA,YAAYO,iBAAiB;YACtD,OAAOD;QACT;IACF;IAEA,OAAOE;AACT;AAEA;;;;;;;;;CASC,GACD5B,aAAa6B,kBAAkB,GAAG,SAAUV,MAAM,EAAEW,IAAI;IACtD,MAAMR,aAAaH,OAAOG,UAAU;IACpC,MAAMC,mBAAmBD,WAAWE,MAAM;IAC1C,IAAK,IAAIC,IAAI,GAAGA,IAAIF,kBAAkB,EAAEE,EAAG;QACzC,MAAMC,YAAYJ,UAAU,CAACG,EAAE;QAC/B,IAAIC,UAAUI,IAAI,KAAKA,MAAM;YAC3B,OAAOJ;QACT;IACF;IAEA,OAAOE;AACT;AAEA;;;;;;;;CAQC,GACD5B,aAAa+B,oBAAoB,GAAG,SAAUC,UAAU,EAAEC,KAAK;IAC7D,IAAK,IAAIR,IAAI,GAAGA,IAAIO,WAAWR,MAAM,EAAEC,IAAK;QAC1C,MAAMS,eAAeF,UAAU,CAACP,EAAE;QAClC,IACES,aAAaC,eAAe,KAAKF,SACjCC,aAAaD,KAAK,KAAKA,OACvB;YACA,OAAOC;QACT;IACF;IAEA,OAAON;AACT;AAEA5B,aAAaoC,sBAAsB,GAAG,SAAUd,UAAU;IACxD,IAAI,CAAC,IAAA,6KAAO,EAACA,aAAa;QACxB,OAAO;IACT;IAEA,IAAK,IAAIG,IAAI,GAAGA,IAAIH,WAAWE,MAAM,EAAEC,IAAK;QAC1C,MAAMC,YAAYJ,UAAU,CAACG,EAAE;QAC/B,IAAI,IAAA,6KAAO,EAACC,UAAUW,YAAY,GAAG;YACnC,OAAO;QACT;IACF;IACA,OAAO;AACT;AAEA;;;;CAIC,GACDrC,aAAasC,gBAAgB,GAAG,SAAUZ,SAAS;IACjD,MAAMN,WAAWM,UAAUN,QAAQ;IACnC,MAAMC,WAAWK,UAAUL,QAAQ;IAEnC,IAAIkB;IACJ,IAAIC,cAAc;IAClB,IAAI,IAAA,6KAAO,EAACpB,WAAW;QACrBmB,eAAe,8LAAuB,CAACE,eAAe,CAACrB,UAAUC;QACjEmB,cAAc;IAChB,OAAO;QACLD,eAAeb,UAAUI,IAAI;QAC7B,2EAA2E;QAC3E,iBAAiB;QACjBS,eAAeA,aAAaG,OAAO,CAAC,MAAM;QAC1CH,eAAeA,aAAaI,WAAW;IACzC;IAEA,MAAMC,gBAAgB,cAAcC,IAAI,CAACN;IACzC,MAAMO,gBAAgBpB,UAAUxB,IAAI;IACpC,IAAI6C,WAAW,oLAAa,CAACC,WAAW,CAACF;IAEzC,wEAAwE;IACxE,sEAAsE;IACtE,6BAA6B;IAC7B,IAAIF,eAAe;QACjBG,WAAW;IACb;IAEA,MAAME,cAAc,IAAA,6KAAO,EAACvB,UAAUW,YAAY;IAClD,IAAIa;IACJ,IAAID,aAAa;QACf,2EAA2E;QAC3EC,oBAAoBN,gBAChB,SACA,oLAAa,CAACI,WAAW,CAACtB,UAAUW,YAAY,CAACnC,IAAI;IAC3D;IAEA,OAAO;QACLwB,WAAWA;QACXuB,aAAaA;QACbV,cAAcA;QACdC,aAAaA;QACbO,UAAUA;QACVG,mBAAmBA;IACrB;AACF;AAEA,MAAMC,sBAAsB,IAAI,gLAAU;AAC1C,MAAMC,sBAAsB,IAAI,gLAAU;AAE1C;;;;;;;;;;;;CAYC,GACDpD,aAAaqD,iBAAiB,GAAG,SAC/BC,SAAS,EACTC,wBAAwB,EACxBC,wBAAwB;IAExB,MAAMC,wBAAwBzD,aAAakB,sBAAsB,CAC/DoC,WACA;IAGF,IAAII,cAAcD,sBAAsBE,GAAG;IAC3C,IAAIC,cAAcH,sBAAsBI,GAAG;IAE3C,IAAI,IAAA,6KAAO,EAACL,6BAA6B,IAAA,6KAAO,EAACD,2BAA2B;QAC1EK,cAAc,gLAAU,CAACE,GAAG,CAC1BF,aACAL,0BACAH;QAEFM,cAAc,gLAAU,CAACI,GAAG,CAC1BJ,aACAF,0BACAL;IAEJ;IAEA,OAAO;QACLU,KAAKD;QACLD,KAAKD;IACP;AACF;AAEA;;;;;;;;;;;;CAYC,GACD1D,aAAa+D,uBAAuB,GAAG,SAAUC,MAAM,EAAEC,WAAW,EAAEC,MAAM;IAC1EA,SAAS,6KAAO,CAACC,KAAK,CAAC,6KAAO,CAACpD,QAAQ,EAAEmD;IAEzC,IAAIF,WAAW,2KAAI,CAACI,CAAC,EAAE;QACrBF,SAAS,6KAAO,CAACC,KAAK,CAAC,2KAAI,CAACE,YAAY,EAAEH;IAC5C,OAAO,IAAIF,WAAW,2KAAI,CAACM,CAAC,EAAE;QAC5BJ,SAAS,6KAAO,CAACC,KAAK,CAAC,2KAAI,CAACI,YAAY,EAAEL;IAC5C;IAEA,IAAID,gBAAgB,2KAAI,CAACO,CAAC,EAAE;QAC1B,8EAA8E;QAC9EN,SAAS,6KAAO,CAACO,sBAAsB,CAACP,QAAQ,2KAAI,CAACQ,YAAY,EAAER;IACrE;IAEA,OAAOA;AACT;AAEA,MAAMS,iBAAiB,IAAI,6KAAO;AAElC;;;;;;;;;;;;;;;;CAgBC,GACD3E,aAAa4E,WAAW,GAAG,SAAUC,WAAW,EAAEC,aAAa;IAC7D,IAAI,CAAC,mLAAa,CAACC,WAAW,CAACD,gBAAgB;QAC7C,OAAO,+KAAQ,CAACE,IAAI;IACtB;IAEA,MAAMC,UAAU,6KAAO,CAACC,UAAU,CAACL,aAAaF;IAChD,OAAO,6KAAO,CAACQ,WAAW,CAACF,WAAW,MAAM,+KAAQ,CAACG,KAAK,GAAG,+KAAQ,CAACJ,IAAI;AAC5E;AAEA;;;;;;;;;;;;;;;;;;CAkBC,GACDhF,aAAaqF,sBAAsB,GAAG,SAAUC,UAAU;IACxD,2EAA2E;IAC3E,4EAA4E;IAC5E,YAAY;IACZ,IAAIC,sBAAsBD,WAAWE,UAAU,CAAC,kBAAkB;IAClE,oCAAoC;IACpCD,sBAAsBA,oBAAoB7C,OAAO,CAAC,QAAQ;IAC1D,mDAAmD;IACnD,IAAI,MAAMG,IAAI,CAAC0C,sBAAsB;QACnCA,sBAAsB,CAAC,CAAC,EAAEA,qBAAqB;IACjD;IAEA,OAAOA;AACT;AAEAvF,aAAayF,mBAAmB,GAAG;IACjCC,mBAAmB;IACnBC,0BAA0B;IAC1BC,YAAY;IACZC,sBAAsB;IACtBC,8BAA8B;IAC9BC,+BAA+B;IAC/BC,uBAAuB;IACvBC,mBAAmB;IACnBC,yBAAyB;IACzBC,yBAAyB;IACzBC,sBAAsB;IACtBC,yBAAyB;IACzBC,kBAAkB;IAClBC,WAAW;IACXC,4BAA4B;IAC5BC,qBAAqB;IACrBC,sBAAsB;IACtBC,qCAAqC;IACrCC,wBAAwB;IACxBC,0BAA0B;IAC1BC,yBAAyB;IACzBC,qBAAqB;IACrBC,uBAAuB;IACvBC,sBAAsB;IACtBC,oBAAoB;IACpBC,uBAAuB;IACvBC,wBAAwB;IACxBC,0CAA0C;IAC1CC,4BAA4B;AAC9B;AAEA;;;;;;;;CAQC,GACDtH,aAAauH,wBAAwB,GAAG,SAAUC,kBAAkB;IAClE,MAAMhG,SAASgG,mBAAmBhG,MAAM;IACxC,IAAK,IAAIC,IAAI,GAAGA,IAAID,QAAQC,IAAK;QAC/B,MAAMgG,YAAYD,kBAAkB,CAAC/F,EAAE;QACvC,IAAI,CAACzB,aAAayF,mBAAmB,CAACgC,UAAU,EAAE;YAChD,MAAM,IAAI,kLAAY,CAAC,CAAC,4BAA4B,EAAEA,WAAW;QACnE;IACF;AACF;uCAEezH","ignoreList":[0]}},
    {"offset": {"line": 343, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/PrimitiveOutlineGenerator.js"],"sourcesContent":["import Check from \"../../Core/Check.js\";\nimport defined from \"../../Core/defined.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport PixelFormat from \"../../Core/PixelFormat.js\";\nimport ContextLimits from \"../../Renderer/ContextLimits.js\";\nimport Sampler from \"../../Renderer/Sampler.js\";\nimport Texture from \"../../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../../Renderer/TextureWrap.js\";\n\n// glTF does not allow an index value of 65535 because this is the primitive\n// restart value in some APIs.\nconst MAX_GLTF_UINT16_INDEX = 65534;\nconst MAX_GLTF_UINT8_INDEX = 255;\n\n/**\n * A class to handle the low-level details of processing indices and vertex\n * attributes for the CESIUM_primitive_outline extension.\n * <p>\n * To render outlines, a lookup texture is used 3 times, once per edge of a\n * triangle. In order to render correctly, all three vertices must agree on the\n * same ordering of the three edges when computing outline (texture)\n * coordinates. Sometimes this is not possible, as a vertex shared between\n * multiple triangles may become overly constrained. In such cases, vertices are\n * copied and indices are updated until valid outline coordinates can be\n * defined.\n * </p>\n *\n * @see {@link https://www.researchgate.net/publication/220067637_Fast_and_versatile_texture-based_wireframe_rendering|Fast and versatile texture-based wireframe rendering}\n *\n * @alias PrimitiveOutlineGenerator\n * @constructor\n *\n * @param {number} options Object with the following properties:\n * @param {Uint8Array|Uint16Array|Uint32Array} options.triangleIndices The original triangle indices of the primitive. The constructor takes ownership of this typed array as it will be modified internally. Use the updatedTriangleIndices getter to get the final result.\n * @param {number[]} options.outlineIndices The indices of edges in the triangle from the CESIUM_primitive_outline extension\n * @param {number} options.originalVertexCount The original number of vertices in the primitive\n * @example\n * // The constructor will compute the updated indices and generate outline\n * // coordinates.\n * const outlineGenerator = new PrimitiveOutlineGenerator({\n *   triangleIndices: primitive.indices.typedArray,\n *   outlineIndices: outlineIndices,\n *   originalVertexCount: primitive.attributes[0].count\n * });\n *\n * // Caller must update the indices (the data type may have been upgraded!)\n * primitive.indices.typedArray = outlineGenerator.updatedTriangleIndices;\n * primitive.indices.indexDatatype =\n *  IndexDatatype.fromTypedArray(primitive.indices.typedArray);\n *\n * // Create a new attribute for the generated outline coordinates\n * primitive.outlineCoordinates = new ModelComponents.Attribute();\n * // ... initialize as a vec3 attribute\n * primitive.outlineCoordinates.typedArray =\n *   outlineGenerator.outlineCoordinates;\n *\n * // Updating an attribute\n * const attribute = primitive.attributes[i];\n * attribute.typedArray = outlineGenerator.updateAttribute(\n *   attribute.typedArray\n * );\n *\n * @private\n */\nfunction PrimitiveOutlineGenerator(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const triangleIndices = options.triangleIndices;\n  const outlineIndices = options.outlineIndices;\n  const originalVertexCount = options.originalVertexCount;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.triangleIndices\", triangleIndices);\n  Check.typeOf.object(\"options.outlineIndices\", outlineIndices);\n  Check.typeOf.number(\"options.originalVertexCount\", originalVertexCount);\n  //>>includeEnd('debug');\n\n  /**\n   * The triangle indices. It will be modified in place.\n   *\n   * @type {Uint8Array|Uint16Array|Uint32Array}\n   *\n   * @private\n   */\n  this._triangleIndices = triangleIndices;\n\n  /**\n   * How many vertices were originally in the primitive\n   *\n   * @type {number}\n   *\n   * @private\n   */\n  this._originalVertexCount = originalVertexCount;\n\n  /**\n   * The outline indices represent edges of the primitive's triangle mesh where\n   * outlines must be drawn. This is stored as a hash set for efficient\n   * checks of whether an edge is present.\n   *\n   * @type {EdgeSet}\n   *\n   * @private\n   */\n  this._edges = new EdgeSet(outlineIndices, originalVertexCount);\n\n  /**\n   * The typed array that will store the outline texture coordinates\n   * once computed. This typed array should be turned into a vertex attribute\n   * when rendering outlines.\n   *\n   * @type {Float32Array}\n   *\n   * @private\n   */\n  this._outlineCoordinatesTypedArray = undefined;\n\n  /**\n   * Array containing the indices of any vertices that must be copied and\n   * appended to the list.\n   *\n   * @type {number[]}\n   *\n   * @private\n   */\n  this._extraVertices = [];\n\n  initialize(this);\n}\n\nObject.defineProperties(PrimitiveOutlineGenerator.prototype, {\n  /**\n   * The updated triangle indices after generating outlines. The caller is for\n   * responsible for updating the primitive's indices to use this array.\n   *\n   * @memberof PrimitiveOutlineGenerator.prototype\n   *\n   * @type {Uint8Array|Uint16Array|Uint32Array}\n   * @readonly\n   *\n   * @private\n   */\n  updatedTriangleIndices: {\n    get: function () {\n      return this._triangleIndices;\n    },\n  },\n\n  /**\n   * The computed outline coordinates. The caller is responsible for\n   * turning this into a vec3 attribute for rendering.\n   *\n   * @memberof PrimitiveOutlineGenerator.prototype\n   *\n   * @type {Float32Array}\n   * @readonly\n   *\n   * @private\n   */\n  outlineCoordinates: {\n    get: function () {\n      return this._outlineCoordinatesTypedArray;\n    },\n  },\n});\n\n/**\n * Initialize the outline generator from the CESIUM_primitive_outline\n * extension data. This updates the triangle indices and generates outline\n * coordinates, but does not update other attributes (see\n * {@link PrimitiveOutlineGenerator#updateAttribute})\n *\n * @param {PrimitiveOutlineGenerator} outlineGenerator The outline generator\n *\n * @private\n */\nfunction initialize(outlineGenerator) {\n  // triangle indices may be extended from 16-bits to 32 bits if needed.\n  let triangleIndices = outlineGenerator._triangleIndices;\n\n  const edges = outlineGenerator._edges;\n  const outlineCoordinates = [];\n  const extraVertices = outlineGenerator._extraVertices;\n  const vertexCount = outlineGenerator._originalVertexCount;\n\n  // Dictionary of unmatchable vertex index -> copied vertex index. This is\n  // used so we don't copy the same vertex more than necessary.\n  const vertexCopies = {};\n\n  // For each triangle, adjust vertex data so that the correct edges are outlined.\n  for (let i = 0; i < triangleIndices.length; i += 3) {\n    let i0 = triangleIndices[i];\n    let i1 = triangleIndices[i + 1];\n    let i2 = triangleIndices[i + 2];\n\n    // Check which edges need to be outlined based on the contents of the\n    // outline indices from the extension.\n    const all = false; // set this to true to draw a full wireframe.\n    const hasEdge01 = all || edges.hasEdge(i0, i1);\n    const hasEdge12 = all || edges.hasEdge(i1, i2);\n    const hasEdge20 = all || edges.hasEdge(i2, i0);\n\n    // Attempt to compute outline coordinates. If no consistent ordering of\n    // edges can be computed (due to constraints from adjacent faces), the\n    // first attempt may fail. In such cases, make a copy of a vertex and\n    // try again. This relaxes the constraints, so the while loop will\n    // eventually finish.\n    let unmatchableVertexIndex = matchAndStoreCoordinates(\n      outlineCoordinates,\n      i0,\n      i1,\n      i2,\n      hasEdge01,\n      hasEdge12,\n      hasEdge20,\n    );\n    while (defined(unmatchableVertexIndex)) {\n      // Copy the unmatchable index and try again.\n      let copy = vertexCopies[unmatchableVertexIndex];\n\n      // Only copy if we haven't already\n      if (!defined(copy)) {\n        // The new vertex will appear at the end of the vertex list\n        copy = vertexCount + extraVertices.length;\n\n        // Sometimes the copied vertex will in turn be a copy, so search\n        // for the original one\n        let original = unmatchableVertexIndex;\n        while (original >= vertexCount) {\n          original = extraVertices[original - vertexCount];\n        }\n\n        // Store the original vertex that needs to be copied\n        extraVertices.push(original);\n\n        // mark that we've seen this unmatchable vertex before so we don't\n        // copy it multiple times.\n        vertexCopies[unmatchableVertexIndex] = copy;\n      }\n\n      // Corner case: copying a vertex may overflow the range of an\n      // 8- or 16- bit index buffer, so upgrade to a larger data type.\n      if (\n        copy > MAX_GLTF_UINT16_INDEX &&\n        (triangleIndices instanceof Uint16Array ||\n          triangleIndices instanceof Uint8Array)\n      ) {\n        triangleIndices = new Uint32Array(triangleIndices);\n      } else if (\n        copy > MAX_GLTF_UINT8_INDEX &&\n        triangleIndices instanceof Uint8Array\n      ) {\n        triangleIndices = new Uint16Array(triangleIndices);\n      }\n\n      // Update the triangle indices buffer to use the copied vertex instead\n      // of the original one.\n      if (unmatchableVertexIndex === i0) {\n        i0 = copy;\n        triangleIndices[i] = copy;\n      } else if (unmatchableVertexIndex === i1) {\n        i1 = copy;\n        triangleIndices[i + 1] = copy;\n      } else {\n        i2 = copy;\n        triangleIndices[i + 2] = copy;\n      }\n\n      // Attempt to generate outline coordinates again. This is more likely\n      // to succeed since the copied vertex has no constraints on which order\n      // of the 3 edges to use.\n      unmatchableVertexIndex = matchAndStoreCoordinates(\n        outlineCoordinates,\n        i0,\n        i1,\n        i2,\n        hasEdge01,\n        hasEdge12,\n        hasEdge20,\n      );\n    }\n  }\n\n  // Store the triangle indices in case we had to expand to 32-bit indices\n  outlineGenerator._triangleIndices = triangleIndices;\n  outlineGenerator._outlineCoordinatesTypedArray = new Float32Array(\n    outlineCoordinates,\n  );\n}\n\n/**\n * This function attempts to compute a valid ordering of edges for this triangle\n * and if found, computes outline coordinates for the three vertices. If not\n * possible, one of the vertices is returned so it can be copied.\n *\n * @param {number[]} outlineCoordinates An array to store the computed outline coordinates. There are 3 components per vertex. This will be modified in place.\n * @param {number} i0 The index of the first vertex of the triangle.\n * @param {number} i1 The index of the second vertex of the triangle.\n * @param {number} i2 The index of the third vertex of the triangle.\n * @param {boolean} hasEdge01 Whether there is an outline edge between vertices 0 and 1 of the triangle\n * @param {boolean} hasEdge12 Whether there is an outline edge between vertices 1 and 2 of the triangle\n * @param {boolean} hasEdge20 Whether there is an outline edge between vertices 2 and 0 of the triangle\n * @returns {number} If it's not possible to compute consistent outline coordinates for this triangle, the index of the most constrained vertex of i0, i1 and i2 is returned. Otherwise, this function returns undefined to indicate a successful match.\n *\n * @private\n */\nfunction matchAndStoreCoordinates(\n  outlineCoordinates,\n  i0,\n  i1,\n  i2,\n  hasEdge01,\n  hasEdge12,\n  hasEdge20,\n) {\n  const a0 = hasEdge20 ? 1.0 : 0.0;\n  const b0 = hasEdge01 ? 1.0 : 0.0;\n  const c0 = 0.0;\n\n  const i0Mask = computeOrderMask(outlineCoordinates, i0, a0, b0, c0);\n  if (i0Mask === 0) {\n    return i0;\n  }\n\n  const a1 = 0.0;\n  const b1 = hasEdge01 ? 1.0 : 0.0;\n  const c1 = hasEdge12 ? 1.0 : 0.0;\n\n  const i1Mask = computeOrderMask(outlineCoordinates, i1, a1, b1, c1);\n  if (i1Mask === 0) {\n    return i1;\n  }\n\n  const a2 = hasEdge20 ? 1.0 : 0.0;\n  const b2 = 0.0;\n  const c2 = hasEdge12 ? 1.0 : 0.0;\n\n  const i2Mask = computeOrderMask(outlineCoordinates, i2, a2, b2, c2);\n  if (i2Mask === 0) {\n    return i2;\n  }\n\n  const workingOrders = i0Mask & i1Mask & i2Mask;\n\n  let a, b, c;\n\n  if (workingOrders & (1 << 0)) {\n    // 0 - abc\n    a = 0;\n    b = 1;\n    c = 2;\n  } else if (workingOrders & (1 << 1)) {\n    // 1 - acb\n    a = 0;\n    c = 1;\n    b = 2;\n  } else if (workingOrders & (1 << 2)) {\n    // 2 - bac\n    b = 0;\n    a = 1;\n    c = 2;\n  } else if (workingOrders & (1 << 3)) {\n    // 3 - bca\n    b = 0;\n    c = 1;\n    a = 2;\n  } else if (workingOrders & (1 << 4)) {\n    // 4 - cab\n    c = 0;\n    a = 1;\n    b = 2;\n  } else if (workingOrders & (1 << 5)) {\n    // 5 - cba\n    c = 0;\n    b = 1;\n    a = 2;\n  } else {\n    // No ordering works. Report the most constrained vertex (i.e. the one with\n    // fewest valid orderings) as unmatched so we copy that one.\n    const i0ValidOrderCount = popcount6Bit(i0Mask);\n    const i1ValidOrderCount = popcount6Bit(i1Mask);\n    const i2ValidOrderCount = popcount6Bit(i2Mask);\n    if (\n      i0ValidOrderCount < i1ValidOrderCount &&\n      i0ValidOrderCount < i2ValidOrderCount\n    ) {\n      return i0;\n    } else if (i1ValidOrderCount < i2ValidOrderCount) {\n      return i1;\n    }\n    return i2;\n  }\n\n  // We found a valid ordering of the edges, so store the outline coordinates\n  // for this triangle.\n  const i0Start = i0 * 3;\n  outlineCoordinates[i0Start + a] = a0;\n  outlineCoordinates[i0Start + b] = b0;\n  outlineCoordinates[i0Start + c] = c0;\n\n  const i1Start = i1 * 3;\n  outlineCoordinates[i1Start + a] = a1;\n  outlineCoordinates[i1Start + b] = b1;\n  outlineCoordinates[i1Start + c] = c1;\n\n  const i2Start = i2 * 3;\n  outlineCoordinates[i2Start + a] = a2;\n  outlineCoordinates[i2Start + b] = b2;\n  outlineCoordinates[i2Start + c] = c2;\n\n  // successful match\n  return undefined;\n}\n\n/**\n * Each vertex has three coordinates, a, b, and c.\n * a is the coordinate that applies to edge 2-0 for the vertex.\n * b is the coordinate that applies to edge 0-1 for the vertex.\n * c is the coordinate that applies to edge 1-2 for the vertex.\n *\n * A single triangle with all edges highlighted:\n *\n *                 | a | b | c |\n *                 | 1 | 1 | 0 |\n *                       0\n *                      / \\\n *                     /   \\\n *           edge 0-1 /     \\ edge 2-0\n *                   /       \\\n *                  /         \\\n * | a | b | c |   1-----------2   | a | b | c |\n * | 0 | 1 | 1 |     edge 1-2      | 1 | 0 | 1 |\n *\n * There are 6 possible orderings of coordinates a, b, and c:\n * 0 - abc\n * 1 - acb\n * 2 - bac\n * 3 - bca\n * 4 - cab\n * 5 - cba\n *\n * All vertices must use the _same ordering_ for the edges to be rendered\n * correctly. So we compute a bitmask for each vertex, where the bit at\n * each position indicates whether that ordering works (i.e. doesn't\n * conflict with already-assigned coordinates) for that vertex.\n *\n * Then we can find an ordering that works for all three vertices with a\n * bitwise AND.\n *\n * @param {number[]} outlineCoordinates The array of outline coordinates\n * @param {number} vertexIndex The index of the vertex to compute the mask for\n * @param {number} a The outline coordinate for edge 2-0\n * @param {number} b The outline coordinate for edge 0-1\n * @param {number} c The outline coordinate for edge 1-2\n * @returns {number} A bitmask with 6 bits where a 1 indicates the corresponding ordering is valid.\n *\n * @private\n */\nfunction computeOrderMask(outlineCoordinates, vertexIndex, a, b, c) {\n  const startIndex = vertexIndex * 3;\n  const first = outlineCoordinates[startIndex];\n  const second = outlineCoordinates[startIndex + 1];\n  const third = outlineCoordinates[startIndex + 2];\n\n  // If one coordinate is undefined, they all are since matchAndStoreCoordinates sets\n  // all 3 components at once. In this case, all orderings are fine.\n  if (!defined(first)) {\n    return 0b111111;\n  }\n\n  return (\n    ((first === a && second === b && third === c) << 0) |\n    ((first === a && second === c && third === b) << 1) |\n    ((first === b && second === a && third === c) << 2) |\n    ((first === b && second === c && third === a) << 3) |\n    ((first === c && second === a && third === b) << 4) |\n    ((first === c && second === b && third === a) << 5)\n  );\n}\n\n/**\n * Compute the popcount for 6-bit integers (values 0-63). This is the\n * number of 1s in the binary representation of the value.\n *\n * @param {number} value The value to compute the popcount for\n * @returns {number} The number of 1s in the binary representation of value\n *\n * @private\n */\nfunction popcount6Bit(value) {\n  return (\n    (value & 1) +\n    ((value >> 1) & 1) +\n    ((value >> 2) & 1) +\n    ((value >> 3) & 1) +\n    ((value >> 4) & 1) +\n    ((value >> 5) & 1)\n  );\n}\n\n/**\n * After computing the outline coordinates, some vertices may need to be\n * copied and appended to the end of the list of vertices. This function updates\n * a typed array for a single attribute (e.g. POSITION or NORMAL).\n *\n * @param {Uint8Array|Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array} attributeTypedArray The attribute values to update. This function takes ownership of this typed array\n * @returns {Uint8Array|Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array} A new typed array that contains the existing attribute values, plus any copied values at the end.\n *\n * @private\n */\nPrimitiveOutlineGenerator.prototype.updateAttribute = function (\n  attributeTypedArray,\n) {\n  const extraVertices = this._extraVertices;\n\n  const originalLength = attributeTypedArray.length;\n\n  // This is a stride in number of typed elements. For example, a VEC3 would\n  // have a stride of 3 (floats)\n  const stride = originalLength / this._originalVertexCount;\n\n  const extraVerticesLength = extraVertices.length;\n\n  // Make a larger typed array of the same type as the input\n  const ArrayType = attributeTypedArray.constructor;\n  const result = new ArrayType(\n    attributeTypedArray.length + extraVerticesLength * stride,\n  );\n\n  // Copy original vertices\n  result.set(attributeTypedArray);\n\n  // Copy the vertices added for outlining\n  for (let i = 0; i < extraVerticesLength; i++) {\n    const sourceIndex = extraVertices[i] * stride;\n    const resultIndex = originalLength + i * stride;\n    for (let j = 0; j < stride; j++) {\n      result[resultIndex + j] = result[sourceIndex + j];\n    }\n  }\n\n  return result;\n};\n\n/**\n * Create a mip-mapped lookup texture for rendering outlines. The texture is\n * constant, so it is cached on the context.\n *\n * @param {Context} context The context to use for creating the texture\n * @returns {Texture} The outline lookup texture.\n *\n * @private\n */\nPrimitiveOutlineGenerator.createTexture = function (context) {\n  let cache = context.cache.modelOutliningCache;\n  if (!defined(cache)) {\n    cache = context.cache.modelOutliningCache = {};\n  }\n\n  if (defined(cache.outlineTexture)) {\n    return cache.outlineTexture;\n  }\n\n  const maxSize = Math.min(4096, ContextLimits.maximumTextureSize);\n\n  let size = maxSize;\n  const levelZero = createMipLevel(size);\n\n  const mipLevels = [];\n\n  while (size > 1) {\n    size >>= 1;\n    mipLevels.push(createMipLevel(size));\n  }\n\n  const texture = new Texture({\n    context: context,\n    source: {\n      arrayBufferView: levelZero,\n      mipLevels: mipLevels,\n    },\n    width: maxSize,\n    height: 1,\n    pixelFormat: PixelFormat.LUMINANCE,\n    sampler: new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR_MIPMAP_LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR,\n    }),\n  });\n\n  cache.outlineTexture = texture;\n\n  return texture;\n};\n\n/**\n * Create an outline lookup texture for a single mip level. This is a texture of\n * mostly 0 values, except for the last value which is brighter to indicate\n * the outline.\n *\n * @param {number} size The width of the texture for this mip level\n * @returns {Uint8Array} A typed array containing the texels of the mip level\n *\n * @private\n */\nfunction createMipLevel(size) {\n  const texture = new Uint8Array(size);\n\n  // This lookup texture creates an outline with width 0.75 px in screen space.\n  texture[size - 1] = 192;\n\n  // As we reach the top of the mip pyramid, a single set pixel becomes a\n  // significant portion of the texture. This doesn't look great when zoomed\n  // out, so attenuate the value by 50% at each level.\n  if (size === 8) {\n    texture[size - 1] = 96;\n  } else if (size === 4) {\n    texture[size - 1] = 48;\n  } else if (size === 2) {\n    texture[size - 1] = 24;\n  } else if (size === 1) {\n    texture[size - 1] = 12;\n  }\n  return texture;\n}\n\n/**\n * A hash set that provides quick lookups of whether an edge exists between\n * two vertices.\n *\n * @alias EdgeSet\n * @constructor\n *\n * @param {number[]} edgeIndices An array of vertex indices with an even number of elements where each pair of indices defines an edge.\n * @param {number} originalVertexCount The original number of vertices. This is used for computing a hash function.\n *\n * @private\n */\nfunction EdgeSet(edgeIndices, originalVertexCount) {\n  /**\n   * Original number of vertices in the primitive. This is used for computing\n   * the hash key\n   *\n   * @type {number}\n   *\n   * @private\n   */\n  this._originalVertexCount = originalVertexCount;\n\n  /**\n   * The internal hash set used to store the edges. Edges are hashed as follows:\n   * <p>\n   * smallerVertexIndex * originalVertexCount + biggerVertexIndex\n   * <p>\n   * @type {Set}\n   *\n   * @private\n   */\n  this._edges = new Set();\n  for (let i = 0; i < edgeIndices.length; i += 2) {\n    const a = edgeIndices[i];\n    const b = edgeIndices[i + 1];\n    const small = Math.min(a, b);\n    const big = Math.max(a, b);\n    const hash = small * this._originalVertexCount + big;\n    this._edges.add(hash);\n  }\n}\n\n/**\n * Check if an edge exists in the set. The order of the input vertices does\n * not matter.\n * @param {number} a The first index\n * @param {number} b The second index\n * @returns {boolean} true if there is an edge between a and b\n *\n * @private\n */\nEdgeSet.prototype.hasEdge = function (a, b) {\n  const small = Math.min(a, b);\n  const big = Math.max(a, b);\n  const hash = small * this._originalVertexCount + big;\n  return this._edges.has(hash);\n};\n\nexport default PrimitiveOutlineGenerator;\n"],"names":["MAX_GLTF_UINT16_INDEX","MAX_GLTF_UINT8_INDEX","PrimitiveOutlineGenerator","options","EMPTY_OBJECT","triangleIndices","outlineIndices","originalVertexCount","typeOf","object","number","_triangleIndices","_originalVertexCount","_edges","EdgeSet","_outlineCoordinatesTypedArray","undefined","_extraVertices","initialize","Object","defineProperties","prototype","updatedTriangleIndices","get","outlineCoordinates","outlineGenerator","edges","extraVertices","vertexCount","vertexCopies","i","length","i0","i1","i2","all","hasEdge01","hasEdge","hasEdge12","hasEdge20","unmatchableVertexIndex","matchAndStoreCoordinates","copy","original","push","Uint16Array","Uint8Array","Uint32Array","Float32Array","a0","b0","c0","i0Mask","computeOrderMask","a1","b1","c1","i1Mask","a2","b2","c2","i2Mask","workingOrders","a","b","c","i0ValidOrderCount","popcount6Bit","i1ValidOrderCount","i2ValidOrderCount","i0Start","i1Start","i2Start","vertexIndex","startIndex","first","second","third","value","updateAttribute","attributeTypedArray","originalLength","stride","extraVerticesLength","ArrayType","result","set","sourceIndex","resultIndex","j","createTexture","context","cache","modelOutliningCache","outlineTexture","maxSize","Math","min","maximumTextureSize","size","levelZero","createMipLevel","mipLevels","texture","source","arrayBufferView","width","height","pixelFormat","LUMINANCE","sampler","wrapS","CLAMP_TO_EDGE","wrapT","minificationFilter","LINEAR_MIPMAP_LINEAR","magnificationFilter","LINEAR","edgeIndices","Set","small","big","max","hash","add","has"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 911, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/Extensions/Gpm/AnchorPointDirect.js"],"sourcesContent":["import Check from \"../../../../Core/Check.js\";\n\n/**\n * @typedef {object} AnchorPointDirect.ConstructorOptions\n *\n * Initialization options for the AnchorPointDirect constructor\n *\n * @property {Cartesian3} position  Anchor point geographic coordinates\n * @property {Cartesian3} adjustmentParams The adjustment values in meters\n */\n\n/**\n * Metadata for one stored anchor point using direct storage.\n *\n * This reflects the `anchronPointDirect` definition of the\n * {@link https://nsgreg.nga.mil/csmwg.jsp|NGA_gpm_local} glTF extension.\n *\n * @constructor\n * @param {AnchorPointDirect.ConstructorOptions} options An object describing initialization options\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction AnchorPointDirect(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.position\", options.position);\n  Check.typeOf.object(\"options.adjustmentParams\", options.adjustmentParams);\n  //>>includeEnd('debug');\n\n  this._position = options.position;\n  this._adjustmentParams = options.adjustmentParams;\n}\n\nObject.defineProperties(AnchorPointDirect.prototype, {\n  /**\n   * Anchor point geographic coordinates in meters as X/Easting, Y/Northing, Z/HAE\n   *\n   * @memberof AnchorPointDirect.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  position: {\n    get: function () {\n      return this._position;\n    },\n  },\n\n  /**\n   * The delta-x delta-y delta-z adjustment values in meters per anchor\n   * point.\n   *\n   * @memberof AnchorPointDirect.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  adjustmentParams: {\n    get: function () {\n      return this._adjustmentParams;\n    },\n  },\n});\n\nexport default AnchorPointDirect;\n"],"names":["AnchorPointDirect","options","typeOf","object","position","adjustmentParams","_position","_adjustmentParams","Object","defineProperties","prototype","get"],"mappings":";;;;AAAA;;AAEA;;;;;;;CAOC,GAED;;;;;;;;;CASC,GACD,SAASA,kBAAkBC,OAAO;IAChC,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,oBAAoBF,QAAQG,QAAQ;IACxD,2KAAK,CAACF,MAAM,CAACC,MAAM,CAAC,4BAA4BF,QAAQI,gBAAgB;IACxE,wBAAwB;IAExB,IAAI,CAACC,SAAS,GAAGL,QAAQG,QAAQ;IACjC,IAAI,CAACG,iBAAiB,GAAGN,QAAQI,gBAAgB;AACnD;AAEAG,OAAOC,gBAAgB,CAACT,kBAAkBU,SAAS,EAAE;IACnD;;;;;;GAMC,GACDN,UAAU;QACRO,KAAK;YACH,OAAO,IAAI,CAACL,SAAS;QACvB;IACF;IAEA;;;;;;;GAOC,GACDD,kBAAkB;QAChBM,KAAK;YACH,OAAO,IAAI,CAACJ,iBAAiB;QAC/B;IACF;AACF;uCAEeP","ignoreList":[0]}},
    {"offset": {"line": 971, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/Extensions/Gpm/AnchorPointIndirect.js"],"sourcesContent":["import Check from \"../../../../Core/Check.js\";\n\n/**\n * @typedef {object} AnchorPointIndirect.ConstructorOptions\n *\n * Initialization options for the AnchorPointIndirect constructor\n *\n * @property {Cartesian3} position  Anchor point geographic coordinates\n * @property {Cartesian3} adjustmentParams The adjustment values in meters\n * @property {Matrix3} covarianceMatrix The 3x3 covariance matrix\n */\n\n/**\n * Metadata for one stored anchor point.\n *\n * This reflects the `anchronPointIndirect` definition of the\n * {@link https://nsgreg.nga.mil/csmwg.jsp|NGA_gpm_local} glTF extension.\n *\n * @constructor\n * @param {AnchorPointIndirect.ConstructorOptions} options An object describing initialization options\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction AnchorPointIndirect(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.position\", options.position);\n  Check.typeOf.object(\"options.adjustmentParams\", options.adjustmentParams);\n  Check.typeOf.object(\"options.covarianceMatrix\", options.covarianceMatrix);\n  //>>includeEnd('debug');\n\n  this._position = options.position;\n  this._adjustmentParams = options.adjustmentParams;\n  this._covarianceMatrix = options.covarianceMatrix;\n}\n\nObject.defineProperties(AnchorPointIndirect.prototype, {\n  /**\n   * Anchor point geographic coordinates in meters as X/Easting, Y/Northing, Z/HAE\n   *\n   * @memberof AnchorPointIndirect.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  position: {\n    get: function () {\n      return this._position;\n    },\n  },\n\n  /**\n   * The delta-x delta-y delta-z adjustment values in meters per anchor\n   * point.\n   *\n   * @memberof AnchorPointIndirect.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  adjustmentParams: {\n    get: function () {\n      return this._adjustmentParams;\n    },\n  },\n\n  /**\n   * The 3x3 covariance matrix.\n   *\n   * @memberof AnchorPointIndirect.prototype\n   * @type {Matrix3}\n   * @readonly\n   */\n  covarianceMatrix: {\n    get: function () {\n      return this._covarianceMatrix;\n    },\n  },\n});\n\nexport default AnchorPointIndirect;\n"],"names":["AnchorPointIndirect","options","typeOf","object","position","adjustmentParams","covarianceMatrix","_position","_adjustmentParams","_covarianceMatrix","Object","defineProperties","prototype","get"],"mappings":";;;;AAAA;;AAEA;;;;;;;;CAQC,GAED;;;;;;;;;CASC,GACD,SAASA,oBAAoBC,OAAO;IAClC,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,oBAAoBF,QAAQG,QAAQ;IACxD,2KAAK,CAACF,MAAM,CAACC,MAAM,CAAC,4BAA4BF,QAAQI,gBAAgB;IACxE,2KAAK,CAACH,MAAM,CAACC,MAAM,CAAC,4BAA4BF,QAAQK,gBAAgB;IACxE,wBAAwB;IAExB,IAAI,CAACC,SAAS,GAAGN,QAAQG,QAAQ;IACjC,IAAI,CAACI,iBAAiB,GAAGP,QAAQI,gBAAgB;IACjD,IAAI,CAACI,iBAAiB,GAAGR,QAAQK,gBAAgB;AACnD;AAEAI,OAAOC,gBAAgB,CAACX,oBAAoBY,SAAS,EAAE;IACrD;;;;;;GAMC,GACDR,UAAU;QACRS,KAAK;YACH,OAAO,IAAI,CAACN,SAAS;QACvB;IACF;IAEA;;;;;;;GAOC,GACDF,kBAAkB;QAChBQ,KAAK;YACH,OAAO,IAAI,CAACL,iBAAiB;QAC/B;IACF;IAEA;;;;;;GAMC,GACDF,kBAAkB;QAChBO,KAAK;YACH,OAAO,IAAI,CAACJ,iBAAiB;QAC/B;IACF;AACF;uCAEeT","ignoreList":[0]}},
    {"offset": {"line": 1045, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/Extensions/Gpm/CorrelationGroup.js"],"sourcesContent":["import Check from \"../../../../Core/Check.js\";\n\n/**\n * @typedef {object} CorrelationGroup.ConstructorOptions\n *\n * Initialization options for the CorrelationGroup constructor\n *\n * @property {boolean[]} groupFlags Array of 3 booleans indicating if\n * parameters delta-x delta-y delta-z used in the correlation group\n * @property {Cartesian3} rotationThetas Rotations in milliradians\n * about X, Y, Z axes, respectively\n * @property {Spdcf[]} params Array of `Spdcf` (Strictly Positive-Definite\n * Correlation Function) parameters, for the U, V, W directions, respectively\n */\n\n/**\n * Metadata identifying parameters using same correlation modeling and\n * associated correlation parameters.\n *\n * This reflects the `correlationGroup` definition of the\n * {@link https://nsgreg.nga.mil/csmwg.jsp|NGA_gpm_local} glTF extension.\n *\n * @constructor\n * @param {CorrelationGroup.ConstructorOptions} options An object describing initialization options\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction CorrelationGroup(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.groupFlags\", options.groupFlags);\n  Check.typeOf.object(\"options.rotationThetas\", options.rotationThetas);\n  Check.typeOf.object(\"options.params\", options.params);\n  //>>includeEnd('debug');\n\n  this._groupFlags = options.groupFlags;\n  this._rotationThetas = options.rotationThetas;\n  this._params = options.params;\n}\n\nObject.defineProperties(CorrelationGroup.prototype, {\n  /**\n   * Array of 3 booleans indicating if parameters delta-x delta-y delta-z\n   * used in the correlation group\n   *\n   * @memberof CorrelationGroup.prototype\n   * @type {boolean[]}\n   * @readonly\n   */\n  groupFlags: {\n    get: function () {\n      return this._groupFlags;\n    },\n  },\n\n  /**\n   * Rotations in milliradians about X, Y, Z axes, respectively\n   *\n   * @memberof CorrelationGroup.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  rotationThetas: {\n    get: function () {\n      return this._rotationThetas;\n    },\n  },\n\n  /**\n   * Array of 3 sets of SPDCF parameters, for the U, V, W directions, respectively\n   *\n   * @memberof CorrelationGroup.prototype\n   * @type {Spdcf[]}\n   * @readonly\n   */\n  params: {\n    get: function () {\n      return this._params;\n    },\n  },\n});\n\nexport default CorrelationGroup;\n"],"names":["CorrelationGroup","options","typeOf","object","groupFlags","rotationThetas","params","_groupFlags","_rotationThetas","_params","Object","defineProperties","prototype","get"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;;;CAWC,GAED;;;;;;;;;;CAUC,GACD,SAASA,iBAAiBC,OAAO;IAC/B,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,sBAAsBF,QAAQG,UAAU;IAC5D,2KAAK,CAACF,MAAM,CAACC,MAAM,CAAC,0BAA0BF,QAAQI,cAAc;IACpE,2KAAK,CAACH,MAAM,CAACC,MAAM,CAAC,kBAAkBF,QAAQK,MAAM;IACpD,wBAAwB;IAExB,IAAI,CAACC,WAAW,GAAGN,QAAQG,UAAU;IACrC,IAAI,CAACI,eAAe,GAAGP,QAAQI,cAAc;IAC7C,IAAI,CAACI,OAAO,GAAGR,QAAQK,MAAM;AAC/B;AAEAI,OAAOC,gBAAgB,CAACX,iBAAiBY,SAAS,EAAE;IAClD;;;;;;;GAOC,GACDR,YAAY;QACVS,KAAK;YACH,OAAO,IAAI,CAACN,WAAW;QACzB;IACF;IAEA;;;;;;GAMC,GACDF,gBAAgB;QACdQ,KAAK;YACH,OAAO,IAAI,CAACL,eAAe;QAC7B;IACF;IAEA;;;;;;GAMC,GACDF,QAAQ;QACNO,KAAK;YACH,OAAO,IAAI,CAACJ,OAAO;QACrB;IACF;AACF;uCAEeT","ignoreList":[0]}},
    {"offset": {"line": 1123, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/Extensions/Gpm/StorageType.js"],"sourcesContent":["/**\n * An enum of storage types for covariance information.\n *\n * This reflects the `gltfGpmLocal.storageType` definition of the\n * {@link https://nsgreg.nga.mil/csmwg.jsp|NGA_gpm_local} glTF extension.\n *\n * @enum {string}\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst StorageType = {\n  /**\n   * Store the full error covariance of the anchor points, to include the cross-covariance terms\n   *\n   * @type {string}\n   * @constant\n   */\n  Direct: \"Direct\",\n\n  /**\n   * A full covariance matrix is stored for each of the anchor points. However, in this case the\n   * cross-covariance terms are not directly stored, but can be computed by a set of spatial\n   * correlation function parameters which are stored in the metadata.\n   *\n   * @type {string}\n   * @constant\n   */\n  Indirect: \"Indirect\",\n};\n\nexport default Object.freeze(StorageType);\n"],"names":["StorageType","Direct","Indirect","Object","freeze"],"mappings":";;;;AAAA;;;;;;;;CAQC,GACD,MAAMA,cAAc;IAClB;;;;;GAKC,GACDC,QAAQ;IAER;;;;;;;GAOC,GACDC,UAAU;AACZ;uCAEeC,OAAOC,MAAM,CAACJ","ignoreList":[0]}},
    {"offset": {"line": 1156, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/Extensions/Gpm/GltfGpmLocal.js"],"sourcesContent":["import defined from \"../../../../Core/defined.js\";\nimport Check from \"../../../../Core/Check.js\";\nimport RuntimeError from \"../../../../Core/RuntimeError.js\";\nimport StorageType from \"./StorageType.js\";\n\n/**\n * @typedef {object} GltfGpmLocal.ConstructorOptions\n *\n * Initialization options for the GltfGpmLocal constructor\n *\n * @property {string} storageType The storage type.\n * This must be one of the `StorageType` constants, i.e. `Direct` or `Indirect`.\n * @property {AnchorPointIndirect[]|undefined} [anchorPointsIndirect] The indirect anchor points.\n * This must be present if and only if the storage type is `Indirect`.\n * @property {CorrelationGroup[]|undefined} [intraTileCorrelationGroups] The intra-tile correlation groups.\n * This must be present if and only if the storage type is `Indirect`.\n * @property {AnchorPointDirect[]|undefined} [anchorPointsDirect] The direct anchor points.\n * This must be present if and only if the storage type is `Direct`.\n * @property {Matrix3|undefined} [covarianceDirect] The covariance of anchor point parameters.\n * This must be present if and only if the storage type is `Direct`.\n */\n\n/**\n * The GPM metadata for a Ground-Space Indirect implementation stored\n * locally (i.e. a tile and/or leaf node).\n *\n * This reflects the root extension object of the {@link https://nsgreg.nga.mil/csmwg.jsp|NGA_gpm_local}\n * glTF extension. When a model that contains this extension was loaded,\n * then an object of this type can be obtained by calling\n * ```\n * const gltfGpmLocal = model.getExtension(\"NGA_gpm_local\");\n * ```\n *\n * The storage type determines the presence of the optional properties:\n * <ul>\n *  <li>\n *   When the storage type is `StorageType.Indirect`, then the\n *   `anchorPointsIndirect` and `intraTileCorrelationGroups`\n *   are present.\n *  </li>\n *  <li>\n *   When the storage type is `StorageType.Direct`, then the\n *   `anchorPointsDirect` and `covarianceDirect` are present.\n *  </li>\n * </ul>\n *\n * @constructor\n * @param {GltfGpmLocal.ConstructorOptions} options An object describing initialization options\n *\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction GltfGpmLocal(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.storageType\", options.storageType);\n  //>>includeEnd('debug');\n\n  this._storageType = options.storageType;\n  this._anchorPointsIndirect = options.anchorPointsIndirect;\n  this._anchorPointsDirect = options.anchorPointsDirect;\n  this._intraTileCorrelationGroups = options.intraTileCorrelationGroups;\n  this._covarianceDirect = options.covarianceDirect;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (this.storageType === StorageType.Indirect) {\n    if (!defined(this.anchorPointsIndirect)) {\n      throw new RuntimeError(\n        \"The anchorPointsIndirect are required for 'Indirect' storage\",\n      );\n    }\n    if (!defined(this.intraTileCorrelationGroups)) {\n      throw new RuntimeError(\n        \"The intraTileCorrelationGroups are required for 'Indirect' storage\",\n      );\n    }\n    if (defined(this.anchorPointsDirect)) {\n      throw new RuntimeError(\n        \"The anchorPointsDirect must be omitted for 'Indirect' storage\",\n      );\n    }\n    if (defined(this.covarianceDirect)) {\n      throw new RuntimeError(\n        \"The covarianceDirect must be omitted for 'Indirect' storage\",\n      );\n    }\n  } else {\n    // Direct storage\n    if (!defined(this.anchorPointsDirect)) {\n      throw new RuntimeError(\n        \"The anchorPointsDirect are required for 'Direct' storage\",\n      );\n    }\n    if (!defined(this.covarianceDirect)) {\n      throw new RuntimeError(\n        \"The covarianceDirect is required for 'Direct' storage\",\n      );\n    }\n    if (defined(this.anchorPointsIndirect)) {\n      throw new RuntimeError(\n        \"The anchorPointsIndirect must be omitted for 'Direct' storage\",\n      );\n    }\n    if (defined(this.intraTileCorrelationGroups)) {\n      throw new RuntimeError(\n        \"The intraTileCorrelationGroups must be omitted for 'Direct' storage\",\n      );\n    }\n  }\n  //>>includeEnd('debug');\n}\n\nObject.defineProperties(GltfGpmLocal.prototype, {\n  /**\n   * Specifies if covariance storage is indirect or direct.\n   *\n   * @memberof GltfGpmLocal.prototype\n   * @type {StorageType}\n   * @readonly\n   */\n  storageType: {\n    get: function () {\n      return this._storageType;\n    },\n  },\n\n  /**\n   * Array of stored indirect anchor points\n   *\n   * @memberof GltfGpmLocal.prototype\n   * @type {AnchorPointIndirect[]|undefined}\n   * @readonly\n   */\n  anchorPointsIndirect: {\n    get: function () {\n      return this._anchorPointsIndirect;\n    },\n  },\n\n  /**\n   * Array of stored direct anchor points\n   *\n   * @memberof GltfGpmLocal.prototype\n   * @type {AnchorPointDirect[]|undefined}\n   * @readonly\n   */\n  anchorPointsDirect: {\n    get: function () {\n      return this._anchorPointsDirect;\n    },\n  },\n\n  /**\n   * Metadata identifying parameters using same correlation modeling and\n   * associated correlation parameters\n   *\n   * @memberof GltfGpmLocal.prototype\n   * @type {CorrelationGroup[]|undefined}\n   * @readonly\n   */\n  intraTileCorrelationGroups: {\n    get: function () {\n      return this._intraTileCorrelationGroups;\n    },\n  },\n\n  /**\n   * The full covariance of anchor point parameters\n   *\n   * @memberof GltfGpmLocal.prototype\n   * @type {Matrix3|undefined}\n   * @readonly\n   */\n  covarianceDirect: {\n    get: function () {\n      return this._covarianceDirect;\n    },\n  },\n});\n\nexport default GltfGpmLocal;\n"],"names":["GltfGpmLocal","options","typeOf","string","storageType","_storageType","_anchorPointsIndirect","anchorPointsIndirect","_anchorPointsDirect","anchorPointsDirect","_intraTileCorrelationGroups","intraTileCorrelationGroups","_covarianceDirect","covarianceDirect","Indirect","Object","defineProperties","prototype","get"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;;;;;;;;;;;;;CAeC,GAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BC,GACD,SAASA,aAAaC,OAAO;IAC3B,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,uBAAuBF,QAAQG,WAAW;IAC9D,wBAAwB;IAExB,IAAI,CAACC,YAAY,GAAGJ,QAAQG,WAAW;IACvC,IAAI,CAACE,qBAAqB,GAAGL,QAAQM,oBAAoB;IACzD,IAAI,CAACC,mBAAmB,GAAGP,QAAQQ,kBAAkB;IACrD,IAAI,CAACC,2BAA2B,GAAGT,QAAQU,0BAA0B;IACrE,IAAI,CAACC,iBAAiB,GAAGX,QAAQY,gBAAgB;IAEjD,yCAAyC;IACzC,IAAI,IAAI,CAACT,WAAW,KAAK,gNAAW,CAACU,QAAQ,EAAE;QAC7C,IAAI,CAAC,IAAA,6KAAO,EAAC,IAAI,CAACP,oBAAoB,GAAG;YACvC,MAAM,IAAI,kLAAY,CACpB;QAEJ;QACA,IAAI,CAAC,IAAA,6KAAO,EAAC,IAAI,CAACI,0BAA0B,GAAG;YAC7C,MAAM,IAAI,kLAAY,CACpB;QAEJ;QACA,IAAI,IAAA,6KAAO,EAAC,IAAI,CAACF,kBAAkB,GAAG;YACpC,MAAM,IAAI,kLAAY,CACpB;QAEJ;QACA,IAAI,IAAA,6KAAO,EAAC,IAAI,CAACI,gBAAgB,GAAG;YAClC,MAAM,IAAI,kLAAY,CACpB;QAEJ;IACF,OAAO;QACL,iBAAiB;QACjB,IAAI,CAAC,IAAA,6KAAO,EAAC,IAAI,CAACJ,kBAAkB,GAAG;YACrC,MAAM,IAAI,kLAAY,CACpB;QAEJ;QACA,IAAI,CAAC,IAAA,6KAAO,EAAC,IAAI,CAACI,gBAAgB,GAAG;YACnC,MAAM,IAAI,kLAAY,CACpB;QAEJ;QACA,IAAI,IAAA,6KAAO,EAAC,IAAI,CAACN,oBAAoB,GAAG;YACtC,MAAM,IAAI,kLAAY,CACpB;QAEJ;QACA,IAAI,IAAA,6KAAO,EAAC,IAAI,CAACI,0BAA0B,GAAG;YAC5C,MAAM,IAAI,kLAAY,CACpB;QAEJ;IACF;AACA,wBAAwB;AAC1B;AAEAI,OAAOC,gBAAgB,CAAChB,aAAaiB,SAAS,EAAE;IAC9C;;;;;;GAMC,GACDb,aAAa;QACXc,KAAK;YACH,OAAO,IAAI,CAACb,YAAY;QAC1B;IACF;IAEA;;;;;;GAMC,GACDE,sBAAsB;QACpBW,KAAK;YACH,OAAO,IAAI,CAACZ,qBAAqB;QACnC;IACF;IAEA;;;;;;GAMC,GACDG,oBAAoB;QAClBS,KAAK;YACH,OAAO,IAAI,CAACV,mBAAmB;QACjC;IACF;IAEA;;;;;;;GAOC,GACDG,4BAA4B;QAC1BO,KAAK;YACH,OAAO,IAAI,CAACR,2BAA2B;QACzC;IACF;IAEA;;;;;;GAMC,GACDG,kBAAkB;QAChBK,KAAK;YACH,OAAO,IAAI,CAACN,iBAAiB;QAC/B;IACF;AACF;uCAEeZ","ignoreList":[0]}},
    {"offset": {"line": 1314, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/Extensions/Gpm/Spdcf.js"],"sourcesContent":["import Check from \"../../../../Core/Check.js\";\n\n/**\n * @typedef {object} Spdcf.ConstructorOptions\n *\n * Initialization options for the Spdcf constructor\n *\n * @property {number} A The factor A, in (0, 1]\n * @property {number} alpha The alpha value, in [0, 1)\n * @property {number} beta The beta value, in [0, 10]\n * @property {number} T the tau value, in (0, +inf)\n */\n\n/**\n * Variables for a Strictly Positive-Definite Correlation Function.\n *\n * This reflects the `spdcf` definition of the\n * {@link https://nsgreg.nga.mil/csmwg.jsp|NGA_gpm_local} glTF extension.\n * Instances of this type are stored as the parameters within a\n * `CorrelationGroup`.\n *\n * Parameters (A, alpha, beta, T) describe the correlation decrease\n * between points as a function of delta time:\n * ```\n * spdcf(delta_t) = A_t * (alpha_t + ((1 - alpha_t)(1 + beta_t)) / (beta_t + e^(delta_t/T_t)))\n * ```\n *\n * @constructor\n * @param {Spdcf.ConstructorOptions} options An object describing initialization options\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction Spdcf(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThan(\"options.A\", options.A, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\"options.A\", options.A, 1.0);\n  Check.typeOf.number.greaterThanOrEquals(\"options.alpha\", options.alpha, 0.0);\n  Check.typeOf.number.lessThan(\"options.alpha\", options.alpha, 1.0);\n  Check.typeOf.number.greaterThanOrEquals(\"options.beta\", options.beta, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\"options.beta\", options.beta, 10.0);\n  Check.typeOf.number.greaterThan(\"options.T\", options.T, 0.0);\n  //>>includeEnd('debug');\n\n  this._A = options.A;\n  this._alpha = options.alpha;\n  this._beta = options.beta;\n  this._T = options.T;\n}\n\nObject.defineProperties(Spdcf.prototype, {\n  /**\n   * In (0, 1]\n   *\n   * @memberof Spdcf.prototype\n   * @type {number}\n   * @readonly\n   */\n  A: {\n    get: function () {\n      return this._A;\n    },\n  },\n\n  /**\n   * In [0, 1)\n   *\n   * @memberof Spdcf.prototype\n   * @type {number}\n   * @readonly\n   */\n  alpha: {\n    get: function () {\n      return this._alpha;\n    },\n  },\n\n  /**\n   * In [0, 10]\n   *\n   * @memberof Spdcf.prototype\n   * @type {number}\n   * @readonly\n   */\n  beta: {\n    get: function () {\n      return this._beta;\n    },\n  },\n\n  /**\n   * In (0, +inf)\n   *\n   * @memberof Spdcf.prototype\n   * @type {number}\n   * @readonly\n   */\n  T: {\n    get: function () {\n      return this._T;\n    },\n  },\n});\n\nexport default Spdcf;\n"],"names":["Spdcf","options","typeOf","number","greaterThan","A","lessThanOrEquals","greaterThanOrEquals","alpha","lessThan","beta","T","_A","_alpha","_beta","_T","Object","defineProperties","prototype","get"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;CASC,GAED;;;;;;;;;;;;;;;;;CAiBC,GACD,SAASA,MAAMC,OAAO;IACpB,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAACC,WAAW,CAAC,aAAaH,QAAQI,CAAC,EAAE;IACxD,2KAAK,CAACH,MAAM,CAACC,MAAM,CAACG,gBAAgB,CAAC,aAAaL,QAAQI,CAAC,EAAE;IAC7D,2KAAK,CAACH,MAAM,CAACC,MAAM,CAACI,mBAAmB,CAAC,iBAAiBN,QAAQO,KAAK,EAAE;IACxE,2KAAK,CAACN,MAAM,CAACC,MAAM,CAACM,QAAQ,CAAC,iBAAiBR,QAAQO,KAAK,EAAE;IAC7D,2KAAK,CAACN,MAAM,CAACC,MAAM,CAACI,mBAAmB,CAAC,gBAAgBN,QAAQS,IAAI,EAAE;IACtE,2KAAK,CAACR,MAAM,CAACC,MAAM,CAACG,gBAAgB,CAAC,gBAAgBL,QAAQS,IAAI,EAAE;IACnE,2KAAK,CAACR,MAAM,CAACC,MAAM,CAACC,WAAW,CAAC,aAAaH,QAAQU,CAAC,EAAE;IACxD,wBAAwB;IAExB,IAAI,CAACC,EAAE,GAAGX,QAAQI,CAAC;IACnB,IAAI,CAACQ,MAAM,GAAGZ,QAAQO,KAAK;IAC3B,IAAI,CAACM,KAAK,GAAGb,QAAQS,IAAI;IACzB,IAAI,CAACK,EAAE,GAAGd,QAAQU,CAAC;AACrB;AAEAK,OAAOC,gBAAgB,CAACjB,MAAMkB,SAAS,EAAE;IACvC;;;;;;GAMC,GACDb,GAAG;QACDc,KAAK;YACH,OAAO,IAAI,CAACP,EAAE;QAChB;IACF;IAEA;;;;;;GAMC,GACDJ,OAAO;QACLW,KAAK;YACH,OAAO,IAAI,CAACN,MAAM;QACpB;IACF;IAEA;;;;;;GAMC,GACDH,MAAM;QACJS,KAAK;YACH,OAAO,IAAI,CAACL,KAAK;QACnB;IACF;IAEA;;;;;;GAMC,GACDH,GAAG;QACDQ,KAAK;YACH,OAAO,IAAI,CAACJ,EAAE;QAChB;IACF;AACF;uCAEef","ignoreList":[0]}},
    {"offset": {"line": 1412, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/Extensions/Gpm/GltfGpmLoader.js"],"sourcesContent":["import Cartesian3 from \"../../../../Core/Cartesian3.js\";\nimport Check from \"../../../../Core/Check.js\";\nimport Matrix3 from \"../../../../Core/Matrix3.js\";\nimport RuntimeError from \"../../../../Core/RuntimeError.js\";\nimport AnchorPointDirect from \"./AnchorPointDirect.js\";\nimport AnchorPointIndirect from \"./AnchorPointIndirect.js\";\nimport CorrelationGroup from \"./CorrelationGroup.js\";\nimport GltfGpmLocal from \"./GltfGpmLocal.js\";\nimport Spdcf from \"./Spdcf.js\";\nimport StorageType from \"./StorageType.js\";\n\n/**\n * Loads glTF NGA_gpm_local from the root of a glTF object\n *\n * @alias GltfGpmLoader\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {string} [options.extension] The <code>NGA_gpm_local</code> extension object.\n *\n * @private\n */\nfunction GltfGpmLoader() {}\n\n/**\n * Creates a Matrix3 that describes a covariance matrix (which is\n * symmetric) from the array containing the upper triangle, in\n * column-major order.\n *\n * @param {number[]} array The input array\n * @returns {Matrix3} The Matrix3\n */\nfunction createCovarianceMatrixFromUpperTriangle(array) {\n  const covarianceMatrix = new Matrix3(\n    array[0],\n    array[1],\n    array[3],\n    array[1],\n    array[2],\n    array[4],\n    array[3],\n    array[4],\n    array[5],\n  );\n  return covarianceMatrix;\n}\n\n/**\n * Creates an `AnchorPointDirect` from the given JSON representation\n *\n * @param {object} anchorPointDirectJson The input JSON\n * @returns {AnchorPointDirect} The direct anchor point\n */\nfunction createAnchorPointDirect(anchorPointDirectJson) {\n  const position = Cartesian3.fromArray(\n    anchorPointDirectJson.position,\n    0,\n    new Cartesian3(),\n  );\n  const adjustmentParams = Cartesian3.fromArray(\n    anchorPointDirectJson.adjustmentParams,\n    0,\n    new Cartesian3(),\n  );\n  const anchorPointDirect = new AnchorPointDirect({\n    position: position,\n    adjustmentParams: adjustmentParams,\n  });\n  return anchorPointDirect;\n}\n\n/**\n * Creates an `AnchorPointIndirect` from the given JSON representation\n *\n * @param {object} anchorPointIndirectJson The input JSON\n * @returns {AnchorPointIndirect} The indirect anchor point\n */\nfunction createAnchorPointIndirect(anchorPointIndirectJson) {\n  const position = Cartesian3.fromArray(\n    anchorPointIndirectJson.position,\n    0,\n    new Cartesian3(),\n  );\n  const adjustmentParams = Cartesian3.fromArray(\n    anchorPointIndirectJson.adjustmentParams,\n    0,\n    new Cartesian3(),\n  );\n  const covarianceMatrix = createCovarianceMatrixFromUpperTriangle(\n    anchorPointIndirectJson.covarianceMatrix,\n  );\n  const anchorPointIndirect = new AnchorPointIndirect({\n    position: position,\n    adjustmentParams: adjustmentParams,\n    covarianceMatrix: covarianceMatrix,\n  });\n  return anchorPointIndirect;\n}\n\n/**\n * Creates a `CorrelationGroup` from the given JSON representation\n *\n * @param {object} correlationGroupJson The input JSON\n * @returns {CorrelationGroup} The correlation group\n */\nfunction createCorrelationGroup(correlationGroupJson) {\n  const groupFlags = correlationGroupJson.groupFlags;\n  const rotationThetas = Cartesian3.fromArray(\n    correlationGroupJson.rotationThetas,\n    0,\n    new Cartesian3(),\n  );\n  const params = [];\n  for (const paramJson of correlationGroupJson.params) {\n    const param = new Spdcf({\n      A: paramJson.A,\n      alpha: paramJson.alpha,\n      beta: paramJson.beta,\n      T: paramJson.T,\n    });\n    params.push(param);\n  }\n  const correlationGroup = new CorrelationGroup({\n    groupFlags: groupFlags,\n    rotationThetas: rotationThetas,\n    params: params,\n  });\n  return correlationGroup;\n}\n\n/**\n * Loads the GPM data from the given JSON that was found as the\n * `NGA_gpm_local` extension object in the root of the glTF.\n *\n * @param {object} gltfGpmLocalJson The extension object\n * @returns {GltfGpmLocal} The parsed object\n * @throws RuntimeError When the given object contains invalid storage types.\n * @private\n */\nGltfGpmLoader.load = function (gltfGpmLocalJson) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"gltfGpmLocalJson\", gltfGpmLocalJson);\n  //>>includeEnd('debug');\n\n  const storageType = gltfGpmLocalJson.storageType;\n  if (storageType === StorageType.Direct) {\n    return GltfGpmLoader.loadDirect(gltfGpmLocalJson);\n  }\n  if (storageType === StorageType.Indirect) {\n    return GltfGpmLoader.loadIndirect(gltfGpmLocalJson);\n  }\n  throw new RuntimeError(\n    `Invalid storage type in NGA_gpm_local - expected 'Direct' or 'Indirect', but found ${storageType}`,\n  );\n};\n\n/**\n * Loads the GPM data from the given JSON that was found as the\n * `NGA_gpm_local` extension object in the root of the glTF,\n * assuming that the `storageType` of the given object is\n * `StorageType.Direct`.\n *\n * @param {object} gltfGpmLocalJson The extension object\n * @returns {GltfGpmLocal} The parsed object\n * @private\n */\nGltfGpmLoader.loadDirect = function (gltfGpmLocalJson) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"gltfGpmLocalJson\", gltfGpmLocalJson);\n  Check.typeOf.object(\n    \"gltfGpmLocalJson.anchorPointsDirect\",\n    gltfGpmLocalJson.anchorPointsDirect,\n  );\n  Check.typeOf.object(\n    \"gltfGpmLocalJson.covarianceDirectUpperTriangle\",\n    gltfGpmLocalJson.covarianceDirectUpperTriangle,\n  );\n  //>>includeEnd('debug');\n\n  const anchorPointsDirect = [];\n  const anchorPointsDirectJson = gltfGpmLocalJson.anchorPointsDirect;\n  for (const anchorPointDirectJson of anchorPointsDirectJson) {\n    const anchorPointDirect = createAnchorPointDirect(anchorPointDirectJson);\n    anchorPointsDirect.push(anchorPointDirect);\n  }\n  const covarianceDirect = createCovarianceMatrixFromUpperTriangle(\n    gltfGpmLocalJson.covarianceDirectUpperTriangle,\n  );\n\n  const gltfGpmLocal = new GltfGpmLocal({\n    storageType: StorageType.Direct,\n    anchorPointsDirect: anchorPointsDirect,\n    covarianceDirect: covarianceDirect,\n  });\n  return gltfGpmLocal;\n};\n\n/**\n * Loads the GPM data from the given JSON that was found as the\n * `NGA_gpm_local` extension object in the root of the glTF,\n * assuming that the `storageType` of the given object is\n * `StorageType.Indirect`.\n *\n * @param {object} gltfGpmLocalJson The extension object\n * @returns {GltfGpmLocal} The parsed object\n * @private\n */\nGltfGpmLoader.loadIndirect = function (gltfGpmLocalJson) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"gltfGpmLocalJson\", gltfGpmLocalJson);\n  Check.typeOf.object(\n    \"gltfGpmLocalJson.anchorPointsIndirect\",\n    gltfGpmLocalJson.anchorPointsIndirect,\n  );\n  Check.typeOf.object(\n    \"gltfGpmLocalJson.intraTileCorrelationGroups\",\n    gltfGpmLocalJson.intraTileCorrelationGroups,\n  );\n  //>>includeEnd('debug');\n\n  const anchorPointsIndirect = [];\n  const anchorPointsIndirectJson = gltfGpmLocalJson.anchorPointsIndirect;\n  for (const anchorPointIndirectJson of anchorPointsIndirectJson) {\n    const anchorPointIndirect = createAnchorPointIndirect(\n      anchorPointIndirectJson,\n    );\n    anchorPointsIndirect.push(anchorPointIndirect);\n  }\n\n  const intraTileCorrelationGroupsJson =\n    gltfGpmLocalJson.intraTileCorrelationGroups;\n  const intraTileCorrelationGroups = [];\n\n  for (const correlationGroupJson of intraTileCorrelationGroupsJson) {\n    const correlationGroup = createCorrelationGroup(correlationGroupJson);\n    intraTileCorrelationGroups.push(correlationGroup);\n  }\n\n  const gltfGpmLocal = new GltfGpmLocal({\n    storageType: StorageType.Indirect,\n    anchorPointsIndirect: anchorPointsIndirect,\n    intraTileCorrelationGroups: intraTileCorrelationGroups,\n  });\n  return gltfGpmLocal;\n};\n\nexport default GltfGpmLoader;\n"],"names":["GltfGpmLoader","createCovarianceMatrixFromUpperTriangle","array","covarianceMatrix","createAnchorPointDirect","anchorPointDirectJson","position","fromArray","adjustmentParams","anchorPointDirect","createAnchorPointIndirect","anchorPointIndirectJson","anchorPointIndirect","createCorrelationGroup","correlationGroupJson","groupFlags","rotationThetas","params","paramJson","param","A","alpha","beta","T","push","correlationGroup","load","gltfGpmLocalJson","typeOf","object","storageType","Direct","loadDirect","Indirect","loadIndirect","anchorPointsDirect","covarianceDirectUpperTriangle","anchorPointsDirectJson","covarianceDirect","gltfGpmLocal","anchorPointsIndirect","intraTileCorrelationGroups","anchorPointsIndirectJson","intraTileCorrelationGroupsJson"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAEA;;;;;;;;;;;CAWC,GACD,SAASA,iBAAiB;AAE1B;;;;;;;CAOC,GACD,SAASC,wCAAwCC,KAAK;IACpD,MAAMC,mBAAmB,IAAI,6KAAO,CAClCD,KAAK,CAAC,EAAE,EACRA,KAAK,CAAC,EAAE,EACRA,KAAK,CAAC,EAAE,EACRA,KAAK,CAAC,EAAE,EACRA,KAAK,CAAC,EAAE,EACRA,KAAK,CAAC,EAAE,EACRA,KAAK,CAAC,EAAE,EACRA,KAAK,CAAC,EAAE,EACRA,KAAK,CAAC,EAAE;IAEV,OAAOC;AACT;AAEA;;;;;CAKC,GACD,SAASC,wBAAwBC,qBAAqB;IACpD,MAAMC,WAAW,gLAAU,CAACC,SAAS,CACnCF,sBAAsBC,QAAQ,EAC9B,GACA,IAAI,gLAAU;IAEhB,MAAME,mBAAmB,gLAAU,CAACD,SAAS,CAC3CF,sBAAsBG,gBAAgB,EACtC,GACA,IAAI,gLAAU;IAEhB,MAAMC,oBAAoB,IAAI,sNAAiB,CAAC;QAC9CH,UAAUA;QACVE,kBAAkBA;IACpB;IACA,OAAOC;AACT;AAEA;;;;;CAKC,GACD,SAASC,0BAA0BC,uBAAuB;IACxD,MAAML,WAAW,gLAAU,CAACC,SAAS,CACnCI,wBAAwBL,QAAQ,EAChC,GACA,IAAI,gLAAU;IAEhB,MAAME,mBAAmB,gLAAU,CAACD,SAAS,CAC3CI,wBAAwBH,gBAAgB,EACxC,GACA,IAAI,gLAAU;IAEhB,MAAML,mBAAmBF,wCACvBU,wBAAwBR,gBAAgB;IAE1C,MAAMS,sBAAsB,IAAI,wNAAmB,CAAC;QAClDN,UAAUA;QACVE,kBAAkBA;QAClBL,kBAAkBA;IACpB;IACA,OAAOS;AACT;AAEA;;;;;CAKC,GACD,SAASC,uBAAuBC,oBAAoB;IAClD,MAAMC,aAAaD,qBAAqBC,UAAU;IAClD,MAAMC,iBAAiB,gLAAU,CAACT,SAAS,CACzCO,qBAAqBE,cAAc,EACnC,GACA,IAAI,gLAAU;IAEhB,MAAMC,SAAS,EAAE;IACjB,KAAK,MAAMC,aAAaJ,qBAAqBG,MAAM,CAAE;QACnD,MAAME,QAAQ,IAAI,0MAAK,CAAC;YACtBC,GAAGF,UAAUE,CAAC;YACdC,OAAOH,UAAUG,KAAK;YACtBC,MAAMJ,UAAUI,IAAI;YACpBC,GAAGL,UAAUK,CAAC;QAChB;QACAN,OAAOO,IAAI,CAACL;IACd;IACA,MAAMM,mBAAmB,IAAI,qNAAgB,CAAC;QAC5CV,YAAYA;QACZC,gBAAgBA;QAChBC,QAAQA;IACV;IACA,OAAOQ;AACT;AAEA;;;;;;;;CAQC,GACDzB,cAAc0B,IAAI,GAAG,SAAUC,gBAAgB;IAC7C,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,oBAAoBF;IACxC,wBAAwB;IAExB,MAAMG,cAAcH,iBAAiBG,WAAW;IAChD,IAAIA,gBAAgB,gNAAW,CAACC,MAAM,EAAE;QACtC,OAAO/B,cAAcgC,UAAU,CAACL;IAClC;IACA,IAAIG,gBAAgB,gNAAW,CAACG,QAAQ,EAAE;QACxC,OAAOjC,cAAckC,YAAY,CAACP;IACpC;IACA,MAAM,IAAI,kLAAY,CACpB,CAAC,mFAAmF,EAAEG,aAAa;AAEvG;AAEA;;;;;;;;;CASC,GACD9B,cAAcgC,UAAU,GAAG,SAAUL,gBAAgB;IACnD,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,oBAAoBF;IACxC,2KAAK,CAACC,MAAM,CAACC,MAAM,CACjB,uCACAF,iBAAiBQ,kBAAkB;IAErC,2KAAK,CAACP,MAAM,CAACC,MAAM,CACjB,kDACAF,iBAAiBS,6BAA6B;IAEhD,wBAAwB;IAExB,MAAMD,qBAAqB,EAAE;IAC7B,MAAME,yBAAyBV,iBAAiBQ,kBAAkB;IAClE,KAAK,MAAM9B,yBAAyBgC,uBAAwB;QAC1D,MAAM5B,oBAAoBL,wBAAwBC;QAClD8B,mBAAmBX,IAAI,CAACf;IAC1B;IACA,MAAM6B,mBAAmBrC,wCACvB0B,iBAAiBS,6BAA6B;IAGhD,MAAMG,eAAe,IAAI,iNAAY,CAAC;QACpCT,aAAa,gNAAW,CAACC,MAAM;QAC/BI,oBAAoBA;QACpBG,kBAAkBA;IACpB;IACA,OAAOC;AACT;AAEA;;;;;;;;;CASC,GACDvC,cAAckC,YAAY,GAAG,SAAUP,gBAAgB;IACrD,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,oBAAoBF;IACxC,2KAAK,CAACC,MAAM,CAACC,MAAM,CACjB,yCACAF,iBAAiBa,oBAAoB;IAEvC,2KAAK,CAACZ,MAAM,CAACC,MAAM,CACjB,+CACAF,iBAAiBc,0BAA0B;IAE7C,wBAAwB;IAExB,MAAMD,uBAAuB,EAAE;IAC/B,MAAME,2BAA2Bf,iBAAiBa,oBAAoB;IACtE,KAAK,MAAM7B,2BAA2B+B,yBAA0B;QAC9D,MAAM9B,sBAAsBF,0BAC1BC;QAEF6B,qBAAqBhB,IAAI,CAACZ;IAC5B;IAEA,MAAM+B,iCACJhB,iBAAiBc,0BAA0B;IAC7C,MAAMA,6BAA6B,EAAE;IAErC,KAAK,MAAM3B,wBAAwB6B,+BAAgC;QACjE,MAAMlB,mBAAmBZ,uBAAuBC;QAChD2B,2BAA2BjB,IAAI,CAACC;IAClC;IAEA,MAAMc,eAAe,IAAI,iNAAY,CAAC;QACpCT,aAAa,gNAAW,CAACG,QAAQ;QACjCO,sBAAsBA;QACtBC,4BAA4BA;IAC9B;IACA,OAAOF;AACT;uCAEevC","ignoreList":[0]}},
    {"offset": {"line": 1603, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/Extensions/Gpm/PpeTexture.js"],"sourcesContent":["import Check from \"../../../../Core/Check.js\";\n\n/**\n * @typedef {object} PpeTexture.ConstructorOptions\n *\n * Initialization options for the PpeTexture constructor\n *\n * @property {PpeMetadata} traits The traits that indicate which data is stored in this texture\n * @property {number} index The index of the texture inside the glTF textures array\n * @property {number|undefined} [texCoord] The optional set index for the TEXCOORD attribute\n * @property {number|undefined} [noData] The value to represent missing data\n * @property {number|undefined} [offset] An offset to apply to property values.\n * @property {number|undefined} [scale] A scale to apply to property values.\n */\n\n/**\n * PPE (Per-Point Error) texture in `NGA_gpm_local`.\n *\n * This reflects the `ppeTexture` definition of the\n * {@link https://nsgreg.nga.mil/csmwg.jsp|NGA_gpm_local} glTF extension.\n *\n * This is a valid glTF `TextureInfo` object (with a required `index`\n * and an optional `texCoord)`, with additional properties that\n * describe the structure of the metdata that is stored in the texture.\n *\n * @constructor\n * @param {PpeTexture.ConstructorOptions} options An object describing initialization options\n *\n * @private\n */\nfunction PpeTexture(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.traits\", options.traits);\n  Check.typeOf.number.greaterThanOrEquals(\"options.index\", options.index, 0);\n  //>>includeEnd('debug');\n\n  this._traits = options.traits;\n  this._noData = options.noData;\n  this._offset = options.offset;\n  this._scale = options.scale;\n  this._index = options.index;\n  this._texCoord = options.texCoord;\n}\n\nObject.defineProperties(PpeTexture.prototype, {\n  /**\n   * The data contained here applies to this node and corresponding\n   * texture.\n   *\n   * @memberof PpeTexture.prototype\n   * @type {PpeMetadata}\n   * @readonly\n   */\n  traits: {\n    get: function () {\n      return this._traits;\n    },\n  },\n\n  /**\n   * A value to represent missing data - also known as a sentinel value -\n   * wherever it appears.\n   *\n   * @memberof PpeTexture.prototype\n   * @type {number|undefined}\n   * @readonly\n   */\n  noData: {\n    get: function () {\n      return this._noData;\n    },\n  },\n\n  /**\n   * An offset to apply to property values.\n   *\n   * @memberof PpeTexture.prototype\n   * @type {number|undefined}\n   * @readonly\n   */\n  offset: {\n    get: function () {\n      return this._offset;\n    },\n  },\n\n  /**\n   * An scale to apply to property values.\n   *\n   * @memberof PpeTexture.prototype\n   * @type {number|undefined}\n   * @readonly\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    },\n  },\n\n  /**\n   * The index of the texture\n   *\n   * @memberof PpeTexture.prototype\n   * @type {number}\n   * @readonly\n   */\n  index: {\n    get: function () {\n      return this._index;\n    },\n  },\n\n  /**\n   * The set index of texture's TEXCOORD attribute used for texture coordinate mapping.\n   *\n   * @memberof PpeTexture.prototype\n   * @type {number|undefined}\n   * @readonly\n   */\n  texCoord: {\n    get: function () {\n      return this._texCoord;\n    },\n  },\n});\n\nexport default PpeTexture;\n"],"names":["PpeTexture","options","typeOf","object","traits","number","greaterThanOrEquals","index","_traits","_noData","noData","_offset","offset","_scale","scale","_index","_texCoord","texCoord","Object","defineProperties","prototype","get"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;;;CAWC,GAED;;;;;;;;;;;;;;CAcC,GACD,SAASA,WAAWC,OAAO;IACzB,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,kBAAkBF,QAAQG,MAAM;IACpD,2KAAK,CAACF,MAAM,CAACG,MAAM,CAACC,mBAAmB,CAAC,iBAAiBL,QAAQM,KAAK,EAAE;IACxE,wBAAwB;IAExB,IAAI,CAACC,OAAO,GAAGP,QAAQG,MAAM;IAC7B,IAAI,CAACK,OAAO,GAAGR,QAAQS,MAAM;IAC7B,IAAI,CAACC,OAAO,GAAGV,QAAQW,MAAM;IAC7B,IAAI,CAACC,MAAM,GAAGZ,QAAQa,KAAK;IAC3B,IAAI,CAACC,MAAM,GAAGd,QAAQM,KAAK;IAC3B,IAAI,CAACS,SAAS,GAAGf,QAAQgB,QAAQ;AACnC;AAEAC,OAAOC,gBAAgB,CAACnB,WAAWoB,SAAS,EAAE;IAC5C;;;;;;;GAOC,GACDhB,QAAQ;QACNiB,KAAK;YACH,OAAO,IAAI,CAACb,OAAO;QACrB;IACF;IAEA;;;;;;;GAOC,GACDE,QAAQ;QACNW,KAAK;YACH,OAAO,IAAI,CAACZ,OAAO;QACrB;IACF;IAEA;;;;;;GAMC,GACDG,QAAQ;QACNS,KAAK;YACH,OAAO,IAAI,CAACV,OAAO;QACrB;IACF;IAEA;;;;;;GAMC,GACDG,OAAO;QACLO,KAAK;YACH,OAAO,IAAI,CAACR,MAAM;QACpB;IACF;IAEA;;;;;;GAMC,GACDN,OAAO;QACLc,KAAK;YACH,OAAO,IAAI,CAACN,MAAM;QACpB;IACF;IAEA;;;;;;GAMC,GACDE,UAAU;QACRI,KAAK;YACH,OAAO,IAAI,CAACL,SAAS;QACvB;IACF;AACF;uCAEehB","ignoreList":[0]}},
    {"offset": {"line": 1721, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/Extensions/Gpm/PpeMetadata.js"],"sourcesContent":["import Check from \"../../../../Core/Check.js\";\n\n/**\n * @typedef {object} PpeMetadata.ConstructorOptions\n *\n * Initialization options for the PpeMetadata constructor\n *\n * @property {PpeSource} source The source of the error data\n * @property {number|undefined} [min] Minimum allowed value for the property.\n * @property {number|undefined} [max] Maximum allowed value for the property.\n */\n\n/**\n * Metadata related to the stored PPE (Per-Point Error) data.\n *\n * This reflects the `ppeMetadata` definition of the\n * {@link https://nsgreg.nga.mil/csmwg.jsp|NGA_gpm_local} glTF extension.\n *\n * @constructor\n * @param {PpeMetadata.ConstructorOptions} options An object describing initialization options\n *\n * @private\n */\nfunction PpeMetadata(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.source\", options.source);\n  //>>includeEnd('debug');\n\n  this._min = options.min;\n  this._max = options.max;\n  this._source = options.source;\n}\n\nObject.defineProperties(PpeMetadata.prototype, {\n  /**\n   * Minimum allowed value for the property. This is the minimum of all\n   * values after the transforms based on the offset and scale properties\n   * have been applied.\n   *\n   * @memberof PpeMetadata.prototype\n   * @type {number|undefined}\n   * @readonly\n   */\n  min: {\n    get: function () {\n      return this._min;\n    },\n  },\n\n  /**\n   * Maximum allowed value for the property. This is the maximum of all\n   * values after the transforms based on the offset and scale properties\n   * have been applied.\n   *\n   * @memberof PpeMetadata.prototype\n   * @type {number|undefined}\n   * @readonly\n   */\n  max: {\n    get: function () {\n      return this._max;\n    },\n  },\n\n  /**\n   * Possible error source contents\n   *\n   * @memberof PpeMetadata.prototype\n   * @type {PpeSource}\n   * @readonly\n   */\n  source: {\n    get: function () {\n      return this._source;\n    },\n  },\n});\n\nexport default PpeMetadata;\n"],"names":["PpeMetadata","options","typeOf","string","source","_min","min","_max","max","_source","Object","defineProperties","prototype","get"],"mappings":";;;;AAAA;;AAEA;;;;;;;;CAQC,GAED;;;;;;;;;;CAUC,GACD,SAASA,YAAYC,OAAO;IAC1B,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,kBAAkBF,QAAQG,MAAM;IACpD,wBAAwB;IAExB,IAAI,CAACC,IAAI,GAAGJ,QAAQK,GAAG;IACvB,IAAI,CAACC,IAAI,GAAGN,QAAQO,GAAG;IACvB,IAAI,CAACC,OAAO,GAAGR,QAAQG,MAAM;AAC/B;AAEAM,OAAOC,gBAAgB,CAACX,YAAYY,SAAS,EAAE;IAC7C;;;;;;;;GAQC,GACDN,KAAK;QACHO,KAAK;YACH,OAAO,IAAI,CAACR,IAAI;QAClB;IACF;IAEA;;;;;;;;GAQC,GACDG,KAAK;QACHK,KAAK;YACH,OAAO,IAAI,CAACN,IAAI;QAClB;IACF;IAEA;;;;;;GAMC,GACDH,QAAQ;QACNS,KAAK;YACH,OAAO,IAAI,CAACJ,OAAO;QACrB;IACF;AACF;uCAEeT","ignoreList":[0]}},
    {"offset": {"line": 1797, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/Extensions/Gpm/MeshPrimitiveGpmLocal.js"],"sourcesContent":["/**\n * Local Generic Point-cloud Model information about a glTF primitive.\n *\n * @param {PpeTexture[]} ppeTextures The Per-Point Error textures\n *\n * @constructor\n * @private\n */\nfunction MeshPrimitiveGpmLocal(ppeTextures) {\n  this._ppeTextures = ppeTextures;\n}\n\nObject.defineProperties(MeshPrimitiveGpmLocal.prototype, {\n  /**\n   * An array of ppe textures.\n   *\n   * @memberof MeshPrimitiveGpmLocal.prototype\n   * @type {PpeTexture[]|undefined}\n   * @readonly\n   */\n  ppeTextures: {\n    get: function () {\n      return this._ppeTextures;\n    },\n  },\n});\n\nexport default MeshPrimitiveGpmLocal;\n"],"names":["MeshPrimitiveGpmLocal","ppeTextures","_ppeTextures","Object","defineProperties","prototype","get"],"mappings":";;;;AAAA;;;;;;;CAOC,GACD,SAASA,sBAAsBC,WAAW;IACxC,IAAI,CAACC,YAAY,GAAGD;AACtB;AAEAE,OAAOC,gBAAgB,CAACJ,sBAAsBK,SAAS,EAAE;IACvD;;;;;;GAMC,GACDJ,aAAa;QACXK,KAAK;YACH,OAAO,IAAI,CAACJ,YAAY;QAC1B;IACF;AACF;uCAEeF","ignoreList":[0]}},
    {"offset": {"line": 1829, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/Extensions/Gpm/GltfMeshPrimitiveGpmLoader.js"],"sourcesContent":["import Check from \"../../../../Core/Check.js\";\nimport Frozen from \"../../../../Core/Frozen.js\";\nimport defined from \"../../../../Core/defined.js\";\nimport ResourceCache from \"../../../ResourceCache.js\";\nimport ResourceLoader from \"../../../ResourceLoader.js\";\nimport ResourceLoaderState from \"../../../ResourceLoaderState.js\";\nimport PropertyTexture from \"../../../PropertyTexture.js\";\nimport StructuralMetadata from \"../../../StructuralMetadata.js\";\nimport MetadataSchema from \"../../../MetadataSchema.js\";\nimport PpeTexture from \"./PpeTexture.js\";\nimport PpeMetadata from \"./PpeMetadata.js\";\nimport MeshPrimitiveGpmLocal from \"./MeshPrimitiveGpmLocal.js\";\n\n/**\n * Loads glTF NGA_gpm_local from a glTF mesh primitive.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n * This loads the \"ppeTextures\" of the NGA_gpm_local extension of a mesh primitive\n * and stores them in a `MeshPrimitiveGpmLocal` object.\n *\n * This object will be converted into a `StructuralMetadata` object, which may\n * override any `StructuralMetadata` that was read directly from the glTF.\n *\n * @alias GltfMeshPrimitiveGpmLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {string} [options.extension] The <code>NGA_gpm_local</code> extension object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {SupportedImageFormats} options.supportedImageFormats The supported image formats.\n * @param {FrameState} options.frameState The frame state.\n * @param {string} [options.cacheKey] The cache key of the resource.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n *\n * @private\n */\nfunction GltfMeshPrimitiveGpmLoader(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const gltf = options.gltf;\n  const extension = options.extension;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const supportedImageFormats = options.supportedImageFormats;\n  const frameState = options.frameState;\n  const cacheKey = options.cacheKey;\n  const asynchronous = options.asynchronous ?? true;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.extension\", extension);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.supportedImageFormats\", supportedImageFormats);\n  Check.typeOf.object(\"options.frameState\", frameState);\n  //>>includeEnd('debug');\n\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._extension = extension;\n  this._supportedImageFormats = supportedImageFormats;\n  this._frameState = frameState;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._textureLoaders = [];\n  this._textureIds = [];\n  this._meshPrimitiveGpmLocal = undefined;\n  this._structuralMetadata = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\n\nif (defined(Object.create)) {\n  GltfMeshPrimitiveGpmLoader.prototype = Object.create(\n    ResourceLoader.prototype,\n  );\n  GltfMeshPrimitiveGpmLoader.prototype.constructor = GltfMeshPrimitiveGpmLoader;\n}\n\nObject.defineProperties(GltfMeshPrimitiveGpmLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfMeshPrimitiveGpmLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n\n  /**\n   * The parsed GPM extension information from the mesh primitive\n   *\n   * @memberof GltfMeshPrimitiveGpmLoader.prototype\n   *\n   * @type {MeshPrimitiveGpmLocal}\n   * @readonly\n   * @private\n   */\n  meshPrimitiveGpmLocal: {\n    get: function () {\n      return this._meshPrimitiveGpmLocal;\n    },\n  },\n\n  /**\n   * Returns the result of converting the parsed 'MeshPrimitiveGpmLocal'\n   * into a 'StructuralMetadata'.\n   *\n   * Some details about the translation are intentionally not specified here.\n   *\n   * @memberof GltfMeshPrimitiveGpmLoader.prototype\n   *\n   * @type {StructuralMetadata}\n   * @readonly\n   * @private\n   */\n  structuralMetadata: {\n    get: function () {\n      return this._structuralMetadata;\n    },\n  },\n});\n\nGltfMeshPrimitiveGpmLoader.prototype._loadResources = async function () {\n  try {\n    const texturesPromise = this._loadTextures();\n    await texturesPromise;\n\n    if (this.isDestroyed()) {\n      return;\n    }\n\n    this._gltf = undefined; // No longer need to hold onto the glTF\n\n    this._state = ResourceLoaderState.LOADED;\n    return this;\n  } catch (error) {\n    if (this.isDestroyed()) {\n      return;\n    }\n\n    this.unload();\n    this._state = ResourceLoaderState.FAILED;\n    const errorMessage = \"Failed to load GPM data\";\n    throw this.getError(errorMessage, error);\n  }\n};\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfMeshPrimitiveGpmLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfMeshPrimitiveGpmLoader.prototype.load = function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n\n  this._state = ResourceLoaderState.LOADING;\n  this._promise = this._loadResources(this);\n  return this._promise;\n};\n\nfunction gatherUsedTextureIds(gpmExtension) {\n  // Gather the used textures\n  const textureIds = {};\n  const ppeTextures = gpmExtension.ppeTextures;\n  if (defined(ppeTextures)) {\n    for (let i = 0; i < ppeTextures.length; i++) {\n      const ppeTexture = ppeTextures[i];\n      // The texture is a valid textureInfo.\n      textureIds[ppeTexture.index] = ppeTexture;\n    }\n  }\n  return textureIds;\n}\n\nGltfMeshPrimitiveGpmLoader.prototype._loadTextures = function () {\n  let textureIds;\n  if (defined(this._extension)) {\n    textureIds = gatherUsedTextureIds(this._extension);\n  }\n\n  const gltf = this._gltf;\n  const gltfResource = this._gltfResource;\n  const baseResource = this._baseResource;\n  const supportedImageFormats = this._supportedImageFormats;\n  const frameState = this._frameState;\n  const asynchronous = this._asynchronous;\n\n  // Load the textures\n  const texturePromises = [];\n  for (const textureId in textureIds) {\n    if (textureIds.hasOwnProperty(textureId)) {\n      const textureLoader = ResourceCache.getTextureLoader({\n        gltf: gltf,\n        textureInfo: textureIds[textureId],\n        gltfResource: gltfResource,\n        baseResource: baseResource,\n        supportedImageFormats: supportedImageFormats,\n        frameState: frameState,\n        asynchronous: asynchronous,\n      });\n      this._textureLoaders.push(textureLoader);\n      this._textureIds.push(textureId);\n      texturePromises.push(textureLoader.load());\n    }\n  }\n\n  return Promise.all(texturePromises);\n};\n\n/**\n * A static mapping from PPE texture property identifier keys\n * to `MetadataSchema` instances. This is used to create each\n * schema (with a certain structure) only ONCE in\n * _obtainPpeTexturesMetadataSchema\n *\n * @private\n */\nGltfMeshPrimitiveGpmLoader.ppeTexturesMetadataSchemaCache = new Map();\n\n/**\n * Create the JSON description of a metadata class that treats\n * the given PPE texture as a property texture property.\n *\n * @param {PpeTexture} ppeTexture - The PPE texture\n * @param {number} index - The index of the texture in the extension\n * @returns The class JSON\n */\nGltfMeshPrimitiveGpmLoader._createPpeTextureClassJson = function (\n  ppeTexture,\n  index,\n) {\n  const traits = ppeTexture.traits;\n  const ppePropertyName = traits.source;\n\n  // The ppeTexture will have a structure like this:\n  //\n  //\"ppeTextures\" : [\n  //  {\n  //    \"traits\" : {\n  //      \"source\" : \"SIGZ\",\n  //      \"min\" : 0.0,\n  //      \"max\" : 16.0\n  //    },\n  //    \"index\" : 2,\n  //    \"noData\" : 255,\n  //    \"offset\" : 0.0,\n  //    \"scale\" : 0.06274509803921569,\n  //    \"texCoord\" : 1\n  //  },\n  //\n  // This is translated into a single class property here, that defines\n  // the structure of the property texture property.\n  //\n  // Given that `offset` and `scale` may only be applied to integer\n  // property values when they are `normalized`, the values will be\n  // declared as `normalized` here.\n  // The normalization factor will later have to be cancelled out,\n  // with the `scale` being multiplied by 255.\n  const offset = ppeTexture.offset ?? 0.0;\n  const scale = (ppeTexture.scale ?? 1.0) * 255.0;\n  const classJson = {\n    name: `PPE texture class ${index}`,\n    properties: {\n      [ppePropertyName]: {\n        name: \"PPE\",\n        type: \"SCALAR\",\n        componentType: \"UINT8\",\n        normalized: true,\n        offset: offset,\n        scale: scale,\n        min: traits.min,\n        max: traits.max,\n      },\n    },\n  };\n  return classJson;\n};\n\n/**\n * Returns the `MetadataSchema` for the PPE textures in the given\n * `MeshPrimitiveGpmLocal` instance.\n *\n * This method will return a (statically/globally) cached metadata\n * schema that reflects the structure of the PPE textures in the\n * given instance, creating and caching it if necessary.\n *\n * For details on the cache key, see `_collectPpeTexturePropertyIdentifiers`\n *\n * @param {MeshPrimitiveGpmLocal} meshPrimitiveGpmLocal The extension object\n * @returns The `MetadataSchema`\n */\nGltfMeshPrimitiveGpmLoader._obtainPpeTexturesMetadataSchema = function (\n  meshPrimitiveGpmLocal,\n) {\n  const ppeTexturePropertyIdentifiers =\n    GltfMeshPrimitiveGpmLoader._collectPpeTexturePropertyIdentifiers(\n      meshPrimitiveGpmLocal,\n    );\n  const key = ppeTexturePropertyIdentifiers.toString();\n  let ppeTexturesMetadataSchema =\n    GltfMeshPrimitiveGpmLoader.ppeTexturesMetadataSchemaCache.get(key);\n  if (defined(ppeTexturesMetadataSchema)) {\n    return ppeTexturesMetadataSchema;\n  }\n\n  const schemaId = `PPE_TEXTURE_SCHEMA_${GltfMeshPrimitiveGpmLoader.ppeTexturesMetadataSchemaCache.size}`;\n  const ppeTexturesMetadataSchemaJson = {\n    id: schemaId,\n    classes: {},\n  };\n\n  const ppeTextures = meshPrimitiveGpmLocal.ppeTextures;\n  for (let i = 0; i < ppeTextures.length; i++) {\n    const ppeTexture = ppeTextures[i];\n    const classId = `ppeTexture_${i}`;\n    const classJson = GltfMeshPrimitiveGpmLoader._createPpeTextureClassJson(\n      ppeTexture,\n      i,\n    );\n    ppeTexturesMetadataSchemaJson.classes[classId] = classJson;\n  }\n\n  ppeTexturesMetadataSchema = MetadataSchema.fromJson(\n    ppeTexturesMetadataSchemaJson,\n  );\n  GltfMeshPrimitiveGpmLoader.ppeTexturesMetadataSchemaCache.set(\n    key,\n    ppeTexturesMetadataSchema,\n  );\n  return ppeTexturesMetadataSchema;\n};\n\n/**\n * Creates an array of strings that serve as identifiers for PPE textures.\n *\n * Each glTF may define multiple `ppeTexture` objects within the\n * `NGA_gpm_local` extensions. Each of these textures corresponds\n * to one 'property texture property' in a metadata schema.\n *\n * This method will create an array where each element is a (JSON)\n * string representation of the parts of a GPM PPE texture definition\n * that are relevant for distinguishing two PPE textures in terms\n * of their structure within a `StructuralMetadata`.\n *\n * @param {MeshPrimitiveGpmLocal} meshPrimitiveGpmLocal The extension object\n * @returns The identifiers\n */\nGltfMeshPrimitiveGpmLoader._collectPpeTexturePropertyIdentifiers = function (\n  meshPrimitiveGpmLocal,\n) {\n  const ppeTexturePropertyIdentifiers = [];\n  const ppeTextures = meshPrimitiveGpmLocal.ppeTextures;\n  for (let i = 0; i < ppeTextures.length; i++) {\n    const ppeTexture = ppeTextures[i];\n    // The following will create an identifier that can be used\n    // to define two PPE textures as \"representing the same\n    // property texture property\" within a structural metadata\n    // schema.\n    const classJson = GltfMeshPrimitiveGpmLoader._createPpeTextureClassJson(\n      ppeTexture,\n      i,\n    );\n    const ppeTexturePropertyIdentifier = JSON.stringify(classJson);\n    ppeTexturePropertyIdentifiers.push(ppeTexturePropertyIdentifier);\n  }\n  return ppeTexturePropertyIdentifiers;\n};\n\n/**\n * Converts the given `MeshPrimitiveGpmLocal` object into a `StructuralMetadata`\n * object.\n *\n * This will translate the PPE textures from the given object into property\n * texture properties. The schema will be created based on the the structure\n * of the PPE textures.\n *\n * @param {MeshPrimitiveGpmLocal} meshPrimitiveGpmLocal The extension object\n * @param {object} textures The mapping from texture ID to texture objects\n * @returns The `StructuralMetadata` object\n */\nGltfMeshPrimitiveGpmLoader._convertToStructuralMetadata = function (\n  meshPrimitiveGpmLocal,\n  textures,\n) {\n  const propertyTextures = [];\n  const ppeTexturesMetadataSchema =\n    GltfMeshPrimitiveGpmLoader._obtainPpeTexturesMetadataSchema(\n      meshPrimitiveGpmLocal,\n    );\n  const ppeTextures = meshPrimitiveGpmLocal.ppeTextures;\n  for (let i = 0; i < ppeTextures.length; i++) {\n    const ppeTexture = ppeTextures[i];\n    const classId = `ppeTexture_${i}`;\n    const traits = ppeTexture.traits;\n    const ppePropertyName = traits.source;\n    const metadataClass = ppeTexturesMetadataSchema.classes[classId];\n\n    const ppeTextureAsPropertyTexture = {\n      class: classId,\n      properties: {\n        [ppePropertyName]: {\n          index: ppeTexture.index,\n          texCoord: ppeTexture.texCoord,\n        },\n      },\n    };\n    propertyTextures.push(\n      new PropertyTexture({\n        id: i,\n        name: ppeTexture.name,\n        propertyTexture: ppeTextureAsPropertyTexture,\n        class: metadataClass,\n        textures: textures,\n      }),\n    );\n  }\n  const structuralMetadata = new StructuralMetadata({\n    schema: ppeTexturesMetadataSchema,\n    propertyTables: [],\n    propertyTextures: propertyTextures,\n    propertyAttributes: [],\n  });\n  return structuralMetadata;\n};\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfMeshPrimitiveGpmLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n\n  if (this._state !== ResourceLoaderState.LOADED) {\n    return false;\n  }\n\n  // The standard process of loading textures\n  // (from GltfStructuralMetadataLoader)\n  const textureLoaders = this._textureLoaders;\n  const textureLoadersLength = textureLoaders.length;\n  let ready = true;\n  for (let i = 0; i < textureLoadersLength; ++i) {\n    const textureLoader = textureLoaders[i];\n    const textureReady = textureLoader.process(frameState);\n    ready = ready && textureReady;\n  }\n\n  if (!ready) {\n    return false;\n  }\n\n  // More of the standard process of loading textures\n  // (from GltfStructuralMetadataLoader)\n  const textures = {};\n  for (let i = 0; i < this._textureIds.length; ++i) {\n    const textureId = this._textureIds[i];\n    const textureLoader = textureLoaders[i];\n    if (!textureLoader.isDestroyed()) {\n      textures[textureId] = textureLoader.texture;\n    }\n  }\n\n  // Convert the JSON representation of the `ppeTextures` that\n  // are found in the extensjon JSON into `PpeTexture` objects\n  const ppeTextures = [];\n  const extension = this._extension;\n  if (defined(extension.ppeTextures)) {\n    const ppeTexturesJson = extension.ppeTextures;\n    for (const ppeTextureJson of ppeTexturesJson) {\n      const traitsJson = ppeTextureJson.traits;\n      const traits = new PpeMetadata({\n        min: traitsJson.min,\n        max: traitsJson.max,\n        source: traitsJson.source,\n      });\n      const ppeTexture = new PpeTexture({\n        traits: traits,\n        noData: ppeTextureJson.noData,\n        offset: ppeTextureJson.offset,\n        scale: ppeTextureJson.scale,\n        index: ppeTextureJson.index,\n        texCoord: ppeTextureJson.texCoord,\n      });\n      ppeTextures.push(ppeTexture);\n    }\n  }\n  const meshPrimitiveGpmLocal = new MeshPrimitiveGpmLocal(ppeTextures);\n  this._meshPrimitiveGpmLocal = meshPrimitiveGpmLocal;\n\n  const structuralMetadata =\n    GltfMeshPrimitiveGpmLoader._convertToStructuralMetadata(\n      meshPrimitiveGpmLocal,\n      textures,\n    );\n  this._structuralMetadata = structuralMetadata;\n\n  this._state = ResourceLoaderState.READY;\n  return true;\n};\n\nGltfMeshPrimitiveGpmLoader.prototype._unloadTextures = function () {\n  const textureLoaders = this._textureLoaders;\n  const textureLoadersLength = textureLoaders.length;\n  for (let i = 0; i < textureLoadersLength; ++i) {\n    ResourceCache.unload(textureLoaders[i]);\n  }\n  this._textureLoaders.length = 0;\n  this._textureIds.length = 0;\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfMeshPrimitiveGpmLoader.prototype.unload = function () {\n  this._unloadTextures();\n  this._gltf = undefined;\n  this._extension = undefined;\n  this._structuralMetadata = undefined;\n};\n\nexport default GltfMeshPrimitiveGpmLoader;\n"],"names":["GltfMeshPrimitiveGpmLoader","options","EMPTY_OBJECT","gltf","extension","gltfResource","baseResource","supportedImageFormats","frameState","cacheKey","asynchronous","typeOf","object","_gltfResource","_baseResource","_gltf","_extension","_supportedImageFormats","_frameState","_cacheKey","_asynchronous","_textureLoaders","_textureIds","_meshPrimitiveGpmLocal","undefined","_structuralMetadata","_state","UNLOADED","_promise","Object","create","prototype","defineProperties","get","meshPrimitiveGpmLocal","structuralMetadata","_loadResources","texturesPromise","_loadTextures","isDestroyed","LOADED","error","unload","FAILED","errorMessage","getError","load","LOADING","gatherUsedTextureIds","gpmExtension","textureIds","ppeTextures","i","length","ppeTexture","index","texturePromises","textureId","hasOwnProperty","textureLoader","getTextureLoader","textureInfo","push","Promise","all","ppeTexturesMetadataSchemaCache","Map","_createPpeTextureClassJson","traits","ppePropertyName","source","offset","scale","classJson","name","properties","type","componentType","normalized","min","max","_obtainPpeTexturesMetadataSchema","ppeTexturePropertyIdentifiers","_collectPpeTexturePropertyIdentifiers","key","toString","ppeTexturesMetadataSchema","schemaId","size","ppeTexturesMetadataSchemaJson","id","classes","classId","fromJson","set","ppeTexturePropertyIdentifier","JSON","stringify","_convertToStructuralMetadata","textures","propertyTextures","metadataClass","ppeTextureAsPropertyTexture","class","texCoord","propertyTexture","schema","propertyTables","propertyAttributes","process","READY","textureLoaders","textureLoadersLength","ready","textureReady","texture","ppeTexturesJson","ppeTextureJson","traitsJson","noData","_unloadTextures"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2375, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/Extensions/Gpm/PpeSource.js"],"sourcesContent":["/**\n * An enum of per-point error sources.\n *\n * This reflects the `ppeMetadata.source` definition of the\n * {@link https://nsgreg.nga.mil/csmwg.jsp|NGA_gpm_local} glTF extension.\n *\n * @enum {string}\n * @private\n */\nconst PpeSource = {\n  /**\n   * The PPE standard deviation of error in the x dimension of the MCS (sigma x). Value will be squared\n   * and used to populate the (1,1) element in the PPE covariance matrix.\n   *\n   * @type {string}\n   * @constant\n   */\n  SIGX: \"SIGX\",\n\n  /**\n   * The PPE standard deviation of error in the y dimension of the MCS (sigma y). Value will be squared\n   * and used to populate the (2,2) element in the PPE covariance matrix.\n   *\n   * @type {string}\n   * @constant\n   */\n  SIGY: \"SIGY\",\n\n  /**\n   * The PPE standard deviation of error in the z dimension of the MCS (sigma z). Value will be squared\n   * and used to populate the (3,3) element in the PPE covariance matrix.\n   *\n   * @type {string}\n   * @constant\n   */\n  SIGZ: \"SIGZ\",\n\n  /**\n   * The PPE variance of error in the x dimension of the MCS (sigma x2). Value will be used to populate\n   * the (1,1) element in the PPE covariance matrix.\n   *\n   * @type {string}\n   * @constant\n   */\n  VARX: \"VARX\",\n\n  /**\n   * The PPE variance of error in the y dimension of the MCS (sigma y2). Value will be used to populate\n   * the (2,2) element in the PPE covariance matrix.\n   *\n   * @type {string}\n   * @constant\n   */\n  VARY: \"VARY\",\n\n  /**\n   * The PPE variance of error in the z dimension of the MCS (sigma z2). Value will be used to populate\n   * the (3,3) element in the PPE covariance matrix.\n   *\n   * @type {string}\n   * @constant\n   */\n  VARZ: \"VARZ\",\n\n  /**\n   * The PPE radial error in the horizontal dimension (x-y) of the MCS (sigma radial) . Value will be squared\n   * and used to populate the (1,1) and (2,2) element in the PPE covariance matrix.\n   *\n   * @type {string}\n   * @constant\n   */\n  SIGR: \"VARZ\",\n};\n\nexport default Object.freeze(PpeSource);\n"],"names":["PpeSource","SIGX","SIGY","SIGZ","VARX","VARY","VARZ","SIGR","Object","freeze"],"mappings":";;;;AAAA;;;;;;;;CAQC,GACD,MAAMA,YAAY;IAChB;;;;;;GAMC,GACDC,MAAM;IAEN;;;;;;GAMC,GACDC,MAAM;IAEN;;;;;;GAMC,GACDC,MAAM;IAEN;;;;;;GAMC,GACDC,MAAM;IAEN;;;;;;GAMC,GACDC,MAAM;IAEN;;;;;;GAMC,GACDC,MAAM;IAEN;;;;;;GAMC,GACDC,MAAM;AACR;uCAEeC,OAAOC,MAAM,CAACT","ignoreList":[0]}},
    {"offset": {"line": 2479, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/B3dmLoader.js"],"sourcesContent":["import Axis from \"../Axis.js\";\nimport B3dmParser from \"../B3dmParser.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cesium3DTileFeatureTable from \"../Cesium3DTileFeatureTable.js\";\nimport Check from \"../../Core/Check.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport StructuralMetadata from \"../StructuralMetadata.js\";\nimport GltfLoader from \"../GltfLoader.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport MetadataClass from \"../MetadataClass.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport parseBatchTable from \"../parseBatchTable.js\";\nimport PropertyTable from \"../PropertyTable.js\";\nimport ResourceLoader from \"../ResourceLoader.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\nconst B3dmLoaderState = {\n  UNLOADED: 0,\n  LOADING: 1,\n  PROCESSING: 2,\n  READY: 3,\n  FAILED: 4,\n};\n\nconst FeatureIdAttribute = ModelComponents.FeatureIdAttribute;\n\n/**\n * Loads a Batched 3D Model.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias B3dmLoader\n * @constructor\n * @augments ResourceLoader\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.b3dmResource The {@link Resource} containing the b3dm.\n * @param {ArrayBuffer} options.arrayBuffer The array buffer of the b3dm contents.\n * @param {number} [options.byteOffset] The byte offset to the beginning of the b3dm contents in the array buffer.\n * @param {Resource} [options.baseResource] The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {boolean} [options.releaseGltfJson=false] When true, the glTF JSON is released once the glTF is loaded. This is especially useful for cases like 3D Tiles, where each .gltf model is unique and caching the glTF JSON is not effective.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the glTF is loaded.\n * @param {Axis} [options.upAxis=Axis.Y] The up-axis of the glTF model.\n * @param {Axis} [options.forwardAxis=Axis.X] The forward-axis of the glTF model.\n * @param {boolean} [options.loadAttributesAsTypedArray=false] If <code>true</code>, load all attributes as typed arrays instead of GPU buffers. If the attributes are interleaved in the glTF they will be de-interleaved in the typed array.\n * @param {boolean} [options.loadAttributesFor2D=false] If <code>true</code>, load the positions buffer and any instanced attribute buffers as typed arrays for accurately projecting models to 2D.\n * @param {boolean} [options.enablePick=false]  If <code>true</code>, load the positions buffer, any instanced attribute buffers, and index buffer as typed arrays for CPU-enabled picking in WebGL1.\n * @param {boolean} [options.loadIndicesForWireframe=false] If <code>true</code>, load the index buffer as a typed array. This is useful for creating wireframe indices in WebGL1.\n * @param {boolean} [options.loadPrimitiveOutline=true] If <code>true</code>, load outlines from the {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/CESIUM_primitive_outline|CESIUM_primitive_outline} extension. This can be set false to avoid post-processing geometry at load time.\n * @param {boolean} [options.loadForClassification=false] If <code>true</code> and if the model has feature IDs, load the feature IDs and indices as typed arrays. This is useful for batching features for classification.\n * */\nfunction B3dmLoader(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const b3dmResource = options.b3dmResource;\n  let baseResource = options.baseResource;\n  const arrayBuffer = options.arrayBuffer;\n  const byteOffset = options.byteOffset ?? 0;\n  const releaseGltfJson = options.releaseGltfJson ?? false;\n  const asynchronous = options.asynchronous ?? true;\n  const incrementallyLoadTextures = options.incrementallyLoadTextures ?? true;\n  const upAxis = options.upAxis ?? Axis.Y;\n  const forwardAxis = options.forwardAxis ?? Axis.X;\n  const loadAttributesAsTypedArray =\n    options.loadAttributesAsTypedArray ?? false;\n  const loadAttributesFor2D = options.loadAttributesFor2D ?? false;\n  const enablePick = options.enablePick ?? false;\n  const loadIndicesForWireframe = options.loadIndicesForWireframe ?? false;\n  const loadPrimitiveOutline = options.loadPrimitiveOutline ?? true;\n  const loadForClassification = options.loadForClassification ?? false;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.b3dmResource\", b3dmResource);\n  Check.typeOf.object(\"options.arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  baseResource = defined(baseResource) ? baseResource : b3dmResource.clone();\n\n  this._b3dmResource = b3dmResource;\n  this._baseResource = baseResource;\n  this._arrayBuffer = arrayBuffer;\n  this._byteOffset = byteOffset;\n  this._releaseGltfJson = releaseGltfJson;\n  this._asynchronous = asynchronous;\n  this._incrementallyLoadTextures = incrementallyLoadTextures;\n  this._upAxis = upAxis;\n  this._forwardAxis = forwardAxis;\n  this._loadAttributesAsTypedArray = loadAttributesAsTypedArray;\n  this._loadAttributesFor2D = loadAttributesFor2D;\n  this._enablePick = enablePick;\n  this._loadIndicesForWireframe = loadIndicesForWireframe;\n  this._loadPrimitiveOutline = loadPrimitiveOutline;\n  this._loadForClassification = loadForClassification;\n\n  this._state = B3dmLoaderState.UNLOADED;\n\n  this._promise = undefined;\n\n  this._gltfLoader = undefined;\n\n  // Loaded results.\n  this._batchLength = 0;\n  this._propertyTable = undefined;\n\n  // The batch table object contains a json and a binary component access using keys of the same name.\n  this._batchTable = undefined;\n  this._components = undefined;\n  this._transform = Matrix4.IDENTITY;\n}\n\nif (defined(Object.create)) {\n  B3dmLoader.prototype = Object.create(ResourceLoader.prototype);\n  B3dmLoader.prototype.constructor = B3dmLoader;\n}\n\nObject.defineProperties(B3dmLoader.prototype, {\n  /**\n   * true if textures are loaded, useful when incrementallyLoadTextures is true\n   *\n   * @memberof B3dmLoader.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  texturesLoaded: {\n    get: function () {\n      return this._gltfLoader?.texturesLoaded;\n    },\n  },\n  /**\n   * The cache key of the resource\n   *\n   * @memberof B3dmLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * The loaded components.\n   *\n   * @memberof B3dmLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise<B3dmLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nB3dmLoader.prototype.load = function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n\n  const b3dm = B3dmParser.parse(this._arrayBuffer, this._byteOffset);\n\n  let batchLength = b3dm.batchLength;\n  const featureTableJson = b3dm.featureTableJson;\n  const featureTableBinary = b3dm.featureTableBinary;\n  const batchTableJson = b3dm.batchTableJson;\n  const batchTableBinary = b3dm.batchTableBinary;\n\n  const featureTable = new Cesium3DTileFeatureTable(\n    featureTableJson,\n    featureTableBinary,\n  );\n  batchLength = featureTable.getGlobalProperty(\"BATCH_LENGTH\");\n  // Set batch length.\n  this._batchLength = batchLength;\n  // Set the RTC Center transform, if present.\n  const rtcCenter = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3,\n  );\n  if (defined(rtcCenter)) {\n    this._transform = Matrix4.fromTranslation(Cartesian3.fromArray(rtcCenter));\n  }\n\n  this._batchTable = {\n    json: batchTableJson,\n    binary: batchTableBinary,\n  };\n\n  const gltfLoader = new GltfLoader({\n    typedArray: b3dm.gltf,\n    upAxis: this._upAxis,\n    forwardAxis: this._forwardAxis,\n    gltfResource: this._b3dmResource,\n    baseResource: this._baseResource,\n    releaseGltfJson: this._releaseGltfJson,\n    incrementallyLoadTextures: this._incrementallyLoadTextures,\n    loadAttributesAsTypedArray: this._loadAttributesAsTypedArray,\n    loadAttributesFor2D: this._loadAttributesFor2D,\n    enablePick: this._enablePick,\n    loadIndicesForWireframe: this._loadIndicesForWireframe,\n    loadPrimitiveOutline: this._loadPrimitiveOutline,\n    loadForClassification: this._loadForClassification,\n    renameBatchIdSemantic: true,\n  });\n\n  this._gltfLoader = gltfLoader;\n  this._state = B3dmLoaderState.LOADING;\n\n  const that = this;\n  this._promise = gltfLoader\n    .load()\n    .then(function () {\n      if (that.isDestroyed()) {\n        return;\n      }\n\n      that._state = B3dmLoaderState.PROCESSING;\n      return that;\n    })\n    .catch(function (error) {\n      if (that.isDestroyed()) {\n        return;\n      }\n\n      return handleError(that, error);\n    });\n\n  return this._promise;\n};\n\nfunction handleError(b3dmLoader, error) {\n  b3dmLoader.unload();\n  b3dmLoader._state = B3dmLoaderState.FAILED;\n  const errorMessage = \"Failed to load b3dm\";\n  error = b3dmLoader.getError(errorMessage, error);\n  return Promise.reject(error);\n}\n\nB3dmLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === B3dmLoaderState.READY) {\n    return true;\n  }\n\n  if (this._state !== B3dmLoaderState.PROCESSING) {\n    return false;\n  }\n\n  const ready = this._gltfLoader.process(frameState);\n  if (!ready) {\n    return false;\n  }\n\n  const components = this._gltfLoader.components;\n\n  // Combine the RTC_CENTER transform from the b3dm and the CESIUM_RTC\n  // transform from the glTF. In practice usually only one or the\n  // other is supplied. If they don't exist the transforms will\n  // be identity matrices.\n  components.transform = Matrix4.multiplyTransformation(\n    this._transform,\n    components.transform,\n    components.transform,\n  );\n  createStructuralMetadata(this, components);\n  this._components = components;\n\n  // Now that we have the parsed components, we can release the array buffer\n  this._arrayBuffer = undefined;\n\n  this._state = B3dmLoaderState.READY;\n  return true;\n};\n\nfunction createStructuralMetadata(loader, components) {\n  const batchTable = loader._batchTable;\n  const batchLength = loader._batchLength;\n\n  if (batchLength === 0) {\n    return;\n  }\n\n  let structuralMetadata;\n  if (defined(batchTable.json)) {\n    // Add the structural metadata from the batch table to the model components.\n    structuralMetadata = parseBatchTable({\n      count: batchLength,\n      batchTable: batchTable.json,\n      binaryBody: batchTable.binary,\n    });\n  } else {\n    // If batch table is not defined, create a property table without any properties.\n    const emptyPropertyTable = new PropertyTable({\n      name: MetadataClass.BATCH_TABLE_CLASS_NAME,\n      count: batchLength,\n    });\n    structuralMetadata = new StructuralMetadata({\n      schema: {},\n      propertyTables: [emptyPropertyTable],\n    });\n  }\n\n  // Add the feature ID attribute to the primitives.\n  const nodes = components.scene.nodes;\n  const length = nodes.length;\n  for (let i = 0; i < length; i++) {\n    processNode(nodes[i]);\n  }\n  components.structuralMetadata = structuralMetadata;\n}\n\n// Recursive function to add the feature ID attribute to all primitives that have a feature ID vertex attribute.\nfunction processNode(node) {\n  const childrenLength = node.children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    processNode(node.children[i]);\n  }\n\n  const primitivesLength = node.primitives.length;\n  for (let i = 0; i < primitivesLength; i++) {\n    const primitive = node.primitives[i];\n    const featureIdVertexAttribute = ModelUtility.getAttributeBySemantic(\n      primitive,\n      VertexAttributeSemantic.FEATURE_ID,\n    );\n    if (defined(featureIdVertexAttribute)) {\n      featureIdVertexAttribute.setIndex = 0;\n      const featureIdAttribute = new FeatureIdAttribute();\n      featureIdAttribute.propertyTableId = 0;\n      featureIdAttribute.setIndex = 0;\n      featureIdAttribute.positionalLabel = \"featureId_0\";\n      primitive.featureIds.push(featureIdAttribute);\n    }\n  }\n}\n\nB3dmLoader.prototype.unload = function () {\n  if (defined(this._gltfLoader) && !this._gltfLoader.isDestroyed()) {\n    this._gltfLoader.unload();\n  }\n\n  this._components = undefined;\n  this._arrayBuffer = undefined;\n};\n\nexport default B3dmLoader;\n"],"names":["B3dmLoaderState","UNLOADED","LOADING","PROCESSING","READY","FAILED","FeatureIdAttribute","B3dmLoader","options","EMPTY_OBJECT","b3dmResource","baseResource","arrayBuffer","byteOffset","releaseGltfJson","asynchronous","incrementallyLoadTextures","upAxis","Y","forwardAxis","X","loadAttributesAsTypedArray","loadAttributesFor2D","enablePick","loadIndicesForWireframe","loadPrimitiveOutline","loadForClassification","typeOf","object","clone","_b3dmResource","_baseResource","_arrayBuffer","_byteOffset","_releaseGltfJson","_asynchronous","_incrementallyLoadTextures","_upAxis","_forwardAxis","_loadAttributesAsTypedArray","_loadAttributesFor2D","_enablePick","_loadIndicesForWireframe","_loadPrimitiveOutline","_loadForClassification","_state","_promise","undefined","_gltfLoader","_batchLength","_propertyTable","_batchTable","_components","_transform","IDENTITY","Object","create","prototype","defineProperties","texturesLoaded","get","cacheKey","components","load","b3dm","parse","batchLength","featureTableJson","featureTableBinary","batchTableJson","batchTableBinary","featureTable","getGlobalProperty","rtcCenter","FLOAT","fromTranslation","fromArray","json","binary","gltfLoader","typedArray","gltf","gltfResource","renameBatchIdSemantic","that","then","isDestroyed","catch","error","handleError","b3dmLoader","unload","errorMessage","getError","Promise","reject","process","frameState","ready","transform","multiplyTransformation","createStructuralMetadata","loader","batchTable","structuralMetadata","count","binaryBody","emptyPropertyTable","name","BATCH_TABLE_CLASS_NAME","schema","propertyTables","nodes","scene","length","i","processNode","node","childrenLength","children","primitivesLength","primitives","primitive","featureIdVertexAttribute","getAttributeBySemantic","FEATURE_ID","setIndex","featureIdAttribute","propertyTableId","positionalLabel","featureIds","push"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2808, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/GeoJsonLoader.js"],"sourcesContent":["import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport Ellipsoid from \"../../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../../Core/IndexDatatype.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport JsonMetadataTable from \"../JsonMetadataTable.js\";\nimport MetadataSchema from \"../MetadataSchema.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport PropertyTable from \"../PropertyTable.js\";\nimport ResourceLoader from \"../ResourceLoader.js\";\nimport StructuralMetadata from \"../StructuralMetadata.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport addAllToArray from \"../../Core/addAllToArray.js\";\n\n/**\n * Loads a GeoJson model as part of the <code>MAXAR_content_geojson</code> extension with the following constraints:\n * <ul>\n *   <li>The top level GeoJSON type must be FeatureCollection or Feature.</li>\n *   <li>The geometry types must be LineString, MultiLineString, MultiPolygon, Polygon, MultiPoint, or Point.</li>\n *   <li>Polygon and polyline geometries are converted to geodesic lines.</li>\n *   <li>Only WGS84 geographic coordinates are supported.</li>\n * </ul>\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GeoJsonLoader\n * @constructor\n * @augments ResourceLoader\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.geoJson The GeoJson object.\n */\nfunction GeoJsonLoader(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.geoJson\", options.geoJson);\n  //>>includeEnd('debug');\n\n  this._geoJson = options.geoJson;\n  this._components = undefined;\n}\n\nif (defined(Object.create)) {\n  GeoJsonLoader.prototype = Object.create(ResourceLoader.prototype);\n  GeoJsonLoader.prototype.constructor = GeoJsonLoader;\n}\n\nObject.defineProperties(GeoJsonLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GeoJsonLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    },\n  },\n  /**\n   * The loaded components.\n   *\n   * @memberof GeoJsonLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise<GeoJsonLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGeoJsonLoader.prototype.load = function () {\n  return Promise.resolve(this);\n};\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGeoJsonLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (defined(this._components)) {\n    return true;\n  }\n\n  this._components = parse(this._geoJson, frameState);\n  this._geoJson = undefined;\n  return true;\n};\n\nfunction ParsedFeature() {\n  this.lines = undefined;\n  this.points = undefined;\n  this.properties = undefined;\n}\n\nfunction ParseResult() {\n  this.features = [];\n}\n\nfunction parsePosition(position) {\n  const x = position[0];\n  const y = position[1];\n  const z = position[2] ?? 0.0;\n  return new Cartesian3(x, y, z);\n}\n\nfunction parseLineString(coordinates) {\n  const positionsLength = coordinates.length;\n  const line = new Array(positionsLength);\n  for (let i = 0; i < positionsLength; i++) {\n    line[i] = parsePosition(coordinates[i]);\n  }\n  const lines = [line];\n  return lines;\n}\n\nfunction parseMultiLineString(coordinates) {\n  const linesLength = coordinates.length;\n  const lines = new Array(linesLength);\n  for (let i = 0; i < linesLength; i++) {\n    lines[i] = parseLineString(coordinates[i])[0];\n  }\n  return lines;\n}\n\nfunction parsePolygon(coordinates) {\n  // Treat exterior polygon and interior polygons as lines\n  const linesLength = coordinates.length;\n  const lines = new Array(linesLength);\n  for (let i = 0; i < linesLength; i++) {\n    lines[i] = parseLineString(coordinates[i])[0];\n  }\n  return lines;\n}\n\nfunction parseMultiPolygon(coordinates) {\n  const polygonsLength = coordinates.length;\n  const lines = [];\n  for (let i = 0; i < polygonsLength; i++) {\n    const polygon = parsePolygon(coordinates[i]);\n    addAllToArray(lines, polygon);\n  }\n  return lines;\n}\n\nfunction parsePoint(coordinates) {\n  return [parsePosition(coordinates)];\n}\n\nfunction parseMultiPoint(coordinates) {\n  const pointsLength = coordinates.length;\n  const points = new Array(pointsLength);\n  for (let i = 0; i < pointsLength; i++) {\n    points[i] = parsePosition(coordinates[i]);\n  }\n  return points;\n}\n\nconst geometryTypes = {\n  LineString: parseLineString,\n  MultiLineString: parseMultiLineString,\n  MultiPolygon: parseMultiPolygon,\n  Polygon: parsePolygon,\n  MultiPoint: parseMultiPoint,\n  Point: parsePoint,\n};\n\nconst primitiveTypes = {\n  LineString: PrimitiveType.LINES,\n  MultiLineString: PrimitiveType.LINES,\n  MultiPolygon: PrimitiveType.LINES,\n  Polygon: PrimitiveType.LINES,\n  MultiPoint: PrimitiveType.POINTS,\n  Point: PrimitiveType.POINTS,\n};\n\nfunction parseFeature(feature, result) {\n  if (!defined(feature.geometry)) {\n    return;\n  }\n\n  const geometryType = feature.geometry.type;\n  const geometryFunction = geometryTypes[geometryType];\n  const primitiveType = primitiveTypes[geometryType];\n  const coordinates = feature.geometry.coordinates;\n\n  if (!defined(geometryFunction)) {\n    return;\n  }\n\n  if (!defined(coordinates)) {\n    return;\n  }\n\n  const parsedFeature = new ParsedFeature();\n\n  if (primitiveType === PrimitiveType.LINES) {\n    parsedFeature.lines = geometryFunction(coordinates);\n  } else if (primitiveType === PrimitiveType.POINTS) {\n    parsedFeature.points = geometryFunction(coordinates);\n  }\n\n  parsedFeature.properties = feature.properties;\n\n  result.features.push(parsedFeature);\n}\n\nfunction parseFeatureCollection(featureCollection, result) {\n  const features = featureCollection.features;\n  const featuresLength = features.length;\n  for (let i = 0; i < featuresLength; i++) {\n    parseFeature(features[i], result);\n  }\n}\n\nconst geoJsonObjectTypes = {\n  FeatureCollection: parseFeatureCollection,\n  Feature: parseFeature,\n};\n\nconst scratchCartesian = new Cartesian3();\n\nfunction createLinesPrimitive(features, toLocal, frameState) {\n  // Count the number of vertices and indices\n  let vertexCount = 0;\n  let indexCount = 0;\n\n  const featureCount = features.length;\n\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    if (defined(feature.lines)) {\n      const linesLength = feature.lines.length;\n      for (let j = 0; j < linesLength; j++) {\n        const line = feature.lines[j];\n        vertexCount += line.length;\n        indexCount += (line.length - 1) * 2;\n      }\n    }\n  }\n\n  // Allocate typed arrays\n  const positionsTypedArray = new Float32Array(vertexCount * 3);\n  const featureIdsTypedArray = new Float32Array(vertexCount);\n  const indicesTypedArray = IndexDatatype.createTypedArray(\n    vertexCount,\n    indexCount,\n  );\n  const indexDatatype = IndexDatatype.fromTypedArray(indicesTypedArray);\n\n  // Process the data. Convert positions to local ENU. Generate indices.\n  const localMin = new Cartesian3(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n  );\n\n  const localMax = new Cartesian3(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n  );\n\n  let vertexCounter = 0;\n  let segmentCounter = 0;\n\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n\n    if (!defined(feature.lines)) {\n      continue;\n    }\n\n    const linesLength = feature.lines.length;\n    for (let j = 0; j < linesLength; j++) {\n      const line = feature.lines[j];\n      const positionsLength = line.length;\n      for (let k = 0; k < positionsLength; k++) {\n        const cartographic = line[k];\n        const globalCartesian = Cartesian3.fromDegrees(\n          cartographic.x,\n          cartographic.y,\n          cartographic.z,\n          Ellipsoid.WGS84,\n          scratchCartesian,\n        );\n        const localCartesian = Matrix4.multiplyByPoint(\n          toLocal,\n          globalCartesian,\n          scratchCartesian,\n        );\n\n        Cartesian3.minimumByComponent(localMin, localCartesian, localMin);\n        Cartesian3.maximumByComponent(localMax, localCartesian, localMax);\n\n        Cartesian3.pack(localCartesian, positionsTypedArray, vertexCounter * 3);\n\n        featureIdsTypedArray[vertexCounter] = i;\n\n        if (k < positionsLength - 1) {\n          indicesTypedArray[segmentCounter * 2] = vertexCounter;\n          indicesTypedArray[segmentCounter * 2 + 1] = vertexCounter + 1;\n          segmentCounter++;\n        }\n\n        vertexCounter++;\n      }\n    }\n  }\n\n  // Create GPU buffers\n  const positionBuffer = Buffer.createVertexBuffer({\n    typedArray: positionsTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  positionBuffer.vertexArrayDestroyable = false;\n\n  const featureIdBuffer = Buffer.createVertexBuffer({\n    typedArray: featureIdsTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  featureIdBuffer.vertexArrayDestroyable = false;\n\n  const indexBuffer = Buffer.createIndexBuffer({\n    typedArray: indicesTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: indexDatatype,\n  });\n  indexBuffer.vertexArrayDestroyable = false;\n\n  // Create ModelComponents\n  const positionAttribute = new ModelComponents.Attribute();\n  positionAttribute.semantic = VertexAttributeSemantic.POSITION;\n  positionAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  positionAttribute.type = AttributeType.VEC3;\n  positionAttribute.count = vertexCount;\n  positionAttribute.min = localMin;\n  positionAttribute.max = localMax;\n  positionAttribute.buffer = positionBuffer;\n\n  const featureIdAttribute = new ModelComponents.Attribute();\n  featureIdAttribute.semantic = VertexAttributeSemantic.FEATURE_ID;\n  featureIdAttribute.setIndex = 0;\n  featureIdAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  featureIdAttribute.type = AttributeType.SCALAR;\n  featureIdAttribute.count = vertexCount;\n  featureIdAttribute.buffer = featureIdBuffer;\n\n  const attributes = [positionAttribute, featureIdAttribute];\n\n  const material = new ModelComponents.Material();\n  material.unlit = true;\n\n  const indices = new ModelComponents.Indices();\n  indices.indexDatatype = indexDatatype;\n  indices.count = indicesTypedArray.length;\n  indices.buffer = indexBuffer;\n\n  const featureId = new ModelComponents.FeatureIdAttribute();\n  featureId.featureCount = featureCount;\n  featureId.propertyTableId = 0;\n  featureId.setIndex = 0;\n  featureId.positionalLabel = \"featureId_0\";\n\n  const featureIds = [featureId];\n\n  const primitive = new ModelComponents.Primitive();\n  primitive.attributes = attributes;\n  primitive.indices = indices;\n  primitive.featureIds = featureIds;\n  primitive.primitiveType = PrimitiveType.LINES;\n  primitive.material = material;\n\n  return primitive;\n}\n\nfunction createPointsPrimitive(features, toLocal, frameState) {\n  // Count the number of vertices\n  let vertexCount = 0;\n\n  const featureCount = features.length;\n\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    if (defined(feature.points)) {\n      vertexCount += feature.points.length;\n    }\n  }\n\n  // Allocate typed arrays\n  const positionsTypedArray = new Float32Array(vertexCount * 3);\n  const featureIdsTypedArray = new Float32Array(vertexCount);\n\n  // Process the data. Convert positions to local ENU.\n  const localMin = new Cartesian3(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n  );\n\n  const localMax = new Cartesian3(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n  );\n\n  let vertexCounter = 0;\n\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n\n    if (!defined(feature.points)) {\n      continue;\n    }\n\n    const pointsLength = feature.points.length;\n    for (let j = 0; j < pointsLength; j++) {\n      const cartographic = feature.points[j];\n      const globalCartesian = Cartesian3.fromDegrees(\n        cartographic.x,\n        cartographic.y,\n        cartographic.z,\n        Ellipsoid.WGS84,\n        scratchCartesian,\n      );\n      const localCartesian = Matrix4.multiplyByPoint(\n        toLocal,\n        globalCartesian,\n        scratchCartesian,\n      );\n\n      Cartesian3.minimumByComponent(localMin, localCartesian, localMin);\n      Cartesian3.maximumByComponent(localMax, localCartesian, localMax);\n\n      Cartesian3.pack(localCartesian, positionsTypedArray, vertexCounter * 3);\n\n      featureIdsTypedArray[vertexCounter] = i;\n\n      vertexCounter++;\n    }\n  }\n\n  // Create GPU buffers\n  const positionBuffer = Buffer.createVertexBuffer({\n    typedArray: positionsTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  positionBuffer.vertexArrayDestroyable = false;\n\n  const featureIdBuffer = Buffer.createVertexBuffer({\n    typedArray: featureIdsTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  featureIdBuffer.vertexArrayDestroyable = false;\n\n  // Create ModelComponents\n  const positionAttribute = new ModelComponents.Attribute();\n  positionAttribute.semantic = VertexAttributeSemantic.POSITION;\n  positionAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  positionAttribute.type = AttributeType.VEC3;\n  positionAttribute.count = vertexCount;\n  positionAttribute.min = localMin;\n  positionAttribute.max = localMax;\n  positionAttribute.buffer = positionBuffer;\n\n  const featureIdAttribute = new ModelComponents.Attribute();\n  featureIdAttribute.semantic = VertexAttributeSemantic.FEATURE_ID;\n  featureIdAttribute.setIndex = 0;\n  featureIdAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  featureIdAttribute.type = AttributeType.SCALAR;\n  featureIdAttribute.count = vertexCount;\n  featureIdAttribute.buffer = featureIdBuffer;\n\n  const attributes = [positionAttribute, featureIdAttribute];\n\n  const material = new ModelComponents.Material();\n  material.unlit = true;\n\n  const featureId = new ModelComponents.FeatureIdAttribute();\n  featureId.featureCount = featureCount;\n  featureId.propertyTableId = 0;\n  featureId.setIndex = 0;\n  featureId.positionalLabel = \"featureId_0\";\n\n  const featureIds = [featureId];\n\n  const primitive = new ModelComponents.Primitive();\n  primitive.attributes = attributes;\n  primitive.featureIds = featureIds;\n  primitive.primitiveType = PrimitiveType.POINTS;\n  primitive.material = material;\n\n  return primitive;\n}\n\nfunction parse(geoJson, frameState) {\n  const result = new ParseResult();\n\n  // Parse the GeoJSON\n  const parseFunction = geoJsonObjectTypes[geoJson.type];\n  if (defined(parseFunction)) {\n    parseFunction(geoJson, result);\n  }\n\n  const features = result.features;\n  const featureCount = features.length;\n\n  if (featureCount === 0) {\n    throw new RuntimeError(\"GeoJSON must have at least one feature\");\n  }\n\n  // Allocate space for property values\n  const properties = {};\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    const featureProperties = feature.properties ?? Frozen.EMPTY_OBJECT;\n    for (const propertyId in featureProperties) {\n      if (featureProperties.hasOwnProperty(propertyId)) {\n        if (!defined(properties[propertyId])) {\n          properties[propertyId] = new Array(featureCount);\n        }\n      }\n    }\n  }\n\n  // Fill in the property values. Default to empty string for undefined values.\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    for (const propertyId in properties) {\n      if (properties.hasOwnProperty(propertyId)) {\n        const value = feature.properties[propertyId] ?? \"\";\n        properties[propertyId][i] = value;\n      }\n    }\n  }\n\n  const jsonMetadataTable = new JsonMetadataTable({\n    count: featureCount,\n    properties: properties,\n  });\n\n  const propertyTable = new PropertyTable({\n    id: 0,\n    count: featureCount,\n    jsonMetadataTable: jsonMetadataTable,\n  });\n  const propertyTables = [propertyTable];\n\n  const schema = MetadataSchema.fromJson({});\n\n  const structuralMetadata = new StructuralMetadata({\n    schema: schema,\n    propertyTables: propertyTables,\n  });\n\n  // Find the cartographic bounding box\n  const cartographicMin = new Cartesian3(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n  );\n\n  const cartographicMax = new Cartesian3(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n  );\n\n  let hasLines = false;\n  let hasPoints = false;\n\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    if (defined(feature.lines)) {\n      hasLines = true;\n      const linesLength = feature.lines.length;\n      for (let j = 0; j < linesLength; j++) {\n        const line = feature.lines[j];\n        const positionsLength = line.length;\n        for (let k = 0; k < positionsLength; k++) {\n          Cartesian3.minimumByComponent(\n            cartographicMin,\n            line[k],\n            cartographicMin,\n          );\n          Cartesian3.maximumByComponent(\n            cartographicMax,\n            line[k],\n            cartographicMax,\n          );\n        }\n      }\n    }\n\n    if (defined(feature.points)) {\n      hasPoints = true;\n      const pointsLength = feature.points.length;\n      for (let j = 0; j < pointsLength; j++) {\n        const point = feature.points[j];\n        Cartesian3.minimumByComponent(cartographicMin, point, cartographicMin);\n        Cartesian3.maximumByComponent(cartographicMax, point, cartographicMax);\n      }\n    }\n  }\n\n  // Compute the ENU matrix\n  const cartographicCenter = Cartesian3.midpoint(\n    cartographicMin,\n    cartographicMax,\n    new Cartesian3(),\n  );\n  const ecefCenter = Cartesian3.fromDegrees(\n    cartographicCenter.x,\n    cartographicCenter.y,\n    cartographicCenter.z,\n    Ellipsoid.WGS84,\n    new Cartesian3(),\n  );\n  const toGlobal = Transforms.eastNorthUpToFixedFrame(\n    ecefCenter,\n    Ellipsoid.WGS84,\n    new Matrix4(),\n  );\n  const toLocal = Matrix4.inverseTransformation(toGlobal, new Matrix4());\n\n  const primitives = [];\n\n  if (hasLines) {\n    primitives.push(createLinesPrimitive(features, toLocal, frameState));\n  }\n\n  if (hasPoints) {\n    primitives.push(createPointsPrimitive(features, toLocal, frameState));\n  }\n\n  const node = new ModelComponents.Node();\n  node.index = 0;\n  node.primitives = primitives;\n\n  const nodes = [node];\n\n  const scene = new ModelComponents.Scene();\n  scene.nodes = nodes;\n\n  const components = new ModelComponents.Components();\n  components.scene = scene;\n  components.nodes = nodes;\n  components.transform = toGlobal;\n  components.structuralMetadata = structuralMetadata;\n\n  return components;\n}\n\n/**\n * Unloads the resource.\n * @private\n */\nGeoJsonLoader.prototype.unload = function () {\n  this._components = undefined;\n};\n\nexport default GeoJsonLoader;\n"],"names":["GeoJsonLoader","options","EMPTY_OBJECT","typeOf","object","geoJson","_geoJson","_components","undefined","Object","create","prototype","defineProperties","cacheKey","get","components","load","Promise","resolve","process","frameState","parse","ParsedFeature","lines","points","properties","ParseResult","features","parsePosition","position","x","y","z","parseLineString","coordinates","positionsLength","length","line","Array","i","parseMultiLineString","linesLength","parsePolygon","parseMultiPolygon","polygonsLength","polygon","parsePoint","parseMultiPoint","pointsLength","geometryTypes","LineString","MultiLineString","MultiPolygon","Polygon","MultiPoint","Point","primitiveTypes","LINES","POINTS","parseFeature","feature","result","geometry","geometryType","type","geometryFunction","primitiveType","parsedFeature","push","parseFeatureCollection","featureCollection","featuresLength","geoJsonObjectTypes","FeatureCollection","Feature","scratchCartesian","createLinesPrimitive","toLocal","vertexCount","indexCount","featureCount","j","positionsTypedArray","Float32Array","featureIdsTypedArray","indicesTypedArray","createTypedArray","indexDatatype","fromTypedArray","localMin","Number","POSITIVE_INFINITY","localMax","NEGATIVE_INFINITY","vertexCounter","segmentCounter","k","cartographic","globalCartesian","fromDegrees","WGS84","localCartesian","multiplyByPoint","minimumByComponent","maximumByComponent","pack","positionBuffer","createVertexBuffer","typedArray","context","usage","STATIC_DRAW","vertexArrayDestroyable","featureIdBuffer","indexBuffer","createIndexBuffer","positionAttribute","Attribute","semantic","POSITION","componentDatatype","FLOAT","VEC3","count","min","max","buffer","featureIdAttribute","FEATURE_ID","setIndex","SCALAR","attributes","material","Material","unlit","indices","Indices","featureId","FeatureIdAttribute","propertyTableId","positionalLabel","featureIds","primitive","Primitive","createPointsPrimitive","parseFunction","featureProperties","propertyId","hasOwnProperty","value","jsonMetadataTable","propertyTable","id","propertyTables","schema","fromJson","structuralMetadata","cartographicMin","cartographicMax","hasLines","hasPoints","point","cartographicCenter","midpoint","ecefCenter","toGlobal","eastNorthUpToFixedFrame","inverseTransformation","primitives","node","Node","index","nodes","scene","Scene","Components","transform","unload"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3370, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/I3dmLoader.js"],"sourcesContent":["import AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport clone from \"../../Core/clone.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport Ellipsoid from \"../../Core/Ellipsoid.js\";\nimport getStringFromTypedArray from \"../../Core/getStringFromTypedArray.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport Axis from \"../Axis.js\";\nimport Cesium3DTileFeatureTable from \"../Cesium3DTileFeatureTable.js\";\nimport GltfLoader from \"../GltfLoader.js\";\nimport InstanceAttributeSemantic from \"../InstanceAttributeSemantic.js\";\nimport I3dmParser from \"../I3dmParser.js\";\nimport MetadataClass from \"../MetadataClass.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport parseBatchTable from \"../parseBatchTable.js\";\nimport PropertyTable from \"../PropertyTable.js\";\nimport ResourceLoader from \"../ResourceLoader.js\";\nimport StructuralMetadata from \"../StructuralMetadata.js\";\n\nconst I3dmLoaderState = {\n  NOT_LOADED: 0,\n  LOADING: 1,\n  PROCESSING: 2,\n  POST_PROCESSING: 3,\n  READY: 4,\n  FAILED: 5,\n  UNLOADED: 6,\n};\n\nconst Attribute = ModelComponents.Attribute;\nconst FeatureIdAttribute = ModelComponents.FeatureIdAttribute;\nconst Instances = ModelComponents.Instances;\n\n/**\n * Loads an Instanced 3D Model.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias I3dmLoader\n * @constructor\n * @augments ResourceLoader\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.i3dmResource The {@link Resource} containing the i3dm.\n * @param {ArrayBuffer} options.arrayBuffer The array buffer of the i3dm contents.\n * @param {number} [options.byteOffset=0] The byte offset to the beginning of the i3dm contents in the array buffer.\n * @param {Resource} [options.baseResource] The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {boolean} [options.releaseGltfJson=false] When true, the glTF JSON is released once the glTF is loaded. This is is especially useful for cases like 3D Tiles, where each .gltf model is unique and caching the glTF JSON is not effective.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the glTF is loaded.\n * @param {Axis} [options.upAxis=Axis.Y] The up-axis of the glTF model.\n * @param {Axis} [options.forwardAxis=Axis.X] The forward-axis of the glTF model.\n * @param {boolean} [options.loadAttributesAsTypedArray=false] Load all attributes as typed arrays instead of GPU buffers. If the attributes are interleaved in the glTF they will be de-interleaved in the typed array.\n * @param {boolean} [options.enablePick=false]  If <code>true</code>, load the positions buffer, any instanced attribute buffers, and index buffer as typed arrays for CPU-enabled picking in WebGL1.\n * @param {boolean} [options.loadIndicesForWireframe=false] Load the index buffer as a typed array so wireframe indices can be created for WebGL1.\n * @param {boolean} [options.loadPrimitiveOutline=true] If true, load outlines from the {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/CESIUM_primitive_outline|CESIUM_primitive_outline} extension. This can be set false to avoid post-processing geometry at load time.\n */\nfunction I3dmLoader(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const i3dmResource = options.i3dmResource;\n  const arrayBuffer = options.arrayBuffer;\n  let baseResource = options.baseResource;\n  const byteOffset = options.byteOffset ?? 0;\n  const releaseGltfJson = options.releaseGltfJson ?? false;\n  const asynchronous = options.asynchronous ?? true;\n  const incrementallyLoadTextures = options.incrementallyLoadTextures ?? true;\n  const upAxis = options.upAxis ?? Axis.Y;\n  const forwardAxis = options.forwardAxis ?? Axis.X;\n  const loadAttributesAsTypedArray =\n    options.loadAttributesAsTypedArray ?? false;\n  const loadIndicesForWireframe = options.loadIndicesForWireframe ?? false;\n  const loadPrimitiveOutline = options.loadPrimitiveOutline ?? true;\n  const enablePick = options.enablePick ?? false;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.i3dmResource\", i3dmResource);\n  Check.typeOf.object(\"options.arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  baseResource = defined(baseResource) ? baseResource : i3dmResource.clone();\n\n  this._i3dmResource = i3dmResource;\n  this._baseResource = baseResource;\n  this._arrayBuffer = arrayBuffer;\n  this._byteOffset = byteOffset;\n  this._releaseGltfJson = releaseGltfJson;\n  this._asynchronous = asynchronous;\n  this._incrementallyLoadTextures = incrementallyLoadTextures;\n  this._upAxis = upAxis;\n  this._forwardAxis = forwardAxis;\n  this._loadAttributesAsTypedArray = loadAttributesAsTypedArray;\n  this._loadIndicesForWireframe = loadIndicesForWireframe;\n  this._loadPrimitiveOutline = loadPrimitiveOutline;\n  this._enablePick = enablePick;\n\n  this._state = I3dmLoaderState.NOT_LOADED;\n  this._promise = undefined;\n\n  this._gltfLoader = undefined;\n\n  // Instanced attributes are initially parsed as typed arrays, but if they\n  // do not need to be further processed (e.g. turned into transform matrices),\n  // it is more efficient to turn them into buffers. The I3dmLoader will own the\n  // resources and store them here.\n  this._buffers = [];\n  this._components = undefined;\n\n  this._transform = Matrix4.IDENTITY;\n  this._batchTable = undefined;\n  this._featureTable = undefined;\n  this._instancesLength = 0;\n}\n\nif (defined(Object.create)) {\n  I3dmLoader.prototype = Object.create(ResourceLoader.prototype);\n  I3dmLoader.prototype.constructor = I3dmLoader;\n}\n\nObject.defineProperties(I3dmLoader.prototype, {\n  /**\n   * true if textures are loaded, useful when incrementallyLoadTextures is true\n   *\n   * @memberof  I3dmLoader.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  texturesLoaded: {\n    get: function () {\n      return this._gltfLoader?.texturesLoaded;\n    },\n  },\n  /**\n   * The cache key of the resource\n   *\n   * @memberof I3dmLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * The loaded components.\n   *\n   * @memberof I3dmLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @default {@link Matrix4.IDENTITY}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise<I3dmLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nI3dmLoader.prototype.load = function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n\n  // Parse the i3dm into its various sections.\n  const i3dm = I3dmParser.parse(this._arrayBuffer, this._byteOffset);\n\n  const featureTableJson = i3dm.featureTableJson;\n  const featureTableBinary = i3dm.featureTableBinary;\n  const batchTableJson = i3dm.batchTableJson;\n  const batchTableBinary = i3dm.batchTableBinary;\n  const gltfFormat = i3dm.gltfFormat;\n\n  // Generate the feature table.\n  const featureTable = new Cesium3DTileFeatureTable(\n    featureTableJson,\n    featureTableBinary,\n  );\n  this._featureTable = featureTable;\n\n  // Get the number of instances in the i3dm.\n  const instancesLength = featureTable.getGlobalProperty(\"INSTANCES_LENGTH\");\n  featureTable.featuresLength = instancesLength;\n  if (!defined(instancesLength)) {\n    throw new RuntimeError(\n      \"Feature table global property: INSTANCES_LENGTH must be defined\",\n    );\n  }\n  this._instancesLength = instancesLength;\n\n  // Get the RTC center, if available, and set the loader's transform.\n  const rtcCenter = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3,\n  );\n  if (defined(rtcCenter)) {\n    this._transform = Matrix4.fromTranslation(Cartesian3.fromArray(rtcCenter));\n  }\n\n  // Save the batch table section to use for StructuralMetadata generation.\n  this._batchTable = {\n    json: batchTableJson,\n    binary: batchTableBinary,\n  };\n\n  const loaderOptions = {\n    upAxis: this._upAxis,\n    forwardAxis: this._forwardAxis,\n    releaseGltfJson: this._releaseGltfJson,\n    incrementallyLoadTextures: this._incrementallyLoadTextures,\n    loadAttributesAsTypedArray: this._loadAttributesAsTypedArray,\n    enablePick: this._enablePick,\n    loadIndicesForWireframe: this._loadIndicesForWireframe,\n    loadPrimitiveOutline: this._loadPrimitiveOutline,\n  };\n\n  if (gltfFormat === 0) {\n    let gltfUrl = getStringFromTypedArray(i3dm.gltf);\n\n    // We need to remove padding from the end of the model URL in case this tile was part of a composite tile.\n    // This removes all white space and null characters from the end of the string.\n    gltfUrl = gltfUrl.replace(/[\\s\\0]+$/, \"\");\n    const gltfResource = this._baseResource.getDerivedResource({\n      url: gltfUrl,\n    });\n    loaderOptions.gltfResource = gltfResource;\n    loaderOptions.baseResource = gltfResource;\n  } else {\n    loaderOptions.gltfResource = this._i3dmResource;\n    loaderOptions.typedArray = i3dm.gltf;\n  }\n\n  // Create the GltfLoader, update the state and load the glTF.\n  const gltfLoader = new GltfLoader(loaderOptions);\n\n  this._gltfLoader = gltfLoader;\n  this._state = I3dmLoaderState.LOADING;\n\n  this._promise = gltfLoader\n    .load()\n    .then(() => {\n      if (this.isDestroyed()) {\n        return;\n      }\n\n      this._state = I3dmLoaderState.PROCESSING;\n      return this;\n    })\n    .catch((error) => {\n      if (this.isDestroyed()) {\n        return;\n      }\n      throw handleError(this, error);\n    });\n\n  return this._promise;\n};\n\nfunction handleError(i3dmLoader, error) {\n  i3dmLoader.unload();\n  i3dmLoader._state = I3dmLoaderState.FAILED;\n  const errorMessage = \"Failed to load i3dm\";\n  return i3dmLoader.getError(errorMessage, error);\n}\n\nI3dmLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === I3dmLoaderState.READY) {\n    return true;\n  }\n\n  const gltfLoader = this._gltfLoader;\n  let ready = false;\n  if (this._state === I3dmLoaderState.PROCESSING) {\n    ready = gltfLoader.process(frameState);\n  }\n\n  if (!ready) {\n    return false;\n  }\n\n  const components = gltfLoader.components;\n\n  // Combine the RTC_CENTER transform from the i3dm and the CESIUM_RTC\n  // transform from the glTF. In practice CESIUM_RTC is not set for\n  // instanced models but multiply the transforms just in case.\n  components.transform = Matrix4.multiplyTransformation(\n    this._transform,\n    components.transform,\n    components.transform,\n  );\n\n  createInstances(this, components, frameState);\n  createStructuralMetadata(this, components);\n  this._components = components;\n\n  // Now that we have the parsed components, we can release the array buffer\n  this._arrayBuffer = undefined;\n\n  this._state = I3dmLoaderState.READY;\n  return true;\n};\n\nfunction createStructuralMetadata(loader, components) {\n  const batchTable = loader._batchTable;\n  const instancesLength = loader._instancesLength;\n\n  if (instancesLength === 0) {\n    return;\n  }\n\n  let structuralMetadata;\n  if (defined(batchTable.json)) {\n    // Add the structural metadata from the batch table to the model components.\n    structuralMetadata = parseBatchTable({\n      count: instancesLength,\n      batchTable: batchTable.json,\n      binaryBody: batchTable.binary,\n    });\n  } else {\n    // If batch table is not defined, create a property table without any properties.\n    const emptyPropertyTable = new PropertyTable({\n      name: MetadataClass.BATCH_TABLE_CLASS_NAME,\n      count: instancesLength,\n    });\n    structuralMetadata = new StructuralMetadata({\n      schema: {},\n      propertyTables: [emptyPropertyTable],\n    });\n  }\n\n  components.structuralMetadata = structuralMetadata;\n}\n\nconst positionScratch = new Cartesian3();\nconst propertyScratch1 = new Array(4);\nconst transformScratch = new Matrix4();\n\nfunction createInstances(loader, components, frameState) {\n  let i;\n  const featureTable = loader._featureTable;\n  const instancesLength = loader._instancesLength;\n\n  if (instancesLength === 0) {\n    return;\n  }\n\n  const rtcCenter = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3,\n  );\n\n  const eastNorthUp = featureTable.getGlobalProperty(\"EAST_NORTH_UP\");\n  const hasRotation =\n    featureTable.hasProperty(\"NORMAL_UP\") ||\n    featureTable.hasProperty(\"NORMAL_UP_OCT32P\") ||\n    eastNorthUp;\n\n  const hasScale =\n    featureTable.hasProperty(\"SCALE\") ||\n    featureTable.hasProperty(\"SCALE_NON_UNIFORM\");\n\n  const translationTypedArray = getPositions(featureTable, instancesLength);\n  let rotationTypedArray;\n  if (hasRotation) {\n    rotationTypedArray = new Float32Array(4 * instancesLength);\n  }\n  let scaleTypedArray;\n  if (hasScale) {\n    scaleTypedArray = new Float32Array(3 * instancesLength);\n  }\n  const featureIdArray = new Float32Array(instancesLength);\n\n  const instancePositions = Cartesian3.unpackArray(translationTypedArray);\n  let instancePosition = new Cartesian3();\n\n  const instanceNormalRight = new Cartesian3();\n  const instanceNormalUp = new Cartesian3();\n  const instanceNormalForward = new Cartesian3();\n  const instanceRotation = new Matrix3();\n  const instanceQuaternion = new Quaternion();\n  const instanceQuaternionArray = new Array(4);\n\n  const instanceScale = new Cartesian3();\n  const instanceScaleArray = new Array(3);\n\n  const instanceTransform = new Matrix4();\n\n  // For I3DMs that do not define an RTC center, we manually compute a BoundingSphere and store\n  // positions relative to the center, to be uploaded to the GPU. This avoids jittering at higher\n  // precisions.\n  // Also manually compute if RTC center equals Cartesian3.ZERO\n  if (\n    !defined(rtcCenter) ||\n    Cartesian3.equals(Cartesian3.unpack(rtcCenter), Cartesian3.ZERO)\n  ) {\n    const positionBoundingSphere = BoundingSphere.fromPoints(instancePositions);\n\n    for (i = 0; i < instancePositions.length; i++) {\n      Cartesian3.subtract(\n        instancePositions[i],\n        positionBoundingSphere.center,\n        positionScratch,\n      );\n\n      translationTypedArray[3 * i + 0] = positionScratch.x;\n      translationTypedArray[3 * i + 1] = positionScratch.y;\n      translationTypedArray[3 * i + 2] = positionScratch.z;\n    }\n\n    // Set the center of the bounding sphere as the RTC center transform.\n    const centerTransform = Matrix4.fromTranslation(\n      positionBoundingSphere.center,\n      transformScratch,\n    );\n\n    // Combine the center transform and the CESIUM_RTC transform from the glTF.\n    // In practice CESIUM_RTC is not set for instanced models but multiply the\n    // transforms just in case.\n    components.transform = Matrix4.multiplyTransformation(\n      centerTransform,\n      components.transform,\n      components.transform,\n    );\n  }\n\n  for (i = 0; i < instancesLength; i++) {\n    // Get the instance position\n    instancePosition = Cartesian3.clone(instancePositions[i]);\n\n    if (defined(rtcCenter)) {\n      Cartesian3.add(\n        instancePosition,\n        Cartesian3.unpack(rtcCenter),\n        instancePosition,\n      );\n    }\n\n    // Get the instance rotation, if present\n    if (hasRotation) {\n      processRotation(\n        featureTable,\n        eastNorthUp,\n        i,\n        instanceQuaternion,\n        instancePosition,\n        instanceNormalUp,\n        instanceNormalRight,\n        instanceNormalForward,\n        instanceRotation,\n        instanceTransform,\n      );\n      Quaternion.pack(instanceQuaternion, instanceQuaternionArray, 0);\n      rotationTypedArray[4 * i + 0] = instanceQuaternionArray[0];\n      rotationTypedArray[4 * i + 1] = instanceQuaternionArray[1];\n      rotationTypedArray[4 * i + 2] = instanceQuaternionArray[2];\n      rotationTypedArray[4 * i + 3] = instanceQuaternionArray[3];\n    }\n\n    // Get the instance scale, if present\n    if (hasScale) {\n      processScale(featureTable, i, instanceScale);\n      Cartesian3.pack(instanceScale, instanceScaleArray, 0);\n      scaleTypedArray[3 * i + 0] = instanceScaleArray[0];\n      scaleTypedArray[3 * i + 1] = instanceScaleArray[1];\n      scaleTypedArray[3 * i + 2] = instanceScaleArray[2];\n    }\n\n    // Get the batchId\n    let batchId = featureTable.getProperty(\n      \"BATCH_ID\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      1,\n      i,\n    );\n    if (!defined(batchId)) {\n      // If BATCH_ID semantic is undefined, batchId is just the instance number\n      batchId = i;\n    }\n    featureIdArray[i] = batchId;\n  }\n\n  // Create instances.\n  const instances = new Instances();\n  instances.transformInWorldSpace = true;\n  const buffers = loader._buffers;\n\n  // Create translation vertex attribute.\n  const translationAttribute = new Attribute();\n  translationAttribute.name = \"Instance Translation\";\n  translationAttribute.semantic = InstanceAttributeSemantic.TRANSLATION;\n  translationAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  translationAttribute.type = AttributeType.VEC3;\n  translationAttribute.count = instancesLength;\n  // The min / max values of the translation attribute need to be computed\n  // by the model pipeline, so so a pointer to the typed array is stored.\n  translationAttribute.typedArray = translationTypedArray;\n  // If there is no rotation attribute, however, the translations can also be\n  // loaded as a buffer to prevent additional resource creation in the pipeline.\n  if (!hasRotation) {\n    const buffer = Buffer.createVertexBuffer({\n      context: frameState.context,\n      typedArray: translationTypedArray,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    // Destruction of resources is handled by I3dmLoader.unload().\n    buffer.vertexArrayDestroyable = false;\n    buffers.push(buffer);\n\n    translationAttribute.buffer = buffer;\n  }\n\n  instances.attributes.push(translationAttribute);\n\n  // Create rotation vertex attribute.\n  if (hasRotation) {\n    const rotationAttribute = new Attribute();\n    rotationAttribute.name = \"Instance Rotation\";\n    rotationAttribute.semantic = InstanceAttributeSemantic.ROTATION;\n    rotationAttribute.componentDatatype = ComponentDatatype.FLOAT;\n    rotationAttribute.type = AttributeType.VEC4;\n    rotationAttribute.count = instancesLength;\n    rotationAttribute.typedArray = rotationTypedArray;\n    instances.attributes.push(rotationAttribute);\n  }\n\n  // Create scale vertex attribute.\n  if (hasScale) {\n    const scaleAttribute = new Attribute();\n    scaleAttribute.name = \"Instance Scale\";\n    scaleAttribute.semantic = InstanceAttributeSemantic.SCALE;\n    scaleAttribute.componentDatatype = ComponentDatatype.FLOAT;\n    scaleAttribute.type = AttributeType.VEC3;\n    scaleAttribute.count = instancesLength;\n    if (hasRotation) {\n      // If rotations are present, all transform attributes are loaded\n      // as typed arrays to compute transform matrices for the model.\n      scaleAttribute.typedArray = scaleTypedArray;\n    } else {\n      const buffer = Buffer.createVertexBuffer({\n        context: frameState.context,\n        typedArray: scaleTypedArray,\n        usage: BufferUsage.STATIC_DRAW,\n      });\n      // Destruction of resources is handled by I3dmLoader.unload().\n      buffer.vertexArrayDestroyable = false;\n      buffers.push(buffer);\n\n      scaleAttribute.buffer = buffer;\n    }\n\n    instances.attributes.push(scaleAttribute);\n  }\n\n  // Create feature ID vertex attribute.\n  const featureIdAttribute = new Attribute();\n  featureIdAttribute.name = \"Instance Feature ID\";\n  featureIdAttribute.setIndex = 0;\n  featureIdAttribute.semantic = InstanceAttributeSemantic.FEATURE_ID;\n  featureIdAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  featureIdAttribute.type = AttributeType.SCALAR;\n  featureIdAttribute.count = instancesLength;\n  const buffer = Buffer.createVertexBuffer({\n    context: frameState.context,\n    typedArray: featureIdArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  // Destruction of resources is handled by I3dmLoader.unload().\n  buffer.vertexArrayDestroyable = false;\n  buffers.push(buffer);\n  featureIdAttribute.buffer = buffer;\n\n  instances.attributes.push(featureIdAttribute);\n\n  // Create feature ID attribute.\n  const featureIdInstanceAttribute = new FeatureIdAttribute();\n  featureIdInstanceAttribute.propertyTableId = 0;\n  featureIdInstanceAttribute.setIndex = 0;\n  featureIdInstanceAttribute.positionalLabel = \"instanceFeatureId_0\";\n  instances.featureIds.push(featureIdInstanceAttribute);\n\n  // Apply instancing to every node that has at least one primitive.\n  const nodes = components.nodes;\n  const nodesLength = nodes.length;\n  let makeInstancesCopy = false;\n  for (i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if (node.primitives.length > 0) {\n      // If the instances have not been assigned to a node already, assign\n      // it to the first node encountered. Otherwise, make a copy of them\n      // for each subsequent node.\n      node.instances = makeInstancesCopy\n        ? createInstancesCopy(instances)\n        : instances;\n\n      makeInstancesCopy = true;\n    }\n  }\n}\n\n/**\n * Returns a copy of the instances that contains shallow copies of the instanced\n * attributes. That is, the instances and attribute objects will be new copies,\n * but they will point to the same buffers and typed arrays. This is so each\n * node can manage memory separately, such that unloading memory for one\n * node does not unload it for another.\n *\n * @returns {ModelComponents.Instances}\n *\n * @private\n */\nfunction createInstancesCopy(instances) {\n  const instancesCopy = new Instances();\n  instancesCopy.transformInWorldSpace = instances.transformInWorldSpace;\n\n  const attributes = instances.attributes;\n  const attributesLength = attributes.length;\n\n  for (let i = 0; i < attributesLength; i++) {\n    const attributeCopy = clone(attributes[i], false);\n    instancesCopy.attributes.push(attributeCopy);\n  }\n\n  instancesCopy.featureIds = instances.featureIds;\n\n  return instancesCopy;\n}\n\n/**\n * Returns a typed array of positions from the i3dm's feature table. The positions\n * returned are dequantized, if dequantization is applied.\n *\n * @private\n */\nfunction getPositions(featureTable, instancesLength) {\n  if (featureTable.hasProperty(\"POSITION\")) {\n    // Handle positions.\n    return featureTable.getPropertyArray(\n      \"POSITION\",\n      ComponentDatatype.FLOAT,\n      3,\n    );\n  } else if (featureTable.hasProperty(\"POSITION_QUANTIZED\")) {\n    // Handle quantized positions.\n    const quantizedPositions = featureTable.getPropertyArray(\n      \"POSITION_QUANTIZED\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      3,\n    );\n\n    const quantizedVolumeOffset = featureTable.getGlobalProperty(\n      \"QUANTIZED_VOLUME_OFFSET\",\n      ComponentDatatype.FLOAT,\n      3,\n    );\n    if (!defined(quantizedVolumeOffset)) {\n      throw new RuntimeError(\n        \"Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\",\n      );\n    }\n\n    const quantizedVolumeScale = featureTable.getGlobalProperty(\n      \"QUANTIZED_VOLUME_SCALE\",\n      ComponentDatatype.FLOAT,\n      3,\n    );\n    if (!defined(quantizedVolumeScale)) {\n      throw new RuntimeError(\n        \"Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\",\n      );\n    }\n\n    const decodedPositions = new Float32Array(quantizedPositions.length);\n    for (let i = 0; i < quantizedPositions.length / 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        const index = 3 * i + j;\n        decodedPositions[index] =\n          (quantizedPositions[index] / 65535.0) * quantizedVolumeScale[j] +\n          quantizedVolumeOffset[j];\n      }\n    }\n\n    return decodedPositions;\n\n    // eslint-disable-next-line no-else-return\n  } else {\n    throw new RuntimeError(\n      \"Either POSITION or POSITION_QUANTIZED must be defined for each instance.\",\n    );\n  }\n}\n\nconst propertyScratch2 = new Array(4);\nfunction processRotation(\n  featureTable,\n  eastNorthUp,\n  i,\n  instanceQuaternion,\n  instancePosition,\n  instanceNormalUp,\n  instanceNormalRight,\n  instanceNormalForward,\n  instanceRotation,\n  instanceTransform,\n) {\n  // Get the instance rotation\n  const normalUp = featureTable.getProperty(\n    \"NORMAL_UP\",\n    ComponentDatatype.FLOAT,\n    3,\n    i,\n    propertyScratch1,\n  );\n  const normalRight = featureTable.getProperty(\n    \"NORMAL_RIGHT\",\n    ComponentDatatype.FLOAT,\n    3,\n    i,\n    propertyScratch2,\n  );\n  let hasCustomOrientation = false;\n  if (defined(normalUp)) {\n    if (!defined(normalRight)) {\n      throw new RuntimeError(\n        \"To define a custom orientation, both NORMAL_UP and NORMAL_RIGHT must be defined.\",\n      );\n    }\n    Cartesian3.unpack(normalUp, 0, instanceNormalUp);\n    Cartesian3.unpack(normalRight, 0, instanceNormalRight);\n    hasCustomOrientation = true;\n  } else {\n    const octNormalUp = featureTable.getProperty(\n      \"NORMAL_UP_OCT32P\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      2,\n      i,\n      propertyScratch1,\n    );\n    const octNormalRight = featureTable.getProperty(\n      \"NORMAL_RIGHT_OCT32P\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      2,\n      i,\n      propertyScratch2,\n    );\n    if (defined(octNormalUp)) {\n      if (!defined(octNormalRight)) {\n        throw new RuntimeError(\n          \"To define a custom orientation with oct-encoded vectors, both NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P must be defined.\",\n        );\n      }\n      AttributeCompression.octDecodeInRange(\n        octNormalUp[0],\n        octNormalUp[1],\n        65535,\n        instanceNormalUp,\n      );\n      AttributeCompression.octDecodeInRange(\n        octNormalRight[0],\n        octNormalRight[1],\n        65535,\n        instanceNormalRight,\n      );\n      hasCustomOrientation = true;\n    } else if (eastNorthUp) {\n      Transforms.eastNorthUpToFixedFrame(\n        instancePosition,\n        Ellipsoid.WGS84,\n        instanceTransform,\n      );\n      Matrix4.getMatrix3(instanceTransform, instanceRotation);\n    } else {\n      Matrix3.clone(Matrix3.IDENTITY, instanceRotation);\n    }\n  }\n  if (hasCustomOrientation) {\n    Cartesian3.cross(\n      instanceNormalRight,\n      instanceNormalUp,\n      instanceNormalForward,\n    );\n    Cartesian3.normalize(instanceNormalForward, instanceNormalForward);\n    Matrix3.setColumn(\n      instanceRotation,\n      0,\n      instanceNormalRight,\n      instanceRotation,\n    );\n    Matrix3.setColumn(instanceRotation, 1, instanceNormalUp, instanceRotation);\n    Matrix3.setColumn(\n      instanceRotation,\n      2,\n      instanceNormalForward,\n      instanceRotation,\n    );\n  }\n  Quaternion.fromRotationMatrix(instanceRotation, instanceQuaternion);\n}\n\nfunction processScale(featureTable, i, instanceScale) {\n  instanceScale = Cartesian3.fromElements(1.0, 1.0, 1.0, instanceScale);\n  const scale = featureTable.getProperty(\n    \"SCALE\",\n    ComponentDatatype.FLOAT,\n    1,\n    i,\n  );\n  if (defined(scale)) {\n    Cartesian3.multiplyByScalar(instanceScale, scale, instanceScale);\n  }\n  const nonUniformScale = featureTable.getProperty(\n    \"SCALE_NON_UNIFORM\",\n    ComponentDatatype.FLOAT,\n    3,\n    i,\n    propertyScratch1,\n  );\n  if (defined(nonUniformScale)) {\n    instanceScale.x *= nonUniformScale[0];\n    instanceScale.y *= nonUniformScale[1];\n    instanceScale.z *= nonUniformScale[2];\n  }\n}\n\nfunction unloadBuffers(loader) {\n  const buffers = loader._buffers;\n  const length = buffers.length;\n  for (let i = 0; i < length; i++) {\n    const buffer = buffers[i];\n    if (!buffer.isDestroyed()) {\n      buffer.destroy();\n    }\n  }\n  buffers.length = 0;\n}\n\nI3dmLoader.prototype.isUnloaded = function () {\n  return this._state === I3dmLoaderState.UNLOADED;\n};\n\nI3dmLoader.prototype.unload = function () {\n  if (defined(this._gltfLoader) && !this._gltfLoader.isDestroyed()) {\n    this._gltfLoader.unload();\n  }\n\n  unloadBuffers(this);\n\n  this._components = undefined;\n  this._arrayBuffer = undefined;\n  this._state = I3dmLoaderState.UNLOADED;\n};\n\nexport default I3dmLoader;\n"],"names":["I3dmLoaderState","NOT_LOADED","LOADING","PROCESSING","POST_PROCESSING","READY","FAILED","UNLOADED","Attribute","FeatureIdAttribute","Instances","I3dmLoader","options","EMPTY_OBJECT","i3dmResource","arrayBuffer","baseResource","byteOffset","releaseGltfJson","asynchronous","incrementallyLoadTextures","upAxis","Y","forwardAxis","X","loadAttributesAsTypedArray","loadIndicesForWireframe","loadPrimitiveOutline","enablePick","typeOf","object","clone","_i3dmResource","_baseResource","_arrayBuffer","_byteOffset","_releaseGltfJson","_asynchronous","_incrementallyLoadTextures","_upAxis","_forwardAxis","_loadAttributesAsTypedArray","_loadIndicesForWireframe","_loadPrimitiveOutline","_enablePick","_state","_promise","undefined","_gltfLoader","_buffers","_components","_transform","IDENTITY","_batchTable","_featureTable","_instancesLength","Object","create","prototype","defineProperties","texturesLoaded","get","cacheKey","components","load","i3dm","parse","featureTableJson","featureTableBinary","batchTableJson","batchTableBinary","gltfFormat","featureTable","instancesLength","getGlobalProperty","featuresLength","rtcCenter","FLOAT","fromTranslation","fromArray","json","binary","loaderOptions","gltfUrl","gltf","replace","gltfResource","getDerivedResource","url","typedArray","gltfLoader","then","isDestroyed","catch","error","handleError","i3dmLoader","unload","errorMessage","getError","process","frameState","ready","transform","multiplyTransformation","createInstances","createStructuralMetadata","loader","batchTable","structuralMetadata","count","binaryBody","emptyPropertyTable","name","BATCH_TABLE_CLASS_NAME","schema","propertyTables","positionScratch","propertyScratch1","Array","transformScratch","i","eastNorthUp","hasRotation","hasProperty","hasScale","translationTypedArray","getPositions","rotationTypedArray","Float32Array","scaleTypedArray","featureIdArray","instancePositions","unpackArray","instancePosition","instanceNormalRight","instanceNormalUp","instanceNormalForward","instanceRotation","instanceQuaternion","instanceQuaternionArray","instanceScale","instanceScaleArray","instanceTransform","equals","unpack","ZERO","positionBoundingSphere","fromPoints","length","subtract","center","x","y","z","centerTransform","add","processRotation","pack","processScale","batchId","getProperty","UNSIGNED_SHORT","instances","transformInWorldSpace","buffers","translationAttribute","semantic","TRANSLATION","componentDatatype","type","VEC3","buffer","createVertexBuffer","context","usage","STATIC_DRAW","vertexArrayDestroyable","push","attributes","rotationAttribute","ROTATION","VEC4","scaleAttribute","SCALE","featureIdAttribute","setIndex","FEATURE_ID","SCALAR","featureIdInstanceAttribute","propertyTableId","positionalLabel","featureIds","nodes","nodesLength","makeInstancesCopy","node","primitives","createInstancesCopy","instancesCopy","attributesLength","attributeCopy","getPropertyArray","quantizedPositions","quantizedVolumeOffset","quantizedVolumeScale","decodedPositions","j","index","propertyScratch2","normalUp","normalRight","hasCustomOrientation","octNormalUp","octNormalRight","octDecodeInRange","eastNorthUpToFixedFrame","WGS84","getMatrix3","cross","normalize","setColumn","fromRotationMatrix","fromElements","scale","multiplyByScalar","nonUniformScale","unloadBuffers","destroy","isUnloaded"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4025, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelAnimationChannel.js"],"sourcesContent":["import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport ConstantSpline from \"../../Core/ConstantSpline.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport HermiteSpline from \"../../Core/HermiteSpline.js\";\nimport InterpolationType from \"../../Core/InterpolationType.js\";\nimport LinearSpline from \"../../Core/LinearSpline.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport SteppedSpline from \"../../Core/SteppedSpline.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport QuaternionSpline from \"../../Core/QuaternionSpline.js\";\n\nconst AnimatedPropertyType = ModelComponents.AnimatedPropertyType;\n\n/**\n * A runtime animation channel for a {@link ModelAnimation}. An animation\n * channel is responsible for interpolating between the keyframe values of an animated\n * property, then applying the change to the target node.\n *\n * @param {object} options An object containing the following options:\n * @param {ModelComponents.AnimationChannel} options.channel The corresponding animation channel components from the 3D model.\n * @param {ModelAnimation} options.runtimeAnimation The runtime animation containing this channel.\n * @param {ModelRuntimeNode} options.runtimeNode The runtime node that this channel will animate.\n *\n * @alias ModelAnimationChannel\n * @constructor\n *\n * @private\n */\nfunction ModelAnimationChannel(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const channel = options.channel;\n  const runtimeAnimation = options.runtimeAnimation;\n  const runtimeNode = options.runtimeNode;\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.channel\", channel);\n  Check.typeOf.object(\"options.runtimeAnimation\", runtimeAnimation);\n  Check.typeOf.object(\"options.runtimeNode\", runtimeNode);\n  //>>includeEnd('debug');\n\n  this._channel = channel;\n  this._runtimeAnimation = runtimeAnimation;\n  this._runtimeNode = runtimeNode;\n\n  // An animation channel can have multiple splines if it animates\n  // a node's morph weights, which will involve multiple morph targets.\n  this._splines = [];\n  this._path = undefined;\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelAnimationChannel.prototype, {\n  /**\n   * The glTF animation channel.\n   *\n   * @memberof ModelAnimationChannel.prototype\n   *\n   * @type {ModelComponents.AnimationChannel}\n   * @readonly\n   *\n   * @private\n   */\n  channel: {\n    get: function () {\n      return this._channel;\n    },\n  },\n\n  /**\n   * The runtime animation that owns this channel.\n   *\n   * @memberof ModelAnimationChannel.prototype\n   *\n   * @type {ModelAnimation}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeAnimation: {\n    get: function () {\n      return this._runtimeAnimation;\n    },\n  },\n\n  /**\n   * The runtime node that this channel animates.\n   *\n   * @memberof ModelAnimationChannel.prototype\n   *\n   * @type {ModelRuntimeNode}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeNode: {\n    get: function () {\n      return this._runtimeNode;\n    },\n  },\n\n  /**\n   * The splines used to evaluate this animation channel.\n   *\n   * @memberof ModelAnimationChannel.prototype\n   *\n   * @type {Spline[]}\n   * @readonly\n   *\n   * @private\n   */\n  splines: {\n    get: function () {\n      return this._splines;\n    },\n  },\n});\n\nfunction createCubicSpline(times, points) {\n  const cubicPoints = [];\n  const inTangents = [];\n  const outTangents = [];\n\n  const length = points.length;\n  for (let i = 0; i < length; i += 3) {\n    inTangents.push(points[i]);\n    cubicPoints.push(points[i + 1]);\n    outTangents.push(points[i + 2]);\n  }\n\n  // Remove the first in-tangent and last out-tangent, since they\n  // are not used in the spline calculations\n  inTangents.splice(0, 1);\n  outTangents.length = outTangents.length - 1;\n\n  return new HermiteSpline({\n    times: times,\n    points: cubicPoints,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n}\n\nfunction createSpline(times, points, interpolation, path) {\n  if (times.length === 1 && points.length === 1) {\n    return new ConstantSpline(points[0]);\n  }\n\n  switch (interpolation) {\n    case InterpolationType.STEP:\n      return new SteppedSpline({\n        times: times,\n        points: points,\n      });\n    case InterpolationType.CUBICSPLINE:\n      return createCubicSpline(times, points);\n    case InterpolationType.LINEAR:\n      if (path === AnimatedPropertyType.ROTATION) {\n        return new QuaternionSpline({\n          times: times,\n          points: points,\n        });\n      }\n      return new LinearSpline({\n        times: times,\n        points: points,\n      });\n  }\n}\n\nfunction createSplines(times, points, interpolation, path, count) {\n  const splines = [];\n  if (path === AnimatedPropertyType.WEIGHTS) {\n    const pointsLength = points.length;\n    // Get the number of keyframes in each weight's output.\n    const outputLength = pointsLength / count;\n\n    // Iterate over the array using the number of morph targets in the model.\n    let targetIndex, i;\n    for (targetIndex = 0; targetIndex < count; targetIndex++) {\n      const output = new Array(outputLength);\n\n      // Weights are ordered such that they are keyframed in the order in which\n      // their targets appear the glTF. For example, the weights of three targets\n      // may appear as [w(0,0), w(0,1), w(0,2), w(1,0), w(1,1), w(1,2) ...],\n      // where i and j in w(i,j) are the time indices and target indices, respectively.\n\n      // However, for morph targets with cubic interpolation, the data is stored per\n      // keyframe in the order [a1, a2, ..., an, v1, v2, ... vn, b1, b2, ..., bn],\n      // where ai, vi, and bi are the in-tangent, property, and out-tangents of\n      // the ith morph target respectively.\n      let pointsIndex = targetIndex;\n      if (interpolation === InterpolationType.CUBICSPLINE) {\n        for (i = 0; i < outputLength; i += 3) {\n          output[i] = points[pointsIndex];\n          output[i + 1] = points[pointsIndex + count];\n          output[i + 2] = points[pointsIndex + 2 * count];\n          pointsIndex += count * 3;\n        }\n      } else {\n        for (i = 0; i < outputLength; i++) {\n          output[i] = points[pointsIndex];\n          pointsIndex += count;\n        }\n      }\n\n      splines.push(createSpline(times, output, interpolation, path));\n    }\n  } else {\n    splines.push(createSpline(times, points, interpolation, path));\n  }\n\n  return splines;\n}\n\nconst scratchCartesian3 = new Cartesian3();\nconst scratchQuaternion = new Quaternion();\n\nfunction initialize(runtimeChannel) {\n  const channel = runtimeChannel._channel;\n\n  const sampler = channel.sampler;\n  const times = sampler.input;\n  const points = sampler.output;\n\n  const interpolation = sampler.interpolation;\n  const target = channel.target;\n  const path = target.path;\n\n  const runtimeNode = runtimeChannel._runtimeNode;\n  const count = defined(runtimeNode.morphWeights)\n    ? runtimeNode.morphWeights.length\n    : 1;\n  const splines = createSplines(times, points, interpolation, path, count);\n\n  runtimeChannel._splines = splines;\n  runtimeChannel._path = path;\n}\n\n/**\n * Animates the target node property based on its spline.\n *\n * @param {number} time The local animation time.\n *\n * @private\n */\nModelAnimationChannel.prototype.animate = function (time) {\n  const splines = this._splines;\n  const path = this._path;\n  const model = this._runtimeAnimation.model;\n  const runtimeNode = this._runtimeNode;\n\n  // Weights are handled differently than the other properties because\n  // they need to be updated in place.\n  if (path === AnimatedPropertyType.WEIGHTS) {\n    const morphWeights = runtimeNode.morphWeights;\n    const length = morphWeights.length;\n    for (let i = 0; i < length; i++) {\n      const spline = splines[i];\n      const localAnimationTime = model.clampAnimations\n        ? spline.clampTime(time)\n        : spline.wrapTime(time);\n      morphWeights[i] = spline.evaluate(localAnimationTime);\n    }\n  } else if (runtimeNode.userAnimated) {\n    // If the node is being animated externally, ignore the glTF animation.\n    return;\n  } else {\n    const spline = splines[0];\n    const localAnimationTime = model.clampAnimations\n      ? spline.clampTime(time)\n      : spline.wrapTime(time);\n\n    // This sets the translate, rotate, and scale properties.\n    if (\n      path === AnimatedPropertyType.TRANSLATION ||\n      path === AnimatedPropertyType.SCALE\n    ) {\n      runtimeNode[path] = spline.evaluate(\n        localAnimationTime,\n        scratchCartesian3,\n      );\n    } else if (path === AnimatedPropertyType.ROTATION) {\n      runtimeNode[path] = spline.evaluate(\n        localAnimationTime,\n        scratchQuaternion,\n      );\n    }\n  }\n};\n\nexport default ModelAnimationChannel;\n"],"names":["AnimatedPropertyType","ModelAnimationChannel","options","EMPTY_OBJECT","channel","runtimeAnimation","runtimeNode","typeOf","object","_channel","_runtimeAnimation","_runtimeNode","_splines","_path","undefined","initialize","Object","defineProperties","prototype","get","splines","createCubicSpline","times","points","cubicPoints","inTangents","outTangents","length","i","push","splice","createSpline","interpolation","path","STEP","CUBICSPLINE","LINEAR","ROTATION","createSplines","count","WEIGHTS","pointsLength","outputLength","targetIndex","output","Array","pointsIndex","scratchCartesian3","scratchQuaternion","runtimeChannel","sampler","input","target","morphWeights","animate","time","model","spline","localAnimationTime","clampAnimations","clampTime","wrapTime","evaluate","userAnimated","TRANSLATION","SCALE"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4286, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelAnimation.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport Event from \"../../Core/Event.js\";\nimport JulianDate from \"../../Core/JulianDate.js\";\nimport ModelAnimationLoop from \"../ModelAnimationLoop.js\";\nimport ModelAnimationState from \"../ModelAnimationState.js\";\nimport ModelAnimationChannel from \"./ModelAnimationChannel.js\";\n\n/**\n * <div class=\"notice\">\n * Create animations by calling {@link ModelAnimationCollection#add}. Do not call the constructor directly.\n * </div>\n *\n * An active animation derived from a glTF asset. An active animation is an\n * animation that is either currently playing or scheduled to be played due to\n * being added to a model's {@link ModelAnimationCollection}. An active animation\n * is an instance of an animation; for example, there can be multiple active\n * animations for the same glTF animation, each with a different start time.\n *\n * @alias ModelAnimation\n * @internalConstructor\n * @class\n *\n * @see ModelAnimationCollection#add\n */\nfunction ModelAnimation(model, animation, options) {\n  this._animation = animation;\n  this._name = animation.name;\n  this._runtimeChannels = undefined;\n\n  this._startTime = JulianDate.clone(options.startTime);\n  this._delay = options.delay ?? 0.0; // in seconds\n  this._stopTime = JulianDate.clone(options.stopTime);\n\n  /**\n   * When <code>true</code>, the animation is removed after it stops playing.\n   * This is slightly more efficient that not removing it, but if, for example,\n   * time is reversed, the animation is not played again.\n   *\n   * @type {boolean}\n   * @default false\n   */\n  this.removeOnStop = options.removeOnStop ?? false;\n  this._multiplier = options.multiplier ?? 1.0;\n  this._reverse = options.reverse ?? false;\n  this._loop = options.loop ?? ModelAnimationLoop.NONE;\n  this._animationTime = options.animationTime;\n  this._prevAnimationDelta = undefined;\n\n  /**\n   * The event fired when this animation is started.  This can be used, for\n   * example, to play a sound or start a particle system, when the animation starts.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * animation.start.addEventListener(function(model, animation) {\n   *   console.log(`Animation started: ${animation.name}`);\n   * });\n   */\n  this.start = new Event();\n\n  /**\n   * The event fired when on each frame when this animation is updated.  The\n   * current time of the animation, relative to the glTF animation time span, is\n   * passed to the event, which allows, for example, starting new animations at a\n   * specific time relative to a playing animation.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * animation.update.addEventListener(function(model, animation, time) {\n   *   console.log(`Animation updated: ${animation.name}. glTF animation time: ${time}`);\n   * });\n   */\n  this.update = new Event();\n\n  /**\n   * The event fired when this animation is stopped.  This can be used, for\n   * example, to play a sound or start a particle system, when the animation stops.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * animation.stop.addEventListener(function(model, animation) {\n   *   console.log(`Animation stopped: ${animation.name}`);\n   * });\n   */\n  this.stop = new Event();\n\n  this._state = ModelAnimationState.STOPPED;\n\n  // Set during animation update\n  this._computedStartTime = undefined;\n  this._duration = undefined;\n\n  // To avoid allocations in ModelAnimationCollection.update\n  const that = this;\n  this._raiseStartEvent = function () {\n    that.start.raiseEvent(model, that);\n  };\n  this._updateEventTime = 0.0;\n  this._raiseUpdateEvent = function () {\n    that.update.raiseEvent(model, that, that._updateEventTime);\n  };\n  this._raiseStopEvent = function () {\n    that.stop.raiseEvent(model, that);\n  };\n\n  this._model = model;\n\n  this._localStartTime = undefined;\n  this._localStopTime = undefined;\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelAnimation.prototype, {\n  /**\n   * The glTF animation.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {ModelComponents.Animation}\n   * @readonly\n   *\n   * @private\n   */\n  animation: {\n    get: function () {\n      return this._animation;\n    },\n  },\n\n  /**\n   * The name that identifies this animation in the model, if it exists.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {string}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The runtime animation channels for this animation.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {ModelAnimationChannel[]}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeChannels: {\n    get: function () {\n      return this._runtimeChannels;\n    },\n  },\n\n  /**\n   * The {@link Model} that owns this animation.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {Model}\n   * @readonly\n   *\n   * @private\n   */\n  model: {\n    get: function () {\n      return this._model;\n    },\n  },\n\n  /**\n   * The starting point of the animation in local animation time. This is the minimum\n   * time value across all of the keyframes belonging to this animation.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  localStartTime: {\n    get: function () {\n      return this._localStartTime;\n    },\n  },\n\n  /**\n   * The stopping point of the animation in local animation time. This is the maximum\n   * time value across all of the keyframes belonging to this animation.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  localStopTime: {\n    get: function () {\n      return this._localStopTime;\n    },\n  },\n\n  /**\n   * The scene time to start playing this animation. When this is <code>undefined</code>,\n   * the animation starts at the next frame.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {JulianDate}\n   * @readonly\n   *\n   * @default undefined\n   */\n  startTime: {\n    get: function () {\n      return this._startTime;\n    },\n  },\n\n  /**\n   * The delay, in seconds, from {@link ModelAnimation#startTime} to start playing.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @default undefined\n   */\n  delay: {\n    get: function () {\n      return this._delay;\n    },\n  },\n\n  /**\n   * The scene time to stop playing this animation. When this is <code>undefined</code>,\n   * the animation is played for its full duration and perhaps repeated depending on\n   * {@link ModelAnimation#loop}.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {JulianDate}\n   * @readonly\n   *\n   * @default undefined\n   */\n  stopTime: {\n    get: function () {\n      return this._stopTime;\n    },\n  },\n\n  /**\n   * Values greater than <code>1.0</code> increase the speed that the animation is played relative\n   * to the scene clock speed; values less than <code>1.0</code> decrease the speed.  A value of\n   * <code>1.0</code> plays the animation at the speed in the glTF animation mapped to the scene\n   * clock speed.  For example, if the scene is played at 2x real-time, a two-second glTF animation\n   * will play in one second even if <code>multiplier</code> is <code>1.0</code>.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @default 1.0\n   */\n  multiplier: {\n    get: function () {\n      return this._multiplier;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the animation is played in reverse.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  reverse: {\n    get: function () {\n      return this._reverse;\n    },\n  },\n\n  /**\n   * Determines if and how the animation is looped.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {ModelAnimationLoop}\n   * @readonly\n   *\n   * @default {@link ModelAnimationLoop.NONE}\n   */\n  loop: {\n    get: function () {\n      return this._loop;\n    },\n  },\n\n  /**\n   * If this is defined, it will be used to compute the local animation time\n   * instead of the scene's time.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {ModelAnimation.AnimationTimeCallback}\n   * @default undefined\n   */\n  animationTime: {\n    get: function () {\n      return this._animationTime;\n    },\n  },\n});\n\nfunction initialize(runtimeAnimation) {\n  let localStartTime = Number.MAX_VALUE;\n  let localStopTime = -Number.MAX_VALUE;\n\n  const sceneGraph = runtimeAnimation._model.sceneGraph;\n  const animation = runtimeAnimation._animation;\n  const channels = animation.channels;\n  const length = channels.length;\n\n  const runtimeChannels = [];\n  for (let i = 0; i < length; i++) {\n    const channel = channels[i];\n    const target = channel.target;\n\n    // Ignore this channel if the target is invalid, i.e. if the node\n    // it references doesn't exist.\n    if (!defined(target)) {\n      continue;\n    }\n\n    const nodeIndex = target.node.index;\n    const runtimeNode = sceneGraph._runtimeNodes[nodeIndex];\n\n    const runtimeChannel = new ModelAnimationChannel({\n      channel: channel,\n      runtimeAnimation: runtimeAnimation,\n      runtimeNode: runtimeNode,\n    });\n\n    const times = channel.sampler.input;\n    localStartTime = Math.min(localStartTime, times[0]);\n    localStopTime = Math.max(localStopTime, times[times.length - 1]);\n\n    runtimeChannels.push(runtimeChannel);\n  }\n\n  runtimeAnimation._runtimeChannels = runtimeChannels;\n  runtimeAnimation._localStartTime = localStartTime;\n  runtimeAnimation._localStopTime = localStopTime;\n}\n\n/**\n * Evaluate all animation channels to advance this animation.\n *\n * @param {number} time The local animation time.\n *\n * @private\n */\nModelAnimation.prototype.animate = function (time) {\n  const runtimeChannels = this._runtimeChannels;\n  const length = runtimeChannels.length;\n  for (let i = 0; i < length; i++) {\n    runtimeChannels[i].animate(time);\n  }\n};\n\n/**\n * A function used to compute the local animation time for a ModelAnimation.\n * @callback ModelAnimation.AnimationTimeCallback\n *\n * @param {number} duration The animation's original duration in seconds.\n * @param {number} seconds The seconds since the animation started, in scene time.\n * @returns {number} Returns the local animation time.\n *\n * @example\n * // Use real time for model animation (assuming animateWhilePaused was set to true)\n * function animationTime(duration) {\n *     return Date.now() / 1000 / duration;\n * }\n *\n * @example\n * // Offset the phase of the animation, so it starts halfway through its cycle.\n * function animationTime(duration, seconds) {\n *     return seconds / duration + 0.5;\n * }\n */\nexport default ModelAnimation;\n"],"names":["ModelAnimation","model","animation","options","_animation","_name","name","_runtimeChannels","undefined","_startTime","clone","startTime","_delay","delay","_stopTime","stopTime","removeOnStop","_multiplier","multiplier","_reverse","reverse","_loop","loop","NONE","_animationTime","animationTime","_prevAnimationDelta","start","update","stop","_state","STOPPED","_computedStartTime","_duration","that","_raiseStartEvent","raiseEvent","_updateEventTime","_raiseUpdateEvent","_raiseStopEvent","_model","_localStartTime","_localStopTime","initialize","Object","defineProperties","prototype","get","runtimeChannels","localStartTime","localStopTime","runtimeAnimation","Number","MAX_VALUE","sceneGraph","channels","length","i","channel","target","nodeIndex","node","index","runtimeNode","_runtimeNodes","runtimeChannel","times","sampler","input","Math","min","max","push","animate","time"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4646, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelAnimationCollection.js"],"sourcesContent":["import Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Event from \"../../Core/Event.js\";\nimport JulianDate from \"../../Core/JulianDate.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport ModelAnimation from \"./ModelAnimation.js\";\nimport ModelAnimationLoop from \".././ModelAnimationLoop.js\";\nimport ModelAnimationState from \".././ModelAnimationState.js\";\n\n/**\n * <div class=\"notice\">\n * Access a model's animations {@link Model#activeAnimations}. Do not call the constructor directly\n * </div>\n *\n * A collection of active model animations.\n *\n * @alias ModelAnimationCollection\n * @internalConstructor\n * @class\n *\n * @see Model#activeAnimations\n */\nfunction ModelAnimationCollection(model) {\n  /**\n   * The event fired when an animation is added to the collection.  This can be used, for\n   * example, to keep a UI in sync.\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * model.activeAnimations.animationAdded.addEventListener(function(model, animation) {\n   *   console.log(`Animation added: ${animation.name}`);\n   * });\n   */\n  this.animationAdded = new Event();\n\n  /**\n   * The event fired when an animation is removed from the collection.  This can be used, for\n   * example, to keep a UI in sync.\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * model.activeAnimations.animationRemoved.addEventListener(function(model, animation) {\n   *   console.log(`Animation removed: ${animation.name}`);\n   * });\n   */\n  this.animationRemoved = new Event();\n\n  /**\n   * When true, the animation will play even when the scene time is paused. However,\n   * whether animation takes place will depend on the animationTime functions assigned\n   * to the model's animations. By default, this is based on scene time, so models using\n   * the default will not animate regardless of this setting.\n   *\n   * @type {boolean}\n   * @default false\n   */\n  this.animateWhilePaused = false;\n\n  this._model = model;\n  this._runtimeAnimations = [];\n  this._previousTime = undefined;\n}\n\nObject.defineProperties(ModelAnimationCollection.prototype, {\n  /**\n   * The number of animations in the collection.\n   *\n   * @memberof ModelAnimationCollection.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._runtimeAnimations.length;\n    },\n  },\n\n  /**\n   * The model that owns this animation collection.\n   *\n   * @memberof ModelAnimationCollection.prototype\n   *\n   * @type {Model}\n   * @readonly\n   */\n  model: {\n    get: function () {\n      return this._model;\n    },\n  },\n});\n\nfunction addAnimation(collection, animation, options) {\n  const model = collection._model;\n  const runtimeAnimation = new ModelAnimation(model, animation, options);\n  collection._runtimeAnimations.push(runtimeAnimation);\n  collection.animationAdded.raiseEvent(model, runtimeAnimation);\n  return runtimeAnimation;\n}\n\n/**\n * Creates and adds an animation with the specified initial properties to the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationAdded} event so, for example, a UI can stay in sync.\n * </p>\n *\n * @param {object} options Object with the following properties:\n * @param {string} [options.name] The glTF animation name that identifies the animation. Must be defined if <code>options.index</code> is <code>undefined</code>.\n * @param {number} [options.index] The glTF animation index that identifies the animation. Must be defined if <code>options.name</code> is <code>undefined</code>.\n * @param {JulianDate} [options.startTime] The scene time to start playing the animation.  When this is <code>undefined</code>, the animation starts at the next frame.\n * @param {number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.\n * @param {JulianDate} [options.stopTime] The scene time to stop playing the animation.  When this is <code>undefined</code>, the animation is played for its full duration.\n * @param {boolean} [options.removeOnStop=false] When <code>true</code>, the animation is removed after it stops playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.\n * @param {number} [options.multiplier=1.0] Values greater than <code>1.0</code> increase the speed that the animation is played relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.\n * @param {boolean} [options.reverse=false] When <code>true</code>, the animation is played in reverse.\n * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animation is looped.\n * @param {ModelAnimation.AnimationTimeCallback} [options.animationTime=undefined] If defined, computes the local animation time for this animation.\n * @returns {ModelAnimation} The animation that was added to the collection.\n *\n * @exception {DeveloperError} Animations are not loaded.  Wait for the {@link Model#ready} to return trues.\n * @exception {DeveloperError} options.name must be a valid animation name.\n * @exception {DeveloperError} options.index must be a valid animation index.\n * @exception {DeveloperError} Either options.name or options.index must be defined.\n * @exception {DeveloperError} options.multiplier must be greater than zero.\n *\n * @example\n * // Example 1. Add an animation by name\n * model.activeAnimations.add({\n *   name : 'animation name'\n * });\n *\n * @example\n * // Example 2. Add an animation by index\n * model.activeAnimations.add({\n *   index : 0\n * });\n *\n * @example\n * // Example 3. Add an animation and provide all properties and events\n * const startTime = Cesium.JulianDate.now();\n *\n * const animation = model.activeAnimations.add({\n *   name : 'another animation name',\n *   startTime : startTime,\n *   delay : 0.0,                                 // Play at startTime (default)\n *   stopTime : Cesium.JulianDate.addSeconds(startTime, 4.0, new Cesium.JulianDate()),\n *   removeOnStop : false,                        // Do not remove when animation stops (default)\n *   multiplier : 2.0,                            // Play at double speed\n *   reverse : true,                              // Play in reverse\n *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animation\n * });\n *\n * animation.start.addEventListener(function(model, animation) {\n *   console.log(`Animation started: ${animation.name}`);\n * });\n * animation.update.addEventListener(function(model, animation, time) {\n *   console.log(`Animation updated: ${animation.name}. glTF animation time: ${time}`);\n * });\n * animation.stop.addEventListener(function(model, animation) {\n *   console.log(`Animation stopped: ${animation.name}`);\n * });\n */\nModelAnimationCollection.prototype.add = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const model = this._model;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!model.ready) {\n    throw new DeveloperError(\n      \"Animations are not loaded.  Wait for Model.ready to be true.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const animations = model.sceneGraph.components.animations;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.name) && !defined(options.index)) {\n    throw new DeveloperError(\n      \"Either options.name or options.index must be defined.\",\n    );\n  }\n\n  if (defined(options.multiplier) && options.multiplier <= 0.0) {\n    throw new DeveloperError(\"options.multiplier must be greater than zero.\");\n  }\n\n  if (\n    defined(options.index) &&\n    (options.index >= animations.length || options.index < 0)\n  ) {\n    throw new DeveloperError(\"options.index must be a valid animation index.\");\n  }\n  //>>includeEnd('debug');\n\n  let index = options.index;\n  if (defined(index)) {\n    return addAnimation(this, animations[index], options);\n  }\n\n  // Find the index of the animation with the given name\n  const length = animations.length;\n  for (let i = 0; i < length; ++i) {\n    if (animations[i].name === options.name) {\n      index = i;\n      break;\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"options.name must be a valid animation name.\");\n  }\n  //>>includeEnd('debug');\n\n  return addAnimation(this, animations[index], options);\n};\n\n/**\n * Creates and adds animations with the specified initial properties to the collection\n * for all animations in the model.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationAdded} event for each model so, for example, a UI can stay in sync.\n * </p>\n *\n * @param {object} [options] Object with the following properties:\n * @param {JulianDate} [options.startTime] The scene time to start playing the animations. When this is <code>undefined</code>, the animations starts at the next frame.\n * @param {number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.\n * @param {JulianDate} [options.stopTime] The scene time to stop playing the animations. When this is <code>undefined</code>, the animations are played for its full duration.\n * @param {boolean} [options.removeOnStop=false] When <code>true</code>, the animations are removed after they stop playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.\n * @param {number} [options.multiplier=1.0] Values greater than <code>1.0</code> increase the speed that the animations play relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.\n * @param {boolean} [options.reverse=false] When <code>true</code>, the animations are played in reverse.\n * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animations are looped.\n * @param {ModelAnimation.AnimationTimeCallback} [options.animationTime=undefined] If defined, computes the local animation time for all of the animations.\n * @returns {ModelAnimation[]} An array of {@link ModelAnimation} objects, one for each animation added to the collection.  If there are no glTF animations, the array is empty.\n *\n * @exception {DeveloperError} Animations are not loaded. Wait for the {@link Model#ready} to return true.\n * @exception {DeveloperError} options.multiplier must be greater than zero.\n *\n * @example\n * model.activeAnimations.addAll({\n *   multiplier : 0.5,                            // Play at half-speed\n *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animations\n * });\n */\nModelAnimationCollection.prototype.addAll = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const model = this._model;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!model.ready) {\n    throw new DeveloperError(\n      \"Animations are not loaded.  Wait for Model.ready to be true.\",\n    );\n  }\n\n  if (defined(options.multiplier) && options.multiplier <= 0.0) {\n    throw new DeveloperError(\"options.multiplier must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  const animations = model.sceneGraph.components.animations;\n\n  const addedAnimations = [];\n  const length = animations.length;\n  for (let i = 0; i < length; ++i) {\n    const animation = addAnimation(this, animations[i], options);\n    addedAnimations.push(animation);\n  }\n  return addedAnimations;\n};\n\n/**\n * Removes an animation from the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationRemoved} event so, for example, a UI can stay in sync.\n * </p>\n * <p>\n * An animation can also be implicitly removed from the collection by setting {@link ModelAnimationCollection#removeOnStop} to\n * <code>true</code>.  The {@link ModelAnimationCollection#animationRemoved} event is still fired when the animation is removed.\n * </p>\n *\n * @param {ModelAnimation} runtimeAnimation The runtime animation to remove.\n * @returns {boolean} <code>true</code> if the animation was removed; <code>false</code> if the animation was not found in the collection.\n *\n * @example\n * const a = model.activeAnimations.add({\n *   name : 'animation name'\n * });\n * model.activeAnimations.remove(a); // Returns true\n */\nModelAnimationCollection.prototype.remove = function (runtimeAnimation) {\n  if (!defined(runtimeAnimation)) {\n    return false;\n  }\n\n  const animations = this._runtimeAnimations;\n  const i = animations.indexOf(runtimeAnimation);\n  if (i !== -1) {\n    animations.splice(i, 1);\n    this.animationRemoved.raiseEvent(this._model, runtimeAnimation);\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Removes all animations from the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationRemoved} event for each\n * animation so, for example, a UI can stay in sync.\n * </p>\n */\nModelAnimationCollection.prototype.removeAll = function () {\n  const model = this._model;\n  const animations = this._runtimeAnimations;\n  const length = animations.length;\n\n  this._runtimeAnimations.length = 0;\n\n  for (let i = 0; i < length; ++i) {\n    this.animationRemoved.raiseEvent(model, animations[i]);\n  }\n};\n\n/**\n * Determines whether this collection contains a given animation.\n *\n * @param {ModelAnimation} runtimeAnimation The runtime animation to check for.\n * @returns {boolean} <code>true</code> if this collection contains the animation, <code>false</code> otherwise.\n */\nModelAnimationCollection.prototype.contains = function (runtimeAnimation) {\n  if (defined(runtimeAnimation)) {\n    return this._runtimeAnimations.indexOf(runtimeAnimation) !== -1;\n  }\n\n  return false;\n};\n\n/**\n * Returns the animation in the collection at the specified index.  Indices are zero-based\n * and increase as animations are added.  Removing an animation shifts all animations after\n * it to the left, changing their indices.  This function is commonly used to iterate over\n * all the animations in the collection.\n *\n * @param {number} index The zero-based index of the animation.\n * @returns {ModelAnimation} The runtime animation at the specified index.\n *\n * @example\n * // Output the names of all the animations in the collection.\n * const animations = model.activeAnimations;\n * const length = animations.length;\n * for (let i = 0; i < length; ++i) {\n *   console.log(animations.get(i).name);\n * }\n */\nModelAnimationCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n\n  if (index >= this._runtimeAnimations.length || index < 0) {\n    throw new DeveloperError(\n      \"index must be valid within the range of the collection\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  return this._runtimeAnimations[index];\n};\n\nconst animationsToRemove = [];\n\nfunction createAnimationRemovedFunction(\n  modelAnimationCollection,\n  model,\n  animation,\n) {\n  return function () {\n    modelAnimationCollection.animationRemoved.raiseEvent(model, animation);\n  };\n}\n\n/**\n * Updates the runtime animations in this collection, removing any animations\n * that have stopped.\n *\n * @param {FrameState} frameState The current frame state.\n * @returns {boolean} <code>true</code> if an animation played during this update, <code>false</code> otherwise.\n *\n * @private\n */\nModelAnimationCollection.prototype.update = function (frameState) {\n  const runtimeAnimations = this._runtimeAnimations;\n  let length = runtimeAnimations.length;\n\n  if (length === 0) {\n    this._previousTime = undefined;\n    return false;\n  }\n\n  if (\n    !this.animateWhilePaused &&\n    JulianDate.equals(frameState.time, this._previousTime)\n  ) {\n    return false;\n  }\n  this._previousTime = JulianDate.clone(frameState.time, this._previousTime);\n\n  let animationOccurred = false;\n  const sceneTime = frameState.time;\n  const model = this._model;\n\n  for (let i = 0; i < length; ++i) {\n    const runtimeAnimation = runtimeAnimations[i];\n\n    if (!defined(runtimeAnimation._computedStartTime)) {\n      runtimeAnimation._computedStartTime = JulianDate.addSeconds(\n        runtimeAnimation.startTime ?? sceneTime,\n        runtimeAnimation.delay,\n        new JulianDate(),\n      );\n    }\n\n    if (!defined(runtimeAnimation._duration)) {\n      runtimeAnimation._duration =\n        runtimeAnimation.localStopTime * (1.0 / runtimeAnimation.multiplier);\n    }\n\n    const startTime = runtimeAnimation._computedStartTime;\n    const duration = runtimeAnimation._duration;\n    const stopTime = runtimeAnimation.stopTime;\n\n    const pastStartTime = JulianDate.lessThanOrEquals(startTime, sceneTime);\n    const reachedStopTime =\n      defined(stopTime) && JulianDate.greaterThan(sceneTime, stopTime);\n\n    // [0.0, 1.0] normalized local animation time\n    let delta = 0.0;\n    if (duration !== 0.0) {\n      const seconds = JulianDate.secondsDifference(\n        reachedStopTime ? stopTime : sceneTime,\n        startTime,\n      );\n      delta = defined(runtimeAnimation._animationTime)\n        ? runtimeAnimation._animationTime(duration, seconds)\n        : seconds / duration;\n    }\n\n    // Play animation if\n    // * we are after the start time or the animation is being repeated, and\n    // * before the end of the animation's duration or the animation is being repeated, and\n    // * we did not reach a user-provided stop time.\n\n    const repeat =\n      runtimeAnimation.loop === ModelAnimationLoop.REPEAT ||\n      runtimeAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT;\n\n    const play =\n      (pastStartTime || (repeat && !defined(runtimeAnimation.startTime))) &&\n      (delta <= 1.0 || repeat) &&\n      !reachedStopTime;\n\n    if (delta === runtimeAnimation._prevAnimationDelta) {\n      const animationStopped =\n        runtimeAnimation._state === ModelAnimationState.STOPPED;\n      // no change to delta, and no change to the animation state means we can\n      // skip the update this time around.\n      if (play !== animationStopped) {\n        continue;\n      }\n    }\n    runtimeAnimation._prevAnimationDelta = delta;\n\n    // If it IS, or WAS, animating...\n    if (play || runtimeAnimation._state === ModelAnimationState.ANIMATING) {\n      // ...transition from STOPPED to ANIMATING\n      if (play && runtimeAnimation._state === ModelAnimationState.STOPPED) {\n        runtimeAnimation._state = ModelAnimationState.ANIMATING;\n        if (runtimeAnimation.start.numberOfListeners > 0) {\n          frameState.afterRender.push(runtimeAnimation._raiseStartEvent);\n        }\n      }\n\n      // Truncate to [0.0, 1.0] for repeating animations\n      if (runtimeAnimation.loop === ModelAnimationLoop.REPEAT) {\n        delta = delta - Math.floor(delta);\n      } else if (runtimeAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT) {\n        const floor = Math.floor(delta);\n        const fract = delta - floor;\n        // When odd use (1.0 - fract) to mirror repeat\n        delta = floor % 2 === 1.0 ? 1.0 - fract : fract;\n      }\n\n      if (runtimeAnimation.reverse) {\n        delta = 1.0 - delta;\n      }\n\n      let localAnimationTime = delta * duration * runtimeAnimation.multiplier;\n      // Clamp in case floating-point roundoff goes outside the animation's first or last keyframe\n      localAnimationTime = CesiumMath.clamp(\n        localAnimationTime,\n        runtimeAnimation.localStartTime,\n        runtimeAnimation.localStopTime,\n      );\n\n      runtimeAnimation.animate(localAnimationTime);\n\n      if (runtimeAnimation.update.numberOfListeners > 0) {\n        runtimeAnimation._updateEventTime = localAnimationTime;\n        frameState.afterRender.push(runtimeAnimation._raiseUpdateEvent);\n      }\n      animationOccurred = true;\n\n      if (!play) {\n        // transition from ANIMATING to STOPPED\n        runtimeAnimation._state = ModelAnimationState.STOPPED;\n        if (runtimeAnimation.stop.numberOfListeners > 0) {\n          frameState.afterRender.push(runtimeAnimation._raiseStopEvent);\n        }\n\n        if (runtimeAnimation.removeOnStop) {\n          animationsToRemove.push(runtimeAnimation);\n        }\n      }\n    }\n  }\n\n  // Remove animations that stopped\n  length = animationsToRemove.length;\n  for (let j = 0; j < length; ++j) {\n    const animationToRemove = animationsToRemove[j];\n    runtimeAnimations.splice(runtimeAnimations.indexOf(animationToRemove), 1);\n    frameState.afterRender.push(\n      createAnimationRemovedFunction(this, model, animationToRemove),\n    );\n  }\n  animationsToRemove.length = 0;\n\n  return animationOccurred;\n};\n\nexport default ModelAnimationCollection;\n"],"names":["ModelAnimationCollection","model","animationAdded","animationRemoved","animateWhilePaused","_model","_runtimeAnimations","_previousTime","undefined","Object","defineProperties","prototype","length","get","addAnimation","collection","animation","options","runtimeAnimation","push","raiseEvent","add","EMPTY_OBJECT","ready","animations","sceneGraph","components","name","index","multiplier","i","addAll","addedAnimations","remove","indexOf","splice","removeAll","contains","animationsToRemove","createAnimationRemovedFunction","modelAnimationCollection","update","frameState","runtimeAnimations","equals","time","clone","animationOccurred","sceneTime","_computedStartTime","addSeconds","startTime","delay","_duration","localStopTime","duration","stopTime","pastStartTime","lessThanOrEquals","reachedStopTime","greaterThan","delta","seconds","secondsDifference","_animationTime","repeat","loop","REPEAT","MIRRORED_REPEAT","play","_prevAnimationDelta","animationStopped","_state","STOPPED","ANIMATING","start","numberOfListeners","afterRender","_raiseStartEvent","Math","floor","fract","reverse","localAnimationTime","clamp","localStartTime","animate","_updateEventTime","_raiseUpdateEvent","stop","_raiseStopEvent","removeOnStop","j","animationToRemove"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5100, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelFeature.js"],"sourcesContent":["import Color from \"../../Core/Color.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * A feature of a {@link Model}.\n * <p>\n * Provides access to a feature's properties stored in the model's feature table.\n * </p>\n * <p>\n * Modifications to a <code>ModelFeature</code> object have the lifetime of the model.\n * </p>\n * <p>\n * Do not construct this directly. Access it through picking using {@link Scene#pick}.\n * </p>\n *\n * @alias ModelFeature\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Model} options.model The model the feature belongs to.\n * @param {number} options.featureId The unique integral identifier for this feature.\n *\n * @example\n * // On mouse over, display all the properties for a feature in the console log.\n * handler.setInputAction(function(movement) {\n *     const feature = scene.pick(movement.endPosition);\n *     if (feature instanceof Cesium.ModelFeature) {\n *         console.log(feature);\n *     }\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n *\n */\nfunction ModelFeature(options) {\n  this._model = options.model;\n\n  // This ModelFeatureTable is not documented as an option since it is\n  // part of the private API and should not appear in the documentation.\n  this._featureTable = options.featureTable;\n\n  this._featureId = options.featureId;\n  this._color = undefined; // for calling getColor\n}\n\nObject.defineProperties(ModelFeature.prototype, {\n  /**\n   * Gets or sets if the feature will be shown. This is set for all features\n   * when a style's show is evaluated.\n   *\n   * @memberof ModelFeature.prototype\n   *\n   * @type {boolean}\n   *\n   * @default true\n   */\n  show: {\n    get: function () {\n      return this._featureTable.getShow(this._featureId);\n    },\n    set: function (value) {\n      this._featureTable.setShow(this._featureId, value);\n    },\n  },\n\n  /**\n   * Gets or sets the highlight color multiplied with the feature's color.  When\n   * this is white, the feature's color is not changed. This is set for all features\n   * when a style's color is evaluated.\n   *\n   * @memberof ModelFeature.prototype\n   *\n   * @type {Color}\n   *\n   * @default {@link Color.WHITE}\n   */\n  color: {\n    get: function () {\n      if (!defined(this._color)) {\n        this._color = new Color();\n      }\n      return this._featureTable.getColor(this._featureId, this._color);\n    },\n    set: function (value) {\n      this._featureTable.setColor(this._featureId, value);\n    },\n  },\n  /**\n   * All objects returned by {@link Scene#pick} have a <code>primitive</code> property. This returns\n   * the model containing the feature.\n   *\n   * @memberof ModelFeature.prototype\n   *\n   * @type {Model}\n   *\n   * @readonly\n   * @private\n   */\n  primitive: {\n    get: function () {\n      return this._model;\n    },\n  },\n\n  /**\n   *  The {@link ModelFeatureTable} that this feature belongs to.\n   *\n   * @memberof ModelFeature.prototype\n   *\n   * @type {ModelFeatureTable}\n   *\n   * @readonly\n   * @private\n   */\n  featureTable: {\n    get: function () {\n      return this._featureTable;\n    },\n  },\n\n  /**\n   * Get the feature ID associated with this feature. For 3D Tiles 1.0, the\n   * batch ID is returned. For EXT_mesh_features, this is the feature ID from\n   * the selected feature ID set.\n   *\n   * @memberof ModelFeature.prototype\n   *\n   * @type {number}\n   *\n   * @readonly\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  featureId: {\n    get: function () {\n      return this._featureId;\n    },\n  },\n});\n\n/**\n * Returns whether the feature contains this property.\n *\n * @param {string} name The case-sensitive name of the property.\n * @returns {boolean} Whether the feature contains this property.\n */\nModelFeature.prototype.hasProperty = function (name) {\n  return this._featureTable.hasProperty(this._featureId, name);\n};\n\n/**\n * Returns a copy of the value of the feature's property with the given name.\n *\n * @param {string} name The case-sensitive name of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n *\n * @example\n * // Display all the properties for a feature in the console log.\n * const propertyIds = feature.getPropertyIds();\n * const length = propertyIds.length;\n * for (let i = 0; i < length; ++i) {\n *     const propertyId = propertyIds[i];\n *     console.log(propertyId + ': ' + feature.getProperty(propertyId));\n * }\n */\nModelFeature.prototype.getProperty = function (name) {\n  return this._featureTable.getProperty(this._featureId, name);\n};\n\n/**\n * Returns a copy of the feature's property with the given name, examining all\n * the metadata from the EXT_structural_metadata and legacy EXT_feature_metadata glTF\n * extensions. Metadata is checked against name from most specific to most\n * general and the first match is returned. Metadata is checked in this order:\n * <ol>\n *   <li>structural metadata property by semantic</li>\n *   <li>structural metadata property by property ID</li>\n * </ol>\n * <p>\n * See the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension} as well as the\n * previous {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension} for glTF.\n * </p>\n *\n * @param {string} name The semantic or property ID of the feature. Semantics are checked before property IDs in each granularity of metadata.\n * @return {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nModelFeature.prototype.getPropertyInherited = function (name) {\n  if (this._featureTable.hasPropertyBySemantic(this._featureId, name)) {\n    return this._featureTable.getPropertyBySemantic(this._featureId, name);\n  }\n\n  return this._featureTable.getProperty(this._featureId, name);\n};\n\n/**\n * Returns an array of property IDs for the feature.\n *\n * @param {string[]} [results] An array into which to store the results.\n * @returns {string[]} The IDs of the feature's properties.\n */\nModelFeature.prototype.getPropertyIds = function (results) {\n  return this._featureTable.getPropertyIds(results);\n};\n\n/**\n * Sets the value of the feature's property with the given name.\n *\n * @param {string} name The case-sensitive name of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @exception {DeveloperError} Inherited batch table hierarchy property is read only.\n *\n * @example\n * const height = feature.getProperty('Height'); // e.g., the height of a building\n *\n * @example\n * const name = 'clicked';\n * if (feature.getProperty(name)) {\n *     console.log('already clicked');\n * } else {\n *     feature.setProperty(name, true);\n *     console.log('first click');\n * }\n */\nModelFeature.prototype.setProperty = function (name, value) {\n  return this._featureTable.setProperty(this._featureId, name, value);\n};\n\nexport default ModelFeature;\n"],"names":["ModelFeature","options","_model","model","_featureTable","featureTable","_featureId","featureId","_color","undefined","Object","defineProperties","prototype","show","get","getShow","set","value","setShow","color","getColor","setColor","primitive","hasProperty","name","getProperty","getPropertyInherited","hasPropertyBySemantic","getPropertyBySemantic","getPropertyIds","results","setProperty"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BC,GACD,SAASA,aAAaC,OAAO;IAC3B,IAAI,CAACC,MAAM,GAAGD,QAAQE,KAAK;IAE3B,oEAAoE;IACpE,sEAAsE;IACtE,IAAI,CAACC,aAAa,GAAGH,QAAQI,YAAY;IAEzC,IAAI,CAACC,UAAU,GAAGL,QAAQM,SAAS;IACnC,IAAI,CAACC,MAAM,GAAGC,WAAW,uBAAuB;AAClD;AAEAC,OAAOC,gBAAgB,CAACX,aAAaY,SAAS,EAAE;IAC9C;;;;;;;;;GASC,GACDC,MAAM;QACJC,KAAK;YACH,OAAO,IAAI,CAACV,aAAa,CAACW,OAAO,CAAC,IAAI,CAACT,UAAU;QACnD;QACAU,KAAK,SAAUC,KAAK;YAClB,IAAI,CAACb,aAAa,CAACc,OAAO,CAAC,IAAI,CAACZ,UAAU,EAAEW;QAC9C;IACF;IAEA;;;;;;;;;;GAUC,GACDE,OAAO;QACLL,KAAK;YACH,IAAI,CAAC,IAAA,6KAAO,EAAC,IAAI,CAACN,MAAM,GAAG;gBACzB,IAAI,CAACA,MAAM,GAAG,IAAI,2KAAK;YACzB;YACA,OAAO,IAAI,CAACJ,aAAa,CAACgB,QAAQ,CAAC,IAAI,CAACd,UAAU,EAAE,IAAI,CAACE,MAAM;QACjE;QACAQ,KAAK,SAAUC,KAAK;YAClB,IAAI,CAACb,aAAa,CAACiB,QAAQ,CAAC,IAAI,CAACf,UAAU,EAAEW;QAC/C;IACF;IACA;;;;;;;;;;GAUC,GACDK,WAAW;QACTR,KAAK;YACH,OAAO,IAAI,CAACZ,MAAM;QACpB;IACF;IAEA;;;;;;;;;GASC,GACDG,cAAc;QACZS,KAAK;YACH,OAAO,IAAI,CAACV,aAAa;QAC3B;IACF;IAEA;;;;;;;;;;;GAWC,GACDG,WAAW;QACTO,KAAK;YACH,OAAO,IAAI,CAACR,UAAU;QACxB;IACF;AACF;AAEA;;;;;CAKC,GACDN,aAAaY,SAAS,CAACW,WAAW,GAAG,SAAUC,IAAI;IACjD,OAAO,IAAI,CAACpB,aAAa,CAACmB,WAAW,CAAC,IAAI,CAACjB,UAAU,EAAEkB;AACzD;AAEA;;;;;;;;;;;;;;CAcC,GACDxB,aAAaY,SAAS,CAACa,WAAW,GAAG,SAAUD,IAAI;IACjD,OAAO,IAAI,CAACpB,aAAa,CAACqB,WAAW,CAAC,IAAI,CAACnB,UAAU,EAAEkB;AACzD;AAEA;;;;;;;;;;;;;;;;;;CAkBC,GACDxB,aAAaY,SAAS,CAACc,oBAAoB,GAAG,SAAUF,IAAI;IAC1D,IAAI,IAAI,CAACpB,aAAa,CAACuB,qBAAqB,CAAC,IAAI,CAACrB,UAAU,EAAEkB,OAAO;QACnE,OAAO,IAAI,CAACpB,aAAa,CAACwB,qBAAqB,CAAC,IAAI,CAACtB,UAAU,EAAEkB;IACnE;IAEA,OAAO,IAAI,CAACpB,aAAa,CAACqB,WAAW,CAAC,IAAI,CAACnB,UAAU,EAAEkB;AACzD;AAEA;;;;;CAKC,GACDxB,aAAaY,SAAS,CAACiB,cAAc,GAAG,SAAUC,OAAO;IACvD,OAAO,IAAI,CAAC1B,aAAa,CAACyB,cAAc,CAACC;AAC3C;AAEA;;;;;;;;;;;;;;;;;;;;CAoBC,GACD9B,aAAaY,SAAS,CAACmB,WAAW,GAAG,SAAUP,IAAI,EAAEP,KAAK;IACxD,OAAO,IAAI,CAACb,aAAa,CAAC2B,WAAW,CAAC,IAAI,CAACzB,UAAU,EAAEkB,MAAMP;AAC/D;uCAEejB","ignoreList":[0]}},
    {"offset": {"line": 5314, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/StyleCommandsNeeded.js"],"sourcesContent":["/**\n * An enum describing what commands (opaque or translucent) are required by\n * a {@link Cesium3DTileStyle}.\n *\n * @enum {number}\n * @private\n */\nconst StyleCommandsNeeded = {\n  ALL_OPAQUE: 0,\n  ALL_TRANSLUCENT: 1,\n  OPAQUE_AND_TRANSLUCENT: 2,\n};\n\n/**\n * @private\n */\nStyleCommandsNeeded.getStyleCommandsNeeded = function (\n  featuresLength,\n  translucentFeaturesLength,\n) {\n  if (translucentFeaturesLength === 0) {\n    return StyleCommandsNeeded.ALL_OPAQUE;\n  } else if (translucentFeaturesLength === featuresLength) {\n    return StyleCommandsNeeded.ALL_TRANSLUCENT;\n  }\n  return StyleCommandsNeeded.OPAQUE_AND_TRANSLUCENT;\n};\n\nexport default Object.freeze(StyleCommandsNeeded);\n"],"names":["StyleCommandsNeeded","ALL_OPAQUE","ALL_TRANSLUCENT","OPAQUE_AND_TRANSLUCENT","getStyleCommandsNeeded","featuresLength","translucentFeaturesLength","Object","freeze"],"mappings":";;;;AAAA;;;;;;CAMC,GACD,MAAMA,sBAAsB;IAC1BC,YAAY;IACZC,iBAAiB;IACjBC,wBAAwB;AAC1B;AAEA;;CAEC,GACDH,oBAAoBI,sBAAsB,GAAG,SAC3CC,cAAc,EACdC,yBAAyB;IAEzB,IAAIA,8BAA8B,GAAG;QACnC,OAAON,oBAAoBC,UAAU;IACvC,OAAO,IAAIK,8BAA8BD,gBAAgB;QACvD,OAAOL,oBAAoBE,eAAe;IAC5C;IACA,OAAOF,oBAAoBG,sBAAsB;AACnD;uCAEeI,OAAOC,MAAM,CAACR","ignoreList":[0]}},
    {"offset": {"line": 5344, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelType.js"],"sourcesContent":["import Check from \"../../Core/Check.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\n\n/**\n * An enum to distinguish the different uses for {@link Model},\n * which include individual glTF models, and various 3D Tiles formats\n * (including glTF via <code>3DTILES_content_gltf</code>).\n *\n * @enum {string}\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst ModelType = {\n  /**\n   * An individual glTF model.\n   * <p>\n   * Not to be confused with {@link ModelType.TILE_GLTF}\n   * which is for 3D Tiles\n   * </p>\n   *\n   * @type {string}\n   * @constant\n   */\n  GLTF: \"GLTF\",\n  /**\n   * A glTF model used as tile content in a 3D Tileset via\n   * <code>3DTILES_content_gltf</code>.\n   * <p>\n   * Not to be confused with {@link ModelType.GLTF}\n   * which is for individual models\n   * </p>\n   *\n   * @type {string}\n   * @constant\n   */\n  TILE_GLTF: \"TILE_GLTF\",\n  /**\n   * A 3D Tiles 1.0 Batched 3D Model\n   *\n   * @type {string}\n   * @constant\n   */\n  TILE_B3DM: \"B3DM\",\n  /**\n   * A 3D Tiles 1.0 Instanced 3D Model\n   *\n   * @type {string}\n   * @constant\n   */\n  TILE_I3DM: \"I3DM\",\n  /**\n   * A 3D Tiles 1.0 Point Cloud\n   *\n   * @type {string}\n   * @constant\n   */\n  TILE_PNTS: \"PNTS\",\n\n  /**\n   * GeoJSON content for <code>MAXAR_content_geojson</code> extension\n   *\n   * @type {string}\n   * @constant\n   */\n  TILE_GEOJSON: \"TILE_GEOJSON\",\n};\n\n/**\n * Check if a model is used for 3D Tiles.\n * @param {ModelType} modelType The type of model\n * @returns {boolean} <code>true</code> if the model is a 3D Tiles format, <code>false</code> otherwise\n */\nModelType.is3DTiles = function (modelType) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"modelType\", modelType);\n  //>>includeEnd('debug');\n\n  switch (modelType) {\n    case ModelType.TILE_GLTF:\n    case ModelType.TILE_B3DM:\n    case ModelType.TILE_I3DM:\n    case ModelType.TILE_PNTS:\n    case ModelType.TILE_GEOJSON:\n      return true;\n    case ModelType.GLTF:\n      return false;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"modelType is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\nexport default Object.freeze(ModelType);\n"],"names":["ModelType","GLTF","TILE_GLTF","TILE_B3DM","TILE_I3DM","TILE_PNTS","TILE_GEOJSON","is3DTiles","modelType","typeOf","string","Object","freeze"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;;CAQC,GACD,MAAMA,YAAY;IAChB;;;;;;;;;GASC,GACDC,MAAM;IACN;;;;;;;;;;GAUC,GACDC,WAAW;IACX;;;;;GAKC,GACDC,WAAW;IACX;;;;;GAKC,GACDC,WAAW;IACX;;;;;GAKC,GACDC,WAAW;IAEX;;;;;GAKC,GACDC,cAAc;AAChB;AAEA;;;;CAIC,GACDN,UAAUO,SAAS,GAAG,SAAUC,SAAS;IACvC,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,aAAaF;IACjC,wBAAwB;IAExB,OAAQA;QACN,KAAKR,UAAUE,SAAS;QACxB,KAAKF,UAAUG,SAAS;QACxB,KAAKH,UAAUI,SAAS;QACxB,KAAKJ,UAAUK,SAAS;QACxB,KAAKL,UAAUM,YAAY;YACzB,OAAO;QACT,KAAKN,UAAUC,IAAI;YACjB,OAAO;QACT,yCAAyC;QACzC;YACE,MAAM,IAAI,oLAAc,CAAC;IAE7B;AACF;uCAEeU,OAAOC,MAAM,CAACZ","ignoreList":[0]}},
    {"offset": {"line": 5434, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelFeatureTable.js"],"sourcesContent":["import BatchTexture from \"../BatchTexture.js\";\nimport Cesium3DTileFeature from \"../Cesium3DTileFeature.js\";\nimport Check from \"../../Core/Check.js\";\nimport Color from \"../../Core/Color.js\";\nimport defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport ModelFeature from \"./ModelFeature.js\";\nimport StyleCommandsNeeded from \"./StyleCommandsNeeded.js\";\nimport ModelType from \"./ModelType.js\";\n\n/**\n * Manages the {@link ModelFeature}s in a {@link Model}.\n * Extracts the properties from a {@link PropertyTable}.\n *\n * @param {object} options An object containing the following options:\n * @param {Model} options.model The model that owns this feature table.\n * @param {PropertyTable} options.propertyTable The property table from the model used to initialize the model.\n *\n * @alias ModelFeatureTable\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction ModelFeatureTable(options) {\n  const model = options.model;\n  const propertyTable = options.propertyTable;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"propertyTable\", propertyTable);\n  Check.typeOf.object(\"model\", model);\n  //>>includeEnd('debug');\n\n  this._propertyTable = propertyTable;\n  this._model = model;\n\n  this._features = undefined;\n  this._featuresLength = 0;\n\n  this._batchTexture = undefined;\n\n  this._styleCommandsNeededDirty = false;\n  this._styleCommandsNeeded = StyleCommandsNeeded.ALL_OPAQUE;\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelFeatureTable.prototype, {\n  /**\n   * The batch texture created for the features in this table.\n   *\n   * @memberof ModelFeatureTable.prototype\n   *\n   * @type {BatchTexture}\n   * @readonly\n   *\n   * @private\n   */\n  batchTexture: {\n    get: function () {\n      return this._batchTexture;\n    },\n  },\n\n  /**\n   * The number of features in this table.\n   *\n   * @memberof ModelFeatureTable.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  featuresLength: {\n    get: function () {\n      return this._featuresLength;\n    },\n  },\n\n  /**\n   * Size of the batch texture. This does not count the property table size\n   * as that is counted separately through StructuralMetadata.\n   *\n   * @memberof ModelFeatureTable.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  batchTextureByteLength: {\n    get: function () {\n      if (defined(this._batchTexture)) {\n        return this._batchTexture.byteLength;\n      }\n\n      return 0;\n    },\n  },\n\n  /**\n   * A flag to indicate whether or not the types of style commands needed by this feature table have changed.\n   *\n   * @memberof ModelFeatureTable.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  styleCommandsNeededDirty: {\n    get: function () {\n      return this._styleCommandsNeededDirty;\n    },\n  },\n});\n\nfunction initialize(modelFeatureTable) {\n  const model = modelFeatureTable._model;\n  const is3DTiles = ModelType.is3DTiles(model.type);\n\n  const featuresLength = modelFeatureTable._propertyTable.count;\n  if (featuresLength === 0) {\n    return;\n  }\n\n  let i;\n  const features = new Array(featuresLength);\n  if (is3DTiles) {\n    const content = model.content;\n    for (i = 0; i < featuresLength; i++) {\n      features[i] = new Cesium3DTileFeature(content, i);\n    }\n  } else {\n    for (i = 0; i < featuresLength; i++) {\n      features[i] = new ModelFeature({\n        model: model,\n        featureId: i,\n        featureTable: modelFeatureTable,\n      });\n    }\n  }\n\n  modelFeatureTable._features = features;\n  modelFeatureTable._featuresLength = featuresLength;\n\n  modelFeatureTable._batchTexture = new BatchTexture({\n    featuresLength: featuresLength,\n    owner: modelFeatureTable,\n    statistics: is3DTiles ? model.content.tileset.statistics : undefined,\n  });\n}\n\n/**\n * Creates/updates the batch texture.\n *\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nModelFeatureTable.prototype.update = function (frameState) {\n  // Assume the number of translucent features has not changed.\n  this._styleCommandsNeededDirty = false;\n  this._batchTexture.update(undefined, frameState);\n\n  const currentStyleCommandsNeeded = StyleCommandsNeeded.getStyleCommandsNeeded(\n    this._featuresLength,\n    this._batchTexture.translucentFeaturesLength,\n  );\n\n  if (this._styleCommandsNeeded !== currentStyleCommandsNeeded) {\n    this._styleCommandsNeededDirty = true;\n    this._styleCommandsNeeded = currentStyleCommandsNeeded;\n  }\n};\n\nModelFeatureTable.prototype.setShow = function (featureId, show) {\n  this._batchTexture.setShow(featureId, show);\n};\n\nModelFeatureTable.prototype.setAllShow = function (show) {\n  this._batchTexture.setAllShow(show);\n};\n\nModelFeatureTable.prototype.getShow = function (featureId) {\n  return this._batchTexture.getShow(featureId);\n};\n\nModelFeatureTable.prototype.setColor = function (featureId, color) {\n  this._batchTexture.setColor(featureId, color);\n};\n\nModelFeatureTable.prototype.setAllColor = function (color) {\n  this._batchTexture.setAllColor(color);\n};\n\nModelFeatureTable.prototype.getColor = function (featureId, result) {\n  return this._batchTexture.getColor(featureId, result);\n};\n\nModelFeatureTable.prototype.getPickColor = function (featureId) {\n  return this._batchTexture.getPickColor(featureId);\n};\n\nModelFeatureTable.prototype.getFeature = function (featureId) {\n  return this._features[featureId];\n};\n\nModelFeatureTable.prototype.hasProperty = function (featureId, propertyName) {\n  return this._propertyTable.hasProperty(featureId, propertyName);\n};\n\nModelFeatureTable.prototype.hasPropertyBySemantic = function (\n  featureId,\n  propertyName,\n) {\n  return this._propertyTable.hasPropertyBySemantic(featureId, propertyName);\n};\n\nModelFeatureTable.prototype.getProperty = function (featureId, name) {\n  return this._propertyTable.getProperty(featureId, name);\n};\n\nModelFeatureTable.prototype.getPropertyBySemantic = function (\n  featureId,\n  semantic,\n) {\n  return this._propertyTable.getPropertyBySemantic(featureId, semantic);\n};\n\nModelFeatureTable.prototype.getPropertyIds = function (results) {\n  return this._propertyTable.getPropertyIds(results);\n};\n\nModelFeatureTable.prototype.setProperty = function (featureId, name, value) {\n  return this._propertyTable.setProperty(featureId, name, value);\n};\n\nModelFeatureTable.prototype.isClass = function (featureId, className) {\n  return this._propertyTable.isClass(featureId, className);\n};\n\nModelFeatureTable.prototype.isExactClass = function (featureId, className) {\n  return this._propertyTable.isExactClass(featureId, className);\n};\n\nModelFeatureTable.prototype.getExactClassName = function (featureId) {\n  return this._propertyTable.getExactClassName(featureId);\n};\n\nconst scratchColor = new Color();\n/**\n * @private\n */\nModelFeatureTable.prototype.applyStyle = function (style) {\n  if (!defined(style)) {\n    this.setAllColor(BatchTexture.DEFAULT_COLOR_VALUE);\n    this.setAllShow(BatchTexture.DEFAULT_SHOW_VALUE);\n    return;\n  }\n\n  for (let i = 0; i < this._featuresLength; i++) {\n    const feature = this.getFeature(i);\n    const color = defined(style.color)\n      ? (style.color.evaluateColor(feature, scratchColor) ??\n        BatchTexture.DEFAULT_COLOR_VALUE)\n      : BatchTexture.DEFAULT_COLOR_VALUE;\n    const show = defined(style.show)\n      ? (style.show.evaluate(feature) ?? BatchTexture.DEFAULT_SHOW_VALUE)\n      : BatchTexture.DEFAULT_SHOW_VALUE;\n\n    this.setColor(i, color);\n    this.setShow(i, show);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ModelFeatureTable#destroy\n * @private\n */\nModelFeatureTable.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see ModelFeatureTable#isDestroyed\n * @private\n */\nModelFeatureTable.prototype.destroy = function (frameState) {\n  this._batchTexture = this._batchTexture && this._batchTexture.destroy();\n  destroyObject(this);\n};\n\nexport default ModelFeatureTable;\n"],"names":["ModelFeatureTable","options","model","propertyTable","typeOf","object","_propertyTable","_model","_features","undefined","_featuresLength","_batchTexture","_styleCommandsNeededDirty","_styleCommandsNeeded","ALL_OPAQUE","initialize","Object","defineProperties","prototype","batchTexture","get","featuresLength","batchTextureByteLength","byteLength","styleCommandsNeededDirty","modelFeatureTable","is3DTiles","type","count","i","features","Array","content","featureId","featureTable","owner","statistics","tileset","update","frameState","currentStyleCommandsNeeded","getStyleCommandsNeeded","translucentFeaturesLength","setShow","show","setAllShow","getShow","setColor","color","setAllColor","getColor","result","getPickColor","getFeature","hasProperty","propertyName","hasPropertyBySemantic","getProperty","name","getPropertyBySemantic","semantic","getPropertyIds","results","setProperty","value","isClass","className","isExactClass","getExactClassName","scratchColor","applyStyle","style","DEFAULT_COLOR_VALUE","DEFAULT_SHOW_VALUE","feature","evaluateColor","evaluate","isDestroyed","destroy"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAEA;;;;;;;;;;;;;CAaC,GACD,SAASA,kBAAkBC,OAAO;IAChC,MAAMC,QAAQD,QAAQC,KAAK;IAC3B,MAAMC,gBAAgBF,QAAQE,aAAa;IAE3C,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,iBAAiBF;IACrC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,SAASH;IAC7B,wBAAwB;IAExB,IAAI,CAACI,cAAc,GAAGH;IACtB,IAAI,CAACI,MAAM,GAAGL;IAEd,IAAI,CAACM,SAAS,GAAGC;IACjB,IAAI,CAACC,eAAe,GAAG;IAEvB,IAAI,CAACC,aAAa,GAAGF;IAErB,IAAI,CAACG,yBAAyB,GAAG;IACjC,IAAI,CAACC,oBAAoB,GAAG,mMAAmB,CAACC,UAAU;IAE1DC,WAAW,IAAI;AACjB;AAEAC,OAAOC,gBAAgB,CAACjB,kBAAkBkB,SAAS,EAAE;IACnD;;;;;;;;;GASC,GACDC,cAAc;QACZC,KAAK;YACH,OAAO,IAAI,CAACT,aAAa;QAC3B;IACF;IAEA;;;;;;;;;GASC,GACDU,gBAAgB;QACdD,KAAK;YACH,OAAO,IAAI,CAACV,eAAe;QAC7B;IACF;IAEA;;;;;;;;;;GAUC,GACDY,wBAAwB;QACtBF,KAAK;YACH,IAAI,IAAA,6KAAO,EAAC,IAAI,CAACT,aAAa,GAAG;gBAC/B,OAAO,IAAI,CAACA,aAAa,CAACY,UAAU;YACtC;YAEA,OAAO;QACT;IACF;IAEA;;;;;;;;;GASC,GACDC,0BAA0B;QACxBJ,KAAK;YACH,OAAO,IAAI,CAACR,yBAAyB;QACvC;IACF;AACF;AAEA,SAASG,WAAWU,iBAAiB;IACnC,MAAMvB,QAAQuB,kBAAkBlB,MAAM;IACtC,MAAMmB,YAAY,yLAAS,CAACA,SAAS,CAACxB,MAAMyB,IAAI;IAEhD,MAAMN,iBAAiBI,kBAAkBnB,cAAc,CAACsB,KAAK;IAC7D,IAAIP,mBAAmB,GAAG;QACxB;IACF;IAEA,IAAIQ;IACJ,MAAMC,WAAW,IAAIC,MAAMV;IAC3B,IAAIK,WAAW;QACb,MAAMM,UAAU9B,MAAM8B,OAAO;QAC7B,IAAKH,IAAI,GAAGA,IAAIR,gBAAgBQ,IAAK;YACnCC,QAAQ,CAACD,EAAE,GAAG,IAAI,0LAAmB,CAACG,SAASH;QACjD;IACF,OAAO;QACL,IAAKA,IAAI,GAAGA,IAAIR,gBAAgBQ,IAAK;YACnCC,QAAQ,CAACD,EAAE,GAAG,IAAI,4LAAY,CAAC;gBAC7B3B,OAAOA;gBACP+B,WAAWJ;gBACXK,cAAcT;YAChB;QACF;IACF;IAEAA,kBAAkBjB,SAAS,GAAGsB;IAC9BL,kBAAkBf,eAAe,GAAGW;IAEpCI,kBAAkBd,aAAa,GAAG,IAAI,mLAAY,CAAC;QACjDU,gBAAgBA;QAChBc,OAAOV;QACPW,YAAYV,YAAYxB,MAAM8B,OAAO,CAACK,OAAO,CAACD,UAAU,GAAG3B;IAC7D;AACF;AAEA;;;;;;CAMC,GACDT,kBAAkBkB,SAAS,CAACoB,MAAM,GAAG,SAAUC,UAAU;IACvD,6DAA6D;IAC7D,IAAI,CAAC3B,yBAAyB,GAAG;IACjC,IAAI,CAACD,aAAa,CAAC2B,MAAM,CAAC7B,WAAW8B;IAErC,MAAMC,6BAA6B,mMAAmB,CAACC,sBAAsB,CAC3E,IAAI,CAAC/B,eAAe,EACpB,IAAI,CAACC,aAAa,CAAC+B,yBAAyB;IAG9C,IAAI,IAAI,CAAC7B,oBAAoB,KAAK2B,4BAA4B;QAC5D,IAAI,CAAC5B,yBAAyB,GAAG;QACjC,IAAI,CAACC,oBAAoB,GAAG2B;IAC9B;AACF;AAEAxC,kBAAkBkB,SAAS,CAACyB,OAAO,GAAG,SAAUV,SAAS,EAAEW,IAAI;IAC7D,IAAI,CAACjC,aAAa,CAACgC,OAAO,CAACV,WAAWW;AACxC;AAEA5C,kBAAkBkB,SAAS,CAAC2B,UAAU,GAAG,SAAUD,IAAI;IACrD,IAAI,CAACjC,aAAa,CAACkC,UAAU,CAACD;AAChC;AAEA5C,kBAAkBkB,SAAS,CAAC4B,OAAO,GAAG,SAAUb,SAAS;IACvD,OAAO,IAAI,CAACtB,aAAa,CAACmC,OAAO,CAACb;AACpC;AAEAjC,kBAAkBkB,SAAS,CAAC6B,QAAQ,GAAG,SAAUd,SAAS,EAAEe,KAAK;IAC/D,IAAI,CAACrC,aAAa,CAACoC,QAAQ,CAACd,WAAWe;AACzC;AAEAhD,kBAAkBkB,SAAS,CAAC+B,WAAW,GAAG,SAAUD,KAAK;IACvD,IAAI,CAACrC,aAAa,CAACsC,WAAW,CAACD;AACjC;AAEAhD,kBAAkBkB,SAAS,CAACgC,QAAQ,GAAG,SAAUjB,SAAS,EAAEkB,MAAM;IAChE,OAAO,IAAI,CAACxC,aAAa,CAACuC,QAAQ,CAACjB,WAAWkB;AAChD;AAEAnD,kBAAkBkB,SAAS,CAACkC,YAAY,GAAG,SAAUnB,SAAS;IAC5D,OAAO,IAAI,CAACtB,aAAa,CAACyC,YAAY,CAACnB;AACzC;AAEAjC,kBAAkBkB,SAAS,CAACmC,UAAU,GAAG,SAAUpB,SAAS;IAC1D,OAAO,IAAI,CAACzB,SAAS,CAACyB,UAAU;AAClC;AAEAjC,kBAAkBkB,SAAS,CAACoC,WAAW,GAAG,SAAUrB,SAAS,EAAEsB,YAAY;IACzE,OAAO,IAAI,CAACjD,cAAc,CAACgD,WAAW,CAACrB,WAAWsB;AACpD;AAEAvD,kBAAkBkB,SAAS,CAACsC,qBAAqB,GAAG,SAClDvB,SAAS,EACTsB,YAAY;IAEZ,OAAO,IAAI,CAACjD,cAAc,CAACkD,qBAAqB,CAACvB,WAAWsB;AAC9D;AAEAvD,kBAAkBkB,SAAS,CAACuC,WAAW,GAAG,SAAUxB,SAAS,EAAEyB,IAAI;IACjE,OAAO,IAAI,CAACpD,cAAc,CAACmD,WAAW,CAACxB,WAAWyB;AACpD;AAEA1D,kBAAkBkB,SAAS,CAACyC,qBAAqB,GAAG,SAClD1B,SAAS,EACT2B,QAAQ;IAER,OAAO,IAAI,CAACtD,cAAc,CAACqD,qBAAqB,CAAC1B,WAAW2B;AAC9D;AAEA5D,kBAAkBkB,SAAS,CAAC2C,cAAc,GAAG,SAAUC,OAAO;IAC5D,OAAO,IAAI,CAACxD,cAAc,CAACuD,cAAc,CAACC;AAC5C;AAEA9D,kBAAkBkB,SAAS,CAAC6C,WAAW,GAAG,SAAU9B,SAAS,EAAEyB,IAAI,EAAEM,KAAK;IACxE,OAAO,IAAI,CAAC1D,cAAc,CAACyD,WAAW,CAAC9B,WAAWyB,MAAMM;AAC1D;AAEAhE,kBAAkBkB,SAAS,CAAC+C,OAAO,GAAG,SAAUhC,SAAS,EAAEiC,SAAS;IAClE,OAAO,IAAI,CAAC5D,cAAc,CAAC2D,OAAO,CAAChC,WAAWiC;AAChD;AAEAlE,kBAAkBkB,SAAS,CAACiD,YAAY,GAAG,SAAUlC,SAAS,EAAEiC,SAAS;IACvE,OAAO,IAAI,CAAC5D,cAAc,CAAC6D,YAAY,CAAClC,WAAWiC;AACrD;AAEAlE,kBAAkBkB,SAAS,CAACkD,iBAAiB,GAAG,SAAUnC,SAAS;IACjE,OAAO,IAAI,CAAC3B,cAAc,CAAC8D,iBAAiB,CAACnC;AAC/C;AAEA,MAAMoC,eAAe,IAAI,2KAAK;AAC9B;;CAEC,GACDrE,kBAAkBkB,SAAS,CAACoD,UAAU,GAAG,SAAUC,KAAK;IACtD,IAAI,CAAC,IAAA,6KAAO,EAACA,QAAQ;QACnB,IAAI,CAACtB,WAAW,CAAC,mLAAY,CAACuB,mBAAmB;QACjD,IAAI,CAAC3B,UAAU,CAAC,mLAAY,CAAC4B,kBAAkB;QAC/C;IACF;IAEA,IAAK,IAAI5C,IAAI,GAAGA,IAAI,IAAI,CAACnB,eAAe,EAAEmB,IAAK;QAC7C,MAAM6C,UAAU,IAAI,CAACrB,UAAU,CAACxB;QAChC,MAAMmB,QAAQ,IAAA,6KAAO,EAACuB,MAAMvB,KAAK,IAC5BuB,MAAMvB,KAAK,CAAC2B,aAAa,CAACD,SAASL,iBACpC,mLAAY,CAACG,mBAAmB,GAChC,mLAAY,CAACA,mBAAmB;QACpC,MAAM5B,OAAO,IAAA,6KAAO,EAAC2B,MAAM3B,IAAI,IAC1B2B,MAAM3B,IAAI,CAACgC,QAAQ,CAACF,YAAY,mLAAY,CAACD,kBAAkB,GAChE,mLAAY,CAACA,kBAAkB;QAEnC,IAAI,CAAC1B,QAAQ,CAAClB,GAAGmB;QACjB,IAAI,CAACL,OAAO,CAACd,GAAGe;IAClB;AACF;AAEA;;;;;;;;;;;CAWC,GACD5C,kBAAkBkB,SAAS,CAAC2D,WAAW,GAAG;IACxC,OAAO;AACT;AAEA;;;;;;;;;;;;;;;;CAgBC,GACD7E,kBAAkBkB,SAAS,CAAC4D,OAAO,GAAG,SAAUvC,UAAU;IACxD,IAAI,CAAC5B,aAAa,GAAG,IAAI,CAACA,aAAa,IAAI,IAAI,CAACA,aAAa,CAACmE,OAAO;IACrE,IAAA,mLAAa,EAAC,IAAI;AACpB;uCAEe9E","ignoreList":[0]}},
    {"offset": {"line": 5701, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/TilesetPipelineStage.js"],"sourcesContent":["import combine from \"../../Core/combine.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport Cartesian2 from \"../../Core/Cartesian2.js\";\nimport StencilConstants from \"../StencilConstants.js\";\n\n/**\n * The tileset pipeline stage is responsible for updating the model with behavior\n * specific to 3D Tiles.\n *\n * @namespace TilesetPipelineStage\n *\n * @private\n */\nconst TilesetPipelineStage = {\n  name: \"TilesetPipelineStage\", // Helps with debugging\n};\n\n/**\n * Process a model. This modifies the following parts of the render resources:\n *\n * <ul>\n *  <li>adds a define to the fragment shader to indicate that the model uses polygon offset for the skipLevelOfDetail optimization</li>\n *  <li>adds a function to the uniform map to supply polygon offset values for the skipLevelOfDetail optimization</li>\n *  <li>sets stencil values that enable classification on 3D Tiles</li>\n * </ul>\n *\n * <p>\n * See {@link ModelDrawCommand} for the corresponding skipLevelOfDetail derived commands.\n * </p>\n *\n * @param {ModelRenderResources} renderResources The render resources for this model.\n * @param {ModelExperimental} model The model.\n * @param {FrameState} frameState The frameState.\n *\n * @private\n */\nTilesetPipelineStage.process = function (renderResources, model, frameState) {\n  if (model.hasSkipLevelOfDetail(frameState)) {\n    // Make the log-depth depth fragment write account for the polygon offset, too.\n    // Otherwise, the back face commands will cause the higher resolution\n    // tiles to disappear.\n    const shaderBuilder = renderResources.shaderBuilder;\n    shaderBuilder.addDefine(\n      \"POLYGON_OFFSET\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n\n    // This value will be overriden by the depth-only back face derived command.\n    // We just prepare it in advance so we don't have to recompile the shader.\n    // We don't add a uniform declaration through ShaderBuilder because\n    // this is included in writeLogDepth.glsl\n    const uniformMap = {\n      u_polygonOffset: function () {\n        return Cartesian2.ZERO;\n      },\n    };\n\n    renderResources.uniformMap = combine(\n      uniformMap,\n      renderResources.uniformMap,\n    );\n    renderResources.hasSkipLevelOfDetail = true;\n  }\n\n  // Set stencil values for classification on 3D Tiles. This is applied to all\n  // of the derived commands, not just the back-face derived command.\n  const renderStateOptions = renderResources.renderStateOptions;\n  renderStateOptions.stencilTest = StencilConstants.setCesium3DTileBit();\n  renderStateOptions.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n};\n\nexport default TilesetPipelineStage;\n"],"names":["TilesetPipelineStage","name","process","renderResources","model","frameState","hasSkipLevelOfDetail","shaderBuilder","addDefine","undefined","FRAGMENT","uniformMap","u_polygonOffset","ZERO","renderStateOptions","stencilTest","setCesium3DTileBit","stencilMask","CESIUM_3D_TILE_MASK"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;;;;;CAOC,GACD,MAAMA,uBAAuB;IAC3BC,MAAM;AACR;AAEA;;;;;;;;;;;;;;;;;;CAkBC,GACDD,qBAAqBE,OAAO,GAAG,SAAUC,eAAe,EAAEC,KAAK,EAAEC,UAAU;IACzE,IAAID,MAAME,oBAAoB,CAACD,aAAa;QAC1C,+EAA+E;QAC/E,qEAAqE;QACrE,sBAAsB;QACtB,MAAME,gBAAgBJ,gBAAgBI,aAAa;QACnDA,cAAcC,SAAS,CACrB,kBACAC,WACA,2LAAiB,CAACC,QAAQ;QAG5B,4EAA4E;QAC5E,0EAA0E;QAC1E,mEAAmE;QACnE,yCAAyC;QACzC,MAAMC,aAAa;YACjBC,iBAAiB;gBACf,OAAO,gLAAU,CAACC,IAAI;YACxB;QACF;QAEAV,gBAAgBQ,UAAU,GAAG,IAAA,6KAAO,EAClCA,YACAR,gBAAgBQ,UAAU;QAE5BR,gBAAgBG,oBAAoB,GAAG;IACzC;IAEA,4EAA4E;IAC5E,mEAAmE;IACnE,MAAMQ,qBAAqBX,gBAAgBW,kBAAkB;IAC7DA,mBAAmBC,WAAW,GAAG,uLAAgB,CAACC,kBAAkB;IACpEF,mBAAmBG,WAAW,GAAG,uLAAgB,CAACC,mBAAmB;AACvE;uCAEelB","ignoreList":[0]}},
    {"offset": {"line": 5771, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/AtmospherePipelineStage.js"],"sourcesContent":["import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport AtmosphereStageFS from \"../../Shaders/Model/AtmosphereStageFS.js\";\nimport AtmosphereStageVS from \"../../Shaders/Model/AtmosphereStageVS.js\";\n\n/**\n * The atmosphere pipeline stage applies all earth atmosphere effects that apply\n * to models, including fog.\n *\n * @namespace AtmospherePipelineStage\n *\n * @private\n */\nconst AtmospherePipelineStage = {\n  name: \"AtmospherePipelineStage\", // Helps with debugging\n};\n\n/**\n * @param {ModelRenderResources} modelRenderResources\n * @param {Model} model\n * @param {FrameState} frameState\n */\nAtmospherePipelineStage.process = function (\n  modelRenderResources,\n  model,\n  frameState,\n) {\n  const shaderBuilder = modelRenderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\"HAS_ATMOSPHERE\", undefined, ShaderDestination.BOTH);\n  shaderBuilder.addDefine(\n    \"COMPUTE_POSITION_WC_ATMOSPHERE\",\n    undefined,\n    ShaderDestination.BOTH,\n  );\n\n  shaderBuilder.addVarying(\"vec3\", \"v_atmosphereRayleighColor\");\n  shaderBuilder.addVarying(\"vec3\", \"v_atmosphereMieColor\");\n  shaderBuilder.addVarying(\"float\", \"v_atmosphereOpacity\");\n\n  shaderBuilder.addVertexLines([AtmosphereStageVS]);\n  shaderBuilder.addFragmentLines([AtmosphereStageFS]);\n\n  // Add a uniform so fog is only calculated when the effect would\n  // be non-negligible. For example when the camera is in space, fog density decreases\n  // to 0 so fog shouldn't be rendered. Since this state may change rapidly if\n  // the camera is moving, this is implemented as a uniform, not a define.\n  shaderBuilder.addUniform(\"bool\", \"u_isInFog\", ShaderDestination.FRAGMENT);\n  modelRenderResources.uniformMap.u_isInFog = function () {\n    // We only need a rough measure of distance to the model, so measure\n    // from the camera to the bounding sphere center.\n    const distance = Cartesian3.distance(\n      frameState.camera.positionWC,\n      model.boundingSphere.center,\n    );\n\n    return (\n      CesiumMath.fog(distance, frameState.fog.density) > CesiumMath.EPSILON3\n    );\n  };\n};\n\nexport default AtmospherePipelineStage;\n"],"names":["AtmospherePipelineStage","name","process","modelRenderResources","model","frameState","shaderBuilder","addDefine","undefined","BOTH","addVarying","addVertexLines","addFragmentLines","addUniform","FRAGMENT","uniformMap","u_isInFog","distance","camera","positionWC","boundingSphere","center","fog","density","EPSILON3"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;CAOC,GACD,MAAMA,0BAA0B;IAC9BC,MAAM;AACR;AAEA;;;;CAIC,GACDD,wBAAwBE,OAAO,GAAG,SAChCC,oBAAoB,EACpBC,KAAK,EACLC,UAAU;IAEV,MAAMC,gBAAgBH,qBAAqBG,aAAa;IAExDA,cAAcC,SAAS,CAAC,kBAAkBC,WAAW,2LAAiB,CAACC,IAAI;IAC3EH,cAAcC,SAAS,CACrB,kCACAC,WACA,2LAAiB,CAACC,IAAI;IAGxBH,cAAcI,UAAU,CAAC,QAAQ;IACjCJ,cAAcI,UAAU,CAAC,QAAQ;IACjCJ,cAAcI,UAAU,CAAC,SAAS;IAElCJ,cAAcK,cAAc,CAAC;QAAC,mMAAiB;KAAC;IAChDL,cAAcM,gBAAgB,CAAC;QAAC,mMAAiB;KAAC;IAElD,gEAAgE;IAChE,oFAAoF;IACpF,4EAA4E;IAC5E,wEAAwE;IACxEN,cAAcO,UAAU,CAAC,QAAQ,aAAa,2LAAiB,CAACC,QAAQ;IACxEX,qBAAqBY,UAAU,CAACC,SAAS,GAAG;QAC1C,oEAAoE;QACpE,iDAAiD;QACjD,MAAMC,WAAW,gLAAU,CAACA,QAAQ,CAClCZ,WAAWa,MAAM,CAACC,UAAU,EAC5Bf,MAAMgB,cAAc,CAACC,MAAM;QAG7B,OACE,0KAAU,CAACC,GAAG,CAACL,UAAUZ,WAAWiB,GAAG,CAACC,OAAO,IAAI,0KAAU,CAACC,QAAQ;IAE1E;AACF;uCAEexB","ignoreList":[0]}},
    {"offset": {"line": 5829, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ImageBasedLightingPipelineStage.js"],"sourcesContent":["import combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport ImageBasedLightingStageFS from \"../../Shaders/Model/ImageBasedLightingStageFS.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport SpecularEnvironmentCubeMap from \"../SpecularEnvironmentCubeMap.js\";\nimport Cartesian2 from \"../../Core/Cartesian2.js\";\n\nconst ImageBasedLightingPipelineStage = {\n  name: \"ImageBasedLightingPipelineStage\", // Helps with debugging\n};\n\nconst scratchCartesian = new Cartesian2();\n\n/**\n * Add shader code, uniforms, and defines related to image based lighting\n * @param {ModelRenderResources} renderResources\n * @param {Model} model\n * @param {FrameState} frameState\n * @private\n */\nImageBasedLightingPipelineStage.process = function (\n  renderResources,\n  model,\n  frameState,\n) {\n  const imageBasedLighting = model.imageBasedLighting;\n  const environmentMapManager = model.environmentMapManager;\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  // If environment maps or spherical harmonics are not specifically provided, use procedural lighting.\n  let specularEnvironmentMapAtlas;\n  if (!defined(imageBasedLighting.specularEnvironmentMaps)) {\n    specularEnvironmentMapAtlas = environmentMapManager.radianceCubeMap;\n  }\n  const sphericalHarmonicCoefficients =\n    imageBasedLighting.sphericalHarmonicCoefficients ??\n    environmentMapManager.sphericalHarmonicCoefficients;\n\n  shaderBuilder.addDefine(\n    \"USE_IBL_LIGHTING\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addUniform(\n    \"vec2\",\n    \"model_iblFactor\",\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (SpecularEnvironmentCubeMap.isSupported(frameState.context)) {\n    const addMatrix =\n      imageBasedLighting.useSphericalHarmonics ||\n      imageBasedLighting.useSpecularEnvironmentMaps ||\n      imageBasedLighting.enabled;\n    if (addMatrix) {\n      shaderBuilder.addUniform(\n        \"mat3\",\n        \"model_iblReferenceFrameMatrix\",\n        ShaderDestination.FRAGMENT,\n      );\n    }\n\n    if (defined(specularEnvironmentMapAtlas)) {\n      shaderBuilder.addDefine(\n        \"COMPUTE_POSITION_WC_ATMOSPHERE\",\n        undefined,\n        ShaderDestination.BOTH,\n      );\n    }\n\n    if (\n      defined(sphericalHarmonicCoefficients) &&\n      defined(sphericalHarmonicCoefficients[0])\n    ) {\n      shaderBuilder.addDefine(\n        \"DIFFUSE_IBL\",\n        undefined,\n        ShaderDestination.FRAGMENT,\n      );\n      shaderBuilder.addDefine(\n        \"CUSTOM_SPHERICAL_HARMONICS\",\n        undefined,\n        ShaderDestination.FRAGMENT,\n      );\n      shaderBuilder.addUniform(\n        \"vec3\",\n        \"model_sphericalHarmonicCoefficients[9]\",\n        ShaderDestination.FRAGMENT,\n      );\n    } else if (imageBasedLighting.useDefaultSphericalHarmonics) {\n      shaderBuilder.addDefine(\n        \"DIFFUSE_IBL\",\n        undefined,\n        ShaderDestination.FRAGMENT,\n      );\n    }\n\n    if (\n      (defined(imageBasedLighting.specularEnvironmentCubeMap) &&\n        imageBasedLighting.specularEnvironmentCubeMap.ready) ||\n      defined(specularEnvironmentMapAtlas)\n    ) {\n      shaderBuilder.addDefine(\n        \"SPECULAR_IBL\",\n        undefined,\n        ShaderDestination.FRAGMENT,\n      );\n      shaderBuilder.addDefine(\n        \"CUSTOM_SPECULAR_IBL\",\n        undefined,\n        ShaderDestination.FRAGMENT,\n      );\n      shaderBuilder.addUniform(\n        \"samplerCube\",\n        \"model_specularEnvironmentMaps\",\n        ShaderDestination.FRAGMENT,\n      );\n      shaderBuilder.addUniform(\n        \"float\",\n        \"model_specularEnvironmentMapsMaximumLOD\",\n        ShaderDestination.FRAGMENT,\n      );\n    } else if (model.useDefaultSpecularMaps) {\n      shaderBuilder.addDefine(\n        \"SPECULAR_IBL\",\n        undefined,\n        ShaderDestination.FRAGMENT,\n      );\n    }\n  }\n\n  shaderBuilder.addFragmentLines(ImageBasedLightingStageFS);\n\n  const uniformMap = {\n    model_iblFactor: function () {\n      return Cartesian2.multiplyByScalar(\n        imageBasedLighting.imageBasedLightingFactor,\n        environmentMapManager?.intensity || 1.0,\n        scratchCartesian,\n      );\n    },\n    model_iblReferenceFrameMatrix: function () {\n      return model._iblReferenceFrameMatrix;\n    },\n    model_sphericalHarmonicCoefficients: function () {\n      return sphericalHarmonicCoefficients;\n    },\n    model_specularEnvironmentMaps: function () {\n      return imageBasedLighting.specularEnvironmentCubeMap.texture;\n    },\n    model_specularEnvironmentMapsMaximumLOD: function () {\n      return imageBasedLighting.specularEnvironmentCubeMap.maximumMipmapLevel;\n    },\n  };\n\n  if (defined(specularEnvironmentMapAtlas)) {\n    uniformMap.model_specularEnvironmentMaps = function () {\n      return specularEnvironmentMapAtlas;\n    };\n    uniformMap.model_specularEnvironmentMapsMaximumLOD = function () {\n      return environmentMapManager.maximumMipmapLevel;\n    };\n  }\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\n\nexport default ImageBasedLightingPipelineStage;\n"],"names":["ImageBasedLightingPipelineStage","name","scratchCartesian","process","renderResources","model","frameState","imageBasedLighting","environmentMapManager","shaderBuilder","specularEnvironmentMapAtlas","specularEnvironmentMaps","radianceCubeMap","sphericalHarmonicCoefficients","addDefine","undefined","FRAGMENT","addUniform","isSupported","context","addMatrix","useSphericalHarmonics","useSpecularEnvironmentMaps","enabled","BOTH","useDefaultSphericalHarmonics","specularEnvironmentCubeMap","ready","useDefaultSpecularMaps","addFragmentLines","uniformMap","model_iblFactor","multiplyByScalar","imageBasedLightingFactor","intensity","model_iblReferenceFrameMatrix","_iblReferenceFrameMatrix","model_sphericalHarmonicCoefficients","model_specularEnvironmentMaps","texture","model_specularEnvironmentMapsMaximumLOD","maximumMipmapLevel"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5924, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelArticulationStage.js"],"sourcesContent":["import ArticulationStageType from \"../../Core/ArticulationStageType.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport Check from \"../../Core/Check.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\n\nconst articulationEpsilon = CesiumMath.EPSILON16;\n\n/**\n * An in-memory representation of an articulation stage belonging to a\n * {@link ModelArticulation}.\n *\n * @param {object} options An object containing the following options:\n * @param {ModelComponents.ArticulationStage} options.stage The articulation stage components from the 3D model.\n * @param {ModelArticulation} options.runtimeArticulation The runtime articulation that this stage belongs to.\n *\n * @alias ModelArticulationStage\n * @constructor\n *\n * @private\n */\nfunction ModelArticulationStage(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const stage = options.stage;\n  const runtimeArticulation = options.runtimeArticulation;\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.stage\", stage);\n  Check.typeOf.object(\"options.runtimeArticulation\", runtimeArticulation);\n  //>>includeEnd('debug');\n\n  this._stage = stage;\n  this._runtimeArticulation = runtimeArticulation;\n\n  this._name = stage.name;\n  this._type = stage.type;\n  this._minimumValue = stage.minimumValue;\n  this._maximumValue = stage.maximumValue;\n  this._currentValue = stage.initialValue;\n}\n\nObject.defineProperties(ModelArticulationStage.prototype, {\n  /**\n   * The internal articulation stage that this runtime stage represents.\n   *\n   * @memberof ModelArticulationStage.prototype\n   * @type {ModelComponents.ArticulationStage}\n   * @readonly\n   *\n   * @private\n   */\n  stage: {\n    get: function () {\n      return this._stage;\n    },\n  },\n\n  /**\n   * The runtime articulation that this stage belongs to.\n   *\n   * @memberof ModelArticulationStage.prototype\n   * @type {ModelArticulation}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeArticulation: {\n    get: function () {\n      return this._runtimeArticulation;\n    },\n  },\n\n  /**\n   * The name of this articulation stage.\n   *\n   * @memberof ModelArticulationStage.prototype\n   * @type {string}\n   * @readonly\n   *\n   * @private\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The type of this articulation stage. This specifies which of the\n   * node's properties is modified by the stage's value.\n   *\n   * @memberof ModelArticulationStage.prototype\n   * @type {ArticulationStageType}\n   * @readonly\n   *\n   * @private\n   */\n  type: {\n    get: function () {\n      return this._type;\n    },\n  },\n\n  /**\n   * The minimum value of this articulation stage.\n   *\n   * @memberof ModelArticulationStage.prototype\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  minimumValue: {\n    get: function () {\n      return this._minimumValue;\n    },\n  },\n\n  /**\n   * The maximum value of this articulation stage.\n   *\n   * @memberof ModelArticulationStage.prototype\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  maximumValue: {\n    get: function () {\n      return this._maximumValue;\n    },\n  },\n\n  /**\n   * The current value of this articulation stage.\n   *\n   * @memberof ModelArticulationStage.prototype\n   * @type {number}\n   *\n   * @private\n   */\n  currentValue: {\n    get: function () {\n      return this._currentValue;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"value\", value);\n      //>>includeEnd('debug');\n\n      value = CesiumMath.clamp(value, this.minimumValue, this.maximumValue);\n      if (\n        !CesiumMath.equalsEpsilon(\n          this._currentValue,\n          value,\n          articulationEpsilon,\n        )\n      ) {\n        this._currentValue = value;\n        this.runtimeArticulation._dirty = true;\n      }\n    },\n  },\n});\n\nconst scratchArticulationCartesian = new Cartesian3();\nconst scratchArticulationRotation = new Matrix3();\n\n/**\n * Modifies a Matrix4 by applying a transformation for a given value of a stage.\n * Note that the <code>result</code> parameter is not just a container for the\n * returned value. The incoming value of <code>result</code> is part of the\n * computation itself. Various stages of an articulation can be multiplied\n * together, so their transformations are all merged into a composite Matrix4\n * representing them all.\n *\n * @param {Matrix4} result The matrix to be modified.\n * @returns {Matrix4} The transformed matrix as requested by the articulation stage.\n *\n * @private\n */\nModelArticulationStage.prototype.applyStageToMatrix = function (result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const type = this.type;\n  const value = this.currentValue;\n  const cartesian = scratchArticulationCartesian;\n  let rotation;\n  switch (type) {\n    case ArticulationStageType.XROTATE:\n      rotation = Matrix3.fromRotationX(\n        CesiumMath.toRadians(value),\n        scratchArticulationRotation,\n      );\n      result = Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n    case ArticulationStageType.YROTATE:\n      rotation = Matrix3.fromRotationY(\n        CesiumMath.toRadians(value),\n        scratchArticulationRotation,\n      );\n      result = Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n    case ArticulationStageType.ZROTATE:\n      rotation = Matrix3.fromRotationZ(\n        CesiumMath.toRadians(value),\n        scratchArticulationRotation,\n      );\n      result = Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n    case ArticulationStageType.XTRANSLATE:\n      cartesian.x = value;\n      cartesian.y = 0.0;\n      cartesian.z = 0.0;\n      result = Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n    case ArticulationStageType.YTRANSLATE:\n      cartesian.x = 0.0;\n      cartesian.y = value;\n      cartesian.z = 0.0;\n      result = Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n    case ArticulationStageType.ZTRANSLATE:\n      cartesian.x = 0.0;\n      cartesian.y = 0.0;\n      cartesian.z = value;\n      result = Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n    case ArticulationStageType.XSCALE:\n      cartesian.x = value;\n      cartesian.y = 1.0;\n      cartesian.z = 1.0;\n      result = Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n    case ArticulationStageType.YSCALE:\n      cartesian.x = 1.0;\n      cartesian.y = value;\n      cartesian.z = 1.0;\n      result = Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n    case ArticulationStageType.ZSCALE:\n      cartesian.x = 1.0;\n      cartesian.y = 1.0;\n      cartesian.z = value;\n      result = Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n    case ArticulationStageType.UNIFORMSCALE:\n      result = Matrix4.multiplyByUniformScale(result, value, result);\n      break;\n    default:\n      break;\n  }\n\n  return result;\n};\n\nexport default ModelArticulationStage;\n"],"names":["articulationEpsilon","EPSILON16","ModelArticulationStage","options","EMPTY_OBJECT","stage","runtimeArticulation","typeOf","object","_stage","_runtimeArticulation","_name","name","_type","type","_minimumValue","minimumValue","_maximumValue","maximumValue","_currentValue","initialValue","Object","defineProperties","prototype","get","currentValue","set","value","number","clamp","equalsEpsilon","_dirty","scratchArticulationCartesian","scratchArticulationRotation","applyStageToMatrix","result","cartesian","rotation","XROTATE","fromRotationX","toRadians","multiplyByMatrix3","YROTATE","fromRotationY","ZROTATE","fromRotationZ","XTRANSLATE","x","y","z","multiplyByTranslation","YTRANSLATE","ZTRANSLATE","XSCALE","multiplyByScale","YSCALE","ZSCALE","UNIFORMSCALE","multiplyByUniformScale"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6158, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelArticulation.js"],"sourcesContent":["import Check from \"../../Core/Check.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport ModelArticulationStage from \"./ModelArticulationStage.js\";\n\n/**\n * An in-memory representation of an articulation that affects nodes in the\n * {@link ModelSceneGraph}. This is defined in a model by the\n * <code>AGI_articulations</code> extension.\n *\n * @param {object} options An object containing the following options:\n * @param {ModelComponents.Articulation} options.articulation The articulation components from the 3D model.\n * @param {ModelSceneGraph} options.sceneGraph The scene graph this articulation belongs to.\n *\n * @alias ModelArticulation\n * @constructor\n *\n * @private\n */\nfunction ModelArticulation(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const articulation = options.articulation;\n  const sceneGraph = options.sceneGraph;\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.articulation\", articulation);\n  Check.typeOf.object(\"options.sceneGraph\", sceneGraph);\n  //>>includeEnd('debug');\n\n  this._articulation = articulation;\n  this._sceneGraph = sceneGraph;\n\n  this._name = articulation.name;\n  this._runtimeStages = [];\n  this._runtimeStagesByName = {};\n\n  // Will be populated as the runtime nodes are created\n  this._runtimeNodes = [];\n\n  // Set to true so that the first call to\n  // ModelSceneGraph.applyArticulations will work.\n  this._dirty = true;\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelArticulation.prototype, {\n  /**\n   * The internal articulation that this runtime articulation represents.\n   *\n   * @memberof ModelArticulation.prototype\n   * @type {ModelComponents.Articulation}\n   * @readonly\n   *\n   * @private\n   */\n  articulation: {\n    get: function () {\n      return this._articulation;\n    },\n  },\n\n  /**\n   * The scene graph that this articulation belongs to.\n   *\n   * @memberof ModelArticulation.prototype\n   * @type {ModelSceneGraph}\n   * @readonly\n   *\n   * @private\n   */\n  sceneGraph: {\n    get: function () {\n      return this._sceneGraph;\n    },\n  },\n\n  /**\n   * The name of this articulation.\n   *\n   * @memberof ModelArticulation.prototype\n   * @type {string}\n   * @readonly\n   *\n   * @private\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The runtime stages that belong to this articulation.\n   *\n   * @memberof ModelArticulation.prototype\n   * @type {ModelArticulationStage[]}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeStages: {\n    get: function () {\n      return this._runtimeStages;\n    },\n  },\n\n  /**\n   * The runtime nodes that are affected by this articulation.\n   *\n   * @memberof ModelArticulation.prototype\n   * @type {ModelRuntimeNode[]}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeNodes: {\n    get: function () {\n      return this._runtimeNodes;\n    },\n  },\n});\n\nfunction initialize(runtimeArticulation) {\n  const articulation = runtimeArticulation.articulation;\n\n  const stages = articulation.stages;\n  const length = stages.length;\n\n  const runtimeStages = runtimeArticulation._runtimeStages;\n  const runtimeStagesByName = runtimeArticulation._runtimeStagesByName;\n  for (let i = 0; i < length; i++) {\n    const stage = stages[i];\n    const runtimeStage = new ModelArticulationStage({\n      stage: stage,\n      runtimeArticulation: runtimeArticulation,\n    });\n\n    // Store the stages in an array to preserve the order in which\n    // they appeared in the 3D model.\n    runtimeStages.push(runtimeStage);\n\n    // Store the stages in a dictionary for retrieval by name.\n    const stageName = stage.name;\n    runtimeStagesByName[stageName] = runtimeStage;\n  }\n}\n\n/**\n * Sets the current value of an articulation stage.\n *\n * @param {string} stageName The name of the articulation stage.\n * @param {number} value The numeric value of this stage of the articulation.\n *\n * @private\n */\nModelArticulation.prototype.setArticulationStage = function (stageName, value) {\n  const stage = this._runtimeStagesByName[stageName];\n  if (defined(stage)) {\n    stage.currentValue = value;\n  }\n};\n\nconst scratchArticulationMatrix = new Matrix4();\nconst scratchNodeMatrix = new Matrix4();\n\n/**\n * Applies the chain of articulation stages to the transform of each node that\n * participates in the articulation. This only recomputes the node transforms\n * if any stage in the articulation has been modified.\n * <p>\n * Note that this will overwrite any existing transformations on participating\n * nodes.\n * </p>\n *\n * @private\n */\nModelArticulation.prototype.apply = function () {\n  if (!this._dirty) {\n    return;\n  }\n  this._dirty = false;\n\n  let articulationMatrix = Matrix4.clone(\n    Matrix4.IDENTITY,\n    scratchArticulationMatrix,\n  );\n\n  let i;\n  const stages = this._runtimeStages;\n  const stagesLength = stages.length;\n\n  // Compute the result of the articulation stages...\n  for (i = 0; i < stagesLength; i++) {\n    const stage = stages[i];\n    articulationMatrix = stage.applyStageToMatrix(articulationMatrix);\n  }\n\n  // ...then apply it to the transforms of the affected nodes.\n  const nodes = this._runtimeNodes;\n  const nodesLength = nodes.length;\n  for (i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    const transform = Matrix4.multiplyTransformation(\n      node.originalTransform,\n      articulationMatrix,\n      scratchNodeMatrix,\n    );\n    node.transform = transform;\n  }\n};\n\nexport default ModelArticulation;\n"],"names":["ModelArticulation","options","EMPTY_OBJECT","articulation","sceneGraph","typeOf","object","_articulation","_sceneGraph","_name","name","_runtimeStages","_runtimeStagesByName","_runtimeNodes","_dirty","initialize","Object","defineProperties","prototype","get","runtimeStages","runtimeNodes","runtimeArticulation","stages","length","runtimeStagesByName","i","stage","runtimeStage","push","stageName","setArticulationStage","value","currentValue","scratchArticulationMatrix","scratchNodeMatrix","apply","articulationMatrix","clone","IDENTITY","stagesLength","applyStageToMatrix","nodes","nodesLength","node","transform","multiplyTransformation","originalTransform"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6345, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelColorPipelineStage.js"],"sourcesContent":["import ColorBlendMode from \"../ColorBlendMode.js\";\nimport combine from \"../../Core/combine.js\";\nimport ModelColorStageFS from \"../../Shaders/Model/ModelColorStageFS.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\n\n/**\n * The model color pipeline stage is responsible for handling the application of a static color to the model.\n *\n * @namespace ModelColorPipelineStage\n *\n * @private\n */\nconst ModelColorPipelineStage = {\n  name: \"ModelColorPipelineStage\", // Helps with debugging\n\n  COLOR_UNIFORM_NAME: \"model_color\",\n  COLOR_BLEND_UNIFORM_NAME: \"model_colorBlend\",\n};\n\n/**\n * Process a model. This modifies the following parts of the render resources:\n *\n * <ul>\n *  <li>adds a define to the fragment shader to indicate that the model has a color</li>\n *  <li>adds a function to the fragment shader to apply the color to the model's base color</li>\n *  <li>adds the uniforms for the fragment shader for the model's color and blending properties</li>\n *  <li>updates the pass type in the render resources based on translucency of the model's color</li>\n *</ul>\n *\n * @param {ModelRenderResources} renderResources The render resources for this model.\n * @param {Model} model The model.\n * @param {FrameState} frameState The frameState.\n *\n * @private\n */\nModelColorPipelineStage.process = function (\n  renderResources,\n  model,\n  frameState,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\n    \"HAS_MODEL_COLOR\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addFragmentLines(ModelColorStageFS);\n\n  const stageUniforms = {};\n\n  // Pass the model's color as a uniform. Set the pass type to translucent, if needed.\n  const color = model.color;\n\n  if (color.alpha === 0.0 && !model.hasSilhouette(frameState)) {\n    renderResources.renderStateOptions.colorMask = {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false,\n    };\n  }\n\n  if (color.alpha < 1.0) {\n    renderResources.alphaOptions.pass = Pass.TRANSLUCENT;\n  }\n\n  shaderBuilder.addUniform(\n    \"vec4\",\n    ModelColorPipelineStage.COLOR_UNIFORM_NAME,\n    ShaderDestination.FRAGMENT,\n  );\n  stageUniforms[ModelColorPipelineStage.COLOR_UNIFORM_NAME] = function () {\n    return model.color;\n  };\n\n  // Create a colorBlend from the model's colorBlendMode and colorBlendAmount and pass it as a uniform.\n  shaderBuilder.addUniform(\n    \"float\",\n    ModelColorPipelineStage.COLOR_BLEND_UNIFORM_NAME,\n    ShaderDestination.FRAGMENT,\n  );\n  stageUniforms[ModelColorPipelineStage.COLOR_BLEND_UNIFORM_NAME] =\n    function () {\n      return ColorBlendMode.getColorBlend(\n        model.colorBlendMode,\n        model.colorBlendAmount,\n      );\n    };\n\n  renderResources.uniformMap = combine(\n    stageUniforms,\n    renderResources.uniformMap,\n  );\n};\n\nexport default ModelColorPipelineStage;\n"],"names":["ModelColorPipelineStage","name","COLOR_UNIFORM_NAME","COLOR_BLEND_UNIFORM_NAME","process","renderResources","model","frameState","shaderBuilder","addDefine","undefined","FRAGMENT","addFragmentLines","stageUniforms","color","alpha","hasSilhouette","renderStateOptions","colorMask","red","green","blue","alphaOptions","pass","TRANSLUCENT","addUniform","getColorBlend","colorBlendMode","colorBlendAmount","uniformMap"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;CAMC,GACD,MAAMA,0BAA0B;IAC9BC,MAAM;IAENC,oBAAoB;IACpBC,0BAA0B;AAC5B;AAEA;;;;;;;;;;;;;;;CAeC,GACDH,wBAAwBI,OAAO,GAAG,SAChCC,eAAe,EACfC,KAAK,EACLC,UAAU;IAEV,MAAMC,gBAAgBH,gBAAgBG,aAAa;IAEnDA,cAAcC,SAAS,CACrB,mBACAC,WACA,2LAAiB,CAACC,QAAQ;IAE5BH,cAAcI,gBAAgB,CAAC,mMAAiB;IAEhD,MAAMC,gBAAgB,CAAC;IAEvB,oFAAoF;IACpF,MAAMC,QAAQR,MAAMQ,KAAK;IAEzB,IAAIA,MAAMC,KAAK,KAAK,OAAO,CAACT,MAAMU,aAAa,CAACT,aAAa;QAC3DF,gBAAgBY,kBAAkB,CAACC,SAAS,GAAG;YAC7CC,KAAK;YACLC,OAAO;YACPC,MAAM;YACNN,OAAO;QACT;IACF;IAEA,IAAID,MAAMC,KAAK,GAAG,KAAK;QACrBV,gBAAgBiB,YAAY,CAACC,IAAI,GAAG,8KAAI,CAACC,WAAW;IACtD;IAEAhB,cAAciB,UAAU,CACtB,QACAzB,wBAAwBE,kBAAkB,EAC1C,2LAAiB,CAACS,QAAQ;IAE5BE,aAAa,CAACb,wBAAwBE,kBAAkB,CAAC,GAAG;QAC1D,OAAOI,MAAMQ,KAAK;IACpB;IAEA,qGAAqG;IACrGN,cAAciB,UAAU,CACtB,SACAzB,wBAAwBG,wBAAwB,EAChD,2LAAiB,CAACQ,QAAQ;IAE5BE,aAAa,CAACb,wBAAwBG,wBAAwB,CAAC,GAC7D;QACE,OAAO,qLAAc,CAACuB,aAAa,CACjCpB,MAAMqB,cAAc,EACpBrB,MAAMsB,gBAAgB;IAE1B;IAEFvB,gBAAgBwB,UAAU,GAAG,IAAA,6KAAO,EAClChB,eACAR,gBAAgBwB,UAAU;AAE9B;uCAEe7B","ignoreList":[0]}},
    {"offset": {"line": 6419, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelClippingPlanesPipelineStage.js"],"sourcesContent":["import Cartesian2 from \"../../Core/Cartesian2.js\";\nimport ClippingPlaneCollection from \"../ClippingPlaneCollection.js\";\nimport combine from \"../../Core/combine.js\";\nimport Color from \"../../Core/Color.js\";\nimport ModelClippingPlanesStageFS from \"../../Shaders/Model/ModelClippingPlanesStageFS.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\n\n/**\n * The model clipping planes stage is responsible for applying clipping planes to the model.\n *\n * @namespace ModelClippingPlanesPipelineStage\n *\n * @private\n */\nconst ModelClippingPlanesPipelineStage = {\n  name: \"ModelClippingPlanesPipelineStage\", // Helps with debugging\n};\n\nconst textureResolutionScratch = new Cartesian2();\n/**\n * Process a model. This modifies the following parts of the render resources:\n *\n * <ul>\n *  <li>adds a define to the fragment shader to indicate that the model has clipping planes</li>\n *  <li>adds the defines to the fragment shader for parameters related to clipping planes, such as the number of planes</li>\n *  <li>adds a function to the fragment shader to apply the clipping planes to the model's base color</li>\n *  <li>adds the uniforms for the fragment shader for the clipping plane texture and matrix</li>\n *</ul>\n *\n * @param {ModelRenderResources} renderResources The render resources for this model.\n * @param {Model} model The model.\n * @param {FrameState} frameState The frameState.\n *\n * @private\n */\nModelClippingPlanesPipelineStage.process = function (\n  renderResources,\n  model,\n  frameState,\n) {\n  const clippingPlanes = model.clippingPlanes;\n  const context = frameState.context;\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\n    \"HAS_CLIPPING_PLANES\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  shaderBuilder.addDefine(\n    \"CLIPPING_PLANES_LENGTH\",\n    clippingPlanes.length,\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (clippingPlanes.unionClippingRegions) {\n    shaderBuilder.addDefine(\n      \"UNION_CLIPPING_REGIONS\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (ClippingPlaneCollection.useFloatTexture(context)) {\n    shaderBuilder.addDefine(\n      \"USE_CLIPPING_PLANES_FLOAT_TEXTURE\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  const textureResolution = ClippingPlaneCollection.getTextureResolution(\n    clippingPlanes,\n    context,\n    textureResolutionScratch,\n  );\n\n  shaderBuilder.addDefine(\n    \"CLIPPING_PLANES_TEXTURE_WIDTH\",\n    textureResolution.x,\n    ShaderDestination.FRAGMENT,\n  );\n\n  shaderBuilder.addDefine(\n    \"CLIPPING_PLANES_TEXTURE_HEIGHT\",\n    textureResolution.y,\n    ShaderDestination.FRAGMENT,\n  );\n\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    \"model_clippingPlanes\",\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addUniform(\n    \"vec4\",\n    \"model_clippingPlanesEdgeStyle\",\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addUniform(\n    \"mat4\",\n    \"model_clippingPlanesMatrix\",\n    ShaderDestination.FRAGMENT,\n  );\n\n  shaderBuilder.addFragmentLines(ModelClippingPlanesStageFS);\n\n  const uniformMap = {\n    model_clippingPlanes: function () {\n      return clippingPlanes.texture;\n    },\n    model_clippingPlanesEdgeStyle: function () {\n      const style = Color.clone(clippingPlanes.edgeColor);\n      style.alpha = clippingPlanes.edgeWidth;\n      return style;\n    },\n    model_clippingPlanesMatrix: function () {\n      return model._clippingPlanesMatrix;\n    },\n  };\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\n\nexport default ModelClippingPlanesPipelineStage;\n"],"names":["ModelClippingPlanesPipelineStage","name","textureResolutionScratch","process","renderResources","model","frameState","clippingPlanes","context","shaderBuilder","addDefine","undefined","FRAGMENT","length","unionClippingRegions","useFloatTexture","textureResolution","getTextureResolution","x","y","addUniform","addFragmentLines","uniformMap","model_clippingPlanes","texture","model_clippingPlanesEdgeStyle","style","clone","edgeColor","alpha","edgeWidth","model_clippingPlanesMatrix","_clippingPlanesMatrix"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEA;;;;;;CAMC,GACD,MAAMA,mCAAmC;IACvCC,MAAM;AACR;AAEA,MAAMC,2BAA2B,IAAI,gLAAU;AAC/C;;;;;;;;;;;;;;;CAeC,GACDF,iCAAiCG,OAAO,GAAG,SACzCC,eAAe,EACfC,KAAK,EACLC,UAAU;IAEV,MAAMC,iBAAiBF,MAAME,cAAc;IAC3C,MAAMC,UAAUF,WAAWE,OAAO;IAClC,MAAMC,gBAAgBL,gBAAgBK,aAAa;IAEnDA,cAAcC,SAAS,CACrB,uBACAC,WACA,2LAAiB,CAACC,QAAQ;IAG5BH,cAAcC,SAAS,CACrB,0BACAH,eAAeM,MAAM,EACrB,2LAAiB,CAACD,QAAQ;IAG5B,IAAIL,eAAeO,oBAAoB,EAAE;QACvCL,cAAcC,SAAS,CACrB,0BACAC,WACA,2LAAiB,CAACC,QAAQ;IAE9B;IAEA,IAAI,8LAAuB,CAACG,eAAe,CAACP,UAAU;QACpDC,cAAcC,SAAS,CACrB,qCACAC,WACA,2LAAiB,CAACC,QAAQ;IAE9B;IAEA,MAAMI,oBAAoB,8LAAuB,CAACC,oBAAoB,CACpEV,gBACAC,SACAN;IAGFO,cAAcC,SAAS,CACrB,iCACAM,kBAAkBE,CAAC,EACnB,2LAAiB,CAACN,QAAQ;IAG5BH,cAAcC,SAAS,CACrB,kCACAM,kBAAkBG,CAAC,EACnB,2LAAiB,CAACP,QAAQ;IAG5BH,cAAcW,UAAU,CACtB,aACA,wBACA,2LAAiB,CAACR,QAAQ;IAE5BH,cAAcW,UAAU,CACtB,QACA,iCACA,2LAAiB,CAACR,QAAQ;IAE5BH,cAAcW,UAAU,CACtB,QACA,8BACA,2LAAiB,CAACR,QAAQ;IAG5BH,cAAcY,gBAAgB,CAAC,4MAA0B;IAEzD,MAAMC,aAAa;QACjBC,sBAAsB;YACpB,OAAOhB,eAAeiB,OAAO;QAC/B;QACAC,+BAA+B;YAC7B,MAAMC,QAAQ,2KAAK,CAACC,KAAK,CAACpB,eAAeqB,SAAS;YAClDF,MAAMG,KAAK,GAAGtB,eAAeuB,SAAS;YACtC,OAAOJ;QACT;QACAK,4BAA4B;YAC1B,OAAO1B,MAAM2B,qBAAqB;QACpC;IACF;IAEA5B,gBAAgBkB,UAAU,GAAG,IAAA,6KAAO,EAACA,YAAYlB,gBAAgBkB,UAAU;AAC7E;uCAEetB","ignoreList":[0]}},
    {"offset": {"line": 6499, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelClippingPolygonsPipelineStage.js"],"sourcesContent":["import combine from \"../../Core/combine.js\";\nimport ModelClippingPolygonsStageVS from \"../../Shaders/Model/ModelClippingPolygonsStageVS.js\";\nimport ModelClippingPolygonsStageFS from \"../../Shaders/Model/ModelClippingPolygonsStageFS.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\n\n/**\n * The model clipping planes stage is responsible for applying clipping planes to the model.\n *\n * @namespace ModelClippingPolygonsPipelineStage\n *\n * @private\n */\nconst ModelClippingPolygonsPipelineStage = {\n  name: \"ModelClippingPolygonsPipelineStage\", // Helps with debugging\n};\n\n/**\n * Process a model for polygon clipping. This modifies the following parts of the render resources:\n *\n * <ul>\n *  <li>adds a define to both the vertex and fragment shaders to indicate that the model has clipping polygons</li>\n *  <li>adds the defines to both the vertex and fragment shaders for parameters related to clipping polygons, such as the number of polygons</li>\n *  <li>adds a function to the vertex shader to determine lookup uvs</li>\n *  <li>adds a function to the fragment shader to discard clipped regions</li>\n *  <li>adds the uniforms to the vertex and fragment shaders for the clipping extents texture and clipping distance respectively</li>\n *  <li>adds a varying for lookup uvs in the clipping texture</li>\n *</ul>\n *\n * @param {ModelRenderResources} renderResources The render resources for this model.\n * @param {Model} model The model.\n * @param {FrameState} frameState The frameState.\n *\n * @private\n */\nModelClippingPolygonsPipelineStage.process = function (\n  renderResources,\n  model,\n  frameState,\n) {\n  const clippingPolygons = model.clippingPolygons;\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\n    \"ENABLE_CLIPPING_POLYGONS\",\n    undefined,\n    ShaderDestination.BOTH,\n  );\n\n  if (clippingPolygons.inverse) {\n    shaderBuilder.addDefine(\n      \"CLIPPING_INVERSE\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  shaderBuilder.addDefine(\n    \"CLIPPING_POLYGON_REGIONS_LENGTH\",\n    clippingPolygons.extentsCount,\n    ShaderDestination.BOTH,\n  );\n\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    \"model_clippingDistance\",\n    ShaderDestination.FRAGMENT,\n  );\n\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    \"model_clippingExtents\",\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addVarying(\"vec2\", \"v_clippingPosition\");\n  shaderBuilder.addVarying(\"int\", \"v_regionIndex\", \"flat\");\n  shaderBuilder.addVertexLines(ModelClippingPolygonsStageVS);\n  shaderBuilder.addFragmentLines(ModelClippingPolygonsStageFS);\n\n  const uniformMap = {\n    model_clippingDistance: function () {\n      return (\n        // The later should never happen during a render pass, see https://github.com/CesiumGS/cesium/issues/12725\n        clippingPolygons.clippingTexture ?? frameState.context.defaultTexture\n      );\n    },\n    model_clippingExtents: function () {\n      return (\n        // The later should never happen during a render pass, see https://github.com/CesiumGS/cesium/issues/12725\n        clippingPolygons.extentsTexture ?? frameState.context.defaultTexture\n      );\n    },\n  };\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\n\nexport default ModelClippingPolygonsPipelineStage;\n"],"names":["ModelClippingPolygonsPipelineStage","name","process","renderResources","model","frameState","clippingPolygons","shaderBuilder","addDefine","undefined","BOTH","inverse","FRAGMENT","extentsCount","addUniform","VERTEX","addVarying","addVertexLines","addFragmentLines","uniformMap","model_clippingDistance","clippingTexture","context","defaultTexture","model_clippingExtents","extentsTexture"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;;;;CAMC,GACD,MAAMA,qCAAqC;IACzCC,MAAM;AACR;AAEA;;;;;;;;;;;;;;;;;CAiBC,GACDD,mCAAmCE,OAAO,GAAG,SAC3CC,eAAe,EACfC,KAAK,EACLC,UAAU;IAEV,MAAMC,mBAAmBF,MAAME,gBAAgB;IAC/C,MAAMC,gBAAgBJ,gBAAgBI,aAAa;IAEnDA,cAAcC,SAAS,CACrB,4BACAC,WACA,2LAAiB,CAACC,IAAI;IAGxB,IAAIJ,iBAAiBK,OAAO,EAAE;QAC5BJ,cAAcC,SAAS,CACrB,oBACAC,WACA,2LAAiB,CAACG,QAAQ;IAE9B;IAEAL,cAAcC,SAAS,CACrB,mCACAF,iBAAiBO,YAAY,EAC7B,2LAAiB,CAACH,IAAI;IAGxBH,cAAcO,UAAU,CACtB,aACA,0BACA,2LAAiB,CAACF,QAAQ;IAG5BL,cAAcO,UAAU,CACtB,aACA,yBACA,2LAAiB,CAACC,MAAM;IAG1BR,cAAcS,UAAU,CAAC,QAAQ;IACjCT,cAAcS,UAAU,CAAC,OAAO,iBAAiB;IACjDT,cAAcU,cAAc,CAAC,8MAA4B;IACzDV,cAAcW,gBAAgB,CAAC,8MAA4B;IAE3D,MAAMC,aAAa;QACjBC,wBAAwB;YACtB,OACE,0GAA0G;YAC1Gd,iBAAiBe,eAAe,IAAIhB,WAAWiB,OAAO,CAACC,cAAc;QAEzE;QACAC,uBAAuB;YACrB,OACE,0GAA0G;YAC1GlB,iBAAiBmB,cAAc,IAAIpB,WAAWiB,OAAO,CAACC,cAAc;QAExE;IACF;IAEApB,gBAAgBgB,UAAU,GAAG,IAAA,6KAAO,EAACA,YAAYhB,gBAAgBgB,UAAU;AAC7E;uCAEenB","ignoreList":[0]}},
    {"offset": {"line": 6568, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelNode.js"],"sourcesContent":["import Check from \"../../Core/Check.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * <div class=\"notice\">\n * Use {@link Model#getNode} to get a node from a loaded model. Do not call the constructor directly.\n * </div>\n *\n * A model node with a modifiable transform to allow users to define their\n * own animations. While a model's asset can contain animations that target\n * a node's transform, this class allows users to change a node's transform\n * externally. In this way, animation can be driven by another source, not\n * just by the model's asset.\n *\n * @alias ModelNode\n * @internalConstructor\n * @class\n *\n * @example\n * const node = model.getNode(\"Hand\");\n * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);\n *\n * @see Model#getNode\n */\nfunction ModelNode(model, runtimeNode) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"model\", model);\n  Check.typeOf.object(\"runtimeNode\", runtimeNode);\n  //>>includeEnd('debug');\n\n  this._model = model;\n  this._runtimeNode = runtimeNode;\n}\n\nObject.defineProperties(ModelNode.prototype, {\n  /**\n   * The value of the <code>name</code> property of this node.\n   *\n   * @memberof ModelNode.prototype\n   *\n   * @type {string}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._runtimeNode._name;\n    },\n  },\n\n  /**\n   * The index of the node in the glTF.\n   *\n   * @memberof ModelNode.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._runtimeNode._id;\n    },\n  },\n\n  /**\n   * Determines if this node and its children will be shown.\n   *\n   * @memberof ModelNode.prototype\n   * @type {boolean}\n   *\n   * @default true\n   */\n  show: {\n    get: function () {\n      return this._runtimeNode.show;\n    },\n    set: function (value) {\n      this._runtimeNode.show = value;\n    },\n  },\n\n  /**\n   * The node's 4x4 matrix transform from its local coordinates to\n   * its parent's. Setting the matrix to undefined will restore the\n   * node's original transform, and allow the node to be animated by\n   * any animations in the model again.\n   * <p>\n   * For changes to take effect, this property must be assigned to;\n   * setting individual elements of the matrix will not work.\n   * </p>\n   *\n   * @memberof ModelNode.prototype\n   * @type {Matrix4}\n   */\n  matrix: {\n    get: function () {\n      return this._runtimeNode.transform;\n    },\n    set: function (value) {\n      if (defined(value)) {\n        this._runtimeNode.transform = value;\n        this._runtimeNode.userAnimated = true;\n        this._model._userAnimationDirty = true;\n      } else {\n        this._runtimeNode.transform = this.originalMatrix;\n        this._runtimeNode.userAnimated = false;\n      }\n    },\n  },\n\n  /**\n   * Gets the node's original 4x4 matrix transform from its local\n   * coordinates to its parent's, without any node transformations\n   * or articulations applied.\n   *\n   * @memberof ModelNode.prototype\n   * @type {Matrix4}\n   */\n  originalMatrix: {\n    get: function () {\n      return this._runtimeNode.originalTransform;\n    },\n  },\n});\n\nexport default ModelNode;\n"],"names":["ModelNode","model","runtimeNode","typeOf","object","_model","_runtimeNode","Object","defineProperties","prototype","name","get","_name","id","_id","show","set","value","matrix","transform","userAnimated","_userAnimationDirty","originalMatrix","originalTransform"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;;;;;;;;;;;;;;CAoBC,GACD,SAASA,UAAUC,KAAK,EAAEC,WAAW;IACnC,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,SAASH;IAC7B,2KAAK,CAACE,MAAM,CAACC,MAAM,CAAC,eAAeF;IACnC,wBAAwB;IAExB,IAAI,CAACG,MAAM,GAAGJ;IACd,IAAI,CAACK,YAAY,GAAGJ;AACtB;AAEAK,OAAOC,gBAAgB,CAACR,UAAUS,SAAS,EAAE;IAC3C;;;;;;;GAOC,GACDC,MAAM;QACJC,KAAK;YACH,OAAO,IAAI,CAACL,YAAY,CAACM,KAAK;QAChC;IACF;IAEA;;;;;;;GAOC,GACDC,IAAI;QACFF,KAAK;YACH,OAAO,IAAI,CAACL,YAAY,CAACQ,GAAG;QAC9B;IACF;IAEA;;;;;;;GAOC,GACDC,MAAM;QACJJ,KAAK;YACH,OAAO,IAAI,CAACL,YAAY,CAACS,IAAI;QAC/B;QACAC,KAAK,SAAUC,KAAK;YAClB,IAAI,CAACX,YAAY,CAACS,IAAI,GAAGE;QAC3B;IACF;IAEA;;;;;;;;;;;;GAYC,GACDC,QAAQ;QACNP,KAAK;YACH,OAAO,IAAI,CAACL,YAAY,CAACa,SAAS;QACpC;QACAH,KAAK,SAAUC,KAAK;YAClB,IAAI,IAAA,6KAAO,EAACA,QAAQ;gBAClB,IAAI,CAACX,YAAY,CAACa,SAAS,GAAGF;gBAC9B,IAAI,CAACX,YAAY,CAACc,YAAY,GAAG;gBACjC,IAAI,CAACf,MAAM,CAACgB,mBAAmB,GAAG;YACpC,OAAO;gBACL,IAAI,CAACf,YAAY,CAACa,SAAS,GAAG,IAAI,CAACG,cAAc;gBACjD,IAAI,CAAChB,YAAY,CAACc,YAAY,GAAG;YACnC;QACF;IACF;IAEA;;;;;;;GAOC,GACDE,gBAAgB;QACdX,KAAK;YACH,OAAO,IAAI,CAACL,YAAY,CAACiB,iBAAiB;QAC5C;IACF;AACF;uCAEevB","ignoreList":[0]}},
    {"offset": {"line": 6689, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/InstancingPipelineStage.js"],"sourcesContent":["import addAllToArray from \"../../Core/addAllToArray.js\";\nimport AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport clone from \"../../Core/clone.js\";\nimport combine from \"../../Core/combine.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport InstancingStageCommon from \"../../Shaders/Model/InstancingStageCommon.js\";\nimport InstancingStageVS from \"../../Shaders/Model/InstancingStageVS.js\";\nimport LegacyInstancingStageVS from \"../../Shaders/Model/LegacyInstancingStageVS.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport InstanceAttributeSemantic from \"../InstanceAttributeSemantic.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport SceneTransforms from \"../SceneTransforms.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\nconst modelViewScratch = new Matrix4();\nconst nodeTransformScratch = new Matrix4();\nconst modelView2DScratch = new Matrix4();\n\n/**\n * The instancing pipeline stage is responsible for handling GPU mesh instancing at the node\n * level.\n *\n * @namespace InstancingPipelineStage\n * @private\n */\nconst InstancingPipelineStage = {\n  name: \"InstancingPipelineStage\", // Helps with debugging\n\n  // Expose some methods for testing\n  _getInstanceTransformsAsMatrices: getInstanceTransformsAsMatrices,\n  _transformsToTypedArray: transformsToTypedArray,\n};\n\n/**\n * Process a node. This modifies the following parts of the render resources:\n * <ul>\n *  <li> creates buffers for the typed arrays of each attribute, if they do not yet exist\n *  <li> adds attribute declarations for the instancing vertex attributes in the vertex shader</li>\n *  <li> sets the instancing translation min and max to compute an accurate bounding volume</li>\n * </ul>\n *\n * If the scene is in either 2D or CV mode, this stage also:\n * <ul>\n *  <li> adds additional attributes for the transformation attributes projected to 2D\n *  <li> adds a flag to the shader to use the 2D instanced attributes\n *  <li> adds a uniform for the view model matrix in 2D\n * </ul>\n *\n * @param {NodeRenderResources} renderResources The render resources for this node.\n * @param {ModelComponents.Node} node The node.\n * @param {FrameState} frameState The frame state.\n */\nInstancingPipelineStage.process = function (renderResources, node, frameState) {\n  const instances = node.instances;\n  const count = instances.attributes[0].count;\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addDefine(\"HAS_INSTANCING\");\n  shaderBuilder.addVertexLines(InstancingStageCommon);\n\n  const model = renderResources.model;\n  const sceneGraph = model.sceneGraph;\n  const runtimeNode = renderResources.runtimeNode;\n\n  const use2D =\n    frameState.mode !== SceneMode.SCENE3D &&\n    !frameState.scene3DOnly &&\n    model._projectTo2D;\n  const keepTypedArray = model._enablePick && !frameState.context.webgl2;\n\n  const instancingVertexAttributes = [];\n\n  processTransformAttributes(\n    renderResources,\n    frameState,\n    instances,\n    instancingVertexAttributes,\n    use2D,\n    keepTypedArray,\n  );\n\n  processFeatureIdAttributes(\n    renderResources,\n    frameState,\n    instances,\n    instancingVertexAttributes,\n  );\n\n  const uniformMap = {};\n\n  if (instances.transformInWorldSpace) {\n    shaderBuilder.addDefine(\n      \"USE_LEGACY_INSTANCING\",\n      undefined,\n      ShaderDestination.VERTEX,\n    );\n    shaderBuilder.addUniform(\n      \"mat4\",\n      \"u_instance_modifiedModelView\",\n      ShaderDestination.VERTEX,\n    );\n    shaderBuilder.addUniform(\n      \"mat4\",\n      \"u_instance_nodeTransform\",\n      ShaderDestination.VERTEX,\n    );\n\n    // The i3dm format applies the instancing transforms in world space.\n    // Instancing matrices come from a vertex attribute rather than a\n    // uniform, and they are multiplied in the middle of the modelView matrix\n    // product. This means czm_modelView can't be used. Instead, we split the\n    // matrix into two parts, modifiedModelView and nodeTransform, and handle\n    // this in LegacyInstancingStageVS.glsl. Conceptually the product looks like\n    // this:\n    //\n    // modelView = u_modifiedModelView * a_instanceTransform * u_nodeTransform\n    uniformMap.u_instance_modifiedModelView = function () {\n      // Model matrix without the node hierarchy or axis correction\n      // (see u_instance_nodeTransform).\n      let modifiedModelMatrix = Matrix4.multiplyTransformation(\n        // For 3D Tiles, model.modelMatrix is the computed tile\n        // transform (which includes tileset.modelMatrix). This always applies\n        // for i3dm, since such models are always part of a tileset.\n        model.modelMatrix,\n        // For i3dm models, components.transform contains the RTC_CENTER\n        // translation.\n        sceneGraph.components.transform,\n        modelViewScratch,\n      );\n\n      if (use2D) {\n        // If projectTo2D is enabled, the 2D view matrix\n        // will be accounted for in the u_modelView2D\n        // uniform.\n        //\n        // modifiedModelView = view3D * modifiedModel\n        return Matrix4.multiplyTransformation(\n          frameState.context.uniformState.view3D,\n          modifiedModelMatrix,\n          modelViewScratch,\n        );\n      }\n\n      // For projection to 2D without projectTo2D enabled,\n      // project the model matrix to 2D.\n      if (frameState.mode !== SceneMode.SCENE3D) {\n        modifiedModelMatrix = Transforms.basisTo2D(\n          frameState.mapProjection,\n          modifiedModelMatrix,\n          modelViewScratch,\n        );\n      }\n\n      // modifiedModelView = view * modifiedModel\n      return Matrix4.multiplyTransformation(\n        frameState.context.uniformState.view,\n        modifiedModelMatrix,\n        modelViewScratch,\n      );\n    };\n\n    uniformMap.u_instance_nodeTransform = function () {\n      // nodeTransform = axisCorrection * nodeHierarchyTransform\n      return Matrix4.multiplyTransformation(\n        // glTF y-up to 3D Tiles z-up\n        sceneGraph.axisCorrectionMatrix,\n        // This transforms from the node's coordinate system to the root\n        // of the node hierarchy\n        runtimeNode.computedTransform,\n        nodeTransformScratch,\n      );\n    };\n\n    shaderBuilder.addVertexLines(LegacyInstancingStageVS);\n  } else {\n    shaderBuilder.addVertexLines(InstancingStageVS);\n  }\n\n  if (use2D) {\n    shaderBuilder.addDefine(\n      \"USE_2D_INSTANCING\",\n      undefined,\n      ShaderDestination.VERTEX,\n    );\n\n    shaderBuilder.addUniform(\"mat4\", \"u_modelView2D\", ShaderDestination.VERTEX);\n\n    const context = frameState.context;\n    const modelMatrix2D = Matrix4.fromTranslation(\n      runtimeNode.instancingReferencePoint2D,\n      new Matrix4(),\n    );\n\n    uniformMap.u_modelView2D = function () {\n      return Matrix4.multiplyTransformation(\n        context.uniformState.view,\n        modelMatrix2D,\n        modelView2DScratch,\n      );\n    };\n  }\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n\n  renderResources.instanceCount = count;\n  addAllToArray(renderResources.attributes, instancingVertexAttributes);\n};\n\nconst projectedTransformScratch = new Matrix4();\nconst projectedPositionScratch = new Cartesian3();\n\nfunction projectTransformTo2D(\n  transform,\n  modelMatrix,\n  nodeTransform,\n  frameState,\n  result,\n) {\n  let projectedTransform = Matrix4.multiplyTransformation(\n    modelMatrix,\n    transform,\n    projectedTransformScratch,\n  );\n\n  projectedTransform = Matrix4.multiplyTransformation(\n    projectedTransform,\n    nodeTransform,\n    projectedTransformScratch,\n  );\n\n  result = Transforms.basisTo2D(\n    frameState.mapProjection,\n    projectedTransform,\n    result,\n  );\n\n  return result;\n}\n\nfunction projectPositionTo2D(\n  position,\n  modelMatrix,\n  nodeTransform,\n  frameState,\n  result,\n) {\n  const translationMatrix = Matrix4.fromTranslation(\n    position,\n    projectedTransformScratch,\n  );\n\n  let projectedTransform = Matrix4.multiplyTransformation(\n    modelMatrix,\n    translationMatrix,\n    projectedTransformScratch,\n  );\n\n  projectedTransform = Matrix4.multiplyTransformation(\n    projectedTransform,\n    nodeTransform,\n    projectedTransformScratch,\n  );\n\n  const finalPosition = Matrix4.getTranslation(\n    projectedTransform,\n    projectedPositionScratch,\n  );\n\n  result = SceneTransforms.computeActualEllipsoidPosition(\n    frameState,\n    finalPosition,\n    result,\n  );\n\n  return result;\n}\n\nfunction getModelMatrixAndNodeTransform(\n  renderResources,\n  modelMatrix,\n  nodeComputedTransform,\n) {\n  const model = renderResources.model;\n  const sceneGraph = model.sceneGraph;\n\n  const instances = renderResources.runtimeNode.node.instances;\n  if (instances.transformInWorldSpace) {\n    // Replicate the multiplication order in LegacyInstancingStageVS.\n    modelMatrix = Matrix4.multiplyTransformation(\n      model.modelMatrix,\n      sceneGraph.components.transform,\n      modelMatrix,\n    );\n\n    nodeComputedTransform = Matrix4.multiplyTransformation(\n      sceneGraph.axisCorrectionMatrix,\n      renderResources.runtimeNode.computedTransform,\n      nodeComputedTransform,\n    );\n  } else {\n    // The node transform should be pre-multiplied with the instancing transform.\n    modelMatrix = Matrix4.clone(sceneGraph.computedModelMatrix, modelMatrix);\n    modelMatrix = Matrix4.multiplyTransformation(\n      modelMatrix,\n      renderResources.runtimeNode.computedTransform,\n      modelMatrix,\n    );\n\n    nodeComputedTransform = Matrix4.clone(\n      Matrix4.IDENTITY,\n      nodeComputedTransform,\n    );\n  }\n}\n\nconst modelMatrixScratch = new Matrix4();\nconst nodeComputedTransformScratch = new Matrix4();\nconst transformScratch = new Matrix4();\nconst positionScratch = new Cartesian3();\n\nfunction projectTransformsTo2D(\n  transforms,\n  renderResources,\n  frameState,\n  result,\n) {\n  const modelMatrix = modelMatrixScratch;\n  const nodeComputedTransform = nodeComputedTransformScratch;\n\n  getModelMatrixAndNodeTransform(\n    renderResources,\n    modelMatrix,\n    nodeComputedTransform,\n  );\n\n  const runtimeNode = renderResources.runtimeNode;\n  const referencePoint = runtimeNode.instancingReferencePoint2D;\n\n  const count = transforms.length;\n  for (let i = 0; i < count; i++) {\n    const transform = transforms[i];\n\n    const projectedTransform = projectTransformTo2D(\n      transform,\n      modelMatrix,\n      nodeComputedTransform,\n      frameState,\n      transformScratch,\n    );\n\n    const position = Matrix4.getTranslation(\n      projectedTransform,\n      positionScratch,\n    );\n\n    const finalTranslation = Cartesian3.subtract(\n      position,\n      referencePoint,\n      position,\n    );\n\n    result[i] = Matrix4.setTranslation(\n      projectedTransform,\n      finalTranslation,\n      result[i],\n    );\n  }\n\n  return result;\n}\n\nfunction projectTranslationsTo2D(\n  translations,\n  renderResources,\n  frameState,\n  result,\n) {\n  const modelMatrix = modelMatrixScratch;\n  const nodeComputedTransform = nodeComputedTransformScratch;\n\n  getModelMatrixAndNodeTransform(\n    renderResources,\n    modelMatrix,\n    nodeComputedTransform,\n  );\n\n  const runtimeNode = renderResources.runtimeNode;\n  const referencePoint = runtimeNode.instancingReferencePoint2D;\n  const count = translations.length;\n  for (let i = 0; i < count; i++) {\n    const translation = translations[i];\n\n    const projectedPosition = projectPositionTo2D(\n      translation,\n      modelMatrix,\n      nodeComputedTransform,\n      frameState,\n      translation,\n    );\n\n    result[i] = Cartesian3.subtract(\n      projectedPosition,\n      referencePoint,\n      result[i],\n    );\n  }\n\n  return result;\n}\n\nconst scratchProjectedMin = new Cartesian3();\nconst scratchProjectedMax = new Cartesian3();\n\nfunction computeReferencePoint2D(renderResources, frameState) {\n  // Compute the reference point by averaging the instancing translation\n  // min / max values after they are projected to 2D.\n  const runtimeNode = renderResources.runtimeNode;\n  const modelMatrix = renderResources.model.sceneGraph.computedModelMatrix;\n  const transformedPositionMin = Matrix4.multiplyByPoint(\n    modelMatrix,\n    runtimeNode.instancingTranslationMin,\n    scratchProjectedMin,\n  );\n\n  const projectedMin = SceneTransforms.computeActualEllipsoidPosition(\n    frameState,\n    transformedPositionMin,\n    transformedPositionMin,\n  );\n\n  const transformedPositionMax = Matrix4.multiplyByPoint(\n    modelMatrix,\n    runtimeNode.instancingTranslationMax,\n    scratchProjectedMax,\n  );\n\n  const projectedMax = SceneTransforms.computeActualEllipsoidPosition(\n    frameState,\n    transformedPositionMax,\n    transformedPositionMax,\n  );\n\n  runtimeNode.instancingReferencePoint2D = Cartesian3.lerp(\n    projectedMin,\n    projectedMax,\n    0.5,\n    new Cartesian3(),\n  );\n}\n\nfunction transformsToTypedArray(transforms) {\n  const elements = 12;\n  const count = transforms.length;\n  const transformsTypedArray = new Float32Array(count * elements);\n\n  for (let i = 0; i < count; i++) {\n    const transform = transforms[i];\n    const offset = elements * i;\n\n    transformsTypedArray[offset + 0] = transform[0];\n    transformsTypedArray[offset + 1] = transform[4];\n    transformsTypedArray[offset + 2] = transform[8];\n    transformsTypedArray[offset + 3] = transform[12];\n    transformsTypedArray[offset + 4] = transform[1];\n    transformsTypedArray[offset + 5] = transform[5];\n    transformsTypedArray[offset + 6] = transform[9];\n    transformsTypedArray[offset + 7] = transform[13];\n    transformsTypedArray[offset + 8] = transform[2];\n    transformsTypedArray[offset + 9] = transform[6];\n    transformsTypedArray[offset + 10] = transform[10];\n    transformsTypedArray[offset + 11] = transform[14];\n  }\n\n  return transformsTypedArray;\n}\n\nfunction translationsToTypedArray(translations) {\n  const elements = 3;\n  const count = translations.length;\n  const transationsTypedArray = new Float32Array(count * elements);\n\n  for (let i = 0; i < count; i++) {\n    const translation = translations[i];\n    const offset = elements * i;\n\n    transationsTypedArray[offset + 0] = translation[0];\n    transationsTypedArray[offset + 1] = translation[4];\n    transationsTypedArray[offset + 2] = translation[8];\n  }\n\n  return transationsTypedArray;\n}\n\nconst translationScratch = new Cartesian3();\nconst rotationScratch = new Quaternion();\nconst scaleScratch = new Cartesian3();\n\nfunction getInstanceTransformsAsMatrices(instances, count, renderResources) {\n  const transforms = new Array(count);\n\n  const translationAttribute = ModelUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.TRANSLATION,\n  );\n  const rotationAttribute = ModelUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.ROTATION,\n  );\n  const scaleAttribute = ModelUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.SCALE,\n  );\n\n  const instancingTranslationMax = new Cartesian3(\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n  );\n  const instancingTranslationMin = new Cartesian3(\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n  );\n\n  const hasTranslation = defined(translationAttribute);\n  const hasRotation = defined(rotationAttribute);\n  const hasScale = defined(scaleAttribute);\n\n  // Translations get initialized to (0, 0, 0).\n  const translationTypedArray = hasTranslation\n    ? translationAttribute.typedArray\n    : new Float32Array(count * 3);\n\n  // Rotations get initialized to (0, 0, 0, 0).\n  // The w-component is set to 1 in the loop below.\n  let rotationTypedArray = hasRotation\n    ? rotationAttribute.typedArray\n    : new Float32Array(count * 4);\n\n  // The rotation attribute may be normalized\n  if (hasRotation && rotationAttribute.normalized) {\n    rotationTypedArray = AttributeCompression.dequantize(\n      rotationTypedArray,\n      rotationAttribute.componentDatatype,\n      rotationAttribute.type,\n      count,\n    );\n  }\n\n  // Scales get initialized to (1, 1, 1).\n  let scaleTypedArray;\n  if (hasScale) {\n    scaleTypedArray = scaleAttribute.typedArray;\n  } else {\n    scaleTypedArray = new Float32Array(count * 3);\n    scaleTypedArray.fill(1);\n  }\n\n  for (let i = 0; i < count; i++) {\n    const translation = new Cartesian3(\n      translationTypedArray[i * 3],\n      translationTypedArray[i * 3 + 1],\n      translationTypedArray[i * 3 + 2],\n      translationScratch,\n    );\n\n    Cartesian3.maximumByComponent(\n      instancingTranslationMax,\n      translation,\n      instancingTranslationMax,\n    );\n    Cartesian3.minimumByComponent(\n      instancingTranslationMin,\n      translation,\n      instancingTranslationMin,\n    );\n\n    const rotation = new Quaternion(\n      rotationTypedArray[i * 4],\n      rotationTypedArray[i * 4 + 1],\n      rotationTypedArray[i * 4 + 2],\n      hasRotation ? rotationTypedArray[i * 4 + 3] : 1,\n      rotationScratch,\n    );\n\n    const scale = new Cartesian3(\n      scaleTypedArray[i * 3],\n      scaleTypedArray[i * 3 + 1],\n      scaleTypedArray[i * 3 + 2],\n      scaleScratch,\n    );\n\n    const transform = Matrix4.fromTranslationQuaternionRotationScale(\n      translation,\n      rotation,\n      scale,\n      new Matrix4(),\n    );\n\n    transforms[i] = transform;\n  }\n\n  const runtimeNode = renderResources.runtimeNode;\n  runtimeNode.instancingTranslationMin = instancingTranslationMin;\n  runtimeNode.instancingTranslationMax = instancingTranslationMax;\n\n  // Unload the typed arrays. These are just pointers to the arrays\n  // in the vertex buffer loader.\n  if (hasTranslation) {\n    translationAttribute.typedArray = undefined;\n  }\n  if (hasRotation) {\n    rotationAttribute.typedArray = undefined;\n  }\n  if (hasScale) {\n    scaleAttribute.typedArray = undefined;\n  }\n\n  return transforms;\n}\n\nfunction getInstanceTranslationsAsCartesian3s(\n  translationAttribute,\n  count,\n  renderResources,\n) {\n  const instancingTranslations = new Array(count);\n  const translationTypedArray = translationAttribute.typedArray;\n\n  const instancingTranslationMin = new Cartesian3(\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n  );\n  const instancingTranslationMax = new Cartesian3(\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n  );\n\n  for (let i = 0; i < count; i++) {\n    const translation = new Cartesian3(\n      translationTypedArray[i * 3],\n      translationTypedArray[i * 3 + 1],\n      translationTypedArray[i * 3 + 2],\n    );\n\n    instancingTranslations[i] = translation;\n\n    Cartesian3.minimumByComponent(\n      instancingTranslationMin,\n      translation,\n      instancingTranslationMin,\n    );\n    Cartesian3.maximumByComponent(\n      instancingTranslationMax,\n      translation,\n      instancingTranslationMax,\n    );\n  }\n\n  const runtimeNode = renderResources.runtimeNode;\n  runtimeNode.instancingTranslationMin = instancingTranslationMin;\n  runtimeNode.instancingTranslationMax = instancingTranslationMax;\n\n  // Unload the typed array. This is just a pointer to the array\n  // in the vertex buffer loader.\n  translationAttribute.typedArray = undefined;\n\n  return instancingTranslations;\n}\n\nfunction createVertexBuffer(typedArray, frameState) {\n  const buffer = Buffer.createVertexBuffer({\n    context: frameState.context,\n    typedArray: typedArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n\n  // Destruction of resources allocated by the Model\n  // is handled by Model.destroy().\n  buffer.vertexArrayDestroyable = false;\n\n  return buffer;\n}\n\nfunction processTransformAttributes(\n  renderResources,\n  frameState,\n  instances,\n  instancingVertexAttributes,\n  use2D,\n  keepTypedArray,\n) {\n  const rotationAttribute = ModelUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.ROTATION,\n  );\n\n  // Only use matrices for the transforms if the rotation attribute is defined.\n  if (defined(rotationAttribute)) {\n    processTransformMatrixAttributes(\n      renderResources,\n      instances,\n      instancingVertexAttributes,\n      frameState,\n      use2D,\n      keepTypedArray,\n    );\n  } else {\n    processTransformVec3Attributes(\n      renderResources,\n      instances,\n      instancingVertexAttributes,\n      frameState,\n      use2D,\n    );\n  }\n}\n\nfunction processTransformMatrixAttributes(\n  renderResources,\n  instances,\n  instancingVertexAttributes,\n  frameState,\n  use2D,\n  keepTypedArray,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const count = instances.attributes[0].count;\n\n  const model = renderResources.model;\n  const runtimeNode = renderResources.runtimeNode;\n\n  shaderBuilder.addDefine(\"HAS_INSTANCE_MATRICES\");\n  const attributeString = \"Transform\";\n\n  let transforms;\n  let buffer = runtimeNode.instancingTransformsBuffer;\n  if (!defined(buffer)) {\n    // This function computes the transforms, sets the translation min / max,\n    // and unloads the typed arrays associated with the attributes.\n    transforms = getInstanceTransformsAsMatrices(\n      instances,\n      count,\n      renderResources,\n    );\n\n    const transformsTypedArray = transformsToTypedArray(transforms);\n    buffer = createVertexBuffer(transformsTypedArray, frameState);\n    model._modelResources.push(buffer);\n\n    if (keepTypedArray) {\n      runtimeNode.transformsTypedArray = transformsTypedArray;\n    }\n\n    runtimeNode.instancingTransformsBuffer = buffer;\n  }\n\n  processMatrixAttributes(\n    renderResources,\n    buffer,\n    instancingVertexAttributes,\n    attributeString,\n  );\n\n  if (!use2D) {\n    return;\n  }\n\n  // Force the scene mode to be CV. In 2D, projected positions will have\n  // an x-coordinate of 0, which eliminates the height data that is\n  // necessary for rendering in CV mode.\n  const frameStateCV = clone(frameState);\n  frameStateCV.mode = SceneMode.COLUMBUS_VIEW;\n\n  // To prevent jitter, the positions are defined relative to a common\n  // reference point. For convenience, this is the center of the instanced\n  // translation bounds projected to 2D.\n  computeReferencePoint2D(renderResources, frameStateCV);\n\n  let buffer2D = runtimeNode.instancingTransformsBuffer2D;\n  if (!defined(buffer2D)) {\n    const projectedTransforms = projectTransformsTo2D(\n      transforms,\n      renderResources,\n      frameStateCV,\n      transforms,\n    );\n    const projectedTypedArray = transformsToTypedArray(projectedTransforms);\n\n    // This memory is counted during the statistics stage at the end\n    // of the pipeline.\n    buffer2D = createVertexBuffer(projectedTypedArray, frameState);\n    model._modelResources.push(buffer2D);\n\n    runtimeNode.instancingTransformsBuffer2D = buffer2D;\n  }\n\n  const attributeString2D = \"Transform2D\";\n  processMatrixAttributes(\n    renderResources,\n    buffer2D,\n    instancingVertexAttributes,\n    attributeString2D,\n  );\n}\n\nfunction processTransformVec3Attributes(\n  renderResources,\n  instances,\n  instancingVertexAttributes,\n  frameState,\n  use2D,\n  keepTypedArray,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const runtimeNode = renderResources.runtimeNode;\n  const translationAttribute = ModelUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.TRANSLATION,\n  );\n  const scaleAttribute = ModelUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.SCALE,\n  );\n\n  if (defined(scaleAttribute)) {\n    shaderBuilder.addDefine(\"HAS_INSTANCE_SCALE\");\n    const attributeString = \"Scale\";\n\n    // Instanced scale attributes are loaded as buffers only.\n    processVec3Attribute(\n      renderResources,\n      scaleAttribute.buffer,\n      scaleAttribute.byteOffset,\n      scaleAttribute.byteStride,\n      instancingVertexAttributes,\n      attributeString,\n    );\n  }\n\n  if (!defined(translationAttribute)) {\n    return;\n  }\n\n  let instancingTranslations;\n  const typedArray = translationAttribute.typedArray;\n  if (defined(typedArray)) {\n    // This function computes and set the translation min / max, and unloads\n    // the typed array associated with the attribute.\n    // The translations are also returned in case they're used for 2D projection.\n    instancingTranslations = getInstanceTranslationsAsCartesian3s(\n      translationAttribute,\n      translationAttribute.count,\n      renderResources,\n    );\n  } else if (!defined(runtimeNode.instancingTranslationMin)) {\n    runtimeNode.instancingTranslationMin = translationAttribute.min;\n    runtimeNode.instancingTranslationMax = translationAttribute.max;\n  }\n\n  shaderBuilder.addDefine(\"HAS_INSTANCE_TRANSLATION\");\n  const attributeString = \"Translation\";\n\n  processVec3Attribute(\n    renderResources,\n    translationAttribute.buffer,\n    translationAttribute.byteOffset,\n    translationAttribute.byteStride,\n    instancingVertexAttributes,\n    attributeString,\n  );\n\n  if (!use2D && !keepTypedArray) {\n    return;\n  }\n\n  // Force the scene mode to be CV. In 2D, projected positions will have\n  // an x-coordinate of 0, which eliminates the height data that is\n  // necessary for rendering in CV mode.\n  const frameStateCV = clone(frameState);\n  frameStateCV.mode = SceneMode.COLUMBUS_VIEW;\n\n  // To prevent jitter, the positions are defined relative to a common\n  // reference point. For convenience, this is the center of the instanced\n  // translation bounds projected to 2D.\n  computeReferencePoint2D(renderResources, frameStateCV);\n\n  let buffer2D = runtimeNode.instancingTranslationBuffer2D;\n\n  if (!defined(buffer2D)) {\n    const projectedTranslations = projectTranslationsTo2D(\n      instancingTranslations,\n      renderResources,\n      frameStateCV,\n      instancingTranslations,\n    );\n    const projectedTypedArray = translationsToTypedArray(projectedTranslations);\n\n    if (keepTypedArray) {\n      runtimeNode.transformsTypedArray = projectedTypedArray;\n    }\n\n    // This memory is counted during the statistics stage at the end\n    // of the pipeline.\n    buffer2D = createVertexBuffer(projectedTypedArray, frameState);\n    renderResources.model._modelResources.push(buffer2D);\n\n    runtimeNode.instancingTranslationBuffer2D = buffer2D;\n  }\n\n  if (!use2D) {\n    return;\n  }\n\n  const byteOffset = 0;\n  const byteStride = undefined;\n\n  const attributeString2D = \"Translation2D\";\n  processVec3Attribute(\n    renderResources,\n    buffer2D,\n    byteOffset,\n    byteStride,\n    instancingVertexAttributes,\n    attributeString2D,\n  );\n}\n\nfunction processMatrixAttributes(\n  renderResources,\n  buffer,\n  instancingVertexAttributes,\n  attributeString,\n) {\n  const vertexSizeInFloats = 12;\n  const componentByteSize = ComponentDatatype.getSizeInBytes(\n    ComponentDatatype.FLOAT,\n  );\n  const strideInBytes = componentByteSize * vertexSizeInFloats;\n\n  const matrixAttributes = [\n    {\n      index: renderResources.attributeIndex++,\n      vertexBuffer: buffer,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: strideInBytes,\n      instanceDivisor: 1,\n    },\n    {\n      index: renderResources.attributeIndex++,\n      vertexBuffer: buffer,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      normalize: false,\n      offsetInBytes: componentByteSize * 4,\n      strideInBytes: strideInBytes,\n      instanceDivisor: 1,\n    },\n    {\n      index: renderResources.attributeIndex++,\n      vertexBuffer: buffer,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      normalize: false,\n      offsetInBytes: componentByteSize * 8,\n      strideInBytes: strideInBytes,\n      instanceDivisor: 1,\n    },\n  ];\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addAttribute(\"vec4\", `a_instancing${attributeString}Row0`);\n  shaderBuilder.addAttribute(\"vec4\", `a_instancing${attributeString}Row1`);\n  shaderBuilder.addAttribute(\"vec4\", `a_instancing${attributeString}Row2`);\n\n  addAllToArray(instancingVertexAttributes, matrixAttributes);\n}\n\nfunction processVec3Attribute(\n  renderResources,\n  buffer,\n  byteOffset,\n  byteStride,\n  instancingVertexAttributes,\n  attributeString,\n) {\n  instancingVertexAttributes.push({\n    index: renderResources.attributeIndex++,\n    vertexBuffer: buffer,\n    componentsPerAttribute: 3,\n    componentDatatype: ComponentDatatype.FLOAT,\n    normalize: false,\n    offsetInBytes: byteOffset,\n    strideInBytes: byteStride,\n    instanceDivisor: 1,\n  });\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addAttribute(\"vec3\", `a_instance${attributeString}`);\n}\n\nfunction processFeatureIdAttributes(\n  renderResources,\n  frameState,\n  instances,\n  instancingVertexAttributes,\n) {\n  const attributes = instances.attributes;\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    if (attribute.semantic !== InstanceAttributeSemantic.FEATURE_ID) {\n      continue;\n    }\n\n    if (\n      attribute.setIndex >= renderResources.featureIdVertexAttributeSetIndex\n    ) {\n      renderResources.featureIdVertexAttributeSetIndex = attribute.setIndex + 1;\n    }\n\n    instancingVertexAttributes.push({\n      index: renderResources.attributeIndex++,\n      vertexBuffer: attribute.buffer,\n      componentsPerAttribute: AttributeType.getNumberOfComponents(\n        attribute.type,\n      ),\n      componentDatatype: attribute.componentDatatype,\n      normalize: false,\n      offsetInBytes: attribute.byteOffset,\n      strideInBytes: attribute.byteStride,\n      instanceDivisor: 1,\n    });\n\n    shaderBuilder.addAttribute(\n      \"float\",\n      `a_instanceFeatureId_${attribute.setIndex}`,\n    );\n  }\n}\n\nexport default InstancingPipelineStage;\n"],"names":["modelViewScratch","nodeTransformScratch","modelView2DScratch","InstancingPipelineStage","name","_getInstanceTransformsAsMatrices","getInstanceTransformsAsMatrices","_transformsToTypedArray","transformsToTypedArray","process","renderResources","node","frameState","instances","count","attributes","shaderBuilder","addDefine","addVertexLines","model","sceneGraph","runtimeNode","use2D","mode","SCENE3D","scene3DOnly","_projectTo2D","keepTypedArray","_enablePick","context","webgl2","instancingVertexAttributes","processTransformAttributes","processFeatureIdAttributes","uniformMap","transformInWorldSpace","undefined","VERTEX","addUniform","u_instance_modifiedModelView","modifiedModelMatrix","multiplyTransformation","modelMatrix","components","transform","uniformState","view3D","basisTo2D","mapProjection","view","u_instance_nodeTransform","axisCorrectionMatrix","computedTransform","modelMatrix2D","fromTranslation","instancingReferencePoint2D","u_modelView2D","instanceCount","projectedTransformScratch","projectedPositionScratch","projectTransformTo2D","nodeTransform","result","projectedTransform","projectPositionTo2D","position","translationMatrix","finalPosition","getTranslation","computeActualEllipsoidPosition","getModelMatrixAndNodeTransform","nodeComputedTransform","clone","computedModelMatrix","IDENTITY","modelMatrixScratch","nodeComputedTransformScratch","transformScratch","positionScratch","projectTransformsTo2D","transforms","referencePoint","length","i","finalTranslation","subtract","setTranslation","projectTranslationsTo2D","translations","translation","projectedPosition","scratchProjectedMin","scratchProjectedMax","computeReferencePoint2D","transformedPositionMin","multiplyByPoint","instancingTranslationMin","projectedMin","transformedPositionMax","instancingTranslationMax","projectedMax","lerp","elements","transformsTypedArray","Float32Array","offset","translationsToTypedArray","transationsTypedArray","translationScratch","rotationScratch","scaleScratch","Array","translationAttribute","getAttributeBySemantic","TRANSLATION","rotationAttribute","ROTATION","scaleAttribute","SCALE","Number","MAX_VALUE","hasTranslation","hasRotation","hasScale","translationTypedArray","typedArray","rotationTypedArray","normalized","dequantize","componentDatatype","type","scaleTypedArray","fill","maximumByComponent","minimumByComponent","rotation","scale","fromTranslationQuaternionRotationScale","getInstanceTranslationsAsCartesian3s","instancingTranslations","createVertexBuffer","buffer","usage","STATIC_DRAW","vertexArrayDestroyable","processTransformMatrixAttributes","processTransformVec3Attributes","attributeString","instancingTransformsBuffer","_modelResources","push","processMatrixAttributes","frameStateCV","COLUMBUS_VIEW","buffer2D","instancingTransformsBuffer2D","projectedTransforms","projectedTypedArray","attributeString2D","processVec3Attribute","byteOffset","byteStride","min","max","instancingTranslationBuffer2D","projectedTranslations","vertexSizeInFloats","componentByteSize","getSizeInBytes","FLOAT","strideInBytes","matrixAttributes","index","attributeIndex","vertexBuffer","componentsPerAttribute","normalize","offsetInBytes","instanceDivisor","addAttribute","attribute","semantic","FEATURE_ID","setIndex","featureIdVertexAttributeSetIndex","getNumberOfComponents"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7245, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelMatrixUpdateStage.js"],"sourcesContent":["import Matrix4 from \"../../Core/Matrix4.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport SceneMode from \"../SceneMode.js\";\n\n/**\n * The model matrix update stage is responsible for updating the model matrices and bounding volumes of the draw commands.\n *\n * @namespace ModelMatrixUpdateStage\n *\n * @private\n */\nconst ModelMatrixUpdateStage = {};\nModelMatrixUpdateStage.name = \"ModelMatrixUpdateStage\"; // Helps with debugging\n\n/**\n * Processes a runtime node. This modifies the following parts of the scene graph and draw commands:\n * <ul>\n *  <li>updates the transforms the children of any nodes with a dirty transform</li>\n *  <li>updates the model matrix of each draw command in each primitive of the the dirty nodes and their children</li>\n *  <li>updates the bounding volume of each draw command in each primitive of the the dirty nodes and their children</li>\n * </ul>\n *\n * @param {ModelRuntimeNode} runtimeNode\n * @param {ModelSceneGraph} sceneGraph\n * @param {FrameState} frameState\n *\n * @private\n */\nModelMatrixUpdateStage.update = function (runtimeNode, sceneGraph, frameState) {\n  // Skip the update stage if the model is being projected to 2D\n  const use2D = frameState.mode !== SceneMode.SCENE3D;\n  if (use2D && sceneGraph._model._projectTo2D) {\n    return;\n  }\n\n  if (runtimeNode._transformDirty) {\n    const modelMatrix = use2D\n      ? sceneGraph._computedModelMatrix2D\n      : sceneGraph._computedModelMatrix;\n\n    updateRuntimeNode(\n      runtimeNode,\n      sceneGraph,\n      modelMatrix,\n      runtimeNode.transformToRoot,\n    );\n    runtimeNode._transformDirty = false;\n  }\n};\n\n/**\n * Update the modelMatrix and cullFrace of the given draw command.\n *\n * @private\n */\nfunction updateDrawCommand(drawCommand, modelMatrix, transformToRoot) {\n  drawCommand.modelMatrix = Matrix4.multiplyTransformation(\n    modelMatrix,\n    transformToRoot,\n    drawCommand.modelMatrix,\n  );\n  drawCommand.cullFace = ModelUtility.getCullFace(\n    drawCommand.modelMatrix,\n    drawCommand.primitiveType,\n  );\n}\n\n/**\n * Recursively update all child runtime nodes and their runtime primitives.\n *\n * @private\n */\nfunction updateRuntimeNode(\n  runtimeNode,\n  sceneGraph,\n  modelMatrix,\n  transformToRoot,\n) {\n  let i;\n\n  // Apply the current node's transform to the end of the chain\n  transformToRoot = Matrix4.multiplyTransformation(\n    transformToRoot,\n    runtimeNode.transform,\n    new Matrix4(),\n  );\n\n  runtimeNode.updateComputedTransform();\n\n  const primitivesLength = runtimeNode.runtimePrimitives.length;\n  for (i = 0; i < primitivesLength; i++) {\n    const runtimePrimitive = runtimeNode.runtimePrimitives[i];\n    updateDrawCommand(\n      runtimePrimitive.drawCommand,\n      modelMatrix,\n      transformToRoot,\n    );\n  }\n\n  const childrenLength = runtimeNode.children.length;\n  for (i = 0; i < childrenLength; i++) {\n    const childRuntimeNode = sceneGraph._runtimeNodes[runtimeNode.children[i]];\n\n    // Update transformToRoot to accommodate changes in the transforms of this node and its ancestors\n    childRuntimeNode._transformToRoot = Matrix4.clone(\n      transformToRoot,\n      childRuntimeNode._transformToRoot,\n    );\n\n    updateRuntimeNode(\n      childRuntimeNode,\n      sceneGraph,\n      modelMatrix,\n      transformToRoot,\n    );\n    childRuntimeNode._transformDirty = false;\n  }\n}\n\nexport default ModelMatrixUpdateStage;\n"],"names":["ModelMatrixUpdateStage","name","update","runtimeNode","sceneGraph","frameState","use2D","mode","SCENE3D","_model","_projectTo2D","_transformDirty","modelMatrix","_computedModelMatrix2D","_computedModelMatrix","updateRuntimeNode","transformToRoot","updateDrawCommand","drawCommand","multiplyTransformation","cullFace","getCullFace","primitiveType","i","transform","updateComputedTransform","primitivesLength","runtimePrimitives","length","runtimePrimitive","childrenLength","children","childRuntimeNode","_runtimeNodes","_transformToRoot","clone"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;CAMC,GACD,MAAMA,yBAAyB,CAAC;AAChCA,uBAAuBC,IAAI,GAAG,0BAA0B,uBAAuB;AAE/E;;;;;;;;;;;;;CAaC,GACDD,uBAAuBE,MAAM,GAAG,SAAUC,WAAW,EAAEC,UAAU,EAAEC,UAAU;IAC3E,8DAA8D;IAC9D,MAAMC,QAAQD,WAAWE,IAAI,KAAK,gLAAS,CAACC,OAAO;IACnD,IAAIF,SAASF,WAAWK,MAAM,CAACC,YAAY,EAAE;QAC3C;IACF;IAEA,IAAIP,YAAYQ,eAAe,EAAE;QAC/B,MAAMC,cAAcN,QAChBF,WAAWS,sBAAsB,GACjCT,WAAWU,oBAAoB;QAEnCC,kBACEZ,aACAC,YACAQ,aACAT,YAAYa,eAAe;QAE7Bb,YAAYQ,eAAe,GAAG;IAChC;AACF;AAEA;;;;CAIC,GACD,SAASM,kBAAkBC,WAAW,EAAEN,WAAW,EAAEI,eAAe;IAClEE,YAAYN,WAAW,GAAG,6KAAO,CAACO,sBAAsB,CACtDP,aACAI,iBACAE,YAAYN,WAAW;IAEzBM,YAAYE,QAAQ,GAAG,4LAAY,CAACC,WAAW,CAC7CH,YAAYN,WAAW,EACvBM,YAAYI,aAAa;AAE7B;AAEA;;;;CAIC,GACD,SAASP,kBACPZ,WAAW,EACXC,UAAU,EACVQ,WAAW,EACXI,eAAe;IAEf,IAAIO;IAEJ,6DAA6D;IAC7DP,kBAAkB,6KAAO,CAACG,sBAAsB,CAC9CH,iBACAb,YAAYqB,SAAS,EACrB,IAAI,6KAAO;IAGbrB,YAAYsB,uBAAuB;IAEnC,MAAMC,mBAAmBvB,YAAYwB,iBAAiB,CAACC,MAAM;IAC7D,IAAKL,IAAI,GAAGA,IAAIG,kBAAkBH,IAAK;QACrC,MAAMM,mBAAmB1B,YAAYwB,iBAAiB,CAACJ,EAAE;QACzDN,kBACEY,iBAAiBX,WAAW,EAC5BN,aACAI;IAEJ;IAEA,MAAMc,iBAAiB3B,YAAY4B,QAAQ,CAACH,MAAM;IAClD,IAAKL,IAAI,GAAGA,IAAIO,gBAAgBP,IAAK;QACnC,MAAMS,mBAAmB5B,WAAW6B,aAAa,CAAC9B,YAAY4B,QAAQ,CAACR,EAAE,CAAC;QAE1E,iGAAiG;QACjGS,iBAAiBE,gBAAgB,GAAG,6KAAO,CAACC,KAAK,CAC/CnB,iBACAgB,iBAAiBE,gBAAgB;QAGnCnB,kBACEiB,kBACA5B,YACAQ,aACAI;QAEFgB,iBAAiBrB,eAAe,GAAG;IACrC;AACF;uCAEeX","ignoreList":[0]}},
    {"offset": {"line": 7324, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/NodeStatisticsPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\n\n/**\n * The node statistics update stage updates memory usage statistics for a Model\n * on the node level. This counts the binary resources that exist for the\n * lifetime of the Model (e.g. attributes loaded by GltfLoader). It does not\n * count resources that are created every time the pipeline is run.\n * The individual pipeline stages are responsible for keeping track of any\n * additional memory they allocate.\n *\n * @namespace NodeStatisticsPipelineStage\n *\n * @private\n */\nconst NodeStatisticsPipelineStage = {\n  name: \"NodeStatisticsPipelineStage\", // Helps with debugging\n\n  // Expose some methods for testing\n  _countInstancingAttributes: countInstancingAttributes,\n  _countGeneratedBuffers: countGeneratedBuffers,\n};\n\nNodeStatisticsPipelineStage.process = function (\n  renderResources,\n  node,\n  frameState,\n) {\n  const statistics = renderResources.model.statistics;\n  const instances = node.instances;\n  const runtimeNode = renderResources.runtimeNode;\n\n  countInstancingAttributes(statistics, instances);\n  countGeneratedBuffers(statistics, runtimeNode);\n};\n\nfunction countInstancingAttributes(statistics, instances) {\n  if (!defined(instances)) {\n    return;\n  }\n\n  const attributes = instances.attributes;\n  const length = attributes.length;\n  for (let i = 0; i < length; i++) {\n    const attribute = attributes[i];\n    if (defined(attribute.buffer)) {\n      // Any typed arrays should have been unloaded before this stage.\n      const hasCpuCopy = false;\n      statistics.addBuffer(attribute.buffer, hasCpuCopy);\n    }\n  }\n}\n\nfunction countGeneratedBuffers(statistics, runtimeNode) {\n  if (defined(runtimeNode.instancingTransformsBuffer)) {\n    // The typed array containing the computed transforms isn't saved\n    // after the buffer is created.\n    const hasCpuCopy = false;\n    statistics.addBuffer(runtimeNode.instancingTransformsBuffer, hasCpuCopy);\n  }\n  if (defined(runtimeNode.instancingTransformsBuffer2D)) {\n    // The typed array containing the computed 2D transforms isn't saved\n    // after the buffer is created.\n    const hasCpuCopy = false;\n    statistics.addBuffer(runtimeNode.instancingTransformsBuffer2D, hasCpuCopy);\n  }\n\n  if (defined(runtimeNode.instancingTranslationBuffer2D)) {\n    // The typed array containing the computed 2D translations isn't saved\n    // after the buffer is created.\n    const hasCpuCopy = false;\n    statistics.addBuffer(runtimeNode.instancingTranslationBuffer2D, hasCpuCopy);\n  }\n}\n\nexport default NodeStatisticsPipelineStage;\n"],"names":["NodeStatisticsPipelineStage","name","_countInstancingAttributes","countInstancingAttributes","_countGeneratedBuffers","countGeneratedBuffers","process","renderResources","node","frameState","statistics","model","instances","runtimeNode","attributes","length","i","attribute","buffer","hasCpuCopy","addBuffer","instancingTransformsBuffer","instancingTransformsBuffer2D","instancingTranslationBuffer2D"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;;;CAWC,GACD,MAAMA,8BAA8B;IAClCC,MAAM;IAEN,kCAAkC;IAClCC,4BAA4BC;IAC5BC,wBAAwBC;AAC1B;AAEAL,4BAA4BM,OAAO,GAAG,SACpCC,eAAe,EACfC,IAAI,EACJC,UAAU;IAEV,MAAMC,aAAaH,gBAAgBI,KAAK,CAACD,UAAU;IACnD,MAAME,YAAYJ,KAAKI,SAAS;IAChC,MAAMC,cAAcN,gBAAgBM,WAAW;IAE/CV,0BAA0BO,YAAYE;IACtCP,sBAAsBK,YAAYG;AACpC;AAEA,SAASV,0BAA0BO,UAAU,EAAEE,SAAS;IACtD,IAAI,CAAC,IAAA,6KAAO,EAACA,YAAY;QACvB;IACF;IAEA,MAAME,aAAaF,UAAUE,UAAU;IACvC,MAAMC,SAASD,WAAWC,MAAM;IAChC,IAAK,IAAIC,IAAI,GAAGA,IAAID,QAAQC,IAAK;QAC/B,MAAMC,YAAYH,UAAU,CAACE,EAAE;QAC/B,IAAI,IAAA,6KAAO,EAACC,UAAUC,MAAM,GAAG;YAC7B,gEAAgE;YAChE,MAAMC,aAAa;YACnBT,WAAWU,SAAS,CAACH,UAAUC,MAAM,EAAEC;QACzC;IACF;AACF;AAEA,SAASd,sBAAsBK,UAAU,EAAEG,WAAW;IACpD,IAAI,IAAA,6KAAO,EAACA,YAAYQ,0BAA0B,GAAG;QACnD,iEAAiE;QACjE,+BAA+B;QAC/B,MAAMF,aAAa;QACnBT,WAAWU,SAAS,CAACP,YAAYQ,0BAA0B,EAAEF;IAC/D;IACA,IAAI,IAAA,6KAAO,EAACN,YAAYS,4BAA4B,GAAG;QACrD,oEAAoE;QACpE,+BAA+B;QAC/B,MAAMH,aAAa;QACnBT,WAAWU,SAAS,CAACP,YAAYS,4BAA4B,EAAEH;IACjE;IAEA,IAAI,IAAA,6KAAO,EAACN,YAAYU,6BAA6B,GAAG;QACtD,sEAAsE;QACtE,+BAA+B;QAC/B,MAAMJ,aAAa;QACnBT,WAAWU,SAAS,CAACP,YAAYU,6BAA6B,EAAEJ;IAClE;AACF;uCAEenB","ignoreList":[0]}},
    {"offset": {"line": 7394, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelRuntimeNode.js"],"sourcesContent":["import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport TranslationRotationScale from \"../../Core/TranslationRotationScale.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport InstancingPipelineStage from \"./InstancingPipelineStage.js\";\nimport ModelMatrixUpdateStage from \"./ModelMatrixUpdateStage.js\";\nimport NodeStatisticsPipelineStage from \"./NodeStatisticsPipelineStage.js\";\n\n/**\n * An in-memory representation of a node as part of the {@link ModelSceneGraph}.\n *\n * @param {object} options An object containing the following options:\n * @param {ModelComponents.Node} options.node The corresponding node components from the 3D model.\n * @param {Matrix4} options.transform The transform of this node, excluding transforms from the node's ancestors or children.\n * @param {Matrix4} options.transformToRoot The product of the transforms of all the node's ancestors, excluding the node's own transform.\n * @param {ModelSceneGraph} options.sceneGraph The scene graph this node belongs to.\n * @param {number[]} options.children The indices of the children of this node in the runtime nodes array of the scene graph.\n *\n * @alias ModelRuntimeNode\n * @constructor\n *\n * @private\n */\nfunction ModelRuntimeNode(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const node = options.node;\n  const transform = options.transform;\n  const transformToRoot = options.transformToRoot;\n  const sceneGraph = options.sceneGraph;\n  const children = options.children;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.node\", node);\n  Check.typeOf.object(\"options.transform\", transform);\n  Check.typeOf.object(\"options.transformToRoot\", transformToRoot);\n  Check.typeOf.object(\"options.sceneGraph\", sceneGraph);\n  Check.typeOf.object(\"options.children\", children);\n  //>>includeEnd('debug');\n\n  this._node = node;\n  this._name = node.name;\n  this._id = node.index;\n  this._sceneGraph = sceneGraph;\n  this._children = children;\n\n  this._originalTransform = Matrix4.clone(transform, this._originalTransform);\n  this._transform = Matrix4.clone(transform, this._transform);\n  this._transformToRoot = Matrix4.clone(transformToRoot, this._transformToRoot);\n\n  this._computedTransform = new Matrix4(); // Computed in initialize()\n  this._transformDirty = false;\n\n  // Used for animation\n  this._transformParameters = undefined;\n  this._morphWeights = [];\n\n  // Will be set by the scene graph after the skins have been created\n  this._runtimeSkin = undefined;\n  this._computedJointMatrices = [];\n\n  /**\n   * Whether or not to show this node and its children. This can be toggled\n   * by the user through {@link ModelNode}.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   *\n   * @private\n   */\n  this.show = true;\n\n  /**\n   * Whether or not this node is animated by the user. This is set by the\n   * corresponding {@link ModelNode} when the user supplies their\n   * own transform. If this is true, the node will ignore animations in the\n   * model's asset.\n   *\n   * @type {boolean}\n   *\n   * @private\n   */\n  this.userAnimated = false;\n\n  /**\n   * Pipeline stages to apply across all the mesh primitives of this node.\n   * This is an array of classes, each with a static method called\n   * <code>process()</code>.\n   *\n   * @type {object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.pipelineStages = [];\n\n  /**\n   * The mesh primitives that belong to this node.\n   *\n   * @type {ModelRuntimePrimitive[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.runtimePrimitives = [];\n\n  /**\n   * Update stages to apply to this node.\n   *\n   * @type {object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.updateStages = [];\n\n  /**\n   * The component-wise minimum value of the translations of the instances.\n   * This value is set by InstancingPipelineStage.\n   *\n   * @type {Cartesian3}\n   *\n   * @private\n   */\n  this.instancingTranslationMin = undefined;\n\n  /**\n   * The component-wise maximum value of the translations of the instances.\n   * This value is set by InstancingPipelineStage.\n   *\n   * @type {Cartesian3}\n   *\n   * @private\n   */\n  this.instancingTranslationMax = undefined;\n\n  /**\n   * A buffer containing the instanced transforms. The memory is managed\n   * by Model; this is just a reference.\n   *\n   * @type {Buffer}\n   *\n   * @private\n   */\n  this.instancingTransformsBuffer = undefined;\n\n  /**\n   * A buffer containing the instanced transforms projected to 2D world\n   * coordinates. Used for rendering in 2D / CV mode. The memory is managed\n   * by Model; this is just a reference.\n   *\n   * @type {Buffer}\n   *\n   * @private\n   */\n  this.instancingTransformsBuffer2D = undefined;\n\n  /**\n   * A buffer containing the instanced translation values for the node if\n   * it is instanced. Used for rendering in 2D / CV mode. The memory is\n   * managed by Model; this is just a reference.\n   *\n   * @type {Buffer}\n   *\n   * @private\n   */\n  this.instancingTranslationBuffer2D = undefined;\n\n  /**\n   * If the model is instanced and projected to 2D, the reference point is the\n   * average of the instancing translation max and min. The 2D translations are\n   * defined relative to this point to avoid precision issues on the GPU.\n   * <p>\n   * This value is set by InstancingPipelineStage.\n   * </p>\n   *\n   * @type {Cartesian3}\n   *\n   * @private\n   */\n  this.instancingReferencePoint2D = undefined;\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelRuntimeNode.prototype, {\n  /**\n   * The internal node this runtime node represents.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {ModelComponents.Node}\n   * @readonly\n   *\n   * @private\n   */\n  node: {\n    get: function () {\n      return this._node;\n    },\n  },\n  /**\n   * The scene graph this node belongs to.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {ModelSceneGraph}\n   * @readonly\n   *\n   * @private\n   */\n  sceneGraph: {\n    get: function () {\n      return this._sceneGraph;\n    },\n  },\n\n  /**\n   * The indices of the children of this node in the scene graph.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {number[]}\n   * @readonly\n   *\n   * @private\n   */\n  children: {\n    get: function () {\n      return this._children;\n    },\n  },\n\n  /**\n   * The node's local space transform. This can be changed externally via\n   * the corresponding {@link ModelNode}, such that animation can be\n   * driven by another source, not just an animation in the model's asset.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Matrix4}\n   *\n   * @private\n   */\n  transform: {\n    get: function () {\n      return this._transform;\n    },\n    set: function (value) {\n      this._transformDirty = true;\n      this._transform = Matrix4.clone(value, this._transform);\n    },\n  },\n\n  /**\n   * The transforms of all the node's ancestors, not including this node's\n   * transform.\n   *\n   * @see ModelRuntimeNode#computedTransform\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  transformToRoot: {\n    get: function () {\n      return this._transformToRoot;\n    },\n  },\n\n  /**\n   * A transform from the node's local space to the model's scene graph space.\n   * This is the product of transformToRoot * transform.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  computedTransform: {\n    get: function () {\n      return this._computedTransform;\n    },\n  },\n\n  /**\n   * The node's original transform, as specified in the model.\n   * Does not include transformations from the node's ancestors.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  originalTransform: {\n    get: function () {\n      return this._originalTransform;\n    },\n  },\n\n  /**\n   * The node's local space translation. This is used internally to allow\n   * animations in the model's asset to affect the node's properties.\n   *\n   * If the node's transformation was originally described using a matrix\n   * in the model, then this will return undefined.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Cartesian3}\n   *\n   * @exception {DeveloperError} The translation of a node cannot be set if it was defined using a matrix in the model's asset.\n   *\n   * @private\n   */\n  translation: {\n    get: function () {\n      return defined(this._transformParameters)\n        ? this._transformParameters.translation\n        : undefined;\n    },\n    set: function (value) {\n      const transformParameters = this._transformParameters;\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(transformParameters)) {\n        throw new DeveloperError(\n          \"The translation of a node cannot be set if it was defined using a matrix in the model.\",\n        );\n      }\n      //>>includeEnd('debug');\n\n      const currentTranslation = transformParameters.translation;\n      if (Cartesian3.equals(currentTranslation, value)) {\n        return;\n      }\n\n      transformParameters.translation = Cartesian3.clone(\n        value,\n        transformParameters.translation,\n      );\n\n      updateTransformFromParameters(this, transformParameters);\n    },\n  },\n\n  /**\n   * The node's local space rotation. This is used internally to allow\n   * animations in the model's asset to affect the node's properties.\n   *\n   * If the node's transformation was originally described using a matrix\n   * in the model, then this will return undefined.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Quaternion}\n   *\n   * @exception {DeveloperError} The rotation of a node cannot be set if it was defined using a matrix in the model's asset.\n   *\n   * @private\n   */\n  rotation: {\n    get: function () {\n      return defined(this._transformParameters)\n        ? this._transformParameters.rotation\n        : undefined;\n    },\n    set: function (value) {\n      const transformParameters = this._transformParameters;\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(transformParameters)) {\n        throw new DeveloperError(\n          \"The rotation of a node cannot be set if it was defined using a matrix in the model.\",\n        );\n      }\n      //>>includeEnd('debug');\n\n      const currentRotation = transformParameters.rotation;\n      if (Quaternion.equals(currentRotation, value)) {\n        return;\n      }\n\n      transformParameters.rotation = Quaternion.clone(\n        value,\n        transformParameters.rotation,\n      );\n\n      updateTransformFromParameters(this, transformParameters);\n    },\n  },\n\n  /**\n   * The node's local space scale. This is used internally to allow\n   * animations in the model's asset to affect the node's properties.\n   *\n   * If the node's transformation was originally described using a matrix\n   * in the model, then this will return undefined.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Cartesian3}\n   *\n   * @exception {DeveloperError} The scale of a node cannot be set if it was defined using a matrix in the model's asset.\n   * @private\n   */\n  scale: {\n    get: function () {\n      return defined(this._transformParameters)\n        ? this._transformParameters.scale\n        : undefined;\n    },\n    set: function (value) {\n      const transformParameters = this._transformParameters;\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(transformParameters)) {\n        throw new DeveloperError(\n          \"The scale of a node cannot be set if it was defined using a matrix in the model.\",\n        );\n      }\n      //>>includeEnd('debug');\n      const currentScale = transformParameters.scale;\n      if (Cartesian3.equals(currentScale, value)) {\n        return;\n      }\n\n      transformParameters.scale = Cartesian3.clone(\n        value,\n        transformParameters.scale,\n      );\n\n      updateTransformFromParameters(this, transformParameters);\n    },\n  },\n\n  /**\n   * The node's morph weights. This is used internally to allow animations\n   * in the model's asset to affect the node's properties.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {number[]}\n   *\n   * @private\n   */\n  morphWeights: {\n    get: function () {\n      return this._morphWeights;\n    },\n    set: function (value) {\n      const valueLength = value.length;\n      //>>includeStart('debug', pragmas.debug);\n      if (this._morphWeights.length !== valueLength) {\n        throw new DeveloperError(\n          \"value must have the same length as the original weights array.\",\n        );\n      }\n      //>>includeEnd('debug');\n      for (let i = 0; i < valueLength; i++) {\n        this._morphWeights[i] = value[i];\n      }\n    },\n  },\n\n  /**\n   * The skin applied to this node, if it exists.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {ModelSkin}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeSkin: {\n    get: function () {\n      return this._runtimeSkin;\n    },\n  },\n\n  /**\n   * The computed joint matrices of this node, derived from its skin.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Matrix4[]}\n   * @readonly\n   *\n   * @private\n   */\n  computedJointMatrices: {\n    get: function () {\n      return this._computedJointMatrices;\n    },\n  },\n});\n\nfunction initialize(runtimeNode) {\n  const transform = runtimeNode.transform;\n  const transformToRoot = runtimeNode.transformToRoot;\n  const computedTransform = runtimeNode._computedTransform;\n  runtimeNode._computedTransform = Matrix4.multiply(\n    transformToRoot,\n    transform,\n    computedTransform,\n  );\n\n  const node = runtimeNode.node;\n  if (!defined(node.matrix)) {\n    runtimeNode._transformParameters = new TranslationRotationScale(\n      node.translation,\n      node.rotation,\n      node.scale,\n    );\n  }\n\n  if (defined(node.morphWeights)) {\n    runtimeNode._morphWeights = node.morphWeights.slice();\n  }\n\n  // If this node is affected by an articulation from the AGI_articulations\n  // extension, add this node to its list of affected nodes.\n  const articulationName = node.articulationName;\n  if (defined(articulationName)) {\n    const sceneGraph = runtimeNode.sceneGraph;\n    const runtimeArticulations = sceneGraph._runtimeArticulations;\n\n    const runtimeArticulation = runtimeArticulations[articulationName];\n    if (defined(runtimeArticulation)) {\n      runtimeArticulation.runtimeNodes.push(runtimeNode);\n    }\n  }\n}\n\nfunction updateTransformFromParameters(runtimeNode, transformParameters) {\n  runtimeNode._transformDirty = true;\n\n  runtimeNode._transform = Matrix4.fromTranslationRotationScale(\n    transformParameters,\n    runtimeNode._transform,\n  );\n}\n\n/**\n * Returns the child with the given index.\n *\n * @param {number} index The index of the child.\n *\n * @returns {ModelRuntimeNode}\n *\n * @example\n * // Iterate through all children of a runtime node.\n * for (let i = 0; i < runtimeNode.children.length; i++)\n * {\n *   const childNode = runtimeNode.getChild(i);\n * }\n *\n * @private\n */\nModelRuntimeNode.prototype.getChild = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  if (index < 0 || index >= this.children.length) {\n    throw new DeveloperError(\n      \"index must be greater than or equal to 0 and less than the number of children.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  return this.sceneGraph._runtimeNodes[this.children[index]];\n};\n\n/**\n * Configure the node pipeline stages. If the pipeline needs to be re-run, call\n * this method again to ensure the correct sequence of pipeline stages are\n * used.\n *\n * @private\n */\nModelRuntimeNode.prototype.configurePipeline = function () {\n  const node = this.node;\n  const pipelineStages = this.pipelineStages;\n  pipelineStages.length = 0;\n  const updateStages = this.updateStages;\n  updateStages.length = 0;\n\n  if (defined(node.instances)) {\n    pipelineStages.push(InstancingPipelineStage);\n  }\n\n  pipelineStages.push(NodeStatisticsPipelineStage);\n\n  updateStages.push(ModelMatrixUpdateStage);\n};\n\n/**\n * Updates the computed transform used for rendering and instancing.\n *\n * @private\n */\nModelRuntimeNode.prototype.updateComputedTransform = function () {\n  this._computedTransform = Matrix4.multiply(\n    this._transformToRoot,\n    this._transform,\n    this._computedTransform,\n  );\n};\n\n/**\n * Updates the joint matrices for this node, where each matrix is computed as\n * computedJointMatrix = nodeWorldTransform^(-1) * skinJointMatrix.\n *\n * @private\n */\nModelRuntimeNode.prototype.updateJointMatrices = function () {\n  const runtimeSkin = this._runtimeSkin;\n  if (!defined(runtimeSkin)) {\n    return;\n  }\n\n  runtimeSkin.updateJointMatrices();\n\n  const computedJointMatrices = this._computedJointMatrices;\n  const skinJointMatrices = runtimeSkin.jointMatrices;\n  const length = skinJointMatrices.length;\n\n  for (let i = 0; i < length; i++) {\n    if (!defined(computedJointMatrices[i])) {\n      computedJointMatrices[i] = new Matrix4();\n    }\n\n    const nodeWorldTransform = Matrix4.multiplyTransformation(\n      this.transformToRoot,\n      this.transform,\n      computedJointMatrices[i],\n    );\n\n    const inverseNodeWorldTransform = Matrix4.inverseTransformation(\n      nodeWorldTransform,\n      computedJointMatrices[i],\n    );\n\n    computedJointMatrices[i] = Matrix4.multiplyTransformation(\n      inverseNodeWorldTransform,\n      skinJointMatrices[i],\n      computedJointMatrices[i],\n    );\n  }\n};\n\nexport default ModelRuntimeNode;\n"],"names":["ModelRuntimeNode","options","EMPTY_OBJECT","node","transform","transformToRoot","sceneGraph","children","typeOf","object","_node","_name","name","_id","index","_sceneGraph","_children","_originalTransform","clone","_transform","_transformToRoot","_computedTransform","_transformDirty","_transformParameters","undefined","_morphWeights","_runtimeSkin","_computedJointMatrices","show","userAnimated","pipelineStages","runtimePrimitives","updateStages","instancingTranslationMin","instancingTranslationMax","instancingTransformsBuffer","instancingTransformsBuffer2D","instancingTranslationBuffer2D","instancingReferencePoint2D","initialize","Object","defineProperties","prototype","get","set","value","computedTransform","originalTransform","translation","transformParameters","currentTranslation","equals","updateTransformFromParameters","rotation","currentRotation","scale","currentScale","morphWeights","valueLength","length","i","runtimeSkin","computedJointMatrices","runtimeNode","multiply","matrix","slice","articulationName","runtimeArticulations","_runtimeArticulations","runtimeArticulation","runtimeNodes","push","fromTranslationRotationScale","getChild","number","_runtimeNodes","configurePipeline","instances","updateComputedTransform","updateJointMatrices","skinJointMatrices","jointMatrices","nodeWorldTransform","multiplyTransformation","inverseNodeWorldTransform","inverseTransformation"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7919, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/AlphaPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport BlendingState from \"../BlendingState.js\";\nimport Pass from \"../../Renderer/Pass.js\";\n\n/**\n * A pipeline stage for configuring the alpha options for handling translucency.\n *\n * @namespace AlphaPipelineStage\n *\n * @private\n */\nconst AlphaPipelineStage = {\n  name: \"AlphaPipelineStage\", // Helps with debugging\n};\n\nAlphaPipelineStage.process = function (renderResources, primitive, frameState) {\n  const alphaOptions = renderResources.alphaOptions;\n\n  // Ensure the pass is defined\n  const model = renderResources.model;\n  alphaOptions.pass = alphaOptions.pass ?? model.opaquePass;\n\n  const renderStateOptions = renderResources.renderStateOptions;\n  if (alphaOptions.pass === Pass.TRANSLUCENT) {\n    renderStateOptions.cull.enabled = false;\n    renderStateOptions.depthMask = false;\n    renderStateOptions.blending = BlendingState.ALPHA_BLEND;\n  }\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  const uniformMap = renderResources.uniformMap;\n\n  if (defined(alphaOptions.alphaCutoff)) {\n    shaderBuilder.addDefine(\n      \"ALPHA_MODE_MASK\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_alphaCutoff\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_alphaCutoff = function () {\n      return alphaOptions.alphaCutoff;\n    };\n  }\n};\n\nexport default AlphaPipelineStage;\n"],"names":["AlphaPipelineStage","name","process","renderResources","primitive","frameState","alphaOptions","model","pass","opaquePass","renderStateOptions","TRANSLUCENT","cull","enabled","depthMask","blending","ALPHA_BLEND","shaderBuilder","uniformMap","alphaCutoff","addDefine","undefined","FRAGMENT","addUniform","u_alphaCutoff"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;;;;CAMC,GACD,MAAMA,qBAAqB;IACzBC,MAAM;AACR;AAEAD,mBAAmBE,OAAO,GAAG,SAAUC,eAAe,EAAEC,SAAS,EAAEC,UAAU;IAC3E,MAAMC,eAAeH,gBAAgBG,YAAY;IAEjD,6BAA6B;IAC7B,MAAMC,QAAQJ,gBAAgBI,KAAK;IACnCD,aAAaE,IAAI,GAAGF,aAAaE,IAAI,IAAID,MAAME,UAAU;IAEzD,MAAMC,qBAAqBP,gBAAgBO,kBAAkB;IAC7D,IAAIJ,aAAaE,IAAI,KAAK,8KAAI,CAACG,WAAW,EAAE;QAC1CD,mBAAmBE,IAAI,CAACC,OAAO,GAAG;QAClCH,mBAAmBI,SAAS,GAAG;QAC/BJ,mBAAmBK,QAAQ,GAAG,oLAAa,CAACC,WAAW;IACzD;IAEA,MAAMC,gBAAgBd,gBAAgBc,aAAa;IACnD,MAAMC,aAAaf,gBAAgBe,UAAU;IAE7C,IAAI,IAAA,6KAAO,EAACZ,aAAaa,WAAW,GAAG;QACrCF,cAAcG,SAAS,CACrB,mBACAC,WACA,2LAAiB,CAACC,QAAQ;QAE5BL,cAAcM,UAAU,CACtB,SACA,iBACA,2LAAiB,CAACD,QAAQ;QAE5BJ,WAAWM,aAAa,GAAG;YACzB,OAAOlB,aAAaa,WAAW;QACjC;IACF;AACF;uCAEenB","ignoreList":[0]}},
    {"offset": {"line": 7966, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/BatchTexturePipelineStage.js"],"sourcesContent":["import combine from \"../../Core/combine.js\";\n\n/**\n * The batch texture stage is responsible for setting up the batch texture for the primitive.\n *\n * @namespace BatchTexturePipelineStage\n * @private\n */\nconst BatchTexturePipelineStage = {\n  name: \"BatchTexturePipelineStage\", // Helps with debugging\n};\n\n/**\n * Processes a primitive. This modifies the following parts of the render resources:\n * <ul>\n *  <li>adds uniforms for the batch texture</li>\n *  <li>adds defines for multiline batch textures</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n */\nBatchTexturePipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const batchTextureUniforms = {};\n\n  const model = renderResources.model;\n\n  const featureTable = model.featureTables[model.featureTableId];\n\n  // Number of features in the feature table.\n  const featuresLength = featureTable.featuresLength;\n  shaderBuilder.addUniform(\"int\", \"model_featuresLength\");\n  batchTextureUniforms.model_featuresLength = function () {\n    return featuresLength;\n  };\n\n  // Batch texture\n  const batchTexture = featureTable.batchTexture;\n  shaderBuilder.addUniform(\"sampler2D\", \"model_batchTexture\");\n  batchTextureUniforms.model_batchTexture = function () {\n    return batchTexture.batchTexture ?? batchTexture.defaultTexture;\n  };\n\n  // Batch texture step size\n  shaderBuilder.addUniform(\"vec4\", \"model_textureStep\");\n  batchTextureUniforms.model_textureStep = function () {\n    return batchTexture.textureStep;\n  };\n\n  // Batch texture dimensions\n  if (batchTexture.textureDimensions.y > 1) {\n    shaderBuilder.addDefine(\"MULTILINE_BATCH_TEXTURE\");\n    shaderBuilder.addUniform(\"vec2\", \"model_textureDimensions\");\n    batchTextureUniforms.model_textureDimensions = function () {\n      return batchTexture.textureDimensions;\n    };\n  }\n\n  renderResources.uniformMap = combine(\n    batchTextureUniforms,\n    renderResources.uniformMap,\n  );\n};\n\nexport default BatchTexturePipelineStage;\n"],"names":["BatchTexturePipelineStage","name","process","renderResources","primitive","frameState","shaderBuilder","batchTextureUniforms","model","featureTable","featureTables","featureTableId","featuresLength","addUniform","model_featuresLength","batchTexture","model_batchTexture","defaultTexture","model_textureStep","textureStep","textureDimensions","y","addDefine","model_textureDimensions","uniformMap"],"mappings":";;;;AAAA;;AAEA;;;;;CAKC,GACD,MAAMA,4BAA4B;IAChCC,MAAM;AACR;AAEA;;;;;;;;;;CAUC,GACDD,0BAA0BE,OAAO,GAAG,SAClCC,eAAe,EACfC,SAAS,EACTC,UAAU;IAEV,MAAMC,gBAAgBH,gBAAgBG,aAAa;IACnD,MAAMC,uBAAuB,CAAC;IAE9B,MAAMC,QAAQL,gBAAgBK,KAAK;IAEnC,MAAMC,eAAeD,MAAME,aAAa,CAACF,MAAMG,cAAc,CAAC;IAE9D,2CAA2C;IAC3C,MAAMC,iBAAiBH,aAAaG,cAAc;IAClDN,cAAcO,UAAU,CAAC,OAAO;IAChCN,qBAAqBO,oBAAoB,GAAG;QAC1C,OAAOF;IACT;IAEA,gBAAgB;IAChB,MAAMG,eAAeN,aAAaM,YAAY;IAC9CT,cAAcO,UAAU,CAAC,aAAa;IACtCN,qBAAqBS,kBAAkB,GAAG;QACxC,OAAOD,aAAaA,YAAY,IAAIA,aAAaE,cAAc;IACjE;IAEA,0BAA0B;IAC1BX,cAAcO,UAAU,CAAC,QAAQ;IACjCN,qBAAqBW,iBAAiB,GAAG;QACvC,OAAOH,aAAaI,WAAW;IACjC;IAEA,2BAA2B;IAC3B,IAAIJ,aAAaK,iBAAiB,CAACC,CAAC,GAAG,GAAG;QACxCf,cAAcgB,SAAS,CAAC;QACxBhB,cAAcO,UAAU,CAAC,QAAQ;QACjCN,qBAAqBgB,uBAAuB,GAAG;YAC7C,OAAOR,aAAaK,iBAAiB;QACvC;IACF;IAEAjB,gBAAgBqB,UAAU,GAAG,IAAA,6KAAO,EAClCjB,sBACAJ,gBAAgBqB,UAAU;AAE9B;uCAEexB","ignoreList":[0]}},
    {"offset": {"line": 8027, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ClassificationPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\n/**\n * The classification pipeline stage is responsible for batching features\n * together to be rendered by the {@link ClassificationModelDrawCommand}.\n *\n * @namespace ClassificationPipelineStage\n *\n * @private\n */\nconst ClassificationPipelineStage = {\n  name: \"ClassificationPipelineStage\", // Helps with debugging\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render resources:\n *\n * <ul>\n *  <li>adds a define to the shader to indicate that the primitive classifies other assets</li>\n *  <li>adds arrays containing batch lengths and offsets to the primitive's resources\n * </ul>\n *\n * <p>\n * See {@link ClassificationModelDrawCommand} for the use of the batch offsets and lengths.\n * </p>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nClassificationPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\n    \"HAS_CLASSIFICATION\",\n    undefined,\n    ShaderDestination.BOTH,\n  );\n\n  const runtimePrimitive = renderResources.runtimePrimitive;\n\n  if (!defined(runtimePrimitive.batchLengths)) {\n    createClassificationBatches(primitive, runtimePrimitive);\n  }\n};\n\nfunction createClassificationBatches(primitive, runtimePrimitive) {\n  const positionAttribute = ModelUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.POSITION,\n  );\n\n  if (!defined(positionAttribute)) {\n    throw new RuntimeError(\n      \"Primitives must have a position attribute to be used for classification.\",\n    );\n  }\n\n  let indicesArray;\n  const indices = primitive.indices;\n  const hasIndices = defined(indices);\n  if (hasIndices) {\n    indicesArray = indices.typedArray;\n    // Unload the typed array. This is just a pointer to the array in\n    // the index buffer loader.\n    indices.typedArray = undefined;\n  }\n\n  const count = hasIndices ? indices.count : positionAttribute.count;\n  const featureIdAttribute = ModelUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.FEATURE_ID,\n    0,\n  );\n\n  // If there are no feature IDs, render the primitive in a single batch.\n  if (!defined(featureIdAttribute)) {\n    runtimePrimitive.batchLengths = [count];\n    runtimePrimitive.batchOffsets = [0];\n\n    return;\n  }\n\n  const featureIds = featureIdAttribute.typedArray;\n  // Unload the typed array. This is just a pointer to the array in\n  // the vertex buffer loader, so if the typed array is shared by\n  // multiple primitives (i.e. multiple instances of the same mesh),\n  // this will not affect the other primitives.\n  featureIdAttribute.typedArray = undefined;\n\n  const batchLengths = [];\n  const batchOffsets = [0];\n\n  const firstIndex = hasIndices ? indicesArray[0] : 0;\n  let currentBatchId = featureIds[firstIndex];\n  let currentOffset = 0;\n\n  for (let i = 1; i < count; i++) {\n    const index = hasIndices ? indicesArray[i] : i;\n    const batchId = featureIds[index];\n\n    if (batchId !== currentBatchId) {\n      // Store the length of this batch and begin counting the next one.\n      const batchLength = i - currentOffset;\n      const newOffset = i;\n\n      batchLengths.push(batchLength);\n      batchOffsets.push(newOffset);\n\n      currentOffset = newOffset;\n      currentBatchId = batchId;\n    }\n  }\n\n  const finalBatchLength = count - currentOffset;\n  batchLengths.push(finalBatchLength);\n\n  runtimePrimitive.batchLengths = batchLengths;\n  runtimePrimitive.batchOffsets = batchOffsets;\n}\n\nexport default ClassificationPipelineStage;\n"],"names":["ClassificationPipelineStage","name","process","renderResources","primitive","frameState","shaderBuilder","addDefine","undefined","BOTH","runtimePrimitive","batchLengths","createClassificationBatches","positionAttribute","getAttributeBySemantic","POSITION","indicesArray","indices","hasIndices","typedArray","count","featureIdAttribute","FEATURE_ID","batchOffsets","featureIds","firstIndex","currentBatchId","currentOffset","i","index","batchId","batchLength","newOffset","push","finalBatchLength"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;CAOC,GACD,MAAMA,8BAA8B;IAClCC,MAAM;AACR;AAEA;;;;;;;;;;;;;;;;;CAiBC,GACDD,4BAA4BE,OAAO,GAAG,SACpCC,eAAe,EACfC,SAAS,EACTC,UAAU;IAEV,MAAMC,gBAAgBH,gBAAgBG,aAAa;IAEnDA,cAAcC,SAAS,CACrB,sBACAC,WACA,2LAAiB,CAACC,IAAI;IAGxB,MAAMC,mBAAmBP,gBAAgBO,gBAAgB;IAEzD,IAAI,CAAC,IAAA,6KAAO,EAACA,iBAAiBC,YAAY,GAAG;QAC3CC,4BAA4BR,WAAWM;IACzC;AACF;AAEA,SAASE,4BAA4BR,SAAS,EAAEM,gBAAgB;IAC9D,MAAMG,oBAAoB,4LAAY,CAACC,sBAAsB,CAC3DV,WACA,8LAAuB,CAACW,QAAQ;IAGlC,IAAI,CAAC,IAAA,6KAAO,EAACF,oBAAoB;QAC/B,MAAM,IAAI,kLAAY,CACpB;IAEJ;IAEA,IAAIG;IACJ,MAAMC,UAAUb,UAAUa,OAAO;IACjC,MAAMC,aAAa,IAAA,6KAAO,EAACD;IAC3B,IAAIC,YAAY;QACdF,eAAeC,QAAQE,UAAU;QACjC,iEAAiE;QACjE,2BAA2B;QAC3BF,QAAQE,UAAU,GAAGX;IACvB;IAEA,MAAMY,QAAQF,aAAaD,QAAQG,KAAK,GAAGP,kBAAkBO,KAAK;IAClE,MAAMC,qBAAqB,4LAAY,CAACP,sBAAsB,CAC5DV,WACA,8LAAuB,CAACkB,UAAU,EAClC;IAGF,uEAAuE;IACvE,IAAI,CAAC,IAAA,6KAAO,EAACD,qBAAqB;QAChCX,iBAAiBC,YAAY,GAAG;YAACS;SAAM;QACvCV,iBAAiBa,YAAY,GAAG;YAAC;SAAE;QAEnC;IACF;IAEA,MAAMC,aAAaH,mBAAmBF,UAAU;IAChD,iEAAiE;IACjE,+DAA+D;IAC/D,kEAAkE;IAClE,6CAA6C;IAC7CE,mBAAmBF,UAAU,GAAGX;IAEhC,MAAMG,eAAe,EAAE;IACvB,MAAMY,eAAe;QAAC;KAAE;IAExB,MAAME,aAAaP,aAAaF,YAAY,CAAC,EAAE,GAAG;IAClD,IAAIU,iBAAiBF,UAAU,CAACC,WAAW;IAC3C,IAAIE,gBAAgB;IAEpB,IAAK,IAAIC,IAAI,GAAGA,IAAIR,OAAOQ,IAAK;QAC9B,MAAMC,QAAQX,aAAaF,YAAY,CAACY,EAAE,GAAGA;QAC7C,MAAME,UAAUN,UAAU,CAACK,MAAM;QAEjC,IAAIC,YAAYJ,gBAAgB;YAC9B,kEAAkE;YAClE,MAAMK,cAAcH,IAAID;YACxB,MAAMK,YAAYJ;YAElBjB,aAAasB,IAAI,CAACF;YAClBR,aAAaU,IAAI,CAACD;YAElBL,gBAAgBK;YAChBN,iBAAiBI;QACnB;IACF;IAEA,MAAMI,mBAAmBd,QAAQO;IACjChB,aAAasB,IAAI,CAACC;IAElBxB,iBAAiBC,YAAY,GAAGA;IAChCD,iBAAiBa,YAAY,GAAGA;AAClC;uCAEevB","ignoreList":[0]}},
    {"offset": {"line": 8138, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/CPUStylingPipelineStage.js"],"sourcesContent":["import ColorBlendMode from \"../ColorBlendMode.js\";\nimport CPUStylingStageVS from \"../../Shaders/Model/CPUStylingStageVS.js\";\nimport CPUStylingStageFS from \"../../Shaders/Model/CPUStylingStageFS.js\";\nimport defined from \"../../Core/defined.js\";\nimport ModelColorPipelineStage from \"./ModelColorPipelineStage.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\n\n/**\n * The CPU styling stage is responsible for ensuring that the feature's color\n * is applied at runtime.\n *\n * @namespace CPUStylingPipelineStage\n *\n * @private\n */\nconst CPUStylingPipelineStage = {\n  name: \"CPUStylingPipelineStage\", // Helps with debugging\n};\n\n/**\n * Processes a primitive. This modifies the following parts of the render resources:\n * <ul>\n *  <li>adds the styling code to both the vertex and fragment shaders</li>\n *  <li>adds the define to trigger the stage's shader functions</li>\n *  <li>adds a uniform with the model's color blend mode and amount</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nCPUStylingPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const model = renderResources.model;\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addVertexLines(CPUStylingStageVS);\n  shaderBuilder.addFragmentLines(CPUStylingStageFS);\n  shaderBuilder.addDefine(\"USE_CPU_STYLING\", undefined, ShaderDestination.BOTH);\n\n  // These uniforms may have already been added by the ModelColorStage\n  // if a static color is applied.\n  if (!defined(model.color)) {\n    shaderBuilder.addUniform(\n      \"float\",\n      ModelColorPipelineStage.COLOR_BLEND_UNIFORM_NAME,\n      ShaderDestination.FRAGMENT,\n    );\n    renderResources.uniformMap[\n      ModelColorPipelineStage.COLOR_BLEND_UNIFORM_NAME\n    ] = function () {\n      return ColorBlendMode.getColorBlend(\n        model.colorBlendMode,\n        model.colorBlendAmount,\n      );\n    };\n  }\n\n  shaderBuilder.addUniform(\n    \"bool\",\n    \"model_commandTranslucent\",\n    ShaderDestination.BOTH,\n  );\n  renderResources.uniformMap.model_commandTranslucent = function () {\n    // Always check the current value, because custom shaders may\n    // change the value with the translucencyMode parameter\n    return renderResources.alphaOptions.pass === Pass.TRANSLUCENT;\n  };\n};\n\nexport default CPUStylingPipelineStage;\n"],"names":["CPUStylingPipelineStage","name","process","renderResources","primitive","frameState","model","shaderBuilder","addVertexLines","addFragmentLines","addDefine","undefined","BOTH","color","addUniform","COLOR_BLEND_UNIFORM_NAME","FRAGMENT","uniformMap","getColorBlend","colorBlendMode","colorBlendAmount","model_commandTranslucent","alphaOptions","pass","TRANSLUCENT"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAEA;;;;;;;CAOC,GACD,MAAMA,0BAA0B;IAC9BC,MAAM;AACR;AAEA;;;;;;;;;;;;;CAaC,GACDD,wBAAwBE,OAAO,GAAG,SAChCC,eAAe,EACfC,SAAS,EACTC,UAAU;IAEV,MAAMC,QAAQH,gBAAgBG,KAAK;IACnC,MAAMC,gBAAgBJ,gBAAgBI,aAAa;IAEnDA,cAAcC,cAAc,CAAC,mMAAiB;IAC9CD,cAAcE,gBAAgB,CAAC,mMAAiB;IAChDF,cAAcG,SAAS,CAAC,mBAAmBC,WAAW,2LAAiB,CAACC,IAAI;IAE5E,oEAAoE;IACpE,gCAAgC;IAChC,IAAI,CAAC,IAAA,6KAAO,EAACN,MAAMO,KAAK,GAAG;QACzBN,cAAcO,UAAU,CACtB,SACA,uMAAuB,CAACC,wBAAwB,EAChD,2LAAiB,CAACC,QAAQ;QAE5Bb,gBAAgBc,UAAU,CACxB,uMAAuB,CAACF,wBAAwB,CACjD,GAAG;YACF,OAAO,qLAAc,CAACG,aAAa,CACjCZ,MAAMa,cAAc,EACpBb,MAAMc,gBAAgB;QAE1B;IACF;IAEAb,cAAcO,UAAU,CACtB,QACA,4BACA,2LAAiB,CAACF,IAAI;IAExBT,gBAAgBc,UAAU,CAACI,wBAAwB,GAAG;QACpD,6DAA6D;QAC7D,uDAAuD;QACvD,OAAOlB,gBAAgBmB,YAAY,CAACC,IAAI,KAAK,8KAAI,CAACC,WAAW;IAC/D;AACF;uCAEexB","ignoreList":[0]}},
    {"offset": {"line": 8205, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/CustomShaderMode.js"],"sourcesContent":["/**\n * An enum describing how the {@link CustomShader} will be added to the\n * fragment shader. This determines how the shader interacts with the material.\n *\n * @enum {string}\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst CustomShaderMode = {\n  /**\n   * The custom shader will be used to modify the results of the material stage\n   * before lighting is applied.\n   *\n   * @type {string}\n   * @constant\n   */\n  MODIFY_MATERIAL: \"MODIFY_MATERIAL\",\n  /**\n   * The custom shader will be used instead of the material stage. This is a hint\n   * to optimize out the material processing code.\n   *\n   * @type {string}\n   * @constant\n   */\n  REPLACE_MATERIAL: \"REPLACE_MATERIAL\",\n};\n\n/**\n * Convert the shader mode to an uppercase identifier for use in GLSL define\n * directives. For example:  <code>#define CUSTOM_SHADER_MODIFY_MATERIAL</code>\n * @param {CustomShaderMode} customShaderMode The shader mode\n * @return {string} The name of the GLSL macro to use\n *\n * @private\n */\nCustomShaderMode.getDefineName = function (customShaderMode) {\n  return `CUSTOM_SHADER_${customShaderMode}`;\n};\n\nexport default Object.freeze(CustomShaderMode);\n"],"names":["CustomShaderMode","MODIFY_MATERIAL","REPLACE_MATERIAL","getDefineName","customShaderMode","Object","freeze"],"mappings":";;;;AAAA;;;;;;;CAOC,GACD,MAAMA,mBAAmB;IACvB;;;;;;GAMC,GACDC,iBAAiB;IACjB;;;;;;GAMC,GACDC,kBAAkB;AACpB;AAEA;;;;;;;CAOC,GACDF,iBAAiBG,aAAa,GAAG,SAAUC,gBAAgB;IACzD,OAAO,CAAC,cAAc,EAAEA,kBAAkB;AAC5C;uCAEeC,OAAOC,MAAM,CAACN","ignoreList":[0]}},
    {"offset": {"line": 8247, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/FeatureIdPipelineStage.js"],"sourcesContent":["import ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport FeatureIdStageFS from \"../../Shaders/Model/FeatureIdStageFS.js\";\nimport FeatureIdStageVS from \"../../Shaders/Model/FeatureIdStageVS.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\n\n/**\n * The feature ID pipeline stage is responsible for processing feature IDs\n * (both attributes and textures), updating the shader in preparation for\n * custom shaders, picking, and/or styling.\n *\n * @namespace FeatureIdPipelineStage\n * @private\n */\nconst FeatureIdPipelineStage = {\n  name: \"FeatureIdPipelineStage\", // Helps with debugging\n\n  STRUCT_ID_FEATURE_IDS_VS: \"FeatureIdsVS\",\n  STRUCT_ID_FEATURE_IDS_FS: \"FeatureIdsFS\",\n  STRUCT_NAME_FEATURE_IDS: \"FeatureIds\",\n  FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS: \"initializeFeatureIdsVS\",\n  FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS: \"initializeFeatureIdsFS\",\n  FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS: \"initializeFeatureIdAliasesVS\",\n  FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS: \"initializeFeatureIdAliasesFS\",\n  FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS:\n    \"void initializeFeatureIds(out FeatureIds featureIds, ProcessedAttributes attributes)\",\n  FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES:\n    \"void initializeFeatureIdAliases(inout FeatureIds featureIds)\",\n  FUNCTION_ID_SET_FEATURE_ID_VARYINGS: \"setFeatureIdVaryings\",\n  FUNCTION_SIGNATURE_SET_FEATURE_ID_VARYINGS: \"void setFeatureIdVaryings()\",\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render resources:\n * <ul>\n *  <li>Adds the FeatureIds struct and corresponding initialization functions in the vertex and fragment shader</li>\n *  <li>For each feature ID attribute, the attributes were already uploaded in the geometry stage, so just update the shader code </li>\n *  <li>For each feature ID implicit range, a new attribute is created and uploaded to the GPU since gl_VertexID is not available in WebGL 1. The shader is updated with an attribute, varying, and initialization code.</li>\n *  <li>For each feature ID texture, the texture is added to the uniform map, and shader code is added to perform the texture read.</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n */\nFeatureIdPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  declareStructsAndFunctions(shaderBuilder);\n\n  const instances = renderResources.runtimeNode.node.instances;\n  if (defined(instances)) {\n    processInstanceFeatureIds(renderResources, instances, frameState);\n  }\n  processPrimitiveFeatureIds(renderResources, primitive, frameState);\n\n  shaderBuilder.addVertexLines(FeatureIdStageVS);\n  shaderBuilder.addFragmentLines(FeatureIdStageFS);\n};\n\nfunction declareStructsAndFunctions(shaderBuilder) {\n  // Declare the FeatureIds struct. The vertex shader will only use\n  // feature ID attributes, while the fragment shader will also use\n  // feature ID textures.\n  shaderBuilder.addStruct(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS,\n    FeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addStruct(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    FeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // declare the initializeFeatureIds() function. The details may differ\n  // between vertex and fragment shader\n  shaderBuilder.addFunction(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS,\n    FeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addFunction(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS,\n    FeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // declare the initializeFeatureIdAliases() function. The details may differ\n  // between vertex and fragment shader\n  shaderBuilder.addFunction(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS,\n    FeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addFunction(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS,\n    FeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // declare the setFeatureIdVaryings() function in the vertex shader only\n  shaderBuilder.addFunction(\n    FeatureIdPipelineStage.FUNCTION_ID_SET_FEATURE_ID_VARYINGS,\n    FeatureIdPipelineStage.FUNCTION_SIGNATURE_SET_FEATURE_ID_VARYINGS,\n    ShaderDestination.VERTEX,\n  );\n}\n\nfunction processInstanceFeatureIds(renderResources, instances, frameState) {\n  const featureIdsArray = instances.featureIds;\n  const count = instances.attributes[0].count;\n\n  for (let i = 0; i < featureIdsArray.length; i++) {\n    const featureIds = featureIdsArray[i];\n    const variableName = featureIds.positionalLabel;\n\n    if (featureIds instanceof ModelComponents.FeatureIdAttribute) {\n      processInstanceAttribute(renderResources, featureIds, variableName);\n    } else {\n      const instanceDivisor = 1;\n      processImplicitRange(\n        renderResources,\n        featureIds,\n        variableName,\n        count,\n        instanceDivisor,\n        frameState,\n      );\n    }\n\n    const label = featureIds.label;\n    if (defined(label)) {\n      addAlias(renderResources, variableName, label, ShaderDestination.BOTH);\n    }\n  }\n}\n\nfunction processPrimitiveFeatureIds(renderResources, primitive, frameState) {\n  const featureIdsArray = primitive.featureIds;\n  const positionAttribute = ModelUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.POSITION,\n  );\n  const count = positionAttribute.count;\n\n  for (let i = 0; i < featureIdsArray.length; i++) {\n    const featureIds = featureIdsArray[i];\n    const variableName = featureIds.positionalLabel;\n\n    let aliasDestination = ShaderDestination.BOTH;\n    if (featureIds instanceof ModelComponents.FeatureIdAttribute) {\n      processAttribute(renderResources, featureIds, variableName);\n    } else if (featureIds instanceof ModelComponents.FeatureIdImplicitRange) {\n      processImplicitRange(\n        renderResources,\n        featureIds,\n        variableName,\n        count,\n        undefined,\n        frameState,\n      );\n    } else {\n      processTexture(renderResources, featureIds, variableName, i, frameState);\n      aliasDestination = ShaderDestination.FRAGMENT;\n    }\n\n    const label = featureIds.label;\n    if (defined(label)) {\n      addAlias(renderResources, variableName, label, aliasDestination);\n    }\n  }\n}\n\nfunction processInstanceAttribute(\n  renderResources,\n  featureIdAttribute,\n  variableName,\n) {\n  // Add a field to the FeatureIds struct.\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int instanceFeatureId_n;\n  //   ...\n  // }\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS,\n    \"int\",\n    variableName,\n  );\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    \"int\",\n    variableName,\n  );\n\n  // Initialize the field from the corresponding attribute.\n  // Example: featureIds.instanceFeatureId_n = int(czm_round(attributes.instanceFeatureId_0));\n  const setIndex = featureIdAttribute.setIndex;\n  const prefix = variableName.replace(/_\\d+$/, \"_\");\n\n  const attributeName = `a_${prefix}${setIndex}`;\n  const varyingName = `v_${prefix}${setIndex}`;\n  const vertexLine = `featureIds.${variableName} = int(czm_round(${attributeName}));`;\n  const fragmentLine = `featureIds.${variableName} = int(czm_round(${varyingName}));`;\n\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS,\n    [vertexLine],\n  );\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS,\n    [fragmentLine],\n  );\n\n  // Instanced attributes don't normally need varyings, so add one here\n  shaderBuilder.addVarying(\"float\", varyingName);\n\n  // The varying needs initialization in the vertex shader\n  // Example:\n  // v_instanceFeatureId_n = a_instanceFeatureId_n;\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_SET_FEATURE_ID_VARYINGS,\n    [`${varyingName} = ${attributeName};`],\n  );\n}\n\nfunction processAttribute(renderResources, featureIdAttribute, variableName) {\n  // Add a field to the FeatureIds struct.\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int featureId_n;\n  //   ...\n  // }\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS,\n    \"int\",\n    variableName,\n  );\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    \"int\",\n    variableName,\n  );\n\n  // Initialize the field from the corresponding attribute.\n  // Example: featureIds.featureId_n = attributes.featureId_0;\n  // Since this uses the ProcessedAttributes struct, the line is the same\n  // for both vertex and fragment shader.\n  const setIndex = featureIdAttribute.setIndex;\n  const prefix = variableName.replace(/_\\d+$/, \"_\");\n\n  const initializationLines = [\n    `featureIds.${variableName} = int(czm_round(attributes.${prefix}${setIndex}));`,\n  ];\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS,\n    initializationLines,\n  );\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS,\n    initializationLines,\n  );\n}\n\nfunction processImplicitRange(\n  renderResources,\n  implicitFeatureIds,\n  variableName,\n  count,\n  instanceDivisor,\n  frameState,\n) {\n  // Generate a vertex attribute for the implicit IDs since WebGL 1 does not\n  // support gl_VertexID\n  generateImplicitFeatureIdAttribute(\n    renderResources,\n    implicitFeatureIds,\n    count,\n    instanceDivisor,\n    frameState,\n  );\n\n  // Declare the vertex attribute in the shader\n  // Example: in float a_implicit_feature_id_n;\n  const shaderBuilder = renderResources.shaderBuilder;\n  const implicitAttributeName = `a_implicit_${variableName}`;\n  shaderBuilder.addAttribute(\"float\", implicitAttributeName);\n\n  // Also declare the corresponding varyings\n  // Example: in float v_implicit_feature_id_n;\n  const implicitVaryingName = `v_implicit_${variableName}`;\n  shaderBuilder.addVarying(\"float\", implicitVaryingName);\n\n  // Add a field to the FeatureIds struct.\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int featureId_n;\n  //   ...\n  // }\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS,\n    \"int\",\n    variableName,\n  );\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    \"int\",\n    variableName,\n  );\n\n  // The varying needs initialization in the vertex shader\n  // Example:\n  // v_implicit_featureId_n = a_implicit_featureId_n;\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_SET_FEATURE_ID_VARYINGS,\n    [`${implicitVaryingName} = ${implicitAttributeName};`],\n  );\n\n  // Initialize the field from the generated attribute/varying.\n  // Example:\n  // featureIds.featureId_n = a_implicit_featureId_n; (VS)\n  // featureIds.featureId_n = v_implicit_featureId_n; (FS)\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS,\n    [`featureIds.${variableName} = int(czm_round(${implicitAttributeName}));`],\n  );\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS,\n    [`featureIds.${variableName} = int(czm_round(${implicitVaryingName}));`],\n  );\n}\n\nfunction processTexture(\n  renderResources,\n  featureIdTexture,\n  variableName,\n  index,\n  frameState,\n) {\n  // Create the feature ID texture uniform. The index matches the index from\n  // the featureIds array, even if this is not consecutive.\n  const uniformName = `u_featureIdTexture_${index}`;\n  const uniformMap = renderResources.uniformMap;\n  const textureReader = featureIdTexture.textureReader;\n  uniformMap[uniformName] = function () {\n    return textureReader.texture ?? frameState.context.defaultTexture;\n  };\n\n  const channels = textureReader.channels;\n\n  // Add a field to the FeatureIds struct in the fragment shader only\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int featureId_n;\n  //   ...\n  // }\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    \"int\",\n    variableName,\n  );\n\n  // Declare the uniform in the fragment shader\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    uniformName,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Get a GLSL expression for the texture coordinates\n  const texCoord = textureReader.texCoord;\n  const texCoordVariable = `v_texCoord_${texCoord}`;\n  let texCoordVariableExpression = texCoordVariable;\n\n  // Check if the texture defines a `transform` from a `KHR_texture_transform`\n  const transform = textureReader.transform;\n  if (defined(transform) && !Matrix3.equals(transform, Matrix3.IDENTITY)) {\n    // Add a uniform for the transformation matrix\n    const transformUniformName = `${uniformName}Transform`;\n    shaderBuilder.addUniform(\n      \"mat3\",\n      transformUniformName,\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap[transformUniformName] = function () {\n      return transform;\n    };\n    // Update the expression for the texture coordinates\n    // with one that transforms the texture coordinates\n    // with the transform matrix first\n    texCoordVariableExpression = `vec2(${transformUniformName} * vec3(${texCoordVariable}, 1.0))`;\n  }\n  // Read one or more channels from the texture\n  // example: texture(u_featureIdTexture_0, v_texCoord_1).rg\n  const textureRead = `texture(${uniformName}, ${texCoordVariableExpression}).${channels}`;\n\n  // Finally, assign to the struct field. Example:\n  // featureIds.featureId_0 = unpacked;\n  const initializationLine = `featureIds.${variableName} = czm_unpackUint(${textureRead});`;\n\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS,\n    [initializationLine],\n  );\n}\n\nfunction addAlias(renderResources, variableName, alias, shaderDestination) {\n  // Add a field to the FeatureIds struct.\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int alias;\n  //   ...\n  // }\n  const shaderBuilder = renderResources.shaderBuilder;\n  const updateVS = ShaderDestination.includesVertexShader(shaderDestination);\n  if (updateVS) {\n    shaderBuilder.addStructField(\n      FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS,\n      \"int\",\n      alias,\n    );\n  }\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    \"int\",\n    alias,\n  );\n\n  // Initialize the field from the original variable\n  // Example: featureIds.alias = featureIds.featureId_n;\n  const initializationLines = [\n    `featureIds.${alias} = featureIds.${variableName};`,\n  ];\n  if (updateVS) {\n    shaderBuilder.addFunctionLines(\n      FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS,\n      initializationLines,\n    );\n  }\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS,\n    initializationLines,\n  );\n}\n\nfunction generateImplicitFeatureIdAttribute(\n  renderResources,\n  implicitFeatureIds,\n  count,\n  instanceDivisor,\n  frameState,\n) {\n  const model = renderResources.model;\n  let vertexBuffer;\n  let value;\n  if (defined(implicitFeatureIds.repeat)) {\n    const typedArray = generateImplicitFeatureIdTypedArray(\n      implicitFeatureIds,\n      count,\n    );\n    vertexBuffer = Buffer.createVertexBuffer({\n      context: frameState.context,\n      typedArray: typedArray,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    vertexBuffer.vertexArrayDestroyable = false;\n    model._pipelineResources.push(vertexBuffer);\n    const hasCpuCopy = false;\n    model.statistics.addBuffer(vertexBuffer, hasCpuCopy);\n  } else {\n    value = [implicitFeatureIds.offset];\n  }\n\n  const generatedFeatureIdAttribute = {\n    index: renderResources.attributeIndex++,\n    instanceDivisor: instanceDivisor,\n    value: value,\n    vertexBuffer: vertexBuffer,\n    normalize: false,\n    componentsPerAttribute: 1,\n    componentDatatype: ComponentDatatype.FLOAT,\n    strideInBytes: ComponentDatatype.getSizeInBytes(ComponentDatatype.FLOAT),\n    offsetInBytes: 0,\n  };\n\n  renderResources.attributes.push(generatedFeatureIdAttribute);\n}\n\n/**\n * Generates a typed array for implicit feature IDs\n * @private\n */\nfunction generateImplicitFeatureIdTypedArray(implicitFeatureIds, count) {\n  const offset = implicitFeatureIds.offset;\n  const repeat = implicitFeatureIds.repeat;\n\n  const typedArray = new Float32Array(count);\n  for (let i = 0; i < count; i++) {\n    typedArray[i] = offset + Math.floor(i / repeat);\n  }\n\n  return typedArray;\n}\n\nexport default FeatureIdPipelineStage;\n"],"names":["FeatureIdPipelineStage","name","STRUCT_ID_FEATURE_IDS_VS","STRUCT_ID_FEATURE_IDS_FS","STRUCT_NAME_FEATURE_IDS","FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS","FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS","FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS","FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS","FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS","FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES","FUNCTION_ID_SET_FEATURE_ID_VARYINGS","FUNCTION_SIGNATURE_SET_FEATURE_ID_VARYINGS","process","renderResources","primitive","frameState","shaderBuilder","declareStructsAndFunctions","instances","runtimeNode","node","processInstanceFeatureIds","processPrimitiveFeatureIds","addVertexLines","addFragmentLines","addStruct","VERTEX","FRAGMENT","addFunction","featureIdsArray","featureIds","count","attributes","i","length","variableName","positionalLabel","FeatureIdAttribute","processInstanceAttribute","instanceDivisor","processImplicitRange","label","addAlias","BOTH","positionAttribute","getAttributeBySemantic","POSITION","aliasDestination","processAttribute","FeatureIdImplicitRange","undefined","processTexture","featureIdAttribute","addStructField","setIndex","prefix","replace","attributeName","varyingName","vertexLine","fragmentLine","addFunctionLines","addVarying","initializationLines","implicitFeatureIds","generateImplicitFeatureIdAttribute","implicitAttributeName","addAttribute","implicitVaryingName","featureIdTexture","index","uniformName","uniformMap","textureReader","texture","context","defaultTexture","channels","addUniform","texCoord","texCoordVariable","texCoordVariableExpression","transform","equals","IDENTITY","transformUniformName","textureRead","initializationLine","alias","shaderDestination","updateVS","includesVertexShader","model","vertexBuffer","value","repeat","typedArray","generateImplicitFeatureIdTypedArray","createVertexBuffer","usage","STATIC_DRAW","vertexArrayDestroyable","_pipelineResources","push","hasCpuCopy","statistics","addBuffer","offset","generatedFeatureIdAttribute","attributeIndex","normalize","componentsPerAttribute","componentDatatype","FLOAT","strideInBytes","getSizeInBytes","offsetInBytes","Float32Array","Math","floor"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAEA;;;;;;;CAOC,GACD,MAAMA,yBAAyB;IAC7BC,MAAM;IAENC,0BAA0B;IAC1BC,0BAA0B;IAC1BC,yBAAyB;IACzBC,uCAAuC;IACvCC,uCAAuC;IACvCC,8CAA8C;IAC9CC,8CAA8C;IAC9CC,2CACE;IACFC,kDACE;IACFC,qCAAqC;IACrCC,4CAA4C;AAC9C;AAEA;;;;;;;;;;;;CAYC,GACDZ,uBAAuBa,OAAO,GAAG,SAC/BC,eAAe,EACfC,SAAS,EACTC,UAAU;IAEV,MAAMC,gBAAgBH,gBAAgBG,aAAa;IACnDC,2BAA2BD;IAE3B,MAAME,YAAYL,gBAAgBM,WAAW,CAACC,IAAI,CAACF,SAAS;IAC5D,IAAI,IAAA,6KAAO,EAACA,YAAY;QACtBG,0BAA0BR,iBAAiBK,WAAWH;IACxD;IACAO,2BAA2BT,iBAAiBC,WAAWC;IAEvDC,cAAcO,cAAc,CAAC,kMAAgB;IAC7CP,cAAcQ,gBAAgB,CAAC,kMAAgB;AACjD;AAEA,SAASP,2BAA2BD,aAAa;IAC/C,iEAAiE;IACjE,iEAAiE;IACjE,uBAAuB;IACvBA,cAAcS,SAAS,CACrB1B,uBAAuBE,wBAAwB,EAC/CF,uBAAuBI,uBAAuB,EAC9C,2LAAiB,CAACuB,MAAM;IAE1BV,cAAcS,SAAS,CACrB1B,uBAAuBG,wBAAwB,EAC/CH,uBAAuBI,uBAAuB,EAC9C,2LAAiB,CAACwB,QAAQ;IAG5B,sEAAsE;IACtE,qCAAqC;IACrCX,cAAcY,WAAW,CACvB7B,uBAAuBK,qCAAqC,EAC5DL,uBAAuBS,yCAAyC,EAChE,2LAAiB,CAACkB,MAAM;IAE1BV,cAAcY,WAAW,CACvB7B,uBAAuBM,qCAAqC,EAC5DN,uBAAuBS,yCAAyC,EAChE,2LAAiB,CAACmB,QAAQ;IAG5B,4EAA4E;IAC5E,qCAAqC;IACrCX,cAAcY,WAAW,CACvB7B,uBAAuBO,4CAA4C,EACnEP,uBAAuBU,gDAAgD,EACvE,2LAAiB,CAACiB,MAAM;IAE1BV,cAAcY,WAAW,CACvB7B,uBAAuBQ,4CAA4C,EACnER,uBAAuBU,gDAAgD,EACvE,2LAAiB,CAACkB,QAAQ;IAG5B,wEAAwE;IACxEX,cAAcY,WAAW,CACvB7B,uBAAuBW,mCAAmC,EAC1DX,uBAAuBY,0CAA0C,EACjE,2LAAiB,CAACe,MAAM;AAE5B;AAEA,SAASL,0BAA0BR,eAAe,EAAEK,SAAS,EAAEH,UAAU;IACvE,MAAMc,kBAAkBX,UAAUY,UAAU;IAC5C,MAAMC,QAAQb,UAAUc,UAAU,CAAC,EAAE,CAACD,KAAK;IAE3C,IAAK,IAAIE,IAAI,GAAGA,IAAIJ,gBAAgBK,MAAM,EAAED,IAAK;QAC/C,MAAMH,aAAaD,eAAe,CAACI,EAAE;QACrC,MAAME,eAAeL,WAAWM,eAAe;QAE/C,IAAIN,sBAAsB,sLAAe,CAACO,kBAAkB,EAAE;YAC5DC,yBAAyBzB,iBAAiBiB,YAAYK;QACxD,OAAO;YACL,MAAMI,kBAAkB;YACxBC,qBACE3B,iBACAiB,YACAK,cACAJ,OACAQ,iBACAxB;QAEJ;QAEA,MAAM0B,QAAQX,WAAWW,KAAK;QAC9B,IAAI,IAAA,6KAAO,EAACA,QAAQ;YAClBC,SAAS7B,iBAAiBsB,cAAcM,OAAO,2LAAiB,CAACE,IAAI;QACvE;IACF;AACF;AAEA,SAASrB,2BAA2BT,eAAe,EAAEC,SAAS,EAAEC,UAAU;IACxE,MAAMc,kBAAkBf,UAAUgB,UAAU;IAC5C,MAAMc,oBAAoB,4LAAY,CAACC,sBAAsB,CAC3D/B,WACA,8LAAuB,CAACgC,QAAQ;IAElC,MAAMf,QAAQa,kBAAkBb,KAAK;IAErC,IAAK,IAAIE,IAAI,GAAGA,IAAIJ,gBAAgBK,MAAM,EAAED,IAAK;QAC/C,MAAMH,aAAaD,eAAe,CAACI,EAAE;QACrC,MAAME,eAAeL,WAAWM,eAAe;QAE/C,IAAIW,mBAAmB,2LAAiB,CAACJ,IAAI;QAC7C,IAAIb,sBAAsB,sLAAe,CAACO,kBAAkB,EAAE;YAC5DW,iBAAiBnC,iBAAiBiB,YAAYK;QAChD,OAAO,IAAIL,sBAAsB,sLAAe,CAACmB,sBAAsB,EAAE;YACvET,qBACE3B,iBACAiB,YACAK,cACAJ,OACAmB,WACAnC;QAEJ,OAAO;YACLoC,eAAetC,iBAAiBiB,YAAYK,cAAcF,GAAGlB;YAC7DgC,mBAAmB,2LAAiB,CAACpB,QAAQ;QAC/C;QAEA,MAAMc,QAAQX,WAAWW,KAAK;QAC9B,IAAI,IAAA,6KAAO,EAACA,QAAQ;YAClBC,SAAS7B,iBAAiBsB,cAAcM,OAAOM;QACjD;IACF;AACF;AAEA,SAAST,yBACPzB,eAAe,EACfuC,kBAAkB,EAClBjB,YAAY;IAEZ,wCAAwC;IACxC,WAAW;IACX,sBAAsB;IACtB,QAAQ;IACR,6BAA6B;IAC7B,QAAQ;IACR,IAAI;IACJ,MAAMnB,gBAAgBH,gBAAgBG,aAAa;IACnDA,cAAcqC,cAAc,CAC1BtD,uBAAuBE,wBAAwB,EAC/C,OACAkC;IAEFnB,cAAcqC,cAAc,CAC1BtD,uBAAuBG,wBAAwB,EAC/C,OACAiC;IAGF,yDAAyD;IACzD,4FAA4F;IAC5F,MAAMmB,WAAWF,mBAAmBE,QAAQ;IAC5C,MAAMC,SAASpB,aAAaqB,OAAO,CAAC,SAAS;IAE7C,MAAMC,gBAAgB,CAAC,EAAE,EAAEF,SAASD,UAAU;IAC9C,MAAMI,cAAc,CAAC,EAAE,EAAEH,SAASD,UAAU;IAC5C,MAAMK,aAAa,CAAC,WAAW,EAAExB,aAAa,iBAAiB,EAAEsB,cAAc,GAAG,CAAC;IACnF,MAAMG,eAAe,CAAC,WAAW,EAAEzB,aAAa,iBAAiB,EAAEuB,YAAY,GAAG,CAAC;IAEnF1C,cAAc6C,gBAAgB,CAC5B9D,uBAAuBK,qCAAqC,EAC5D;QAACuD;KAAW;IAEd3C,cAAc6C,gBAAgB,CAC5B9D,uBAAuBM,qCAAqC,EAC5D;QAACuD;KAAa;IAGhB,qEAAqE;IACrE5C,cAAc8C,UAAU,CAAC,SAASJ;IAElC,wDAAwD;IACxD,WAAW;IACX,iDAAiD;IACjD1C,cAAc6C,gBAAgB,CAC5B9D,uBAAuBW,mCAAmC,EAC1D;QAAC,GAAGgD,YAAY,GAAG,EAAED,cAAc,CAAC,CAAC;KAAC;AAE1C;AAEA,SAAST,iBAAiBnC,eAAe,EAAEuC,kBAAkB,EAAEjB,YAAY;IACzE,wCAAwC;IACxC,WAAW;IACX,sBAAsB;IACtB,QAAQ;IACR,qBAAqB;IACrB,QAAQ;IACR,IAAI;IACJ,MAAMnB,gBAAgBH,gBAAgBG,aAAa;IACnDA,cAAcqC,cAAc,CAC1BtD,uBAAuBE,wBAAwB,EAC/C,OACAkC;IAEFnB,cAAcqC,cAAc,CAC1BtD,uBAAuBG,wBAAwB,EAC/C,OACAiC;IAGF,yDAAyD;IACzD,4DAA4D;IAC5D,uEAAuE;IACvE,uCAAuC;IACvC,MAAMmB,WAAWF,mBAAmBE,QAAQ;IAC5C,MAAMC,SAASpB,aAAaqB,OAAO,CAAC,SAAS;IAE7C,MAAMO,sBAAsB;QAC1B,CAAC,WAAW,EAAE5B,aAAa,4BAA4B,EAAEoB,SAASD,SAAS,GAAG,CAAC;KAChF;IACDtC,cAAc6C,gBAAgB,CAC5B9D,uBAAuBK,qCAAqC,EAC5D2D;IAEF/C,cAAc6C,gBAAgB,CAC5B9D,uBAAuBM,qCAAqC,EAC5D0D;AAEJ;AAEA,SAASvB,qBACP3B,eAAe,EACfmD,kBAAkB,EAClB7B,YAAY,EACZJ,KAAK,EACLQ,eAAe,EACfxB,UAAU;IAEV,0EAA0E;IAC1E,sBAAsB;IACtBkD,mCACEpD,iBACAmD,oBACAjC,OACAQ,iBACAxB;IAGF,6CAA6C;IAC7C,6CAA6C;IAC7C,MAAMC,gBAAgBH,gBAAgBG,aAAa;IACnD,MAAMkD,wBAAwB,CAAC,WAAW,EAAE/B,cAAc;IAC1DnB,cAAcmD,YAAY,CAAC,SAASD;IAEpC,0CAA0C;IAC1C,6CAA6C;IAC7C,MAAME,sBAAsB,CAAC,WAAW,EAAEjC,cAAc;IACxDnB,cAAc8C,UAAU,CAAC,SAASM;IAElC,wCAAwC;IACxC,WAAW;IACX,sBAAsB;IACtB,QAAQ;IACR,qBAAqB;IACrB,QAAQ;IACR,IAAI;IACJpD,cAAcqC,cAAc,CAC1BtD,uBAAuBE,wBAAwB,EAC/C,OACAkC;IAEFnB,cAAcqC,cAAc,CAC1BtD,uBAAuBG,wBAAwB,EAC/C,OACAiC;IAGF,wDAAwD;IACxD,WAAW;IACX,mDAAmD;IACnDnB,cAAc6C,gBAAgB,CAC5B9D,uBAAuBW,mCAAmC,EAC1D;QAAC,GAAG0D,oBAAoB,GAAG,EAAEF,sBAAsB,CAAC,CAAC;KAAC;IAGxD,6DAA6D;IAC7D,WAAW;IACX,wDAAwD;IACxD,wDAAwD;IACxDlD,cAAc6C,gBAAgB,CAC5B9D,uBAAuBK,qCAAqC,EAC5D;QAAC,CAAC,WAAW,EAAE+B,aAAa,iBAAiB,EAAE+B,sBAAsB,GAAG,CAAC;KAAC;IAE5ElD,cAAc6C,gBAAgB,CAC5B9D,uBAAuBM,qCAAqC,EAC5D;QAAC,CAAC,WAAW,EAAE8B,aAAa,iBAAiB,EAAEiC,oBAAoB,GAAG,CAAC;KAAC;AAE5E;AAEA,SAASjB,eACPtC,eAAe,EACfwD,gBAAgB,EAChBlC,YAAY,EACZmC,KAAK,EACLvD,UAAU;IAEV,0EAA0E;IAC1E,yDAAyD;IACzD,MAAMwD,cAAc,CAAC,mBAAmB,EAAED,OAAO;IACjD,MAAME,aAAa3D,gBAAgB2D,UAAU;IAC7C,MAAMC,gBAAgBJ,iBAAiBI,aAAa;IACpDD,UAAU,CAACD,YAAY,GAAG;QACxB,OAAOE,cAAcC,OAAO,IAAI3D,WAAW4D,OAAO,CAACC,cAAc;IACnE;IAEA,MAAMC,WAAWJ,cAAcI,QAAQ;IAEvC,mEAAmE;IACnE,WAAW;IACX,sBAAsB;IACtB,QAAQ;IACR,qBAAqB;IACrB,QAAQ;IACR,IAAI;IACJ,MAAM7D,gBAAgBH,gBAAgBG,aAAa;IACnDA,cAAcqC,cAAc,CAC1BtD,uBAAuBG,wBAAwB,EAC/C,OACAiC;IAGF,6CAA6C;IAC7CnB,cAAc8D,UAAU,CACtB,aACAP,aACA,2LAAiB,CAAC5C,QAAQ;IAG5B,oDAAoD;IACpD,MAAMoD,WAAWN,cAAcM,QAAQ;IACvC,MAAMC,mBAAmB,CAAC,WAAW,EAAED,UAAU;IACjD,IAAIE,6BAA6BD;IAEjC,4EAA4E;IAC5E,MAAME,YAAYT,cAAcS,SAAS;IACzC,IAAI,IAAA,6KAAO,EAACA,cAAc,CAAC,6KAAO,CAACC,MAAM,CAACD,WAAW,6KAAO,CAACE,QAAQ,GAAG;QACtE,8CAA8C;QAC9C,MAAMC,uBAAuB,GAAGd,YAAY,SAAS,CAAC;QACtDvD,cAAc8D,UAAU,CACtB,QACAO,sBACA,2LAAiB,CAAC1D,QAAQ;QAE5B6C,UAAU,CAACa,qBAAqB,GAAG;YACjC,OAAOH;QACT;QACA,oDAAoD;QACpD,mDAAmD;QACnD,kCAAkC;QAClCD,6BAA6B,CAAC,KAAK,EAAEI,qBAAqB,QAAQ,EAAEL,iBAAiB,OAAO,CAAC;IAC/F;IACA,6CAA6C;IAC7C,0DAA0D;IAC1D,MAAMM,cAAc,CAAC,QAAQ,EAAEf,YAAY,EAAE,EAAEU,2BAA2B,EAAE,EAAEJ,UAAU;IAExF,gDAAgD;IAChD,qCAAqC;IACrC,MAAMU,qBAAqB,CAAC,WAAW,EAAEpD,aAAa,kBAAkB,EAAEmD,YAAY,EAAE,CAAC;IAEzFtE,cAAc6C,gBAAgB,CAC5B9D,uBAAuBM,qCAAqC,EAC5D;QAACkF;KAAmB;AAExB;AAEA,SAAS7C,SAAS7B,eAAe,EAAEsB,YAAY,EAAEqD,KAAK,EAAEC,iBAAiB;IACvE,wCAAwC;IACxC,WAAW;IACX,sBAAsB;IACtB,QAAQ;IACR,eAAe;IACf,QAAQ;IACR,IAAI;IACJ,MAAMzE,gBAAgBH,gBAAgBG,aAAa;IACnD,MAAM0E,WAAW,2LAAiB,CAACC,oBAAoB,CAACF;IACxD,IAAIC,UAAU;QACZ1E,cAAcqC,cAAc,CAC1BtD,uBAAuBE,wBAAwB,EAC/C,OACAuF;IAEJ;IACAxE,cAAcqC,cAAc,CAC1BtD,uBAAuBG,wBAAwB,EAC/C,OACAsF;IAGF,kDAAkD;IAClD,sDAAsD;IACtD,MAAMzB,sBAAsB;QAC1B,CAAC,WAAW,EAAEyB,MAAM,cAAc,EAAErD,aAAa,CAAC,CAAC;KACpD;IACD,IAAIuD,UAAU;QACZ1E,cAAc6C,gBAAgB,CAC5B9D,uBAAuBO,4CAA4C,EACnEyD;IAEJ;IACA/C,cAAc6C,gBAAgB,CAC5B9D,uBAAuBQ,4CAA4C,EACnEwD;AAEJ;AAEA,SAASE,mCACPpD,eAAe,EACfmD,kBAAkB,EAClBjC,KAAK,EACLQ,eAAe,EACfxB,UAAU;IAEV,MAAM6E,QAAQ/E,gBAAgB+E,KAAK;IACnC,IAAIC;IACJ,IAAIC;IACJ,IAAI,IAAA,6KAAO,EAAC9B,mBAAmB+B,MAAM,GAAG;QACtC,MAAMC,aAAaC,oCACjBjC,oBACAjC;QAEF8D,eAAe,gLAAM,CAACK,kBAAkB,CAAC;YACvCvB,SAAS5D,WAAW4D,OAAO;YAC3BqB,YAAYA;YACZG,OAAO,qLAAW,CAACC,WAAW;QAChC;QACAP,aAAaQ,sBAAsB,GAAG;QACtCT,MAAMU,kBAAkB,CAACC,IAAI,CAACV;QAC9B,MAAMW,aAAa;QACnBZ,MAAMa,UAAU,CAACC,SAAS,CAACb,cAAcW;IAC3C,OAAO;QACLV,QAAQ;YAAC9B,mBAAmB2C,MAAM;SAAC;IACrC;IAEA,MAAMC,8BAA8B;QAClCtC,OAAOzD,gBAAgBgG,cAAc;QACrCtE,iBAAiBA;QACjBuD,OAAOA;QACPD,cAAcA;QACdiB,WAAW;QACXC,wBAAwB;QACxBC,mBAAmB,uLAAiB,CAACC,KAAK;QAC1CC,eAAe,uLAAiB,CAACC,cAAc,CAAC,uLAAiB,CAACF,KAAK;QACvEG,eAAe;IACjB;IAEAvG,gBAAgBmB,UAAU,CAACuE,IAAI,CAACK;AAClC;AAEA;;;CAGC,GACD,SAASX,oCAAoCjC,kBAAkB,EAAEjC,KAAK;IACpE,MAAM4E,SAAS3C,mBAAmB2C,MAAM;IACxC,MAAMZ,SAAS/B,mBAAmB+B,MAAM;IAExC,MAAMC,aAAa,IAAIqB,aAAatF;IACpC,IAAK,IAAIE,IAAI,GAAGA,IAAIF,OAAOE,IAAK;QAC9B+D,UAAU,CAAC/D,EAAE,GAAG0E,SAASW,KAAKC,KAAK,CAACtF,IAAI8D;IAC1C;IAEA,OAAOC;AACT;uCAEejG","ignoreList":[0]}},
    {"offset": {"line": 8593, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/MetadataPipelineStage.js"],"sourcesContent":["import Matrix3 from \"../../Core/Matrix3.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport MetadataStageFS from \"../../Shaders/Model/MetadataStageFS.js\";\nimport MetadataStageVS from \"../../Shaders/Model/MetadataStageVS.js\";\nimport MetadataType from \"../MetadataType.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\n/**\n * The metadata pipeline stage processes metadata properties from\n * EXT_structural_metadata and inserts them into a struct in the shader.\n * This struct will be used by {@link CustomShaderPipelineStage} to allow the\n * user to access metadata using {@link CustomShader}\n *\n * @namespace MetadataPipelineStage\n *\n * @private\n */\nconst MetadataPipelineStage = {\n  name: \"MetadataPipelineStage\",\n\n  STRUCT_ID_METADATA_VS: \"MetadataVS\",\n  STRUCT_ID_METADATA_FS: \"MetadataFS\",\n  STRUCT_NAME_METADATA: \"Metadata\",\n\n  STRUCT_ID_METADATA_CLASS_VS: \"MetadataClassVS\",\n  STRUCT_ID_METADATA_CLASS_FS: \"MetadataClassFS\",\n  STRUCT_NAME_METADATA_CLASS: \"MetadataClass\",\n\n  STRUCT_ID_METADATA_STATISTICS_VS: \"MetadataStatisticsVS\",\n  STRUCT_ID_METADATA_STATISTICS_FS: \"MetadataStatisticsFS\",\n  STRUCT_NAME_METADATA_STATISTICS: \"MetadataStatistics\",\n\n  FUNCTION_ID_INITIALIZE_METADATA_VS: \"initializeMetadataVS\",\n  FUNCTION_ID_INITIALIZE_METADATA_FS: \"initializeMetadataFS\",\n  FUNCTION_SIGNATURE_INITIALIZE_METADATA:\n    \"void initializeMetadata(out Metadata metadata, out MetadataClass metadataClass, out MetadataStatistics metadataStatistics, ProcessedAttributes attributes)\",\n  FUNCTION_ID_SET_METADATA_VARYINGS: \"setMetadataVaryings\",\n  FUNCTION_SIGNATURE_SET_METADATA_VARYINGS: \"void setMetadataVaryings()\",\n\n  // Metadata class and statistics fields:\n  // - some must be renamed to avoid reserved words\n  // - some always have float/vec values, even for integer/ivec property types\n  METADATA_CLASS_FIELDS: [\n    { specName: \"noData\", shaderName: \"noData\" },\n    { specName: \"default\", shaderName: \"defaultValue\" },\n    { specName: \"min\", shaderName: \"minValue\" },\n    { specName: \"max\", shaderName: \"maxValue\" },\n  ],\n  METADATA_STATISTICS_FIELDS: [\n    { specName: \"min\", shaderName: \"minValue\" },\n    { specName: \"max\", shaderName: \"maxValue\" },\n    { specName: \"mean\", shaderName: \"mean\", type: \"float\" },\n    { specName: \"median\", shaderName: \"median\" },\n    {\n      specName: \"standardDeviation\",\n      shaderName: \"standardDeviation\",\n      type: \"float\",\n    },\n    { specName: \"variance\", shaderName: \"variance\", type: \"float\" },\n    { specName: \"sum\", shaderName: \"sum\" },\n  ],\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>Adds a Metadata struct to the shader</li>\n *   <li>If the primitive has structural metadata, properties are added to the Metadata struct</li>\n *   <li>dynamic functions are added to the shader to initialize the metadata properties</li>\n *   <li>Adds uniforms for property textures to the uniform map as needed</li>\n *   <li>Adds uniforms for offset/scale to the uniform map as needed</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state\n * @private\n */\nMetadataPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const { shaderBuilder, model } = renderResources;\n  const { structuralMetadata = {}, content } = model;\n  const statistics = content?.tileset.metadataExtension?.statistics;\n\n  const propertyAttributesInfo = getPropertyAttributesInfo(\n    structuralMetadata.propertyAttributes,\n    primitive,\n    statistics,\n  );\n  const propertyTexturesInfo = getPropertyTexturesInfo(\n    structuralMetadata.propertyTextures,\n    statistics,\n  );\n\n  // Declare <type>MetadataClass and <type>MetadataStatistics structs as needed\n  const allPropertyInfos = propertyAttributesInfo.concat(propertyTexturesInfo);\n  declareMetadataTypeStructs(shaderBuilder, allPropertyInfos);\n\n  // Always declare the Metadata, MetadataClass, and MetadataStatistics structs\n  // and the initializeMetadata() function, even if not used\n  declareStructsAndFunctions(shaderBuilder);\n  shaderBuilder.addVertexLines(MetadataStageVS);\n  shaderBuilder.addFragmentLines(MetadataStageFS);\n\n  for (let i = 0; i < propertyAttributesInfo.length; i++) {\n    const info = propertyAttributesInfo[i];\n    processPropertyAttributeProperty(renderResources, info);\n  }\n  for (let i = 0; i < propertyTexturesInfo.length; i++) {\n    const info = propertyTexturesInfo[i];\n    processPropertyTextureProperty(renderResources, info);\n  }\n};\n\n/**\n * Collect info about all properties of all propertyAttributes, and\n * return as a flattened Array\n * @param {PropertyAttribute[]} propertyAttributes The PropertyAttributes with properties to be described\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {object} [statistics] Statistics about the properties (if the model is from a 3DTiles tileset)\n * @returns {object[]} An array of objects containing information about each PropertyAttributeProperty\n * @private\n */\nfunction getPropertyAttributesInfo(propertyAttributes, primitive, statistics) {\n  if (!defined(propertyAttributes)) {\n    return [];\n  }\n  return propertyAttributes.flatMap((propertyAttribute) =>\n    getPropertyAttributeInfo(propertyAttribute, primitive, statistics),\n  );\n}\n\n/**\n * Collect info about the properties of a single PropertyAttribute\n * @param {PropertyAttribute} propertyAttribute The PropertyAttribute with properties to be described\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {object} [statistics] Statistics about the properties (if the model is from a 3DTiles tileset)\n * @returns {object[]} An array of objects containing information about each PropertyAttributeProperty\n * @private\n */\nfunction getPropertyAttributeInfo(propertyAttribute, primitive, statistics) {\n  const { getAttributeByName, getAttributeInfo, sanitizeGlslIdentifier } =\n    ModelUtility;\n\n  const classId = propertyAttribute.class.id;\n  const classStatistics = statistics?.classes[classId];\n\n  const propertiesArray = Object.entries(propertyAttribute.properties);\n  const infoArray = new Array(propertiesArray.length);\n\n  for (let i = 0; i < propertiesArray.length; i++) {\n    const [propertyId, property] = propertiesArray[i];\n    const modelAttribute = getAttributeByName(primitive, property.attribute);\n    const { glslType, variableName } = getAttributeInfo(modelAttribute);\n\n    infoArray[i] = {\n      metadataVariable: sanitizeGlslIdentifier(propertyId),\n      property,\n      type: property.classProperty.type,\n      glslType,\n      variableName,\n      propertyStatistics: classStatistics?.properties[propertyId],\n      shaderDestination: ShaderDestination.BOTH,\n    };\n  }\n\n  return infoArray;\n}\n\n/**\n * Collect info about all properties of all propertyTextures, and\n * return as a flattened Array\n * @param {PropertyTexture[]} propertyTextures The PropertyTextures with properties to be described\n * @param {object} [statistics] Statistics about the properties (if the model is from a 3DTiles tileset)\n * @returns {object[]} An array of objects containing information about each PropertyTextureProperty\n * @private\n */\nfunction getPropertyTexturesInfo(propertyTextures, statistics) {\n  if (!defined(propertyTextures)) {\n    return [];\n  }\n  return propertyTextures.flatMap((propertyTexture) =>\n    getPropertyTextureInfo(propertyTexture, statistics),\n  );\n}\n\n/**\n * Collect info about the properties of a single PropertyTexture\n * @param {PropertyTexture} propertyTexture The PropertyTexture with properties to be described\n * @param {object} [statistics] Statistics about the properties (if the model is from a 3DTiles tileset)\n * @returns {object[]} An array of objects containing information about each PropertyTextureProperty\n * @private\n */\nfunction getPropertyTextureInfo(propertyTexture, statistics) {\n  const { sanitizeGlslIdentifier } = ModelUtility;\n\n  const classId = propertyTexture.class.id;\n  const classStatistics = statistics?.classes[classId];\n\n  const propertiesArray = Object.entries(propertyTexture.properties).filter(\n    ([id, property]) => property.isGpuCompatible(),\n  );\n  const infoArray = new Array(propertiesArray.length);\n\n  for (let i = 0; i < propertiesArray.length; i++) {\n    const [propertyId, property] = propertiesArray[i];\n\n    infoArray[i] = {\n      metadataVariable: sanitizeGlslIdentifier(propertyId),\n      property,\n      type: property.classProperty.type,\n      glslType: property.getGlslType(),\n      propertyStatistics: classStatistics?.properties[propertyId],\n      shaderDestination: ShaderDestination.FRAGMENT,\n    };\n  }\n\n  return infoArray;\n}\n\n/**\n * Declare <type>MetadataClass structs in the shader for each PropertyAttributeProperty and PropertyTextureProperty\n * @param {ShaderBuilder} shaderBuilder The shader builder for the primitive\n * @param {object[]} propertyInfos Information about the PropertyAttributeProperties and PropertyTextureProperties\n * @private\n */\nfunction declareMetadataTypeStructs(shaderBuilder, propertyInfos) {\n  const classTypes = new Set();\n  const statisticsTypes = new Set();\n\n  for (let i = 0; i < propertyInfos.length; i++) {\n    const { type, glslType, propertyStatistics } = propertyInfos[i];\n    classTypes.add(glslType);\n    if (!defined(propertyStatistics)) {\n      continue;\n    }\n    if (type !== MetadataType.ENUM) {\n      statisticsTypes.add(glslType);\n    }\n  }\n\n  const classFields = MetadataPipelineStage.METADATA_CLASS_FIELDS;\n  for (const metadataType of classTypes) {\n    const classStructName = `${metadataType}MetadataClass`;\n    declareTypeStruct(classStructName, metadataType, classFields);\n  }\n\n  const statisticsFields = MetadataPipelineStage.METADATA_STATISTICS_FIELDS;\n  for (const metadataType of statisticsTypes) {\n    const statisticsStructName = `${metadataType}MetadataStatistics`;\n    declareTypeStruct(statisticsStructName, metadataType, statisticsFields);\n  }\n\n  function declareTypeStruct(structName, type, fields) {\n    shaderBuilder.addStruct(structName, structName, ShaderDestination.BOTH);\n\n    for (let i = 0; i < fields.length; i++) {\n      const { shaderName } = fields[i];\n      const shaderType =\n        fields[i].type === \"float\" ? convertToFloatComponents(type) : type;\n      shaderBuilder.addStructField(structName, shaderType, shaderName);\n    }\n  }\n}\n\nconst floatConversions = {\n  int: \"float\",\n  ivec2: \"vec2\",\n  ivec3: \"vec3\",\n  ivec4: \"vec4\",\n};\n\n/**\n * For a type with integer components, find a corresponding float-component type\n * @param {string} type The name of a GLSL type with integer components\n * @returns {string} The name of a GLSL type of the same dimension with float components, if available; otherwise the input type\n * @private\n */\nfunction convertToFloatComponents(type) {\n  const converted = floatConversions[type];\n  return defined(converted) ? converted : type;\n}\n\n/**\n * Declare the main Metadata, MetadataClass, and MetadataStatistics structs\n * and the initializeMetadata() function.\n * @param {ShaderBuilder} shaderBuilder The shader builder for the primitive\n * @private\n */\nfunction declareStructsAndFunctions(shaderBuilder) {\n  // Declare the Metadata struct.\n  shaderBuilder.addStruct(\n    MetadataPipelineStage.STRUCT_ID_METADATA_VS,\n    MetadataPipelineStage.STRUCT_NAME_METADATA,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addStruct(\n    MetadataPipelineStage.STRUCT_ID_METADATA_FS,\n    MetadataPipelineStage.STRUCT_NAME_METADATA,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Declare the MetadataClass struct\n  shaderBuilder.addStruct(\n    MetadataPipelineStage.STRUCT_ID_METADATA_CLASS_VS,\n    MetadataPipelineStage.STRUCT_NAME_METADATA_CLASS,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addStruct(\n    MetadataPipelineStage.STRUCT_ID_METADATA_CLASS_FS,\n    MetadataPipelineStage.STRUCT_NAME_METADATA_CLASS,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Declare the MetadataStatistics struct\n  shaderBuilder.addStruct(\n    MetadataPipelineStage.STRUCT_ID_METADATA_STATISTICS_VS,\n    MetadataPipelineStage.STRUCT_NAME_METADATA_STATISTICS,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addStruct(\n    MetadataPipelineStage.STRUCT_ID_METADATA_STATISTICS_FS,\n    MetadataPipelineStage.STRUCT_NAME_METADATA_STATISTICS,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // declare the initializeMetadata() function. The details may differ\n  // between vertex and fragment shader\n  shaderBuilder.addFunction(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_VS,\n    MetadataPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_METADATA,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addFunction(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS,\n    MetadataPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_METADATA,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // declare the setMetadataVaryings() function in the vertex shader only.\n  shaderBuilder.addFunction(\n    MetadataPipelineStage.FUNCTION_ID_SET_METADATA_VARYINGS,\n    MetadataPipelineStage.FUNCTION_SIGNATURE_SET_METADATA_VARYINGS,\n    ShaderDestination.VERTEX,\n  );\n}\n\n/**\n * Update the shader for a single PropertyAttributeProperty\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {object} propertyInfo Info about the PropertyAttributeProperty\n * @private\n */\nfunction processPropertyAttributeProperty(renderResources, propertyInfo) {\n  addPropertyAttributePropertyMetadata(renderResources, propertyInfo);\n  addPropertyMetadataClass(renderResources.shaderBuilder, propertyInfo);\n  addPropertyMetadataStatistics(renderResources.shaderBuilder, propertyInfo);\n}\n\n/**\n * Add fields to the Metadata struct, and metadata value assignments to the\n * initializeMetadata function, for a PropertyAttributeProperty\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {object} propertyInfo Info about the PropertyAttributeProperty\n * @private\n */\nfunction addPropertyAttributePropertyMetadata(renderResources, propertyInfo) {\n  const { shaderBuilder } = renderResources;\n  const { metadataVariable, property, glslType } = propertyInfo;\n\n  const valueExpression = addValueTransformUniforms({\n    valueExpression: `attributes.${propertyInfo.variableName}`,\n    renderResources: renderResources,\n    glslType: glslType,\n    metadataVariable: metadataVariable,\n    shaderDestination: ShaderDestination.BOTH,\n    property: property,\n  });\n\n  // declare the struct field\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_VS,\n    glslType,\n    metadataVariable,\n  );\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_FS,\n    glslType,\n    metadataVariable,\n  );\n\n  // assign the result to the metadata struct property.\n  const initializationLine = `metadata.${metadataVariable} = ${valueExpression};`;\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_VS,\n    [initializationLine],\n  );\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS,\n    [initializationLine],\n  );\n}\n\n/**\n * Update the shader for a single PropertyTextureProperty\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {object[]} propertyInfo Info about the PropertyTextureProperty\n * @private\n */\nfunction processPropertyTextureProperty(renderResources, propertyInfo) {\n  addPropertyTexturePropertyMetadata(renderResources, propertyInfo);\n  addPropertyMetadataClass(renderResources.shaderBuilder, propertyInfo);\n  addPropertyMetadataStatistics(renderResources.shaderBuilder, propertyInfo);\n}\n\n/**\n * Add fields to the Metadata struct, and metadata value expressions to the\n * initializeMetadata function, for a PropertyTextureProperty\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {object} propertyInfo Info about the PropertyTextureProperty\n * @private\n */\nfunction addPropertyTexturePropertyMetadata(renderResources, propertyInfo) {\n  const { shaderBuilder, uniformMap } = renderResources;\n  const { metadataVariable, glslType, property } = propertyInfo;\n\n  const { texCoord, channels, index, texture, transform } =\n    property.textureReader;\n  const textureUniformName = `u_propertyTexture_${index}`;\n\n  // Property texture properties may share the same physical texture, so only\n  // add the texture uniform the first time we encounter it.\n  if (!uniformMap.hasOwnProperty(textureUniformName)) {\n    shaderBuilder.addUniform(\n      \"sampler2D\",\n      textureUniformName,\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap[textureUniformName] = () => texture;\n  }\n\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_FS,\n    glslType,\n    metadataVariable,\n  );\n\n  // Get a GLSL expression for the texture coordinates of the property.\n  // By default, this will be taken directly from the attributes.\n  const texCoordVariable = `attributes.texCoord_${texCoord}`;\n  let texCoordVariableExpression = texCoordVariable;\n\n  // Check if the texture defines a `transform` from a `KHR_texture_transform`\n  if (defined(transform) && !Matrix3.equals(transform, Matrix3.IDENTITY)) {\n    // Add a uniform for the transformation matrix\n    const transformUniformName = `${textureUniformName}Transform`;\n    shaderBuilder.addUniform(\n      \"mat3\",\n      transformUniformName,\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap[transformUniformName] = function () {\n      return transform;\n    };\n\n    // Update the expression for the texture coordinates\n    // with one that transforms the texture coordinates\n    // with the transform matrix first\n    texCoordVariableExpression = `vec2(${transformUniformName} * vec3(${texCoordVariable}, 1.0))`;\n  }\n  const valueExpression = `texture(${textureUniformName}, ${texCoordVariableExpression}).${channels}`;\n\n  // Some types need an unpacking step or two. For example, since texture reads\n  // are always normalized, UINT8 (not normalized) properties need to be\n  // un-normalized in the shader.\n  const unpackedValue = property.unpackInShader(valueExpression);\n\n  const transformedValue = addValueTransformUniforms({\n    valueExpression: unpackedValue,\n    renderResources: renderResources,\n    glslType: glslType,\n    metadataVariable: metadataVariable,\n    shaderDestination: ShaderDestination.FRAGMENT,\n    property: property,\n  });\n\n  const initializationLine = `metadata.${metadataVariable} = ${transformedValue};`;\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS,\n    [initializationLine],\n  );\n}\n\n/**\n * Add fields to the MetadataClass struct, and metadataClass value expressions\n * to the initializeMetadata function, for a PropertyAttributeProperty or\n * PropertyTextureProperty\n * @param {ShaderBuilder} shaderBuilder The shader builder for the primitive\n * @param {object} propertyInfo Info about the PropertyAttributeProperty or PropertyTextureProperty\n * @private\n */\nfunction addPropertyMetadataClass(shaderBuilder, propertyInfo) {\n  const { classProperty } = propertyInfo.property;\n  const { metadataVariable, glslType, shaderDestination } = propertyInfo;\n\n  // Construct assignment statements to set values in the metadataClass struct\n  const assignments = getStructAssignments(\n    MetadataPipelineStage.METADATA_CLASS_FIELDS,\n    classProperty,\n    `metadataClass.${metadataVariable}`,\n    glslType,\n  );\n\n  // Struct field: Prefix to get the appropriate <type>MetadataClass struct\n  const metadataType = `${glslType}MetadataClass`;\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_CLASS_FS,\n    metadataType,\n    metadataVariable,\n  );\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS,\n    assignments,\n  );\n  if (!ShaderDestination.includesVertexShader(shaderDestination)) {\n    return;\n  }\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_CLASS_VS,\n    metadataType,\n    metadataVariable,\n  );\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_VS,\n    assignments,\n  );\n}\n\n/**\n * Add fields to the MetadataStatistics struct, and metadataStatistics value\n * expressions to the initializeMetadata function, for a\n * PropertyAttributeProperty or PropertyTextureProperty\n * @param {ShaderBuilder} shaderBuilder The shader builder for the primitive\n * @param {object} propertyInfo Info about the PropertyAttributeProperty or PropertyTextureProperty\n * @private\n */\nfunction addPropertyMetadataStatistics(shaderBuilder, propertyInfo) {\n  const { propertyStatistics } = propertyInfo;\n  if (!defined(propertyStatistics)) {\n    return;\n  }\n  const { metadataVariable, type, glslType } = propertyInfo;\n  if (type === MetadataType.ENUM) {\n    // enums have an \"occurrences\" statistic which is not implemented yet\n    return;\n  }\n\n  // Construct assignment statements to set values in the metadataStatistics struct\n  const fields = MetadataPipelineStage.METADATA_STATISTICS_FIELDS;\n  const struct = `metadataStatistics.${metadataVariable}`;\n  const assignments = getStructAssignments(\n    fields,\n    propertyStatistics,\n    struct,\n    glslType,\n  );\n\n  // Struct field: Prefix to get the appropriate <type>MetadataStatistics struct\n  const statisticsType = `${glslType}MetadataStatistics`;\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_STATISTICS_FS,\n    statisticsType,\n    metadataVariable,\n  );\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS,\n    assignments,\n  );\n  if (!ShaderDestination.includesVertexShader(propertyInfo.shaderDestination)) {\n    return;\n  }\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_STATISTICS_VS,\n    statisticsType,\n    metadataVariable,\n  );\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_VS,\n    assignments,\n  );\n}\n\n/**\n * Construct GLSL assignment statements to set metadata spec values in a struct\n * @param {object[]} fieldNames An object with the following properties:\n * @param {string} fieldNames[].specName The name of the property in the spec\n * @param {string} fieldNames[].shaderName The name of the property in the shader\n * @param {object} values A source of property values, keyed on fieldNames[].specName\n * @param {string} struct The name of the struct to which values will be assigned\n * @param {string} type The type of the values to be assigned\n * @returns {Array<{name: string, value: any}>} Objects containing the property name (in the shader) and a GLSL assignment statement for the property value\n * @private\n */\nfunction getStructAssignments(fieldNames, values, struct, type) {\n  function constructAssignment(field) {\n    const value = values[field.specName];\n    if (defined(value)) {\n      return `${struct}.${field.shaderName} = ${type}(${value});`;\n    }\n  }\n  return defined(values)\n    ? fieldNames.map(constructAssignment).filter(defined)\n    : [];\n}\n\n/**\n * Handle offset/scale transform for a property value\n * This wraps the GLSL value expression with a czm_valueTransform() call\n *\n * @param {object} options Object with the following properties:\n * @param {string} options.valueExpression The GLSL value expression without the transform\n * @param {string} options.metadataVariable The name of the GLSL variable that will contain the property value\n * @param {string} options.glslType The GLSL type of the variable\n * @param {ShaderDestination} options.shaderDestination Which shader(s) use this variable\n * @param {PrimitiveRenderResources} options.renderResources The render resources for this primitive\n * @param {(PropertyAttributeProperty|PropertyTextureProperty)} options.property The property from which the value is derived\n * @returns {string} A wrapped GLSL value expression\n * @private\n */\nfunction addValueTransformUniforms(options) {\n  const { valueExpression, property } = options;\n\n  if (!property.hasValueTransform) {\n    return valueExpression;\n  }\n\n  const metadataVariable = options.metadataVariable;\n  const offsetUniformName = `u_${metadataVariable}_offset`;\n  const scaleUniformName = `u_${metadataVariable}_scale`;\n\n  const { shaderBuilder, uniformMap } = options.renderResources;\n  const { glslType, shaderDestination } = options;\n  shaderBuilder.addUniform(glslType, offsetUniformName, shaderDestination);\n  shaderBuilder.addUniform(glslType, scaleUniformName, shaderDestination);\n\n  const { offset, scale } = property;\n  uniformMap[offsetUniformName] = () => offset;\n  uniformMap[scaleUniformName] = () => scale;\n\n  return `czm_valueTransform(${offsetUniformName}, ${scaleUniformName}, ${valueExpression})`;\n}\n\nexport default MetadataPipelineStage;\n"],"names":["MetadataPipelineStage","name","STRUCT_ID_METADATA_VS","STRUCT_ID_METADATA_FS","STRUCT_NAME_METADATA","STRUCT_ID_METADATA_CLASS_VS","STRUCT_ID_METADATA_CLASS_FS","STRUCT_NAME_METADATA_CLASS","STRUCT_ID_METADATA_STATISTICS_VS","STRUCT_ID_METADATA_STATISTICS_FS","STRUCT_NAME_METADATA_STATISTICS","FUNCTION_ID_INITIALIZE_METADATA_VS","FUNCTION_ID_INITIALIZE_METADATA_FS","FUNCTION_SIGNATURE_INITIALIZE_METADATA","FUNCTION_ID_SET_METADATA_VARYINGS","FUNCTION_SIGNATURE_SET_METADATA_VARYINGS","METADATA_CLASS_FIELDS","specName","shaderName","METADATA_STATISTICS_FIELDS","type","process","renderResources","primitive","frameState","shaderBuilder","model","structuralMetadata","content","statistics","tileset","metadataExtension","propertyAttributesInfo","getPropertyAttributesInfo","propertyAttributes","propertyTexturesInfo","getPropertyTexturesInfo","propertyTextures","allPropertyInfos","concat","declareMetadataTypeStructs","declareStructsAndFunctions","addVertexLines","addFragmentLines","i","length","info","processPropertyAttributeProperty","processPropertyTextureProperty","flatMap","propertyAttribute","getPropertyAttributeInfo","getAttributeByName","getAttributeInfo","sanitizeGlslIdentifier","classId","class","id","classStatistics","classes","propertiesArray","Object","entries","properties","infoArray","Array","propertyId","property","modelAttribute","attribute","glslType","variableName","metadataVariable","classProperty","propertyStatistics","shaderDestination","BOTH","propertyTexture","getPropertyTextureInfo","filter","isGpuCompatible","getGlslType","FRAGMENT","propertyInfos","classTypes","Set","statisticsTypes","add","ENUM","classFields","metadataType","classStructName","declareTypeStruct","statisticsFields","statisticsStructName","structName","fields","addStruct","shaderType","convertToFloatComponents","addStructField","floatConversions","int","ivec2","ivec3","ivec4","converted","VERTEX","addFunction","propertyInfo","addPropertyAttributePropertyMetadata","addPropertyMetadataClass","addPropertyMetadataStatistics","valueExpression","addValueTransformUniforms","initializationLine","addFunctionLines","addPropertyTexturePropertyMetadata","uniformMap","texCoord","channels","index","texture","transform","textureReader","textureUniformName","hasOwnProperty","addUniform","texCoordVariable","texCoordVariableExpression","equals","IDENTITY","transformUniformName","unpackedValue","unpackInShader","transformedValue","assignments","getStructAssignments","includesVertexShader","struct","statisticsType","fieldNames","values","constructAssignment","field","value","map","options","hasValueTransform","offsetUniformName","scaleUniformName","offset","scale"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9092, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/CustomShaderTranslucencyMode.js"],"sourcesContent":["/**\n * An enum for controling how {@link CustomShader} handles translucency compared with the original\n * primitive.\n *\n * @enum {number}\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst CustomShaderTranslucencyMode = {\n  /**\n   * Inherit translucency settings from the primitive's material. If the primitive used a\n   * translucent material, the custom shader will also be considered translucent. If the primitive\n   * used an opaque material, the custom shader will be considered opaque.\n   *\n   * @type {number}\n   * @constant\n   */\n  INHERIT: 0,\n  /**\n   * Force the primitive to render the primitive as opaque, ignoring any material settings.\n   *\n   * @type {number}\n   * @constant\n   */\n  OPAQUE: 1,\n  /**\n   * Force the primitive to render the primitive as translucent, ignoring any material settings.\n   *\n   * @type {number}\n   * @constant\n   */\n  TRANSLUCENT: 2,\n};\n\nexport default Object.freeze(CustomShaderTranslucencyMode);\n"],"names":["CustomShaderTranslucencyMode","INHERIT","OPAQUE","TRANSLUCENT","Object","freeze"],"mappings":";;;;AAAA;;;;;;;CAOC,GACD,MAAMA,+BAA+B;IACnC;;;;;;;GAOC,GACDC,SAAS;IACT;;;;;GAKC,GACDC,QAAQ;IACR;;;;;GAKC,GACDC,aAAa;AACf;uCAEeC,OAAOC,MAAM,CAACL","ignoreList":[0]}},
    {"offset": {"line": 9130, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/CustomShaderPipelineStage.js"],"sourcesContent":["import combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport oneTimeWarning from \"../../Core/oneTimeWarning.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport CustomShaderStageVS from \"../../Shaders/Model/CustomShaderStageVS.js\";\nimport CustomShaderStageFS from \"../../Shaders/Model/CustomShaderStageFS.js\";\nimport CustomShaderMode from \"./CustomShaderMode.js\";\nimport FeatureIdPipelineStage from \"./FeatureIdPipelineStage.js\";\nimport MetadataPipelineStage from \"./MetadataPipelineStage.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport CustomShaderTranslucencyMode from \"./CustomShaderTranslucencyMode.js\";\n\n/**\n * The custom shader pipeline stage takes GLSL callbacks from the\n * {@link CustomShader} and inserts them into the overall shader code for the\n * {@link Model}. The input to the callback is a struct with many\n * properties that depend on the attributes of the primitive. This shader code\n * is automatically generated by this stage.\n *\n * @namespace CustomShaderPipelineStage\n *\n * @private\n */\nconst CustomShaderPipelineStage = {\n  name: \"CustomShaderPipelineStage\", // Helps with debugging\n\n  STRUCT_ID_ATTRIBUTES_VS: \"AttributesVS\",\n  STRUCT_ID_ATTRIBUTES_FS: \"AttributesFS\",\n  STRUCT_NAME_ATTRIBUTES: \"Attributes\",\n  STRUCT_ID_VERTEX_INPUT: \"VertexInput\",\n  STRUCT_NAME_VERTEX_INPUT: \"VertexInput\",\n  STRUCT_ID_FRAGMENT_INPUT: \"FragmentInput\",\n  STRUCT_NAME_FRAGMENT_INPUT: \"FragmentInput\",\n  FUNCTION_ID_INITIALIZE_INPUT_STRUCT_VS: \"initializeInputStructVS\",\n  FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_VS:\n    \"void initializeInputStruct(out VertexInput vsInput, ProcessedAttributes attributes)\",\n  FUNCTION_ID_INITIALIZE_INPUT_STRUCT_FS: \"initializeInputStructFS\",\n  FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_FS:\n    \"void initializeInputStruct(out FragmentInput fsInput, ProcessedAttributes attributes)\",\n\n  // Expose method for testing.\n  _oneTimeWarning: oneTimeWarning,\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>Modifies the shader to include the custom shader code to the vertex and fragment shaders</li>\n *   <li>Modifies the shader to include automatically-generated structs that serve as input to the custom shader callbacks </li>\n *   <li>Modifies the shader to include any additional user-defined uniforms</li>\n *   <li>Modifies the shader to include any additional user-defined varyings</li>\n *   <li>Adds any user-defined uniforms to the uniform map</li>\n *   <li>If the user specified a lighting model, the settings are overridden in the render resources</li>\n * </ul>\n * <p>\n * This pipeline stage is designed to fail gracefully where possible. If the\n * primitive does not have the right attributes to satisfy the shader code,\n * defaults will be inferred (when reasonable to do so). If not, the custom\n * shader will be disabled.\n * <p>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state.\n * @private\n */\nCustomShaderPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const { shaderBuilder, model, alphaOptions } = renderResources;\n  const { customShader } = model;\n\n  // Check the lighting model and translucent options first, as sometimes\n  // these are used even if there is no vertex or fragment shader text.\n  const { lightingModel, translucencyMode } = customShader;\n\n  // if present, the lighting model overrides the material's lighting model.\n  if (defined(lightingModel)) {\n    renderResources.lightingOptions.lightingModel = lightingModel;\n  }\n\n  if (translucencyMode === CustomShaderTranslucencyMode.TRANSLUCENT) {\n    alphaOptions.pass = Pass.TRANSLUCENT;\n  } else if (translucencyMode === CustomShaderTranslucencyMode.OPAQUE) {\n    // Use the default opqaue pass (either OPAQUE or 3D_TILES), regardless of whether\n    // the material pipeline stage used translucent. The default is configured\n    // in AlphaPipelineStage\n    alphaOptions.pass = undefined;\n  }\n  // For CustomShaderTranslucencyMode.INHERIT, do not modify alphaOptions.pass\n\n  // Generate lines of code for the shader, but don't add them to the shader\n  // yet.\n  const generatedCode = generateShaderLines(customShader, primitive);\n\n  // In some corner cases, the primitive may not be compatible with the\n  // shader. In this case, skip the custom shader.\n  if (!generatedCode.customShaderEnabled) {\n    return;\n  }\n  addLinesToShader(shaderBuilder, customShader, generatedCode);\n\n  // the input to the fragment shader may include a low-precision ECEF position\n  if (generatedCode.shouldComputePositionWC) {\n    shaderBuilder.addDefine(\n      \"COMPUTE_POSITION_WC_CUSTOM_SHADER\",\n      undefined,\n      ShaderDestination.BOTH,\n    );\n  }\n\n  if (defined(customShader.vertexShaderText)) {\n    shaderBuilder.addDefine(\n      \"HAS_CUSTOM_VERTEX_SHADER\",\n      undefined,\n      ShaderDestination.VERTEX,\n    );\n  }\n\n  if (defined(customShader.fragmentShaderText)) {\n    shaderBuilder.addDefine(\n      \"HAS_CUSTOM_FRAGMENT_SHADER\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n\n    // add defines like CUSTOM_SHADER_MODIFY_MATERIAL\n    const shaderModeDefine = CustomShaderMode.getDefineName(customShader.mode);\n    shaderBuilder.addDefine(\n      shaderModeDefine,\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  const uniforms = customShader.uniforms;\n  for (const uniformName in uniforms) {\n    if (uniforms.hasOwnProperty(uniformName)) {\n      const uniform = uniforms[uniformName];\n      shaderBuilder.addUniform(uniform.type, uniformName);\n    }\n  }\n\n  const varyings = customShader.varyings;\n  for (const varyingName in varyings) {\n    if (varyings.hasOwnProperty(varyingName)) {\n      const varyingType = varyings[varyingName];\n      shaderBuilder.addVarying(varyingType, varyingName);\n    }\n  }\n\n  renderResources.uniformMap = combine(\n    renderResources.uniformMap,\n    customShader.uniformMap,\n  );\n};\n\n/**\n * @private\n * @param {ModelComponents.Attribute[]} attributes\n * @returns {Object<string, ModelComponents.Attribute>}\n */\nfunction getAttributesByName(attributes) {\n  const names = {};\n  for (let i = 0; i < attributes.length; i++) {\n    const attributeInfo = ModelUtility.getAttributeInfo(attributes[i]);\n    names[attributeInfo.variableName] = attributeInfo;\n  }\n  return names;\n}\n\n// GLSL types of standard attribute types when uniquely defined\nconst attributeTypeLUT = {\n  position: \"vec3\",\n  normal: \"vec3\",\n  tangent: \"vec3\",\n  bitangent: \"vec3\",\n  texCoord: \"vec2\",\n  color: \"vec4\",\n  joints: \"ivec4\",\n  weights: \"vec4\",\n};\n\n// Corresponding attribute values\nconst attributeDefaultValueLUT = {\n  position: \"vec3(0.0)\",\n  normal: \"vec3(0.0, 0.0, 1.0)\",\n  tangent: \"vec3(1.0, 0.0, 0.0)\",\n  bitangent: \"vec3(0.0, 1.0, 0.0)\",\n  texCoord: \"vec2(0.0)\",\n  color: \"vec4(1.0)\",\n  joints: \"ivec4(0)\",\n  weights: \"vec4(0.0)\",\n};\n\nfunction inferAttributeDefaults(attributeName) {\n  // remove trailing set indices. E.g. \"texCoord_0\" -> \"texCoord\"\n  let trimmed = attributeName.replace(/_[0-9]+$/, \"\");\n  // also remove the MC/EC since they will have the same default value\n  trimmed = trimmed.replace(/(MC|EC)$/, \"\");\n\n  const glslType = attributeTypeLUT[trimmed];\n  const value = attributeDefaultValueLUT[trimmed];\n\n  // - _CUSTOM_ATTRIBUTE has an unknown type.\n  if (!defined(glslType)) {\n    return undefined;\n  }\n\n  return {\n    attributeField: [glslType, attributeName],\n    value: value,\n  };\n}\n\n/**\n * @private\n * @param {CustomShader} customShader\n * @param {Object<string, ModelComponents.Attribute>} attributesByName\n * @returns {object}\n */\nfunction generateVertexShaderLines(customShader, attributesByName) {\n  if (!defined(customShader.vertexShaderText)) {\n    return { enabled: false };\n  }\n\n  const primitiveAttributes = customShader.usedVariablesVertex.attributeSet;\n  const addToShader = getPrimitiveAttributesUsedInShader(\n    attributesByName,\n    primitiveAttributes,\n    false,\n  );\n  const needsDefault = getAttributesNeedingDefaults(\n    attributesByName,\n    primitiveAttributes,\n    false,\n  );\n\n  let vertexInitialization;\n  const attributeFields = [];\n  const initializationLines = [];\n  for (const variableName in addToShader) {\n    if (!addToShader.hasOwnProperty(variableName)) {\n      continue;\n    }\n    const attributeInfo = addToShader[variableName];\n    const attributeField = [attributeInfo.glslType, variableName];\n    attributeFields.push(attributeField);\n\n    // Initializing attribute structs are just a matter of copying the\n    // attribute or varying: E.g.:\n    // \"    vsInput.attributes.position = a_position;\"\n    vertexInitialization = `vsInput.attributes.${variableName} = attributes.${variableName};`;\n    initializationLines.push(vertexInitialization);\n  }\n\n  for (let i = 0; i < needsDefault.length; i++) {\n    const variableName = needsDefault[i];\n    const attributeDefaults = inferAttributeDefaults(variableName);\n    if (!defined(attributeDefaults)) {\n      CustomShaderPipelineStage._oneTimeWarning(\n        \"CustomShaderPipelineStage.incompatiblePrimitiveVS\",\n        `Primitive is missing attribute ${variableName}, disabling custom vertex shader`,\n      );\n      // This primitive isn't compatible with the shader. Return early\n      // to skip the vertex shader\n      return { enabled: false };\n    }\n\n    attributeFields.push(attributeDefaults.attributeField);\n    vertexInitialization = `vsInput.attributes.${variableName} = ${attributeDefaults.value};`;\n    initializationLines.push(vertexInitialization);\n  }\n\n  return {\n    enabled: true,\n    attributeFields: attributeFields,\n    initializationLines: initializationLines,\n  };\n}\n\nfunction generatePositionBuiltins(customShader) {\n  const attributeFields = [];\n  const initializationLines = [];\n  const usedVariables = customShader.usedVariablesFragment.attributeSet;\n\n  // Model space position is the same position as in the glTF accessor,\n  // this is already added to the shader with other attributes.\n\n  // World coordinates in ECEF coordinates. Note that this is\n  // low precision (32-bit floats) on the GPU.\n  if (usedVariables.hasOwnProperty(\"positionWC\")) {\n    attributeFields.push([\"vec3\", \"positionWC\"]);\n    initializationLines.push(\n      \"fsInput.attributes.positionWC = attributes.positionWC;\",\n    );\n  }\n\n  // position in eye coordinates\n  if (usedVariables.hasOwnProperty(\"positionEC\")) {\n    attributeFields.push([\"vec3\", \"positionEC\"]);\n    initializationLines.push(\n      \"fsInput.attributes.positionEC = attributes.positionEC;\",\n    );\n  }\n\n  return {\n    attributeFields: attributeFields,\n    initializationLines: initializationLines,\n  };\n}\n\n/**\n * @private\n * @param {CustomShader} customShader\n * @param {Object<string, ModelComponents.Attribute>} attributesByName\n * @returns {object}\n */\nfunction generateFragmentShaderLines(customShader, attributesByName) {\n  if (!defined(customShader.fragmentShaderText)) {\n    return { enabled: false };\n  }\n\n  const primitiveAttributes = customShader.usedVariablesFragment.attributeSet;\n  const addToShader = getPrimitiveAttributesUsedInShader(\n    attributesByName,\n    primitiveAttributes,\n    true,\n  );\n  const needsDefault = getAttributesNeedingDefaults(\n    attributesByName,\n    primitiveAttributes,\n    true,\n  );\n\n  let fragmentInitialization;\n  const attributeFields = [];\n  const initializationLines = [];\n  for (const variableName in addToShader) {\n    if (!addToShader.hasOwnProperty(variableName)) {\n      continue;\n    }\n    const attributeInfo = addToShader[variableName];\n\n    const attributeField = [attributeInfo.glslType, variableName];\n    attributeFields.push(attributeField);\n\n    // Initializing attribute structs are just a matter of copying the\n    // value from the processed attributes\n    // \"    fsInput.attributes.positionMC = attributes.positionMC;\"\n    fragmentInitialization = `fsInput.attributes.${variableName} = attributes.${variableName};`;\n    initializationLines.push(fragmentInitialization);\n  }\n\n  for (let i = 0; i < needsDefault.length; i++) {\n    const variableName = needsDefault[i];\n    const attributeDefaults = inferAttributeDefaults(variableName);\n    if (!defined(attributeDefaults)) {\n      CustomShaderPipelineStage._oneTimeWarning(\n        \"CustomShaderPipelineStage.incompatiblePrimitiveFS\",\n        `Primitive is missing attribute ${variableName}, disabling custom fragment shader.`,\n      );\n\n      // This primitive isn't compatible with the shader. Return early\n      // so the fragment shader is skipped\n      return { enabled: false };\n    }\n\n    attributeFields.push(attributeDefaults.attributeField);\n    fragmentInitialization = `fsInput.attributes.${variableName} = ${attributeDefaults.value};`;\n    initializationLines.push(fragmentInitialization);\n  }\n\n  // Built-ins for positions in various coordinate systems.\n  const positionBuiltins = generatePositionBuiltins(customShader);\n\n  return {\n    enabled: true,\n    attributeFields: attributeFields.concat(positionBuiltins.attributeFields),\n    initializationLines:\n      positionBuiltins.initializationLines.concat(initializationLines),\n  };\n}\n\n// These attributes are derived from positionMC, and are handled separately\n// from other attributes\nconst builtinAttributes = {\n  positionWC: true,\n  positionEC: true,\n};\n\n/**\n * Get the primitive attributes that are referenced in the shader\n *\n * @private\n * @param {Object<string, ModelComponents.Attribute>} primitiveAttributes set of all the primitive's attributes\n * @param {Object<string, ModelComponents.Attribute>} shaderAttributeSet set of all attributes used in the shader\n * @param {boolean} isFragmentShader\n * @returns {Object<string, ModelComponents.Attribute>} A dictionary of the primitive attributes used in the shader\n */\nfunction getPrimitiveAttributesUsedInShader(\n  primitiveAttributes,\n  shaderAttributeSet,\n  isFragmentShader,\n) {\n  const addToShader = {};\n  for (const attributeName in primitiveAttributes) {\n    if (!primitiveAttributes.hasOwnProperty(attributeName)) {\n      continue;\n    }\n    const attribute = primitiveAttributes[attributeName];\n\n    // normals and tangents are in model coordinates in the attributes but\n    // in eye coordinates in the fragment shader.\n    let renamed = attributeName;\n    if (isFragmentShader && attributeName === \"normalMC\") {\n      renamed = \"normalEC\";\n    } else if (isFragmentShader && attributeName === \"tangentMC\") {\n      renamed = \"tangentEC\";\n      attribute.glslType = \"vec3\";\n    }\n\n    if (shaderAttributeSet.hasOwnProperty(renamed)) {\n      addToShader[renamed] = attribute;\n    }\n  }\n  return addToShader;\n}\n\n/**\n * Get the attributes that will need to have default values defined.\n * Attributes referenced in the shader which are not already defined\n * for the primitive and are not built-in will need default values.\n *\n * @private\n * @param {Object<string, ModelComponents.Attribute>} primitiveAttributes set of all the primitive's attributes\n * @param {Object<string, ModelComponents.Attribute>} shaderAttributeSet set of all attributes used in the shader\n * @param {boolean} isFragmentShader\n * @returns {string[]} The names of the attributes needing defaults\n */\nfunction getAttributesNeedingDefaults(\n  primitiveAttributes,\n  shaderAttributeSet,\n  isFragmentShader,\n) {\n  const needDefaults = [];\n  for (const attributeName in shaderAttributeSet) {\n    if (!shaderAttributeSet.hasOwnProperty(attributeName)) {\n      continue;\n    }\n    if (builtinAttributes.hasOwnProperty(attributeName)) {\n      // Builtins are handled separately from attributes, so skip them here\n      continue;\n    }\n\n    // normals and tangents are in model coordinates in the attributes but\n    // in eye coordinates in the fragment shader.\n    let renamed = attributeName;\n    if (isFragmentShader && attributeName === \"normalEC\") {\n      renamed = \"normalMC\";\n    } else if (isFragmentShader && attributeName === \"tangentEC\") {\n      renamed = \"tangentMC\";\n    }\n\n    if (!primitiveAttributes.hasOwnProperty(renamed)) {\n      needDefaults.push(attributeName);\n    }\n  }\n  return needDefaults;\n}\n\n/**\n * @private\n * @param {CustomShader} customShader\n * @param {ModelComponents.Primitive} primitive\n * @returns {object}\n */\nfunction generateShaderLines(customShader, primitive) {\n  // Attempt to generate vertex and fragment shader lines before adding any\n  // code to the shader.\n  const attributesByName = getAttributesByName(primitive.attributes);\n  const vertexLines = generateVertexShaderLines(customShader, attributesByName);\n  const fragmentLines = generateFragmentShaderLines(\n    customShader,\n    attributesByName,\n  );\n\n  // positionWC must be computed in the vertex shader\n  // for use in the fragmentShader. However, this can be skipped if:\n  // - positionWC isn't used in the fragment shader\n  // - or the fragment shader is disabled\n  const attributeSetFS = customShader.usedVariablesFragment.attributeSet;\n  const shouldComputePositionWC =\n    attributeSetFS.hasOwnProperty(\"positionWC\") && fragmentLines.enabled;\n\n  // Return any generated shader code along with some flags to indicate which\n  // defines should be added.\n  return {\n    vertexLines: vertexLines,\n    fragmentLines: fragmentLines,\n    customShaderEnabled: vertexLines.enabled || fragmentLines.enabled,\n    shouldComputePositionWC: shouldComputePositionWC,\n  };\n}\n\nfunction addVertexLinesToShader(shaderBuilder, vertexLines) {\n  let structId = CustomShaderPipelineStage.STRUCT_ID_ATTRIBUTES_VS;\n  shaderBuilder.addStruct(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES,\n    ShaderDestination.VERTEX,\n  );\n\n  const { attributeFields, initializationLines } = vertexLines;\n  for (let i = 0; i < attributeFields.length; i++) {\n    const [glslType, variableName] = attributeFields[i];\n    shaderBuilder.addStructField(structId, glslType, variableName);\n  }\n\n  // This could be hard-coded, but the symmetry with other structs makes unit\n  // tests more convenient\n  structId = CustomShaderPipelineStage.STRUCT_ID_VERTEX_INPUT;\n  shaderBuilder.addStruct(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_VERTEX_INPUT,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addStructField(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES,\n    \"attributes\",\n  );\n  // Add FeatureIds struct from the Feature ID stage\n  shaderBuilder.addStructField(\n    structId,\n    FeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS,\n    \"featureIds\",\n  );\n  // Add Metadata struct from the metadata stage\n  shaderBuilder.addStructField(\n    structId,\n    MetadataPipelineStage.STRUCT_NAME_METADATA,\n    \"metadata\",\n  );\n  // Add MetadataClass struct from the metadata stage\n  shaderBuilder.addStructField(\n    structId,\n    MetadataPipelineStage.STRUCT_NAME_METADATA_CLASS,\n    \"metadataClass\",\n  );\n  // Add MetadataStatistics struct from the metadata stage\n  shaderBuilder.addStructField(\n    structId,\n    MetadataPipelineStage.STRUCT_NAME_METADATA_STATISTICS,\n    \"metadataStatistics\",\n  );\n\n  const functionId =\n    CustomShaderPipelineStage.FUNCTION_ID_INITIALIZE_INPUT_STRUCT_VS;\n  shaderBuilder.addFunction(\n    functionId,\n    CustomShaderPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_VS,\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addFunctionLines(functionId, initializationLines);\n}\n\nfunction addFragmentLinesToShader(shaderBuilder, fragmentLines) {\n  let structId = CustomShaderPipelineStage.STRUCT_ID_ATTRIBUTES_FS;\n  shaderBuilder.addStruct(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES,\n    ShaderDestination.FRAGMENT,\n  );\n\n  const { attributeFields, initializationLines } = fragmentLines;\n  for (let i = 0; i < attributeFields.length; i++) {\n    const [glslType, variableName] = attributeFields[i];\n    shaderBuilder.addStructField(structId, glslType, variableName);\n  }\n\n  structId = CustomShaderPipelineStage.STRUCT_ID_FRAGMENT_INPUT;\n  shaderBuilder.addStruct(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_FRAGMENT_INPUT,\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addStructField(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES,\n    \"attributes\",\n  );\n  // Add FeatureIds struct from the Feature ID stage\n  shaderBuilder.addStructField(\n    structId,\n    FeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS,\n    \"featureIds\",\n  );\n  // Add Metadata struct from the metadata stage\n  shaderBuilder.addStructField(\n    structId,\n    MetadataPipelineStage.STRUCT_NAME_METADATA,\n    \"metadata\",\n  );\n  // Add MetadataClass struct from the metadata stage\n  shaderBuilder.addStructField(\n    structId,\n    MetadataPipelineStage.STRUCT_NAME_METADATA_CLASS,\n    \"metadataClass\",\n  );\n  // Add MetadataStatistics struct from the metadata stage\n  shaderBuilder.addStructField(\n    structId,\n    MetadataPipelineStage.STRUCT_NAME_METADATA_STATISTICS,\n    \"metadataStatistics\",\n  );\n\n  const functionId =\n    CustomShaderPipelineStage.FUNCTION_ID_INITIALIZE_INPUT_STRUCT_FS;\n  shaderBuilder.addFunction(\n    functionId,\n    CustomShaderPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_FS,\n    ShaderDestination.FRAGMENT,\n  );\n\n  shaderBuilder.addFunctionLines(functionId, initializationLines);\n}\n\nconst scratchShaderLines = [];\n\nfunction addLinesToShader(shaderBuilder, customShader, generatedCode) {\n  const { vertexLines, fragmentLines } = generatedCode;\n  const shaderLines = scratchShaderLines;\n\n  if (vertexLines.enabled) {\n    addVertexLinesToShader(shaderBuilder, vertexLines);\n\n    shaderLines.length = 0;\n    shaderLines.push(\n      \"#line 0\",\n      customShader.vertexShaderText,\n      CustomShaderStageVS,\n    );\n\n    shaderBuilder.addVertexLines(shaderLines);\n  }\n\n  if (fragmentLines.enabled) {\n    addFragmentLinesToShader(shaderBuilder, fragmentLines);\n\n    shaderLines.length = 0;\n    shaderLines.push(\n      \"#line 0\",\n      customShader.fragmentShaderText,\n      CustomShaderStageFS,\n    );\n\n    shaderBuilder.addFragmentLines(shaderLines);\n  }\n}\n\nexport default CustomShaderPipelineStage;\n"],"names":["CustomShaderPipelineStage","name","STRUCT_ID_ATTRIBUTES_VS","STRUCT_ID_ATTRIBUTES_FS","STRUCT_NAME_ATTRIBUTES","STRUCT_ID_VERTEX_INPUT","STRUCT_NAME_VERTEX_INPUT","STRUCT_ID_FRAGMENT_INPUT","STRUCT_NAME_FRAGMENT_INPUT","FUNCTION_ID_INITIALIZE_INPUT_STRUCT_VS","FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_VS","FUNCTION_ID_INITIALIZE_INPUT_STRUCT_FS","FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_FS","_oneTimeWarning","process","renderResources","primitive","frameState","shaderBuilder","model","alphaOptions","customShader","lightingModel","translucencyMode","lightingOptions","TRANSLUCENT","pass","OPAQUE","undefined","generatedCode","generateShaderLines","customShaderEnabled","addLinesToShader","shouldComputePositionWC","addDefine","BOTH","vertexShaderText","VERTEX","fragmentShaderText","FRAGMENT","shaderModeDefine","getDefineName","mode","uniforms","uniformName","hasOwnProperty","uniform","addUniform","type","varyings","varyingName","varyingType","addVarying","uniformMap","getAttributesByName","attributes","names","i","length","attributeInfo","getAttributeInfo","variableName","attributeTypeLUT","position","normal","tangent","bitangent","texCoord","color","joints","weights","attributeDefaultValueLUT","inferAttributeDefaults","attributeName","trimmed","replace","glslType","value","attributeField","generateVertexShaderLines","attributesByName","enabled","primitiveAttributes","usedVariablesVertex","attributeSet","addToShader","getPrimitiveAttributesUsedInShader","needsDefault","getAttributesNeedingDefaults","vertexInitialization","attributeFields","initializationLines","push","attributeDefaults","generatePositionBuiltins","usedVariables","usedVariablesFragment","generateFragmentShaderLines","fragmentInitialization","positionBuiltins","concat","builtinAttributes","positionWC","positionEC","shaderAttributeSet","isFragmentShader","attribute","renamed","needDefaults","vertexLines","fragmentLines","attributeSetFS","addVertexLinesToShader","structId","addStruct","addStructField","STRUCT_NAME_FEATURE_IDS","STRUCT_NAME_METADATA","STRUCT_NAME_METADATA_CLASS","STRUCT_NAME_METADATA_STATISTICS","functionId","addFunction","addFunctionLines","addFragmentLinesToShader","scratchShaderLines","shaderLines","addVertexLines","addFragmentLines"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9619, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/DequantizationPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * The dequantization stage generates shader code to dequantize attributes\n * in the vertex shader\n *\n * @namespace DequantizationPipelineStage\n *\n * @private\n */\nconst DequantizationPipelineStage = {\n  name: \"DequantizationPipelineStage\", // Helps with debugging\n\n  FUNCTION_ID_DEQUANTIZATION_STAGE_VS: \"dequantizationStage\",\n  FUNCTION_SIGNATURE_DEQUANTIZATION_STAGE_VS:\n    \"void dequantizationStage(inout ProcessedAttributes attributes)\",\n};\n\n/**\n * Process a primitive with quantized attributes. This stage modifies the\n * following parts of the render resources:\n * <ul>\n *  <li>generates dequantization function and adds it to the shader</li>\n *  <li>adds any uniforms needed for dequantization to the shader and uniform map</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nDequantizationPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const model = renderResources.model;\n  const hasClassification = defined(model.classificationType);\n\n  shaderBuilder.addDefine(\n    \"USE_DEQUANTIZATION\",\n    undefined,\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addFunction(\n    DequantizationPipelineStage.FUNCTION_ID_DEQUANTIZATION_STAGE_VS,\n    DequantizationPipelineStage.FUNCTION_SIGNATURE_DEQUANTIZATION_STAGE_VS,\n    ShaderDestination.VERTEX,\n  );\n\n  const attributes = primitive.attributes;\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    const quantization = attribute.quantization;\n    if (!defined(quantization)) {\n      // Non-quantized attributes were already handled in GeometryPipelineStage\n      continue;\n    }\n\n    // Only the position and texcoord attributes are used for classification models.\n    const isPositionAttribute =\n      attribute.semantic === VertexAttributeSemantic.POSITION;\n    const isTexcoordAttribute =\n      attribute.semantic === VertexAttributeSemantic.TEXCOORD;\n    if (hasClassification && !isPositionAttribute && !isTexcoordAttribute) {\n      continue;\n    }\n\n    const attributeInfo = ModelUtility.getAttributeInfo(attribute);\n    updateDequantizationFunction(shaderBuilder, attributeInfo);\n    addDequantizationUniforms(renderResources, attributeInfo);\n  }\n};\n\nfunction addDequantizationUniforms(renderResources, attributeInfo) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const uniformMap = renderResources.uniformMap;\n  const variableName = attributeInfo.variableName;\n  const quantization = attributeInfo.attribute.quantization;\n\n  if (quantization.octEncoded) {\n    const normalizationRange = `model_normalizationRange_${variableName}`;\n    shaderBuilder.addUniform(\n      \"float\",\n      normalizationRange,\n      ShaderDestination.VERTEX,\n    );\n    uniformMap[normalizationRange] = function () {\n      return quantization.normalizationRange;\n    };\n  } else {\n    const offset = `model_quantizedVolumeOffset_${variableName}`;\n    const stepSize = `model_quantizedVolumeStepSize_${variableName}`;\n    const glslType = attributeInfo.glslType;\n    shaderBuilder.addUniform(glslType, offset, ShaderDestination.VERTEX);\n    shaderBuilder.addUniform(glslType, stepSize, ShaderDestination.VERTEX);\n\n    let quantizedVolumeOffset = quantization.quantizedVolumeOffset;\n    let quantizedVolumeStepSize = quantization.quantizedVolumeStepSize;\n\n    // COLOR_n is promoted to a vec4 in the shader, so the alpha value\n    // defaults to 1. For correctness, the quantization uniforms must be\n    // promoted to vec4s. The alpha values are chosen so the alpha\n    // dequantization is the identity, i.e. 0.0 + 1.0 * color.a\n    if (/^color_\\d+$/.test(variableName)) {\n      quantizedVolumeOffset = promoteToVec4(quantizedVolumeOffset, 0);\n      quantizedVolumeStepSize = promoteToVec4(quantizedVolumeStepSize, 1);\n    }\n\n    uniformMap[offset] = function () {\n      return quantizedVolumeOffset;\n    };\n\n    uniformMap[stepSize] = function () {\n      return quantizedVolumeStepSize;\n    };\n  }\n}\n\nfunction promoteToVec4(value, defaultAlpha) {\n  if (value instanceof Cartesian4) {\n    return value;\n  }\n\n  return new Cartesian4(value.x, value.y, value.z, defaultAlpha);\n}\n\nfunction updateDequantizationFunction(shaderBuilder, attributeInfo) {\n  const variableName = attributeInfo.variableName;\n  const quantization = attributeInfo.attribute.quantization;\n\n  let line;\n  if (quantization.octEncoded) {\n    line = generateOctDecodeLine(variableName, quantization);\n  } else {\n    line = generateDequantizeLine(variableName);\n  }\n\n  shaderBuilder.addFunctionLines(\n    DequantizationPipelineStage.FUNCTION_ID_DEQUANTIZATION_STAGE_VS,\n    [line],\n  );\n}\n\nfunction generateOctDecodeLine(variableName, quantization) {\n  const structField = `attributes.${variableName}`;\n\n  const quantizedAttribute = `a_quantized_${variableName}`;\n  const normalizationRange = `model_normalizationRange_${variableName}`;\n\n  // Draco stores things as .zxy instead of xyz, so be explicit about the\n  // swizzle to avoid confusion\n  const swizzle = quantization.octEncodedZXY ? \".zxy\" : \".xyz\";\n\n  // This generates lines such as:\n  // attributes.normal = czm_octDecode(a_quantized_normal, model_normalizationRange_normal).zxy;\n  return `${structField} = czm_octDecode(${quantizedAttribute}, ${normalizationRange})${swizzle};`;\n}\n\nfunction generateDequantizeLine(variableName) {\n  const structField = `attributes.${variableName}`;\n  const quantizedAttribute = `a_quantized_${variableName}`;\n  const offset = `model_quantizedVolumeOffset_${variableName}`;\n  const stepSize = `model_quantizedVolumeStepSize_${variableName}`;\n\n  // This generates lines such as:\n  // attributes.texCoord_0 = model_quantizedVolumeOffset_texCoord_0 + a_quantized_texCoord_0 * model_quantizedVolumeStepSize;\n  return `${structField} = ${offset} + ${quantizedAttribute} * ${stepSize};`;\n}\n\nexport default DequantizationPipelineStage;\n"],"names":["DequantizationPipelineStage","name","FUNCTION_ID_DEQUANTIZATION_STAGE_VS","FUNCTION_SIGNATURE_DEQUANTIZATION_STAGE_VS","process","renderResources","primitive","frameState","shaderBuilder","model","hasClassification","classificationType","addDefine","undefined","VERTEX","addFunction","attributes","i","length","attribute","quantization","isPositionAttribute","semantic","POSITION","isTexcoordAttribute","TEXCOORD","attributeInfo","getAttributeInfo","updateDequantizationFunction","addDequantizationUniforms","uniformMap","variableName","octEncoded","normalizationRange","addUniform","offset","stepSize","glslType","quantizedVolumeOffset","quantizedVolumeStepSize","test","promoteToVec4","value","defaultAlpha","x","y","z","line","generateOctDecodeLine","generateDequantizeLine","addFunctionLines","structField","quantizedAttribute","swizzle","octEncodedZXY"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9761, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/EdgeDetectionPipelineStage.js"],"sourcesContent":["import EdgeDetectionStageFS from \"../../Shaders/Model/EdgeDetectionStageFS.js\";\n\n/**\n * Performs the screen-space edge visibility / composition pass. This stage does not\n * build edge geometry itself; that work is handled earlier by {@link EdgeVisibilityPipelineStage},\n * which extracts unique model edges and writes them during a dedicated edge render pass\n * into edge ID / color targets. The fragment logic added here then:\n * <ul>\n *  <li>Samples the edge render targets (edge color + per-edge feature ID)</li>\n *  <li>Compares per-edge feature IDs with underlying surface feature IDs to suppress\n *      edges that belong to filtered or hidden features</li>\n *  <li>Performs depth-based tests (e.g., against globe or scene depth) to discard\n *      occluded edges</li>\n * </ul>\n * In summary: EdgeVisibilityPipelineStage = generate & encode edges; this stage = decide which of\n * those encoded edges are actually visible in the final frame and composite them.\n *\n * @namespace EdgeDetectionPipelineStage\n * @private\n */\nconst EdgeDetectionPipelineStage = {\n  name: \"EdgeDetectionPipelineStage\",\n};\n\n/**\n * Process a primitive by injecting the fragment shader logic that consumes the\n * intermediate edge buffers produced by the edge geometry pass. It adds code to:\n * <ul>\n *  <li>Read edge color / edge ID MRT outputs</li>\n *  <li>Apply depth & feature ID based rejection</li>\n *  <li>Emit final edge color for composition</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @private\n */\nEdgeDetectionPipelineStage.process = function (renderResources) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addFragmentLines([EdgeDetectionStageFS]);\n};\n\nexport default EdgeDetectionPipelineStage;\n"],"names":["EdgeDetectionPipelineStage","name","process","renderResources","shaderBuilder","addFragmentLines"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;;;;;;;;;CAiBC,GACD,MAAMA,6BAA6B;IACjCC,MAAM;AACR;AAEA;;;;;;;;;;CAUC,GACDD,2BAA2BE,OAAO,GAAG,SAAUC,eAAe;IAC5D,MAAMC,gBAAgBD,gBAAgBC,aAAa;IAEnDA,cAAcC,gBAAgB,CAAC;QAAC,sMAAoB;KAAC;AACvD;uCAEeL","ignoreList":[0]}},
    {"offset": {"line": 9808, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelReader.js"],"sourcesContent":["import Check from \"../../Core/Check.js\";\nimport defined from \"../../Core/defined.js\";\nimport Cartesian2 from \"../../Core/Cartesian2.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport IndexDatatype from \"../../Core/IndexDatatype.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\n\nimport AttributeType from \"../AttributeType.js\";\n\n/**\n * A class for reading the data from a <code>ModelComponents.Attribute</code>.\n *\n * NOTE: Much of the functionality here already exists, scattered in many places.\n * In most cases, the functionality is tailored for \"one case\" (like only handling\n * positions, or only normals, or not considering quantization, or not handling\n * interleaved buffers, ...). In many cases, the functionality is tailored for an\n * 'accessor' (and often, the functions also expect the 'gltf' to be given).\n * Most of what is done here (and in the existing functions) is pretty low-level\n * and generic, though: The functions could often be fed with some (count, type,\n * componentType), and there could be convenience functions that EITHER take these\n * values from an 'accessor' OR from an 'attribute'. The tl;dr: Large parts of\n * this could be \"nicer\", or \"more generic\", and \"better\" along all dimensions\n * of this term. Just give me time...\n *\n * NOTE: The fact that all this has to operate on TypedArray is unfortunate.\n * Most of the subsequent processing could operate on some abstraction of\n * that. The fact that that TypedArrays can be read/written as \"bulk\", and\n * then offer access that is \"as efficient as it can be\" could be a\n * justification, as part of the performance-genericity trade-off\n *\n * NOTE: All this does not properly handle MATn types. There should be SOME\n * abstraction for element- and component-wise access of the data. See\n * https://github.com/javagl/JglTF/blob/84ce6d019fec3b75b6af1649bbe834005b2c620f/jgltf-model/src/main/java/de/javagl/jgltf/model/AbstractAccessorData.java#L149\n *\n * @private\n */\nclass ModelReader {\n  /**\n   * Reads the data of the given atttribute into a typed array.\n   *\n   * This will read the data into a compact, flat array with the data\n   * type corresponding to the data type of the attribute.\n   *\n   * If the attribute is contained in an interleaved buffer, marked as\n   * 'normalized', quantized, or oct-encoded, then it will be deinterleaved,\n   * normalization will be applied, it will be dequantized and oct-decoded\n   * as necessary.\n   *\n   * The result will be THE actual attribute data.\n   *\n   * @param {ModelComponents.Attribute} attribute The attribute\n   * @returns {TypedArray} The attribute data\n   */\n  static readAttributeAsTypedArray(attribute) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"attribute\", attribute);\n    //>>includeEnd('debug');\n\n    // Obtain a compact (non-interleaved) typed array that contains\n    // the components.\n    const compactTypedArray =\n      ModelReader.readAttributeAsRawCompactTypedArray(attribute);\n\n    // If the attribute is not normalized and the data is not quantized\n    // and not normalized, then this can be returned directly\n    const normalized = attribute.normalized;\n    const quantization = attribute.quantization;\n    if (!defined(quantization) && !normalized) {\n      return compactTypedArray;\n    }\n\n    const elementType = attribute.type;\n    const elementCount = attribute.count;\n\n    // If the attribute is normalized, normalize the data from\n    // the typed array\n    let normalizedTypedArray = compactTypedArray;\n    if (normalized) {\n      // Note that although this is called \"dequantize\", it does\n      // not really \"dequantize\" based on the quantization. It only\n      // performs the conversion from the (normalized) integer\n      // component types into floating point.\n      normalizedTypedArray = AttributeCompression.dequantize(\n        compactTypedArray,\n        attribute.componentDatatype,\n        elementType,\n        elementCount,\n      );\n    }\n\n    if (!defined(quantization)) {\n      return normalizedTypedArray;\n    }\n    // Now, this one actually DOES dequantize...\n    const dequantizedTypedArray = ModelReader.dequantize(\n      normalizedTypedArray,\n      elementCount,\n      elementType,\n      quantization,\n    );\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Read the data of the given attribute into a compact typed array.\n   *\n   * If the attribute is stored as interleaved data, then the result\n   * will be the deinterleaved data. If the data is quantized or\n   * normalized, then the resulting data will be the \"raw\" data,\n   * without applying normalization or dequantization.\n   *\n   * @param {ModelComponents.Attribute} attribute The attribute\n   * @returns {TypedArray} The raw attribute data\n   */\n  static readAttributeAsRawCompactTypedArray(attribute) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"attribute\", attribute);\n    //>>includeEnd('debug');\n\n    const elementType = attribute.type;\n    const elementCount = attribute.count;\n\n    const componentsPerElement =\n      AttributeType.getNumberOfComponents(elementType);\n    const totalComponentCount = elementCount * componentsPerElement;\n\n    // If the data is quantized, use the quantized component type\n    let componentType = attribute.componentDatatype;\n    const quantization = attribute.quantization;\n    if (defined(quantization)) {\n      componentType = quantization.componentDatatype;\n    }\n    const buffer = attribute.buffer;\n\n    // If the byte stride is the default (i.e. the total element size),\n    // then just fetch the whole buffer data into a typed array of the\n    // desired target type, and return it\n    const byteOffset = attribute.byteOffset;\n    const byteStride = attribute.byteStride;\n    const bytesPerComponent = ComponentDatatype.getSizeInBytes(componentType);\n    const defaultByteStride = componentsPerElement * bytesPerComponent;\n    if (!defined(byteStride) || byteStride === defaultByteStride) {\n      const typedArray = ComponentDatatype.createTypedArray(\n        componentType,\n        totalComponentCount,\n      );\n      buffer.getBufferData(typedArray, byteOffset);\n      return typedArray;\n    }\n\n    // Fetch the whole buffer in its raw form, to pick out the\n    // interleaved values.\n    // Note: When ALL attributes have to be fetched from an\n    // interleaved buffer, then this getBufferData call will\n    // be performed multiple times. It would be preferable to\n    // have ONE \"TypedArray[] getThemFrom(buffer)\" call that\n    // returns all of the (interleaved) attributes at once,\n    // but this requires abstractions that we don't have.\n    const fullTypedArray = new Uint8Array(buffer.sizeInBytes);\n    buffer.getBufferData(fullTypedArray);\n\n    // Read the components of each element, and write them into\n    // a typed array in a compact form\n    const compactTypedArray = ComponentDatatype.createTypedArray(\n      componentType,\n      totalComponentCount,\n    );\n    const elementByteStride = byteStride ?? defaultByteStride;\n    const dataView = new DataView(\n      fullTypedArray.buffer,\n      fullTypedArray.byteOffset,\n      fullTypedArray.byteLength,\n    );\n    const components = new Array(componentsPerElement);\n    const componentsReader = ModelReader.createComponentsReader(componentType);\n    for (let i = 0; i < elementCount; ++i) {\n      const elementByteOffset = byteOffset + i * elementByteStride;\n      componentsReader(\n        dataView,\n        elementByteOffset,\n        componentsPerElement,\n        components,\n      );\n      for (let j = 0; j < componentsPerElement; ++j) {\n        compactTypedArray[i * componentsPerElement + j] = components[j];\n      }\n    }\n    return compactTypedArray;\n  }\n\n  /**\n   * Dequantize the data from the given input array, based on the given\n   * quantization information, and return the result.\n   *\n   * This assumes that normalization has already been applied. This means that\n   * when the <code>quantization.normalized</code> flag is <code>true</code>,\n   * then the input is assumed to contain floating point values in the range\n   * [-1, 1].\n   *\n   * @param {TypedArray} quantizedTypedArray The quantized typed array\n   * @param {number} elementCount The number of elements\n   * @param {AttributeType} elementType The element type\n   * @param {ModelComponents.Quantization} quantization The quantization\n   * @returns {TypedArray} The result\n   * @throws DeveloperError When the element type is not SCALAR, VEC2,\n   * VEC3, or VEC4\n   */\n  static dequantize(\n    quantizedTypedArray,\n    elementCount,\n    elementType,\n    quantization,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.defined(\"elementType\", elementType);\n    Check.defined(\"quantization\", quantization);\n    //>>includeEnd('debug');\n\n    if (quantization.octEncoded) {\n      const dequantizedTypedArray = ModelReader.octDecode(\n        quantizedTypedArray,\n        elementCount,\n        quantization.normalizationRange,\n        undefined,\n      );\n      if (quantization.octEncodedZXY) {\n        ModelReader.convertZxyToXyz(\n          dequantizedTypedArray,\n          dequantizedTypedArray,\n        );\n      }\n      return dequantizedTypedArray;\n    }\n\n    // These could be generalized, if the offset/stepSize were not\n    // CartesianX objects, but arrays...\n    const stepSize = quantization.quantizedVolumeStepSize;\n    const offset = quantization.quantizedVolumeOffset;\n    if (elementType === AttributeType.SCALAR) {\n      return ModelReader.dequantize1D(\n        quantizedTypedArray,\n        elementCount,\n        stepSize,\n        offset,\n        undefined,\n      );\n    }\n    if (elementType === AttributeType.VEC2) {\n      return ModelReader.dequantize2D(\n        quantizedTypedArray,\n        elementCount,\n        stepSize,\n        offset,\n        undefined,\n      );\n    }\n    if (elementType === AttributeType.VEC3) {\n      return ModelReader.dequantize3D(\n        quantizedTypedArray,\n        elementCount,\n        stepSize,\n        offset,\n        undefined,\n      );\n    }\n    if (elementType === AttributeType.VEC4) {\n      return ModelReader.dequantize4D(\n        quantizedTypedArray,\n        elementCount,\n        stepSize,\n        offset,\n        undefined,\n      );\n    }\n    throw new DeveloperError(\n      `Element type for dequantization must be SCALAR, VEC2, VEC3, or VEC4, but is ${elementType}`,\n    );\n  }\n\n  /**\n   * Decode oct-encoded normals from the given input, and write the\n   * result into the given output, allocating and returning a new\n   * array if the result was undefined.\n   *\n   * This will apply the <code>AttributeCompression.octDecodeInRange</code>\n   * function to each three components of the input.\n   *\n   * @param {TypedArray} quantizedTypedArray The input\n   * @param {number} elementCount The number of elements\n   * @param {number} normalizationRange The normalization range\n   * @param {TypedArray} [dequantizedTypedArray] The result\n   * @returns {TypedArray} The result\n   */\n  static octDecode(\n    quantizedTypedArray,\n    elementCount,\n    normalizationRange,\n    dequantizedTypedArray,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.typeOf.number.greaterThan(\n      \"normalizationRange\",\n      normalizationRange,\n      0,\n    );\n    //>>includeEnd('debug');\n\n    if (!defined(dequantizedTypedArray)) {\n      dequantizedTypedArray = new Float32Array(quantizedTypedArray.length);\n    }\n    const c = new Cartesian3();\n    for (let i = 0; i < elementCount; i++) {\n      Cartesian3.unpack(quantizedTypedArray, i * 3, c);\n      AttributeCompression.octDecodeInRange(c, normalizationRange, c);\n      Cartesian3.pack(dequantizedTypedArray, c, i * 3);\n    }\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Swizzle all three consecutive elements in the given input array\n   * from (z, x, y) to (x, y, z), and write the result into the\n   * given output array, creating a new array if the given output\n   * array was undefined.\n   *\n   * @param {TypedArray} input The input\n   * @param {number} elementCount The number of elements\n   * @param {TypedArray} [output] The result\n   * @returns {TypedArray} The result\n   */\n  static convertZxyToXyz(input, elementCount, output) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"input\", input);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    //>>includeEnd('debug');\n\n    if (!defined(output)) {\n      output = new Float32Array(input.length);\n    }\n    let offset = 0;\n    for (let i = 0; i < elementCount; i++, offset += 3) {\n      const z = input[offset + 0];\n      const x = input[offset + 1];\n      const y = input[offset + 2];\n      output[offset + 0] = x;\n      output[offset + 1] = y;\n      output[offset + 2] = z;\n    }\n    return output;\n  }\n\n  /**\n   * Dequantize the given quantized array, based on the given quantization\n   * information, and write the result into the given output array, creating\n   * the output array if it was undefined.\n   *\n   * This will simply fill the output array with\n   * <code>output[i] = input[i] * stepSize + offset</code>\n   *\n   * @param {TypedArray} quantizedTypedArray The quantized array\n   * @param {number} elementCount The number of elements\n   * @param {number} stepSize The quantization step size\n   * @param {number} offset The quantization offset\n   * @param {TypedArray} [dequantizedTypedArray] The result\n   * @returns {TypedArray} The result\n   */\n  static dequantize1D(\n    quantizedTypedArray,\n    elementCount,\n    stepSize,\n    offset,\n    dequantizedTypedArray,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.defined(\"stepSize\", stepSize);\n    Check.defined(\"offset\", offset);\n    //>>includeEnd('debug');\n\n    if (!defined(dequantizedTypedArray)) {\n      dequantizedTypedArray = new Float32Array(quantizedTypedArray.length);\n    }\n    for (let i = 0; i < elementCount; i++) {\n      const q = quantizedTypedArray[i];\n      const d = q * stepSize + offset;\n      dequantizedTypedArray[i] = d;\n    }\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Dequantize the given quantized array, based on the given quantization\n   * information, and write the result into the given output array, creating\n   * the output array if it was undefined.\n   *\n   * This will simply fill the output array with\n   * <code>output[i] = input[i] * stepSize + offset</code>\n   * when interpreting the input and output as arrays of Cartesian2.\n   *\n   * @param {TypedArray} quantizedTypedArray The quantized array\n   * @param {number} elementCount The number of elements\n   * @param {Cartesian2} stepSize The quantization step size\n   * @param {Cartesian2} offset The quantization offset\n   * @param {TypedArray} [dequantizedTypedArray] The result\n   * @returns {TypedArray} The result\n   */\n  static dequantize2D(\n    quantizedTypedArray,\n    elementCount,\n    stepSize,\n    offset,\n    dequantizedTypedArray,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.defined(\"stepSize\", stepSize);\n    Check.defined(\"offset\", offset);\n    //>>includeEnd('debug');\n\n    if (!defined(dequantizedTypedArray)) {\n      dequantizedTypedArray = new Float32Array(quantizedTypedArray.length);\n    }\n    const c = new Cartesian2();\n    for (let i = 0; i < elementCount; i++) {\n      Cartesian2.unpack(quantizedTypedArray, i * 2, c);\n      Cartesian2.multiplyComponents(c, stepSize, c);\n      Cartesian2.add(c, offset, c);\n      Cartesian2.pack(c, dequantizedTypedArray, i * 2);\n    }\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Dequantize the given quantized array, based on the given quantization\n   * information, and write the result into the given output array, creating\n   * the output array if it was undefined.\n   *\n   * This will simply fill the output array with\n   * <code>output[i] = input[i] * stepSize + offset</code>\n   * when interpreting the input and output as arrays of Cartesian3.\n   *\n   * @param {TypedArray} quantizedTypedArray The quantized array\n   * @param {number} elementCount The number of elements\n   * @param {Cartesian3} stepSize The quantization step size\n   * @param {Cartesian3} offset The quantization offset\n   * @param {TypedArray} [dequantizedTypedArray] The result\n   * @returns {TypedArray} The result\n   */\n  static dequantize3D(\n    quantizedTypedArray,\n    elementCount,\n    stepSize,\n    offset,\n    dequantizedTypedArray,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.defined(\"stepSize\", stepSize);\n    Check.defined(\"offset\", offset);\n    //>>includeEnd('debug');\n\n    if (!defined(dequantizedTypedArray)) {\n      dequantizedTypedArray = new Float32Array(quantizedTypedArray.length);\n    }\n    const c = new Cartesian3();\n    for (let i = 0; i < elementCount; i++) {\n      Cartesian3.unpack(quantizedTypedArray, i * 3, c);\n      Cartesian3.multiplyComponents(c, stepSize, c);\n      Cartesian3.add(c, offset, c);\n      Cartesian3.pack(c, dequantizedTypedArray, i * 3);\n    }\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Dequantize the given quantized array, based on the given quantization\n   * information, and write the result into the given output array, creating\n   * the output array if it was undefined.\n   *\n   * This will simply fill the output array with\n   * <code>output[i] = input[i] * stepSize + offset</code>\n   * when interpreting the input and output as arrays of Cartesian4.\n   *\n   * @param {TypedArray} quantizedTypedArray The quantized array\n   * @param {number} elementCount The number of elements\n   * @param {Cartesian4} stepSize The quantization step size\n   * @param {Cartesian4} offset The quantization offset\n   * @param {TypedArray} [dequantizedTypedArray] The result\n   * @returns {TypedArray} The result\n   */\n  static dequantize4D(\n    quantizedTypedArray,\n    elementCount,\n    stepSize,\n    offset,\n    dequantizedTypedArray,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.defined(\"stepSize\", stepSize);\n    Check.defined(\"offset\", offset);\n    //>>includeEnd('debug');\n\n    if (!defined(dequantizedTypedArray)) {\n      dequantizedTypedArray = new Float32Array(quantizedTypedArray.length);\n    }\n    const c = new Cartesian4();\n    for (let i = 0; i < elementCount; i++) {\n      Cartesian4.unpack(quantizedTypedArray, i * 4, c);\n      Cartesian4.multiplyComponents(c, stepSize, c);\n      Cartesian4.add(c, offset, c);\n      Cartesian4.pack(c, dequantizedTypedArray, i * 4);\n    }\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Reads and returns a value with the given type\n   * at the given byte offset from the data view, in little-endian\n   * order\n   * @callback ComponentsReaderCallback\n   * @param {DataView} dataView Typed data view into a binary buffer\n   * @param {number} byteOffset The offset, in bytes, from the start of the view to read the data from\n   * @param {number} numberOfComponents The number of components to read\n   * @param {number[]} result The array in which to read the result\n   */\n\n  /**\n   * Creates a function that reads the specified number of components with\n   * the given type from the given data view, in little-endian\n   * order, and writes them into a given result array.\n   *\n   * @param {ComponentDatatype} componentType The component type\n   * @returns {ComponentsReaderCallback} The reader\n   */\n  static createComponentsReader(componentType) {\n    const componentReader = ModelReader.createComponentReader(componentType);\n    const sizeInBytes = ComponentDatatype.getSizeInBytes(componentType);\n    return function (dataView, byteOffset, numberOfComponents, result) {\n      let offset = byteOffset;\n      for (let i = 0; i < numberOfComponents; ++i) {\n        result[i] = componentReader(dataView, offset);\n        offset += sizeInBytes;\n      }\n    };\n  }\n\n  /**\n   * Reads and returns a value with the given type\n   * at the given byte offset from the data view, in little-endian\n   * order\n   * @callback ComponentReaderCallback\n   * @param {DataView} dataView Typed data view into a binary buffer\n   * @param {number} byteOffset The offset, in bytes, from the start of the view to read the data from\n   * @returns {number|BigInt} The value read from the dataView\n   */\n\n  /**\n   * Creates a function that reads and returns a value with the given type\n   * at the given byte offset from the data view, in little-endian\n   * order\n   * @param {ComponentDatatype} componentType The component type\n   * @returns {ComponentReaderCallback} The reader\n   */\n  static createComponentReader(componentType) {\n    switch (componentType) {\n      case ComponentDatatype.BYTE:\n        return function (dataView, byteOffset) {\n          return dataView.getInt8(byteOffset);\n        };\n      case ComponentDatatype.UNSIGNED_BYTE:\n        return function (dataView, byteOffset) {\n          return dataView.getUint8(byteOffset);\n        };\n      case ComponentDatatype.SHORT:\n        return function (dataView, byteOffset) {\n          return dataView.getInt16(byteOffset, true);\n        };\n      case ComponentDatatype.UNSIGNED_SHORT:\n        return function (dataView, byteOffset) {\n          return dataView.getUint16(byteOffset, true);\n        };\n      case ComponentDatatype.INT:\n        return function (dataView, byteOffset) {\n          return dataView.getInt32(byteOffset, true);\n        };\n      case ComponentDatatype.UNSIGNED_INT:\n        return function (dataView, byteOffset) {\n          return dataView.getUint32(byteOffset, true);\n        };\n      case ComponentDatatype.FLOAT:\n        return function (dataView, byteOffset) {\n          return dataView.getFloat32(byteOffset, true);\n        };\n      case ComponentDatatype.DOUBLE:\n        return function (dataView, byteOffset) {\n          return dataView.getFloat64(byteOffset, true);\n        };\n    }\n    throw new DeveloperError(\n      `The componentType must be a valid ComponentDatatype, but is ${componentType}`,\n    );\n  }\n\n  /**\n   * Transform the elements of the given array with the given 4x4 matrix,\n   * interpreting each 3 consecutive elements as a 3D point, and write\n   * the result into the given result array, creating the result array\n   * if it was undefined.\n   *\n   * @param {TypedArray} input The input array\n   * @param {Matrix4} matrix The matrix\n   * @param {TypedArray} [result] The result\n   * @returns {TypedArray} The result\n   */\n  static transform3D(input, matrix, result) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"input\", input);\n    Check.defined(\"matrix\", matrix);\n    //>>includeEnd('debug');\n\n    if (!defined(result)) {\n      result = new Float32Array(input.length);\n    }\n    const c = new Cartesian3();\n    const elementCount = input.length / 3;\n    for (let i = 0; i < elementCount; i++) {\n      Cartesian3.unpack(input, i * 3, c);\n      Matrix4.multiplyByPoint(matrix, c, c);\n      Cartesian3.pack(c, result, i * 3);\n    }\n    return result;\n  }\n\n  /**\n   * Read the indices values from the given primitive indices, and\n   * return them as a typed array.\n   *\n   * If the given object already has a <code>typedArray/code> property, then it\n   * is assumed that this contains the proper indices, and they are returned.\n   *\n   * Otherwise, this reads the data from the <code>buffer</code> of the given\n   * primitive indices object, into a typed array with a type that matches the\n   * <code>indexDataType</code>, and returns it.\n   *\n   * Clients may not modify the returned typed array.\n   *\n   * @param {ModelComponents.Indices} primitiveIndices The primitive indices\n   * @returns {TypedArray} The indices values\n   * @throws {DeveloperError} If the <code>indexDataType</code> of the given\n   * object is neither <code>UNSIGNED_BYTE</code>, nor <code>UNSIGNED_SHORT</code>,\n   * nor <code>UNSIGNED_INT</code>\n   */\n  static readIndicesAsTypedArray(primitiveIndices) {\n    const existingIndices = primitiveIndices.typedArray;\n    if (defined(existingIndices)) {\n      return existingIndices;\n    }\n    const indicesBuffer = primitiveIndices.buffer;\n    const indicesCount = primitiveIndices.count;\n    const indexDatatype = primitiveIndices.indexDatatype;\n    const indices = ModelReader.createIndexTypedArray(\n      indexDatatype,\n      indicesCount,\n    );\n    indicesBuffer.getBufferData(indices);\n    return indices;\n  }\n\n  /**\n   * Read the indices values from the given primitive indices object, and return\n   * them as a typed array of triangle vertex indices.\n   *\n   * If the given primitive type is <code>TRIANGLES</code>, then the indices\n   * values will be read from the given object, and returned.\n   *\n   * If the primitive type is <code>TRIANGLE_STRIP</code> or <code>TRIANGLE_FAN</code>,\n   * then the original indices values, will be read, converted into triangle indices\n   * (i.e. their equivalent <code>TRIANGLES</code> representation), and the result\n   * will be returned.\n   *\n   * The type of the returned array will match the <code>indexDataType</code>\n   * of the given object.\n   *\n   * Clients may not modify the returned typed array.\n   *\n   * @param {ModelComponents.Indices} primitiveIndices The primitive indices\n   * @returns {TypedArray} The indices, converted to triangle indices if necessary\n   * @throws {DeveloperError} If the <code>indexDataType</code> of the given\n   * object is neither <code>UNSIGNED_BYTE</code>, nor <code>UNSIGNED_SHORT</code>,\n   * nor <code>UNSIGNED_INT</code>, or the given <code>primitiveType</code>\n   * is neither <code>TRIANGLES</code>, nor <code>TRIANGLE_STRIP</code>,\n   * nor <code>TRIANGLE_FAN</code>\n   */\n  static readIndicesAsTriangleIndicesTypedArray(\n    primitiveIndices,\n    primitiveType,\n  ) {\n    const originalIndices =\n      ModelReader.readIndicesAsTypedArray(primitiveIndices);\n    if (primitiveType === PrimitiveType.TRIANGLES) {\n      return originalIndices;\n    }\n    if (primitiveType === PrimitiveType.TRIANGLE_STRIP) {\n      const triangleIndices =\n        ModelReader.convertTriangleStripToTriangleIndices(originalIndices);\n      return triangleIndices;\n    }\n    if (primitiveType === PrimitiveType.TRIANGLE_FAN) {\n      const triangleIndices =\n        ModelReader.convertTriangleFanToTriangleIndices(originalIndices);\n      return triangleIndices;\n    }\n    throw new DeveloperError(\n      `The primitiveType must be TRIANGLES (${PrimitiveType.TRIANGLES}, ` +\n        `TRIANGLE_STRIP (${PrimitiveType.TRIANGLE_STRIP}, or ` +\n        `TRIANGLE_FAN (${PrimitiveType.TRIANGLE_FAN}, but is ${primitiveType}`,\n    );\n  }\n\n  /**\n   * Converts the given indices from a <code>TRIANGLE_STRIP</code> representation\n   * into a <code>TRIANGLES</code> representation, and returns the result.\n   *\n   * The type of the result will be the same as the type of the input array.\n   *\n   * @param {TypedArray} indices The input indices\n   * @returns {TypedArray} The resulting triangle indices\n   */\n  static convertTriangleStripToTriangleIndices(indices) {\n    const triangleIndices = indices.constructor((indices.length - 2) * 3);\n    for (let i = 0; i < indices.length - 2; i++) {\n      if (i % 2 === 1) {\n        triangleIndices[i * 3 + 0] = indices[i + 0];\n        triangleIndices[i * 3 + 1] = indices[i + 2];\n        triangleIndices[i * 3 + 2] = indices[i + 1];\n      } else {\n        triangleIndices[i * 3 + 0] = indices[i + 0];\n        triangleIndices[i * 3 + 1] = indices[i + 1];\n        triangleIndices[i * 3 + 2] = indices[i + 2];\n      }\n    }\n    return triangleIndices;\n  }\n\n  /**\n   * Converts the given indices from a <code>TRIANGLE_FAN</code> representation\n   * into a <code>TRIANGLES</code> representation, and returns the result.\n   *\n   * The type of the result will be the same as the type of the input array.\n   *\n   * @param {TypedArray} indices The input indices\n   * @returns {TypedArray} The resulting triangle indices\n   */\n  static convertTriangleFanToTriangleIndices(indices) {\n    const triangleIndices = indices.constructor((indices.length - 2) * 3);\n    for (let i = 0; i < indices.length - 2; i++) {\n      triangleIndices[i * 3 + 0] = indices[i + 0];\n      triangleIndices[i * 3 + 1] = indices[i + 1];\n      triangleIndices[i * 3 + 2] = indices[i + 2];\n    }\n    return triangleIndices;\n  }\n\n  /**\n   * Create a typed array with a type that matches the given index data type,\n   * and the given size.\n   *\n   * @param {number} indexDatatype The <code>IndexDataType</code>\n   * @param {number} size The size of the array that will be created\n   * @returns {TypedArray} The typed array\n   * @throws {DeveloperError} If the <code>indexDataType</code> is neither\n   * <code>UNSIGNED_BYTE</code>, nor <code>UNSIGNED_SHORT</code>,\n   * nor <code>UNSIGNED_INT</code>, or the size is negative.\n   */\n  static createIndexTypedArray(indexDatatype, size) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.typeOf.number.greaterThanOrEquals(\"size\", size, 0);\n    //>>includeEnd('debug');\n\n    switch (indexDatatype) {\n      case IndexDatatype.UNSIGNED_BYTE:\n        return new Uint8Array(size);\n      case IndexDatatype.UNSIGNED_SHORT:\n        return new Uint16Array(size);\n      case IndexDatatype.UNSIGNED_INT:\n        return new Uint32Array(size);\n    }\n    throw new DeveloperError(\n      `The indexDatatype must be UNSIGNED_BYTE (${IndexDatatype.UNSIGNED_BYTE}, ` +\n        `UNSIGNED_SHORT (${IndexDatatype.UNSIGNED_SHORT}, or ` +\n        `UNSIGNED_INT (${IndexDatatype.UNSIGNED_INT}, but is ${indexDatatype}`,\n    );\n  }\n}\n\nexport default ModelReader;\n"],"names":["ModelReader","readAttributeAsTypedArray","attribute","defined","compactTypedArray","readAttributeAsRawCompactTypedArray","normalized","quantization","elementType","type","elementCount","count","normalizedTypedArray","dequantize","componentDatatype","dequantizedTypedArray","componentsPerElement","getNumberOfComponents","totalComponentCount","componentType","buffer","byteOffset","byteStride","bytesPerComponent","getSizeInBytes","defaultByteStride","typedArray","createTypedArray","getBufferData","fullTypedArray","Uint8Array","sizeInBytes","elementByteStride","dataView","DataView","byteLength","components","Array","componentsReader","createComponentsReader","i","elementByteOffset","j","quantizedTypedArray","typeOf","number","greaterThanOrEquals","octEncoded","octDecode","normalizationRange","undefined","octEncodedZXY","convertZxyToXyz","stepSize","quantizedVolumeStepSize","offset","quantizedVolumeOffset","SCALAR","dequantize1D","VEC2","dequantize2D","VEC3","dequantize3D","VEC4","dequantize4D","greaterThan","Float32Array","length","c","unpack","octDecodeInRange","pack","input","output","z","x","y","q","d","multiplyComponents","add","componentReader","createComponentReader","numberOfComponents","result","BYTE","getInt8","UNSIGNED_BYTE","getUint8","SHORT","getInt16","UNSIGNED_SHORT","getUint16","INT","getInt32","UNSIGNED_INT","getUint32","FLOAT","getFloat32","DOUBLE","getFloat64","transform3D","matrix","multiplyByPoint","readIndicesAsTypedArray","primitiveIndices","existingIndices","indicesBuffer","indicesCount","indexDatatype","indices","createIndexTypedArray","readIndicesAsTriangleIndicesTypedArray","primitiveType","originalIndices","TRIANGLES","TRIANGLE_STRIP","triangleIndices","convertTriangleStripToTriangleIndices","TRIANGLE_FAN","convertTriangleFanToTriangleIndices","size","Uint16Array","Uint32Array"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;CA0BC,GACD,MAAMA;IACJ;;;;;;;;;;;;;;;GAeC,GACD,OAAOC,0BAA0BC,SAAS,EAAE;QAC1C,yCAAyC;QACzC,2KAAK,CAACC,OAAO,CAAC,aAAaD;QAC3B,wBAAwB;QAExB,+DAA+D;QAC/D,kBAAkB;QAClB,MAAME,oBACJJ,YAAYK,mCAAmC,CAACH;QAElD,mEAAmE;QACnE,yDAAyD;QACzD,MAAMI,aAAaJ,UAAUI,UAAU;QACvC,MAAMC,eAAeL,UAAUK,YAAY;QAC3C,IAAI,CAAC,IAAA,6KAAO,EAACA,iBAAiB,CAACD,YAAY;YACzC,OAAOF;QACT;QAEA,MAAMI,cAAcN,UAAUO,IAAI;QAClC,MAAMC,eAAeR,UAAUS,KAAK;QAEpC,0DAA0D;QAC1D,kBAAkB;QAClB,IAAIC,uBAAuBR;QAC3B,IAAIE,YAAY;YACd,0DAA0D;YAC1D,6DAA6D;YAC7D,wDAAwD;YACxD,uCAAuC;YACvCM,uBAAuB,0LAAoB,CAACC,UAAU,CACpDT,mBACAF,UAAUY,iBAAiB,EAC3BN,aACAE;QAEJ;QAEA,IAAI,CAAC,IAAA,6KAAO,EAACH,eAAe;YAC1B,OAAOK;QACT;QACA,4CAA4C;QAC5C,MAAMG,wBAAwBf,YAAYa,UAAU,CAClDD,sBACAF,cACAF,aACAD;QAEF,OAAOQ;IACT;IAEA;;;;;;;;;;GAUC,GACD,OAAOV,oCAAoCH,SAAS,EAAE;QACpD,yCAAyC;QACzC,2KAAK,CAACC,OAAO,CAAC,aAAaD;QAC3B,wBAAwB;QAExB,MAAMM,cAAcN,UAAUO,IAAI;QAClC,MAAMC,eAAeR,UAAUS,KAAK;QAEpC,MAAMK,uBACJ,oLAAa,CAACC,qBAAqB,CAACT;QACtC,MAAMU,sBAAsBR,eAAeM;QAE3C,6DAA6D;QAC7D,IAAIG,gBAAgBjB,UAAUY,iBAAiB;QAC/C,MAAMP,eAAeL,UAAUK,YAAY;QAC3C,IAAI,IAAA,6KAAO,EAACA,eAAe;YACzBY,gBAAgBZ,aAAaO,iBAAiB;QAChD;QACA,MAAMM,SAASlB,UAAUkB,MAAM;QAE/B,mEAAmE;QACnE,kEAAkE;QAClE,qCAAqC;QACrC,MAAMC,aAAanB,UAAUmB,UAAU;QACvC,MAAMC,aAAapB,UAAUoB,UAAU;QACvC,MAAMC,oBAAoB,uLAAiB,CAACC,cAAc,CAACL;QAC3D,MAAMM,oBAAoBT,uBAAuBO;QACjD,IAAI,CAAC,IAAA,6KAAO,EAACD,eAAeA,eAAeG,mBAAmB;YAC5D,MAAMC,aAAa,uLAAiB,CAACC,gBAAgB,CACnDR,eACAD;YAEFE,OAAOQ,aAAa,CAACF,YAAYL;YACjC,OAAOK;QACT;QAEA,0DAA0D;QAC1D,sBAAsB;QACtB,uDAAuD;QACvD,wDAAwD;QACxD,yDAAyD;QACzD,wDAAwD;QACxD,uDAAuD;QACvD,qDAAqD;QACrD,MAAMG,iBAAiB,IAAIC,WAAWV,OAAOW,WAAW;QACxDX,OAAOQ,aAAa,CAACC;QAErB,2DAA2D;QAC3D,kCAAkC;QAClC,MAAMzB,oBAAoB,uLAAiB,CAACuB,gBAAgB,CAC1DR,eACAD;QAEF,MAAMc,oBAAoBV,cAAcG;QACxC,MAAMQ,WAAW,IAAIC,SACnBL,eAAeT,MAAM,EACrBS,eAAeR,UAAU,EACzBQ,eAAeM,UAAU;QAE3B,MAAMC,aAAa,IAAIC,MAAMrB;QAC7B,MAAMsB,mBAAmBtC,YAAYuC,sBAAsB,CAACpB;QAC5D,IAAK,IAAIqB,IAAI,GAAGA,IAAI9B,cAAc,EAAE8B,EAAG;YACrC,MAAMC,oBAAoBpB,aAAamB,IAAIR;YAC3CM,iBACEL,UACAQ,mBACAzB,sBACAoB;YAEF,IAAK,IAAIM,IAAI,GAAGA,IAAI1B,sBAAsB,EAAE0B,EAAG;gBAC7CtC,iBAAiB,CAACoC,IAAIxB,uBAAuB0B,EAAE,GAAGN,UAAU,CAACM,EAAE;YACjE;QACF;QACA,OAAOtC;IACT;IAEA;;;;;;;;;;;;;;;;GAgBC,GACD,OAAOS,WACL8B,mBAAmB,EACnBjC,YAAY,EACZF,WAAW,EACXD,YAAY,EACZ;QACA,yCAAyC;QACzC,2KAAK,CAACJ,OAAO,CAAC,uBAAuBwC;QACrC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAACC,mBAAmB,CAAC,gBAAgBpC,cAAc;QACtE,2KAAK,CAACP,OAAO,CAAC,eAAeK;QAC7B,2KAAK,CAACL,OAAO,CAAC,gBAAgBI;QAC9B,wBAAwB;QAExB,IAAIA,aAAawC,UAAU,EAAE;YAC3B,MAAMhC,wBAAwBf,YAAYgD,SAAS,CACjDL,qBACAjC,cACAH,aAAa0C,kBAAkB,EAC/BC;YAEF,IAAI3C,aAAa4C,aAAa,EAAE;gBAC9BnD,YAAYoD,eAAe,CACzBrC,uBACAA;YAEJ;YACA,OAAOA;QACT;QAEA,8DAA8D;QAC9D,oCAAoC;QACpC,MAAMsC,WAAW9C,aAAa+C,uBAAuB;QACrD,MAAMC,SAAShD,aAAaiD,qBAAqB;QACjD,IAAIhD,gBAAgB,oLAAa,CAACiD,MAAM,EAAE;YACxC,OAAOzD,YAAY0D,YAAY,CAC7Bf,qBACAjC,cACA2C,UACAE,QACAL;QAEJ;QACA,IAAI1C,gBAAgB,oLAAa,CAACmD,IAAI,EAAE;YACtC,OAAO3D,YAAY4D,YAAY,CAC7BjB,qBACAjC,cACA2C,UACAE,QACAL;QAEJ;QACA,IAAI1C,gBAAgB,oLAAa,CAACqD,IAAI,EAAE;YACtC,OAAO7D,YAAY8D,YAAY,CAC7BnB,qBACAjC,cACA2C,UACAE,QACAL;QAEJ;QACA,IAAI1C,gBAAgB,oLAAa,CAACuD,IAAI,EAAE;YACtC,OAAO/D,YAAYgE,YAAY,CAC7BrB,qBACAjC,cACA2C,UACAE,QACAL;QAEJ;QACA,MAAM,IAAI,oLAAc,CACtB,CAAC,4EAA4E,EAAE1C,aAAa;IAEhG;IAEA;;;;;;;;;;;;;GAaC,GACD,OAAOwC,UACLL,mBAAmB,EACnBjC,YAAY,EACZuC,kBAAkB,EAClBlC,qBAAqB,EACrB;QACA,yCAAyC;QACzC,2KAAK,CAACZ,OAAO,CAAC,uBAAuBwC;QACrC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAACC,mBAAmB,CAAC,gBAAgBpC,cAAc;QACtE,2KAAK,CAACkC,MAAM,CAACC,MAAM,CAACoB,WAAW,CAC7B,sBACAhB,oBACA;QAEF,wBAAwB;QAExB,IAAI,CAAC,IAAA,6KAAO,EAAClC,wBAAwB;YACnCA,wBAAwB,IAAImD,aAAavB,oBAAoBwB,MAAM;QACrE;QACA,MAAMC,IAAI,IAAI,gLAAU;QACxB,IAAK,IAAI5B,IAAI,GAAGA,IAAI9B,cAAc8B,IAAK;YACrC,gLAAU,CAAC6B,MAAM,CAAC1B,qBAAqBH,IAAI,GAAG4B;YAC9C,0LAAoB,CAACE,gBAAgB,CAACF,GAAGnB,oBAAoBmB;YAC7D,gLAAU,CAACG,IAAI,CAACxD,uBAAuBqD,GAAG5B,IAAI;QAChD;QACA,OAAOzB;IACT;IAEA;;;;;;;;;;GAUC,GACD,OAAOqC,gBAAgBoB,KAAK,EAAE9D,YAAY,EAAE+D,MAAM,EAAE;QAClD,yCAAyC;QACzC,2KAAK,CAACtE,OAAO,CAAC,SAASqE;QACvB,2KAAK,CAAC5B,MAAM,CAACC,MAAM,CAACC,mBAAmB,CAAC,gBAAgBpC,cAAc;QACtE,wBAAwB;QAExB,IAAI,CAAC,IAAA,6KAAO,EAAC+D,SAAS;YACpBA,SAAS,IAAIP,aAAaM,MAAML,MAAM;QACxC;QACA,IAAIZ,SAAS;QACb,IAAK,IAAIf,IAAI,GAAGA,IAAI9B,cAAc8B,KAAKe,UAAU,EAAG;YAClD,MAAMmB,IAAIF,KAAK,CAACjB,SAAS,EAAE;YAC3B,MAAMoB,IAAIH,KAAK,CAACjB,SAAS,EAAE;YAC3B,MAAMqB,IAAIJ,KAAK,CAACjB,SAAS,EAAE;YAC3BkB,MAAM,CAAClB,SAAS,EAAE,GAAGoB;YACrBF,MAAM,CAAClB,SAAS,EAAE,GAAGqB;YACrBH,MAAM,CAAClB,SAAS,EAAE,GAAGmB;QACvB;QACA,OAAOD;IACT;IAEA;;;;;;;;;;;;;;GAcC,GACD,OAAOf,aACLf,mBAAmB,EACnBjC,YAAY,EACZ2C,QAAQ,EACRE,MAAM,EACNxC,qBAAqB,EACrB;QACA,yCAAyC;QACzC,2KAAK,CAACZ,OAAO,CAAC,uBAAuBwC;QACrC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAACC,mBAAmB,CAAC,gBAAgBpC,cAAc;QACtE,2KAAK,CAACP,OAAO,CAAC,YAAYkD;QAC1B,2KAAK,CAAClD,OAAO,CAAC,UAAUoD;QACxB,wBAAwB;QAExB,IAAI,CAAC,IAAA,6KAAO,EAACxC,wBAAwB;YACnCA,wBAAwB,IAAImD,aAAavB,oBAAoBwB,MAAM;QACrE;QACA,IAAK,IAAI3B,IAAI,GAAGA,IAAI9B,cAAc8B,IAAK;YACrC,MAAMqC,IAAIlC,mBAAmB,CAACH,EAAE;YAChC,MAAMsC,IAAID,IAAIxB,WAAWE;YACzBxC,qBAAqB,CAACyB,EAAE,GAAGsC;QAC7B;QACA,OAAO/D;IACT;IAEA;;;;;;;;;;;;;;;GAeC,GACD,OAAO6C,aACLjB,mBAAmB,EACnBjC,YAAY,EACZ2C,QAAQ,EACRE,MAAM,EACNxC,qBAAqB,EACrB;QACA,yCAAyC;QACzC,2KAAK,CAACZ,OAAO,CAAC,uBAAuBwC;QACrC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAACC,mBAAmB,CAAC,gBAAgBpC,cAAc;QACtE,2KAAK,CAACP,OAAO,CAAC,YAAYkD;QAC1B,2KAAK,CAAClD,OAAO,CAAC,UAAUoD;QACxB,wBAAwB;QAExB,IAAI,CAAC,IAAA,6KAAO,EAACxC,wBAAwB;YACnCA,wBAAwB,IAAImD,aAAavB,oBAAoBwB,MAAM;QACrE;QACA,MAAMC,IAAI,IAAI,gLAAU;QACxB,IAAK,IAAI5B,IAAI,GAAGA,IAAI9B,cAAc8B,IAAK;YACrC,gLAAU,CAAC6B,MAAM,CAAC1B,qBAAqBH,IAAI,GAAG4B;YAC9C,gLAAU,CAACW,kBAAkB,CAACX,GAAGf,UAAUe;YAC3C,gLAAU,CAACY,GAAG,CAACZ,GAAGb,QAAQa;YAC1B,gLAAU,CAACG,IAAI,CAACH,GAAGrD,uBAAuByB,IAAI;QAChD;QACA,OAAOzB;IACT;IAEA;;;;;;;;;;;;;;;GAeC,GACD,OAAO+C,aACLnB,mBAAmB,EACnBjC,YAAY,EACZ2C,QAAQ,EACRE,MAAM,EACNxC,qBAAqB,EACrB;QACA,yCAAyC;QACzC,2KAAK,CAACZ,OAAO,CAAC,uBAAuBwC;QACrC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAACC,mBAAmB,CAAC,gBAAgBpC,cAAc;QACtE,2KAAK,CAACP,OAAO,CAAC,YAAYkD;QAC1B,2KAAK,CAAClD,OAAO,CAAC,UAAUoD;QACxB,wBAAwB;QAExB,IAAI,CAAC,IAAA,6KAAO,EAACxC,wBAAwB;YACnCA,wBAAwB,IAAImD,aAAavB,oBAAoBwB,MAAM;QACrE;QACA,MAAMC,IAAI,IAAI,gLAAU;QACxB,IAAK,IAAI5B,IAAI,GAAGA,IAAI9B,cAAc8B,IAAK;YACrC,gLAAU,CAAC6B,MAAM,CAAC1B,qBAAqBH,IAAI,GAAG4B;YAC9C,gLAAU,CAACW,kBAAkB,CAACX,GAAGf,UAAUe;YAC3C,gLAAU,CAACY,GAAG,CAACZ,GAAGb,QAAQa;YAC1B,gLAAU,CAACG,IAAI,CAACH,GAAGrD,uBAAuByB,IAAI;QAChD;QACA,OAAOzB;IACT;IAEA;;;;;;;;;;;;;;;GAeC,GACD,OAAOiD,aACLrB,mBAAmB,EACnBjC,YAAY,EACZ2C,QAAQ,EACRE,MAAM,EACNxC,qBAAqB,EACrB;QACA,yCAAyC;QACzC,2KAAK,CAACZ,OAAO,CAAC,uBAAuBwC;QACrC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAACC,mBAAmB,CAAC,gBAAgBpC,cAAc;QACtE,2KAAK,CAACP,OAAO,CAAC,YAAYkD;QAC1B,2KAAK,CAAClD,OAAO,CAAC,UAAUoD;QACxB,wBAAwB;QAExB,IAAI,CAAC,IAAA,6KAAO,EAACxC,wBAAwB;YACnCA,wBAAwB,IAAImD,aAAavB,oBAAoBwB,MAAM;QACrE;QACA,MAAMC,IAAI,IAAI,gLAAU;QACxB,IAAK,IAAI5B,IAAI,GAAGA,IAAI9B,cAAc8B,IAAK;YACrC,gLAAU,CAAC6B,MAAM,CAAC1B,qBAAqBH,IAAI,GAAG4B;YAC9C,gLAAU,CAACW,kBAAkB,CAACX,GAAGf,UAAUe;YAC3C,gLAAU,CAACY,GAAG,CAACZ,GAAGb,QAAQa;YAC1B,gLAAU,CAACG,IAAI,CAACH,GAAGrD,uBAAuByB,IAAI;QAChD;QACA,OAAOzB;IACT;IAEA;;;;;;;;;GASC,GAED;;;;;;;GAOC,GACD,OAAOwB,uBAAuBpB,aAAa,EAAE;QAC3C,MAAM8D,kBAAkBjF,YAAYkF,qBAAqB,CAAC/D;QAC1D,MAAMY,cAAc,uLAAiB,CAACP,cAAc,CAACL;QACrD,OAAO,SAAUc,QAAQ,EAAEZ,UAAU,EAAE8D,kBAAkB,EAAEC,MAAM;YAC/D,IAAI7B,SAASlC;YACb,IAAK,IAAImB,IAAI,GAAGA,IAAI2C,oBAAoB,EAAE3C,EAAG;gBAC3C4C,MAAM,CAAC5C,EAAE,GAAGyC,gBAAgBhD,UAAUsB;gBACtCA,UAAUxB;YACZ;QACF;IACF;IAEA;;;;;;;;GAQC,GAED;;;;;;GAMC,GACD,OAAOmD,sBAAsB/D,aAAa,EAAE;QAC1C,OAAQA;YACN,KAAK,uLAAiB,CAACkE,IAAI;gBACzB,OAAO,SAAUpD,QAAQ,EAAEZ,UAAU;oBACnC,OAAOY,SAASqD,OAAO,CAACjE;gBAC1B;YACF,KAAK,uLAAiB,CAACkE,aAAa;gBAClC,OAAO,SAAUtD,QAAQ,EAAEZ,UAAU;oBACnC,OAAOY,SAASuD,QAAQ,CAACnE;gBAC3B;YACF,KAAK,uLAAiB,CAACoE,KAAK;gBAC1B,OAAO,SAAUxD,QAAQ,EAAEZ,UAAU;oBACnC,OAAOY,SAASyD,QAAQ,CAACrE,YAAY;gBACvC;YACF,KAAK,uLAAiB,CAACsE,cAAc;gBACnC,OAAO,SAAU1D,QAAQ,EAAEZ,UAAU;oBACnC,OAAOY,SAAS2D,SAAS,CAACvE,YAAY;gBACxC;YACF,KAAK,uLAAiB,CAACwE,GAAG;gBACxB,OAAO,SAAU5D,QAAQ,EAAEZ,UAAU;oBACnC,OAAOY,SAAS6D,QAAQ,CAACzE,YAAY;gBACvC;YACF,KAAK,uLAAiB,CAAC0E,YAAY;gBACjC,OAAO,SAAU9D,QAAQ,EAAEZ,UAAU;oBACnC,OAAOY,SAAS+D,SAAS,CAAC3E,YAAY;gBACxC;YACF,KAAK,uLAAiB,CAAC4E,KAAK;gBAC1B,OAAO,SAAUhE,QAAQ,EAAEZ,UAAU;oBACnC,OAAOY,SAASiE,UAAU,CAAC7E,YAAY;gBACzC;YACF,KAAK,uLAAiB,CAAC8E,MAAM;gBAC3B,OAAO,SAAUlE,QAAQ,EAAEZ,UAAU;oBACnC,OAAOY,SAASmE,UAAU,CAAC/E,YAAY;gBACzC;QACJ;QACA,MAAM,IAAI,oLAAc,CACtB,CAAC,4DAA4D,EAAEF,eAAe;IAElF;IAEA;;;;;;;;;;GAUC,GACD,OAAOkF,YAAY7B,KAAK,EAAE8B,MAAM,EAAElB,MAAM,EAAE;QACxC,yCAAyC;QACzC,2KAAK,CAACjF,OAAO,CAAC,SAASqE;QACvB,2KAAK,CAACrE,OAAO,CAAC,UAAUmG;QACxB,wBAAwB;QAExB,IAAI,CAAC,IAAA,6KAAO,EAAClB,SAAS;YACpBA,SAAS,IAAIlB,aAAaM,MAAML,MAAM;QACxC;QACA,MAAMC,IAAI,IAAI,gLAAU;QACxB,MAAM1D,eAAe8D,MAAML,MAAM,GAAG;QACpC,IAAK,IAAI3B,IAAI,GAAGA,IAAI9B,cAAc8B,IAAK;YACrC,gLAAU,CAAC6B,MAAM,CAACG,OAAOhC,IAAI,GAAG4B;YAChC,6KAAO,CAACmC,eAAe,CAACD,QAAQlC,GAAGA;YACnC,gLAAU,CAACG,IAAI,CAACH,GAAGgB,QAAQ5C,IAAI;QACjC;QACA,OAAO4C;IACT;IAEA;;;;;;;;;;;;;;;;;;GAkBC,GACD,OAAOoB,wBAAwBC,gBAAgB,EAAE;QAC/C,MAAMC,kBAAkBD,iBAAiB/E,UAAU;QACnD,IAAI,IAAA,6KAAO,EAACgF,kBAAkB;YAC5B,OAAOA;QACT;QACA,MAAMC,gBAAgBF,iBAAiBrF,MAAM;QAC7C,MAAMwF,eAAeH,iBAAiB9F,KAAK;QAC3C,MAAMkG,gBAAgBJ,iBAAiBI,aAAa;QACpD,MAAMC,UAAU9G,YAAY+G,qBAAqB,CAC/CF,eACAD;QAEFD,cAAc/E,aAAa,CAACkF;QAC5B,OAAOA;IACT;IAEA;;;;;;;;;;;;;;;;;;;;;;;;GAwBC,GACD,OAAOE,uCACLP,gBAAgB,EAChBQ,aAAa,EACb;QACA,MAAMC,kBACJlH,YAAYwG,uBAAuB,CAACC;QACtC,IAAIQ,kBAAkB,mLAAa,CAACE,SAAS,EAAE;YAC7C,OAAOD;QACT;QACA,IAAID,kBAAkB,mLAAa,CAACG,cAAc,EAAE;YAClD,MAAMC,kBACJrH,YAAYsH,qCAAqC,CAACJ;YACpD,OAAOG;QACT;QACA,IAAIJ,kBAAkB,mLAAa,CAACM,YAAY,EAAE;YAChD,MAAMF,kBACJrH,YAAYwH,mCAAmC,CAACN;YAClD,OAAOG;QACT;QACA,MAAM,IAAI,oLAAc,CACtB,CAAC,qCAAqC,EAAE,mLAAa,CAACF,SAAS,CAAC,EAAE,CAAC,GACjE,CAAC,gBAAgB,EAAE,mLAAa,CAACC,cAAc,CAAC,KAAK,CAAC,GACtD,CAAC,cAAc,EAAE,mLAAa,CAACG,YAAY,CAAC,SAAS,EAAEN,eAAe;IAE5E;IAEA;;;;;;;;GAQC,GACD,OAAOK,sCAAsCR,OAAO,EAAE;QACpD,MAAMO,kBAAkBP,QAAQ9G,WAAW,CAAC,CAAC8G,QAAQ3C,MAAM,GAAG,CAAC,IAAI;QACnE,IAAK,IAAI3B,IAAI,GAAGA,IAAIsE,QAAQ3C,MAAM,GAAG,GAAG3B,IAAK;YAC3C,IAAIA,IAAI,MAAM,GAAG;gBACf6E,eAAe,CAAC7E,IAAI,IAAI,EAAE,GAAGsE,OAAO,CAACtE,IAAI,EAAE;gBAC3C6E,eAAe,CAAC7E,IAAI,IAAI,EAAE,GAAGsE,OAAO,CAACtE,IAAI,EAAE;gBAC3C6E,eAAe,CAAC7E,IAAI,IAAI,EAAE,GAAGsE,OAAO,CAACtE,IAAI,EAAE;YAC7C,OAAO;gBACL6E,eAAe,CAAC7E,IAAI,IAAI,EAAE,GAAGsE,OAAO,CAACtE,IAAI,EAAE;gBAC3C6E,eAAe,CAAC7E,IAAI,IAAI,EAAE,GAAGsE,OAAO,CAACtE,IAAI,EAAE;gBAC3C6E,eAAe,CAAC7E,IAAI,IAAI,EAAE,GAAGsE,OAAO,CAACtE,IAAI,EAAE;YAC7C;QACF;QACA,OAAO6E;IACT;IAEA;;;;;;;;GAQC,GACD,OAAOG,oCAAoCV,OAAO,EAAE;QAClD,MAAMO,kBAAkBP,QAAQ9G,WAAW,CAAC,CAAC8G,QAAQ3C,MAAM,GAAG,CAAC,IAAI;QACnE,IAAK,IAAI3B,IAAI,GAAGA,IAAIsE,QAAQ3C,MAAM,GAAG,GAAG3B,IAAK;YAC3C6E,eAAe,CAAC7E,IAAI,IAAI,EAAE,GAAGsE,OAAO,CAACtE,IAAI,EAAE;YAC3C6E,eAAe,CAAC7E,IAAI,IAAI,EAAE,GAAGsE,OAAO,CAACtE,IAAI,EAAE;YAC3C6E,eAAe,CAAC7E,IAAI,IAAI,EAAE,GAAGsE,OAAO,CAACtE,IAAI,EAAE;QAC7C;QACA,OAAO6E;IACT;IAEA;;;;;;;;;;GAUC,GACD,OAAON,sBAAsBF,aAAa,EAAEY,IAAI,EAAE;QAChD,yCAAyC;QACzC,2KAAK,CAAC7E,MAAM,CAACC,MAAM,CAACC,mBAAmB,CAAC,QAAQ2E,MAAM;QACtD,wBAAwB;QAExB,OAAQZ;YACN,KAAK,mLAAa,CAACtB,aAAa;gBAC9B,OAAO,IAAIzD,WAAW2F;YACxB,KAAK,mLAAa,CAAC9B,cAAc;gBAC/B,OAAO,IAAI+B,YAAYD;YACzB,KAAK,mLAAa,CAAC1B,YAAY;gBAC7B,OAAO,IAAI4B,YAAYF;QAC3B;QACA,MAAM,IAAI,oLAAc,CACtB,CAAC,yCAAyC,EAAE,mLAAa,CAAClC,aAAa,CAAC,EAAE,CAAC,GACzE,CAAC,gBAAgB,EAAE,mLAAa,CAACI,cAAc,CAAC,KAAK,CAAC,GACtD,CAAC,cAAc,EAAE,mLAAa,CAACI,YAAY,CAAC,SAAS,EAAEc,eAAe;IAE5E;AACF;uCAEe7G","ignoreList":[0]}},
    {"offset": {"line": 10458, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/EdgeVisibilityPipelineStage.js"],"sourcesContent":["import Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport VertexArray from \"../../Renderer/VertexArray.js\";\nimport defined from \"../../Core/defined.js\";\nimport IndexDatatype from \"../../Core/IndexDatatype.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport EdgeVisibilityStageFS from \"../../Shaders/Model/EdgeVisibilityStageFS.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport ModelReader from \"./ModelReader.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * Builds derived line geometry for model edges using EXT_mesh_primitive_edge_visibility data.\n * It parses the encoded edge visibility bits, creates a separate edge-domain vertex array with\n * per-edge attributes (edge type, optional feature ID, silhouette normal, adjacent face normals),\n * sets up the required shader defines / varyings, and stores the resulting line list geometry on\n * the render resources for a later edge rendering pass.\n *\n * @namespace EdgeVisibilityPipelineStage\n * @private\n */\nconst EdgeVisibilityPipelineStage = {\n  name: \"EdgeVisibilityPipelineStage\",\n};\n\n/**\n * Process a primitive to derive edge geometry and shader bindings. This modifies the render resources by:\n * <ul>\n *  <li>Adding shader defines (<code>HAS_EDGE_VISIBILITY</code>, <code>HAS_EDGE_VISIBILITY_MRT</code>)</li>\n *  <li>Injecting the fragment shader logic that outputs edge color / feature information</li>\n *  <li>Adding per-vertex attributes: edge type, optional feature ID, silhouette normal, and adjacent face normals</li>\n *  <li>Adding varyings to pass these attributes to the fragment stage</li>\n *  <li>Creating and storing a derived line list vertex array in <code>renderResources.edgeGeometry</code></li>\n * </ul>\n * If the primitive does not contain edge visibility data, the function returns early.\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state\n * @private\n */\nEdgeVisibilityPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  if (!defined(primitive.edgeVisibility)) {\n    return;\n  }\n\n  // Fallback request: mark that edge visibility is needed this frame.\n  frameState.edgeVisibilityRequested = true;\n\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  // Add shader defines and fragment code\n  shaderBuilder.addDefine(\n    \"HAS_EDGE_VISIBILITY\",\n    undefined,\n    ShaderDestination.BOTH,\n  );\n  shaderBuilder.addDefine(\n    \"HAS_EDGE_VISIBILITY_MRT\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addFragmentLines(EdgeVisibilityStageFS);\n\n  // Add a uniform to distinguish between original geometry pass and edge pass\n  shaderBuilder.addUniform(\"bool\", \"u_isEdgePass\", ShaderDestination.BOTH);\n\n  // Add edge type attribute and varying\n  const edgeTypeLocation = shaderBuilder.addAttribute(\"float\", \"a_edgeType\");\n  shaderBuilder.addVarying(\"float\", \"v_edgeType\", \"flat\");\n\n  // Add edge feature ID attribute and varying\n  const edgeFeatureIdLocation = shaderBuilder.addAttribute(\n    \"float\",\n    \"a_edgeFeatureId\",\n  );\n\n  // Add silhouette normal attribute and varying for silhouette edges\n  const silhouetteNormalLocation = shaderBuilder.addAttribute(\n    \"vec3\",\n    \"a_silhouetteNormal\",\n  );\n  shaderBuilder.addVarying(\"vec3\", \"v_silhouetteNormalView\", \"flat\");\n\n  // Add face normal attributes for silhouette detection\n  const faceNormalALocation = shaderBuilder.addAttribute(\n    \"vec3\",\n    \"a_faceNormalA\",\n  );\n  const faceNormalBLocation = shaderBuilder.addAttribute(\n    \"vec3\",\n    \"a_faceNormalB\",\n  );\n  shaderBuilder.addVarying(\"vec3\", \"v_faceNormalAView\", \"flat\");\n  shaderBuilder.addVarying(\"vec3\", \"v_faceNormalBView\", \"flat\");\n\n  // Add varying for view space position for perspective-correct silhouette detection\n\n  // Pass edge type, silhouette normal, and face normals from vertex to fragment shader\n  shaderBuilder.addFunctionLines(\"setDynamicVaryingsVS\", [\n    \"#ifdef HAS_EDGE_VISIBILITY\",\n    \"  if (u_isEdgePass) {\",\n    \"    v_edgeType = a_edgeType;\",\n    \"#ifdef HAS_EDGE_FEATURE_ID\",\n    \"    v_featureId_0 = a_edgeFeatureId;\",\n    \"#endif\",\n    \"    // Transform normals from model space to view space\",\n    \"    v_silhouetteNormalView = czm_normal * a_silhouetteNormal;\",\n    \"    v_faceNormalAView = czm_normal * a_faceNormalA;\",\n    \"    v_faceNormalBView = czm_normal * a_faceNormalB;\",\n    \"  }\",\n    \"#endif\",\n  ]);\n\n  // Build triangle adjacency (mapping edges to adjacent triangles) and compute per-triangle face normals.\n  const adjacencyData = buildTriangleAdjacency(primitive);\n\n  const edgeResult = extractVisibleEdges(primitive);\n\n  if (\n    !defined(edgeResult) ||\n    !defined(edgeResult.edgeIndices) ||\n    edgeResult.edgeIndices.length === 0\n  ) {\n    return;\n  }\n\n  // Generate paired face normals for each unique edge (used to classify silhouette edges in the shader).\n  const edgeFaceNormals = generateEdgeFaceNormals(\n    adjacencyData,\n    edgeResult.edgeIndices,\n  );\n\n  // Create edge-domain line list geometry (2 vertices per edge) with all required attributes.\n  const edgeGeometry = createCPULineEdgeGeometry(\n    edgeResult.edgeIndices,\n    edgeResult.edgeData,\n    renderResources,\n    frameState.context,\n    edgeTypeLocation,\n    silhouetteNormalLocation,\n    faceNormalALocation,\n    faceNormalBLocation,\n    edgeFeatureIdLocation,\n    primitive.edgeVisibility,\n    edgeFaceNormals,\n  );\n\n  if (!defined(edgeGeometry)) {\n    return;\n  }\n\n  if (edgeGeometry.hasEdgeFeatureIds) {\n    shaderBuilder.addDefine(\n      \"HAS_EDGE_FEATURE_ID\",\n      undefined,\n      ShaderDestination.BOTH,\n    );\n  }\n\n  // Set default value for u_isEdgePass uniform (false for original geometry pass). A later pass overrides this.\n  renderResources.uniformMap.u_isEdgePass = function () {\n    return false;\n  };\n\n  // Store edge geometry metadata so the renderer can issue a separate edges pass.\n  renderResources.edgeGeometry = {\n    vertexArray: edgeGeometry.vertexArray,\n    indexCount: edgeGeometry.indexCount,\n    primitiveType: PrimitiveType.LINES,\n    pass: Pass.CESIUM_3D_TILE_EDGES,\n  };\n};\n\n/**\n * Build triangle adjacency information and per-triangle face normals in model space.\n * The adjacency map associates an undirected edge (minIndex,maxIndex) with the indices\n * of up to two adjacent triangles. Face normals are normalized and stored sequentially.\n *\n * @param {ModelComponents.Primitive} primitive The primitive containing triangle index + position data\n * @returns {{edgeMap:Map<string, number[]>, faceNormals:Float32Array, triangleCount:number}}\n * @private\n */\nfunction buildTriangleAdjacency(primitive) {\n  const indices = primitive.indices;\n  if (!defined(indices)) {\n    return {\n      edgeMap: new Map(),\n      faceNormals: new Float32Array(0),\n      triangleCount: 0,\n    };\n  }\n\n  const triangleIndexArray = indices.typedArray;\n  const triangleCount = Math.floor(triangleIndexArray.length / 3);\n\n  // Get vertex positions for face normal calculation\n  const positionAttribute = ModelUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.POSITION,\n  );\n\n  // Retrieve raw (possibly quantized) position data. If the attribute is quantized\n  // we must dequantize on the CPU here because we compute face normals and silhouette\n  // classification data before the vertex shader's dequantization stage runs.\n  let positions = defined(positionAttribute.typedArray)\n    ? positionAttribute.typedArray\n    : ModelReader.readAttributeAsTypedArray(positionAttribute);\n\n  const quantization = positionAttribute.quantization;\n  if (defined(quantization) && !quantization.octEncoded) {\n    const count = positions.length; // length is 3 * vertexCount\n    const dequantized = new Float32Array(count);\n    const offset = quantization.quantizedVolumeOffset;\n    const step = quantization.quantizedVolumeStepSize;\n    for (let i = 0; i < count; i += 3) {\n      dequantized[i] = offset.x + positions[i] * step.x;\n      dequantized[i + 1] = offset.y + positions[i + 1] * step.y;\n      dequantized[i + 2] = offset.z + positions[i + 2] * step.z;\n    }\n    positions = dequantized;\n  }\n\n  // Build edge map: key = \"min,max\", value = [triangleA, triangleB?]\n  const edgeMap = new Map();\n\n  // Calculate face normals for each triangle (model space)\n  const faceNormals = new Float32Array(triangleCount * 3);\n\n  // Scratch vectors to avoid heap allocations per triangle\n  const scratchP0 = new Cartesian3();\n  const scratchP1 = new Cartesian3();\n  const scratchP2 = new Cartesian3();\n  const scratchE1 = new Cartesian3();\n  const scratchE2 = new Cartesian3();\n  const scratchCross = new Cartesian3();\n\n  function processEdge(a, b, triIndex) {\n    const edgeKey = `${a < b ? a : b},${a < b ? b : a}`;\n    let list = edgeMap.get(edgeKey);\n    if (!defined(list)) {\n      list = [];\n      edgeMap.set(edgeKey, list);\n    }\n    if (list.length < 2) {\n      list.push(triIndex);\n    }\n  }\n\n  for (let t = 0; t < triangleCount; t++) {\n    const base = t * 3;\n    const i0 = triangleIndexArray[base];\n    const i1 = triangleIndexArray[base + 1];\n    const i2 = triangleIndexArray[base + 2];\n\n    const i0o = i0 * 3;\n    const i1o = i1 * 3;\n    const i2o = i2 * 3;\n\n    scratchP0.x = positions[i0o];\n    scratchP0.y = positions[i0o + 1];\n    scratchP0.z = positions[i0o + 2];\n    scratchP1.x = positions[i1o];\n    scratchP1.y = positions[i1o + 1];\n    scratchP1.z = positions[i1o + 2];\n    scratchP2.x = positions[i2o];\n    scratchP2.y = positions[i2o + 1];\n    scratchP2.z = positions[i2o + 2];\n\n    Cartesian3.subtract(scratchP1, scratchP0, scratchE1);\n    Cartesian3.subtract(scratchP2, scratchP0, scratchE2);\n    Cartesian3.cross(scratchE1, scratchE2, scratchCross);\n    Cartesian3.normalize(scratchCross, scratchCross);\n\n    faceNormals[base] = scratchCross.x;\n    faceNormals[base + 1] = scratchCross.y;\n    faceNormals[base + 2] = scratchCross.z;\n\n    // Edges\n    processEdge(i0, i1, t);\n    processEdge(i1, i2, t);\n    processEdge(i2, i0, t);\n  }\n\n  return { edgeMap, faceNormals, triangleCount };\n}\n\n/**\n * For each unique edge produce a pair of face normals (A,B). For boundary edges where only a single\n * adjacent triangle exists, the second normal is synthesized as the negation of the first to allow\n * the shader to reason about front/back facing transitions uniformly.\n *\n * @param {{edgeMap:Map<string,number[]>, faceNormals:Float32Array}} adjacencyData The adjacency data from buildTriangleAdjacency\n * @param {number[]} edgeIndices Packed array of 2 vertex indices per edge\n * @returns {Float32Array} Packed array: 6 floats per edge (normalA.xyz, normalB.xyz)\n * @private\n */\nfunction generateEdgeFaceNormals(adjacencyData, edgeIndices) {\n  const { edgeMap, faceNormals } = adjacencyData;\n  const numEdges = edgeIndices.length / 2;\n\n  // Each edge needs 2 face normals (left and right side)\n  const edgeFaceNormals = new Float32Array(numEdges * 6); // 2 normals * 3 components each\n\n  for (let i = 0; i < numEdges; i++) {\n    const a = edgeIndices[i * 2];\n    const b = edgeIndices[i * 2 + 1];\n    const edgeKey = `${a < b ? a : b},${a < b ? b : a}`;\n    const triangleList = edgeMap.get(edgeKey);\n\n    // Expect at least one triangle; silently skip if not found (defensive)\n    if (!defined(triangleList) || triangleList.length === 0) {\n      continue;\n    }\n\n    const tA = triangleList[0];\n    const aBase = tA * 3;\n    const nAx = faceNormals[aBase];\n    const nAy = faceNormals[aBase + 1];\n    const nAz = faceNormals[aBase + 2];\n\n    let nBx;\n    let nBy;\n    let nBz;\n    if (triangleList.length > 1) {\n      const tB = triangleList[1];\n      const bBase = tB * 3;\n      nBx = faceNormals[bBase];\n      nBy = faceNormals[bBase + 1];\n      nBz = faceNormals[bBase + 2];\n    } else {\n      // Boundary edge â€“ synthesize opposite normal\n      nBx = -nAx;\n      nBy = -nAy;\n      nBz = -nAz;\n    }\n\n    const baseIdx = i * 6;\n    edgeFaceNormals[baseIdx] = nAx;\n    edgeFaceNormals[baseIdx + 1] = nAy;\n    edgeFaceNormals[baseIdx + 2] = nAz;\n    edgeFaceNormals[baseIdx + 3] = nBx;\n    edgeFaceNormals[baseIdx + 4] = nBy;\n    edgeFaceNormals[baseIdx + 5] = nBz;\n  }\n\n  return edgeFaceNormals;\n}\n\n/**\n * Parse the EXT_mesh_primitive_edge_visibility 2-bit edge encoding and extract\n * a unique set of edges that should be considered for rendering. Edge types:\n * <ul>\n *  <li>0 HIDDEN - skipped</li>\n *  <li>1 SILHOUETTE - candidates for conditional display based on facing</li>\n *  <li>2 HARD - always displayed</li>\n *  <li>3 REPEATED - secondary encoding for a hard edge (treated same as 2)</li>\n * </ul>\n * Deduplicates edges shared by adjacent triangles and records per-edge metadata.\n *\n * @param {ModelComponents.Primitive} primitive The primitive with EXT_mesh_primitive_edge_visibility data\n * @returns {{edgeIndices:number[], edgeData:Object[], silhouetteEdgeCount:number}} Edge extraction result\n * @private\n */\nfunction extractVisibleEdges(primitive) {\n  const edgeVisibility = primitive.edgeVisibility;\n  const visibility = edgeVisibility.visibility;\n  const indices = primitive.indices;\n\n  if (!defined(visibility) || !defined(indices)) {\n    return [];\n  }\n\n  const triangleIndexArray = indices.typedArray;\n  const vertexCount = primitive.attributes[0].count;\n  const edgeIndices = [];\n  const edgeData = [];\n  const seenEdgeHashes = new Set();\n  let silhouetteEdgeCount = 0;\n\n  // Process triangles and extract edges (2 bits per edge)\n  let edgeIndex = 0;\n  const totalIndices = triangleIndexArray.length;\n\n  for (let i = 0; i + 2 < totalIndices; i += 3) {\n    const v0 = triangleIndexArray[i];\n    const v1 = triangleIndexArray[i + 1];\n    const v2 = triangleIndexArray[i + 2];\n    for (let e = 0; e < 3; e++) {\n      let a, b;\n      if (e === 0) {\n        a = v0;\n        b = v1;\n      } else if (e === 1) {\n        a = v1;\n        b = v2;\n      } else if (e === 2) {\n        a = v2;\n        b = v0;\n      }\n      const byteIndex = Math.floor(edgeIndex / 4);\n      const bitPairOffset = (edgeIndex % 4) * 2;\n      edgeIndex++;\n\n      if (byteIndex >= visibility.length) {\n        break;\n      }\n\n      const byte = visibility[byteIndex];\n      const visibility2Bit = (byte >> bitPairOffset) & 0x3;\n\n      // Only include visible edge types according to EXT_mesh_primitive_edge_visibility spec\n      let shouldIncludeEdge = false;\n      switch (visibility2Bit) {\n        case 0: // HIDDEN - never draw\n          shouldIncludeEdge = false;\n          break;\n        case 1: // SILHOUETTE - conditionally visible (front-facing vs back-facing)\n          shouldIncludeEdge = true;\n          break;\n        case 2: // HARD - always draw (primary encoding)\n          shouldIncludeEdge = true;\n          break;\n        case 3: // REPEATED - always draw (secondary encoding of a hard edge already encoded as 2)\n          shouldIncludeEdge = true;\n          break;\n      }\n\n      if (shouldIncludeEdge) {\n        const small = Math.min(a, b);\n        const big = Math.max(a, b);\n        const hash = small * vertexCount + big;\n\n        if (!seenEdgeHashes.has(hash)) {\n          seenEdgeHashes.add(hash);\n          edgeIndices.push(a, b);\n\n          let mateVertexIndex = -1;\n          if (visibility2Bit === 1) {\n            mateVertexIndex = silhouetteEdgeCount;\n            silhouetteEdgeCount++;\n          }\n\n          edgeData.push({\n            edgeType: visibility2Bit,\n            triangleIndex: Math.floor(i / 3),\n            edgeIndex: e,\n            mateVertexIndex: mateVertexIndex,\n            currentTriangleVertices: [v0, v1, v2],\n          });\n        }\n      }\n    }\n  }\n\n  return { edgeIndices, edgeData, silhouetteEdgeCount };\n}\n\n/**\n * Create a derived line list geometry representing edges. A new vertex domain is used so we can pack\n * per-edge attributes (silhouette normal, face normal pair, edge type, optional feature ID) without\n * modifying or duplicating the original triangle mesh. Two vertices are generated per unique edge.\n *\n * @param {number[]} edgeIndices Packed array [a0,b0, a1,b1, ...] of vertex indices into the source mesh\n * @param {Object[]} edgeData Array of edge metadata including edge type and silhouette normal lookup index\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {Context} context The WebGL rendering context\n * @param {number} edgeTypeLocation Shader attribute location for the edge type\n * @param {number} silhouetteNormalLocation Shader attribute location for input silhouette normal\n * @param {number} faceNormalALocation Shader attribute location for face normal A\n * @param {number} faceNormalBLocation Shader attribute location for face normal B\n * @param {number} edgeFeatureIdLocation Shader attribute location for optional edge feature ID\n * @param {Object} edgeVisibility Edge visibility extension object (may contain silhouetteNormals[])\n * @param {Float32Array} edgeFaceNormals Packed face normals (6 floats per edge)\n * @returns {Object|undefined} Object with {vertexArray, indexBuffer, indexCount} or undefined on failure\n * @private\n */\nfunction createCPULineEdgeGeometry(\n  edgeIndices,\n  edgeData,\n  renderResources,\n  context,\n  edgeTypeLocation,\n  silhouetteNormalLocation,\n  faceNormalALocation,\n  faceNormalBLocation,\n  edgeFeatureIdLocation,\n  edgeVisibility,\n  edgeFaceNormals,\n) {\n  if (!defined(edgeIndices) || edgeIndices.length === 0) {\n    return undefined;\n  }\n\n  const numEdges = edgeData.length;\n  const vertsPerEdge = 2;\n  const totalVerts = numEdges * vertsPerEdge;\n\n  // Always use location 0 for position to avoid conflicts\n  const positionLocation = 0;\n\n  // Get original vertex positions\n  const positionAttribute = ModelUtility.getAttributeBySemantic(\n    renderResources.runtimePrimitive.primitive,\n    VertexAttributeSemantic.POSITION,\n  );\n  const srcPos = defined(positionAttribute.typedArray)\n    ? positionAttribute.typedArray\n    : ModelReader.readAttributeAsTypedArray(positionAttribute);\n\n  // Create edge-domain vertices (2 per edge)\n  const edgePosArray = new Float32Array(totalVerts * 3);\n  const edgeTypeArray = new Float32Array(totalVerts);\n  const silhouetteNormalArray = new Float32Array(totalVerts * 3);\n  const faceNormalAArray = new Float32Array(totalVerts * 3);\n  const faceNormalBArray = new Float32Array(totalVerts * 3);\n  let p = 0;\n\n  const maxSrcVertex = srcPos.length / 3 - 1;\n\n  for (let i = 0; i < numEdges; i++) {\n    const a = edgeIndices[i * 2];\n    const b = edgeIndices[i * 2 + 1];\n\n    // Validate vertex indices\n    if (a < 0 || b < 0 || a > maxSrcVertex || b > maxSrcVertex) {\n      // Fill with zeros to maintain indexing\n      edgePosArray[p++] = 0;\n      edgePosArray[p++] = 0;\n      edgePosArray[p++] = 0;\n      edgePosArray[p++] = 0;\n      edgePosArray[p++] = 0;\n      edgePosArray[p++] = 0;\n      edgeTypeArray[i * 2] = 0;\n      edgeTypeArray[i * 2 + 1] = 0;\n      // Fill with default values\n      const normalIdx = i * 2;\n      silhouetteNormalArray[normalIdx * 3] = 0;\n      silhouetteNormalArray[normalIdx * 3 + 1] = 0;\n      silhouetteNormalArray[normalIdx * 3 + 2] = 1;\n      silhouetteNormalArray[(normalIdx + 1) * 3] = 0;\n      silhouetteNormalArray[(normalIdx + 1) * 3 + 1] = 0;\n      silhouetteNormalArray[(normalIdx + 1) * 3 + 2] = 1;\n\n      // Fill face normals with default values\n      faceNormalAArray[normalIdx * 3] = 0;\n      faceNormalAArray[normalIdx * 3 + 1] = 0;\n      faceNormalAArray[normalIdx * 3 + 2] = 1;\n      faceNormalAArray[(normalIdx + 1) * 3] = 0;\n      faceNormalAArray[(normalIdx + 1) * 3 + 1] = 0;\n      faceNormalAArray[(normalIdx + 1) * 3 + 2] = 1;\n\n      faceNormalBArray[normalIdx * 3] = 0;\n      faceNormalBArray[normalIdx * 3 + 1] = 0;\n      faceNormalBArray[normalIdx * 3 + 2] = 1;\n      faceNormalBArray[(normalIdx + 1) * 3] = 0;\n      faceNormalBArray[(normalIdx + 1) * 3 + 1] = 0;\n      faceNormalBArray[(normalIdx + 1) * 3 + 2] = 1;\n      continue;\n    }\n\n    const ax = srcPos[a * 3];\n    const ay = srcPos[a * 3 + 1];\n    const az = srcPos[a * 3 + 2];\n    const bx = srcPos[b * 3];\n    const by = srcPos[b * 3 + 1];\n    const bz = srcPos[b * 3 + 2];\n\n    // Add edge endpoints\n    edgePosArray[p++] = ax;\n    edgePosArray[p++] = ay;\n    edgePosArray[p++] = az;\n    edgePosArray[p++] = bx;\n    edgePosArray[p++] = by;\n    edgePosArray[p++] = bz;\n\n    const rawType = edgeData[i].edgeType;\n    const t = rawType / 255.0;\n\n    edgeTypeArray[i * 2] = t;\n    edgeTypeArray[i * 2 + 1] = t;\n\n    // Add silhouette normal for silhouette edges (type 1)\n    let normalX = 0,\n      normalY = 0,\n      normalZ = 1; // Default normal pointing up\n\n    if (rawType === 1 && defined(edgeVisibility.silhouetteNormals)) {\n      const mateVertexIndex = edgeData[i].mateVertexIndex;\n      if (\n        mateVertexIndex >= 0 &&\n        mateVertexIndex < edgeVisibility.silhouetteNormals.length\n      ) {\n        const silhouetteNormals = edgeVisibility.silhouetteNormals;\n        const normal = silhouetteNormals[mateVertexIndex];\n\n        if (defined(normal)) {\n          normalX = normal.x;\n          normalY = normal.y;\n          normalZ = normal.z;\n        }\n      }\n    }\n\n    // Set silhouette normal for both edge endpoints\n    const normalIdx = i * 2;\n    silhouetteNormalArray[normalIdx * 3] = normalX;\n    silhouetteNormalArray[normalIdx * 3 + 1] = normalY;\n    silhouetteNormalArray[normalIdx * 3 + 2] = normalZ;\n    silhouetteNormalArray[(normalIdx + 1) * 3] = normalX;\n    silhouetteNormalArray[(normalIdx + 1) * 3 + 1] = normalY;\n    silhouetteNormalArray[(normalIdx + 1) * 3 + 2] = normalZ;\n\n    // Set face normals for both edge endpoints\n    const faceNormalIdx = i * 6; // 6 floats per edge (2 normals * 3 components)\n    const normalAX = edgeFaceNormals[faceNormalIdx];\n    const normalAY = edgeFaceNormals[faceNormalIdx + 1];\n    const normalAZ = edgeFaceNormals[faceNormalIdx + 2];\n    const normalBX = edgeFaceNormals[faceNormalIdx + 3];\n    const normalBY = edgeFaceNormals[faceNormalIdx + 4];\n    const normalBZ = edgeFaceNormals[faceNormalIdx + 5];\n\n    // Face normal A for both endpoints\n    faceNormalAArray[normalIdx * 3] = normalAX;\n    faceNormalAArray[normalIdx * 3 + 1] = normalAY;\n    faceNormalAArray[normalIdx * 3 + 2] = normalAZ;\n    faceNormalAArray[(normalIdx + 1) * 3] = normalAX;\n    faceNormalAArray[(normalIdx + 1) * 3 + 1] = normalAY;\n    faceNormalAArray[(normalIdx + 1) * 3 + 2] = normalAZ;\n\n    // Face normal B for both endpoints\n    faceNormalBArray[normalIdx * 3] = normalBX;\n    faceNormalBArray[normalIdx * 3 + 1] = normalBY;\n    faceNormalBArray[normalIdx * 3 + 2] = normalBZ;\n    faceNormalBArray[(normalIdx + 1) * 3] = normalBX;\n    faceNormalBArray[(normalIdx + 1) * 3 + 1] = normalBY;\n    faceNormalBArray[(normalIdx + 1) * 3 + 2] = normalBZ;\n  }\n\n  // Create vertex buffers\n  const edgePosBuffer = Buffer.createVertexBuffer({\n    context,\n    typedArray: edgePosArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  const edgeTypeBuffer = Buffer.createVertexBuffer({\n    context,\n    typedArray: edgeTypeArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  const silhouetteNormalBuffer = Buffer.createVertexBuffer({\n    context,\n    typedArray: silhouetteNormalArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  const faceNormalABuffer = Buffer.createVertexBuffer({\n    context,\n    typedArray: faceNormalAArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  const faceNormalBBuffer = Buffer.createVertexBuffer({\n    context,\n    typedArray: faceNormalBArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n\n  // Create sequential indices for line pairs\n  const useU32 = totalVerts > 65534;\n  const idx = new Array(totalVerts);\n  for (let i = 0; i < totalVerts; i++) {\n    idx[i] = i;\n  }\n\n  const indexBuffer = Buffer.createIndexBuffer({\n    context,\n    typedArray: useU32 ? new Uint32Array(idx) : new Uint16Array(idx),\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: useU32\n      ? IndexDatatype.UNSIGNED_INT\n      : IndexDatatype.UNSIGNED_SHORT,\n  });\n\n  // Create vertex array with position, edge type, silhouette normal, and face normal attributes\n  const attributes = [\n    {\n      index: positionLocation,\n      vertexBuffer: edgePosBuffer,\n      componentsPerAttribute: 3,\n      componentDatatype: ComponentDatatype.FLOAT,\n      normalize: false,\n    },\n    {\n      index: edgeTypeLocation,\n      vertexBuffer: edgeTypeBuffer,\n      componentsPerAttribute: 1,\n      componentDatatype: ComponentDatatype.FLOAT,\n      normalize: false,\n    },\n    {\n      index: silhouetteNormalLocation,\n      vertexBuffer: silhouetteNormalBuffer,\n      componentsPerAttribute: 3,\n      componentDatatype: ComponentDatatype.FLOAT,\n      normalize: false,\n    },\n    {\n      index: faceNormalALocation,\n      vertexBuffer: faceNormalABuffer,\n      componentsPerAttribute: 3,\n      componentDatatype: ComponentDatatype.FLOAT,\n      normalize: false,\n    },\n    {\n      index: faceNormalBLocation,\n      vertexBuffer: faceNormalBBuffer,\n      componentsPerAttribute: 3,\n      componentDatatype: ComponentDatatype.FLOAT,\n      normalize: false,\n    },\n  ];\n\n  // Get feature ID from original geometry\n  const primitive = renderResources.runtimePrimitive.primitive;\n  const getFeatureIdForEdge = function () {\n    // Try to get the first feature ID from the original primitive\n    if (defined(primitive.featureIds) && primitive.featureIds.length > 0) {\n      const firstFeatureIdSet = primitive.featureIds[0];\n\n      // Handle FeatureIdAttribute objects directly using setIndex\n      if (defined(firstFeatureIdSet.setIndex)) {\n        const featureIdAttribute = primitive.attributes.find(\n          (attr) =>\n            attr.semantic === VertexAttributeSemantic.FEATURE_ID &&\n            attr.setIndex === firstFeatureIdSet.setIndex,\n        );\n\n        if (defined(featureIdAttribute)) {\n          const featureIds = defined(featureIdAttribute.typedArray)\n            ? featureIdAttribute.typedArray\n            : ModelReader.readAttributeAsTypedArray(featureIdAttribute);\n\n          // Create edge feature ID buffer based on edge indices\n          const edgeFeatureIds = new Float32Array(totalVerts);\n          for (let i = 0; i < numEdges; i++) {\n            const a = edgeIndices[i * 2];\n            const featureId = a < featureIds.length ? featureIds[a] : 0;\n            edgeFeatureIds[i * 2] = featureId;\n            edgeFeatureIds[i * 2 + 1] = featureId;\n          }\n\n          return edgeFeatureIds;\n        }\n      }\n    }\n\n    return undefined;\n  };\n\n  const edgeFeatureIds = getFeatureIdForEdge();\n  const hasEdgeFeatureIds = defined(edgeFeatureIds);\n\n  if (hasEdgeFeatureIds) {\n    const edgeFeatureIdBuffer = Buffer.createVertexBuffer({\n      context,\n      typedArray: edgeFeatureIds,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n\n    attributes.push({\n      index: edgeFeatureIdLocation,\n      vertexBuffer: edgeFeatureIdBuffer,\n      componentsPerAttribute: 1,\n      componentDatatype: ComponentDatatype.FLOAT,\n      normalize: false,\n    });\n  }\n\n  const vertexArray = new VertexArray({ context, indexBuffer, attributes });\n\n  if (!vertexArray || totalVerts === 0 || totalVerts % 2 !== 0) {\n    return undefined;\n  }\n\n  return {\n    vertexArray,\n    indexBuffer,\n    indexCount: totalVerts,\n    hasEdgeFeatureIds,\n  };\n}\n\nexport default EdgeVisibilityPipelineStage;\n"],"names":["EdgeVisibilityPipelineStage","name","process","renderResources","primitive","frameState","edgeVisibility","edgeVisibilityRequested","shaderBuilder","addDefine","undefined","BOTH","FRAGMENT","addFragmentLines","addUniform","edgeTypeLocation","addAttribute","addVarying","edgeFeatureIdLocation","silhouetteNormalLocation","faceNormalALocation","faceNormalBLocation","addFunctionLines","adjacencyData","buildTriangleAdjacency","edgeResult","extractVisibleEdges","edgeIndices","length","edgeFaceNormals","generateEdgeFaceNormals","edgeGeometry","createCPULineEdgeGeometry","edgeData","context","hasEdgeFeatureIds","uniformMap","u_isEdgePass","vertexArray","indexCount","primitiveType","LINES","pass","CESIUM_3D_TILE_EDGES","indices","edgeMap","Map","faceNormals","Float32Array","triangleCount","triangleIndexArray","typedArray","Math","floor","positionAttribute","getAttributeBySemantic","POSITION","positions","readAttributeAsTypedArray","quantization","octEncoded","count","dequantized","offset","quantizedVolumeOffset","step","quantizedVolumeStepSize","i","x","y","z","scratchP0","scratchP1","scratchP2","scratchE1","scratchE2","scratchCross","processEdge","a","b","triIndex","edgeKey","list","get","set","push","t","base","i0","i1","i2","i0o","i1o","i2o","subtract","cross","normalize","numEdges","triangleList","tA","aBase","nAx","nAy","nAz","nBx","nBy","nBz","tB","bBase","baseIdx","visibility","vertexCount","attributes","seenEdgeHashes","Set","silhouetteEdgeCount","edgeIndex","totalIndices","v0","v1","v2","e","byteIndex","bitPairOffset","byte","visibility2Bit","shouldIncludeEdge","small","min","big","max","hash","has","add","mateVertexIndex","edgeType","triangleIndex","currentTriangleVertices","vertsPerEdge","totalVerts","positionLocation","runtimePrimitive","srcPos","edgePosArray","edgeTypeArray","silhouetteNormalArray","faceNormalAArray","faceNormalBArray","p","maxSrcVertex","normalIdx","ax","ay","az","bx","by","bz","rawType","normalX","normalY","normalZ","silhouetteNormals","normal","faceNormalIdx","normalAX","normalAY","normalAZ","normalBX","normalBY","normalBZ","edgePosBuffer","createVertexBuffer","usage","STATIC_DRAW","edgeTypeBuffer","silhouetteNormalBuffer","faceNormalABuffer","faceNormalBBuffer","useU32","idx","Array","indexBuffer","createIndexBuffer","Uint32Array","Uint16Array","indexDatatype","UNSIGNED_INT","UNSIGNED_SHORT","index","vertexBuffer","componentsPerAttribute","componentDatatype","FLOAT","getFeatureIdForEdge","featureIds","firstFeatureIdSet","setIndex","featureIdAttribute","find","attr","semantic","FEATURE_ID","edgeFeatureIds","featureId","edgeFeatureIdBuffer"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11112, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/SelectedFeatureIdPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport SelectedFeatureIdStageCommon from \"../../Shaders/Model/SelectedFeatureIdStageCommon.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\n/**\n * The selected feature ID pipeline stage is responsible for handling the\n * set of feature IDs selected for styling/picking.\n *\n * @namespace SelectedFeatureIdPipelineStage\n * @private\n */\nconst SelectedFeatureIdPipelineStage = {\n  name: \"SelectedFeatureIdPipelineStage\", // Helps with debugging\n\n  STRUCT_ID_SELECTED_FEATURE: \"SelectedFeature\",\n  STRUCT_NAME_SELECTED_FEATURE: \"SelectedFeature\",\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render resources:\n * <ul>\n *  <li>sets the defines for the feature ID attribute to use for styling/picking</li>\n *  <li>adds fields to the SelectedFeature struct in the shader</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n */\nSelectedFeatureIdPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  renderResources.hasPropertyTable = true;\n\n  const model = renderResources.model;\n  const node = renderResources.runtimeNode.node;\n  const selectedFeatureIds = getSelectedFeatureIds(model, node, primitive);\n  const shaderDestination = selectedFeatureIds.shaderDestination;\n\n  shaderBuilder.addDefine(\n    \"HAS_SELECTED_FEATURE_ID\",\n    undefined,\n    shaderDestination,\n  );\n\n  // Add a define to insert the variable to use.\n  // Example: #define SELECTED_FEATURE_ID featureId_1\n  // This corresponds to featureIds.featureId_1\n  shaderBuilder.addDefine(\n    \"SELECTED_FEATURE_ID\",\n    selectedFeatureIds.variableName,\n    shaderDestination,\n  );\n\n  // Add a define to the shader to distinguish feature ID attributes from\n  // textures. This is needed for determining where to filter features\n  // by pass type.\n  shaderBuilder.addDefine(\n    selectedFeatureIds.featureIdDefine,\n    undefined,\n    shaderDestination,\n  );\n\n  updateFeatureStruct(shaderBuilder);\n\n  const nullFeatureId = selectedFeatureIds.featureIds.nullFeatureId;\n  const uniformMap = renderResources.uniformMap;\n  if (defined(nullFeatureId)) {\n    shaderBuilder.addDefine(\n      \"HAS_NULL_FEATURE_ID\",\n      undefined,\n      shaderDestination,\n    );\n    shaderBuilder.addUniform(\"int\", \"model_nullFeatureId\", shaderDestination);\n    uniformMap.model_nullFeatureId = function () {\n      return nullFeatureId;\n    };\n  }\n\n  if (selectedFeatureIds.shaderDestination === ShaderDestination.BOTH) {\n    shaderBuilder.addVertexLines(SelectedFeatureIdStageCommon);\n  }\n  shaderBuilder.addFragmentLines(SelectedFeatureIdStageCommon);\n};\n\nfunction getFeatureIdDefine(featureIds) {\n  if (featureIds instanceof ModelComponents.FeatureIdTexture) {\n    return \"HAS_SELECTED_FEATURE_ID_TEXTURE\";\n  }\n\n  return \"HAS_SELECTED_FEATURE_ID_ATTRIBUTE\";\n}\n\nfunction getShaderDestination(featureIds) {\n  // Feature ID textures are only supported in the fragment shader.\n  if (featureIds instanceof ModelComponents.FeatureIdTexture) {\n    return ShaderDestination.FRAGMENT;\n  }\n\n  return ShaderDestination.BOTH;\n}\n\nfunction getSelectedFeatureIds(model, node, primitive) {\n  let variableName;\n  let featureIds;\n  // Check instances first, as this is the most specific type of\n  // feature ID\n  if (defined(node.instances)) {\n    featureIds = ModelUtility.getFeatureIdsByLabel(\n      node.instances.featureIds,\n      model.instanceFeatureIdLabel,\n    );\n\n    if (defined(featureIds)) {\n      // Either label could be used here, but prefer label as it may be more\n      // meaningful when debugging\n      variableName = featureIds.label ?? featureIds.positionalLabel;\n      return {\n        featureIds: featureIds,\n        variableName: variableName,\n        shaderDestination: getShaderDestination(featureIds),\n        featureIdDefine: getFeatureIdDefine(featureIds),\n      };\n    }\n  }\n\n  featureIds = ModelUtility.getFeatureIdsByLabel(\n    primitive.featureIds,\n    model.featureIdLabel,\n  );\n  // again, prefer label for being more descriptive\n  variableName = featureIds.label ?? featureIds.positionalLabel;\n  return {\n    featureIds: featureIds,\n    variableName: variableName,\n    shaderDestination: getShaderDestination(featureIds),\n    featureIdDefine: getFeatureIdDefine(featureIds),\n  };\n}\n\n/**\n * Populate the \"SelectedFeature\" struct in the shaders that holds information about the \"active\" (used for picking/styling) feature.\n * The struct is always added to the shader by the GeometryPipelineStage (required for compilation). The SelectedFeature struct looks\n * as follows:\n *\n * struct SelectedFeature {\n *   int id;\n *   vec2 st;\n *   vec4 color;\n * }\n *\n * @private\n */\nfunction updateFeatureStruct(shaderBuilder) {\n  shaderBuilder.addStructField(\n    SelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE,\n    \"int\",\n    \"id\",\n  );\n\n  shaderBuilder.addStructField(\n    SelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE,\n    \"vec2\",\n    \"st\",\n  );\n\n  shaderBuilder.addStructField(\n    SelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE,\n    \"vec4\",\n    \"color\",\n  );\n}\n\nexport default SelectedFeatureIdPipelineStage;\n"],"names":["SelectedFeatureIdPipelineStage","name","STRUCT_ID_SELECTED_FEATURE","STRUCT_NAME_SELECTED_FEATURE","process","renderResources","primitive","frameState","shaderBuilder","hasPropertyTable","model","node","runtimeNode","selectedFeatureIds","getSelectedFeatureIds","shaderDestination","addDefine","undefined","variableName","featureIdDefine","updateFeatureStruct","nullFeatureId","featureIds","uniformMap","addUniform","model_nullFeatureId","BOTH","addVertexLines","addFragmentLines","getFeatureIdDefine","FeatureIdTexture","getShaderDestination","FRAGMENT","instances","getFeatureIdsByLabel","instanceFeatureIdLabel","label","positionalLabel","featureIdLabel","addStructField"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11242, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/GeometryPipelineStage.js"],"sourcesContent":["import ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport GeometryStageFS from \"../../Shaders/Model/GeometryStageFS.js\";\nimport GeometryStageVS from \"../../Shaders/Model/GeometryStageVS.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ModelType from \"./ModelType.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport SelectedFeatureIdPipelineStage from \"./SelectedFeatureIdPipelineStage.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * The geometry pipeline stage processes the vertex attributes of a primitive.\n *\n * @namespace GeometryPipelineStage\n *\n * @private\n */\nconst GeometryPipelineStage = {\n  name: \"GeometryPipelineStage\", // Helps with debugging\n\n  STRUCT_ID_PROCESSED_ATTRIBUTES_VS: \"ProcessedAttributesVS\",\n  STRUCT_ID_PROCESSED_ATTRIBUTES_FS: \"ProcessedAttributesFS\",\n  STRUCT_NAME_PROCESSED_ATTRIBUTES: \"ProcessedAttributes\",\n  FUNCTION_ID_INITIALIZE_ATTRIBUTES: \"initializeAttributes\",\n  FUNCTION_SIGNATURE_INITIALIZE_ATTRIBUTES:\n    \"void initializeAttributes(out ProcessedAttributes attributes)\",\n  FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS: \"setDynamicVaryingsVS\",\n  FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS: \"setDynamicVaryingsFS\",\n  FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS:\n    \"void setDynamicVaryings(inout ProcessedAttributes attributes)\",\n};\n\n/**\n * This pipeline stage processes the vertex attributes of a primitive,\n * adding attribute declarations to the shaders, adding attribute objects to the\n * render resources, and setting define flags as needed.\n *\n * Processes a primitive. This stage modifies the following parts of the render resources:\n * <ul>\n *  <li> adds attribute and varying declarations for the vertex attributes in the vertex and fragment shaders\n *  <li> creates the objects required to create VertexArrays\n *  <li> sets the flag for point primitive types\n * </ul>\n *\n * If the scene is in either 2D or CV mode, this stage also:\n * <ul>\n *  <li> adds a struct field for the 2D positions\n *  <li> adds an additional attribute object and declaration if the node containing this primitive is not instanced\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nGeometryPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const { shaderBuilder, model } = renderResources;\n\n  // These structs are similar, though the fragment shader version has a couple\n  // additional fields.\n  shaderBuilder.addStruct(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_VS,\n    \"ProcessedAttributes\",\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addStruct(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,\n    \"ProcessedAttributes\",\n    ShaderDestination.FRAGMENT,\n  );\n\n  // The Feature struct is always added since it's required for compilation.\n  // It may be unused if features are not present.\n  shaderBuilder.addStruct(\n    SelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE,\n    SelectedFeatureIdPipelineStage.STRUCT_NAME_SELECTED_FEATURE,\n    ShaderDestination.BOTH,\n  );\n\n  // This initialization function is only needed in the vertex shader,\n  // it assigns the non-quantized attribute struct fields from the\n  // physical attributes\n  shaderBuilder.addFunction(\n    GeometryPipelineStage.FUNCTION_ID_INITIALIZE_ATTRIBUTES,\n    GeometryPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_ATTRIBUTES,\n    ShaderDestination.VERTEX,\n  );\n\n  // Positions in other coordinate systems need more variables\n  shaderBuilder.addVarying(\"vec3\", \"v_positionWC\");\n  shaderBuilder.addVarying(\"vec3\", \"v_positionEC\");\n  shaderBuilder.addStructField(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,\n    \"vec3\",\n    \"positionWC\",\n  );\n  shaderBuilder.addStructField(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,\n    \"vec3\",\n    \"positionEC\",\n  );\n\n  // Though they have identical signatures, the implementation is different\n  // between vertex and fragment shaders. The VS stores attributes in\n  // varyings, while the FS unpacks the varyings for use by other stages.\n  shaderBuilder.addFunction(\n    GeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS,\n    GeometryPipelineStage.FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addFunction(\n    GeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS,\n    GeometryPipelineStage.FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // .pnts point clouds store sRGB color rather than linear color\n  if (model.type === ModelType.TILE_PNTS) {\n    shaderBuilder.addDefine(\n      \"HAS_SRGB_COLOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  // Attributes, structs, and functions will need to be modified for 2D / CV.\n  const use2D =\n    frameState.mode !== SceneMode.SCENE3D &&\n    !frameState.scene3DOnly &&\n    model._projectTo2D;\n\n  // If the model is instanced, the work for 2D projection will have been done\n  // in InstancingPipelineStage. The attribute struct will be updated with\n  // position2D, but nothing else should be modified.\n  const instanced = defined(renderResources.runtimeNode.node.instances);\n\n  // If the scene is in 3D or the model is instanced, the 2D position attribute\n  // is not needed, so don't increment attributeIndex.\n  const incrementIndexFor2D = use2D && !instanced;\n  const length = primitive.attributes.length;\n  for (let i = 0; i < length; i++) {\n    const attribute = primitive.attributes[i];\n    const attributeLocationCount = AttributeType.getAttributeLocationCount(\n      attribute.type,\n    );\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(attribute.buffer) && !defined(attribute.constant)) {\n      throw new DeveloperError(\n        \"Attributes must be provided as a Buffer or constant value\",\n      );\n    }\n    //>>includeEnd('debug');\n\n    const isPositionAttribute =\n      attribute.semantic === VertexAttributeSemantic.POSITION;\n\n    let index;\n    if (attributeLocationCount > 1) {\n      index = renderResources.attributeIndex;\n      renderResources.attributeIndex += attributeLocationCount;\n    } else if (isPositionAttribute && !incrementIndexFor2D) {\n      index = 0;\n    } else {\n      index = renderResources.attributeIndex++;\n    }\n\n    processAttribute(\n      renderResources,\n      attribute,\n      index,\n      attributeLocationCount,\n      use2D,\n      instanced,\n    );\n  }\n\n  handleBitangents(shaderBuilder, primitive.attributes);\n\n  if (primitive.primitiveType === PrimitiveType.POINTS) {\n    shaderBuilder.addDefine(\"PRIMITIVE_TYPE_POINTS\");\n  }\n\n  shaderBuilder.addVertexLines(GeometryStageVS);\n  shaderBuilder.addFragmentLines(GeometryStageFS);\n};\n\nfunction processAttribute(\n  renderResources,\n  attribute,\n  attributeIndex,\n  attributeLocationCount,\n  use2D,\n  instanced,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const attributeInfo = ModelUtility.getAttributeInfo(attribute);\n\n  // This indicates to only modify the resources for 2D if the model is\n  // not instanced.\n  const modifyFor2D = use2D && !instanced;\n\n  if (attributeLocationCount > 1) {\n    // Matrices are stored as multiple attributes, one per column vector.\n    addMatrixAttributeToRenderResources(\n      renderResources,\n      attribute,\n      attributeIndex,\n      attributeLocationCount,\n    );\n  } else {\n    addAttributeToRenderResources(\n      renderResources,\n      attribute,\n      attributeIndex,\n      modifyFor2D,\n    );\n  }\n\n  addAttributeDeclaration(shaderBuilder, attributeInfo, modifyFor2D);\n  addVaryingDeclaration(shaderBuilder, attributeInfo);\n\n  // For common attributes like normals and tangents, the code is\n  // already in GeometryStageVS, we just need to enable it.\n  if (defined(attribute.semantic)) {\n    addSemanticDefine(shaderBuilder, attribute);\n  }\n\n  // Dynamically generate GLSL code for the current attribute.\n  // For 2D projection, the position2D field will always be added\n  // to the attributes struct, even if the model is instanced.\n  updateAttributesStruct(shaderBuilder, attributeInfo, use2D);\n  updateInitializeAttributesFunction(shaderBuilder, attributeInfo, modifyFor2D);\n  updateSetDynamicVaryingsFunction(shaderBuilder, attributeInfo);\n}\n\nfunction addSemanticDefine(shaderBuilder, attribute) {\n  const { semantic, setIndex } = attribute;\n  switch (semantic) {\n    case VertexAttributeSemantic.NORMAL:\n      shaderBuilder.addDefine(\"HAS_NORMALS\");\n      break;\n    case VertexAttributeSemantic.TANGENT:\n      shaderBuilder.addDefine(\"HAS_TANGENTS\");\n      break;\n    case VertexAttributeSemantic.FEATURE_ID:\n      // `_FEATURE_ID starts with an underscore so no need to double the\n      // underscore.\n      shaderBuilder.addDefine(`HAS${semantic}_${setIndex}`);\n      break;\n    case VertexAttributeSemantic.TEXCOORD:\n    case VertexAttributeSemantic.COLOR:\n      shaderBuilder.addDefine(`HAS_${semantic}_${setIndex}`);\n  }\n}\n\nfunction addAttributeToRenderResources(\n  renderResources,\n  attribute,\n  attributeIndex,\n  modifyFor2D,\n) {\n  const { quantization, semantic, setIndex } = attribute;\n  const { type, componentDatatype } = defined(quantization)\n    ? quantization\n    : attribute;\n\n  if (\n    semantic === VertexAttributeSemantic.FEATURE_ID &&\n    setIndex >= renderResources.featureIdVertexAttributeSetIndex\n  ) {\n    renderResources.featureIdVertexAttributeSetIndex = setIndex + 1;\n  }\n\n  // The position attribute should always be in the first index.\n  const isPositionAttribute = semantic === VertexAttributeSemantic.POSITION;\n  const index = isPositionAttribute ? 0 : attributeIndex;\n  const componentsPerAttribute = AttributeType.getNumberOfComponents(type);\n\n  const vertexAttribute = {\n    index: index,\n    value: defined(attribute.buffer) ? undefined : attribute.constant,\n    vertexBuffer: attribute.buffer,\n    count: attribute.count,\n    componentsPerAttribute: componentsPerAttribute,\n    componentDatatype: componentDatatype,\n    offsetInBytes: attribute.byteOffset,\n    strideInBytes: attribute.byteStride,\n    normalize: attribute.normalized,\n  };\n\n  renderResources.attributes.push(vertexAttribute);\n\n  if (!isPositionAttribute || !modifyFor2D) {\n    return;\n  }\n\n  // Add an additional attribute for the projected positions in 2D / CV.\n  const buffer2D = renderResources.runtimePrimitive.positionBuffer2D;\n  const positionAttribute2D = {\n    index: attributeIndex,\n    vertexBuffer: buffer2D,\n    count: attribute.count,\n    componentsPerAttribute: componentsPerAttribute,\n    componentDatatype: ComponentDatatype.FLOAT, // Projected positions will always be floats.\n    offsetInBytes: 0,\n    strideInBytes: undefined,\n    normalize: attribute.normalized,\n  };\n\n  renderResources.attributes.push(positionAttribute2D);\n}\n\nfunction addMatrixAttributeToRenderResources(\n  renderResources,\n  attribute,\n  attributeIndex,\n  columnCount,\n) {\n  const { quantization, normalized } = attribute;\n  const { type, componentDatatype } = defined(quantization)\n    ? quantization\n    : attribute;\n\n  // componentCount is either 4, 9 or 16\n  const componentCount = AttributeType.getNumberOfComponents(type);\n  // componentsPerColumn is either 2, 3, or 4\n  const componentsPerColumn = componentCount / columnCount;\n\n  const componentSizeInBytes =\n    ComponentDatatype.getSizeInBytes(componentDatatype);\n\n  const columnLengthInBytes = componentsPerColumn * componentSizeInBytes;\n\n  // The stride between corresponding columns of two matrices is constant\n  // regardless of where you start\n  const strideInBytes = attribute.byteStride;\n\n  for (let i = 0; i < columnCount; i++) {\n    const offsetInBytes = attribute.byteOffset + i * columnLengthInBytes;\n\n    // upload a single column vector.\n    const columnAttribute = {\n      index: attributeIndex + i,\n      vertexBuffer: attribute.buffer,\n      componentsPerAttribute: componentsPerColumn,\n      componentDatatype: componentDatatype,\n      offsetInBytes: offsetInBytes,\n      strideInBytes: strideInBytes,\n      normalize: normalized,\n    };\n\n    renderResources.attributes.push(columnAttribute);\n  }\n}\n\nfunction addVaryingDeclaration(shaderBuilder, attributeInfo) {\n  const variableName = attributeInfo.variableName;\n  let varyingName = `v_${variableName}`;\n\n  let glslType;\n  if (variableName === \"normalMC\") {\n    // though the attribute is in model coordinates, the varying is\n    // in eye coordinates.\n    varyingName = \"v_normalEC\";\n    glslType = attributeInfo.glslType;\n  } else if (variableName === \"tangentMC\") {\n    // Tangent's glslType is vec4, but in the shader it is split into\n    // vec3 tangent and vec3 bitangent\n    glslType = \"vec3\";\n    // like normalMC, the varying is converted to eye coordinates\n    varyingName = \"v_tangentEC\";\n  } else {\n    glslType = attributeInfo.glslType;\n  }\n\n  shaderBuilder.addVarying(glslType, varyingName);\n}\n\nfunction addAttributeDeclaration(shaderBuilder, attributeInfo, modifyFor2D) {\n  const semantic = attributeInfo.attribute.semantic;\n  const variableName = attributeInfo.variableName;\n\n  let attributeName;\n  let glslType;\n  if (attributeInfo.isQuantized) {\n    attributeName = `a_quantized_${variableName}`;\n    glslType = attributeInfo.quantizedGlslType;\n  } else {\n    attributeName = `a_${variableName}`;\n    glslType = attributeInfo.glslType;\n  }\n\n  const isPosition = semantic === VertexAttributeSemantic.POSITION;\n  if (isPosition) {\n    shaderBuilder.setPositionAttribute(glslType, attributeName);\n  } else {\n    shaderBuilder.addAttribute(glslType, attributeName);\n  }\n\n  if (isPosition && modifyFor2D) {\n    shaderBuilder.addAttribute(\"vec3\", \"a_position2D\");\n  }\n}\n\nfunction updateAttributesStruct(shaderBuilder, attributeInfo, use2D) {\n  const vsStructId = GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_VS;\n  const fsStructId = GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS;\n  const { variableName, glslType } = attributeInfo;\n\n  if (variableName === \"tangentMC\") {\n    // The w component of the tangent is only used for computing the bitangent,\n    // so it can be separated from the other tangent components.\n    shaderBuilder.addStructField(vsStructId, \"vec3\", \"tangentMC\");\n    shaderBuilder.addStructField(vsStructId, \"float\", \"tangentSignMC\");\n    // The tangent is in model coordinates in the vertex shader\n    // but in eye space in the fragment coordinates\n    shaderBuilder.addStructField(fsStructId, \"vec3\", \"tangentEC\");\n  } else if (variableName === \"normalMC\") {\n    // Normals are in model coordinates in the vertex shader but in eye\n    // coordinates in the fragment shader\n    shaderBuilder.addStructField(vsStructId, \"vec3\", \"normalMC\");\n    shaderBuilder.addStructField(fsStructId, \"vec3\", \"normalEC\");\n  } else {\n    shaderBuilder.addStructField(vsStructId, glslType, variableName);\n    shaderBuilder.addStructField(fsStructId, glslType, variableName);\n  }\n\n  if (variableName === \"positionMC\" && use2D) {\n    shaderBuilder.addStructField(vsStructId, \"vec3\", \"position2D\");\n  }\n}\n\nfunction updateInitializeAttributesFunction(\n  shaderBuilder,\n  attributeInfo,\n  use2D,\n) {\n  const functionId = GeometryPipelineStage.FUNCTION_ID_INITIALIZE_ATTRIBUTES;\n  const variableName = attributeInfo.variableName;\n\n  // If the scene is in 2D / CV mode, this line should always be added\n  // regardless of whether the data is quantized.\n  const use2DPosition = variableName === \"positionMC\" && use2D;\n  if (use2DPosition) {\n    const line = \"attributes.position2D = a_position2D;\";\n    shaderBuilder.addFunctionLines(functionId, [line]);\n  }\n\n  if (attributeInfo.isQuantized) {\n    // Skip initialization, it will be handled in the dequantization stage.\n    return;\n  }\n\n  const lines = [];\n  if (variableName === \"tangentMC\") {\n    lines.push(\"attributes.tangentMC = a_tangentMC.xyz;\");\n    lines.push(\"attributes.tangentSignMC = a_tangentMC.w;\");\n  } else {\n    lines.push(`attributes.${variableName} = a_${variableName};`);\n  }\n\n  shaderBuilder.addFunctionLines(functionId, lines);\n}\n\nfunction updateSetDynamicVaryingsFunction(shaderBuilder, attributeInfo) {\n  const { semantic, setIndex } = attributeInfo.attribute;\n  if (defined(semantic) && !defined(setIndex)) {\n    // positions, normals, and tangents are handled statically in\n    // GeometryStageVS\n    return;\n  }\n\n  // In the vertex shader, we want things like\n  // v_texCoord_1 = attributes.texCoord_1;\n  let functionId = GeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS;\n  const variableName = attributeInfo.variableName;\n  let line = `v_${variableName} = attributes.${variableName};`;\n  shaderBuilder.addFunctionLines(functionId, [line]);\n\n  // In the fragment shader, we do the opposite:\n  // attributes.texCoord_1 = v_texCoord_1;\n  functionId = GeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS;\n  line = `attributes.${variableName} = v_${variableName};`;\n  shaderBuilder.addFunctionLines(functionId, [line]);\n}\n\nfunction handleBitangents(shaderBuilder, attributes) {\n  let hasNormals = false;\n  let hasTangents = false;\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    if (attribute.semantic === VertexAttributeSemantic.NORMAL) {\n      hasNormals = true;\n    } else if (attribute.semantic === VertexAttributeSemantic.TANGENT) {\n      hasTangents = true;\n    }\n  }\n\n  // Bitangents are only defined if we have normals and tangents\n  if (!hasNormals || !hasTangents) {\n    return;\n  }\n\n  shaderBuilder.addDefine(\"HAS_BITANGENTS\");\n\n  shaderBuilder.addVarying(\"vec3\", \"v_bitangentEC\");\n  shaderBuilder.addStructField(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_VS,\n    \"vec3\",\n    \"bitangentMC\",\n  );\n  shaderBuilder.addStructField(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,\n    \"vec3\",\n    \"bitangentEC\",\n  );\n}\n\nexport default GeometryPipelineStage;\n"],"names":["GeometryPipelineStage","name","STRUCT_ID_PROCESSED_ATTRIBUTES_VS","STRUCT_ID_PROCESSED_ATTRIBUTES_FS","STRUCT_NAME_PROCESSED_ATTRIBUTES","FUNCTION_ID_INITIALIZE_ATTRIBUTES","FUNCTION_SIGNATURE_INITIALIZE_ATTRIBUTES","FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS","FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS","FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS","process","renderResources","primitive","frameState","shaderBuilder","model","addStruct","VERTEX","FRAGMENT","STRUCT_ID_SELECTED_FEATURE","STRUCT_NAME_SELECTED_FEATURE","BOTH","addFunction","addVarying","addStructField","type","TILE_PNTS","addDefine","undefined","use2D","mode","SCENE3D","scene3DOnly","_projectTo2D","instanced","runtimeNode","node","instances","incrementIndexFor2D","length","attributes","i","attribute","attributeLocationCount","getAttributeLocationCount","buffer","constant","isPositionAttribute","semantic","POSITION","index","attributeIndex","processAttribute","handleBitangents","primitiveType","POINTS","addVertexLines","addFragmentLines","attributeInfo","getAttributeInfo","modifyFor2D","addMatrixAttributeToRenderResources","addAttributeToRenderResources","addAttributeDeclaration","addVaryingDeclaration","addSemanticDefine","updateAttributesStruct","updateInitializeAttributesFunction","updateSetDynamicVaryingsFunction","setIndex","NORMAL","TANGENT","FEATURE_ID","TEXCOORD","COLOR","quantization","componentDatatype","featureIdVertexAttributeSetIndex","componentsPerAttribute","getNumberOfComponents","vertexAttribute","value","vertexBuffer","count","offsetInBytes","byteOffset","strideInBytes","byteStride","normalize","normalized","push","buffer2D","runtimePrimitive","positionBuffer2D","positionAttribute2D","FLOAT","columnCount","componentCount","componentsPerColumn","componentSizeInBytes","getSizeInBytes","columnLengthInBytes","columnAttribute","variableName","varyingName","glslType","attributeName","isQuantized","quantizedGlslType","isPosition","setPositionAttribute","addAttribute","vsStructId","fsStructId","functionId","use2DPosition","line","addFunctionLines","lines","hasNormals","hasTangents"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11627, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ImageryFlags.js"],"sourcesContent":["/**\n * A class containing a set of flags indicating which parts of an\n * <code>ImageryLayer</code> need to be processed.\n *\n * This is used in the <code>ImageryPipelineStage</code> to decide the\n * structure of the function that blends the imagery texture information\n * with the previous pixels.\n *\n * Each flag indicates that at least one of the <code>ImageryLayer</code> objects\n * that are part of the input did <b>not</b> have the default value that\n * was defined via the corresponding <code>ImageryLayer.DEFAULT_...</code>>.\n *\n * Note that the type of the flags can be <code>boolean</code> or\n * <code>number</code>. Users should check for these flags having\n * a 'truthy' or 'falsy' value.\n *\n * @private\n */\nclass ImageryFlags {\n  constructor() {\n    this.alpha = false;\n    this.brightness = false;\n    this.contrast = false;\n    this.hue = false;\n    this.saturation = false;\n    this.gamma = false;\n    this.colorToAlpha = false;\n  }\n}\n\nexport default ImageryFlags;\n"],"names":["ImageryFlags","alpha","brightness","contrast","hue","saturation","gamma","colorToAlpha"],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;CAiBC,GACD,MAAMA;IACJA,aAAc;QACZ,IAAI,CAACC,KAAK,GAAG;QACb,IAAI,CAACC,UAAU,GAAG;QAClB,IAAI,CAACC,QAAQ,GAAG;QAChB,IAAI,CAACC,GAAG,GAAG;QACX,IAAI,CAACC,UAAU,GAAG;QAClB,IAAI,CAACC,KAAK,GAAG;QACb,IAAI,CAACC,YAAY,GAAG;IACtB;AACF;uCAEeP","ignoreList":[0]}},
    {"offset": {"line": 11664, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/CartesianRectangle.js"],"sourcesContent":["/**\n * Internal class for texture coordinate and index range computations.\n *\n * @private\n */\nclass CartesianRectangle {\n  /**\n   * Creates a new instance\n   *\n   * @param {number} [minX=0] The minimum x-coordinate\n   * @param {number} [minY=0] The minimum y-coordinate\n   * @param {number} [maxX=0] The maximum x-coordinate\n   * @param {number} [maxY=0] The maximum y-coordinate\n   */\n  constructor(minX, minY, maxX, maxY) {\n    this._minX = minX ?? 0.0;\n    this._minY = minY ?? 0.0;\n    this._maxX = maxX ?? 0.0;\n    this._maxY = maxY ?? 0.0;\n  }\n\n  /**\n   * Returns the minimum x-coordinate\n   *\n   * @returns {number} The coordinate\n   */\n  get minX() {\n    return this._minX;\n  }\n  set minX(value) {\n    this._minX = value;\n  }\n\n  /**\n   * Returns the minimum y-coordinate\n   *\n   * @returns {number} The coordinate\n   */\n  get minY() {\n    return this._minY;\n  }\n  set minY(value) {\n    this._minY = value;\n  }\n\n  /**\n   * Returns the maximum x-coordinate\n   *\n   * @returns {number} The coordinate\n   */\n  get maxX() {\n    return this._maxX;\n  }\n  set maxX(value) {\n    this._maxX = value;\n  }\n\n  /**\n   * Returns the maximum y-coordinate\n   *\n   * @returns {number} The coordinate\n   */\n  get maxY() {\n    return this._maxY;\n  }\n  set maxY(value) {\n    this._maxY = value;\n  }\n\n  /**\n   * Returns whether this rectangle contains the given coordinates,\n   * using the default containment check, which includes the\n   * minimum point, but excludes the maximum point\n   *\n   * @param {number} x The x-coordinate\n   * @param {number} y The y-coordinate\n   * @returns {boolean} The result\n   */\n  contains(x, y) {\n    return x >= this.minX && x < this.maxX && y >= this.minY && y < this.maxY;\n  }\n\n  /**\n   * Returns whether this rectangle contains the given coordinates,\n   * excluding the border\n   *\n   * @param {number} x The x-coordinate\n   * @param {number} y The y-coordinate\n   * @returns {boolean} The result\n   */\n  containsExclusive(x, y) {\n    return x > this.minX && x < this.maxX && y > this.minY && y < this.maxY;\n  }\n\n  /**\n   * Returns whether this rectangle contains the given coordinates,\n   * including the border\n   *\n   * @param {number} x The x-coordinate\n   * @param {number} y The y-coordinate\n   * @returns {boolean} The result\n   */\n  containsInclusive(x, y) {\n    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n  }\n}\n\nexport default CartesianRectangle;\n"],"names":["CartesianRectangle","minX","minY","maxX","maxY","_minX","_minY","_maxX","_maxY","value","contains","x","y","containsExclusive","containsInclusive"],"mappings":";;;;AAAA;;;;CAIC,GACD,MAAMA;IACJ;;;;;;;GAOC,GACDA,YAAYC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,IAAI,CAAE;QAClC,IAAI,CAACC,KAAK,GAAGJ,QAAQ;QACrB,IAAI,CAACK,KAAK,GAAGJ,QAAQ;QACrB,IAAI,CAACK,KAAK,GAAGJ,QAAQ;QACrB,IAAI,CAACK,KAAK,GAAGJ,QAAQ;IACvB;IAEA;;;;GAIC,GACD,IAAIH,OAAO;QACT,OAAO,IAAI,CAACI,KAAK;IACnB;IACA,IAAIJ,KAAKQ,KAAK,EAAE;QACd,IAAI,CAACJ,KAAK,GAAGI;IACf;IAEA;;;;GAIC,GACD,IAAIP,OAAO;QACT,OAAO,IAAI,CAACI,KAAK;IACnB;IACA,IAAIJ,KAAKO,KAAK,EAAE;QACd,IAAI,CAACH,KAAK,GAAGG;IACf;IAEA;;;;GAIC,GACD,IAAIN,OAAO;QACT,OAAO,IAAI,CAACI,KAAK;IACnB;IACA,IAAIJ,KAAKM,KAAK,EAAE;QACd,IAAI,CAACF,KAAK,GAAGE;IACf;IAEA;;;;GAIC,GACD,IAAIL,OAAO;QACT,OAAO,IAAI,CAACI,KAAK;IACnB;IACA,IAAIJ,KAAKK,KAAK,EAAE;QACd,IAAI,CAACD,KAAK,GAAGC;IACf;IAEA;;;;;;;;GAQC,GACDC,SAASC,CAAC,EAAEC,CAAC,EAAE;QACb,OAAOD,KAAK,IAAI,CAACV,IAAI,IAAIU,IAAI,IAAI,CAACR,IAAI,IAAIS,KAAK,IAAI,CAACV,IAAI,IAAIU,IAAI,IAAI,CAACR,IAAI;IAC3E;IAEA;;;;;;;GAOC,GACDS,kBAAkBF,CAAC,EAAEC,CAAC,EAAE;QACtB,OAAOD,IAAI,IAAI,CAACV,IAAI,IAAIU,IAAI,IAAI,CAACR,IAAI,IAAIS,IAAI,IAAI,CAACV,IAAI,IAAIU,IAAI,IAAI,CAACR,IAAI;IACzE;IAEA;;;;;;;GAOC,GACDU,kBAAkBH,CAAC,EAAEC,CAAC,EAAE;QACtB,OAAOD,KAAK,IAAI,CAACV,IAAI,IAAIU,KAAK,IAAI,CAACR,IAAI,IAAIS,KAAK,IAAI,CAACV,IAAI,IAAIU,KAAK,IAAI,CAACR,IAAI;IAC7E;AACF;uCAEeJ","ignoreList":[0]}},
    {"offset": {"line": 11763, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ImageryCoverage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport Rectangle from \"../../Core/Rectangle.js\";\n\nimport CartesianRectangle from \"./CartesianRectangle.js\";\n\nconst imageryBoundsScratch = new Rectangle();\nconst overlappedRectangleScratch = new Rectangle();\nconst clippedRectangleScratch = new Rectangle();\nconst nativeInputRectangleScratch = new Rectangle();\nconst nativeImageryBoundsScratch = new Rectangle();\nconst nativeClippedImageryBoundsScratch = new Rectangle();\n\n/**\n * A class containing information about a piece of imagery.\n *\n * This represents the result of computing the imagery tiles that\n * are covered by a given <code>Rectangle</code> (and which part\n * of that imagery is covered, in terms of texture coordinates).\n *\n * This class represents a plain structure, without member functions.\n * Instances are created with the <code>createImageryCoverages</code>\n * function.\n *\n * The instances are used by the <code>ModelPrimitiveImagery</code>, to\n * represent the imagery tiles that are covered by the cartographic\n * bounding rectangle of the primitive positions.\n *\n * Implementation note for ImageryCoverage:\n *\n * Some of the static functions in this class have been extracted from\n * <code>ImageryLayer.prototype._createTileImagerySkeletons</code>\n * See https://github.com/CesiumGS/cesium/blob/5eaa2280f495d8f300d9e1f0497118c97aec54c8/packages/engine/Source/Scene/ImageryLayer.js#L700\n * An instance of this class roughly corresponds to the <code>TileImagery</code>\n * that is created there.\n *\n * @private\n */\nclass ImageryCoverage {\n  /**\n   * Creates a new instance.\n   *\n   * @param {number} x x-coordinate of the imagery tile\n   * @param {number} y y-coordinate of the imagery tile\n   * @param {number} level level of the imagery tile\n   * @param {CartesianRectangle} textureCoordinateRectangle The texture coordinate\n   * rectangle from the imagery tile that is covered\n   * @param {Imagery} imagery The imagery\n   */\n  constructor(x, y, level, textureCoordinateRectangle, imagery) {\n    this._x = x;\n    this._y = y;\n    this._level = level;\n    this._textureCoordinateRectangle = textureCoordinateRectangle;\n    this._imagery = imagery;\n  }\n\n  /**\n   * The x-coordinate of the imagery tile, typically correlated with longitude\n   *\n   * @type {number}\n   * @readonly\n   */\n  get x() {\n    return this._x;\n  }\n\n  /**\n   * The y-coordinate of the imagery tile, typically correlated with latitude\n   *\n   * @type {number}\n   * @readonly\n   */\n  get y() {\n    return this._y;\n  }\n\n  /**\n   * The level of the imagery tile\n   *\n   * @type {number}\n   * @readonly\n   */\n  get level() {\n    return this._level;\n  }\n\n  /**\n   * The texture coordinate range that is covered from the\n   * imagery tile.\n   *\n   * This is a <code>CartesianRectangle</code> that contains the\n   * (minU, minV, maxU, maxV) coordinate range.\n   *\n   * Clients may not modify the returned instance.\n   *\n   * @type {CartesianRectangle}\n   * @readonly\n   */\n  get textureCoordinateRectangle() {\n    return this._textureCoordinateRectangle;\n  }\n\n  /**\n   * Returns the imagery\n   *\n   * @type {Imagery}\n   * @readonly\n   */\n  get imagery() {\n    return this._imagery;\n  }\n\n  /**\n   * Computes the <code>ImageryCoverage</code> objects that describe the imagery\n   * tiles and the respective texture coordinates that are covered by the given\n   * input rectangle in the given imagery data.\n   *\n   * The given imagery level will be clamped if necessary, to be in the valid\n   * range for the imagery provider of the given imagery layer.\n   *\n   * @param {Rectangle} inputRectangle The input rectangle (e.g. tile bounds)\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {number} inputImageryLevel The level for which the imagery coverage\n   * should be computed.\n   * @returns {ImageryCoverage[]} The objects describing the covered imagery\n   * and the respective texture coordinates\n   */\n  static createImageryCoverages(\n    inputRectangle,\n    imageryLayer,\n    inputImageryLevel,\n  ) {\n    if (!imageryLayer.show) {\n      return [];\n    }\n\n    const imageryProvider = imageryLayer.imageryProvider;\n    const imageryLevel = ImageryCoverage._clampImageryLevel(\n      imageryProvider,\n      inputImageryLevel,\n    );\n\n    // Compute the range, in integer coordinates, of imagery\n    // tiles that are covered by the input rectangle\n    const imageryBounds = Rectangle.intersection(\n      imageryProvider.rectangle,\n      imageryLayer.rectangle,\n      imageryBoundsScratch,\n    );\n    const imageryTilingScheme = imageryProvider.tilingScheme;\n    const imageryRange = ImageryCoverage._computeImageryRange(\n      inputRectangle,\n      imageryBounds,\n      imageryTilingScheme,\n      imageryLevel,\n    );\n\n    // Convert the input rectangle and the imagery bounds into\n    // the native coordinate system of the tiling scheme\n    const nativeInputRectangle = nativeInputRectangleScratch;\n    imageryTilingScheme.rectangleToNativeRectangle(\n      inputRectangle,\n      nativeInputRectangle,\n    );\n    const nativeImageryBounds = nativeImageryBoundsScratch;\n    imageryTilingScheme.rectangleToNativeRectangle(\n      imageryBounds,\n      nativeImageryBounds,\n    );\n\n    // A function that returns an imagery rectangle, based on (x, y, level),\n    // clipped to the imagery bounds (or undefined if there is no intersection\n    // between the imagery rectangle and the bounds)\n    const computeClippedImageryRectangle = (x, y, level) => {\n      const localImageryRectangle = imageryTilingScheme.tileXYToRectangle(\n        x,\n        y,\n        level,\n      );\n      const localClippedImageryRectangle = Rectangle.intersection(\n        localImageryRectangle,\n        imageryBounds,\n        clippedRectangleScratch,\n      );\n      if (!defined(localClippedImageryRectangle)) {\n        return undefined;\n      }\n      const nativeClippedImageryBounds = nativeClippedImageryBoundsScratch;\n      imageryTilingScheme.rectangleToNativeRectangle(\n        localClippedImageryRectangle,\n        nativeClippedImageryBounds,\n      );\n      return nativeClippedImageryBounds;\n    };\n\n    const imageryCoverages = ImageryCoverage._computeImageryCoverages(\n      imageryLayer,\n      imageryRange,\n      imageryLevel,\n      nativeInputRectangle,\n      computeClippedImageryRectangle,\n    );\n    return imageryCoverages;\n  }\n\n  /**\n   * Validate the given imagery level against the constraints of the\n   * given imagery provider.\n   *\n   * This will clamp the given level to be in the range\n   * <code>[minimumLevel, maximumLevel)</code> that is\n   * defined by the given imagery provider (and cut off\n   * any fractional part that the input may have)\n   *\n   * @param {ImageryProvider} imageryProvider The imagery provider\n   * @param {number} imageryLevel The imagery level\n   * @returns {number} The validated level\n   */\n  static _clampImageryLevel(imageryProvider, imageryLevel) {\n    const minimumLevel = imageryProvider.minimumLevel ?? 0;\n    const maximumLevel =\n      imageryProvider.maximumLevel ?? Number.POSITIVE_INFINITY;\n    const clampedImageryLevel = Math.min(\n      maximumLevel - 1,\n      Math.max(minimumLevel, imageryLevel),\n    );\n    const validImageryLevel = Math.floor(clampedImageryLevel);\n    return validImageryLevel;\n  }\n\n  /**\n   * Compute the rectangle describing the range of imagery that is covered\n   * with the given rectangle.\n   *\n   * This will compute a rectangle with integer coordinates that describe\n   * the X/Y coordinates of the imagery that is overlapped by the given\n   * input rectangle, based on the given imagery rectangle.\n   *\n   * Extracted from _createTileImagerySkeletons.\n   *\n   * @param {Rectangle} inputRectangle The input rectangle\n   * @param {Rectangle} imageryBounds The imagery bounds\n   * @param {TilingScheme} imageryTilingScheme The tiling scheme\n   * @param {number} imageryLevel The imagery level\n   * @returns {CartesianRectangle} The rectangle\n   */\n  static _computeImageryRange(\n    inputRectangle,\n    imageryBounds,\n    imageryTilingScheme,\n    imageryLevel,\n  ) {\n    const overlappedRectangle = ImageryCoverage._computeOverlappedRectangle(\n      inputRectangle,\n      imageryBounds,\n    );\n    const northwestTileCoordinates = imageryTilingScheme.positionToTileXY(\n      Rectangle.northwest(overlappedRectangle),\n      imageryLevel,\n    );\n    const southeastTileCoordinates = imageryTilingScheme.positionToTileXY(\n      Rectangle.southeast(overlappedRectangle),\n      imageryLevel,\n    );\n\n    const result = new CartesianRectangle();\n    result.minX = northwestTileCoordinates.x;\n    result.minY = northwestTileCoordinates.y;\n    result.maxX = southeastTileCoordinates.x;\n    result.maxY = southeastTileCoordinates.y;\n\n    // As extracted from _createTileImagerySkeletons:\n    // If the southeast corner of the rectangle lies very close to the north or west side\n    // of the southeast tile, we don't actually need the southernmost or easternmost\n    // tiles.\n    // Similarly, if the northwest corner of the rectangle lies very close to the south or east side\n    // of the northwest tile, we don't actually need the northernmost or westernmost tiles.\n    // We define \"very close\" as being within 1/512 of the width of the tile.\n    const veryCloseX = inputRectangle.width / 512.0;\n    const veryCloseY = inputRectangle.height / 512.0;\n\n    const northwestTileRectangle = imageryTilingScheme.tileXYToRectangle(\n      result.minX,\n      result.minY,\n      imageryLevel,\n    );\n    const deltaNorth = Math.abs(\n      northwestTileRectangle.south - inputRectangle.north,\n    );\n    if (deltaNorth < veryCloseY && result.minY < result.maxY) {\n      ++result.minY;\n    }\n    const deltaWest = Math.abs(\n      northwestTileRectangle.east - inputRectangle.west,\n    );\n    if (deltaWest < veryCloseX && result.minX < result.maxX) {\n      ++result.minX;\n    }\n\n    const southeastTileRectangle = imageryTilingScheme.tileXYToRectangle(\n      result.maxX,\n      result.maxY,\n      imageryLevel,\n    );\n    const deltaSouth = Math.abs(\n      southeastTileRectangle.north - inputRectangle.south,\n    );\n    if (deltaSouth < veryCloseY && result.maxY > result.minY) {\n      --result.maxY;\n    }\n    const deltaEast = Math.abs(\n      southeastTileRectangle.west - inputRectangle.east,\n    );\n    if (deltaEast < veryCloseX && result.maxX > result.minX) {\n      --result.maxX;\n    }\n\n    return result;\n  }\n\n  /**\n   * Clamp the given input rectangle to the given clamp rectangle.\n   *\n   * If the input rectangle is completely above/below or left/right\n   * of the clamp rectangle, then the north/south or east/east\n   * if the clamp rectangle will be used in the result.\n   *\n   * @param {Rectangle} input The input rectangle\n   * @param {Rectangle} clamp The clamping rectangle\n   * @param {Rectangle} [result] The result\n   * @returns {Rectangle} The result\n   */\n  static _clampRectangle(input, clamp, result) {\n    if (!defined(result)) {\n      result = new Rectangle();\n    }\n    if (input.south >= clamp.north) {\n      result.north = result.south = clamp.north;\n    } else if (input.north <= clamp.south) {\n      result.north = result.south = clamp.south;\n    } else {\n      result.south = Math.max(input.south, clamp.south);\n      result.north = Math.min(input.north, clamp.north);\n    }\n\n    if (input.west >= clamp.east) {\n      result.west = result.east = clamp.east;\n    } else if (input.east <= clamp.west) {\n      result.west = result.east = clamp.west;\n    } else {\n      result.west = Math.max(input.west, clamp.west);\n      result.east = Math.min(input.east, clamp.east);\n    }\n    return result;\n  }\n\n  /**\n   * Compute overlap between the given input rectangle, and the given\n   * bounds that have been obtained from the imagery provider.\n   *\n   * @param {Rectangle} inputRectangle The input\n   * @param {Rectangle} imageryBounds The imagery bounds\n   * @returns {Rectangle} The rectangle\n   */\n  static _computeOverlappedRectangle(inputRectangle, imageryBounds) {\n    const overlappedRectangle = Rectangle.intersection(\n      inputRectangle,\n      imageryBounds,\n      overlappedRectangleScratch,\n    );\n    if (defined(overlappedRectangle)) {\n      return overlappedRectangle;\n    }\n    return ImageryCoverage._clampRectangle(\n      inputRectangle,\n      imageryBounds,\n      overlappedRectangleScratch,\n    );\n  }\n\n  /**\n   * Computes the <code>ImageryCoverage</code> objects that describe the imagery and\n   * the texture coordinates that are contained in the given range of\n   * imagery tile coordinates, referring to the given input rectangle.\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {CartesianRectangle} imageryRange The range of imagery tile coordinates\n   * @param {number} imageryLevel The imagery level\n   * @param {Rectangle} nativeInputRectangle The input rectangle, in coordinates\n   * that are native for the tiling scheme\n   * @param {Function} computeClippedImageryRectangle A function that returns\n   * an imagery rectangle, based on (x, y, level), clipped to the imagery bounds\n   * (or undefined if there is no intersection between the imagery rectangle\n   * and the bounds)\n   * @returns {ImageryCoverage[]} The objects describing the covered imagery\n   * and the respective texture coordinates\n   */\n  static _computeImageryCoverages(\n    imageryLayer,\n    imageryRange,\n    imageryLevel,\n    nativeInputRectangle,\n    computeClippedImageryRectangle,\n  ) {\n    const imageryCoverages = [];\n\n    for (let i = imageryRange.minX; i <= imageryRange.maxX; i++) {\n      const clippedImageryRectangleU = computeClippedImageryRectangle(\n        i,\n        imageryRange.maxY,\n        imageryLevel,\n      );\n\n      if (!defined(clippedImageryRectangleU)) {\n        continue;\n      }\n\n      for (let j = imageryRange.minY; j <= imageryRange.maxY; j++) {\n        const clippedImageryRectangleV = computeClippedImageryRectangle(\n          i,\n          j,\n          imageryLevel,\n        );\n\n        if (!defined(clippedImageryRectangleV)) {\n          continue;\n        }\n\n        const textureCoordinateRectangle =\n          ImageryCoverage._localizeToCartesianRectangle(\n            clippedImageryRectangleV,\n            nativeInputRectangle,\n            undefined,\n          );\n\n        // Note: The getImageryFromCache function will create the whole \"chain\"\n        // of ancestor imageries, up to the root, and increases the reference\n        // counter for each of them, even though it is not called\n        // getImageryFromCacheAndCreateAllAncestorsAndAddReferences.\n        // There is currently no way to have a single imagery, because\n        // somewhere in TileImagery, the parent is assumed to be present.\n        const imagery = imageryLayer.getImageryFromCache(i, j, imageryLevel);\n        const imageryCoverage = new ImageryCoverage(\n          i,\n          j,\n          imageryLevel,\n          textureCoordinateRectangle,\n          imagery,\n        );\n        imageryCoverages.push(imageryCoverage);\n      }\n    }\n    return imageryCoverages;\n  }\n\n  /**\n   * Compute the coordinates of the first rectangle relative to the\n   * second rectangle.\n   *\n   * The result will describe the bounds of the first rectangle\n   * in coordinates that are relative to the (south,west) and\n   * (width, height) of the second rectangle. This is suitable\n   * for describing the texture coordinates of the first\n   * rectangle within the second one.\n   *\n   * The result will be stored in the given result parameter, or\n   * in a new rectangle if the result was undefined.\n   *\n   * @param {Rectangle} rectangleA The first rectangle\n   * @param {Rectangle} rectangleB The second rectangle\n   * @param {CartesianRectangle} [result] The result\n   * @returns {CartesianRectangle} The result\n   */\n  static _localizeToCartesianRectangle(rectangleA, rectangleB, result) {\n    if (!defined(result)) {\n      result = new CartesianRectangle();\n    }\n    const invX = 1.0 / rectangleB.width;\n    const invY = 1.0 / rectangleB.height;\n    result.minX = (rectangleA.west - rectangleB.west) * invX;\n    result.minY = (rectangleA.south - rectangleB.south) * invY;\n    result.maxX = (rectangleA.east - rectangleB.west) * invX;\n    result.maxY = (rectangleA.north - rectangleB.south) * invY;\n    return result;\n  }\n}\n\nexport default ImageryCoverage;\n"],"names":["imageryBoundsScratch","overlappedRectangleScratch","clippedRectangleScratch","nativeInputRectangleScratch","nativeImageryBoundsScratch","nativeClippedImageryBoundsScratch","ImageryCoverage","x","y","level","textureCoordinateRectangle","imagery","_x","_y","_level","_textureCoordinateRectangle","_imagery","createImageryCoverages","inputRectangle","imageryLayer","inputImageryLevel","show","imageryProvider","imageryLevel","_clampImageryLevel","imageryBounds","intersection","rectangle","imageryTilingScheme","tilingScheme","imageryRange","_computeImageryRange","nativeInputRectangle","rectangleToNativeRectangle","nativeImageryBounds","computeClippedImageryRectangle","localImageryRectangle","tileXYToRectangle","localClippedImageryRectangle","undefined","nativeClippedImageryBounds","imageryCoverages","_computeImageryCoverages","minimumLevel","maximumLevel","Number","POSITIVE_INFINITY","clampedImageryLevel","Math","min","max","validImageryLevel","floor","overlappedRectangle","_computeOverlappedRectangle","northwestTileCoordinates","positionToTileXY","northwest","southeastTileCoordinates","southeast","result","minX","minY","maxX","maxY","veryCloseX","width","veryCloseY","height","northwestTileRectangle","deltaNorth","abs","south","north","deltaWest","east","west","southeastTileRectangle","deltaSouth","deltaEast","_clampRectangle","input","clamp","i","clippedImageryRectangleU","j","clippedImageryRectangleV","_localizeToCartesianRectangle","getImageryFromCache","imageryCoverage","push","rectangleA","rectangleB","invX","invY"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12109, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelImageryMapping.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport Cartesian2 from \"../../Core/Cartesian2.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Rectangle from \"../../Core/Rectangle.js\";\nimport Cartographic from \"../../Core/Cartographic.js\";\nimport BoundingRectangle from \"../../Core/BoundingRectangle.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport Check from \"../../Core/Check.js\";\n\nimport AttributeType from \"../AttributeType.js\";\nimport ModelReader from \"./ModelReader.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * A class for computing the texture coordinates of imagery that is\n * supposed to be mapped on a <code>ModelComponents.Primitive</code>.\n *\n * @private\n */\nclass ModelImageryMapping {\n  /**\n   * Creates a typed array that contains texture coordinates for\n   * the given <code>MappedPositions</code>, using the given\n   * projection.\n   *\n   * This will be a typed array that contains the texture coordinates\n   * that result from projecting the given positions with the given\n   * projection, and normalizing them to their bounding rectangle.\n   *\n   * @param {MappedPositions} mappedPositions The positions\n   * @param {MapProjection} projection The projection that should be used\n   * @returns {TypedArray} The result\n   */\n  static createTextureCoordinatesForMappedPositions(\n    mappedPositions,\n    projection,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"mappedPositions\", mappedPositions);\n    Check.defined(\"projection\", projection);\n    //>>includeEnd('debug');\n\n    const cartographicPositions = mappedPositions.cartographicPositions;\n    const cartographicBoundingRectangle =\n      mappedPositions.cartographicBoundingRectangle;\n    const numPositions = mappedPositions.numPositions;\n    return ModelImageryMapping._createTextureCoordinates(\n      cartographicPositions,\n      numPositions,\n      cartographicBoundingRectangle,\n      projection,\n    );\n  }\n\n  /**\n   * Creates a typed array that contains texture coordinates for\n   * a primitive with the given positions, using the given\n   * projection.\n   *\n   * This will be a typed array of size <code>numPositions*2</code>\n   * that contains the texture coordinates that result from\n   * projecting the given positions with the given projection,\n   * and normalizing them to the given bounding rectangle.\n   *\n   * @param {Iterable<Cartographic>} cartographicPositions The\n   * cartographic positions\n   * @param {number} numPositions The number of positions (vertices)\n   * @param {Rectangle} cartographicBoundingRectangle The bounding\n   * rectangle of the cartographic positions\n   * @param {MapProjection} projection The projection that should be used\n   * @returns {TypedArray} The result\n   * @private\n   */\n  static _createTextureCoordinates(\n    cartographicPositions,\n    numPositions,\n    cartographicBoundingRectangle,\n    projection,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"cartographicPositions\", cartographicPositions);\n    Check.typeOf.number.greaterThanOrEquals(\"numPositions\", numPositions, 0);\n    Check.defined(\n      \"cartographicBoundingRectangle\",\n      cartographicBoundingRectangle,\n    );\n    Check.defined(\"projection\", projection);\n    //>>includeEnd('debug');\n\n    // Convert the bounding `Rectangle`(!) of the cartographic positions\n    // into a `BoundingRectangle`(!) using the given projection\n    const boundingRectangle = new BoundingRectangle();\n    BoundingRectangle.fromRectangle(\n      cartographicBoundingRectangle,\n      projection,\n      boundingRectangle,\n    );\n\n    // Compute the projected positions, using the given projection\n    const projectedPositions = ModelImageryMapping.createProjectedPositions(\n      cartographicPositions,\n      projection,\n    );\n\n    // Relativize the projected positions into the bounding rectangle\n    // to obtain texture coordinates\n    const texCoords = ModelImageryMapping.computeTexCoords(\n      projectedPositions,\n      boundingRectangle,\n    );\n\n    // Convert the texture coordinates into a typed array\n    const texCoordsTypedArray =\n      ModelImageryMapping.createTypedArrayFromCartesians2(\n        numPositions,\n        texCoords,\n      );\n\n    return texCoordsTypedArray;\n  }\n\n  /**\n   * Creates the `ModelComponents.Attribute` for the texture coordinates\n   * for a primitive\n   *\n   * This will create an attribute with\n   * - semantic: VertexAttributeSemantic.TEXCOORD\n   * - type: AttributeType.VEC2\n   * - count: mappedPositions.numPositions\n   * that contains the texture coordinates for the given vertex positions,\n   * after they are projected using the given projection, normalized to\n   * their bounding rectangle.\n   *\n   * @param {Iterable<Cartographic>} cartographicPositions The\n   * cartographic positions\n   * @param {number} numPositions The number of positions (vertices)\n   * @param {Rectangle} cartographicBoundingRectangle The bounding\n   * rectangle of the cartographic positions\n   * @param {MapProjection} projection The projection that should be used\n   * @returns {ModelComponents.Attribute} The new attribute\n   */\n  static createTextureCoordinatesAttributeForMappedPositions(\n    mappedPositions,\n    projection,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"mappedPositions\", mappedPositions);\n    Check.defined(\"projection\", projection);\n    //>>includeEnd('debug');\n\n    // Create the typed array that contains the texture coordinates\n    const texCoordsTypedArray =\n      ModelImageryMapping.createTextureCoordinatesForMappedPositions(\n        mappedPositions,\n        projection,\n      );\n\n    // Create an attribute from the texture coordinates typed array\n    const texCoordAttribute =\n      ModelImageryMapping.createTexCoordAttribute(texCoordsTypedArray);\n\n    return texCoordAttribute;\n  }\n\n  /**\n   * Create an iterable that provides the cartographic positions\n   * of the given POSITION attribute, based on the given ellipsoid\n   *\n   * @param {ModelComponents.Attribute} primitivePositionAttribute\n   * The \"POSITION\" attribute of the primitive.\n   * @param {Matrix4} primitivePositionTransform The full transform of the primitive\n   * @param {Elliposid} ellipsoid The ellipsoid that should be used\n   * @returns {Iterable<Cartographic>} The iterable over `Cartographic` objects\n   */\n  static createCartographicPositions(\n    primitivePositionAttribute,\n    primitivePositionTransform,\n    ellipsoid,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"primitivePositionAttribute\", primitivePositionAttribute);\n    Check.defined(\"primitivePositionTransform\", primitivePositionTransform);\n    Check.defined(\"ellipsoid\", ellipsoid);\n    //>>includeEnd('debug');\n\n    // Extract the positions as a typed array\n    const typedArray = ModelReader.readAttributeAsTypedArray(\n      primitivePositionAttribute,\n    );\n\n    // Create an iterable over the positions\n    const type = primitivePositionAttribute.type;\n    const numComponents = AttributeType.getNumberOfComponents(type);\n    const positions =\n      ModelImageryMapping.createIterableCartesian3FromTypedArray(\n        typedArray,\n        numComponents,\n      );\n\n    // Compute the positions after they are transformed with the given matrix\n    const transformedPositions = ModelImageryMapping.transformCartesians3(\n      positions,\n      primitivePositionTransform,\n    );\n\n    // Compute the cartographic positions for the given ellipsoid\n    const cartographicPositions = ModelImageryMapping.transformToCartographic(\n      transformedPositions,\n      ellipsoid,\n    );\n    return cartographicPositions;\n  }\n\n  /**\n   * Creates an iterable over `Cartesian3` objects from the given\n   * typed array.\n   *\n   * The resulting iterable will always return the same `Cartesian3`\n   * object. Clients should not store and modify this object.\n   *\n   * @param {TypedArray} typedArray The typed array\n   * @param {number} stride The stride between to consecutive\n   * `Cartesian3` elements in the given array. Must be at least 3.\n   * @returns {Iterable<Cartesian3>} The iterable\n   */\n  static createIterableCartesian3FromTypedArray(typedArray, stride) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"typedArray\", typedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"stride\", stride, 3);\n    //>>includeEnd('debug');\n\n    const cartesian = new Cartesian3();\n    const numElements = typedArray.length / stride;\n    const result = {\n      [Symbol.iterator]: function* () {\n        for (let i = 0; i < numElements; i++) {\n          cartesian.x = typedArray[i * stride + 0];\n          cartesian.y = typedArray[i * stride + 1];\n          cartesian.z = typedArray[i * stride + 2];\n          yield cartesian;\n        }\n      },\n    };\n    return result;\n  }\n\n  /**\n   * Creates a new iterable that applies the given mapper to the given iterable.\n   *\n   * @param {Iterable} iterable The input iterable\n   * @param {Function} mapper The mapper\n   * @returns {Iterable} The mapped iterable\n   */\n  static map(iterable, mapper) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"iterable\", iterable);\n    Check.defined(\"mapper\", mapper);\n    //>>includeEnd('debug');\n\n    const result = {\n      [Symbol.iterator]: function* () {\n        for (const element of iterable) {\n          yield mapper(element);\n        }\n      },\n    };\n    return result;\n  }\n\n  /**\n   * Computes the bounding rectangle of the given cartographic positions,\n   * stores it in the given result, and returns it.\n   *\n   * If the given result is `undefined`, a new rectangle will be created\n   * and returned.\n   *\n   * @param {Iterable<Cartographic>} cartographicPositions The cartographics\n   * @param {Rectangle} [result] The result\n   * @returns {Rectangle} The result\n   */\n  static computeCartographicBoundingRectangle(cartographicPositions, result) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"cartographicPositions\", cartographicPositions);\n    //>>includeEnd('debug');\n\n    if (!defined(result)) {\n      result = new Rectangle();\n    }\n    // One could store these directly in the result, but that would\n    // violate the constraint of the PI-related ranges..\n    let north = Number.NEGATIVE_INFINITY;\n    let south = Number.POSITIVE_INFINITY;\n    let east = Number.NEGATIVE_INFINITY;\n    let west = Number.POSITIVE_INFINITY;\n    for (const cartographicPosition of cartographicPositions) {\n      north = Math.max(north, cartographicPosition.latitude);\n      south = Math.min(south, cartographicPosition.latitude);\n      east = Math.max(east, cartographicPosition.longitude);\n      west = Math.min(west, cartographicPosition.longitude);\n    }\n    result.north = north;\n    result.south = south;\n    result.east = east;\n    result.west = west;\n    return result;\n  }\n\n  /**\n   * Creates a new iterable that provides `Cartesian3` objects that\n   * are created by transforming the `Cartesian3` objects of the\n   * given iterable with the given matrix.\n   *\n   * The resulting iterable will always return the same `Cartesian3`\n   * object. Clients should not store and modify this object.\n   *\n   * @param {Iterable<Cartesian3>} positions The positions\n   * @param {Matrix4} matrix The matrix\n   * @returns {Iterable<Cartesian3>} The transformed cartesians\n   */\n  static transformCartesians3(positions, matrix) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"positions\", positions);\n    Check.defined(\"matrix\", matrix);\n    //>>includeEnd('debug');\n\n    const transformedPosition = new Cartesian3();\n    const transformedPositions = ModelImageryMapping.map(positions, (p) => {\n      Matrix4.multiplyByPoint(matrix, p, transformedPosition);\n      return transformedPosition;\n    });\n    return transformedPositions;\n  }\n\n  /**\n   * Creates a new iterable that provides `Cartographic` objects that\n   * are created by converting the given `Cartesian3` objects to\n   * cartographics, based on the given ellipsoid.\n   *\n   * The resulting iterable will always return the same `Cartographic`\n   * object. Clients should not store and modify this object.\n   *\n   * @param {Iterable<Cartesian3>} positions The positions\n   * @param {Ellipsoid} ellipsoid The ellipsoid\n   * @returns {Iterable<Cartographic>} The cartographic positions\n   */\n  static transformToCartographic(positions, ellipsoid) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"positions\", positions);\n    Check.defined(\"ellipsoid\", ellipsoid);\n    //>>includeEnd('debug');\n\n    const cartographicPosition = new Cartographic();\n    const cartographicPositions = ModelImageryMapping.map(positions, (p) => {\n      // Note: This will not yield valid results for p=(0,0,0).\n      // But there is no sensible cartographic position for\n      // that, so simply accept the unspecified output here.\n      ellipsoid.cartesianToCartographic(p, cartographicPosition);\n      return cartographicPosition;\n    });\n    return cartographicPositions;\n  }\n\n  /**\n   * Creates an iterable over the results of applying the given projection\n   * to the given cartographic positions.\n   *\n   * The resulting iterable will always return the same `Cartesian3`\n   * object. Clients should not store and modify this object.\n   *\n   * @param {Iterable<Cartographic>} cartographicPositions The cartographic\n   * positions\n   * @param {MapProjection} projection The projection to use\n   * @returns {Iterable<Cartesian3>} The projected positions\n   */\n  static createProjectedPositions(cartographicPositions, projection) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"cartographicPositions\", cartographicPositions);\n    Check.defined(\"projection\", projection);\n    //>>includeEnd('debug');\n\n    const projectedPosition = new Cartesian3();\n    const projectedPositions = ModelImageryMapping.map(\n      cartographicPositions,\n      (c) => {\n        projection.project(c, projectedPosition);\n        return projectedPosition;\n      },\n    );\n    return projectedPositions;\n  }\n\n  /**\n   * Computes the texture coordinates for the given positions, relative\n   * to the given bounding rectangle.\n   *\n   * This will make the x/y coordinates of the given cartesians relative\n   * to the given bounding rectangle and clamp them to [0,0]-[1,1].\n   *\n   * NOTE: This could be broken down into\n   * 1. mapping to 2D\n   * 2. relativizing for the bounding recangle\n   * 3. clamping to [0,0]-[1,1]\n   *\n   * @param {Iterable<Cartesian3>} positions The positions\n   * @param {BoundingRectangle} boundingRectangle The rectangle\n   * @returns {Iterable<Cartesian2>} The texture coordinates\n   */\n  static computeTexCoords(positions, boundingRectangle) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"positions\", positions);\n    Check.defined(\"boundingRectangle\", boundingRectangle);\n    //>>includeEnd('debug');\n\n    const texCoord = new Cartesian2();\n    const invSizeX = 1.0 / boundingRectangle.width;\n    const invSizeY = 1.0 / boundingRectangle.height;\n    const texCoords = ModelImageryMapping.map(positions, (p) => {\n      const uRaw = (p.x - boundingRectangle.x) * invSizeX;\n      const vRaw = (p.y - boundingRectangle.y) * invSizeY;\n      const u = Math.min(Math.max(uRaw, 0.0), 1.0);\n      const v = Math.min(Math.max(vRaw, 0.0), 1.0);\n      texCoord.x = u;\n      texCoord.y = v;\n      return texCoord;\n    });\n    return texCoords;\n  }\n\n  /**\n   * Creates a new typed array from the given `Cartesian2` objects.\n   *\n   * @param {number} numElements The number of elements\n   * @param {Iterable<Cartesian2>} elements The elements\n   * @returns {TypedArray} The typed array\n   */\n  static createTypedArrayFromCartesians2(numElements, elements) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.typeOf.number.greaterThanOrEquals(\"numElements\", numElements, 0);\n    Check.defined(\"elements\", elements);\n    //>>includeEnd('debug');\n\n    const typedArray = new Float32Array(numElements * 2);\n    let index = 0;\n    for (const element of elements) {\n      typedArray[index * 2 + 0] = element.x;\n      typedArray[index * 2 + 1] = element.y;\n      index++;\n    }\n    return typedArray;\n  }\n\n  /**\n   * Create a new texture coordinates attribute from the given data.\n   *\n   * This will create an attribute with\n   * - semantic: VertexAttributeSemantic.TEXCOORD\n   * - type: AttributeType.VEC2\n   * - count: texCoordsTypedArray.length / 2\n   * that contains the data from the given typed array.\n   *\n   * @param {TypedArray} texCoordsTypedArray The typed array\n   * @returns {ModelComponents.Attribute} The attribute\n   */\n  static createTexCoordAttribute(texCoordsTypedArray) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"texCoordsTypedArray\", texCoordsTypedArray);\n    //>>includeEnd('debug');\n\n    const texCoordAttribute = {\n      name: \"Imagery Texture Coordinates\",\n      semantic: VertexAttributeSemantic.TEXCOORD,\n      setIndex: 0,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC2,\n      normalized: false,\n      count: texCoordsTypedArray.length / 2,\n      min: undefined,\n      max: undefined,\n      constant: new Cartesian2(0, 0),\n      quantization: undefined,\n      typedArray: texCoordsTypedArray,\n      byteOffset: 0,\n      byteStride: undefined,\n    };\n    return texCoordAttribute;\n  }\n}\nexport default ModelImageryMapping;\n"],"names":["ModelImageryMapping","createTextureCoordinatesForMappedPositions","mappedPositions","projection","defined","cartographicPositions","cartographicBoundingRectangle","numPositions","_createTextureCoordinates","typeOf","number","greaterThanOrEquals","boundingRectangle","fromRectangle","projectedPositions","createProjectedPositions","texCoords","computeTexCoords","texCoordsTypedArray","createTypedArrayFromCartesians2","createTextureCoordinatesAttributeForMappedPositions","texCoordAttribute","createTexCoordAttribute","createCartographicPositions","primitivePositionAttribute","primitivePositionTransform","ellipsoid","typedArray","readAttributeAsTypedArray","type","numComponents","getNumberOfComponents","positions","createIterableCartesian3FromTypedArray","transformedPositions","transformCartesians3","transformToCartographic","stride","cartesian","numElements","length","result","Symbol","iterator","i","x","y","z","map","iterable","mapper","element","computeCartographicBoundingRectangle","north","Number","NEGATIVE_INFINITY","south","POSITIVE_INFINITY","east","west","cartographicPosition","Math","max","latitude","min","longitude","matrix","transformedPosition","p","multiplyByPoint","cartesianToCartographic","projectedPosition","c","project","texCoord","invSizeX","width","invSizeY","height","uRaw","vRaw","u","v","elements","Float32Array","index","name","semantic","TEXCOORD","setIndex","componentDatatype","FLOAT","VEC2","normalized","count","undefined","constant","quantization","byteOffset","byteStride"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12510, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/MappedPositions.js"],"sourcesContent":["import Check from \"../../Core/Check.js\";\n\n/**\n * A collection of cartographic positions (and their bounding rectangle) that\n * have been computed from cartesian positions, for a specific ellipsoid.\n *\n * This is used in the <code>ModelPrimitiveImagery</code> class, and stores\n * the positions of the primitive, mapped to an ellipsoid that was used\n * on one of the imagery layers. This avoids recomputing the transform\n * of the primitive POSITION attribute values into ECEF, and the subsequent\n * conversion of these positions into cartographic positions.\n *\n * @private\n */\nclass MappedPositions {\n  /**\n   * Creates a new instance\n   *\n   * @param {Iterable<Cartographic>} cartographicPositions The positions\n   * @param {number} numPositions The number of positions\n   * @param {Rectangle} cartographicBoundingRectangle The bounding\n   * rectangle of the positions\n   * @param {Ellipsoid} ellipsoid The ellipsoid\n   */\n  constructor(\n    cartographicPositions,\n    numPositions,\n    cartographicBoundingRectangle,\n    ellipsoid,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"cartographicPositions\", cartographicPositions);\n    Check.typeOf.number.greaterThanOrEquals(\"numPositions\", numPositions, 0);\n    Check.defined(\n      \"cartographicBoundingRectangle\",\n      cartographicBoundingRectangle,\n    );\n    Check.defined(\"ellipsoid\", ellipsoid);\n    //>>includeEnd('debug');\n\n    this._cartographicPositions = cartographicPositions;\n    this._numPositions = numPositions;\n    this._cartographicBoundingRectangle = cartographicBoundingRectangle;\n    this._ellipsoid = ellipsoid;\n  }\n\n  /**\n   * Returns the cartographic positions\n   *\n   * @returns {Iterable<Cartographic>} The positions\n   */\n  get cartographicPositions() {\n    return this._cartographicPositions;\n  }\n\n  /**\n   * Returns the number of positions\n   *\n   * @returns {number} The number of positions\n   */\n  get numPositions() {\n    return this._numPositions;\n  }\n\n  /**\n   * Returns the cartographic bounding rectangle\n   *\n   * @returns {Rectangle} The rectangle\n   */\n  get cartographicBoundingRectangle() {\n    return this._cartographicBoundingRectangle;\n  }\n\n  /**\n   * Returns the ellipsoid for which these positions have been created\n   *\n   * @returns {Ellipsoid} The ellipsoid\n   */\n  get ellipsoid() {\n    return this._ellipsoid;\n  }\n}\n\nexport default MappedPositions;\n"],"names":["MappedPositions","cartographicPositions","numPositions","cartographicBoundingRectangle","ellipsoid","defined","typeOf","number","greaterThanOrEquals","_cartographicPositions","_numPositions","_cartographicBoundingRectangle","_ellipsoid"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;;;CAWC,GACD,MAAMA;IACJ;;;;;;;;GAQC,GACDA,YACEC,qBAAqB,EACrBC,YAAY,EACZC,6BAA6B,EAC7BC,SAAS,CACT;QACA,yCAAyC;QACzC,2KAAK,CAACC,OAAO,CAAC,yBAAyBJ;QACvC,2KAAK,CAACK,MAAM,CAACC,MAAM,CAACC,mBAAmB,CAAC,gBAAgBN,cAAc;QACtE,2KAAK,CAACG,OAAO,CACX,iCACAF;QAEF,2KAAK,CAACE,OAAO,CAAC,aAAaD;QAC3B,wBAAwB;QAExB,IAAI,CAACK,sBAAsB,GAAGR;QAC9B,IAAI,CAACS,aAAa,GAAGR;QACrB,IAAI,CAACS,8BAA8B,GAAGR;QACtC,IAAI,CAACS,UAAU,GAAGR;IACpB;IAEA;;;;GAIC,GACD,IAAIH,wBAAwB;QAC1B,OAAO,IAAI,CAACQ,sBAAsB;IACpC;IAEA;;;;GAIC,GACD,IAAIP,eAAe;QACjB,OAAO,IAAI,CAACQ,aAAa;IAC3B;IAEA;;;;GAIC,GACD,IAAIP,gCAAgC;QAClC,OAAO,IAAI,CAACQ,8BAA8B;IAC5C;IAEA;;;;GAIC,GACD,IAAIP,YAAY;QACd,OAAO,IAAI,CAACQ,UAAU;IACxB;AACF;uCAEeZ","ignoreList":[0]}},
    {"offset": {"line": 12582, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelPrimitiveImagery.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Check from \"../../Core/Check.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\n\nimport ImageryState from \"../ImageryState.js\";\nimport ImageryCoverage from \"./ImageryCoverage.js\";\nimport ModelImageryMapping from \"./ModelImageryMapping.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport MappedPositions from \"./MappedPositions.js\";\n\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\n\n/**\n * A class managing the draping of imagery on a single model primitive.\n *\n * The <code>ModelImagery</code> class creates one instance of this\n * class for each primitive that appears in the model.\n *\n * It is responsible for computing\n * - the mapped (cartographic) positions of the primitive\n * - the imagery tiles that are covered by these mapped positions\n * - the texture coordinates (attributes) that correspond to these mapped positions\n *\n * @private\n */\nclass ModelPrimitiveImagery {\n  /**\n   * Creates a new instance\n   *\n   * @param {Model} model The model\n   * @param {ModelRuntimeNode} runtimeNode The node that the primitive is attached to\n   * @param {ModelRuntimePrimitive} runtimePrimitive The primitive\n   * @throws {DeveloperError} If any argument is not defined\n   */\n  constructor(model, runtimeNode, runtimePrimitive) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"model\", model);\n    Check.defined(\"runtimeNode\", runtimeNode);\n    Check.defined(\"runtimePrimitive\", runtimePrimitive);\n    //>>includeEnd('debug');\n\n    /**\n     * The model that this instance was created for.\n     *\n     * @type {Model}\n     * @readonly\n     * @private\n     */\n    this._model = model;\n\n    /**\n     * The node that the primitive is attached to\n     *\n     * @type {ModelRuntimeNode}\n     * @readonly\n     * @private\n     */\n    this._runtimeNode = runtimeNode;\n\n    /**\n     * The primitive that this instance was created for.\n     *\n     * @type {ModelRuntimePrimitive}\n     * @readonly\n     * @private\n     */\n    this._runtimePrimitive = runtimePrimitive;\n\n    /**\n     * The <code>MappedPositions</code> objects, one for each ellipsoid\n     * of one of the imagery layers\n     *\n     * These objects are just plain structures that summarize the\n     * cartographic positions of the primitive for one specific\n     * ellipsoid\n     *\n     * @type {MappedPositions[]|undefined}\n     * @private\n     */\n    this._mappedPositionsPerEllipsoid = undefined;\n\n    /**\n     * The last <code>model.modelMatrix</code> for which the mapped\n     * positions have been computed.\n     *\n     * This is used for detecting changes in the model matrix that\n     * make it necessary to re-compute the mapped positions.\n     *\n     * @type {Matrix4}\n     * @readonly\n     * @private\n     */\n    this._mappedPositionsModelMatrix = new Matrix4();\n\n    /**\n     * The value that the <code>Cesium3DTileset.imageryLayersModificationCounter</code>\n     * had during the last update call. This is used for triggering updates when the\n     * imagery layer collection in the tileset changes.\n     */\n    this._lastImageryLayersModificationCounter = 0;\n\n    /**\n     * The texture coordinate attributes, one for each projection.\n     *\n     * This contains one <code>ModelComponents.Attribute</code> for each\n     * unique projection that is used in the imagery layers. These\n     * texture coordinate attributes are computed based on the mapped\n     * positions for the respective ellipsoid of that projection.\n     */\n    this._imageryTexCoordAttributesPerProjection = undefined;\n\n    /**\n     * The current imagery layers.\n     *\n     * This is initialized when the _coveragesPerLayer are computed,\n     * and tracked to that the reference counters of the imageries\n     * can be decreased when the coverages per layer are deleted.\n     *\n     * @type {ImageryLayer[]|undefined}\n     * @private\n     */\n    this._currentImageryLayers = undefined;\n\n    /**\n     * Information about the imagery tiles that are covered by the positions\n     * of the primitive.\n     *\n     * This is computed in the <code>update</code> function, based on the\n     * mapped positions of the primitive. After this computation,\n     * <code>_coveragesPerLayer[layerIndex]</code> is an array that contains\n     * the <code>ImageryCoverage</code> objects that describe the imagery\n     * tiles that are covered, including their texture coordinate rectangle.\n     *\n     * @type {ImageryCoverage[][]|undefined}\n     * @private\n     */\n    this._coveragesPerLayer = undefined;\n\n    /**\n     * A flag indicating whether all imagery objects that are covered\n     * are \"ready\".\n     *\n     * This is initially <code>false</code>. During the calls to the\n     * <code>update</code> function (which are triggered from the\n     * <code>Model.update</code> function, each frame), the\n     * <code>_updateImageries</code> function will be called, and\n     * process the imagery tiles, until all them them are in a\n     * state like <code>ImageryState.READY</code>, at which point\n     * this flag is set to <code>true</code>.\n     *\n     * @type {boolean}\n     * @private\n     */\n    this._allImageriesReady = false;\n  }\n\n  /**\n   * Returns the <code>ImageryCoverage</code> array that has been\n   * computed for the given imagery layer.\n   *\n   * This assumes that the given imagery layer is part of the\n   * imagery layer collection of the model, and that this\n   * model primitive imagery is \"ready\", meaning that the\n   * coverages have already been computed.\n   *\n   * Clients may <b>not</b> modify the returned array or any\n   * of its objects!\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @returns {ImageryCoverage[]} The coverage information\n   */\n  coveragesForImageryLayer(imageryLayer) {\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n    const index = imageryLayers.indexOf(imageryLayer);\n    if (index === -1) {\n      throw new DeveloperError(\"Imagery layer is not part of the model\");\n    }\n    const coveragesPerLayer = this._coveragesPerLayer;\n    if (!defined(coveragesPerLayer)) {\n      throw new DeveloperError(\n        `The coveragesPerLayer have not been computed yet`,\n      );\n    }\n    return coveragesPerLayer[index];\n  }\n\n  /**\n   * Update the state of this instance.\n   *\n   * This is called as part of <code>ModelImagery.update</code>, which in\n   * turn is part of the <code>Model.update</code> that is called in each\n   * frame.\n   *\n   * This will perform the computations that are required to establish\n   * the mapping between the imagery and the primitive. It will...\n   * <ul>\n   *   <li>\n   *     Compute the <code>MappedPositions</code> of the primitive,\n   *     one instance for each ellipsoid\n   *   </li>\n   *   <li>\n   *     Compute the \"coverages per layer\", containing the information\n   *     about which parts of the respective imagery layer are covered\n   *     by the mapped positions\n   *   </li>\n   *   <li>\n   *     Compute the texture coordinate attributes for the imagery, one\n   *     for each projection, and store them as the\n   *     <code>_imageryTexCoordAttributesPerProjection</code>\n   *   </li>\n   *   <li>\n   *     Update the imageries (i.e. processing their state machine by\n   *     calling <code>Imagery.processStateMachine</code>) until they\n   *     are in the <code>ImageryState.READY</code> state\n   *   </li>\n   * </ul>\n   *\n   * @param {FrameState} frameState The frame state\n   */\n  update(frameState) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"frameState\", frameState);\n    //>>includeEnd('debug');\n\n    // If the imagery layers have been modified since the last call\n    // to this function, then re-build everything\n    const model = this._model;\n    const content = model.content;\n    const tileset = content.tileset;\n    const modificationCounter = tileset.imageryLayersModificationCounter;\n    if (this._lastImageryLayersModificationCounter !== modificationCounter) {\n      delete this._mappedPositionsPerEllipsoid;\n      this._lastImageryLayersModificationCounter = modificationCounter;\n    }\n\n    if (this._mappedPositionsNeedUpdate) {\n      model.resetDrawCommands();\n      this._mappedPositionsPerEllipsoid =\n        this._computeMappedPositionsPerEllipsoid();\n      this._deleteCoveragesPerLayer();\n      this._destroyImageryTexCoordAttributes();\n    }\n\n    if (!defined(this._imageryTexCoordAttributesPerProjection)) {\n      this._imageryTexCoordAttributesPerProjection =\n        this._computeImageryTexCoordsAttributesPerProjection();\n      this._uploadImageryTexCoordAttributes(frameState.context);\n    }\n\n    if (!defined(this._coveragesPerLayer)) {\n      this._computeCoveragesPerLayer();\n      this._allImageriesReady = false;\n    }\n    if (!this._allImageriesReady) {\n      this._updateImageries(frameState);\n    }\n  }\n\n  /**\n   * Delete the <code>_coveragesPerLayer</code> if they are defined.\n   *\n   * This will call <code>deleteCoverages</code> for each set of coverages,\n   * and eventually delete the <code>_coveragesPerLayer</code>.\n   *\n   * This will cause the reference counters of the imageries to be\n   * decreased.\n   */\n  _deleteCoveragesPerLayer() {\n    const coveragesPerLayer = this._coveragesPerLayer;\n    if (!defined(coveragesPerLayer)) {\n      return;\n    }\n    const imageryLayers = this._currentImageryLayers;\n    const length = coveragesPerLayer.length;\n    for (let i = 0; i < length; i++) {\n      const imageryLayer = imageryLayers[i];\n      const coverages = coveragesPerLayer[i];\n      this._deleteCoverages(imageryLayer, coverages);\n    }\n    delete this._currentImageryLayers;\n    delete this._coveragesPerLayer;\n  }\n\n  /**\n   * Delete the given imagery coverage objects for the given imagery\n   * layer, meaning that it will cause the reference counters of the\n   * imageries to be decreased.\n   *\n   * If the imagery layer already has been destroyed, then nothing\n   * will be done.\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {ImageryCoverage[]} coverages The coverages\n   */\n  _deleteCoverages(imageryLayer, coverages) {\n    if (imageryLayer.isDestroyed()) {\n      return;\n    }\n    const length = coverages.length;\n    for (let i = 0; i < length; i++) {\n      const coverage = coverages[i];\n      const imagery = coverage.imagery;\n      imagery.releaseReference();\n    }\n  }\n\n  /**\n   * Create the GPU buffers for the typed arrays that are contained\n   * in the <code>_imageryTexCoordAttributesPerProjection</code>\n   *\n   * @param {Context} context The GL context\n   */\n  _uploadImageryTexCoordAttributes(context) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"context\", context);\n    //>>includeEnd('debug');\n\n    const attributes = this._imageryTexCoordAttributesPerProjection;\n    if (!defined(attributes)) {\n      return;\n    }\n    const n = attributes.length;\n    for (let i = 0; i < n; i++) {\n      const attribute = attributes[i];\n\n      // Allocate the GL resources for the new attribute\n      const imageryTexCoordBuffer = Buffer.createVertexBuffer({\n        context: context,\n        typedArray: attribute.typedArray,\n        usage: BufferUsage.STATIC_DRAW,\n      });\n\n      // TODO_DRAPING Review this. Probably, some cleanup\n      // has to happen somewhere else after setting this.\n      // Check that the call to \"destroy\" in\n      // _destroyImageryTexCoordAttributes is the right\n      // thing to do here.\n      imageryTexCoordBuffer.vertexArrayDestroyable = false;\n\n      attribute.buffer = imageryTexCoordBuffer;\n    }\n  }\n\n  /**\n   * Destroy the <code>_imageryTexCoordAttributesPerProjection</code>\n   * array.\n   *\n   * This is called for cleaning up the allocated GPU resources, before\n   * they are supposed to be re-computed with\n   * <code>_computeImageryTexCoordsAttributesPerProjection</code>\n   */\n  _destroyImageryTexCoordAttributes() {\n    const attributes = this._imageryTexCoordAttributesPerProjection;\n    if (!defined(attributes)) {\n      return;\n    }\n    const n = attributes.length;\n    for (let i = 0; i < n; i++) {\n      const attribute = attributes[i];\n      if (defined(attribute)) {\n        if (defined(attribute.buffer)) {\n          if (!attribute.buffer.isDestroyed()) {\n            attribute.buffer.destroy();\n          }\n        }\n        attributes[i] = undefined;\n      }\n    }\n    delete this._imageryTexCoordAttributesPerProjection;\n  }\n\n  /**\n   * Returns whether the <code>MappedPositions</code> have to be\n   * re-computed with <code>_computeMappedPositionsPerEllipsoid</code>.\n   *\n   * This is <code>true</code> when the positions have not yet been\n   * computed, or when the <code>modelMatrix</code> of the model\n   * changed since the previous call.\n   *\n   * @returns {boolean} Whether the mapped positions need an update\n   * @private\n   */\n  get _mappedPositionsNeedUpdate() {\n    if (!defined(this._mappedPositionsPerEllipsoid)) {\n      return true;\n    }\n    const model = this._model;\n    const lastModelMatrix = this._mappedPositionsModelMatrix;\n    if (!Matrix4.equals(model.modelMatrix, lastModelMatrix)) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Computes the mapped positions of the primitive, one for each ellipsoid.\n   *\n   * This computes the <i>unique</i> ellipsoids that appear in the imagery\n   * layers of the model, and creates one <code>MappedPositions</code>\n   * object for each of them.\n   *\n   * The respective <code>MappedPositions</code> objects will contain\n   * the cartographic positions that are computed from the positions\n   * of the primitive. These will serve as the basis for computing the\n   * part of the imagery that is covered by the primitive.\n   *\n   * These mapped positions depend on the current <code>modelMatrix</code>\n   * of the model. So they have to be re-computed when the model matrix\n   * changes.\n   *\n   * @returns {MappedPositions[]} The mapped positions\n   * @private\n   */\n  _computeMappedPositionsPerEllipsoid() {\n    const model = this._model;\n    const runtimeNode = this._runtimeNode;\n    const runtimePrimitive = this._runtimePrimitive;\n\n    const primitivePositionAttribute =\n      ModelPrimitiveImagery._obtainPrimitivePositionAttribute(\n        runtimePrimitive.primitive,\n      );\n    const numPositions = primitivePositionAttribute.count;\n\n    const primitivePositionTransform =\n      ModelPrimitiveImagery._computePrimitivePositionTransform(\n        model,\n        runtimeNode,\n        undefined,\n      );\n\n    const mappedPositionsPerEllipsoid = [];\n    const ellipsoids = ModelPrimitiveImagery._computeUniqueEllipsoids(\n      model.imageryLayers,\n    );\n\n    const length = ellipsoids.length;\n    for (let i = 0; i < length; i++) {\n      const ellipsoid = ellipsoids[i];\n      const cartographicPositions =\n        ModelImageryMapping.createCartographicPositions(\n          primitivePositionAttribute,\n          primitivePositionTransform,\n          ellipsoid,\n        );\n      const cartographicBoundingRectangle =\n        ModelImageryMapping.computeCartographicBoundingRectangle(\n          cartographicPositions,\n        );\n\n      const mappedPositions = new MappedPositions(\n        cartographicPositions,\n        numPositions,\n        cartographicBoundingRectangle,\n        ellipsoid,\n      );\n      mappedPositionsPerEllipsoid.push(mappedPositions);\n    }\n    Matrix4.clone(model.modelMatrix, this._mappedPositionsModelMatrix);\n    return mappedPositionsPerEllipsoid;\n  }\n\n  /**\n   * Computes an array containing the <i>unique</i> ellipsoids that\n   * appear in the imagery layers of the given collection.\n   *\n   * @param {ImageryLayerCollection} imageryLayers\n   * @returns {Ellipsoid[]} The ellipsoids\n   * @private\n   */\n  static _computeUniqueEllipsoids(imageryLayers) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayers\", imageryLayers);\n    //>>includeEnd('debug');\n\n    const ellipsoidsSet = new Set();\n    const length = imageryLayers.length;\n    for (let i = 0; i < length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      const ellipsoid = ModelPrimitiveImagery._getEllipsoid(imageryLayer);\n      ellipsoidsSet.add(ellipsoid);\n    }\n    return [...ellipsoidsSet];\n  }\n\n  /**\n   * Computes one coordinate attribute for each unique projection\n   * that is used in the imagery layers.\n   *\n   * This is taking the mapped positions, projecting them with\n   * the respective projection, and creating a texture coordinate\n   * attribute that describes the texture coordinates of these\n   * positions, relative to the cartographic bounding rectangle\n   * of the mapped positions.\n   *\n   * @returns {ModelComponents.Attribute[]} The attributes\n   */\n  _computeImageryTexCoordsAttributesPerProjection() {\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n\n    // Compute the arrays containing ALL projections and the array\n    // containing the UNIQUE projections from the imagery layers.\n    // Texture coordinate attributes only have to be created once\n    // for each projection.\n    const allProjections =\n      ModelPrimitiveImagery._extractProjections(imageryLayers);\n    const uniqueProjections = [...new Set(allProjections)];\n\n    // Create one texture coordinate attribute for each distinct\n    // projection that is used in the imagery layers\n    const attributes = this._createImageryTexCoordAttributes(uniqueProjections);\n    return attributes;\n  }\n\n  /**\n   * Computes an array containing the projections that are used in\n   * the given imagery layers.\n   *\n   * (Note that this array may contain duplicates)\n   *\n   * @param {ImageryLayerCollection} imageryLayers The imagery layers\n   * @returns {MapProjection[]} The projections\n   * @private\n   */\n  static _extractProjections(imageryLayers) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayers\", imageryLayers);\n    //>>includeEnd('debug');\n\n    const projections = [];\n    const length = imageryLayers.length;\n    for (let i = 0; i < length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      const projection = ModelPrimitiveImagery._getProjection(imageryLayer);\n      projections.push(projection);\n    }\n    return projections;\n  }\n\n  /**\n   * Returns the projection of the given imagery layer.\n   *\n   * This only exists to hide a train wreck\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @returns {MapProjection} The projection\n   * @private\n   */\n  static _getProjection(imageryLayer) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayer\", imageryLayer);\n    //>>includeEnd('debug');\n    const projection = imageryLayer.imageryProvider.tilingScheme.projection;\n    return projection;\n  }\n\n  /**\n   * Create texture coordinates, one for each projection.\n   *\n   * This will create a texture coordinate attribute for each of the given projections,\n   * using <code>ModelImageryMapping.createTextureCoordinatesAttributeForMappedPositions</code>,\n   *\n   * (This means that the given projections should indeed be unique,\n   * i.e. contain no duplicates)\n   *\n   * @param {MapProjection[]} uniqueProjections The projections\n   * @returns {ModelComponents.Attribute[]} The attributes\n   */\n  _createImageryTexCoordAttributes(uniqueProjections) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"uniqueProjections\", uniqueProjections);\n    //>>includeEnd('debug');\n\n    const imageryTexCoordAttributePerUniqueProjection = [];\n    const length = uniqueProjections.length;\n    for (let i = 0; i < length; i++) {\n      // Obtain the mapped positions for the ellipsoid that is used\n      // in the projection (i.e. the cartographic positions of the\n      // primitive, for the respective ellipsoid)\n      const projection = uniqueProjections[i];\n      const ellipsoid = projection.ellipsoid;\n      const mappedPositions = this.mappedPositionsForEllipsoid(ellipsoid);\n\n      // Create the actual attribute\n      const imageryTexCoordAttribute =\n        ModelImageryMapping.createTextureCoordinatesAttributeForMappedPositions(\n          mappedPositions,\n          projection,\n        );\n      imageryTexCoordAttributePerUniqueProjection.push(\n        imageryTexCoordAttribute,\n      );\n    }\n    return imageryTexCoordAttributePerUniqueProjection;\n  }\n\n  /**\n   * Compute the coverage information for the primitive, based on the\n   * imagery layers that are associated with the model.\n   *\n   * This updates the <code>_coveragesPerLayer[layerIndex]</code>, which\n   * is an array that contains the <code>ImageryCoverage</code> objects that\n   * describe the imagery tiles that are covered by the primitive, including\n   * their texture coordinate rectangle.\n   *\n   * This has to be called after the mapped positions for the primitive\n   * have been computed with <code>_computeMappedPositionsPerEllipsoid</code>.\n   *\n   * @private\n   */\n  _computeCoveragesPerLayer() {\n    const coveragesPerLayer = [];\n    const currentImageryLayers = [];\n\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n    const length = imageryLayers.length;\n    for (let i = 0; i < length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      const coverages = this._computeCoverage(imageryLayer);\n      coveragesPerLayer.push(coverages);\n      currentImageryLayers.push(imageryLayer);\n    }\n\n    this._coveragesPerLayer = coveragesPerLayer;\n    this._currentImageryLayers = currentImageryLayers;\n  }\n\n  /**\n   * Compute the coverage information for the primitive, based on the\n   * given imagery layer.\n   *\n   * This returns an array that contains the <code>ImageryCoverage</code>\n   * objects that describe the imagery tiles that are covered by the\n   * primitive, including their texture coordinate rectangle.\n   *\n   * This has to be called after the mapped positions for the primitive\n   * have been computed with <code>_computeMappedPositionsPerEllipsoid</code>.\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @returns {ImageryCoverage[]} The coverage information\n   * @private\n   */\n  _computeCoverage(imageryLayer) {\n    const mappedPositions = this.mappedPositionsForImageryLayer(imageryLayer);\n    const cartographicBoundingRectangle =\n      mappedPositions.cartographicBoundingRectangle;\n\n    const imageryLevel = this._computeImageryLevel(\n      imageryLayer,\n      cartographicBoundingRectangle,\n    );\n\n    const coverages = ImageryCoverage.createImageryCoverages(\n      cartographicBoundingRectangle,\n      imageryLayer,\n      imageryLevel,\n    );\n    return coverages;\n  }\n\n  /**\n   * Compute a <code>level</code> for accessing the imagery from the given\n   * imagery layer that is suitable for a primitive with the given bounding\n   * rectangle.\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {Rectangle} cartographicBoundingRectangle The cartographic\n   * bounding rectangle, as obtained from the MappedPositions for\n   * the given imagery layer\n   * @returns {number} The imagery level\n   */\n  _computeImageryLevel(imageryLayer, cartographicBoundingRectangle) {\n    const imageryProvider = imageryLayer.imageryProvider;\n    const tilingScheme = imageryProvider.tilingScheme;\n    const rectangle = tilingScheme.rectangle;\n\n    // The number of tiles covered by the boundingRectangle (b)\n    // for a certain level, based on the tiling scheme rectangle (r) is\n    // numberOfTilesCovered = b / (r / 2^level)\n    // Solving for \"level\" yields\n    // level = log2( numberOfTilesCovered * r / b)\n\n    // The goal here is to drape approximately (!) one imagery\n    // tile on each primitive. In practice, it may be more\n    // (up to 9 in theory)\n    const desiredNumberOfTilesCovered = 1;\n\n    // Perform the computation of the desired level, based on the\n    // number of tiles that should be covered (by whatever is\n    // larger, the width or the height)\n    let boundingRectangleSize = cartographicBoundingRectangle.width;\n    let rectangleSize = rectangle.width;\n    if (\n      cartographicBoundingRectangle.height > cartographicBoundingRectangle.width\n    ) {\n      boundingRectangleSize = cartographicBoundingRectangle.height;\n      rectangleSize = rectangle.height;\n    }\n    const desiredLevel = Math.log2(\n      (desiredNumberOfTilesCovered * rectangleSize) / boundingRectangleSize,\n    );\n\n    // Clamp the level to a valid range, and an integer value\n    const imageryLevel = ImageryCoverage._clampImageryLevel(\n      imageryProvider,\n      desiredLevel,\n    );\n    return imageryLevel;\n  }\n\n  /**\n   * Update all <code>Imagery</code> objects.\n   *\n   * This is called as part of <code>update</code>, until all required\n   * imagery tiles are \"ready\", as indicated by their <code>state</code>\n   * being <code>ImageryState.READY</code>.\n   *\n   * This is called after it has been determined which imagery tiles are\n   * covered by the primitive (i.e. after the <code>_coveragesPerLayer</code>\n   * have been computed by calling <code>_computeCoverages</code>).\n   *\n   * For each covered imagery tile, this will call\n   * <code>Imagery.processStateMachine</code> until they are either\n   * READY, FAILED, or INVALID.\n   *\n   * Once they all are in one of these final states, it will set the\n   * <code>_allImageriesReady</code> flag to <code>true</code>.\n   *\n   * @param {FrameState} frameState The frame state, to be passed to\n   * <code>imagery.processStateMachine</code>\n   * @private\n   */\n  _updateImageries(frameState) {\n    const model = this._model;\n    const coveragesPerLayer = this._coveragesPerLayer;\n    const length = coveragesPerLayer.length;\n    let allImageriesReady = true;\n    for (let i = 0; i < length; i++) {\n      const coverages = coveragesPerLayer[i];\n      const n = coverages.length;\n      for (let j = 0; j < n; j++) {\n        const coverage = coverages[j];\n        const imagery = coverage.imagery;\n\n        // In the context of loading the imagery for draping\n        // it over the primitive, the imagery counts as \"ready\"\n        // when it is really ready, but also when it failed\n        // or was invalid (otherwise, the primitive would\n        // never turn \"ready\"\n        const countsAsReady =\n          imagery.state === ImageryState.READY ||\n          imagery.state === ImageryState.FAILED ||\n          imagery.state === ImageryState.INVALID;\n        if (!countsAsReady) {\n          allImageriesReady = false;\n          imagery.processStateMachine(frameState, false, false);\n        }\n      }\n    }\n\n    // When the imageries turned ready, reset the draw commands\n    // to trigger a rendering with the updated draw commands\n    // that include the imagery now.\n    if (allImageriesReady) {\n      model.resetDrawCommands();\n    }\n    this._allImageriesReady = allImageriesReady;\n  }\n\n  /**\n   * Returns the <code>MappedPositions</code> object that contains\n   * information about the primitive positions that have been computed\n   * for the given imagery layer.\n   *\n   * This assumes that <code>_computeMappedPositionsPerEllipsoid</code> has\n   * already been called.\n   *\n   * @param {ImageryLayer} imageryLayer The imageryLayer\n   * @returns {MappedPositions} The mapped positions\n   * @throws {DeveloperError} If the mapped positions for the\n   * ellipsoid could not be found.\n   */\n  mappedPositionsForImageryLayer(imageryLayer) {\n    const ellipsoid = ModelPrimitiveImagery._getEllipsoid(imageryLayer);\n    return this.mappedPositionsForEllipsoid(ellipsoid);\n  }\n\n  /**\n   * Returns the <code>MappedPositions</code> object that contains\n   * information about the primitive positions that have been computed\n   * from the given ellipsoid.\n   *\n   * This assumes that <code>_computeMappedPositions</code> has\n   * already been called.\n   *\n   * @param {Ellipsoid} ellipsoid The ellipsoid\n   * @returns {MappedPositions} The mapped positions\n   * @throws {DeveloperError} If the mapped positions for the\n   * given ellipsoid could not be found.\n   */\n  mappedPositionsForEllipsoid(ellipsoid) {\n    const mappedPositionsPerEllipsoid = this._mappedPositionsPerEllipsoid;\n    if (!defined(mappedPositionsPerEllipsoid)) {\n      throw new DeveloperError(\n        `The mappedPositions have not been computed yet`,\n      );\n    }\n\n    const length = mappedPositionsPerEllipsoid.length;\n    for (let i = 0; i < length; i++) {\n      const mappedPositions = mappedPositionsPerEllipsoid[i];\n      if (mappedPositions.ellipsoid === ellipsoid) {\n        return mappedPositions;\n      }\n    }\n    throw new DeveloperError(\n      `Could not find mapped positions for ellipsoid ${ellipsoid}`,\n    );\n  }\n\n  /**\n   * Returns the texture coordinate attributes for the primitive that\n   * are used for draping the imagery.\n   *\n   * This will be available when this object is <code>ready</code>, and\n   * will contain one attribute for each unique projection that appears\n   * in the imagery layers.\n   *\n   * @returns {ModelComponents.Attribute[]} The attributes\n   */\n  imageryTexCoordAttributesPerProjection() {\n    const imageryTexCoordAttributesPerProjection =\n      this._imageryTexCoordAttributesPerProjection;\n    if (!defined(imageryTexCoordAttributesPerProjection)) {\n      throw new DeveloperError(\n        `The imagery texture coordinate attributes have not been computed yet`,\n      );\n    }\n    return this._imageryTexCoordAttributesPerProjection;\n  }\n\n  /**\n   * Returns whether the draping computations are \"ready\".\n   *\n   * This means that the <code>coveragesPerLayer</code> information\n   * has been computed, which describes the set of imagery tiles\n   * that are covered by the primitive, <b>and</b> that all the\n   * covered imagery tiles are in a state that counts as \"ready\"\n   * (i.e. <code>ImageryState.READY</code>, <code>FAILED</code>,\n   * or <code>INVALID</code>).\n   *\n   * @returns {boolean} Whether the draping computations are ready\n   */\n  get ready() {\n    const coveragesPerLayer = this._coveragesPerLayer;\n    if (!defined(coveragesPerLayer)) {\n      return false;\n    }\n    return this._allImageriesReady;\n  }\n\n  /**\n   * Returns whether this object was destroyed.\n   *\n   * If this object was destroyed, calling any function other than\n   * <code>isDestroyed</code> will result in a {@link DeveloperError}.\n   *\n   * @returns {boolean} Whether this object was destroyed\n   */\n  isDestroyed() {\n    return false;\n  }\n\n  /**\n   * Destroys this object and all its resources.\n   */\n  destroy() {\n    if (this.isDestroyed()) {\n      return;\n    }\n    this._deleteCoveragesPerLayer();\n    this._destroyImageryTexCoordAttributes();\n    return destroyObject(this);\n  }\n\n  /**\n   * Compute the transform that apparently has to be applied to\n   * the positions attribute of a primitive, to compute the\n   * actual, final positions in ECEF coordinates.\n   *\n   * This is based on the computation of the bounding\n   * sphere that is done at the end of buildDrawCommands\n   *\n   * @param {Model} model The model\n   * @param {ModelComponents.Node} runtimeNode The runtime node\n   * that the primitive is attached to\n   * @param {Matrix4} [result] The result\n   * @returns {Matrix4} The result\n   * @private\n   */\n  static _computePrimitivePositionTransform(model, runtimeNode, result) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"model\", model);\n    Check.defined(\"runtimeNode\", runtimeNode);\n    //>>includeEnd('debug');\n\n    if (!defined(result)) {\n      result = new Matrix4();\n    }\n\n    const modelSceneGraph = model.sceneGraph;\n\n    Matrix4.clone(Matrix4.IDENTITY, result);\n    Matrix4.multiply(result, model.modelMatrix, result);\n    Matrix4.multiply(result, modelSceneGraph.components.transform, result);\n    Matrix4.multiply(result, modelSceneGraph.axisCorrectionMatrix, result);\n    Matrix4.multiply(result, runtimeNode.computedTransform, result);\n    return result;\n  }\n\n  /**\n   * Returns the <code>\"POSITION\"</code> attribute from the given primitive.\n   *\n   * The <code>\"POSITION\"</code> attribute is required. If it is not\n   * defined for the given primitive, then a <code>DeveloperError</code>\n   * is thrown.\n   *\n   * @param {ModelComponents.Primitive} primitive The primitive\n   * @returns {ModelComponents.Attribute} The position attribute\n   * @throws {DeveloperError} If there is no position attribute\n   * @private\n   */\n  static _obtainPrimitivePositionAttribute(primitive) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"primitive\", primitive);\n    //>>includeEnd('debug');\n\n    const primitivePositionAttribute = ModelUtility.getAttributeBySemantic(\n      primitive,\n      \"POSITION\",\n    );\n    if (!defined(primitivePositionAttribute)) {\n      throw new DeveloperError(\n        \"The primitive does not have a POSITION attribute\",\n      );\n    }\n    return primitivePositionAttribute;\n  }\n\n  /**\n   * Returns the ellipsoid of the given imagery layer.\n   *\n   * This only exists to hide a train wreck\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @returns {Ellipsoid} The ellipsoid\n   * @private\n   */\n  static _getEllipsoid(imageryLayer) {\n    const ellipsoid =\n      imageryLayer.imageryProvider.tilingScheme.projection.ellipsoid;\n    return ellipsoid;\n  }\n}\n\nexport default ModelPrimitiveImagery;\n"],"names":["ModelPrimitiveImagery","model","runtimeNode","runtimePrimitive","defined","_model","_runtimeNode","_runtimePrimitive","_mappedPositionsPerEllipsoid","undefined","_mappedPositionsModelMatrix","_lastImageryLayersModificationCounter","_imageryTexCoordAttributesPerProjection","_currentImageryLayers","_coveragesPerLayer","_allImageriesReady","coveragesForImageryLayer","imageryLayer","imageryLayers","index","indexOf","coveragesPerLayer","update","frameState","content","tileset","modificationCounter","imageryLayersModificationCounter","_mappedPositionsNeedUpdate","resetDrawCommands","_computeMappedPositionsPerEllipsoid","_deleteCoveragesPerLayer","_destroyImageryTexCoordAttributes","_computeImageryTexCoordsAttributesPerProjection","_uploadImageryTexCoordAttributes","context","_computeCoveragesPerLayer","_updateImageries","length","i","coverages","_deleteCoverages","isDestroyed","coverage","imagery","releaseReference","attributes","n","attribute","imageryTexCoordBuffer","createVertexBuffer","typedArray","usage","STATIC_DRAW","vertexArrayDestroyable","buffer","destroy","lastModelMatrix","equals","modelMatrix","primitivePositionAttribute","_obtainPrimitivePositionAttribute","primitive","numPositions","count","primitivePositionTransform","_computePrimitivePositionTransform","mappedPositionsPerEllipsoid","ellipsoids","_computeUniqueEllipsoids","ellipsoid","cartographicPositions","createCartographicPositions","cartographicBoundingRectangle","computeCartographicBoundingRectangle","mappedPositions","push","clone","ellipsoidsSet","Set","get","_getEllipsoid","add","allProjections","_extractProjections","uniqueProjections","_createImageryTexCoordAttributes","projections","projection","_getProjection","imageryProvider","tilingScheme","imageryTexCoordAttributePerUniqueProjection","mappedPositionsForEllipsoid","imageryTexCoordAttribute","createTextureCoordinatesAttributeForMappedPositions","currentImageryLayers","_computeCoverage","mappedPositionsForImageryLayer","imageryLevel","_computeImageryLevel","createImageryCoverages","rectangle","desiredNumberOfTilesCovered","boundingRectangleSize","width","rectangleSize","height","desiredLevel","Math","log2","_clampImageryLevel","allImageriesReady","j","countsAsReady","state","READY","FAILED","INVALID","processStateMachine","imageryTexCoordAttributesPerProjection","ready","result","modelSceneGraph","sceneGraph","IDENTITY","multiply","components","transform","axisCorrectionMatrix","computedTransform","getAttributeBySemantic"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 13401, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ImageryInput.js"],"sourcesContent":["/**\n * A structure summarizing the input for the shader that is draping imagery\n * over 3D Tiles, as part of the <code>ImageryPipelineStage</code>.\n *\n * The <code>ImageryPipelineStage</code> receives the primitive, and their\n * <code>ModelPrimitiveImagery</code> objects. These objects provide the\n * <code>ImageryCoverage</code> information, indicating the set of imagery\n * tiles that are covered by the primitive.\n *\n * The <code>ImageryPipelineStage</code> uses the <code>ImageryCoverage</code>\n * to fetch the <code>Imagery</code> object and its texture for the (x, y, level)\n * of each coverage, computes the texture translation and scale, and the covered\n * texture coordinate rectangle of that imagery texture.\n *\n * This information is summarized in an instance of this class, to later\n * be passed to the shader via uniforms.\n *\n * @private\n */\nclass ImageryInput {\n  /**\n   * Creates a new instance\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {Texture} texture The texture from the imagery\n   * @param {Cartesian4} textureTranslationAndScale The translation\n   * and scale that have to be applied to the texture, to properly\n   * be draped on the primitive. This is stored as a Cartesian4\n   * with (x,y) being the translation and (z,w) being the scale.\n   * It could be cleaner and clearer to store this as separate\n   * Cartesian2 objects, but using a single Cartesian4 probably\n   * was a design choice that was originally made in GlobeFS.glsl,\n   * with the goal to have fewer uniforms\n   * @param {Cartesian4} textureCoordinateRectangle The bounding\n   * rectangle (in texture coordinates). This directly corresponds\n   * to the <code>ImageryCoverage.textureCoordinateRectangle</code>,\n   * but converted into a Cartesian4 for the consumption in the\n   * shader\n   * @param {number} imageryTexCoordAttributeSetIndex The \"set index\"\n   * of the texture coordinate attribute that should be used. This\n   * will be used to access the texture coordinate attribute\n   * <code>a_imagery_texCoord_${imageryTexCoordAttributeSetIndex}</code>\n   * in the shader.\n   */\n  constructor(\n    imageryLayer,\n    texture,\n    textureTranslationAndScale,\n    textureCoordinateRectangle,\n    imageryTexCoordAttributeSetIndex,\n  ) {\n    this.imageryLayer = imageryLayer;\n    this.texture = texture;\n    this.textureTranslationAndScale = textureTranslationAndScale;\n    this.textureCoordinateRectangle = textureCoordinateRectangle;\n    this.imageryTexCoordAttributeSetIndex = imageryTexCoordAttributeSetIndex;\n  }\n}\n\nexport default ImageryInput;\n"],"names":["ImageryInput","imageryLayer","texture","textureTranslationAndScale","textureCoordinateRectangle","imageryTexCoordAttributeSetIndex"],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;;CAkBC,GACD,MAAMA;IACJ;;;;;;;;;;;;;;;;;;;;;;;GAuBC,GACDA,YACEC,YAAY,EACZC,OAAO,EACPC,0BAA0B,EAC1BC,0BAA0B,EAC1BC,gCAAgC,CAChC;QACA,IAAI,CAACJ,YAAY,GAAGA;QACpB,IAAI,CAACC,OAAO,GAAGA;QACf,IAAI,CAACC,0BAA0B,GAAGA;QAClC,IAAI,CAACC,0BAA0B,GAAGA;QAClC,IAAI,CAACC,gCAAgC,GAAGA;IAC1C;AACF;uCAEeL","ignoreList":[0]}},
    {"offset": {"line": 13460, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ImageryPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport Check from \"../../Core/Check.js\";\nimport Rectangle from \"../../Core/Rectangle.js\";\n\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\n\nimport ImageryLayer from \"../ImageryLayer.js\";\nimport AttributeType from \"../AttributeType.js\";\n\nimport ImageryFlags from \"./ImageryFlags.js\";\nimport ModelPrimitiveImagery from \"./ModelPrimitiveImagery.js\";\nimport ImageryInput from \"./ImageryInput.js\";\nimport ImageryState from \"../ImageryState.js\";\nimport oneTimeWarning from \"../../Core/oneTimeWarning.js\";\n\n/**\n * A compile-time debugging flag to draw the boundaries of imagery tiles\n * (Similar to \"SHOW_TILE_BOUNDARIES\" in GlobeFS.glsl)\n * @private\n */\nconst debugDrawImageryBoundaries = false;\n\n// Scratch variable for _computeTextureTranslationAndScale\nconst nativeBoundingRectangleScratch = new Rectangle();\n\n// Scratch variable for _computeTextureTranslationAndScale\nconst nativeImageryRectangleScratch = new Rectangle();\n\n/**\n * A pipeline stage that modifies the model shader to take into account\n * imagery textures that are draped over a primitive of the model, when it\n * is part a <code>Model3DTileContent</code> of a <code>Cesium3DTileset</code>\n * that has <code>imageryLayers</code> associated with it.\n *\n * Most of what is done here tries to emulate the parts from\n * https://github.com/CesiumGS/cesium/blob/6cc004aaff586bb59f07f199216ae511014cf5a9/packages/engine/Source/Shaders/GlobeFS.glsl#L166\n * that are relevant for imagery, using the more modern ShaderBuilder structures.\n *\n * @namespace ImageryPipelineStage\n *\n * @private\n */\nclass ImageryPipelineStage {\n  /**\n   * Process a primitive.\n   *\n   * This will update the render resources of the given primitive,\n   * depending on the imagery that is covered by the given primitive.\n   *\n   * This will obtain the <code>ModelPrimitiveImagery</code> from\n   * the given primitive, and use that to compute the actual\n   * <code>ImageryInput</code> objects that describe the information\n   * that has to be passed to the shader for draping the imagery over\n   * the primitive.\n   *\n   * After the <code>ImageryInput</code> has been computed, it will\n   * extend the render resources with the texture coordinate\n   * attribute that has to be used for the imagery, and augment\n   * the <code>primitiveRenderResources.shaderBuilder</code> with\n   * the information hat is required for the draping.\n   *\n   * @param {PrimitiveRenderResources} primitiveRenderResources The render resources for the primitive\n   * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n   * @param {FrameState} frameState The frame state.\n   */\n  static process(primitiveRenderResources, primitive, frameState) {\n    const model = primitiveRenderResources.model;\n    const modelPrimitiveImagery = primitive.modelPrimitiveImagery;\n\n    // When the creation of the model primitive imagery is happening\n    // asynchronously, then the primitive may not yet contain it.\n    // Return early in this case\n    if (!defined(modelPrimitiveImagery)) {\n      return;\n    }\n\n    // Similarly, when the model primitive imagery is not yet ready,\n    // then nothing can be done here\n    if (!modelPrimitiveImagery.ready) {\n      return;\n    }\n\n    // Compute the arrays containing ALL projections and the array\n    // containing the UNIQUE projections from the imagery layers,\n    // to establish the mapping between the imagery index and the\n    // imagery texture coordinate attribute set index.\n    // (This should be implemented and/or documented better...)\n    const imageryLayers = model.imageryLayers;\n    const allProjections =\n      ModelPrimitiveImagery._extractProjections(imageryLayers);\n    const uniqueProjections = [...new Set(allProjections)];\n    const imageryTexCoordAttributeSetIndices =\n      ImageryPipelineStage._computeIndexMapping(\n        allProjections,\n        uniqueProjections,\n      );\n\n    // Create the `ImageryInput` objects that describe\n    // - the texture\n    // - texture coordinate rectangle\n    // - translation and scale\n    // - index of the imagery texture coordinate attribute\n    // to be passed to the actual imagery pipeline stage execution\n    const imageryInputs = ImageryPipelineStage._createImageryInputs(\n      imageryLayers,\n      modelPrimitiveImagery,\n      imageryTexCoordAttributeSetIndices,\n    );\n\n    // This can happen when none of the imagery textures could\n    // be obtained, because they had all been INVALID/FAILED,\n    // or when none of the imagery layers is actually visible\n    // according to `show==true`\n    // Bail out in this case\n    if (imageryInputs.length === 0) {\n      return;\n    }\n\n    // TODO_DRAPING This will have to be handled with upsampling.\n    // For now, just truncate the textures to not exceed the\n    // number of texture units\n    if (imageryInputs.length > 10) {\n      oneTimeWarning(\n        \"imagery-texture-units\",\n        `Warning: Draped imagery requires ${imageryInputs.length} texture units, truncating`,\n      );\n      imageryInputs.length = 10;\n    }\n\n    // Add the imagery texture coordinate attributes to the render\n    // resources\n    ImageryPipelineStage._addImageryTexCoordAttributesToRenderResources(\n      modelPrimitiveImagery,\n      primitiveRenderResources,\n    );\n\n    const imageryLayersArray = [];\n    for (let i = 0; i < imageryLayers.length; i++) {\n      imageryLayersArray.push(imageryLayers.get(i));\n    }\n\n    ImageryPipelineStage._processImageryInputs(\n      imageryLayersArray,\n      primitiveRenderResources,\n      imageryInputs,\n      uniqueProjections.length,\n    );\n  }\n\n  /**\n   * Add one attribute to the render resources, for each imagery texture\n   * coordinate that was computed in the given model primitive imagery\n   * (one for each projection)\n   *\n   * @param {ModelPrimitiveImagery} modelPrimitiveImagery The model primitive imagery\n   * @param {PrimitiveRenderResources} primitiveRenderResources The render resources\n   */\n  static _addImageryTexCoordAttributesToRenderResources(\n    modelPrimitiveImagery,\n    primitiveRenderResources,\n  ) {\n    const imageryTexCoordAttributes =\n      modelPrimitiveImagery.imageryTexCoordAttributesPerProjection();\n    for (const imageryTexCoordAttribute of imageryTexCoordAttributes) {\n      ImageryPipelineStage._addImageryTexCoordAttributeToRenderResources(\n        imageryTexCoordAttribute,\n        primitiveRenderResources,\n      );\n    }\n  }\n\n  /**\n   * Add the given attribute to the render resources\n   *\n   * @param {ModelComponents.Attribute} imageryTexCoordAttribute The attribute\n   * @param {PrimitiveRenderResources} primitiveRenderResources The render resources\n   */\n  static _addImageryTexCoordAttributeToRenderResources(\n    imageryTexCoordAttribute,\n    primitiveRenderResources,\n  ) {\n    const componentsPerAttribute = AttributeType.getNumberOfComponents(\n      imageryTexCoordAttribute.type,\n    );\n    // Convert the given object into another object that essentially\n    // contains the same information, but not exactly, and with most\n    // properties having slightly different names. Shrug.\n    const renderResourcesAttribute = {\n      index: primitiveRenderResources.attributeIndex++,\n      value: defined(imageryTexCoordAttribute.buffer)\n        ? undefined\n        : imageryTexCoordAttribute.constant,\n      vertexBuffer: imageryTexCoordAttribute.buffer,\n      count: imageryTexCoordAttribute.count,\n      componentsPerAttribute: componentsPerAttribute,\n      componentDatatype: imageryTexCoordAttribute.componentDatatype,\n      offsetInBytes: imageryTexCoordAttribute.byteOffset,\n      strideInBytes: imageryTexCoordAttribute.byteStride,\n      normalize: imageryTexCoordAttribute.normalized,\n    };\n    primitiveRenderResources.attributes.push(renderResourcesAttribute);\n  }\n\n  /**\n   * Process the <code>ImageryInput</code> objects that have been\n   * created in <code>process</code>.\n   *\n   * This will build the shader, containing the attributes, uniforms,\n   * and \"sample and blend\" function that is required according to\n   * the given imagery inputs\n   *\n   * @param {ImageryLayer[]} imageryLayersArray The imagery layers\n   * @param {PrimitiveRenderResources} primitiveRenderResources The primitive render resources\n   * @param {ImageryInput[]} imageryInputs The imagery inputs\n   * @param {number} numImageryTexCoordAttributes The number of texture coordinate\n   * attributes that have been created for the imagery (one for each distinct\n   * projection that was found in the imagery layers)\n   */\n  static _processImageryInputs(\n    imageryLayersArray,\n    renderResources,\n    imageryInputs,\n    numImageryTexCoordAttributes,\n  ) {\n    const shaderBuilder = renderResources.shaderBuilder;\n\n    const imageryFlags =\n      ImageryPipelineStage._computeImageryFlags(imageryLayersArray);\n    const numTextures = imageryInputs.length;\n\n    // Set the global defines indicating the presence and number of\n    // imagery textures.\n    shaderBuilder.addDefine(`HAS_IMAGERY`);\n    shaderBuilder.addDefine(`IMAGERY_TEXTURE_UNITS ${numTextures}`);\n\n    ImageryPipelineStage._addAttributes(\n      shaderBuilder,\n      numImageryTexCoordAttributes,\n    );\n\n    ImageryPipelineStage._defineUniforms(shaderBuilder, imageryFlags);\n    ImageryPipelineStage._buildSampleAndBlendFunction(\n      shaderBuilder,\n      imageryFlags,\n    );\n\n    ImageryPipelineStage._createMainImageryShader(\n      shaderBuilder,\n      imageryInputs,\n      imageryFlags,\n    );\n\n    const uniformMap = renderResources.uniformMap;\n    const uniforms = ImageryPipelineStage._createImageryUniforms(imageryInputs);\n    ImageryPipelineStage._setImageryUniforms(uniformMap, uniforms);\n  }\n\n  /**\n   * Add the attribute- and varying definitions for the imagery texture\n   * coordinates to the given shader.\n   *\n   * This includes the definition of the <code>initializeImageryAttributes</code>\n   * function that assigns the attribute values to varyings in the vertex shader.\n   *\n   * @param {ShaderBuilder} shaderBuilder The shader builder\n   * @param {number} numTexCoords The number of imagery texture coordinate sets\n   */\n  static _addAttributes(shaderBuilder, numTexCoords) {\n    for (let i = 0; i < numTexCoords; i++) {\n      shaderBuilder.addAttribute(\"vec2\", `a_imagery_texCoord_${i}`);\n      shaderBuilder.addVarying(\"vec2\", `v_imagery_texCoord_${i}`);\n    }\n\n    const functionId = \"initializeImageryAttributes\";\n    const signature = `void ${functionId}()`;\n    shaderBuilder.addFunction(functionId, signature, ShaderDestination.VERTEX);\n\n    for (let i = 0; i < numTexCoords; i++) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `v_imagery_texCoord_${i} = a_imagery_texCoord_${i};`,\n      ]);\n    }\n  }\n\n  /**\n   * Returns the `ImageryFlags` that indicate the features that are\n   * required for the given imagery layers.\n   *\n   * The resulting flags will indicate whether any of the given\n   * imagery layer objects did *not* have the default value for\n   * the respective property, as defined by `ImageryLayer.DEFAULT_...`\n   *\n   * @param {ImageryLayer[]} imageryLayers The imagery layers\n   * @returns {ImageryFlags} The imagery flags\n   */\n  static _computeImageryFlags(imageryLayers) {\n    const imageryFlags = new ImageryFlags();\n    for (let i = 0; i < imageryLayers.length; i++) {\n      const imageryLayer = imageryLayers[i];\n\n      // These are short-circuiting to `number` instead\n      // of `boolean` here. With \"ecmaVersion: 2021\", we\n      // could use \"||=\" here. Otherwise, there is no\n      // nice shortcut for this.\n      imageryFlags.alpha |= imageryLayer.alpha !== 1.0;\n      imageryFlags.brightness |=\n        imageryLayer.brightness !== ImageryLayer.DEFAULT_BRIGHTNESS;\n      imageryFlags.contrast |=\n        imageryLayer.contrast !== ImageryLayer.DEFAULT_CONTRAST;\n      imageryFlags.hue |= imageryLayer.hue !== ImageryLayer.DEFAULT_HUE;\n      imageryFlags.saturation |=\n        imageryLayer.saturation !== ImageryLayer.DEFAULT_SATURATION;\n      imageryFlags.gamma |= imageryLayer.gamma !== ImageryLayer.DEFAULT_GAMMA;\n      const hasColorToAlpha =\n        defined(imageryLayer.colorToAlpha) &&\n        imageryLayer.colorToAlphaThreshold > 0.0;\n      imageryFlags.colorToAlpha |= hasColorToAlpha;\n    }\n    return imageryFlags;\n  }\n\n  /**\n   * Adds the uniforms that are required for the imagery to the shader.\n   *\n   * This will use the given shader builder to add the uniforms to the\n   * shader that are always required for the imagery (e.g. the\n   * `sampler2D u_imageryTextures[...]`).\n   *\n   * The array size of all arrays will be `IMAGERY_TEXTURE_UNITS`,\n   * so this has to be added as a `define` with a positive value.\n   *\n   * Depending on the given imagery flags being `true`, it will add\n   * the optional uniforms, like `u_imageryTextureAlpha`.\n   *\n   * The naming pattern will be `u_imageryTexture<name>`, except for\n   * `gamma`: To safe that one measly division, the thane will be\n   * `oneOverGamma` there.\n   *\n   * @param {ShaderBuilder} shaderBuilder The shader builder\n   * @param {ImageryFlags} imageryFlags The imagery flags\n   */\n  static _defineUniforms(shaderBuilder, imageryFlags) {\n    shaderBuilder.addUniform(\n      \"sampler2D\",\n      \"u_imageryTextures[IMAGERY_TEXTURE_UNITS]\",\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addUniform(\n      \"vec4\",\n      \"u_imageryTextureCoordinateRectangle[IMAGERY_TEXTURE_UNITS]\",\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addUniform(\n      \"vec4\",\n      \"u_imageryTextureTranslationAndScale[IMAGERY_TEXTURE_UNITS]\",\n      ShaderDestination.FRAGMENT,\n    );\n\n    if (imageryFlags.alpha) {\n      shaderBuilder.addUniform(\n        \"float\",\n        \"u_imageryTextureAlpha[IMAGERY_TEXTURE_UNITS]\",\n        ShaderDestination.FRAGMENT,\n      );\n    }\n    if (imageryFlags.brightness) {\n      shaderBuilder.addUniform(\n        \"float\",\n        \"u_imageryTextureBrightness[IMAGERY_TEXTURE_UNITS]\",\n        ShaderDestination.FRAGMENT,\n      );\n    }\n    if (imageryFlags.contrast) {\n      shaderBuilder.addUniform(\n        \"float\",\n        \"u_imageryTextureContrast[IMAGERY_TEXTURE_UNITS]\",\n        ShaderDestination.FRAGMENT,\n      );\n    }\n    if (imageryFlags.hue) {\n      shaderBuilder.addUniform(\n        \"float\",\n        \"u_imageryTextureHue[IMAGERY_TEXTURE_UNITS]\",\n        ShaderDestination.FRAGMENT,\n      );\n    }\n    if (imageryFlags.saturation) {\n      shaderBuilder.addUniform(\n        \"float\",\n        \"u_imageryTextureSaturation[IMAGERY_TEXTURE_UNITS]\",\n        ShaderDestination.FRAGMENT,\n      );\n    }\n    if (imageryFlags.gamma) {\n      shaderBuilder.addUniform(\n        \"float\",\n        \"u_imageryTextureOneOverGamma[IMAGERY_TEXTURE_UNITS]\",\n        ShaderDestination.FRAGMENT,\n      );\n    }\n    if (imageryFlags.colorToAlpha) {\n      shaderBuilder.addUniform(\n        \"vec4\",\n        \"u_imageryTextureColorToAlpha[IMAGERY_TEXTURE_UNITS]\",\n        ShaderDestination.FRAGMENT,\n      );\n    }\n  }\n\n  /**\n   * Create the function signature for the `sampleAndBlend` function,\n   * based on the features that are required for the imagery.\n   *\n   * For details, see `buildSampleAndBlendFunction`\n   *\n   * @param {ImageryFlags} imageryFlags The imagery flags\n   * @returns {string} The string\n   */\n  static _createSampleAndBlendFunctionSignature(imageryFlags) {\n    const functionId = \"sampleAndBlend\";\n    const parameters = [];\n    parameters.push(`vec4 previousColor`);\n    parameters.push(`sampler2D textureToSample`);\n    parameters.push(`vec2 textureCoordinates`);\n    parameters.push(`vec4 textureCoordinateRectangle`);\n    parameters.push(`vec4 textureCoordinateTranslationAndScale`);\n    if (imageryFlags.alpha) {\n      parameters.push(`float textureAlpha`);\n    }\n    if (imageryFlags.brightness) {\n      parameters.push(`float textureBrightness`);\n    }\n    if (imageryFlags.contrast) {\n      parameters.push(`float textureContrast`);\n    }\n    if (imageryFlags.hue) {\n      parameters.push(`float textureHue`);\n    }\n    if (imageryFlags.saturation) {\n      parameters.push(`float textureSaturation`);\n    }\n    if (imageryFlags.gamma) {\n      parameters.push(`float textureOneOverGamma`);\n    }\n    if (imageryFlags.colorToAlpha) {\n      parameters.push(`vec4 colorToAlpha`);\n    }\n    const parametersString = parameters.join(\", \");\n\n    const signature = `vec4 ${functionId}(${parametersString})`;\n    return signature;\n  }\n\n  /**\n   * Build the `sampleAndBlend` function that will be called for each imagery,\n   * to combine the previous pixel color with the respective imagery input.\n   *\n   * The function that is built here resembles the function that was originally defined at\n   * https://github.com/CesiumGS/cesium/blob/6cc004aaff586bb59f07f199216ae511014cf5a9/packages/engine/Source/Shaders/GlobeFS.glsl#L166\n   *\n   * However, for the function that is built here, the signature will\n   * reflect the actual features that are required for the imagery:\n   * For example, the `float textureAlpha` parameter will only be\n   * present when `imageryFlags.alpha` is `true`.\n   *\n   * @param {ShaderBuilder} shaderBuilder The shader builder\n   * @param {ImageryFlags} imageryFlags The imagery flags\n   */\n  static _buildSampleAndBlendFunction(shaderBuilder, imageryFlags) {\n    const functionId = \"sampleAndBlend\";\n    const signature =\n      ImageryPipelineStage._createSampleAndBlendFunctionSignature(imageryFlags);\n    shaderBuilder.addFunction(\n      functionId,\n      signature,\n      ShaderDestination.FRAGMENT,\n    );\n\n    shaderBuilder.addFunctionLines(functionId, [`float effectiveAlpha = 1.0;`]);\n    if (imageryFlags.alpha) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `effectiveAlpha = textureAlpha;`,\n      ]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [\n      // This is the part that is documented as \"This crazy step stuff\"\n      // in GlobeFS.glsl. Using the if-approach here...\n      `if (textureCoordinates.x < textureCoordinateRectangle.x) effectiveAlpha = 0.0;`,\n      `if (textureCoordinates.x > textureCoordinateRectangle.z) effectiveAlpha = 0.0;`,\n      `if (textureCoordinates.y < textureCoordinateRectangle.y) effectiveAlpha = 0.0;`,\n      `if (textureCoordinates.y > textureCoordinateRectangle.w) effectiveAlpha = 0.0;`,\n\n      `vec2 translation = textureCoordinateTranslationAndScale.xy;`,\n      `vec2 scale = textureCoordinateTranslationAndScale.zw;`,\n      `vec2 effectiveTextureCoordinates = textureCoordinates * scale + translation;`,\n      `vec4 value = texture(textureToSample, effectiveTextureCoordinates);`,\n      `value = czm_srgbToLinear(value);`,\n\n      `vec3 color = value.rgb;`,\n      `float alpha = value.a;`,\n    ]);\n\n    if (imageryFlags.colorToAlpha) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `vec3 colorDiff = abs(color.rgb - colorToAlpha.rgb);`,\n        `colorDiff.r = czm_maximumComponent(colorDiff);`,\n        `alpha = czm_branchFreeTernary(colorDiff.r < colorToAlpha.a, 0.0, alpha);`,\n      ]);\n    }\n\n    if (imageryFlags.gamma) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `color = pow(color, vec3(textureOneOverGamma));`,\n      ]);\n    } else {\n      shaderBuilder.addFunctionLines(functionId, [\n        `vec4 tempColor = czm_gammaCorrect(vec4(color, alpha));`,\n        `color = tempColor.rgb;`,\n        `alpha = tempColor.a;`,\n      ]);\n    }\n\n    if (imageryFlags.brightness) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `color = mix(vec3(0.0), color, textureBrightness);`,\n      ]);\n    }\n\n    if (imageryFlags.contrast) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `color = mix(vec3(0.5), color, textureContrast);`,\n      ]);\n    }\n    if (imageryFlags.hue) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `color = czm_hue(color, textureHue);`,\n      ]);\n    }\n\n    if (imageryFlags.saturation) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `color = czm_saturation(color, textureSaturation);`,\n      ]);\n    }\n\n    shaderBuilder.addFunctionLines(functionId, [\n      `float sourceAlpha = alpha * effectiveAlpha;`,\n      `float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);`,\n      `outAlpha += sign(outAlpha) - 1.0;`,\n      `vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;`,\n      // See comments in https://github.com/CesiumGS/cesium/blob/6cc004aaff586bb59f07f199216ae511014cf5a9/packages/engine/Source/Shaders/GlobeFS.glsl#L166\n      `vec4 result = vec4(outColor, max(outAlpha, 0.0));`,\n    ]);\n\n    // Debug mode: Draw boundaries of imagery in red\n    if (debugDrawImageryBoundaries) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `if (abs(textureCoordinates.x - textureCoordinateRectangle.x) < (1.0/256.0) || `,\n        `    abs(textureCoordinates.x - textureCoordinateRectangle.z) < (1.0/256.0) || `,\n        `    abs(textureCoordinates.y - textureCoordinateRectangle.y) < (1.0/256.0) || `,\n        `    abs(textureCoordinates.y - textureCoordinateRectangle.w) < (1.0/256.0))`,\n        `{`,\n        `    result = vec4(1.0, 0.0, 0.0, effectiveAlpha);`,\n        `}`,\n      ]);\n    }\n\n    shaderBuilder.addFunctionLines(functionId, [`return result;`]);\n  }\n\n  /**\n   * Creates the arguments for a call to `sampleAndBlend` for the\n   * specified imagery.\n   *\n   * For details, see `buildSampleAndBlendFunction`\n   *\n   * @param {ImageryFlags} imageryFlags The imagery flags\n   * @param {number} imageryTexCoordAttributeSetIndex The index for the texture coordinate attribute\n   * @param {number} i The imagery index\n   * @returns {string} The string\n   */\n  static _createSampleAndBlendCallArguments(\n    imageryFlags,\n    imageryTexCoordAttributeSetIndex,\n    i,\n  ) {\n    const textureCoordinates = `v_imagery_texCoord_${imageryTexCoordAttributeSetIndex}`;\n\n    const args = [];\n    args.push(`blendedBaseColor`);\n    args.push(`u_imageryTextures[${i}]`);\n    args.push(`${textureCoordinates}`);\n    args.push(`u_imageryTextureCoordinateRectangle[${i}]`);\n    args.push(`u_imageryTextureTranslationAndScale[${i}]`);\n    if (imageryFlags.alpha) {\n      args.push(`u_imageryTextureAlpha[${i}]`);\n    }\n    if (imageryFlags.brightness) {\n      args.push(`u_imageryTextureBrightness[${i}]`);\n    }\n    if (imageryFlags.contrast) {\n      args.push(`u_imageryTextureContrast[${i}]`);\n    }\n    if (imageryFlags.hue) {\n      args.push(`u_imageryTextureHue[${i}]`);\n    }\n    if (imageryFlags.saturation) {\n      args.push(`u_imageryTextureSaturation[${i}]`);\n    }\n    if (imageryFlags.gamma) {\n      args.push(`u_imageryTextureOneOverGamma[${i}]`);\n    }\n    if (imageryFlags.colorToAlpha) {\n      args.push(`u_imageryTextureColorToAlpha[${i}]`);\n    }\n\n    const argsString = args.join(\", \");\n    return argsString;\n  }\n\n  /**\n   * Creates the main part of the imagery shader.\n   *\n   * It adds the `blendBaseColorWithImagery` function, which is to be\n   * called in the `MaterialStageFS.glsl` when the `HAS_IMAGERY`\n   * flag was set in the shader.\n   *\n   * The `blendBaseColorWithImagery` function will go through all imagery\n   * layers in the input, and call the `sampleAndBlend` function, to\n   * incorporate the imagery input in the resulting pixel.\n   *\n   * @param {ShaderBuilder} shaderBuilder The shader builder\n   * @param {ImageryInput[]} imageryInputs The imagery inputs\n   * @param {ImageryFlags} imageryFlags The imagery flags\n   */\n  static _createMainImageryShader(shaderBuilder, imageryInputs, imageryFlags) {\n    const functionId = \"blendBaseColorWithImagery\";\n    shaderBuilder.addFunction(\n      functionId,\n      `vec4 blendBaseColorWithImagery(vec4 baseColorWithAlpha)`,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addFunctionLines(functionId, [\n      `vec4 blendedBaseColor = baseColorWithAlpha;`,\n    ]);\n\n    // Roughly what was done in https://github.com/CesiumGS/cesium/blob/6cc004aaff586bb59f07f199216ae511014cf5a9/packages/engine/Source/Scene/GlobeSurfaceShaderSet.js#L394\n    for (let i = 0; i < imageryInputs.length; i++) {\n      const imageryInput = imageryInputs[i];\n      const imageryTexCoordAttributeSetIndex =\n        imageryInput.imageryTexCoordAttributeSetIndex;\n      const argsString =\n        ImageryPipelineStage._createSampleAndBlendCallArguments(\n          imageryFlags,\n          imageryTexCoordAttributeSetIndex,\n          i,\n        );\n      shaderBuilder.addFunctionLines(functionId, [\n        `blendedBaseColor = sampleAndBlend(${argsString});`,\n      ]);\n    }\n\n    shaderBuilder.addFunctionLines(functionId, [`return blendedBaseColor;`]);\n  }\n\n  /**\n   * Creates an object that contains the uniform values the given imagery inputs.\n   *\n   * The result will be a structure that contains the uniform values\n   * that match the definitions that have been created by `defineUniforms`.\n   * (It will include the ones that still have their default values\n   * and may not be needed eventually)\n   *\n   * @param {ImageryInput[]} imageryInputs The imagery inputs\n   * @returns {object} The uniforms\n   */\n  static _createImageryUniforms(imageryInputs) {\n    const length = imageryInputs.length;\n    const uniforms = {};\n    uniforms.imageryTextures = Array(length);\n    uniforms.imageryTextureCoordinateRectangle = Array(length);\n    uniforms.imageryTextureTranslationAndScale = Array(length);\n    uniforms.imageryTextureAlpha = Array(length);\n    uniforms.imageryTextureBrightness = Array(length);\n    uniforms.imageryTextureContrast = Array(length);\n    uniforms.imageryTextureHue = Array(length);\n    uniforms.imageryTextureSaturation = Array(length);\n    uniforms.imageryTextureOneOverGamma = Array(length);\n    uniforms.imageryTextureColorToAlpha = Array(length);\n\n    for (let i = 0; i < length; i++) {\n      const imageryInput = imageryInputs[i];\n\n      const imageryLayer = imageryInput.imageryLayer;\n      const texture = imageryInput.texture;\n      const textureCoordinateRectangle =\n        imageryInput.textureCoordinateRectangle;\n      const textureTranslationAndScale =\n        imageryInput.textureTranslationAndScale;\n\n      uniforms.imageryTextures[i] = texture;\n      uniforms.imageryTextureTranslationAndScale[i] =\n        textureTranslationAndScale;\n      uniforms.imageryTextureCoordinateRectangle[i] =\n        textureCoordinateRectangle;\n\n      uniforms.imageryTextureAlpha[i] = imageryLayer.alpha;\n      uniforms.imageryTextureBrightness[i] = imageryLayer.brightness;\n      uniforms.imageryTextureContrast[i] = imageryLayer.contrast;\n      uniforms.imageryTextureHue[i] = imageryLayer.hue;\n      uniforms.imageryTextureSaturation[i] = imageryLayer.saturation;\n      uniforms.imageryTextureOneOverGamma[i] = 1.0 / imageryLayer.gamma;\n\n      let colorToAlpha = uniforms.imageryTextureColorToAlpha[i];\n      if (!defined(colorToAlpha)) {\n        colorToAlpha = new Cartesian4();\n        uniforms.imageryTextureColorToAlpha[i] = colorToAlpha;\n      }\n      const hasColorToAlpha =\n        defined(imageryLayer.colorToAlpha) &&\n        imageryLayer.colorToAlphaThreshold > 0.0;\n      if (hasColorToAlpha) {\n        const color = imageryLayer.colorToAlpha;\n        colorToAlpha.x = color.red;\n        colorToAlpha.y = color.green;\n        colorToAlpha.z = color.blue;\n        colorToAlpha.w = imageryLayer.colorToAlphaThreshold;\n      } else {\n        colorToAlpha.w = -1.0;\n      }\n    }\n    return uniforms;\n  }\n\n  /**\n   * Fill the given uniform map with functions for all properties\n   * in the given uniforms object.\n   *\n   * The uniform names will be created as `u_<propertyName>`, and\n   * their value will just be a function that returns the respective\n   * property value.\n   *\n   * @param {UniformMap} uniformMap The uniform map\n   * @param {object} uniforms The uniforms\n   */\n  static _setImageryUniforms(uniformMap, uniforms) {\n    for (const key in uniforms) {\n      if (uniforms.hasOwnProperty(key)) {\n        const name = `u_${key}`;\n        uniformMap[name] = function () {\n          return uniforms[key];\n        };\n      }\n    }\n  }\n\n  /**\n   * Create the <code>ImageryInput</code> objects that have to be fed to the imagery\n   * pipeline stage for draping the given imagery layers over the primitive\n   * that is described by the given model primitive imagery.\n   *\n   * For each imagery layer that is currently visible (as of `show==true`), this\n   * will obtain the <code>ImageryCoverage</code> objects that are provided by\n   * the given model primitive imagery (and that describe the imagery tiles\n   * that are covered by the primitive), and create one <code>ImageryInput</code> for\n   * each of them.\n   *\n   * @param {ImageryLayerCollection} imageryLayers The imagery layers\n   * @param {ModelPrimitiveImagery} modelPrimitiveImagery The model primitive imagery\n   * @param {number[]} imageryTexCoordAttributeSetIndices The array that contains,\n   * for each imagery layer index, the set index of the texture coordinate\n   * attribute that should be used for this imagery. This is the value that\n   * will be used to access the texture coordinate attribute\n   * <code>a_imagery_texCoord_${imageryTexCoordAttributeSetIndex}</code>\n   * in the shader.\n   * @returns {ImageryInput[]} The imagery inputs\n   */\n  static _createImageryInputs(\n    imageryLayers,\n    modelPrimitiveImagery,\n    imageryTexCoordAttributeSetIndices,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayers\", imageryLayers);\n    Check.defined(\"modelPrimitiveImagery\", modelPrimitiveImagery);\n    Check.defined(\n      \"imageryTexCoordAttributeSetIndices\",\n      imageryTexCoordAttributeSetIndices,\n    );\n    //>>includeEnd('debug');\n\n    const imageryInputs = [];\n\n    for (let i = 0; i < imageryLayers.length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      if (!imageryLayer.show) {\n        continue;\n      }\n      const imageryTexCoordAttributeSetIndex =\n        imageryTexCoordAttributeSetIndices[i];\n      const mappedPositions =\n        modelPrimitiveImagery.mappedPositionsForImageryLayer(imageryLayer);\n      const cartographicBoundingRectangle =\n        mappedPositions.cartographicBoundingRectangle;\n      const coverages =\n        modelPrimitiveImagery.coveragesForImageryLayer(imageryLayer);\n\n      for (let j = 0; j < coverages.length; j++) {\n        const coverage = coverages[j];\n        const imageryInput = ImageryPipelineStage._createImageryInput(\n          imageryLayer,\n          coverage,\n          cartographicBoundingRectangle,\n          imageryTexCoordAttributeSetIndex,\n        );\n        if (defined(imageryInput)) {\n          imageryInputs.push(imageryInput);\n        }\n      }\n    }\n    return imageryInputs;\n  }\n\n  /**\n   * Create the `ImageryInput` that has to be passed to the imagery pipeline\n   * stage, for the given `ImageryCoverage`.\n   *\n   * The `ImageryCoverage` describes on imagery tile that is covered by the\n   * cartographic bounding rectangle of the primitive positions. This function\n   * obtains the actual `Imagery` object and its texture, computes the\n   * required texture coordinate and scale, and assembles this information\n   * into an `ImageryInput`.\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {ImageryCoverage} coverage The imagery coverage\n   * @param {Rectangle} cartographicBoundingRectangle The bounding rectangle\n   * of the cartographic primitive positions\n   * @param {number} imageryTexCoordAttributeSetIndex The set index of the\n   * texture coordinate attribute that should be used for this imagery.\n   * This is the value that will be used to access the texture coordinate\n   * attribute <code>a_imagery_texCoord_${imageryTexCoordAttributeSetIndex}</code>\n   * in the shader.\n   * @returns {ImageryInput|undefined} The imagery input, or undefined if\n   * the imagery for the given coverage turned out to be in the\n   * <code>ImageryState.INVALID/FAILED<code> state, or did not have\n   * a valid texture.\n   * @private\n   */\n  static _createImageryInput(\n    imageryLayer,\n    coverage,\n    cartographicBoundingRectangle,\n    imageryTexCoordAttributeSetIndex,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayer\", imageryLayer);\n    Check.defined(\"coverage\", coverage);\n    Check.defined(\n      \"cartographicBoundingRectangle\",\n      cartographicBoundingRectangle,\n    );\n    Check.typeOf.number.greaterThanOrEquals(\n      \"imageryTexCoordAttributeSetIndex\",\n      imageryTexCoordAttributeSetIndex,\n      0,\n    );\n    //>>includeEnd('debug');\n\n    // Bail out early if something went wrong in the imagery\n    // loading state machine\n    const imagery = coverage.imagery;\n    if (\n      imagery.state === ImageryState.FAILED ||\n      imagery.state === ImageryState.INVALID\n    ) {\n      return undefined;\n    }\n\n    // The texture coordinates are computed for the respective\n    // imagery, so pick either the textureWebMercator or the\n    // texture here\n    let texture = imagery.textureWebMercator;\n    if (!defined(texture)) {\n      texture = imagery.texture;\n      if (!defined(texture)) {\n        // Print an error message only when the imagery\n        // SHOULD actually have a texture\n        if (imagery.state === ImageryState.READY) {\n          console.log(\n            `Imagery at ${coverage.x}, ${coverage.y} (level ${coverage.level}) does not have any texture - state ${imagery.state}`,\n          );\n        }\n        return undefined;\n      }\n    }\n\n    const textureTranslationAndScale =\n      ImageryPipelineStage._computeTextureTranslationAndScale(\n        imageryLayer,\n        cartographicBoundingRectangle,\n        imagery.rectangle,\n      );\n\n    // Convert the texture coordinate rectangle into a Cartesian4\n    // for the consumption as a uniform in the shader\n    const textureCoordinateCartesianRectangle =\n      coverage.textureCoordinateRectangle;\n    const textureCoordinateRectangle = new Cartesian4(\n      textureCoordinateCartesianRectangle.minX,\n      textureCoordinateCartesianRectangle.minY,\n      textureCoordinateCartesianRectangle.maxX,\n      textureCoordinateCartesianRectangle.maxY,\n    );\n\n    const imageryInput = new ImageryInput(\n      imageryLayer,\n      texture,\n      textureTranslationAndScale,\n      textureCoordinateRectangle,\n      imageryTexCoordAttributeSetIndex,\n    );\n    return imageryInput;\n  }\n\n  /**\n   * Compute the translation and scale that has to be applied to\n   * the texture coordinates for mapping the given imagery to\n   * the geometry.\n   *\n   * The given rectangles will be converted into their \"native\" representation,\n   * using the tiling scheme of the given imagery layer, and passed\n   * to `_computeTextureTranslationAndScaleFromNative` (see that for details).\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {Rectangle} nonNativeBoundingRectangle The bounding\n   * rectangle of the geometry\n   * @param {Rectangle} nonNativeImageryRectangle The bounding\n   * rectangle of the imagery\n   * @returns {Cartesian4} The translation and scale\n   * @private\n   */\n  static _computeTextureTranslationAndScale(\n    imageryLayer,\n    nonNativeBoundingRectangle,\n    nonNativeImageryRectangle,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayer\", imageryLayer);\n    Check.defined(\"nonNativeBoundingRectangle\", nonNativeBoundingRectangle);\n    Check.defined(\"nonNativeImageryRectangle\", nonNativeImageryRectangle);\n    //>>includeEnd('debug');\n\n    const tilingScheme = imageryLayer.imageryProvider.tilingScheme;\n\n    const nativeBoundingRectangle = tilingScheme.rectangleToNativeRectangle(\n      nonNativeBoundingRectangle,\n      nativeBoundingRectangleScratch,\n    );\n    const nativeImageryRectangle = tilingScheme.rectangleToNativeRectangle(\n      nonNativeImageryRectangle,\n      nativeImageryRectangleScratch,\n    );\n\n    const translationAndScale =\n      ImageryPipelineStage._computeTextureTranslationAndScaleFromNative(\n        nativeBoundingRectangle,\n        nativeImageryRectangle,\n      );\n    return translationAndScale;\n  }\n\n  /**\n   * Compute the translation and scale that has to be applied to\n   * the texture coordinates for mapping the given imagery rectangle\n   * to the geometry rectangle.\n   *\n   * This will compute a Cartesian4 containing the\n   * (offsetX, offsetY, scaleX, scaleY) that have to be applied to\n   * the texture coordinates that that have been computed with\n   * `ModelImageryMapping.createTextureCoordinatesAttributeForMappedPositions`.\n   * In the shader, this offset and scale will map the given imagery rectangle\n   * to the geometry * rectangle.\n   *\n   * @param {Imagery} imagery The imagery\n   * @param {Rectangle} nonNativeBoundingRectangle The bounding\n   * rectangle of the geometry\n   * @param {Rectangle} nonNativeImageryRectangle The bounding\n   * rectangle of the imagery\n   * @returns {Cartesian4} The translation and scale\n   * @private\n   */\n  static _computeTextureTranslationAndScaleFromNative(\n    nativeBoundingRectangle,\n    nativeImageryRectangle,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"nativeBoundingRectangle\", nativeBoundingRectangle);\n    Check.defined(\"nativeImageryRectangle\", nativeImageryRectangle);\n    //>>includeEnd('debug');\n\n    const invImageryWidth = 1.0 / nativeImageryRectangle.width;\n    const invImageryHeight = 1.0 / nativeImageryRectangle.height;\n    const deltaWest =\n      nativeBoundingRectangle.west - nativeImageryRectangle.west;\n    const deltaSouth =\n      nativeBoundingRectangle.south - nativeImageryRectangle.south;\n    const offsetX = deltaWest * invImageryWidth;\n    const offsetY = deltaSouth * invImageryHeight;\n    const scaleX = nativeBoundingRectangle.width * invImageryWidth;\n    const scaleY = nativeBoundingRectangle.height * invImageryHeight;\n    return new Cartesian4(offsetX, offsetY, scaleX, scaleY);\n  }\n\n  /**\n   * Computes the index mapping from the given source to the given target.\n   *\n   * The result will be an array that has the same length as the source,\n   * and contains the indices that the source elements have in the\n   * target array.\n   *\n   * @param {object[]} source The source array\n   * @param {object[]} target The target array\n   * @returns {number[]} The result\n   */\n  static _computeIndexMapping(source, target) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"source\", source);\n    Check.defined(\"target\", target);\n    //>>includeEnd('debug');\n\n    const result = [];\n    const length = source.length;\n    for (let i = 0; i < length; i++) {\n      const element = source[i];\n      const index = target.indexOf(element);\n      result.push(index);\n    }\n    return result;\n  }\n}\n\n// Static properties (direct initialization disallowed by eslint)\n//ImageryPipelineStage.name = \"ImageryPipelineStage\"; // Helps with debugging, if you know where to look\n\nexport default ImageryPipelineStage;\n"],"names":["debugDrawImageryBoundaries","nativeBoundingRectangleScratch","nativeImageryRectangleScratch","ImageryPipelineStage","process","primitiveRenderResources","primitive","frameState","model","modelPrimitiveImagery","ready","imageryLayers","allProjections","_extractProjections","uniqueProjections","Set","imageryTexCoordAttributeSetIndices","_computeIndexMapping","imageryInputs","_createImageryInputs","length","_addImageryTexCoordAttributesToRenderResources","imageryLayersArray","i","push","get","_processImageryInputs","imageryTexCoordAttributes","imageryTexCoordAttributesPerProjection","imageryTexCoordAttribute","_addImageryTexCoordAttributeToRenderResources","componentsPerAttribute","getNumberOfComponents","type","renderResourcesAttribute","index","attributeIndex","value","buffer","undefined","constant","vertexBuffer","count","componentDatatype","offsetInBytes","byteOffset","strideInBytes","byteStride","normalize","normalized","attributes","renderResources","numImageryTexCoordAttributes","shaderBuilder","imageryFlags","_computeImageryFlags","numTextures","addDefine","_addAttributes","_defineUniforms","_buildSampleAndBlendFunction","_createMainImageryShader","uniformMap","uniforms","_createImageryUniforms","_setImageryUniforms","numTexCoords","addAttribute","addVarying","functionId","signature","addFunction","VERTEX","addFunctionLines","imageryLayer","alpha","brightness","DEFAULT_BRIGHTNESS","contrast","DEFAULT_CONTRAST","hue","DEFAULT_HUE","saturation","DEFAULT_SATURATION","gamma","DEFAULT_GAMMA","hasColorToAlpha","colorToAlpha","colorToAlphaThreshold","addUniform","FRAGMENT","_createSampleAndBlendFunctionSignature","parameters","parametersString","join","_createSampleAndBlendCallArguments","imageryTexCoordAttributeSetIndex","textureCoordinates","args","argsString","imageryInput","imageryTextures","Array","imageryTextureCoordinateRectangle","imageryTextureTranslationAndScale","imageryTextureAlpha","imageryTextureBrightness","imageryTextureContrast","imageryTextureHue","imageryTextureSaturation","imageryTextureOneOverGamma","imageryTextureColorToAlpha","texture","textureCoordinateRectangle","textureTranslationAndScale","color","x","red","y","green","z","blue","w","key","hasOwnProperty","name","defined","show","mappedPositions","mappedPositionsForImageryLayer","cartographicBoundingRectangle","coverages","coveragesForImageryLayer","j","coverage","_createImageryInput","typeOf","number","greaterThanOrEquals","imagery","state","FAILED","INVALID","textureWebMercator","READY","console","log","level","_computeTextureTranslationAndScale","rectangle","textureCoordinateCartesianRectangle","minX","minY","maxX","maxY","nonNativeBoundingRectangle","nonNativeImageryRectangle","tilingScheme","imageryProvider","nativeBoundingRectangle","rectangleToNativeRectangle","nativeImageryRectangle","translationAndScale","_computeTextureTranslationAndScaleFromNative","invImageryWidth","width","invImageryHeight","height","deltaWest","west","deltaSouth","south","offsetX","offsetY","scaleX","scaleY","source","target","result","element","indexOf"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 14235, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/LightingModel.js"],"sourcesContent":["/**\n * The lighting model to use for lighting a {@link Model}.\n *\n * @enum {number}\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst LightingModel = {\n  /**\n   * Use unlit shading, i.e. skip lighting calculations. The model's\n   * diffuse color (assumed to be linear RGB, not sRGB) is used directly\n   * when computing <code>out_FragColor</code>. The alpha mode is still\n   * applied.\n   *\n   * @type {number}\n   * @constant\n   */\n  UNLIT: 0,\n  /**\n   * Use physically-based rendering lighting calculations. This includes\n   * both PBR metallic roughness and PBR specular glossiness. Image-based\n   * lighting is also applied when possible.\n   *\n   * @type {number}\n   * @constant\n   */\n  PBR: 1,\n};\n\nexport default Object.freeze(LightingModel);\n"],"names":["LightingModel","UNLIT","PBR","Object","freeze"],"mappings":";;;;AAAA;;;;;;CAMC,GACD,MAAMA,gBAAgB;IACpB;;;;;;;;GAQC,GACDC,OAAO;IACP;;;;;;;GAOC,GACDC,KAAK;AACP;uCAEeC,OAAOC,MAAM,CAACJ","ignoreList":[0]}},
    {"offset": {"line": 14269, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/LightingPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport LightingStageFS from \"../../Shaders/Model/LightingStageFS.js\";\nimport LightingModel from \"./LightingModel.js\";\n\n/**\n * The lighting pipeline stage is responsible for taking a material and rendering\n * it with a lighting model such as physically based rendering (PBR) or unlit\n * shading\n *\n * @namespace LightingPipelineStage\n *\n * @private\n */\nconst LightingPipelineStage = {\n  name: \"LightingPipelineStage\", // Helps with debugging\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>modifies the shader to include the lighting stage</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n *\n * @private\n */\nLightingPipelineStage.process = function (renderResources, primitive) {\n  const { model, lightingOptions, shaderBuilder } = renderResources;\n\n  if (defined(model.lightColor)) {\n    shaderBuilder.addDefine(\n      \"USE_CUSTOM_LIGHT_COLOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n\n    shaderBuilder.addUniform(\n      \"vec3\",\n      \"model_lightColorHdr\",\n      ShaderDestination.FRAGMENT,\n    );\n\n    const uniformMap = renderResources.uniformMap;\n    uniformMap.model_lightColorHdr = function () {\n      return model.lightColor;\n    };\n  }\n\n  // The lighting model is always set by the material. However, custom shaders\n  // can override this.\n  const { lightingModel } = lightingOptions;\n\n  if (lightingModel === LightingModel.PBR) {\n    shaderBuilder.addDefine(\n      \"LIGHTING_PBR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  } else {\n    shaderBuilder.addDefine(\n      \"LIGHTING_UNLIT\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  shaderBuilder.addFragmentLines(LightingStageFS);\n};\n\nexport default LightingPipelineStage;\n"],"names":["LightingPipelineStage","name","process","renderResources","primitive","model","lightingOptions","shaderBuilder","lightColor","addDefine","undefined","FRAGMENT","addUniform","uniformMap","model_lightColorHdr","lightingModel","PBR","addFragmentLines"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;;;;;;CAQC,GACD,MAAMA,wBAAwB;IAC5BC,MAAM;AACR;AAEA;;;;;;;;;;CAUC,GACDD,sBAAsBE,OAAO,GAAG,SAAUC,eAAe,EAAEC,SAAS;IAClE,MAAM,EAAEC,KAAK,EAAEC,eAAe,EAAEC,aAAa,EAAE,GAAGJ;IAElD,IAAI,IAAA,6KAAO,EAACE,MAAMG,UAAU,GAAG;QAC7BD,cAAcE,SAAS,CACrB,0BACAC,WACA,2LAAiB,CAACC,QAAQ;QAG5BJ,cAAcK,UAAU,CACtB,QACA,uBACA,2LAAiB,CAACD,QAAQ;QAG5B,MAAME,aAAaV,gBAAgBU,UAAU;QAC7CA,WAAWC,mBAAmB,GAAG;YAC/B,OAAOT,MAAMG,UAAU;QACzB;IACF;IAEA,4EAA4E;IAC5E,qBAAqB;IACrB,MAAM,EAAEO,aAAa,EAAE,GAAGT;IAE1B,IAAIS,kBAAkB,6LAAa,CAACC,GAAG,EAAE;QACvCT,cAAcE,SAAS,CACrB,gBACAC,WACA,2LAAiB,CAACC,QAAQ;IAE9B,OAAO;QACLJ,cAAcE,SAAS,CACrB,kBACAC,WACA,2LAAiB,CAACC,QAAQ;IAE9B;IAEAJ,cAAcU,gBAAgB,CAAC,iMAAe;AAChD;uCAEejB","ignoreList":[0]}},
    {"offset": {"line": 14327, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/MaterialPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport MaterialStageFS from \"../../Shaders/Model/MaterialStageFS.js\";\nimport AlphaMode from \"../AlphaMode.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport LightingModel from \"./LightingModel.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\nconst { Material, MetallicRoughness, SpecularGlossiness, Specular, Clearcoat } =\n  ModelComponents;\n\n/**\n * The material pipeline stage processes textures and other uniforms needed\n * to render a primitive. This handles the following material types:\n * <ul>\n *   <li>Basic glTF materials (PBR metallic roughness model)</li>\n *   <li>The `KHR_materials_specular` glTF extension</li>\n *   <li>The `KHR_materials_pbrSpecularGlossiness` glTF extension</li>\n *   <li>The `KHR_materials_unlit` glTF extension</li>\n * </ul>\n *\n * @namespace MaterialPipelineStage\n *\n * @private\n */\nconst MaterialPipelineStage = {\n  name: \"MaterialPipelineStage\", // Helps with debugging\n\n  // Expose some methods for testing\n  _processTexture: processTexture,\n  _processTextureTransform: processTextureTransform,\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>Modifies the shader to include the material processing stage</li>\n *   <li>Modifies the shader to include additional uniforms for textures and other rendering details</li>\n *   <li>Modifies the lighting options to set either PBR or unlit lighting</li>\n *   <li>Sets the render state for back-face culling</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state.\n * @private\n */\nMaterialPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  // gltf-pipeline automatically creates a default material so this will always\n  // be defined.\n  const material = primitive.material;\n  const { model, uniformMap, shaderBuilder } = renderResources;\n\n  // Classification models only use position and feature ID attributes,\n  // so textures should be disabled to avoid compile errors.\n  const hasClassification = defined(model.classificationType);\n  const disableTextures = hasClassification;\n\n  // When textures are loaded incrementally, fall back to a default 1x1 texture\n  const { defaultTexture, defaultNormalTexture, defaultEmissiveTexture } =\n    frameState.context;\n\n  processMaterialUniforms(\n    material,\n    uniformMap,\n    shaderBuilder,\n    defaultTexture,\n    defaultNormalTexture,\n    defaultEmissiveTexture,\n    disableTextures,\n  );\n\n  if (defined(material.specularGlossiness)) {\n    processSpecularGlossinessUniforms(\n      material.specularGlossiness,\n      uniformMap,\n      shaderBuilder,\n      defaultTexture,\n      disableTextures,\n    );\n  } else {\n    if (\n      defined(material.specular) &&\n      ModelUtility.supportedExtensions.KHR_materials_specular\n    ) {\n      processSpecularUniforms(\n        material.specular,\n        uniformMap,\n        shaderBuilder,\n        defaultTexture,\n        disableTextures,\n      );\n    }\n    if (\n      defined(material.anisotropy) &&\n      ModelUtility.supportedExtensions.KHR_materials_anisotropy\n    ) {\n      processAnisotropyUniforms(\n        material.anisotropy,\n        uniformMap,\n        shaderBuilder,\n        defaultTexture,\n        disableTextures,\n      );\n    }\n    if (\n      defined(material.clearcoat) &&\n      ModelUtility.supportedExtensions.KHR_materials_clearcoat\n    ) {\n      processClearcoatUniforms(\n        material.clearcoat,\n        uniformMap,\n        shaderBuilder,\n        defaultTexture,\n        disableTextures,\n      );\n    }\n    processMetallicRoughnessUniforms(\n      material.metallicRoughness,\n      uniformMap,\n      shaderBuilder,\n      defaultTexture,\n      disableTextures,\n    );\n  }\n\n  // If the primitive does not have normals, fall back to unlit lighting.\n  const hasNormals = ModelUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.NORMAL,\n  );\n\n  // Disable PointCloud normals if the user explicitly turned them off.\n  const disablePointCloudNormals =\n    defined(model.pointCloudShading) && !model.pointCloudShading.normalShading;\n\n  // Classification models will be rendered as unlit.\n  const lightingOptions = renderResources.lightingOptions;\n  if (\n    material.unlit ||\n    !hasNormals ||\n    hasClassification ||\n    disablePointCloudNormals\n  ) {\n    lightingOptions.lightingModel = LightingModel.UNLIT;\n  } else {\n    lightingOptions.lightingModel = LightingModel.PBR;\n  }\n\n  // Configure back-face culling\n  const cull = model.backFaceCulling && !material.doubleSided;\n  renderResources.renderStateOptions.cull.enabled = cull;\n\n  const alphaOptions = renderResources.alphaOptions;\n  if (material.alphaMode === AlphaMode.BLEND) {\n    alphaOptions.pass = Pass.TRANSLUCENT;\n  } else if (material.alphaMode === AlphaMode.MASK) {\n    alphaOptions.alphaCutoff = material.alphaCutoff;\n  }\n\n  shaderBuilder.addFragmentLines(MaterialStageFS);\n\n  if (material.doubleSided) {\n    shaderBuilder.addDefine(\n      \"HAS_DOUBLE_SIDED_MATERIAL\",\n      undefined,\n      ShaderDestination.BOTH,\n    );\n  }\n};\n\n/**\n * Process a single texture transformation and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {string} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {string} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTextureTransform(\n  shaderBuilder,\n  uniformMap,\n  textureReader,\n  uniformName,\n  defineName,\n) {\n  // Add a define to enable the texture transformation code in the shader.\n  const transformDefine = `HAS_${defineName}_TEXTURE_TRANSFORM`;\n  shaderBuilder.addDefine(\n    transformDefine,\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Add a uniform for the transformation matrix\n  const transformUniformName = `${uniformName}Transform`;\n  shaderBuilder.addUniform(\n    \"mat3\",\n    transformUniformName,\n    ShaderDestination.FRAGMENT,\n  );\n  uniformMap[transformUniformName] = function () {\n    return textureReader.transform;\n  };\n}\n\n/**\n * Process a single texture scale and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {string} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {string} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTextureScale(\n  shaderBuilder,\n  uniformMap,\n  textureReader,\n  uniformName,\n  defineName,\n) {\n  // Add a define to enable the texture transformation code in the shader.\n  const transformDefine = `HAS_${defineName}_TEXTURE_SCALE`;\n  shaderBuilder.addDefine(\n    transformDefine,\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Add a uniform for the transformation matrix\n  const scaleUniformName = `${uniformName}Scale`;\n  shaderBuilder.addUniform(\n    \"float\",\n    scaleUniformName,\n    ShaderDestination.FRAGMENT,\n  );\n  uniformMap[scaleUniformName] = function () {\n    return textureReader.scale;\n  };\n}\n\n/**\n * Process a single texture and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {string} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {string} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTexture(\n  shaderBuilder,\n  uniformMap,\n  textureReader,\n  uniformName,\n  defineName,\n  defaultTexture,\n) {\n  // Add a uniform for the texture itself\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    uniformName,\n    ShaderDestination.FRAGMENT,\n  );\n  uniformMap[uniformName] = function () {\n    return textureReader.texture ?? defaultTexture;\n  };\n\n  // Add a #define directive to enable using the texture in the shader\n  const textureDefine = `HAS_${defineName}_TEXTURE`;\n  shaderBuilder.addDefine(textureDefine, undefined, ShaderDestination.FRAGMENT);\n\n  // Add a #define to tell the shader which texture coordinates varying to use.\n  const texCoordIndex = textureReader.texCoord;\n  const texCoordVarying = `v_texCoord_${texCoordIndex}`;\n  const texCoordDefine = `TEXCOORD_${defineName}`;\n  shaderBuilder.addDefine(\n    texCoordDefine,\n    texCoordVarying,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Some textures have matrix transforms (e.g. for texture atlases). Add those\n  // to the shader if present.\n  const textureTransform = textureReader.transform;\n  if (\n    defined(textureTransform) &&\n    !Matrix3.equals(textureTransform, Matrix3.IDENTITY)\n  ) {\n    processTextureTransform(\n      shaderBuilder,\n      uniformMap,\n      textureReader,\n      uniformName,\n      defineName,\n    );\n  }\n\n  const { scale } = textureReader;\n  if (defined(scale) && scale !== 1.0) {\n    processTextureScale(\n      shaderBuilder,\n      uniformMap,\n      textureReader,\n      uniformName,\n      defineName,\n    );\n  }\n}\n\nfunction processMaterialUniforms(\n  material,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  defaultNormalTexture,\n  defaultEmissiveTexture,\n  disableTextures,\n) {\n  const { emissiveFactor, emissiveTexture, normalTexture, occlusionTexture } =\n    material;\n\n  if (\n    defined(emissiveFactor) &&\n    !Cartesian3.equals(emissiveFactor, Material.DEFAULT_EMISSIVE_FACTOR)\n  ) {\n    shaderBuilder.addUniform(\n      \"vec3\",\n      \"u_emissiveFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_emissiveFactor = function () {\n      return material.emissiveFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_EMISSIVE_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n\n    if (defined(emissiveTexture) && !disableTextures) {\n      processTexture(\n        shaderBuilder,\n        uniformMap,\n        emissiveTexture,\n        \"u_emissiveTexture\",\n        \"EMISSIVE\",\n        defaultEmissiveTexture,\n      );\n    }\n  }\n\n  if (defined(normalTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      normalTexture,\n      \"u_normalTexture\",\n      \"NORMAL\",\n      defaultNormalTexture,\n    );\n  }\n\n  if (defined(occlusionTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      occlusionTexture,\n      \"u_occlusionTexture\",\n      \"OCCLUSION\",\n      defaultTexture,\n    );\n  }\n}\n\n/**\n * Add uniforms and defines for the KHR_materials_pbrSpecularGlossiness extension\n *\n * @param {ModelComponents.SpecularGlossiness} specularGlossiness\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processSpecularGlossinessUniforms(\n  specularGlossiness,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  disableTextures,\n) {\n  const {\n    diffuseTexture,\n    diffuseFactor,\n    specularGlossinessTexture,\n    specularFactor,\n    glossinessFactor,\n  } = specularGlossiness;\n\n  shaderBuilder.addDefine(\n    \"USE_SPECULAR_GLOSSINESS\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (defined(diffuseTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      diffuseTexture,\n      \"u_diffuseTexture\",\n      \"DIFFUSE\",\n      defaultTexture,\n    );\n  }\n\n  if (\n    defined(diffuseFactor) &&\n    !Cartesian4.equals(diffuseFactor, SpecularGlossiness.DEFAULT_DIFFUSE_FACTOR)\n  ) {\n    shaderBuilder.addUniform(\n      \"vec4\",\n      \"u_diffuseFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_diffuseFactor = function () {\n      return specularGlossiness.diffuseFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_DIFFUSE_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (defined(specularGlossinessTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      specularGlossinessTexture,\n      \"u_specularGlossinessTexture\",\n      \"SPECULAR_GLOSSINESS\",\n      defaultTexture,\n    );\n  }\n\n  if (\n    defined(specularFactor) &&\n    !Cartesian3.equals(\n      specularFactor,\n      SpecularGlossiness.DEFAULT_SPECULAR_FACTOR,\n    )\n  ) {\n    shaderBuilder.addUniform(\n      \"vec3\",\n      \"u_legacySpecularFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_legacySpecularFactor = function () {\n      return specularGlossiness.specularFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_LEGACY_SPECULAR_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (\n    defined(glossinessFactor) &&\n    glossinessFactor !== SpecularGlossiness.DEFAULT_GLOSSINESS_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_glossinessFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_glossinessFactor = function () {\n      return specularGlossiness.glossinessFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_GLOSSINESS_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n}\n\n/**\n * Add uniforms and defines for the KHR_materials_specular extension\n *\n * @param {ModelComponents.Specular} specular\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processSpecularUniforms(\n  specular,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  disableTextures,\n) {\n  const {\n    specularTexture,\n    specularFactor,\n    specularColorTexture,\n    specularColorFactor,\n  } = specular;\n\n  shaderBuilder.addDefine(\n    \"USE_SPECULAR\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (defined(specularTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      specularTexture,\n      \"u_specularTexture\",\n      \"SPECULAR\",\n      defaultTexture,\n    );\n  }\n\n  if (\n    defined(specularFactor) &&\n    specularFactor !== Specular.DEFAULT_SPECULAR_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_specularFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_specularFactor = function () {\n      return specular.specularFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_SPECULAR_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (defined(specularColorTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      specularColorTexture,\n      \"u_specularColorTexture\",\n      \"SPECULAR_COLOR\",\n      defaultTexture,\n    );\n  }\n\n  if (\n    defined(specularColorFactor) &&\n    !Cartesian3.equals(\n      specularColorFactor,\n      Specular.DEFAULT_SPECULAR_COLOR_FACTOR,\n    )\n  ) {\n    shaderBuilder.addUniform(\n      \"vec3\",\n      \"u_specularColorFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_specularColorFactor = function () {\n      return specular.specularColorFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_SPECULAR_COLOR_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n}\n\nconst scratchAnisotropy = new Cartesian3();\n\n/**\n * Add uniforms and defines for the KHR_materials_anisotropy extension\n *\n * @param {ModelComponents.Anisotropy} anisotropy\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processAnisotropyUniforms(\n  anisotropy,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  disableTextures,\n) {\n  const { anisotropyStrength, anisotropyRotation, anisotropyTexture } =\n    anisotropy;\n\n  shaderBuilder.addDefine(\n    \"USE_ANISOTROPY\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (defined(anisotropyTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      anisotropyTexture,\n      \"u_anisotropyTexture\",\n      \"ANISOTROPY\",\n      defaultTexture,\n    );\n  }\n\n  // Pre-compute cos and sin of rotation, since they are the same for all fragments.\n  // Combine with strength as one vec3 uniform.\n  const cosRotation = Math.cos(anisotropyRotation);\n  const sinRotation = Math.sin(anisotropyRotation);\n  shaderBuilder.addUniform(\"vec3\", \"u_anisotropy\", ShaderDestination.FRAGMENT);\n  uniformMap.u_anisotropy = function () {\n    return Cartesian3.fromElements(\n      cosRotation,\n      sinRotation,\n      anisotropyStrength,\n      scratchAnisotropy,\n    );\n  };\n}\n\n/**\n * Add uniforms and defines for the KHR_materials_clearcoat extension\n *\n * @param {ModelComponents.Clearcoat} clearcoat\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processClearcoatUniforms(\n  clearcoat,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  disableTextures,\n) {\n  const {\n    clearcoatFactor,\n    clearcoatTexture,\n    clearcoatRoughnessFactor,\n    clearcoatRoughnessTexture,\n    clearcoatNormalTexture,\n  } = clearcoat;\n\n  shaderBuilder.addDefine(\n    \"USE_CLEARCOAT\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (\n    defined(clearcoatFactor) &&\n    clearcoatFactor !== Clearcoat.DEFAULT_CLEARCOAT_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_clearcoatFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_clearcoatFactor = function () {\n      return clearcoat.clearcoatFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_CLEARCOAT_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (defined(clearcoatTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      clearcoatTexture,\n      \"u_clearcoatTexture\",\n      \"CLEARCOAT\",\n      defaultTexture,\n    );\n  }\n\n  if (\n    defined(clearcoatRoughnessFactor) &&\n    clearcoatFactor !== Clearcoat.DEFAULT_CLEARCOAT_ROUGHNESS_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_clearcoatRoughnessFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_clearcoatRoughnessFactor = function () {\n      return clearcoat.clearcoatRoughnessFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_CLEARCOAT_ROUGHNESS_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (defined(clearcoatRoughnessTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      clearcoatRoughnessTexture,\n      \"u_clearcoatRoughnessTexture\",\n      \"CLEARCOAT_ROUGHNESS\",\n      defaultTexture,\n    );\n  }\n\n  if (defined(clearcoatNormalTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      clearcoatNormalTexture,\n      \"u_clearcoatNormalTexture\",\n      \"CLEARCOAT_NORMAL\",\n      defaultTexture,\n    );\n  }\n}\n\n/**\n * Add uniforms and defines for the PBR metallic roughness model\n *\n * @param {ModelComponents.MetallicRoughness} metallicRoughness\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processMetallicRoughnessUniforms(\n  metallicRoughness,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  disableTextures,\n) {\n  shaderBuilder.addDefine(\n    \"USE_METALLIC_ROUGHNESS\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  const baseColorTexture = metallicRoughness.baseColorTexture;\n  if (defined(baseColorTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      baseColorTexture,\n      \"u_baseColorTexture\",\n      \"BASE_COLOR\",\n      defaultTexture,\n    );\n  }\n\n  const baseColorFactor = metallicRoughness.baseColorFactor;\n  if (\n    defined(baseColorFactor) &&\n    !Cartesian4.equals(\n      baseColorFactor,\n      MetallicRoughness.DEFAULT_BASE_COLOR_FACTOR,\n    )\n  ) {\n    shaderBuilder.addUniform(\n      \"vec4\",\n      \"u_baseColorFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_baseColorFactor = function () {\n      return metallicRoughness.baseColorFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_BASE_COLOR_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  const metallicRoughnessTexture = metallicRoughness.metallicRoughnessTexture;\n  if (defined(metallicRoughnessTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      metallicRoughnessTexture,\n      \"u_metallicRoughnessTexture\",\n      \"METALLIC_ROUGHNESS\",\n      defaultTexture,\n    );\n  }\n\n  const metallicFactor = metallicRoughness.metallicFactor;\n  if (\n    defined(metallicFactor) &&\n    metallicFactor !== MetallicRoughness.DEFAULT_METALLIC_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_metallicFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_metallicFactor = function () {\n      return metallicRoughness.metallicFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_METALLIC_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  const roughnessFactor = metallicRoughness.roughnessFactor;\n  if (\n    defined(roughnessFactor) &&\n    roughnessFactor !== MetallicRoughness.DEFAULT_ROUGHNESS_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_roughnessFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_roughnessFactor = function () {\n      return metallicRoughness.roughnessFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_ROUGHNESS_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n}\n\nexport default MaterialPipelineStage;\n"],"names":["Material","MetallicRoughness","SpecularGlossiness","Specular","Clearcoat","MaterialPipelineStage","name","_processTexture","processTexture","_processTextureTransform","processTextureTransform","process","renderResources","primitive","frameState","material","model","uniformMap","shaderBuilder","hasClassification","classificationType","disableTextures","defaultTexture","defaultNormalTexture","defaultEmissiveTexture","context","processMaterialUniforms","specularGlossiness","processSpecularGlossinessUniforms","specular","supportedExtensions","KHR_materials_specular","processSpecularUniforms","anisotropy","KHR_materials_anisotropy","processAnisotropyUniforms","clearcoat","KHR_materials_clearcoat","processClearcoatUniforms","processMetallicRoughnessUniforms","metallicRoughness","hasNormals","getAttributeBySemantic","NORMAL","disablePointCloudNormals","pointCloudShading","normalShading","lightingOptions","unlit","lightingModel","UNLIT","PBR","cull","backFaceCulling","doubleSided","renderStateOptions","enabled","alphaOptions","alphaMode","BLEND","pass","TRANSLUCENT","MASK","alphaCutoff","addFragmentLines","addDefine","undefined","BOTH","textureReader","uniformName","defineName","transformDefine","FRAGMENT","transformUniformName","addUniform","transform","processTextureScale","scaleUniformName","scale","texture","textureDefine","texCoordIndex","texCoord","texCoordVarying","texCoordDefine","textureTransform","equals","IDENTITY","emissiveFactor","emissiveTexture","normalTexture","occlusionTexture","DEFAULT_EMISSIVE_FACTOR","u_emissiveFactor","diffuseTexture","diffuseFactor","specularGlossinessTexture","specularFactor","glossinessFactor","DEFAULT_DIFFUSE_FACTOR","u_diffuseFactor","DEFAULT_SPECULAR_FACTOR","u_legacySpecularFactor","DEFAULT_GLOSSINESS_FACTOR","u_glossinessFactor","specularTexture","specularColorTexture","specularColorFactor","u_specularFactor","DEFAULT_SPECULAR_COLOR_FACTOR","u_specularColorFactor","scratchAnisotropy","anisotropyStrength","anisotropyRotation","anisotropyTexture","cosRotation","Math","cos","sinRotation","sin","u_anisotropy","fromElements","clearcoatFactor","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughnessTexture","clearcoatNormalTexture","DEFAULT_CLEARCOAT_FACTOR","u_clearcoatFactor","DEFAULT_CLEARCOAT_ROUGHNESS_FACTOR","u_clearcoatRoughnessFactor","baseColorTexture","baseColorFactor","DEFAULT_BASE_COLOR_FACTOR","u_baseColorFactor","metallicRoughnessTexture","metallicFactor","DEFAULT_METALLIC_FACTOR","u_metallicFactor","roughnessFactor","DEFAULT_ROUGHNESS_FACTOR","u_roughnessFactor"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 14718, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/MetadataPickingPipelineStage.js"],"sourcesContent":["import ShaderDestination from \"../../Renderer/ShaderDestination.js\";\n\n/**\n * The MetadataPickingPipelineStage is inserting the\n * metadataPickingStage function into the shader code,\n * including the 'defines' that will be filled with\n * the proper values for metadata picking in the\n * 'DerivedCommands'\n *\n * @namespace MetadataPickingPipelineStage\n * @private\n */\nconst MetadataPickingPipelineStage = {\n  name: \"MetadataPickingPipelineStage\", // Helps with debugging\n\n  // The identifiers for 'define' directives that are inserted into the\n  // shader code. The values of these defines will be be assigned\n  // in the `DerivedCommands` class when a derived command for metadata\n  // picking is created.\n  METADATA_PICKING_ENABLED: \"METADATA_PICKING_ENABLED\",\n  METADATA_PICKING_VALUE_TYPE: \"METADATA_PICKING_VALUE_TYPE\",\n  METADATA_PICKING_VALUE_STRING: \"METADATA_PICKING_VALUE_STRING\",\n  METADATA_PICKING_VALUE_COMPONENT_X: \"METADATA_PICKING_VALUE_COMPONENT_X\",\n  METADATA_PICKING_VALUE_COMPONENT_Y: \"METADATA_PICKING_VALUE_COMPONENT_Y\",\n  METADATA_PICKING_VALUE_COMPONENT_Z: \"METADATA_PICKING_VALUE_COMPONENT_Z\",\n  METADATA_PICKING_VALUE_COMPONENT_W: \"METADATA_PICKING_VALUE_COMPONENT_W\",\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render resources:\n * <ul>\n *  <li>adds the required defines and \"metadataPickingStage\" to function in the shader</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n */\nMetadataPickingPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\n    MetadataPickingPipelineStage.METADATA_PICKING_VALUE_TYPE,\n    \"float\",\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addDefine(\n    MetadataPickingPipelineStage.METADATA_PICKING_VALUE_STRING,\n    \"0.0\",\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addDefine(\n    MetadataPickingPipelineStage.METADATA_PICKING_VALUE_COMPONENT_X,\n    \"0.0\",\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addDefine(\n    MetadataPickingPipelineStage.METADATA_PICKING_VALUE_COMPONENT_Y,\n    \"0.0\",\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addDefine(\n    MetadataPickingPipelineStage.METADATA_PICKING_VALUE_COMPONENT_Z,\n    \"0.0\",\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addDefine(\n    MetadataPickingPipelineStage.METADATA_PICKING_VALUE_COMPONENT_W,\n    \"0.0\",\n    ShaderDestination.FRAGMENT,\n  );\n\n  shaderBuilder.addFunction(\n    \"metadataPickingStage\",\n    \"void metadataPickingStage(Metadata metadata, MetadataClass metadataClass, inout vec4 metadataValues)\",\n    ShaderDestination.FRAGMENT,\n  );\n\n  shaderBuilder.addFunctionLines(\n    \"metadataPickingStage\",\n    [\n      `${MetadataPickingPipelineStage.METADATA_PICKING_VALUE_TYPE} value = ${MetadataPickingPipelineStage.METADATA_PICKING_VALUE_TYPE}(${MetadataPickingPipelineStage.METADATA_PICKING_VALUE_STRING});`,\n      `metadataValues.x = ${MetadataPickingPipelineStage.METADATA_PICKING_VALUE_COMPONENT_X};`,\n      `metadataValues.y = ${MetadataPickingPipelineStage.METADATA_PICKING_VALUE_COMPONENT_Y};`,\n      `metadataValues.z = ${MetadataPickingPipelineStage.METADATA_PICKING_VALUE_COMPONENT_Z};`,\n      `metadataValues.w = ${MetadataPickingPipelineStage.METADATA_PICKING_VALUE_COMPONENT_W};`,\n    ],\n    ShaderDestination.FRAGMENT,\n  );\n};\n\nexport default MetadataPickingPipelineStage;\n"],"names":["MetadataPickingPipelineStage","name","METADATA_PICKING_ENABLED","METADATA_PICKING_VALUE_TYPE","METADATA_PICKING_VALUE_STRING","METADATA_PICKING_VALUE_COMPONENT_X","METADATA_PICKING_VALUE_COMPONENT_Y","METADATA_PICKING_VALUE_COMPONENT_Z","METADATA_PICKING_VALUE_COMPONENT_W","process","renderResources","primitive","frameState","shaderBuilder","addDefine","FRAGMENT","addFunction","addFunctionLines"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;CASC,GACD,MAAMA,+BAA+B;IACnCC,MAAM;IAEN,qEAAqE;IACrE,+DAA+D;IAC/D,qEAAqE;IACrE,sBAAsB;IACtBC,0BAA0B;IAC1BC,6BAA6B;IAC7BC,+BAA+B;IAC/BC,oCAAoC;IACpCC,oCAAoC;IACpCC,oCAAoC;IACpCC,oCAAoC;AACtC;AAEA;;;;;;;;;CASC,GACDR,6BAA6BS,OAAO,GAAG,SACrCC,eAAe,EACfC,SAAS,EACTC,UAAU;IAEV,MAAMC,gBAAgBH,gBAAgBG,aAAa;IAEnDA,cAAcC,SAAS,CACrBd,6BAA6BG,2BAA2B,EACxD,SACA,2LAAiB,CAACY,QAAQ;IAE5BF,cAAcC,SAAS,CACrBd,6BAA6BI,6BAA6B,EAC1D,OACA,2LAAiB,CAACW,QAAQ;IAE5BF,cAAcC,SAAS,CACrBd,6BAA6BK,kCAAkC,EAC/D,OACA,2LAAiB,CAACU,QAAQ;IAE5BF,cAAcC,SAAS,CACrBd,6BAA6BM,kCAAkC,EAC/D,OACA,2LAAiB,CAACS,QAAQ;IAE5BF,cAAcC,SAAS,CACrBd,6BAA6BO,kCAAkC,EAC/D,OACA,2LAAiB,CAACQ,QAAQ;IAE5BF,cAAcC,SAAS,CACrBd,6BAA6BQ,kCAAkC,EAC/D,OACA,2LAAiB,CAACO,QAAQ;IAG5BF,cAAcG,WAAW,CACvB,wBACA,wGACA,2LAAiB,CAACD,QAAQ;IAG5BF,cAAcI,gBAAgB,CAC5B,wBACA;QACE,GAAGjB,6BAA6BG,2BAA2B,CAAC,SAAS,EAAEH,6BAA6BG,2BAA2B,CAAC,CAAC,EAAEH,6BAA6BI,6BAA6B,CAAC,EAAE,CAAC;QACjM,CAAC,mBAAmB,EAAEJ,6BAA6BK,kCAAkC,CAAC,CAAC,CAAC;QACxF,CAAC,mBAAmB,EAAEL,6BAA6BM,kCAAkC,CAAC,CAAC,CAAC;QACxF,CAAC,mBAAmB,EAAEN,6BAA6BO,kCAAkC,CAAC,CAAC,CAAC;QACxF,CAAC,mBAAmB,EAAEP,6BAA6BQ,kCAAkC,CAAC,CAAC,CAAC;KACzF,EACD,2LAAiB,CAACO,QAAQ;AAE9B;uCAEef","ignoreList":[0]}},
    {"offset": {"line": 14778, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/MorphTargetsPipelineStage.js"],"sourcesContent":["import AttributeType from \"../AttributeType.js\";\nimport combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport MorphTargetsStageVS from \"../../Shaders/Model/MorphTargetsStageVS.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * The morph targets pipeline stage processes the morph targets and weights of a primitive.\n *\n * @namespace MorphTargetsPipelineStage\n *\n * @private\n */\nconst MorphTargetsPipelineStage = {\n  name: \"MorphTargetsPipelineStage\", // Helps with debugging\n\n  FUNCTION_ID_GET_MORPHED_POSITION: \"getMorphedPosition\",\n  FUNCTION_SIGNATURE_GET_MORPHED_POSITION:\n    \"vec3 getMorphedPosition(in vec3 position)\",\n  FUNCTION_ID_GET_MORPHED_NORMAL: \"getMorphedNormal\",\n  FUNCTION_SIGNATURE_GET_MORPHED_NORMAL:\n    \"vec3 getMorphedNormal(in vec3 normal)\",\n  FUNCTION_ID_GET_MORPHED_TANGENT: \"getMorphedTangent\",\n  FUNCTION_SIGNATURE_GET_MORPHED_TANGENT:\n    \"vec3 getMorphedTangent(in vec3 tangent)\",\n};\n\n/**\n * This pipeline stage processes the morph targets and weights of a primitive,\n * adding the relevant attribute declarations and functions to the shaders.\n *\n * Processes a primitive. This stage modifies the following parts of the render resources:\n * <ul>\n *  <li> adds attribute declarations for the morph targets in the vertex shader\n *  <li> adds the uniform declaration for the morph weights in the vertex shader\n *  <li> adds functions to apply the morphs in the vertex shader\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n *\n * @private\n */\nMorphTargetsPipelineStage.process = function (renderResources, primitive) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\n    \"HAS_MORPH_TARGETS\",\n    undefined,\n    ShaderDestination.VERTEX,\n  );\n\n  addGetMorphedAttributeFunctionDeclarations(shaderBuilder);\n\n  const morphTargetsLength = primitive.morphTargets.length;\n  for (let i = 0; i < morphTargetsLength; i++) {\n    const attributes = primitive.morphTargets[i].attributes;\n\n    const attributesLength = attributes.length;\n    for (let j = 0; j < attributesLength; j++) {\n      const attribute = attributes[j];\n      const semantic = attribute.semantic;\n\n      // Cesium only supports morph targets for positions, normals, and tangents\n      if (\n        semantic !== VertexAttributeSemantic.POSITION &&\n        semantic !== VertexAttributeSemantic.NORMAL &&\n        semantic !== VertexAttributeSemantic.TANGENT\n      ) {\n        continue;\n      }\n\n      processMorphTargetAttribute(\n        renderResources,\n        attribute,\n        renderResources.attributeIndex,\n        i,\n      );\n      renderResources.attributeIndex++;\n    }\n  }\n\n  addGetMorphedAttributeFunctionReturns(shaderBuilder);\n\n  const weights = renderResources.runtimeNode.morphWeights;\n  const weightsLength = weights.length;\n  shaderBuilder.addUniform(\n    \"float\",\n    `u_morphWeights[${weightsLength}]`,\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addVertexLines(MorphTargetsStageVS);\n\n  const uniformMap = {\n    u_morphWeights: function () {\n      return renderResources.runtimeNode.morphWeights;\n    },\n  };\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\n\nconst scratchAttributeInfo = {\n  attributeString: undefined,\n  functionId: undefined,\n};\n\nfunction processMorphTargetAttribute(\n  renderResources,\n  attribute,\n  attributeIndex,\n  morphTargetIndex,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  addMorphTargetAttributeToRenderResources(\n    renderResources,\n    attribute,\n    attributeIndex,\n  );\n\n  const attributeInfo = getMorphTargetAttributeInfo(\n    attribute,\n    scratchAttributeInfo,\n  );\n\n  addMorphTargetAttributeDeclarationAndFunctionLine(\n    shaderBuilder,\n    attributeInfo,\n    morphTargetIndex,\n  );\n}\n\nfunction addMorphTargetAttributeToRenderResources(\n  renderResources,\n  attribute,\n  attributeIndex,\n) {\n  const vertexAttribute = {\n    index: attributeIndex,\n    value: defined(attribute.buffer) ? undefined : attribute.constant,\n    vertexBuffer: attribute.buffer,\n    componentsPerAttribute: AttributeType.getNumberOfComponents(attribute.type),\n    componentDatatype: attribute.componentDatatype,\n    offsetInBytes: attribute.byteOffset,\n    strideInBytes: attribute.byteStride,\n    normalize: attribute.normalized,\n  };\n\n  renderResources.attributes.push(vertexAttribute);\n}\n\nfunction getMorphTargetAttributeInfo(attribute, result) {\n  const semantic = attribute.semantic;\n  switch (semantic) {\n    case VertexAttributeSemantic.POSITION:\n      result.attributeString = \"Position\";\n      result.functionId =\n        MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION;\n      break;\n    case VertexAttributeSemantic.NORMAL:\n      result.attributeString = \"Normal\";\n      result.functionId =\n        MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL;\n      break;\n    case VertexAttributeSemantic.TANGENT:\n      result.attributeString = \"Tangent\";\n      result.functionId =\n        MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT;\n      break;\n    default:\n      break;\n  }\n  return result;\n}\n\nfunction addMorphTargetAttributeDeclarationAndFunctionLine(\n  shaderBuilder,\n  attributeInfo,\n  morphTargetIndex,\n) {\n  const attributeString = attributeInfo.attributeString;\n  const attributeName = `a_target${attributeString}_${morphTargetIndex}`;\n  const line = `morphed${attributeString} += u_morphWeights[${morphTargetIndex}] * a_target${attributeString}_${morphTargetIndex};`;\n  shaderBuilder.addAttribute(\"vec3\", attributeName);\n  shaderBuilder.addFunctionLines(attributeInfo.functionId, [line]);\n}\n\nfunction addGetMorphedAttributeFunctionDeclarations(shaderBuilder) {\n  shaderBuilder.addFunction(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION,\n    MorphTargetsPipelineStage.FUNCTION_SIGNATURE_GET_MORPHED_POSITION,\n    ShaderDestination.VERTEX,\n  );\n\n  const positionLine = \"vec3 morphedPosition = position;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION,\n    [positionLine],\n  );\n\n  shaderBuilder.addFunction(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL,\n    MorphTargetsPipelineStage.FUNCTION_SIGNATURE_GET_MORPHED_NORMAL,\n    ShaderDestination.VERTEX,\n  );\n\n  const normalLine = \"vec3 morphedNormal = normal;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL,\n    [normalLine],\n  );\n\n  shaderBuilder.addFunction(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT,\n    MorphTargetsPipelineStage.FUNCTION_SIGNATURE_GET_MORPHED_TANGENT,\n    ShaderDestination.VERTEX,\n  );\n\n  const tangentLine = \"vec3 morphedTangent = tangent;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT,\n    [tangentLine],\n  );\n}\n\nfunction addGetMorphedAttributeFunctionReturns(shaderBuilder) {\n  const positionLine = \"return morphedPosition;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION,\n    [positionLine],\n  );\n\n  const normalLine = \"return morphedNormal;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL,\n    [normalLine],\n  );\n\n  const tangentLine = \"return morphedTangent;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT,\n    [tangentLine],\n  );\n}\n\nexport default MorphTargetsPipelineStage;\n"],"names":["MorphTargetsPipelineStage","name","FUNCTION_ID_GET_MORPHED_POSITION","FUNCTION_SIGNATURE_GET_MORPHED_POSITION","FUNCTION_ID_GET_MORPHED_NORMAL","FUNCTION_SIGNATURE_GET_MORPHED_NORMAL","FUNCTION_ID_GET_MORPHED_TANGENT","FUNCTION_SIGNATURE_GET_MORPHED_TANGENT","process","renderResources","primitive","shaderBuilder","addDefine","undefined","VERTEX","addGetMorphedAttributeFunctionDeclarations","morphTargetsLength","morphTargets","length","i","attributes","attributesLength","j","attribute","semantic","POSITION","NORMAL","TANGENT","processMorphTargetAttribute","attributeIndex","addGetMorphedAttributeFunctionReturns","weights","runtimeNode","morphWeights","weightsLength","addUniform","addVertexLines","uniformMap","u_morphWeights","scratchAttributeInfo","attributeString","functionId","morphTargetIndex","addMorphTargetAttributeToRenderResources","attributeInfo","getMorphTargetAttributeInfo","addMorphTargetAttributeDeclarationAndFunctionLine","vertexAttribute","index","value","buffer","constant","vertexBuffer","componentsPerAttribute","getNumberOfComponents","type","componentDatatype","offsetInBytes","byteOffset","strideInBytes","byteStride","normalize","normalized","push","result","attributeName","line","addAttribute","addFunctionLines","addFunction","positionLine","normalLine","tangentLine"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 14943, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/PickingPipelineStage.js"],"sourcesContent":["import Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport Color from \"../../Core/Color.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport ModelType from \"./ModelType.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\n/**\n * The picking pipeline stage is responsible for handling picking of primitives.\n *\n * @namespace PickingPipelineStage\n * @private\n */\nconst PickingPipelineStage = {\n  name: \"PickingPipelineStage\", // Helps with debugging\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render resources:\n * <ul>\n *  <li>adds attribute and varying declaration for the pick color vertex attribute in the vertex shader for instanced meshes</li>\n *  <li>adds declaration for the pick color uniform for non-instanced meshes</li>\n *  <li>adds defines in the shader for when picking is enabled</li>\n *  <li>creates the pick ID objects in the context</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n */\nPickingPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const context = frameState.context;\n  const runtimeNode = renderResources.runtimeNode;\n  const shaderBuilder = renderResources.shaderBuilder;\n  const model = renderResources.model;\n  const instances = runtimeNode.node.instances;\n\n  if (renderResources.hasPropertyTable) {\n    processPickTexture(renderResources, primitive, instances, context);\n  } else if (defined(instances)) {\n    // For instanced meshes, a pick color vertex attribute is used.\n    processInstancedPickIds(renderResources, context);\n  } else {\n    // For non-instanced meshes, a pick color uniform is used.\n    const pickObject = buildPickObject(renderResources);\n\n    const pickId = context.createPickId(pickObject);\n    model._pipelineResources.push(pickId);\n    model._pickIds.push(pickId);\n\n    shaderBuilder.addUniform(\n      \"vec4\",\n      \"czm_pickColor\",\n      ShaderDestination.FRAGMENT,\n    );\n\n    const uniformMap = renderResources.uniformMap;\n    uniformMap.czm_pickColor = function () {\n      return pickId.color;\n    };\n\n    renderResources.pickId = \"czm_pickColor\";\n  }\n};\n\n/**\n * @private\n */\nfunction buildPickObject(renderResources, instanceId) {\n  const model = renderResources.model;\n\n  // Primitives that wrap Model may define the pickObject differently.\n  if (defined(model.pickObject)) {\n    return model.pickObject;\n  }\n\n  const detailPickObject = {\n    model: model,\n    node: renderResources.runtimeNode,\n    primitive: renderResources.runtimePrimitive,\n  };\n\n  let pickObject;\n\n  if (ModelType.is3DTiles(model.type)) {\n    // For 3D Tiles, the pick object's content and primitive are set to the Cesium3DTileContent that owns the model\n    // and the tileset it belongs to, respectively. The detail pick object is returned under the detail key.\n    const content = model.content;\n    pickObject = {\n      content: content,\n      primitive: content.tileset,\n      detail: detailPickObject,\n    };\n  } else {\n    // For models, the model itself is returned as the primitive, with the detail pick object under the detail key.\n    pickObject = {\n      primitive: model,\n      detail: detailPickObject,\n    };\n  }\n\n  pickObject.id = model.id;\n\n  if (defined(instanceId)) {\n    // For instanced models, an instanceId property is added to the pick object.\n    pickObject.instanceId = instanceId;\n  }\n\n  return pickObject;\n}\n\nfunction processPickTexture(renderResources, primitive, instances) {\n  const model = renderResources.model;\n  let featureTableId;\n  let featureIdAttribute;\n  const featureIdLabel = model.featureIdLabel;\n  const instanceFeatureIdLabel = model.instanceFeatureIdLabel;\n\n  if (defined(model.featureTableId)) {\n    // Extract the Feature Table ID from the Cesium3DTileContent.\n    featureTableId = model.featureTableId;\n  } else if (defined(instances)) {\n    // Extract the Feature Table ID from the instanced Feature ID attributes.\n    featureIdAttribute = ModelUtility.getFeatureIdsByLabel(\n      instances.featureIds,\n      instanceFeatureIdLabel,\n    );\n    featureTableId = featureIdAttribute.propertyTableId;\n  } else {\n    // Extract the Feature Table ID from the primitive Feature ID attributes.\n    featureIdAttribute = ModelUtility.getFeatureIdsByLabel(\n      primitive.featureIds,\n      featureIdLabel,\n    );\n    featureTableId = featureIdAttribute.propertyTableId;\n  }\n\n  const featureTable = model.featureTables[featureTableId];\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    \"model_pickTexture\",\n    ShaderDestination.FRAGMENT,\n  );\n\n  const batchTexture = featureTable.batchTexture;\n  renderResources.uniformMap.model_pickTexture = function () {\n    return batchTexture.pickTexture ?? batchTexture.defaultTexture;\n  };\n\n  // The feature ID is ignored if it is greater than the number of features.\n  renderResources.pickId =\n    \"((selectedFeature.id < int(model_featuresLength)) ? texture(model_pickTexture, selectedFeature.st) : vec4(0.0))\";\n}\n\nfunction processInstancedPickIds(renderResources, context) {\n  const instanceCount = renderResources.instanceCount;\n  const pickIds = new Array(instanceCount);\n  const pickIdsTypedArray = new Uint8Array(instanceCount * 4);\n\n  const model = renderResources.model;\n\n  const pipelineResources = model._pipelineResources;\n  for (let i = 0; i < instanceCount; i++) {\n    const pickObject = buildPickObject(renderResources, i);\n\n    const pickId = context.createPickId(pickObject);\n    pipelineResources.push(pickId);\n    pickIds[i] = pickId;\n\n    const pickColor = pickId.color;\n    pickIdsTypedArray[i * 4 + 0] = Color.floatToByte(pickColor.red);\n    pickIdsTypedArray[i * 4 + 1] = Color.floatToByte(pickColor.green);\n    pickIdsTypedArray[i * 4 + 2] = Color.floatToByte(pickColor.blue);\n    pickIdsTypedArray[i * 4 + 3] = Color.floatToByte(pickColor.alpha);\n  }\n\n  model._pickIds = pickIds;\n\n  const pickIdsBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: pickIdsTypedArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  // Destruction of resources allocated by the Model\n  // is handled by Model.destroyPipelineResources().\n  pickIdsBuffer.vertexArrayDestroyable = false;\n  const hasCpuCopy = false;\n  model.statistics.addBuffer(pickIdsBuffer, hasCpuCopy);\n  pipelineResources.push(pickIdsBuffer);\n\n  const pickIdsVertexAttribute = {\n    index: renderResources.attributeIndex++,\n    vertexBuffer: pickIdsBuffer,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n    normalize: true,\n    offsetInBytes: 0,\n    strideInBytes: 0,\n    instanceDivisor: 1,\n  };\n\n  renderResources.attributes.push(pickIdsVertexAttribute);\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addDefine(\"USE_PICKING\", undefined, ShaderDestination.BOTH);\n  shaderBuilder.addAttribute(\"vec4\", \"a_pickColor\");\n  shaderBuilder.addVarying(\"vec4\", \"v_pickColor\");\n  renderResources.pickId = \"v_pickColor\";\n}\n\nexport default PickingPipelineStage;\n"],"names":["PickingPipelineStage","name","process","renderResources","primitive","frameState","context","runtimeNode","shaderBuilder","model","instances","node","hasPropertyTable","processPickTexture","processInstancedPickIds","pickObject","buildPickObject","pickId","createPickId","_pipelineResources","push","_pickIds","addUniform","FRAGMENT","uniformMap","czm_pickColor","color","instanceId","detailPickObject","runtimePrimitive","is3DTiles","type","content","tileset","detail","id","featureTableId","featureIdAttribute","featureIdLabel","instanceFeatureIdLabel","getFeatureIdsByLabel","featureIds","propertyTableId","featureTable","featureTables","batchTexture","model_pickTexture","pickTexture","defaultTexture","instanceCount","pickIds","Array","pickIdsTypedArray","Uint8Array","pipelineResources","i","pickColor","floatToByte","red","green","blue","alpha","pickIdsBuffer","createVertexBuffer","typedArray","usage","STATIC_DRAW","vertexArrayDestroyable","hasCpuCopy","statistics","addBuffer","pickIdsVertexAttribute","index","attributeIndex","vertexBuffer","componentsPerAttribute","componentDatatype","UNSIGNED_BYTE","normalize","offsetInBytes","strideInBytes","instanceDivisor","attributes","addDefine","undefined","BOTH","addAttribute","addVarying"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 15123, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/PointCloudStylingPipelineStage.js"],"sourcesContent":["import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport Cesium3DTileRefine from \"../Cesium3DTileRefine.js\";\nimport clone from \"../../Core/clone.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport ModelType from \"./ModelType.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport OrthographicFrustum from \"../../Core/OrthographicFrustum.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport PointCloudStylingStageVS from \"../../Shaders/Model/PointCloudStylingStageVS.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\nconst scratchUniform = new Cartesian4();\n\n/**\n * The point cloud styling stage is responsible for applying color,\n * size, and show styles to point clouds at runtime. It also handles\n * point cloud shading provided by either the model or the tileset that\n * owns it. Point cloud shading is only applied if no point size style\n * is provided.\n *\n * @namespace PointCloudStylingPipelineStage\n *\n * @private\n */\nconst PointCloudStylingPipelineStage = {\n  name: \"PointCloudStylingPipelineStage\", // Helps with debugging\n};\n\n/**\n * Processes a primitive. If the model that owns it has a style, then\n * this stage modifies the following parts of the render resources:\n * <ul>\n *  <li>adds the styling functions to the vertex shaders</li>\n *  <li>adds a define to compute the position in world coordinates</li>\n *  <li>adds a varying to compute point cloud color</li>\n * </ul>\n *\n * If the model has point cloud shading, then this stage modifies the following\n * part of the render resources:\n * <ul>\n *  <li>adds vertex shader code to compute attenuation and update gl_PointSize</li>\n *  <li>updates the uniform map to pass in point cloud parameters</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nPointCloudStylingPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const model = renderResources.model;\n  const style = model.style;\n\n  // Point cloud styling will only be applied on the GPU if there is\n  // no batch table. If a batch table exists, then:\n  //  - the property attribute will not be defined\n  //  - the model will be using a feature table\n\n  const structuralMetadata = model.structuralMetadata;\n  const propertyAttributes = defined(structuralMetadata)\n    ? structuralMetadata.propertyAttributes\n    : undefined;\n\n  const hasFeatureTable =\n    defined(model.featureTableId) &&\n    model.featureTables[model.featureTableId].featuresLength > 0;\n\n  const hasBatchTable = !defined(propertyAttributes) && hasFeatureTable;\n\n  if (defined(style) && !hasBatchTable) {\n    const variableSubstitutionMap =\n      getVariableSubstitutionMap(propertyAttributes);\n    const shaderFunctionInfo = getStyleShaderFunctionInfo(\n      style,\n      variableSubstitutionMap,\n    );\n    addShaderFunctionsAndDefines(shaderBuilder, shaderFunctionInfo);\n\n    const propertyNames = getPropertyNames(shaderFunctionInfo);\n\n    const usesNormalSemantic = propertyNames.indexOf(\"normalMC\") >= 0;\n    const hasNormals = ModelUtility.getAttributeBySemantic(\n      primitive,\n      VertexAttributeSemantic.NORMAL,\n    );\n\n    if (usesNormalSemantic && !hasNormals) {\n      throw new RuntimeError(\n        \"Style references the NORMAL semantic but the point cloud does not have normals\",\n      );\n    }\n\n    shaderBuilder.addDefine(\n      \"COMPUTE_POSITION_WC_STYLE\",\n      undefined,\n      ShaderDestination.VERTEX,\n    );\n\n    // If the style is translucent, the alpha options must be adjusted.\n    const styleTranslucent = shaderFunctionInfo.styleTranslucent;\n    if (styleTranslucent) {\n      renderResources.alphaOptions.pass = Pass.TRANSLUCENT;\n    }\n  }\n\n  const pointCloudShading = model.pointCloudShading;\n  if (pointCloudShading.attenuation) {\n    shaderBuilder.addDefine(\n      \"HAS_POINT_CLOUD_ATTENUATION\",\n      undefined,\n      ShaderDestination.VERTEX,\n    );\n  }\n\n  if (pointCloudShading.backFaceCulling) {\n    shaderBuilder.addDefine(\n      \"HAS_POINT_CLOUD_BACK_FACE_CULLING\",\n      undefined,\n      ShaderDestination.VERTEX,\n    );\n  }\n\n  let content;\n  let is3DTiles;\n  let usesAddRefinement;\n\n  if (ModelType.is3DTiles(model.type)) {\n    is3DTiles = true;\n    content = model.content;\n    usesAddRefinement = content.tile.refine === Cesium3DTileRefine.ADD;\n  }\n\n  shaderBuilder.addUniform(\n    \"vec4\",\n    \"model_pointCloudParameters\",\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addVertexLines(PointCloudStylingStageVS);\n\n  const uniformMap = renderResources.uniformMap;\n  uniformMap.model_pointCloudParameters = function () {\n    const vec4 = scratchUniform;\n\n    // Point size\n    let defaultPointSize = 1.0;\n    if (is3DTiles) {\n      defaultPointSize = usesAddRefinement\n        ? 5.0\n        : content.tileset.memoryAdjustedScreenSpaceError;\n    }\n    vec4.x = pointCloudShading.maximumAttenuation ?? defaultPointSize;\n    vec4.x *= frameState.pixelRatio;\n\n    // Geometric error\n    const geometricError = getGeometricError(\n      renderResources,\n      primitive,\n      pointCloudShading,\n      content,\n    );\n    vec4.y = geometricError * pointCloudShading.geometricErrorScale;\n\n    const context = frameState.context;\n    const frustum = frameState.camera.frustum;\n    let depthMultiplier;\n\n    // Attenuation is maximumAttenuation in 2D/ortho\n    if (\n      frameState.mode === SceneMode.SCENE2D ||\n      frustum instanceof OrthographicFrustum\n    ) {\n      depthMultiplier = Number.POSITIVE_INFINITY;\n    } else {\n      depthMultiplier =\n        context.drawingBufferHeight / frameState.camera.frustum.sseDenominator;\n    }\n\n    // Depth multiplier\n    vec4.z = depthMultiplier;\n\n    // Time\n    if (is3DTiles) {\n      vec4.w = content.tileset.timeSinceLoad;\n    }\n\n    return vec4;\n  };\n};\n\nconst scratchDimensions = new Cartesian3();\nfunction getGeometricError(\n  renderResources,\n  primitive,\n  pointCloudShading,\n  content,\n) {\n  if (defined(content)) {\n    const geometricError = content.tile.geometricError;\n\n    if (geometricError > 0) {\n      return geometricError;\n    }\n  }\n\n  if (defined(pointCloudShading.baseResolution)) {\n    return pointCloudShading.baseResolution;\n  }\n\n  const positionAttribute = ModelUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.POSITION,\n  );\n  const pointsLength = positionAttribute.count;\n\n  // Estimate the geometric error\n  const nodeTransform = renderResources.runtimeNode.transform;\n  let dimensions = Cartesian3.subtract(\n    positionAttribute.max,\n    positionAttribute.min,\n    scratchDimensions,\n  );\n  // dimensions is a vector, as it is a subtraction between two points\n  dimensions = Matrix4.multiplyByPointAsVector(\n    nodeTransform,\n    dimensions,\n    scratchDimensions,\n  );\n  const volume = dimensions.x * dimensions.y * dimensions.z;\n  const geometricErrorEstimate = CesiumMath.cbrt(volume / pointsLength);\n  return geometricErrorEstimate;\n}\n\nconst scratchShaderFunctionInfo = {\n  colorStyleFunction: undefined,\n  showStyleFunction: undefined,\n  pointSizeStyleFunction: undefined,\n  styleTranslucent: false,\n};\n\nconst builtinVariableSubstitutionMap = {\n  POSITION: \"attributes.positionMC\",\n  POSITION_ABSOLUTE: \"v_positionWC\",\n  COLOR: \"attributes.color_0\",\n  NORMAL: \"attributes.normalMC\",\n};\n\nfunction getVariableSubstitutionMap(propertyAttributes) {\n  const variableSubstitutionMap = clone(builtinVariableSubstitutionMap);\n\n  if (!defined(propertyAttributes)) {\n    return variableSubstitutionMap;\n  }\n\n  for (let i = 0; i < propertyAttributes.length; i++) {\n    const propertyAttribute = propertyAttributes[i];\n    const properties = propertyAttribute.properties;\n    for (const propertyId in properties) {\n      // The property ID was already sanitized for GLSL by PntsLoader.\n      if (properties.hasOwnProperty(propertyId)) {\n        variableSubstitutionMap[propertyId] = `metadata.${propertyId}`;\n      }\n    }\n  }\n\n  return variableSubstitutionMap;\n}\nconst parameterList =\n  \"ProcessedAttributes attributes, \" +\n  \"Metadata metadata, \" +\n  \"float tiles3d_tileset_time\";\n\nfunction getStyleShaderFunctionInfo(style, variableSubstitutionMap) {\n  const info = scratchShaderFunctionInfo;\n  const shaderState = {\n    translucent: false,\n  };\n\n  info.colorStyleFunction = style.getColorShaderFunction(\n    `getColorFromStyle(${parameterList})`,\n    variableSubstitutionMap,\n    shaderState,\n  );\n  info.showStyleFunction = style.getShowShaderFunction(\n    `getShowFromStyle(${parameterList})`,\n    variableSubstitutionMap,\n    shaderState,\n  );\n  info.pointSizeStyleFunction = style.getPointSizeShaderFunction(\n    `getPointSizeFromStyle(${parameterList})`,\n    variableSubstitutionMap,\n    shaderState,\n  );\n  info.styleTranslucent =\n    defined(info.colorStyleFunction) && shaderState.translucent;\n\n  return info;\n}\n\nfunction addShaderFunctionsAndDefines(shaderBuilder, shaderFunctionInfo) {\n  const colorStyleFunction = shaderFunctionInfo.colorStyleFunction;\n  if (defined(colorStyleFunction)) {\n    shaderBuilder.addDefine(\n      \"HAS_POINT_CLOUD_COLOR_STYLE\",\n      undefined,\n      ShaderDestination.BOTH,\n    );\n    shaderBuilder.addVertexLines(colorStyleFunction);\n\n    // The point cloud may not necessarily have a color attribute.\n    // Use a custom varying to account for this.\n    shaderBuilder.addVarying(\"vec4\", \"v_pointCloudColor\");\n  }\n\n  const showStyleFunction = shaderFunctionInfo.showStyleFunction;\n  if (defined(showStyleFunction)) {\n    shaderBuilder.addDefine(\n      \"HAS_POINT_CLOUD_SHOW_STYLE\",\n      undefined,\n      ShaderDestination.BOTH,\n    );\n    shaderBuilder.addVertexLines(showStyleFunction);\n    shaderBuilder.addVarying(\"float\", \"v_pointCloudShow\");\n  }\n\n  const pointSizeStyleFunction = shaderFunctionInfo.pointSizeStyleFunction;\n  if (defined(pointSizeStyleFunction)) {\n    shaderBuilder.addDefine(\n      \"HAS_POINT_CLOUD_POINT_SIZE_STYLE\",\n      undefined,\n      ShaderDestination.VERTEX,\n    );\n    shaderBuilder.addVertexLines(pointSizeStyleFunction);\n  }\n}\n\n/**\n * Gets all the built-in property names used by the given style\n * function.\n *\n * @param {Function} source The style function.\n * @param {string[]} propertyNames The array of property names to add to.\n *\n * @private\n */\nfunction getBuiltinPropertyNames(source, propertyNames) {\n  const regex = /attributes\\.(\\w+)/g;\n  let matches = regex.exec(source);\n  while (matches !== null) {\n    const name = matches[1];\n    // Add the property name if it isn't already in the array.\n    if (propertyNames.indexOf(name) === -1) {\n      propertyNames.push(name);\n    }\n    matches = regex.exec(source);\n  }\n}\n\nfunction getPropertyNames(shaderFunctionInfo) {\n  const colorStyleFunction = shaderFunctionInfo.colorStyleFunction;\n  const showStyleFunction = shaderFunctionInfo.showStyleFunction;\n  const pointSizeStyleFunction = shaderFunctionInfo.pointSizeStyleFunction;\n\n  // Get the properties in use by the style.\n  const builtinPropertyNames = [];\n\n  if (defined(colorStyleFunction)) {\n    getBuiltinPropertyNames(colorStyleFunction, builtinPropertyNames);\n  }\n  if (defined(showStyleFunction)) {\n    getBuiltinPropertyNames(showStyleFunction, builtinPropertyNames);\n  }\n  if (defined(pointSizeStyleFunction)) {\n    getBuiltinPropertyNames(pointSizeStyleFunction, builtinPropertyNames);\n  }\n\n  return builtinPropertyNames;\n}\n\nexport default PointCloudStylingPipelineStage;\n"],"names":["scratchUniform","PointCloudStylingPipelineStage","name","process","renderResources","primitive","frameState","shaderBuilder","model","style","structuralMetadata","propertyAttributes","undefined","hasFeatureTable","featureTableId","featureTables","featuresLength","hasBatchTable","variableSubstitutionMap","getVariableSubstitutionMap","shaderFunctionInfo","getStyleShaderFunctionInfo","addShaderFunctionsAndDefines","propertyNames","getPropertyNames","usesNormalSemantic","indexOf","hasNormals","getAttributeBySemantic","NORMAL","addDefine","VERTEX","styleTranslucent","alphaOptions","pass","TRANSLUCENT","pointCloudShading","attenuation","backFaceCulling","content","is3DTiles","usesAddRefinement","type","tile","refine","ADD","addUniform","addVertexLines","uniformMap","model_pointCloudParameters","vec4","defaultPointSize","tileset","memoryAdjustedScreenSpaceError","x","maximumAttenuation","pixelRatio","geometricError","getGeometricError","y","geometricErrorScale","context","frustum","camera","depthMultiplier","mode","SCENE2D","Number","POSITIVE_INFINITY","drawingBufferHeight","sseDenominator","z","w","timeSinceLoad","scratchDimensions","baseResolution","positionAttribute","POSITION","pointsLength","count","nodeTransform","runtimeNode","transform","dimensions","subtract","max","min","multiplyByPointAsVector","volume","geometricErrorEstimate","cbrt","scratchShaderFunctionInfo","colorStyleFunction","showStyleFunction","pointSizeStyleFunction","builtinVariableSubstitutionMap","POSITION_ABSOLUTE","COLOR","i","length","propertyAttribute","properties","propertyId","hasOwnProperty","parameterList","info","shaderState","translucent","getColorShaderFunction","getShowShaderFunction","getPointSizeShaderFunction","BOTH","addVarying","getBuiltinPropertyNames","source","regex","matches","exec","push","builtinPropertyNames"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 15397, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/PrimitiveOutlinePipelineStage.js"],"sourcesContent":["import AttributeType from \"../AttributeType.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport PrimitiveOutlineGenerator from \"./PrimitiveOutlineGenerator.js\";\nimport PrimitiveOutlineStageVS from \"../../Shaders/Model/PrimitiveOutlineStageVS.js\";\nimport PrimitiveOutlineStageFS from \"../../Shaders/Model/PrimitiveOutlineStageFS.js\";\n\n/**\n * The primitive outline pipeline stage configures the shader to render outlines\n * from the CESIUM_primitive_outline extension.\n *\n * @namespace PrimitiveOutlinePipelineStage\n *\n * @private\n */\nconst PrimitiveOutlinePipelineStage = {\n  name: \"PrimitiveOutlinePipelineStage\", // Helps with debugging\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *  <li>Declares a new attribute for the outline (texture) coordinates</li>\n *  <li>Adds shader code to overlay outlines on the primitive after lighting computations</li>\n *  <li>Add uniforms for showing the outline and changing its color</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state\n * @private\n */\nPrimitiveOutlinePipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const uniformMap = renderResources.uniformMap;\n\n  shaderBuilder.addDefine(\n    \"HAS_PRIMITIVE_OUTLINE\",\n    undefined,\n    ShaderDestination.BOTH,\n  );\n\n  shaderBuilder.addAttribute(\"vec3\", \"a_outlineCoordinates\");\n  shaderBuilder.addVarying(\"vec3\", \"v_outlineCoordinates\");\n\n  const outlineCoordinates = primitive.outlineCoordinates;\n  const vertexAttribute = {\n    index: renderResources.attributeIndex++,\n    vertexBuffer: outlineCoordinates.buffer,\n    componentsPerAttribute: AttributeType.getNumberOfComponents(\n      outlineCoordinates.type,\n    ),\n    componentDatatype: outlineCoordinates.componentDatatype,\n    offsetInBytes: outlineCoordinates.byteOffset,\n    strideInBytes: outlineCoordinates.byteStride,\n    normalize: outlineCoordinates.normalized,\n  };\n  renderResources.attributes.push(vertexAttribute);\n\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    \"model_outlineTexture\",\n    ShaderDestination.FRAGMENT,\n  );\n\n  // This automatically handles caching the texture on the context\n  const outlineTexture = PrimitiveOutlineGenerator.createTexture(\n    frameState.context,\n  );\n  uniformMap.model_outlineTexture = function () {\n    return outlineTexture;\n  };\n\n  const model = renderResources.model;\n  shaderBuilder.addUniform(\n    \"vec4\",\n    \"model_outlineColor\",\n    ShaderDestination.FRAGMENT,\n  );\n  uniformMap.model_outlineColor = function () {\n    return model.outlineColor;\n  };\n  shaderBuilder.addUniform(\n    \"bool\",\n    \"model_showOutline\",\n    ShaderDestination.FRAGMENT,\n  );\n  uniformMap.model_showOutline = function () {\n    return model.showOutline;\n  };\n\n  shaderBuilder.addVertexLines(PrimitiveOutlineStageVS);\n  shaderBuilder.addFragmentLines(PrimitiveOutlineStageFS);\n};\n\nexport default PrimitiveOutlinePipelineStage;\n"],"names":["PrimitiveOutlinePipelineStage","name","process","renderResources","primitive","frameState","shaderBuilder","uniformMap","addDefine","undefined","BOTH","addAttribute","addVarying","outlineCoordinates","vertexAttribute","index","attributeIndex","vertexBuffer","buffer","componentsPerAttribute","getNumberOfComponents","type","componentDatatype","offsetInBytes","byteOffset","strideInBytes","byteStride","normalize","normalized","attributes","push","addUniform","FRAGMENT","outlineTexture","createTexture","context","model_outlineTexture","model","model_outlineColor","outlineColor","model_showOutline","showOutline","addVertexLines","addFragmentLines"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;CAOC,GACD,MAAMA,gCAAgC;IACpCC,MAAM;AACR;AAEA;;;;;;;;;;;;CAYC,GACDD,8BAA8BE,OAAO,GAAG,SACtCC,eAAe,EACfC,SAAS,EACTC,UAAU;IAEV,MAAMC,gBAAgBH,gBAAgBG,aAAa;IACnD,MAAMC,aAAaJ,gBAAgBI,UAAU;IAE7CD,cAAcE,SAAS,CACrB,yBACAC,WACA,2LAAiB,CAACC,IAAI;IAGxBJ,cAAcK,YAAY,CAAC,QAAQ;IACnCL,cAAcM,UAAU,CAAC,QAAQ;IAEjC,MAAMC,qBAAqBT,UAAUS,kBAAkB;IACvD,MAAMC,kBAAkB;QACtBC,OAAOZ,gBAAgBa,cAAc;QACrCC,cAAcJ,mBAAmBK,MAAM;QACvCC,wBAAwB,oLAAa,CAACC,qBAAqB,CACzDP,mBAAmBQ,IAAI;QAEzBC,mBAAmBT,mBAAmBS,iBAAiB;QACvDC,eAAeV,mBAAmBW,UAAU;QAC5CC,eAAeZ,mBAAmBa,UAAU;QAC5CC,WAAWd,mBAAmBe,UAAU;IAC1C;IACAzB,gBAAgB0B,UAAU,CAACC,IAAI,CAAChB;IAEhCR,cAAcyB,UAAU,CACtB,aACA,wBACA,2LAAiB,CAACC,QAAQ;IAG5B,gEAAgE;IAChE,MAAMC,iBAAiB,yMAAyB,CAACC,aAAa,CAC5D7B,WAAW8B,OAAO;IAEpB5B,WAAW6B,oBAAoB,GAAG;QAChC,OAAOH;IACT;IAEA,MAAMI,QAAQlC,gBAAgBkC,KAAK;IACnC/B,cAAcyB,UAAU,CACtB,QACA,sBACA,2LAAiB,CAACC,QAAQ;IAE5BzB,WAAW+B,kBAAkB,GAAG;QAC9B,OAAOD,MAAME,YAAY;IAC3B;IACAjC,cAAcyB,UAAU,CACtB,QACA,qBACA,2LAAiB,CAACC,QAAQ;IAE5BzB,WAAWiC,iBAAiB,GAAG;QAC7B,OAAOH,MAAMI,WAAW;IAC1B;IAEAnC,cAAcoC,cAAc,CAAC,yMAAuB;IACpDpC,cAAcqC,gBAAgB,CAAC,yMAAuB;AACxD;uCAEe3C","ignoreList":[0]}},
    {"offset": {"line": 15473, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/PrimitiveStatisticsPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\n/**\n * The primitive statistics update stage updates memory usage statistics\n * on the primitive level. This counts the binary resources that exist\n * for the lifetime of the Model (e.g. attributes and textures\n * loaded by GltfLoader). It does not count resources that are created\n * every time the pipeline is run. The individual pipeline stages are\n * responsible for tracking the additional memory they allocate.\n *\n * @namespace PrimitiveStatisticsPipelineStage\n *\n * @private\n */\nconst PrimitiveStatisticsPipelineStage = {\n  name: \"PrimitiveStatisticsPipelineStage\", // Helps with debugging\n\n  // Expose some methods for testing\n  _countGeometry: countGeometry,\n  _count2DPositions: count2DPositions,\n  _countMorphTargetAttributes: countMorphTargetAttributes,\n  _countMaterialTextures: countMaterialTextures,\n  _countFeatureIdTextures: countFeatureIdTextures,\n  _countBinaryMetadata: countBinaryMetadata,\n};\n\nPrimitiveStatisticsPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const model = renderResources.model;\n  const statistics = model.statistics;\n\n  countGeometry(statistics, primitive);\n  count2DPositions(statistics, renderResources.runtimePrimitive);\n  countMorphTargetAttributes(statistics, primitive);\n  countMaterialTextures(statistics, primitive.material);\n  countFeatureIdTextures(statistics, primitive.featureIds);\n  countBinaryMetadata(statistics, model);\n\n  // The following stages handle their own memory statistics, since all their\n  // resources are generated each time draw commands are built:\n  //\n  // - PickingPipelineStage\n  // - WireframePipelineStage\n  // - InstancingPipelineStage\n  // - FeatureIdPipelineStage (feature ID implicit ranges only)\n};\n\nfunction countGeometry(statistics, primitive) {\n  const indicesCount = defined(primitive.indices)\n    ? primitive.indices.count\n    : ModelUtility.getAttributeBySemantic(primitive, \"POSITION\").count;\n\n  const primitiveType = primitive.primitiveType;\n\n  if (primitiveType === PrimitiveType.POINTS) {\n    statistics.pointsLength += indicesCount;\n  } else if (PrimitiveType.isTriangles(primitiveType)) {\n    statistics.trianglesLength += countTriangles(primitiveType, indicesCount);\n  }\n\n  const attributes = primitive.attributes;\n  const length = attributes.length;\n  for (let i = 0; i < length; i++) {\n    const attribute = attributes[i];\n    if (defined(attribute.buffer)) {\n      const hasCpuCopy = defined(attribute.typedArray);\n      statistics.addBuffer(attribute.buffer, hasCpuCopy);\n    }\n  }\n\n  const outlineCoordinates = primitive.outlineCoordinates;\n  if (defined(outlineCoordinates) && defined(outlineCoordinates.buffer)) {\n    const hasCpuCopy = false;\n    statistics.addBuffer(outlineCoordinates.buffer, hasCpuCopy);\n  }\n\n  const indices = primitive.indices;\n  if (defined(indices) && defined(indices.buffer)) {\n    // Wireframe mode will have both GPU and CPU copies\n    const hasCpuCopy = defined(indices.typedArray);\n    statistics.addBuffer(indices.buffer, hasCpuCopy);\n  }\n}\n\nfunction countTriangles(primitiveType, indicesCount) {\n  switch (primitiveType) {\n    case PrimitiveType.TRIANGLES:\n      return indicesCount / 3;\n    case PrimitiveType.TRIANGLE_STRIP:\n    case PrimitiveType.TRIANGLE_FAN:\n      return Math.max(indicesCount - 2, 0);\n    default:\n      return 0;\n  }\n}\n\nfunction count2DPositions(statistics, runtimePrimitive) {\n  const buffer2D = runtimePrimitive.positionBuffer2D;\n\n  // The 2D buffer is only created the first time the scene switches to 2D mode.\n  // This means there's two main cases for accounting for 2D positions:\n  // 1. The scene was in 3D mode so positions were never generated from\n  //    positionAttribute.typedArray. In this case, countGeometry() will\n  //    detect the typed array and set hasCpuCopy = true. No memory is counted\n  //    here.\n  // 2. The scene was in 2D mode so positions were generated as a buffer.\n  //    Even though the typed array was unlinked from the attribute, it still\n  //    exists in the loader so we count it here.\n  if (defined(buffer2D)) {\n    const hasCpuCopy = true;\n    statistics.addBuffer(buffer2D, hasCpuCopy);\n  }\n}\n\nfunction countMorphTargetAttributes(statistics, primitive) {\n  const morphTargets = primitive.morphTargets;\n  if (!defined(morphTargets)) {\n    return;\n  }\n\n  const hasCpuCopy = false;\n  const morphTargetsLength = morphTargets.length;\n  for (let i = 0; i < morphTargetsLength; i++) {\n    const attributes = morphTargets[i].attributes;\n\n    const attributesLength = attributes.length;\n    for (let j = 0; j < attributesLength; j++) {\n      const attribute = attributes[j];\n\n      if (defined(attribute.buffer)) {\n        statistics.addBuffer(attribute.buffer, hasCpuCopy);\n      }\n    }\n  }\n}\n\nfunction countMaterialTextures(statistics, material) {\n  // gltf-pipeline provides a default material so material will always be\n  // defined.\n  const textureReaders = getAllTextureReaders(material);\n  const length = textureReaders.length;\n  for (let i = 0; i < length; i++) {\n    const textureReader = textureReaders[i];\n    // If textures were loaded asynchronously, the texture may not be available\n    // the first time this is run.\n    if (defined(textureReader) && defined(textureReader.texture)) {\n      statistics.addTexture(textureReader.texture);\n    }\n  }\n}\n\nfunction getAllTextureReaders(material) {\n  const metallicRoughness = material.metallicRoughness;\n  const textureReaders = [\n    material.emissiveTexture,\n    material.normalTexture,\n    material.occlusionTexture,\n    metallicRoughness.baseColorTexture,\n    metallicRoughness.metallicRoughnessTexture,\n  ];\n\n  const specularGlossiness = material.specularGlossiness;\n  if (defined(specularGlossiness)) {\n    textureReaders.push(specularGlossiness.diffuseTexture);\n    textureReaders.push(specularGlossiness.specularGlossinessTexture);\n  }\n\n  return textureReaders;\n}\n\nfunction countFeatureIdTextures(statistics, featureIdSets) {\n  // Feature ID attributes are handled by countGeometry()\n\n  // Feature ID implicit ranges are handled in the FeatureIdPipelineStage,\n  // as they only are created as-needed.\n\n  const length = featureIdSets.length;\n  for (let i = 0; i < length; i++) {\n    const featureIds = featureIdSets[i];\n    if (featureIds instanceof ModelComponents.FeatureIdTexture) {\n      const textureReader = featureIds.textureReader;\n      if (defined(textureReader.texture)) {\n        statistics.addTexture(textureReader.texture);\n      }\n    }\n  }\n}\n\nfunction countBinaryMetadata(statistics, model) {\n  // Add metadata memory to the statistics. Note that feature ID memory is\n  // handled by the Feature ID pipeline stage.\n  const structuralMetadata = model.structuralMetadata;\n  if (defined(structuralMetadata)) {\n    // Property textures are added to the texture memory count. If textures\n    // are loaded asynchronously, this may add 0 to the total. The pipeline\n    // will be re-run when textures are loaded for an accurate count.\n    countPropertyTextures(statistics, structuralMetadata);\n\n    // Property tables are accounted for here.\n    statistics.propertyTablesByteLength +=\n      structuralMetadata.propertyTablesByteLength;\n\n    // Skip property attributes since those are handled in countGeometry().\n  }\n\n  // Model feature tables also have batch and pick textures that need to be\n  // counted.\n  const featureTables = model.featureTables;\n  if (!defined(featureTables)) {\n    return;\n  }\n\n  const length = featureTables.length;\n  for (let i = 0; i < length; i++) {\n    const featureTable = featureTables[i];\n\n    // This does not include the property table memory, since\n    // it is counted through the structuralMetadata above.\n    statistics.addBatchTexture(featureTable.batchTexture);\n  }\n}\n\nfunction countPropertyTextures(statistics, structuralMetadata) {\n  const propertyTextures = structuralMetadata.propertyTextures;\n  if (!defined(propertyTextures)) {\n    return;\n  }\n\n  // Loop over the property textures from here so we can use\n  // statistics.addTexture() which avoids double-counting shared textures.\n  const texturesLength = propertyTextures.length;\n  for (let i = 0; i < texturesLength; i++) {\n    const propertyTexture = propertyTextures[i];\n    const properties = propertyTexture.properties;\n    for (const propertyId in properties) {\n      if (properties.hasOwnProperty(propertyId)) {\n        const property = properties[propertyId];\n        const textureReader = property.textureReader;\n        if (defined(textureReader.texture)) {\n          statistics.addTexture(textureReader.texture);\n        }\n      }\n    }\n  }\n}\n\nexport default PrimitiveStatisticsPipelineStage;\n"],"names":["PrimitiveStatisticsPipelineStage","name","_countGeometry","countGeometry","_count2DPositions","count2DPositions","_countMorphTargetAttributes","countMorphTargetAttributes","_countMaterialTextures","countMaterialTextures","_countFeatureIdTextures","countFeatureIdTextures","_countBinaryMetadata","countBinaryMetadata","process","renderResources","primitive","frameState","model","statistics","runtimePrimitive","material","featureIds","indicesCount","indices","count","getAttributeBySemantic","primitiveType","POINTS","pointsLength","isTriangles","trianglesLength","countTriangles","attributes","length","i","attribute","buffer","hasCpuCopy","typedArray","addBuffer","outlineCoordinates","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","Math","max","buffer2D","positionBuffer2D","morphTargets","morphTargetsLength","attributesLength","j","textureReaders","getAllTextureReaders","textureReader","texture","addTexture","metallicRoughness","emissiveTexture","normalTexture","occlusionTexture","baseColorTexture","metallicRoughnessTexture","specularGlossiness","push","diffuseTexture","specularGlossinessTexture","featureIdSets","FeatureIdTexture","structuralMetadata","countPropertyTextures","propertyTablesByteLength","featureTables","featureTable","addBatchTexture","batchTexture","propertyTextures","texturesLength","propertyTexture","properties","propertyId","hasOwnProperty","property"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 15696, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/SceneMode2DPipelineStage.js"],"sourcesContent":["import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport clone from \"../../Core/clone.js\";\nimport combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport SceneTransforms from \"../SceneTransforms.js\";\n\nconst scratchModelMatrix = new Matrix4();\nconst scratchModelView2D = new Matrix4();\n\n/**\n * The scene mode 2D stage generates resources for rendering a primitive in 2D / CV mode.\n *\n * @namespace SceneMode2DPipelineStage\n *\n * @private\n */\nconst SceneMode2DPipelineStage = {\n  name: \"SceneMode2DPipelineStage\", // Helps with debugging\n};\n\n/**\n * This pipeline stage processes the position attribute of a primitive and adds the relevant\n * define and uniform matrix to the shader. It also generates new resources for the primitive\n * in 2D. These resources persist in the runtime primitive so that the typed array used to\n * store the positional data can be freed.\n *\n * This stage must go before the GeometryPipelineStage in the primitive pipeline.\n *\n * Processes a primitive. This stage modifies the following parts of the render resources:\n * <ul>\n *  <li> creates a vertex buffer for the positions of the primitive projected to 2D\n *  <li> creates the bounding sphere for the primitive in 2D\n *  <li> adds a flag to the shader to use 2D positions\n *  <li> adds a uniform for the view model matrix in 2D\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\n\nSceneMode2DPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const positionAttribute = ModelUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.POSITION,\n  );\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  const model = renderResources.model;\n  const modelMatrix = model.sceneGraph.computedModelMatrix;\n  const nodeComputedTransform = renderResources.runtimeNode.computedTransform;\n  const computedModelMatrix = Matrix4.multiplyTransformation(\n    modelMatrix,\n    nodeComputedTransform,\n    scratchModelMatrix,\n  );\n\n  const boundingSphere2D = computeBoundingSphere2D(\n    renderResources,\n    computedModelMatrix,\n    frameState,\n  );\n\n  const runtimePrimitive = renderResources.runtimePrimitive;\n  runtimePrimitive.boundingSphere2D = boundingSphere2D;\n\n  // If the model is instanced, 2D projection will be handled in the\n  // InstancingPipelineStage.\n  const instances = renderResources.runtimeNode.node.instances;\n  if (defined(instances)) {\n    return;\n  }\n\n  // If the typed array of the position attribute exists, then\n  // the positions haven't been projected to 2D yet.\n  if (defined(positionAttribute.typedArray)) {\n    const buffer2D = createPositionBufferFor2D(\n      positionAttribute,\n      computedModelMatrix,\n      boundingSphere2D,\n      frameState,\n    );\n\n    // Since this buffer will persist even if the pipeline is re-run,\n    // its memory will be counted in PrimitiveStatisticsPipelineStage\n    runtimePrimitive.positionBuffer2D = buffer2D;\n    model._modelResources.push(buffer2D);\n\n    // Unload the typed array. This is just a pointer to the array in\n    // the vertex buffer loader, so if the typed array is shared by\n    // multiple primitives (i.e. multiple instances of the same mesh),\n    // this will not affect the other primitives.\n    positionAttribute.typedArray = undefined;\n  }\n\n  shaderBuilder.addDefine(\n    \"USE_2D_POSITIONS\",\n    undefined,\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addUniform(\"mat4\", \"u_modelView2D\", ShaderDestination.VERTEX);\n\n  const modelMatrix2D = Matrix4.fromTranslation(\n    boundingSphere2D.center,\n    new Matrix4(),\n  );\n\n  const context = frameState.context;\n  const uniformMap = {\n    u_modelView2D: function () {\n      return Matrix4.multiplyTransformation(\n        context.uniformState.view,\n        modelMatrix2D,\n        scratchModelView2D,\n      );\n    },\n  };\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\n\nconst scratchProjectedMin = new Cartesian3();\nconst scratchProjectedMax = new Cartesian3();\n\nfunction computeBoundingSphere2D(renderResources, modelMatrix, frameState) {\n  // Compute the bounding sphere in 2D.\n  const transformedPositionMin = Matrix4.multiplyByPoint(\n    modelMatrix,\n    renderResources.positionMin,\n    scratchProjectedMin,\n  );\n\n  const projectedMin = SceneTransforms.computeActualEllipsoidPosition(\n    frameState,\n    transformedPositionMin,\n    transformedPositionMin,\n  );\n\n  const transformedPositionMax = Matrix4.multiplyByPoint(\n    modelMatrix,\n    renderResources.positionMax,\n    scratchProjectedMax,\n  );\n\n  const projectedMax = SceneTransforms.computeActualEllipsoidPosition(\n    frameState,\n    transformedPositionMax,\n    transformedPositionMax,\n  );\n\n  return BoundingSphere.fromCornerPoints(\n    projectedMin,\n    projectedMax,\n    new BoundingSphere(),\n  );\n}\n\nconst scratchPosition = new Cartesian3();\n\nfunction dequantizePositionsTypedArray(typedArray, quantization) {\n  // Draco compression is normally handled in the dequantization stage\n  // in the shader, but it must be decoded here in order to project\n  // the positions to 2D / CV.\n  const length = typedArray.length;\n  const dequantizedArray = new Float32Array(length);\n  const quantizedVolumeOffset = quantization.quantizedVolumeOffset;\n  const quantizedVolumeStepSize = quantization.quantizedVolumeStepSize;\n  for (let i = 0; i < length; i += 3) {\n    const initialPosition = Cartesian3.fromArray(\n      typedArray,\n      i,\n      scratchPosition,\n    );\n    const scaledPosition = Cartesian3.multiplyComponents(\n      initialPosition,\n      quantizedVolumeStepSize,\n      initialPosition,\n    );\n    const dequantizedPosition = Cartesian3.add(\n      scaledPosition,\n      quantizedVolumeOffset,\n      scaledPosition,\n    );\n\n    dequantizedArray[i] = dequantizedPosition.x;\n    dequantizedArray[i + 1] = dequantizedPosition.y;\n    dequantizedArray[i + 2] = dequantizedPosition.z;\n  }\n\n  return dequantizedArray;\n}\n\nfunction createPositionsTypedArrayFor2D(\n  attribute,\n  modelMatrix,\n  referencePoint,\n  frameState,\n) {\n  let result;\n  if (defined(attribute.quantization)) {\n    // Dequantize the positions if necessary.\n    result = dequantizePositionsTypedArray(\n      attribute.typedArray,\n      attribute.quantization,\n    );\n  } else {\n    result = attribute.typedArray.slice();\n  }\n\n  const startIndex = attribute.byteOffset / Float32Array.BYTES_PER_ELEMENT;\n  const length = result.length;\n  const stride = defined(attribute.byteStride)\n    ? attribute.byteStride / Float32Array.BYTES_PER_ELEMENT\n    : 3;\n\n  for (let i = startIndex; i < length; i += stride) {\n    const initialPosition = Cartesian3.fromArray(result, i, scratchPosition);\n    if (\n      isNaN(initialPosition.x) ||\n      isNaN(initialPosition.y) ||\n      isNaN(initialPosition.z)\n    ) {\n      continue;\n    }\n\n    const transformedPosition = Matrix4.multiplyByPoint(\n      modelMatrix,\n      initialPosition,\n      initialPosition,\n    );\n\n    const projectedPosition = SceneTransforms.computeActualEllipsoidPosition(\n      frameState,\n      transformedPosition,\n      transformedPosition,\n    );\n\n    const relativePosition = Cartesian3.subtract(\n      projectedPosition,\n      referencePoint,\n      projectedPosition,\n    );\n\n    result[i] = relativePosition.x;\n    result[i + 1] = relativePosition.y;\n    result[i + 2] = relativePosition.z;\n  }\n\n  return result;\n}\n\nfunction createPositionBufferFor2D(\n  positionAttribute,\n  modelMatrix,\n  boundingSphere2D,\n  frameState,\n) {\n  // Force the scene mode to be CV. In 2D, projected positions will have\n  // an x-coordinate of 0, which eliminates the height data that is\n  // necessary for rendering in CV mode.\n  const frameStateCV = clone(frameState);\n  frameStateCV.mode = SceneMode.COLUMBUS_VIEW;\n\n  // To prevent jitter, the positions are defined relative to a common\n  // reference point. For convenience, this is the center of the\n  // primitive's bounding sphere in 2D.\n  const referencePoint = boundingSphere2D.center;\n  const projectedPositions = createPositionsTypedArrayFor2D(\n    positionAttribute,\n    modelMatrix,\n    referencePoint,\n    frameStateCV,\n  );\n\n  // Put the resulting data in a GPU buffer.\n  const buffer = Buffer.createVertexBuffer({\n    context: frameState.context,\n    typedArray: projectedPositions,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  buffer.vertexArrayDestroyable = false;\n\n  return buffer;\n}\n\nexport default SceneMode2DPipelineStage;\n"],"names":["scratchModelMatrix","scratchModelView2D","SceneMode2DPipelineStage","name","process","renderResources","primitive","frameState","positionAttribute","getAttributeBySemantic","POSITION","shaderBuilder","model","modelMatrix","sceneGraph","computedModelMatrix","nodeComputedTransform","runtimeNode","computedTransform","multiplyTransformation","boundingSphere2D","computeBoundingSphere2D","runtimePrimitive","instances","node","typedArray","buffer2D","createPositionBufferFor2D","positionBuffer2D","_modelResources","push","undefined","addDefine","VERTEX","addUniform","modelMatrix2D","fromTranslation","center","context","uniformMap","u_modelView2D","uniformState","view","scratchProjectedMin","scratchProjectedMax","transformedPositionMin","multiplyByPoint","positionMin","projectedMin","computeActualEllipsoidPosition","transformedPositionMax","positionMax","projectedMax","fromCornerPoints","scratchPosition","dequantizePositionsTypedArray","quantization","length","dequantizedArray","Float32Array","quantizedVolumeOffset","quantizedVolumeStepSize","i","initialPosition","fromArray","scaledPosition","multiplyComponents","dequantizedPosition","add","x","y","z","createPositionsTypedArrayFor2D","attribute","referencePoint","result","slice","startIndex","byteOffset","BYTES_PER_ELEMENT","stride","byteStride","isNaN","transformedPosition","projectedPosition","relativePosition","subtract","frameStateCV","mode","COLUMBUS_VIEW","projectedPositions","buffer","createVertexBuffer","usage","STATIC_DRAW","vertexArrayDestroyable"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 15878, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/SkinningPipelineStage.js"],"sourcesContent":["import combine from \"../../Core/combine.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport SkinningStageVS from \"../../Shaders/Model/SkinningStageVS.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * The skinning pipeline stage processes the joint matrices of a skinned primitive.\n *\n * @namespace SkinningPipelineStage\n *\n * @private\n */\n\nconst SkinningPipelineStage = {\n  name: \"SkinningPipelineStage\", // Helps with debugging\n\n  FUNCTION_ID_GET_SKINNING_MATRIX: \"getSkinningMatrix\",\n  FUNCTION_SIGNATURE_GET_SKINNING_MATRIX: \"mat4 getSkinningMatrix()\",\n};\n\n/**\n * This pipeline stage processes the joint matrices of a skinned primitive, adding\n * the relevant functions and uniforms to the shaders. The joint and weight attributes\n * themselves are processed in the geometry pipeline stage.\n *\n * Processes a primitive. This stage modifies the following parts of the render resources:\n * <ul>\n *  <li> adds the uniform declaration for the joint matrices in the vertex shader</li>\n *  <li> adds the function to compute the skinning matrix in the vertex shader</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @private\n */\nSkinningPipelineStage.process = function (renderResources, primitive) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\"HAS_SKINNING\", undefined, ShaderDestination.VERTEX);\n  addGetSkinningMatrixFunction(shaderBuilder, primitive);\n\n  const runtimeNode = renderResources.runtimeNode;\n  const jointMatrices = runtimeNode.computedJointMatrices;\n\n  shaderBuilder.addUniform(\n    \"mat4\",\n    `u_jointMatrices[${jointMatrices.length}]`,\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addVertexLines(SkinningStageVS);\n\n  const uniformMap = {\n    u_jointMatrices: function () {\n      return runtimeNode.computedJointMatrices;\n    },\n  };\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\n\nfunction getMaximumAttributeSetIndex(primitive) {\n  let setIndex = -1;\n  const attributes = primitive.attributes;\n  const length = attributes.length;\n  for (let i = 0; i < length; i++) {\n    const attribute = attributes[i];\n    const isJointsOrWeights =\n      attribute.semantic === VertexAttributeSemantic.JOINTS ||\n      attribute.semantic === VertexAttributeSemantic.WEIGHTS;\n\n    if (!isJointsOrWeights) {\n      continue;\n    }\n\n    setIndex = Math.max(setIndex, attribute.setIndex);\n  }\n\n  return setIndex;\n}\n\nfunction addGetSkinningMatrixFunction(shaderBuilder, primitive) {\n  shaderBuilder.addFunction(\n    SkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX,\n    SkinningPipelineStage.FUNCTION_SIGNATURE_GET_SKINNING_MATRIX,\n    ShaderDestination.VERTEX,\n  );\n\n  const initialLine = \"mat4 skinnedMatrix = mat4(0);\";\n  shaderBuilder.addFunctionLines(\n    SkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX,\n    [initialLine],\n  );\n\n  let setIndex;\n  let componentIndex;\n  const componentStrings = [\"x\", \"y\", \"z\", \"w\"];\n  const maximumSetIndex = getMaximumAttributeSetIndex(primitive);\n  for (setIndex = 0; setIndex <= maximumSetIndex; setIndex++) {\n    for (componentIndex = 0; componentIndex <= 3; componentIndex++) {\n      const component = componentStrings[componentIndex];\n      // Example: skinnedMatrix += a_weights_0.x * u_jointMatrices[int(a_joints_0.x)];\n      const line = `skinnedMatrix += a_weights_${setIndex}.${component} * u_jointMatrices[int(a_joints_${setIndex}.${component})];`;\n      shaderBuilder.addFunctionLines(\n        SkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX,\n        [line],\n      );\n    }\n  }\n\n  const returnLine = \"return skinnedMatrix;\";\n  shaderBuilder.addFunctionLines(\n    SkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX,\n    [returnLine],\n  );\n}\n\nexport default SkinningPipelineStage;\n"],"names":["SkinningPipelineStage","name","FUNCTION_ID_GET_SKINNING_MATRIX","FUNCTION_SIGNATURE_GET_SKINNING_MATRIX","process","renderResources","primitive","shaderBuilder","addDefine","undefined","VERTEX","addGetSkinningMatrixFunction","runtimeNode","jointMatrices","computedJointMatrices","addUniform","length","addVertexLines","uniformMap","u_jointMatrices","getMaximumAttributeSetIndex","setIndex","attributes","i","attribute","isJointsOrWeights","semantic","JOINTS","WEIGHTS","Math","max","addFunction","initialLine","addFunctionLines","componentIndex","componentStrings","maximumSetIndex","component","line","returnLine"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;;;;CAMC,GAED,MAAMA,wBAAwB;IAC5BC,MAAM;IAENC,iCAAiC;IACjCC,wCAAwC;AAC1C;AAEA;;;;;;;;;;;;;;CAcC,GACDH,sBAAsBI,OAAO,GAAG,SAAUC,eAAe,EAAEC,SAAS;IAClE,MAAMC,gBAAgBF,gBAAgBE,aAAa;IAEnDA,cAAcC,SAAS,CAAC,gBAAgBC,WAAW,2LAAiB,CAACC,MAAM;IAC3EC,6BAA6BJ,eAAeD;IAE5C,MAAMM,cAAcP,gBAAgBO,WAAW;IAC/C,MAAMC,gBAAgBD,YAAYE,qBAAqB;IAEvDP,cAAcQ,UAAU,CACtB,QACA,CAAC,gBAAgB,EAAEF,cAAcG,MAAM,CAAC,CAAC,CAAC,EAC1C,2LAAiB,CAACN,MAAM;IAG1BH,cAAcU,cAAc,CAAC,iMAAe;IAE5C,MAAMC,aAAa;QACjBC,iBAAiB;YACf,OAAOP,YAAYE,qBAAqB;QAC1C;IACF;IAEAT,gBAAgBa,UAAU,GAAG,IAAA,6KAAO,EAACA,YAAYb,gBAAgBa,UAAU;AAC7E;AAEA,SAASE,4BAA4Bd,SAAS;IAC5C,IAAIe,WAAW,CAAC;IAChB,MAAMC,aAAahB,UAAUgB,UAAU;IACvC,MAAMN,SAASM,WAAWN,MAAM;IAChC,IAAK,IAAIO,IAAI,GAAGA,IAAIP,QAAQO,IAAK;QAC/B,MAAMC,YAAYF,UAAU,CAACC,EAAE;QAC/B,MAAME,oBACJD,UAAUE,QAAQ,KAAK,8LAAuB,CAACC,MAAM,IACrDH,UAAUE,QAAQ,KAAK,8LAAuB,CAACE,OAAO;QAExD,IAAI,CAACH,mBAAmB;YACtB;QACF;QAEAJ,WAAWQ,KAAKC,GAAG,CAACT,UAAUG,UAAUH,QAAQ;IAClD;IAEA,OAAOA;AACT;AAEA,SAASV,6BAA6BJ,aAAa,EAAED,SAAS;IAC5DC,cAAcwB,WAAW,CACvB/B,sBAAsBE,+BAA+B,EACrDF,sBAAsBG,sCAAsC,EAC5D,2LAAiB,CAACO,MAAM;IAG1B,MAAMsB,cAAc;IACpBzB,cAAc0B,gBAAgB,CAC5BjC,sBAAsBE,+BAA+B,EACrD;QAAC8B;KAAY;IAGf,IAAIX;IACJ,IAAIa;IACJ,MAAMC,mBAAmB;QAAC;QAAK;QAAK;QAAK;KAAI;IAC7C,MAAMC,kBAAkBhB,4BAA4Bd;IACpD,IAAKe,WAAW,GAAGA,YAAYe,iBAAiBf,WAAY;QAC1D,IAAKa,iBAAiB,GAAGA,kBAAkB,GAAGA,iBAAkB;YAC9D,MAAMG,YAAYF,gBAAgB,CAACD,eAAe;YAClD,gFAAgF;YAChF,MAAMI,OAAO,CAAC,2BAA2B,EAAEjB,SAAS,CAAC,EAAEgB,UAAU,gCAAgC,EAAEhB,SAAS,CAAC,EAAEgB,UAAU,GAAG,CAAC;YAC7H9B,cAAc0B,gBAAgB,CAC5BjC,sBAAsBE,+BAA+B,EACrD;gBAACoC;aAAK;QAEV;IACF;IAEA,MAAMC,aAAa;IACnBhC,cAAc0B,gBAAgB,CAC5BjC,sBAAsBE,+BAA+B,EACrD;QAACqC;KAAW;AAEhB;uCAEevC","ignoreList":[0]}},
    {"offset": {"line": 15979, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/VerticalExaggerationPipelineStage.js"],"sourcesContent":["import Cartesian2 from \"../../Core/Cartesian2.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport VerticalExaggerationStageVS from \"../../Shaders/Model/VerticalExaggerationStageVS.js\";\n\n/**\n * The vertical exaggeration pipeline stage transforms the vertex\n * positions based on the values of {@link Scene#verticalExaggeration} and\n * {@link Scene#verticalExaggerationRelativeHeight}\n *\n * @namespace VerticalExaggerationPipelineStage\n *\n * @private\n */\nconst VerticalExaggerationPipelineStage = {\n  name: \"VerticalExaggerationPipelineStage\", // Helps with debugging\n};\n\nconst scratchExaggerationUniform = new Cartesian2();\n\n/**\n * Add defines and uniforms for vertical exaggeration calculations in the vertex shader\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state.\n * @private\n */\nVerticalExaggerationPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const { shaderBuilder, uniformMap } = renderResources;\n\n  shaderBuilder.addVertexLines(VerticalExaggerationStageVS);\n\n  shaderBuilder.addDefine(\n    \"HAS_VERTICAL_EXAGGERATION\",\n    undefined,\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addUniform(\n    \"vec2\",\n    \"u_verticalExaggerationAndRelativeHeight\",\n    ShaderDestination.VERTEX,\n  );\n\n  uniformMap.u_verticalExaggerationAndRelativeHeight = function () {\n    return Cartesian2.fromElements(\n      frameState.verticalExaggeration,\n      frameState.verticalExaggerationRelativeHeight,\n      scratchExaggerationUniform,\n    );\n  };\n};\n\nexport default VerticalExaggerationPipelineStage;\n"],"names":["VerticalExaggerationPipelineStage","name","scratchExaggerationUniform","process","renderResources","primitive","frameState","shaderBuilder","uniformMap","addVertexLines","addDefine","undefined","VERTEX","addUniform","u_verticalExaggerationAndRelativeHeight","fromElements","verticalExaggeration","verticalExaggerationRelativeHeight"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;CAQC,GACD,MAAMA,oCAAoC;IACxCC,MAAM;AACR;AAEA,MAAMC,6BAA6B,IAAI,gLAAU;AAEjD;;;;;;;CAOC,GACDF,kCAAkCG,OAAO,GAAG,SAC1CC,eAAe,EACfC,SAAS,EACTC,UAAU;IAEV,MAAM,EAAEC,aAAa,EAAEC,UAAU,EAAE,GAAGJ;IAEtCG,cAAcE,cAAc,CAAC,6MAA2B;IAExDF,cAAcG,SAAS,CACrB,6BACAC,WACA,2LAAiB,CAACC,MAAM;IAG1BL,cAAcM,UAAU,CACtB,QACA,2CACA,2LAAiB,CAACD,MAAM;IAG1BJ,WAAWM,uCAAuC,GAAG;QACnD,OAAO,gLAAU,CAACC,YAAY,CAC5BT,WAAWU,oBAAoB,EAC/BV,WAAWW,kCAAkC,EAC7Cf;IAEJ;AACF;uCAEeF","ignoreList":[0]}},
    {"offset": {"line": 16022, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/WireframePipelineStage.js"],"sourcesContent":["import Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport defined from \"../../Core/defined.js\";\nimport IndexDatatype from \"../../Core/IndexDatatype.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport WireframeIndexGenerator from \"../../Core/WireframeIndexGenerator.js\";\n\n/**\n * The wireframe pipeline stage generates a new index buffer for rendering the\n * structure of the mesh with gl.LINES.\n *\n * @namespace WireframePipelineStage\n * @private\n */\nconst WireframePipelineStage = {\n  name: \"WireframePipelineStage\", // Helps with debugging\n};\n\n/**\n * Process a primitive. This modifies the render resources as follows:\n * <ul>\n *   <li>Adds a define to the fragment shader to prevent extra shading of the lines.</li>\n *   <li>Adds a separate index buffer for wireframe indices</li>\n *   <li>Updates the primitive type and count for rendering with gl.LINES</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this node\n * @param {ModelComponents.primitive} primitive The primitive\n * @param {FrameState} frameState The frame state\n */\nWireframePipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  // Applying normal mapping to the lines will result in rendering\n  // errors on Linux. This define is added to disable normal\n  // mapping in the shader.\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addDefine(\n    \"HAS_WIREFRAME\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  const model = renderResources.model;\n  const wireframeIndexBuffer = createWireframeIndexBuffer(\n    primitive,\n    renderResources.indices,\n    frameState,\n  );\n  model._pipelineResources.push(wireframeIndexBuffer);\n  renderResources.wireframeIndexBuffer = wireframeIndexBuffer;\n\n  // We only need to count memory for the generated buffer. In WebGL 1, the CPU\n  // copy of the original indices is already counted in the geometry stage,\n  // and in WebGL 2, the CPU copy of the original indices (generated from the\n  // data of the original buffer) is discarded after generating the wireframe\n  // indices.\n  const hasCpuCopy = false;\n  model.statistics.addBuffer(wireframeIndexBuffer, hasCpuCopy);\n\n  // Update render resources so we render LINES with the correct index count\n  const originalPrimitiveType = renderResources.primitiveType;\n  const originalCount = renderResources.count;\n  renderResources.primitiveType = PrimitiveType.LINES;\n  renderResources.count = WireframeIndexGenerator.getWireframeIndicesCount(\n    originalPrimitiveType,\n    originalCount,\n  );\n};\n\nfunction createWireframeIndexBuffer(primitive, indices, frameState) {\n  const positionAttribute = ModelUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.POSITION,\n  );\n  const vertexCount = positionAttribute.count;\n  const webgl2 = frameState.context.webgl2;\n\n  let originalIndices;\n  if (defined(indices)) {\n    const indicesBuffer = indices.buffer;\n    const indicesCount = indices.count;\n    if (defined(indicesBuffer) && webgl2) {\n      const useUint8Array = indicesBuffer.sizeInBytes === indicesCount;\n      originalIndices = useUint8Array\n        ? new Uint8Array(indicesCount)\n        : IndexDatatype.createTypedArray(vertexCount, indicesCount);\n\n      indicesBuffer.getBufferData(originalIndices);\n    } else {\n      originalIndices = indices.typedArray;\n    }\n  }\n\n  const primitiveType = primitive.primitiveType;\n  const wireframeIndices = WireframeIndexGenerator.createWireframeIndices(\n    primitiveType,\n    vertexCount,\n    originalIndices,\n  );\n  const indexDatatype = IndexDatatype.fromSizeInBytes(\n    wireframeIndices.BYTES_PER_ELEMENT,\n  );\n\n  return Buffer.createIndexBuffer({\n    context: frameState.context,\n    typedArray: wireframeIndices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: indexDatatype,\n  });\n}\n\nexport default WireframePipelineStage;\n"],"names":["WireframePipelineStage","name","process","renderResources","primitive","frameState","shaderBuilder","addDefine","undefined","FRAGMENT","model","wireframeIndexBuffer","createWireframeIndexBuffer","indices","_pipelineResources","push","hasCpuCopy","statistics","addBuffer","originalPrimitiveType","primitiveType","originalCount","count","LINES","getWireframeIndicesCount","positionAttribute","getAttributeBySemantic","POSITION","vertexCount","webgl2","context","originalIndices","indicesBuffer","buffer","indicesCount","useUint8Array","sizeInBytes","Uint8Array","createTypedArray","getBufferData","typedArray","wireframeIndices","createWireframeIndices","indexDatatype","fromSizeInBytes","BYTES_PER_ELEMENT","createIndexBuffer","usage","STATIC_DRAW"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAEA;;;;;;CAMC,GACD,MAAMA,yBAAyB;IAC7BC,MAAM;AACR;AAEA;;;;;;;;;;;CAWC,GACDD,uBAAuBE,OAAO,GAAG,SAC/BC,eAAe,EACfC,SAAS,EACTC,UAAU;IAEV,gEAAgE;IAChE,0DAA0D;IAC1D,yBAAyB;IACzB,MAAMC,gBAAgBH,gBAAgBG,aAAa;IACnDA,cAAcC,SAAS,CACrB,iBACAC,WACA,2LAAiB,CAACC,QAAQ;IAG5B,MAAMC,QAAQP,gBAAgBO,KAAK;IACnC,MAAMC,uBAAuBC,2BAC3BR,WACAD,gBAAgBU,OAAO,EACvBR;IAEFK,MAAMI,kBAAkB,CAACC,IAAI,CAACJ;IAC9BR,gBAAgBQ,oBAAoB,GAAGA;IAEvC,6EAA6E;IAC7E,yEAAyE;IACzE,2EAA2E;IAC3E,2EAA2E;IAC3E,WAAW;IACX,MAAMK,aAAa;IACnBN,MAAMO,UAAU,CAACC,SAAS,CAACP,sBAAsBK;IAEjD,0EAA0E;IAC1E,MAAMG,wBAAwBhB,gBAAgBiB,aAAa;IAC3D,MAAMC,gBAAgBlB,gBAAgBmB,KAAK;IAC3CnB,gBAAgBiB,aAAa,GAAG,mLAAa,CAACG,KAAK;IACnDpB,gBAAgBmB,KAAK,GAAG,6LAAuB,CAACE,wBAAwB,CACtEL,uBACAE;AAEJ;AAEA,SAAST,2BAA2BR,SAAS,EAAES,OAAO,EAAER,UAAU;IAChE,MAAMoB,oBAAoB,4LAAY,CAACC,sBAAsB,CAC3DtB,WACA,8LAAuB,CAACuB,QAAQ;IAElC,MAAMC,cAAcH,kBAAkBH,KAAK;IAC3C,MAAMO,SAASxB,WAAWyB,OAAO,CAACD,MAAM;IAExC,IAAIE;IACJ,IAAI,IAAA,6KAAO,EAAClB,UAAU;QACpB,MAAMmB,gBAAgBnB,QAAQoB,MAAM;QACpC,MAAMC,eAAerB,QAAQS,KAAK;QAClC,IAAI,IAAA,6KAAO,EAACU,kBAAkBH,QAAQ;YACpC,MAAMM,gBAAgBH,cAAcI,WAAW,KAAKF;YACpDH,kBAAkBI,gBACd,IAAIE,WAAWH,gBACf,mLAAa,CAACI,gBAAgB,CAACV,aAAaM;YAEhDF,cAAcO,aAAa,CAACR;QAC9B,OAAO;YACLA,kBAAkBlB,QAAQ2B,UAAU;QACtC;IACF;IAEA,MAAMpB,gBAAgBhB,UAAUgB,aAAa;IAC7C,MAAMqB,mBAAmB,6LAAuB,CAACC,sBAAsB,CACrEtB,eACAQ,aACAG;IAEF,MAAMY,gBAAgB,mLAAa,CAACC,eAAe,CACjDH,iBAAiBI,iBAAiB;IAGpC,OAAO,gLAAM,CAACC,iBAAiB,CAAC;QAC9BhB,SAASzB,WAAWyB,OAAO;QAC3BU,YAAYC;QACZM,OAAO,qLAAW,CAACC,WAAW;QAC9BL,eAAeA;IACjB;AACF;uCAEe3C","ignoreList":[0]}},
    {"offset": {"line": 16118, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelRuntimePrimitive.js"],"sourcesContent":["import Check from \"../../Core/Check.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport AlphaPipelineStage from \"./AlphaPipelineStage.js\";\nimport BatchTexturePipelineStage from \"./BatchTexturePipelineStage.js\";\nimport ClassificationPipelineStage from \"./ClassificationPipelineStage.js\";\nimport CPUStylingPipelineStage from \"./CPUStylingPipelineStage.js\";\nimport CustomShaderMode from \"./CustomShaderMode.js\";\nimport CustomShaderPipelineStage from \"./CustomShaderPipelineStage.js\";\nimport DequantizationPipelineStage from \"./DequantizationPipelineStage.js\";\nimport EdgeDetectionPipelineStage from \"./EdgeDetectionPipelineStage.js\";\nimport EdgeVisibilityPipelineStage from \"./EdgeVisibilityPipelineStage.js\";\nimport FeatureIdPipelineStage from \"./FeatureIdPipelineStage.js\";\nimport GeometryPipelineStage from \"./GeometryPipelineStage.js\";\nimport ImageryPipelineStage from \"./ImageryPipelineStage.js\";\nimport LightingPipelineStage from \"./LightingPipelineStage.js\";\nimport MaterialPipelineStage from \"./MaterialPipelineStage.js\";\nimport MetadataPickingPipelineStage from \"./MetadataPickingPipelineStage.js\";\nimport MetadataPipelineStage from \"./MetadataPipelineStage.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport MorphTargetsPipelineStage from \"./MorphTargetsPipelineStage.js\";\nimport PickingPipelineStage from \"./PickingPipelineStage.js\";\nimport PointCloudStylingPipelineStage from \"./PointCloudStylingPipelineStage.js\";\nimport PrimitiveOutlinePipelineStage from \"./PrimitiveOutlinePipelineStage.js\";\nimport PrimitiveStatisticsPipelineStage from \"./PrimitiveStatisticsPipelineStage.js\";\nimport SceneMode2DPipelineStage from \"./SceneMode2DPipelineStage.js\";\nimport SelectedFeatureIdPipelineStage from \"./SelectedFeatureIdPipelineStage.js\";\nimport SkinningPipelineStage from \"./SkinningPipelineStage.js\";\nimport VerticalExaggerationPipelineStage from \"./VerticalExaggerationPipelineStage.js\";\nimport WireframePipelineStage from \"./WireframePipelineStage.js\";\nimport oneTimeWarning from \"../../Core/oneTimeWarning.js\";\n\n/**\n * In memory representation of a single primitive, that is, a primitive\n * and its corresponding mesh.\n *\n * @param {object} options An object containing the following options:\n * @param {ModelComponents.Primitive} options.primitive The primitive component.\n * @param {ModelComponents.Node} options.node The node that this primitive belongs to.\n * @param {Model} options.model The {@link Model} this primitive belongs to.\n *\n * @alias ModelRuntimePrimitive\n * @constructor\n *\n * @private\n */\nfunction ModelRuntimePrimitive(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const primitive = options.primitive;\n  const node = options.node;\n  const model = options.model;\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.primitive\", primitive);\n  Check.typeOf.object(\"options.node\", node);\n  Check.typeOf.object(\"options.model\", model);\n  //>>includeEnd('debug');\n\n  /**\n   * The primitive component associated with this primitive.\n   *\n   * @type {ModelComponents.Primitive}\n   *\n   * @private\n   */\n  this.primitive = primitive;\n\n  /**\n   * A reference to the node this primitive belongs to.\n   *\n   * @type {ModelComponents.Node}\n   *\n   * @private\n   */\n  this.node = node;\n\n  /**\n   * A reference to the model\n   *\n   * @type {Model}\n   *\n   * @private\n   */\n  this.model = model;\n\n  /**\n   * Pipeline stages to apply to this primitive. This\n   * is an array of classes, each with a static method called\n   * <code>process()</code>\n   *\n   * @type {object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.pipelineStages = [];\n\n  /**\n   * The generated {@link ModelDrawCommand} or {@link ClassificationModelDrawCommand}\n   * associated with this primitive.\n   *\n   * @type {ModelDrawCommand|ClassificationModelDrawCommand}\n   *\n   * @private\n   */\n  this.drawCommand = undefined;\n\n  /**\n   * The bounding sphere of this primitive in object-space.\n   *\n   * @type {BoundingSphere}\n   *\n   * @private\n   */\n  this.boundingSphere = undefined;\n\n  /**\n   * The bounding sphere of this primitive in 2D world space.\n   *\n   * @type {BoundingSphere}\n   *\n   * @private\n   */\n  this.boundingSphere2D = undefined;\n\n  /**\n   * A buffer containing the primitive's positions projected to 2D world\n   * coordinates. This is generated by SceneMode2DPipelineStage and used for\n   * rendering in 2D / CV mode. The memory is managed by Model; this is just\n   * a reference.\n   *\n   * @type {Buffer}\n   *\n   * @private\n   */\n  this.positionBuffer2D = undefined;\n\n  /**\n   * An array containing the lengths of the vertex batches for classification.\n   * Vertices with the same feature ID are batched together, and each batch is\n   * drawn with a different draw command in order to properly classify other\n   * assets.\n   * <p>\n   * This is generated by ClassificationPipelineStage. The memory is managed by\n   * Model; this is just a reference.\n   * </p>\n   *\n   * @type {number[]}\n   *\n   * @private\n   */\n  this.batchLengths = undefined;\n\n  /**\n   * An array containing the offsets of the vertex batches for classification.\n   * Vertices with the same feature ID are batched together, and each batch is\n   * drawn with a different draw command in order to properly classify other\n   * assets.\n   * <p>\n   * This is generated by ClassificationPipelineStage. The memory is managed by\n   * Model; this is just a reference.\n   * </p>\n   *\n   * @type {number[]}\n   *\n   * @private\n   */\n  this.batchOffsets = undefined;\n\n  /**\n   * Update stages to apply to this primitive.\n   *\n   * @type {object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.updateStages = [];\n}\n\n/**\n * Configure the primitive pipeline stages. If the pipeline needs to be re-run,\n * call this method again to ensure the correct sequence of pipeline stages are\n * used.\n *\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nModelRuntimePrimitive.prototype.configurePipeline = function (frameState) {\n  const pipelineStages = this.pipelineStages;\n  pipelineStages.length = 0;\n\n  const primitive = this.primitive;\n  const node = this.node;\n  const model = this.model;\n\n  const customShader = model.customShader;\n  const style = model.style;\n\n  const useWebgl2 = frameState.context.webgl2;\n  const mode = frameState.mode;\n  const use2D =\n    mode !== SceneMode.SCENE3D && !frameState.scene3DOnly && model._projectTo2D;\n  const hasVerticalExaggeration =\n    frameState.verticalExaggeration !== 1.0 && model.hasVerticalExaggeration;\n\n  const hasMorphTargets =\n    defined(primitive.morphTargets) && primitive.morphTargets.length > 0;\n  const hasSkinning = defined(node.skin);\n\n  // Check whether the model is part of a `Model3DTileContent` that\n  // belongs to a tileset that has imagery layers. If this is the\n  // case, then the `ImageryPipelineStage` will be required.\n  const hasImageryLayers = defined(model.imageryLayers);\n\n  const hasCustomShader = defined(customShader);\n  const hasCustomFragmentShader =\n    hasCustomShader && defined(customShader.fragmentShaderText);\n  const materialsEnabled =\n    !hasCustomFragmentShader ||\n    customShader.mode !== CustomShaderMode.REPLACE_MATERIAL;\n  const hasQuantization = ModelUtility.hasQuantizedAttributes(\n    primitive.attributes,\n  );\n\n  const generateWireframeIndices =\n    model.debugWireframe &&\n    PrimitiveType.isTriangles(primitive.primitiveType) &&\n    // Generating index buffers for wireframes is always possible in WebGL2.\n    // However, this will only work in WebGL1 if the model was constructed with\n    // enableDebugWireframe set to true.\n    (model._enableDebugWireframe || useWebgl2);\n\n  const pointCloudShading = model.pointCloudShading;\n  const hasAttenuation =\n    defined(pointCloudShading) && pointCloudShading.attenuation;\n  const hasPointCloudBackFaceCulling =\n    defined(pointCloudShading) && pointCloudShading.backFaceCulling;\n  const hasPointCloudStyle =\n    primitive.primitiveType === PrimitiveType.POINTS &&\n    (defined(style) || hasAttenuation || hasPointCloudBackFaceCulling);\n\n  const hasOutlines =\n    model._enableShowOutline && defined(primitive.outlineCoordinates);\n\n  const hasEdgeVisibility = defined(primitive.edgeVisibility);\n\n  const featureIdFlags = inspectFeatureIds(model, node, primitive);\n\n  const hasClassification = defined(model.classificationType);\n\n  // Start of pipeline -----------------------------------------------------\n  if (use2D) {\n    pipelineStages.push(SceneMode2DPipelineStage);\n  }\n\n  pipelineStages.push(GeometryPipelineStage);\n\n  if (generateWireframeIndices) {\n    pipelineStages.push(WireframePipelineStage);\n  }\n\n  if (hasClassification) {\n    pipelineStages.push(ClassificationPipelineStage);\n  }\n\n  if (hasMorphTargets) {\n    pipelineStages.push(MorphTargetsPipelineStage);\n  }\n\n  if (hasSkinning) {\n    pipelineStages.push(SkinningPipelineStage);\n  }\n\n  if (hasPointCloudStyle) {\n    pipelineStages.push(PointCloudStylingPipelineStage);\n  }\n\n  if (hasQuantization) {\n    pipelineStages.push(DequantizationPipelineStage);\n  }\n\n  if (hasImageryLayers) {\n    if (hasOutlines) {\n      oneTimeWarning(\n        \"outlines-and-draping\",\n        \"Primitive outlines disable imagery draping\",\n      );\n    } else {\n      pipelineStages.push(ImageryPipelineStage);\n    }\n  }\n\n  if (materialsEnabled) {\n    pipelineStages.push(MaterialPipelineStage);\n  }\n\n  // These stages are always run to ensure structs\n  // are declared to avoid compilation errors.\n  pipelineStages.push(FeatureIdPipelineStage);\n  pipelineStages.push(MetadataPipelineStage);\n  pipelineStages.push(MetadataPickingPipelineStage);\n\n  if (featureIdFlags.hasPropertyTable) {\n    pipelineStages.push(SelectedFeatureIdPipelineStage);\n    pipelineStages.push(BatchTexturePipelineStage);\n    pipelineStages.push(CPUStylingPipelineStage);\n  }\n\n  if (hasVerticalExaggeration) {\n    pipelineStages.push(VerticalExaggerationPipelineStage);\n  }\n\n  if (hasCustomShader) {\n    pipelineStages.push(CustomShaderPipelineStage);\n  }\n\n  pipelineStages.push(LightingPipelineStage);\n\n  if (model.allowPicking) {\n    pipelineStages.push(PickingPipelineStage);\n  }\n\n  if (hasOutlines) {\n    pipelineStages.push(PrimitiveOutlinePipelineStage);\n  }\n\n  if (hasEdgeVisibility) {\n    // Indicate to Scene (after primitive updates) that the edge MRT should be enabled.\n    frameState.edgeVisibilityRequested = true;\n    pipelineStages.push(EdgeVisibilityPipelineStage);\n    pipelineStages.push(EdgeDetectionPipelineStage);\n  }\n\n  pipelineStages.push(AlphaPipelineStage);\n\n  pipelineStages.push(PrimitiveStatisticsPipelineStage);\n\n  return;\n};\n\nfunction inspectFeatureIds(model, node, primitive) {\n  let featureIds;\n  // Check instances first, as this is the most specific type of\n  // feature ID\n  if (defined(node.instances)) {\n    featureIds = ModelUtility.getFeatureIdsByLabel(\n      node.instances.featureIds,\n      model.instanceFeatureIdLabel,\n    );\n\n    if (defined(featureIds)) {\n      return {\n        hasFeatureIds: true,\n        hasPropertyTable: defined(featureIds.propertyTableId),\n      };\n    }\n  }\n\n  featureIds = ModelUtility.getFeatureIdsByLabel(\n    primitive.featureIds,\n    model.featureIdLabel,\n  );\n  if (defined(featureIds)) {\n    return {\n      hasFeatureIds: true,\n      hasPropertyTable: defined(featureIds.propertyTableId),\n    };\n  }\n\n  return {\n    hasFeatureIds: false,\n    hasPropertyTable: false,\n  };\n}\n\nexport default ModelRuntimePrimitive;\n"],"names":["ModelRuntimePrimitive","options","EMPTY_OBJECT","primitive","node","model","typeOf","object","pipelineStages","drawCommand","undefined","boundingSphere","boundingSphere2D","positionBuffer2D","batchLengths","batchOffsets","updateStages","prototype","configurePipeline","frameState","length","customShader","style","useWebgl2","context","webgl2","mode","use2D","SCENE3D","scene3DOnly","_projectTo2D","hasVerticalExaggeration","verticalExaggeration","hasMorphTargets","morphTargets","hasSkinning","skin","hasImageryLayers","imageryLayers","hasCustomShader","hasCustomFragmentShader","fragmentShaderText","materialsEnabled","REPLACE_MATERIAL","hasQuantization","hasQuantizedAttributes","attributes","generateWireframeIndices","debugWireframe","isTriangles","primitiveType","_enableDebugWireframe","pointCloudShading","hasAttenuation","attenuation","hasPointCloudBackFaceCulling","backFaceCulling","hasPointCloudStyle","POINTS","hasOutlines","_enableShowOutline","outlineCoordinates","hasEdgeVisibility","edgeVisibility","featureIdFlags","inspectFeatureIds","hasClassification","classificationType","push","hasPropertyTable","allowPicking","edgeVisibilityRequested","featureIds","instances","getFeatureIdsByLabel","instanceFeatureIdLabel","hasFeatureIds","propertyTableId","featureIdLabel"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 16449, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelSkin.js"],"sourcesContent":["import Matrix4 from \"../../Core/Matrix4.js\";\nimport Check from \"../../Core/Check.js\";\nimport Frozen from \"../../Core/Frozen.js\";\n\n/**\n * An in-memory representation of a skin that affects nodes in the {@link ModelSceneGraph}.\n * Skins should only be initialized after all of the {@link ModelRuntimeNode}s have been instantiated\n * by the scene graph.\n *\n * @param {object} options An object containing the following options:\n * @param {ModelComponents.Skin} options.skin The corresponding skin components from the 3D model\n * @param {ModelSceneGraph} options.sceneGraph The scene graph this skin belongs to.\n *\n * @alias ModelSkin\n * @constructor\n *\n * @private\n */\nfunction ModelSkin(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.skin\", options.skin);\n  Check.typeOf.object(\"options.sceneGraph\", options.sceneGraph);\n  //>>includeEnd('debug');\n\n  this._sceneGraph = options.sceneGraph;\n  const skin = options.skin;\n\n  this._skin = skin;\n\n  this._inverseBindMatrices = undefined;\n  this._joints = [];\n  this._jointMatrices = [];\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelSkin.prototype, {\n  /**\n   * The internal skin this runtime skin represents.\n   *\n   * @memberof ModelSkin.prototype\n   * @type {ModelComponents.Skin}\n   * @readonly\n   *\n   * @private\n   */\n  skin: {\n    get: function () {\n      return this._skin;\n    },\n  },\n\n  /**\n   * The scene graph this skin belongs to.\n   *\n   * @memberof ModelSkin.prototype\n   * @type {ModelSceneGraph}\n   * @readonly\n   *\n   * @private\n   */\n  sceneGraph: {\n    get: function () {\n      return this._sceneGraph;\n    },\n  },\n\n  /**\n   * The inverse bind matrices of the skin.\n   *\n   * @memberof ModelSkin.prototype\n   * @type {Matrix4[]}\n   * @readonly\n   *\n   * @private\n   */\n  inverseBindMatrices: {\n    get: function () {\n      return this._inverseBindMatrices;\n    },\n  },\n\n  /**\n   * The joints of the skin.\n   *\n   * @memberof ModelSkin.prototype\n   * @type {ModelRuntimeNode[]}\n   * @readonly\n   *\n   * @private\n   */\n  joints: {\n    get: function () {\n      return this._joints;\n    },\n  },\n\n  /**\n   * The joint matrices for the skin, where each joint matrix is computed as\n   * jointMatrix = jointWorldTransform * inverseBindMatrix.\n   *\n   * Each node that references this skin is responsible for pre-multiplying its inverse\n   * world transform to the joint matrices for its own use.\n   *\n   * @memberof ModelSkin.prototype\n   * @type {Matrix4[]}\n   * @readonly\n   *\n   * @private\n   */\n  jointMatrices: {\n    get: function () {\n      return this._jointMatrices;\n    },\n  },\n});\n\nfunction initialize(runtimeSkin) {\n  const skin = runtimeSkin.skin;\n  const inverseBindMatrices = skin.inverseBindMatrices;\n  runtimeSkin._inverseBindMatrices = inverseBindMatrices;\n\n  const joints = skin.joints;\n  const length = joints.length;\n\n  const runtimeNodes = runtimeSkin.sceneGraph._runtimeNodes;\n  const runtimeJoints = runtimeSkin.joints;\n  const runtimeJointMatrices = runtimeSkin._jointMatrices;\n  for (let i = 0; i < length; i++) {\n    const jointIndex = joints[i].index;\n    const runtimeNode = runtimeNodes[jointIndex];\n    runtimeJoints.push(runtimeNode);\n\n    const inverseBindMatrix = inverseBindMatrices[i];\n    const jointMatrix = computeJointMatrix(\n      runtimeNode,\n      inverseBindMatrix,\n      new Matrix4(),\n    );\n    runtimeJointMatrices.push(jointMatrix);\n  }\n}\n\nfunction computeJointMatrix(joint, inverseBindMatrix, result) {\n  const jointWorldTransform = Matrix4.multiplyTransformation(\n    joint.transformToRoot,\n    joint.transform,\n    result,\n  );\n\n  result = Matrix4.multiplyTransformation(\n    jointWorldTransform,\n    inverseBindMatrix,\n    result,\n  );\n\n  return result;\n}\n\n/**\n * Updates the joint matrices for the skin.\n *\n * @private\n */\nModelSkin.prototype.updateJointMatrices = function () {\n  const jointMatrices = this._jointMatrices;\n  const length = jointMatrices.length;\n  for (let i = 0; i < length; i++) {\n    const joint = this.joints[i];\n    const inverseBindMatrix = this.inverseBindMatrices[i];\n    jointMatrices[i] = computeJointMatrix(\n      joint,\n      inverseBindMatrix,\n      jointMatrices[i],\n    );\n  }\n};\n\nexport default ModelSkin;\n"],"names":["ModelSkin","options","EMPTY_OBJECT","typeOf","object","skin","sceneGraph","_sceneGraph","_skin","_inverseBindMatrices","undefined","_joints","_jointMatrices","initialize","Object","defineProperties","prototype","get","inverseBindMatrices","joints","jointMatrices","runtimeSkin","length","runtimeNodes","_runtimeNodes","runtimeJoints","runtimeJointMatrices","i","jointIndex","index","runtimeNode","push","inverseBindMatrix","jointMatrix","computeJointMatrix","joint","result","jointWorldTransform","multiplyTransformation","transformToRoot","transform","updateJointMatrices"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;;;;;;CAaC,GACD,SAASA,UAAUC,OAAO;IACxBA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IACxC,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,gBAAgBH,QAAQI,IAAI;IAChD,2KAAK,CAACF,MAAM,CAACC,MAAM,CAAC,sBAAsBH,QAAQK,UAAU;IAC5D,wBAAwB;IAExB,IAAI,CAACC,WAAW,GAAGN,QAAQK,UAAU;IACrC,MAAMD,OAAOJ,QAAQI,IAAI;IAEzB,IAAI,CAACG,KAAK,GAAGH;IAEb,IAAI,CAACI,oBAAoB,GAAGC;IAC5B,IAAI,CAACC,OAAO,GAAG,EAAE;IACjB,IAAI,CAACC,cAAc,GAAG,EAAE;IAExBC,WAAW,IAAI;AACjB;AAEAC,OAAOC,gBAAgB,CAACf,UAAUgB,SAAS,EAAE;IAC3C;;;;;;;;GAQC,GACDX,MAAM;QACJY,KAAK;YACH,OAAO,IAAI,CAACT,KAAK;QACnB;IACF;IAEA;;;;;;;;GAQC,GACDF,YAAY;QACVW,KAAK;YACH,OAAO,IAAI,CAACV,WAAW;QACzB;IACF;IAEA;;;;;;;;GAQC,GACDW,qBAAqB;QACnBD,KAAK;YACH,OAAO,IAAI,CAACR,oBAAoB;QAClC;IACF;IAEA;;;;;;;;GAQC,GACDU,QAAQ;QACNF,KAAK;YACH,OAAO,IAAI,CAACN,OAAO;QACrB;IACF;IAEA;;;;;;;;;;;;GAYC,GACDS,eAAe;QACbH,KAAK;YACH,OAAO,IAAI,CAACL,cAAc;QAC5B;IACF;AACF;AAEA,SAASC,WAAWQ,WAAW;IAC7B,MAAMhB,OAAOgB,YAAYhB,IAAI;IAC7B,MAAMa,sBAAsBb,KAAKa,mBAAmB;IACpDG,YAAYZ,oBAAoB,GAAGS;IAEnC,MAAMC,SAASd,KAAKc,MAAM;IAC1B,MAAMG,SAASH,OAAOG,MAAM;IAE5B,MAAMC,eAAeF,YAAYf,UAAU,CAACkB,aAAa;IACzD,MAAMC,gBAAgBJ,YAAYF,MAAM;IACxC,MAAMO,uBAAuBL,YAAYT,cAAc;IACvD,IAAK,IAAIe,IAAI,GAAGA,IAAIL,QAAQK,IAAK;QAC/B,MAAMC,aAAaT,MAAM,CAACQ,EAAE,CAACE,KAAK;QAClC,MAAMC,cAAcP,YAAY,CAACK,WAAW;QAC5CH,cAAcM,IAAI,CAACD;QAEnB,MAAME,oBAAoBd,mBAAmB,CAACS,EAAE;QAChD,MAAMM,cAAcC,mBAClBJ,aACAE,mBACA,IAAI,6KAAO;QAEbN,qBAAqBK,IAAI,CAACE;IAC5B;AACF;AAEA,SAASC,mBAAmBC,KAAK,EAAEH,iBAAiB,EAAEI,MAAM;IAC1D,MAAMC,sBAAsB,6KAAO,CAACC,sBAAsB,CACxDH,MAAMI,eAAe,EACrBJ,MAAMK,SAAS,EACfJ;IAGFA,SAAS,6KAAO,CAACE,sBAAsB,CACrCD,qBACAL,mBACAI;IAGF,OAAOA;AACT;AAEA;;;;CAIC,GACDpC,UAAUgB,SAAS,CAACyB,mBAAmB,GAAG;IACxC,MAAMrB,gBAAgB,IAAI,CAACR,cAAc;IACzC,MAAMU,SAASF,cAAcE,MAAM;IACnC,IAAK,IAAIK,IAAI,GAAGA,IAAIL,QAAQK,IAAK;QAC/B,MAAMQ,QAAQ,IAAI,CAAChB,MAAM,CAACQ,EAAE;QAC5B,MAAMK,oBAAoB,IAAI,CAACd,mBAAmB,CAACS,EAAE;QACrDP,aAAa,CAACO,EAAE,GAAGO,mBACjBC,OACAH,mBACAZ,aAAa,CAACO,EAAE;IAEpB;AACF;uCAEe3B","ignoreList":[0]}},
    {"offset": {"line": 16598, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelAlphaOptions.js"],"sourcesContent":["/**\n * Options for configuring the {@link AlphaPipelineStage}\n *\n * @alias ModelAlphaOptions\n * @constructor\n *\n * @private\n */\nfunction ModelAlphaOptions() {\n  /**\n   * Which render pass will render the model.\n   *\n   * @type {Pass}\n   * @private\n   */\n  this.pass = undefined;\n  /**\n   * Determines the alpha threshold below which fragments are discarded\n   *\n   * @type {number}\n   * @private\n   */\n  this.alphaCutoff = undefined;\n}\n\nexport default ModelAlphaOptions;\n"],"names":["ModelAlphaOptions","pass","undefined","alphaCutoff"],"mappings":";;;;AAAA;;;;;;;CAOC,GACD,SAASA;IACP;;;;;GAKC,GACD,IAAI,CAACC,IAAI,GAAGC;IACZ;;;;;GAKC,GACD,IAAI,CAACC,WAAW,GAAGD;AACrB;uCAEeF","ignoreList":[0]}},
    {"offset": {"line": 16628, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelRenderResources.js"],"sourcesContent":["import Check from \"../../Core/Check.js\";\nimport ModelAlphaOptions from \"./ModelAlphaOptions.js\";\nimport RenderState from \"../../Renderer/RenderState.js\";\nimport ShaderBuilder from \"../../Renderer/ShaderBuilder.js\";\nimport DepthFunction from \"../DepthFunction.js\";\n\n/**\n * Model render resources are for setting details that are consistent across\n * the entire model.\n *\n * @constructor\n * @param {Model} model The model that will be rendered\n *\n * @private\n */\nfunction ModelRenderResources(model) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"model\", model);\n  //>>includeEnd('debug');\n\n  /**\n   * An object used to build a shader incrementally. Each pipeline stage\n   * may add lines of shader code to this object.\n   *\n   * @type {ShaderBuilder}\n   * @readonly\n   *\n   * @private\n   */\n  this.shaderBuilder = new ShaderBuilder();\n\n  /**\n   * A reference to the model.\n   *\n   * @type {Model}\n   * @readonly\n   *\n   * @private\n   */\n  this.model = model;\n\n  /**\n   * A dictionary mapping uniform name to functions that return the uniform\n   * values.\n   *\n   * @type {Object<string, Function>}\n   * @readonly\n   *\n   * @private\n   */\n  this.uniformMap = {};\n\n  /**\n   * Options for configuring the alpha stage such as pass and alpha cutoff.\n   *\n   * @type {ModelAlphaOptions}\n   * @readonly\n   *\n   * @private\n   */\n  this.alphaOptions = new ModelAlphaOptions();\n\n  /**\n   * An object storing options for creating a {@link RenderState}.\n   * The pipeline stages simply set the options, the render state is created\n   * when the {@link DrawCommand} is constructed.\n   *\n   * @type {object}\n   * @readonly\n   *\n   * @private\n   */\n  this.renderStateOptions = RenderState.getState(\n    RenderState.fromCache({\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS_OR_EQUAL,\n      },\n    }),\n  );\n\n  /**\n   * Whether the model has a silhouette. This value indicates what draw commands\n   * are needed and is set by ModelSilhouettePipelineStage.\n   *\n   * @type {boolean}\n   * @default false\n   *\n   * @private\n   */\n  this.hasSilhouette = false;\n\n  /**\n   * Whether the model is part of a tileset that uses the skipLevelOfDetail\n   * optimization. This value indicates what draw commands are needed and\n   * is set by TilesetPipelineStage.\n   *\n   * @type {boolean}\n   * @default false\n   *\n   * @private\n   */\n  this.hasSkipLevelOfDetail = false;\n\n  /**\n   * The NodeRenderResources for the nodes of the scene graph.\n   *\n   * Note that elements of this array may be <code>undefined</code> when\n   * there was no runtime node for a certain node.\n   *\n   * @type {NodeRenderResources[]}\n   * @default []\n   *\n   * @private\n   */\n  this.nodeRenderResources = [];\n}\n\nexport default ModelRenderResources;\n"],"names":["ModelRenderResources","model","typeOf","object","shaderBuilder","uniformMap","alphaOptions","renderStateOptions","getState","fromCache","depthTest","enabled","func","LESS_OR_EQUAL","hasSilhouette","hasSkipLevelOfDetail","nodeRenderResources"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;CAQC,GACD,SAASA,qBAAqBC,KAAK;IACjC,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,SAASF;IAC7B,wBAAwB;IAExB;;;;;;;;GAQC,GACD,IAAI,CAACG,aAAa,GAAG,IAAI,uLAAa;IAEtC;;;;;;;GAOC,GACD,IAAI,CAACH,KAAK,GAAGA;IAEb;;;;;;;;GAQC,GACD,IAAI,CAACI,UAAU,GAAG,CAAC;IAEnB;;;;;;;GAOC,GACD,IAAI,CAACC,YAAY,GAAG,IAAI,iMAAiB;IAEzC;;;;;;;;;GASC,GACD,IAAI,CAACC,kBAAkB,GAAG,qLAAW,CAACC,QAAQ,CAC5C,qLAAW,CAACC,SAAS,CAAC;QACpBC,WAAW;YACTC,SAAS;YACTC,MAAM,oLAAa,CAACC,aAAa;QACnC;IACF;IAGF;;;;;;;;GAQC,GACD,IAAI,CAACC,aAAa,GAAG;IAErB;;;;;;;;;GASC,GACD,IAAI,CAACC,oBAAoB,GAAG;IAE5B;;;;;;;;;;GAUC,GACD,IAAI,CAACC,mBAAmB,GAAG,EAAE;AAC/B;uCAEehB","ignoreList":[0]}},
    {"offset": {"line": 16739, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelSilhouettePipelineStage.js"],"sourcesContent":["import combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport ModelSilhouetteStageFS from \"../../Shaders/Model/ModelSilhouetteStageFS.js\";\nimport ModelSilhouetteStageVS from \"../../Shaders/Model/ModelSilhouetteStageVS.js\";\n\n/**\n * The model silhouette pipeline stage is responsible applying silhouettes to the model.\n *\n * @namespace ModelSilhouettePipelineStage\n *\n * @private\n */\nconst ModelSilhouettePipelineStage = {\n  name: \"ModelSilhouettePipelineStage\", // Helps with debugging\n};\n\n/**\n * Tracks how many silhouettes have been created. This value is used to\n * assign a reference number to the stencil.\n *\n * @type {number}\n * @private\n */\nModelSilhouettePipelineStage.silhouettesLength = 0;\n\n/**\n * Process a model. This modifies the following parts of the render resources:\n *\n * <ul>\n *  <li>defines the silhouette ID for the model, if it doesn't yet exist\n *  <li>adds a define to the shaders to indicate that the model uses silhouettes</li>\n *  <li>adds a function to the vertex shader to create the silhouette around the model</li>\n *  <li>adds a function to the fragment shader to apply color to the silhouette</li>\n *  <li>adds the uniforms to the shaders for the corresponding silhouette properties</li>\n *  <li>adds a uniform to distinguish which draw command is used to render the silhouette</li>\n *  <li>sets a variable in the render resources denoting whether the model has a silhouette</li>\n * </ul>\n *\n * <p>\n * Note that the model must have a normal attribute in order to use silhouettes. The flag for this is\n * added to the shader in GeometryPipelineStage.\n * </p>\n *\n * @param {ModelRenderResources} renderResources The render resources for this model.\n * @param {Model} model The model.\n * @param {FrameState} frameState The frameState.\n *\n * @private\n */\nModelSilhouettePipelineStage.process = function (\n  renderResources,\n  model,\n  frameState,\n) {\n  if (!defined(model._silhouetteId)) {\n    model._silhouetteId = ++ModelSilhouettePipelineStage.silhouettesLength;\n  }\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addDefine(\"HAS_SILHOUETTE\", undefined, ShaderDestination.BOTH);\n\n  shaderBuilder.addVertexLines(ModelSilhouetteStageVS);\n  shaderBuilder.addFragmentLines(ModelSilhouetteStageFS);\n\n  shaderBuilder.addUniform(\n    \"vec4\",\n    \"model_silhouetteColor\",\n    ShaderDestination.FRAGMENT,\n  );\n\n  shaderBuilder.addUniform(\n    \"float\",\n    \"model_silhouetteSize\",\n    ShaderDestination.VERTEX,\n  );\n\n  // Rendering silhouettes requires two draw commands:\n  // - First, the model is rendered as normal, writing to the stencil buffer.\n  // - Second, the silhouette is drawn, and the stencil buffer is used to cutout\n  //   the part that overlaps the regular model.\n  //\n  // To avoid creating a second shader program to handle silhouettes, a uniform\n  // is used to distinguish between the two draw commands. The second command will set\n  // this uniform true, such that only it applies the silhouette stage.\n  shaderBuilder.addUniform(\n    \"bool\",\n    \"model_silhouettePass\",\n    ShaderDestination.BOTH,\n  );\n\n  const uniformMap = {\n    model_silhouetteColor: function () {\n      return model.silhouetteColor;\n    },\n    model_silhouetteSize: function () {\n      return model.silhouetteSize;\n    },\n    model_silhouettePass: function () {\n      // This will be set to true by the draw command that draws the silhouette.\n      return false;\n    },\n  };\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n  renderResources.hasSilhouette = true;\n};\n\nexport default ModelSilhouettePipelineStage;\n"],"names":["ModelSilhouettePipelineStage","name","silhouettesLength","process","renderResources","model","frameState","_silhouetteId","shaderBuilder","addDefine","undefined","BOTH","addVertexLines","addFragmentLines","addUniform","FRAGMENT","VERTEX","uniformMap","model_silhouetteColor","silhouetteColor","model_silhouetteSize","silhouetteSize","model_silhouettePass","hasSilhouette"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;CAMC,GACD,MAAMA,+BAA+B;IACnCC,MAAM;AACR;AAEA;;;;;;CAMC,GACDD,6BAA6BE,iBAAiB,GAAG;AAEjD;;;;;;;;;;;;;;;;;;;;;;;CAuBC,GACDF,6BAA6BG,OAAO,GAAG,SACrCC,eAAe,EACfC,KAAK,EACLC,UAAU;IAEV,IAAI,CAAC,IAAA,6KAAO,EAACD,MAAME,aAAa,GAAG;QACjCF,MAAME,aAAa,GAAG,EAAEP,6BAA6BE,iBAAiB;IACxE;IAEA,MAAMM,gBAAgBJ,gBAAgBI,aAAa;IACnDA,cAAcC,SAAS,CAAC,kBAAkBC,WAAW,2LAAiB,CAACC,IAAI;IAE3EH,cAAcI,cAAc,CAAC,wMAAsB;IACnDJ,cAAcK,gBAAgB,CAAC,wMAAsB;IAErDL,cAAcM,UAAU,CACtB,QACA,yBACA,2LAAiB,CAACC,QAAQ;IAG5BP,cAAcM,UAAU,CACtB,SACA,wBACA,2LAAiB,CAACE,MAAM;IAG1B,oDAAoD;IACpD,2EAA2E;IAC3E,8EAA8E;IAC9E,8CAA8C;IAC9C,EAAE;IACF,6EAA6E;IAC7E,oFAAoF;IACpF,qEAAqE;IACrER,cAAcM,UAAU,CACtB,QACA,wBACA,2LAAiB,CAACH,IAAI;IAGxB,MAAMM,aAAa;QACjBC,uBAAuB;YACrB,OAAOb,MAAMc,eAAe;QAC9B;QACAC,sBAAsB;YACpB,OAAOf,MAAMgB,cAAc;QAC7B;QACAC,sBAAsB;YACpB,0EAA0E;YAC1E,OAAO;QACT;IACF;IAEAlB,gBAAgBa,UAAU,GAAG,IAAA,6KAAO,EAACA,YAAYb,gBAAgBa,UAAU;IAC3Eb,gBAAgBmB,aAAa,GAAG;AAClC;uCAEevB","ignoreList":[0]}},
    {"offset": {"line": 16831, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelSplitterPipelineStage.js"],"sourcesContent":["import combine from \"../../Core/combine.js\";\nimport ModelSplitterStageFS from \"../../Shaders/Model/ModelSplitterStageFS.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\n\n/**\n * The model splitting pipeline stage is responsible for discarding fragments on the wrong side of the splitter.\n *\n * @namespace ModelSplitterPipelineStage\n *\n * @private\n */\nconst ModelSplitterPipelineStage = {\n  name: \"ModelSplitterPipelineStage\", // Helps with debugging\n\n  SPLIT_DIRECTION_UNIFORM_NAME: \"model_splitDirection\",\n};\n\n/**\n * Process a model. This modifies the following parts of the render resources:\n *\n * <ul>\n *  <li>adds a define to the fragment shader to indicate that the model is split</li>\n *  <li>adds a function to the fragment shader to discard the fragment if it's on the wrong side of the splitter.</li>\n *  <li>adds a uniform indicating the \"splitDirection\" (side of the screen on which to show the model)\n *</ul>\n *\n * @param {ModelRenderResources} renderResources The render resources for this model.\n * @param {Model} model The model.\n * @param {FrameState} frameState The frameState.\n *\n * @private\n */\nModelSplitterPipelineStage.process = function (\n  renderResources,\n  model,\n  frameState,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\n    \"HAS_MODEL_SPLITTER\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addFragmentLines(ModelSplitterStageFS);\n\n  const stageUniforms = {};\n\n  shaderBuilder.addUniform(\n    \"float\",\n    ModelSplitterPipelineStage.SPLIT_DIRECTION_UNIFORM_NAME,\n    ShaderDestination.FRAGMENT,\n  );\n  stageUniforms[ModelSplitterPipelineStage.SPLIT_DIRECTION_UNIFORM_NAME] =\n    function () {\n      return model.splitDirection;\n    };\n\n  renderResources.uniformMap = combine(\n    stageUniforms,\n    renderResources.uniformMap,\n  );\n};\n\nexport default ModelSplitterPipelineStage;\n"],"names":["ModelSplitterPipelineStage","name","SPLIT_DIRECTION_UNIFORM_NAME","process","renderResources","model","frameState","shaderBuilder","addDefine","undefined","FRAGMENT","addFragmentLines","stageUniforms","addUniform","splitDirection","uniformMap"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;CAMC,GACD,MAAMA,6BAA6B;IACjCC,MAAM;IAENC,8BAA8B;AAChC;AAEA;;;;;;;;;;;;;;CAcC,GACDF,2BAA2BG,OAAO,GAAG,SACnCC,eAAe,EACfC,KAAK,EACLC,UAAU;IAEV,MAAMC,gBAAgBH,gBAAgBG,aAAa;IAEnDA,cAAcC,SAAS,CACrB,sBACAC,WACA,2LAAiB,CAACC,QAAQ;IAE5BH,cAAcI,gBAAgB,CAAC,sMAAoB;IAEnD,MAAMC,gBAAgB,CAAC;IAEvBL,cAAcM,UAAU,CACtB,SACAb,2BAA2BE,4BAA4B,EACvD,2LAAiB,CAACQ,QAAQ;IAE5BE,aAAa,CAACZ,2BAA2BE,4BAA4B,CAAC,GACpE;QACE,OAAOG,MAAMS,cAAc;IAC7B;IAEFV,gBAAgBW,UAAU,GAAG,IAAA,6KAAO,EAClCH,eACAR,gBAAgBW,UAAU;AAE9B;uCAEef","ignoreList":[0]}},
    {"offset": {"line": 16881, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/NodeRenderResources.js"],"sourcesContent":["import Check from \"../../Core/Check.js\";\nimport clone from \"../../Core/clone.js\";\n\n/**\n * A model is made up of one or more nodes in the scene graph. Some details\n * such as instancing are computed on a per-node basis. This class provides\n * a place to store such details. It also inherits some properties from\n * the model render resources.\n *\n * @constructor\n *\n * @param {ModelRenderResources} modelRenderResources The model resources to inherit\n * @param {ModelRuntimeNode} runtimeNode The in-memory representation of the scene graph node.\n *\n * @private\n */\nfunction NodeRenderResources(modelRenderResources, runtimeNode) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"modelRenderResources\", modelRenderResources);\n  Check.typeOf.object(\"runtimeNode\", runtimeNode);\n  //>>includeEnd('debug');\n\n  // Properties inherited from the ModelRenderResources.\n  /**\n   * A reference to the model. Inherited from the model render resources.\n   *\n   * @type {Model}\n   * @readonly\n   *\n   * @private\n   */\n  this.model = modelRenderResources.model;\n  /**\n   * An object used to build a shader incrementally. This is cloned from the\n   * model render resources because each node can compute a different shader.\n   *\n   * @type {ShaderBuilder}\n   * @readonly\n   *\n   * @private\n   */\n  this.shaderBuilder = modelRenderResources.shaderBuilder.clone();\n\n  /**\n   * A dictionary mapping uniform name to functions that return the uniform\n   * values. Inherited from the model render resources.\n   *\n   * @type {Object<string, Function>}\n   * @readonly\n   *\n   * @private\n   */\n  this.uniformMap = clone(modelRenderResources.uniformMap);\n\n  /**\n   * Options for configuring the alpha stage such as pass and alpha cutoff.\n   * Inherited from the model render resources.\n   *\n   * @type {ModelAlphaOptions}\n   * @readonly\n   *\n   * @private\n   */\n  this.alphaOptions = clone(modelRenderResources.alphaOptions);\n\n  /**\n   * An object storing options for creating a {@link RenderState}.\n   * The pipeline stages simply set the options, the render state is created\n   * when the {@link DrawCommand} is constructed. Inherited from the model\n   * render resources.\n   *\n   * @type {object}\n   * @readonly\n   *\n   * @private\n   */\n  this.renderStateOptions = clone(\n    modelRenderResources.renderStateOptions,\n    true,\n  );\n\n  /**\n   * Whether the model has a silhouette. This value indicates what draw commands\n   * are needed. Inherited from the model render resources.\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  this.hasSilhouette = modelRenderResources.hasSilhouette;\n\n  /**\n   * Whether the model is part of a tileset that uses the skipLevelOfDetail\n   * optimization. This value indicates what draw commands are needed.\n   * Inherited from the model render resources.\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  this.hasSkipLevelOfDetail = modelRenderResources.hasSkipLevelOfDetail;\n\n  // Other properties.\n  /**\n   * A reference to the runtime node\n   *\n   * @type {ModelRuntimeNode}\n   * @readonly\n   *\n   * @private\n   */\n  this.runtimeNode = runtimeNode;\n\n  /**\n   * An array of objects describing vertex attributes that will eventually\n   * be used to create a {@link VertexArray} for the draw command. Attributes\n   * at the node level may be needed for extensions such as EXT_mesh_gpu_instancing.\n   *\n   * @type {object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.attributes = [];\n\n  /**\n   * The index to give to the next vertex attribute added to the attributes array.\n   * POSITION takes index 0.\n   *\n   * @type {number}\n   *\n   * @private\n   */\n  this.attributeIndex = 1;\n\n  /**\n   * The set index to assign to feature ID vertex attribute(s) created from the\n   * offset/repeat in the feature ID attribute.\n   *\n   * @type {number}\n   * @default 0\n   *\n   * @private\n   */\n  this.featureIdVertexAttributeSetIndex = 0;\n\n  /**\n   * The number of instances. This value is set by InstancingPipelineStage.\n   *\n   * @type {number}\n   * @default 0\n   *\n   * @private\n   */\n  this.instanceCount = 0;\n\n  /**\n   * The PrimitiveRenderResources for the primitives of the node.\n   *\n   * @type {PrimitiveRenderResources[]}\n   * @default []\n   *\n   * @private\n   */\n  this.primitiveRenderResources = [];\n}\n\nexport default NodeRenderResources;\n"],"names":["NodeRenderResources","modelRenderResources","runtimeNode","typeOf","object","model","shaderBuilder","clone","uniformMap","alphaOptions","renderStateOptions","hasSilhouette","hasSkipLevelOfDetail","attributes","attributeIndex","featureIdVertexAttributeSetIndex","instanceCount","primitiveRenderResources"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;;;;;;CAYC,GACD,SAASA,oBAAoBC,oBAAoB,EAAEC,WAAW;IAC5D,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,wBAAwBH;IAC5C,2KAAK,CAACE,MAAM,CAACC,MAAM,CAAC,eAAeF;IACnC,wBAAwB;IAExB,sDAAsD;IACtD;;;;;;;GAOC,GACD,IAAI,CAACG,KAAK,GAAGJ,qBAAqBI,KAAK;IACvC;;;;;;;;GAQC,GACD,IAAI,CAACC,aAAa,GAAGL,qBAAqBK,aAAa,CAACC,KAAK;IAE7D;;;;;;;;GAQC,GACD,IAAI,CAACC,UAAU,GAAG,IAAA,2KAAK,EAACP,qBAAqBO,UAAU;IAEvD;;;;;;;;GAQC,GACD,IAAI,CAACC,YAAY,GAAG,IAAA,2KAAK,EAACR,qBAAqBQ,YAAY;IAE3D;;;;;;;;;;GAUC,GACD,IAAI,CAACC,kBAAkB,GAAG,IAAA,2KAAK,EAC7BT,qBAAqBS,kBAAkB,EACvC;IAGF;;;;;;;;GAQC,GACD,IAAI,CAACC,aAAa,GAAGV,qBAAqBU,aAAa;IAEvD;;;;;;;;;GASC,GACD,IAAI,CAACC,oBAAoB,GAAGX,qBAAqBW,oBAAoB;IAErE,oBAAoB;IACpB;;;;;;;GAOC,GACD,IAAI,CAACV,WAAW,GAAGA;IAEnB;;;;;;;;;GASC,GACD,IAAI,CAACW,UAAU,GAAG,EAAE;IAEpB;;;;;;;GAOC,GACD,IAAI,CAACC,cAAc,GAAG;IAEtB;;;;;;;;GAQC,GACD,IAAI,CAACC,gCAAgC,GAAG;IAExC;;;;;;;GAOC,GACD,IAAI,CAACC,aAAa,GAAG;IAErB;;;;;;;GAOC,GACD,IAAI,CAACC,wBAAwB,GAAG,EAAE;AACpC;uCAEejB","ignoreList":[0]}},
    {"offset": {"line": 17030, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelLightingOptions.js"],"sourcesContent":["import Frozen from \"../../Core/Frozen.js\";\nimport LightingModel from \"./LightingModel.js\";\n\n/**\n * Options for configuring the {@link LightingPipelineStage}\n *\n * @param {object} options An object containing the following options\n * @param {LightingModel} [options.lightingModel=LightingModel.UNLIT] The lighting model to use\n *\n * @alias ModelLightingOptions\n * @constructor\n *\n * @private\n */\nfunction ModelLightingOptions(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  /**\n   * The lighting model to use, such as UNLIT or PBR. This is determined by\n   * the primitive's material.\n   *\n   * @type {LightingModel}\n   *\n   * @private\n   */\n  this.lightingModel = options.lightingModel ?? LightingModel.UNLIT;\n}\n\nexport default ModelLightingOptions;\n"],"names":["ModelLightingOptions","options","EMPTY_OBJECT","lightingModel","UNLIT"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;;;;CAUC,GACD,SAASA,qBAAqBC,OAAO;IACnCA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC;;;;;;;GAOC,GACD,IAAI,CAACC,aAAa,GAAGF,QAAQE,aAAa,IAAI,6LAAa,CAACC,KAAK;AACnE;uCAEeJ","ignoreList":[0]}},
    {"offset": {"line": 17064, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/PrimitiveRenderResources.js"],"sourcesContent":["import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport clone from \"../../Core/clone.js\";\nimport defined from \"../../Core/defined.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport ModelLightingOptions from \"./ModelLightingOptions.js\";\n\n/**\n * Each node may have many mesh primitives. Most model pipeline stages operate\n * at the primitive level. Again, properties are inherited from the parent.\n *\n * @param {NodeRenderResources} nodeRenderResources The node resources to inherit from\n * @param {ModelRuntimePrimitive} runtimePrimitive The primitive.\n *\n * @private\n */\nfunction PrimitiveRenderResources(nodeRenderResources, runtimePrimitive) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"nodeRenderResources\", nodeRenderResources);\n  Check.typeOf.object(\"runtimePrimitive\", runtimePrimitive);\n  //>>includeEnd('debug');\n\n  // Properties inherited from NodeRenderResources.\n  /**\n   * A reference to the model. Inherited from the node render resources.\n   *\n   * @type {Model}\n   * @readonly\n   *\n   * @private\n   */\n  this.model = nodeRenderResources.model;\n\n  /**\n   * A reference to the runtime node. Inherited from the node render resources.\n   *\n   * @type {ModelRuntimeNode}\n   * @readonly\n   *\n   * @private\n   */\n  this.runtimeNode = nodeRenderResources.runtimeNode;\n\n  /**\n   * The vertex attributes. This is shallow cloned from the node render\n   * resources as the primitive will add additional properties.\n   *\n   * @type {object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.attributes = nodeRenderResources.attributes.slice();\n\n  /**\n   * The index to give to the next vertex attribute added to the attributes\n   * array. POSITION takes index 0. Inherited from the node render resources.\n   *\n   * @type {number}\n   *\n   * @private\n   */\n  this.attributeIndex = nodeRenderResources.attributeIndex;\n\n  /**\n   * The set index to assign to feature ID vertex attribute(s) created from the\n   * offset/repeat in the feature ID attribute. Inherited from the node render\n   * resources.\n   *\n   * @type {number}\n   *\n   * @private\n   */\n  this.featureIdVertexAttributeSetIndex =\n    nodeRenderResources.featureIdVertexAttributeSetIndex;\n\n  /**\n   * A dictionary mapping uniform name to functions that return the uniform\n   * values. Inherited from the node render resources.\n   *\n   * @type {Object<string, Function>}\n   * @readonly\n   *\n   * @private\n   */\n  this.uniformMap = clone(nodeRenderResources.uniformMap);\n\n  /**\n   * Options for configuring the alpha stage such as pass and alpha cutoff.\n   * Inherited from the node render resources.\n   *\n   * @type {ModelAlphaOptions}\n   * @readonly\n   *\n   * @private\n   */\n  this.alphaOptions = clone(nodeRenderResources.alphaOptions);\n\n  /**\n   * An object storing options for creating a {@link RenderState}.\n   * The pipeline stages simply set the options; the actual render state\n   * is created when the {@link DrawCommand} is constructed. Inherited from\n   * the node render resources.\n   *\n   * @type {object}\n   * @readonly\n   *\n   * @private\n   */\n  this.renderStateOptions = clone(nodeRenderResources.renderStateOptions, true);\n\n  /**\n   * Whether the model has a silhouette. This value indicates what draw commands\n   * are needed. Inherited from the node render resources.\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  this.hasSilhouette = nodeRenderResources.hasSilhouette;\n\n  /**\n   * Whether the model is part of a tileset that uses the skipLevelOfDetail\n   * optimization. This value indicates what draw commands are needed.\n   * Inherited from the node render resources.\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  this.hasSkipLevelOfDetail = nodeRenderResources.hasSkipLevelOfDetail;\n\n  /**\n   * An object used to build a shader incrementally. This is cloned from the\n   * node render resources because each primitive can compute a different shader.\n   *\n   * @type {ShaderBuilder}\n   * @readonly\n   *\n   * @private\n   */\n  this.shaderBuilder = nodeRenderResources.shaderBuilder.clone();\n\n  /**\n   * The number of instances. Default is 0, if instancing is not used.\n   * Inherited from the node render resources.\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  this.instanceCount = nodeRenderResources.instanceCount;\n\n  // Other properties\n  /**\n   * A reference to the runtime primitive.\n   *\n   * @type {ModelRuntimePrimitive}\n   * @readonly\n   *\n   * @private\n   */\n  this.runtimePrimitive = runtimePrimitive;\n\n  /**\n   * The primitive associated with the render resources.\n   *\n   * @type {ModelComponents.Primitive}\n   * @readonly\n   *\n   * @private\n   */\n  const primitive = runtimePrimitive.primitive;\n\n  /**\n   * The number of indices in the primitive. The interpretation of this\n   * depends on the primitive type.\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  this.count = defined(primitive.indices)\n    ? primitive.indices.count\n    : ModelUtility.getAttributeBySemantic(primitive, \"POSITION\").count;\n\n  /**\n   * Whether or not this primitive has a property table for storing metadata.\n   * When present, picking and styling can use this. This value is set by\n   * SelectedFeatureIdPipelineStage.\n   *\n   * @type {boolean}\n   * @default false\n   *\n   * @private\n   */\n  this.hasPropertyTable = false;\n\n  /**\n   * The indices for this primitive.\n   *\n   * @type {ModelComponents.Indices}\n   * @readonly\n   *\n   * @private\n   */\n  this.indices = primitive.indices;\n\n  /**\n   * Additional index buffer for wireframe mode (if enabled). This value is set\n   * by WireframePipelineStage.\n   *\n   * @type {Buffer}\n   * @readonly\n   *\n   * @private\n   */\n  this.wireframeIndexBuffer = undefined;\n\n  /**\n   * The primitive type such as TRIANGLES or POINTS.\n   *\n   * @type {PrimitiveType}\n   * @readonly\n   *\n   * @private\n   */\n  this.primitiveType = primitive.primitiveType;\n\n  const positionMinMax = ModelUtility.getPositionMinMax(\n    primitive,\n    this.runtimeNode.instancingTranslationMin,\n    this.runtimeNode.instancingTranslationMax,\n  );\n\n  /**\n   * The minimum position value for this primitive.\n   *\n   * @type {Cartesian3}\n   * @readonly\n   *\n   * @private\n   */\n  this.positionMin = Cartesian3.clone(positionMinMax.min, new Cartesian3());\n\n  /**\n   * The maximum position value for this primitive.\n   *\n   * @type {Cartesian3}\n   * @readonly\n   *\n   * @private\n   */\n  this.positionMax = Cartesian3.clone(positionMinMax.max, new Cartesian3());\n\n  /**\n   * The bounding sphere that contains all the vertices in this primitive.\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   *\n   * @private\n   */\n  this.boundingSphere = BoundingSphere.fromCornerPoints(\n    this.positionMin,\n    this.positionMax,\n    new BoundingSphere(),\n  );\n\n  /**\n   * Options for configuring the lighting stage, such as selecting between\n   * unlit and PBR shading.\n   *\n   * @type {ModelLightingOptions}\n   * @readonly\n   *\n   * @private\n   */\n  this.lightingOptions = new ModelLightingOptions();\n\n  /**\n   * The shader variable to use for picking. If picking is enabled, this value\n   * is set by PickingPipelineStage.\n   *\n   * @type {string|undefined}\n   *\n   * @private\n   */\n  this.pickId = undefined;\n}\n\nexport default PrimitiveRenderResources;\n"],"names":["PrimitiveRenderResources","nodeRenderResources","runtimePrimitive","typeOf","object","model","runtimeNode","attributes","slice","attributeIndex","featureIdVertexAttributeSetIndex","uniformMap","alphaOptions","renderStateOptions","hasSilhouette","hasSkipLevelOfDetail","shaderBuilder","clone","instanceCount","primitive","count","indices","getAttributeBySemantic","hasPropertyTable","wireframeIndexBuffer","undefined","primitiveType","positionMinMax","getPositionMinMax","instancingTranslationMin","instancingTranslationMax","positionMin","min","positionMax","max","boundingSphere","fromCornerPoints","lightingOptions","pickId"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 17313, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ClassificationModelDrawCommand.js"],"sourcesContent":["import addAllToArray from \"../../Core/addAllToArray.js\";\nimport BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Check from \"../../Core/Check.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport DrawCommand from \"../../Renderer/DrawCommand.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport RenderState from \"../../Renderer/RenderState.js\";\nimport BlendingState from \"../BlendingState.js\";\nimport ClassificationType from \"../ClassificationType.js\";\nimport DepthFunction from \"../DepthFunction.js\";\nimport StencilConstants from \"../StencilConstants.js\";\nimport StencilFunction from \"../StencilFunction.js\";\nimport StencilOperation from \"../StencilOperation.js\";\n\n/**\n * A wrapper around the draw commands used to render a classification model,\n * i.e. a {@link Model} that classifies another asset. This manages the\n * derived commands and returns only the necessary commands depending on the\n * given frame state.\n *\n * @param {object} options An object containing the following options:\n * @param {DrawCommand} options.command The draw command from which to derive other commands from.\n * @param {PrimitiveRenderResources} options.primitiveRenderResources The render resources of the primitive associated with the command.\n *\n * @alias ClassificationModelDrawCommand\n * @constructor\n *\n * @private\n */\nfunction ClassificationModelDrawCommand(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const command = options.command;\n  const renderResources = options.primitiveRenderResources;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.command\", command);\n  Check.typeOf.object(\"options.primitiveRenderResources\", renderResources);\n  //>>includeEnd('debug');\n\n  const model = renderResources.model;\n\n  this._command = command;\n  this._model = model;\n  this._runtimePrimitive = renderResources.runtimePrimitive;\n\n  // Classification models aren't supported in 2D mode, so there's no need to\n  // duplicate the model matrix for each derived command.\n  this._modelMatrix = command.modelMatrix;\n  this._boundingVolume = command.boundingVolume;\n  this._cullFace = command.renderState.cull.face;\n\n  const type = model.classificationType;\n  this._classificationType = type;\n\n  // ClassificationType has three values: terrain only, 3D Tiles only, or both.\n  this._classifiesTerrain = type !== ClassificationType.CESIUM_3D_TILE;\n  this._classifies3DTiles = type !== ClassificationType.TERRAIN;\n\n  this._useDebugWireframe = model._enableDebugWireframe && model.debugWireframe;\n  this._pickId = renderResources.pickId;\n\n  this._commandListTerrain = [];\n  this._commandList3DTiles = [];\n  this._commandListIgnoreShow = []; // Used for inverted classification.\n  this._commandListDebugWireframe = [];\n\n  this._commandListTerrainPicking = [];\n  this._commandList3DTilesPicking = [];\n\n  initialize(this);\n}\n\nfunction getStencilDepthRenderState(stencilFunction) {\n  return {\n    colorMask: {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false,\n    },\n    stencilTest: {\n      enabled: true,\n      frontFunction: stencilFunction,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.DECREMENT_WRAP,\n        zPass: StencilOperation.KEEP,\n      },\n      backFunction: stencilFunction,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.INCREMENT_WRAP,\n        zPass: StencilOperation.KEEP,\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK,\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL,\n    },\n    depthMask: false,\n  };\n}\n\nconst colorRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK,\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false,\n  },\n  depthMask: false,\n  blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND,\n};\n\nconst pickRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK,\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false,\n  },\n  depthMask: false,\n};\n\nconst scratchDerivedCommands = [];\n\nfunction initialize(drawCommand) {\n  const command = drawCommand._command;\n  const derivedCommands = scratchDerivedCommands;\n\n  // If debug wireframe is enabled, don't derive any new commands.\n  // Render normally in the opaque pass.\n  if (drawCommand._useDebugWireframe) {\n    command.pass = Pass.OPAQUE;\n\n    derivedCommands.length = 0;\n    derivedCommands.push(command);\n\n    drawCommand._commandListDebugWireframe = createBatchCommands(\n      drawCommand,\n      derivedCommands,\n      drawCommand._commandListDebugWireframe,\n    );\n\n    const commandList = drawCommand._commandListDebugWireframe;\n    const length = commandList.length;\n    for (let i = 0; i < length; i++) {\n      // The lengths / offsets of the batches have to be adjusted for wireframe.\n      // Only PrimitiveType.TRIANGLES is allowed for classification, so this\n      // just requires doubling the values for the batches.\n      const command = commandList[i];\n      command.count *= 2;\n      command.offset *= 2;\n    }\n\n    return;\n  }\n\n  const model = drawCommand.model;\n  const allowPicking = model.allowPicking;\n\n  if (drawCommand._classifiesTerrain) {\n    const pass = Pass.TERRAIN_CLASSIFICATION;\n    const stencilDepthCommand = deriveStencilDepthCommand(command, pass);\n    const colorCommand = deriveColorCommand(command, pass);\n\n    derivedCommands.length = 0;\n    derivedCommands.push(stencilDepthCommand, colorCommand);\n\n    drawCommand._commandListTerrain = createBatchCommands(\n      drawCommand,\n      derivedCommands,\n      drawCommand._commandListTerrain,\n    );\n\n    if (allowPicking) {\n      drawCommand._commandListTerrainPicking = createPickCommands(\n        drawCommand,\n        derivedCommands,\n        drawCommand._commandListTerrainPicking,\n      );\n    }\n  }\n\n  if (drawCommand._classifies3DTiles) {\n    const pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    const stencilDepthCommand = deriveStencilDepthCommand(command, pass);\n    const colorCommand = deriveColorCommand(command, pass);\n\n    derivedCommands.length = 0;\n    derivedCommands.push(stencilDepthCommand, colorCommand);\n\n    drawCommand._commandList3DTiles = createBatchCommands(\n      drawCommand,\n      derivedCommands,\n      drawCommand._commandList3DTiles,\n    );\n\n    if (allowPicking) {\n      drawCommand._commandList3DTilesPicking = createPickCommands(\n        drawCommand,\n        derivedCommands,\n        drawCommand._commandList3DTilesPicking,\n      );\n    }\n  }\n}\n\nfunction createBatchCommands(drawCommand, derivedCommands, result) {\n  const runtimePrimitive = drawCommand._runtimePrimitive;\n  const batchLengths = runtimePrimitive.batchLengths;\n  const batchOffsets = runtimePrimitive.batchOffsets;\n\n  const numBatches = batchLengths.length;\n  const numDerivedCommands = derivedCommands.length;\n  for (let i = 0; i < numBatches; i++) {\n    const batchLength = batchLengths[i];\n    const batchOffset = batchOffsets[i];\n    // For multiple derived commands (e.g. stencil and color commands),\n    // they must be added in a certain order even within the batches.\n    for (let j = 0; j < numDerivedCommands; j++) {\n      const derivedCommand = derivedCommands[j];\n      const batchCommand = DrawCommand.shallowClone(derivedCommand);\n      batchCommand.count = batchLength;\n      batchCommand.offset = batchOffset;\n      result.push(batchCommand);\n    }\n  }\n\n  return result;\n}\n\nfunction deriveStencilDepthCommand(command, pass) {\n  const stencilDepthCommand = DrawCommand.shallowClone(command);\n  stencilDepthCommand.cull = false;\n  stencilDepthCommand.pass = pass;\n\n  const stencilFunction =\n    pass === Pass.TERRAIN_CLASSIFICATION\n      ? StencilFunction.ALWAYS\n      : StencilFunction.EQUAL;\n  const renderState = getStencilDepthRenderState(stencilFunction);\n  stencilDepthCommand.renderState = RenderState.fromCache(renderState);\n\n  return stencilDepthCommand;\n}\n\nfunction deriveColorCommand(command, pass) {\n  const colorCommand = DrawCommand.shallowClone(command);\n  colorCommand.cull = false;\n  colorCommand.pass = pass;\n\n  colorCommand.renderState = RenderState.fromCache(colorRenderState);\n\n  return colorCommand;\n}\n\nconst scratchPickCommands = [];\n\nfunction createPickCommands(drawCommand, derivedCommands, commandList) {\n  const renderState = RenderState.fromCache(pickRenderState);\n  const stencilDepthCommand = derivedCommands[0];\n  const colorCommand = derivedCommands[1];\n\n  const pickStencilDepthCommand = DrawCommand.shallowClone(stencilDepthCommand);\n  pickStencilDepthCommand.cull = true;\n  pickStencilDepthCommand.pickOnly = true;\n\n  const pickColorCommand = DrawCommand.shallowClone(colorCommand);\n  pickColorCommand.cull = true;\n  pickColorCommand.pickOnly = true;\n  pickColorCommand.renderState = renderState;\n  pickColorCommand.pickId = drawCommand._pickId;\n\n  const pickCommands = scratchPickCommands;\n  pickCommands.length = 0;\n  pickCommands.push(pickStencilDepthCommand, pickColorCommand);\n\n  return createBatchCommands(drawCommand, pickCommands, commandList);\n}\n\nObject.defineProperties(ClassificationModelDrawCommand.prototype, {\n  /**\n   * The main draw command that the other commands are derived from.\n   *\n   * @memberof ClassificationModelDrawCommand.prototype\n   * @type {DrawCommand}\n   *\n   * @readonly\n   * @private\n   */\n  command: {\n    get: function () {\n      return this._command;\n    },\n  },\n\n  /**\n   * The runtime primitive that the draw command belongs to.\n   *\n   * @memberof ClassificationModelDrawCommand.prototype\n   * @type {ModelRuntimePrimitive}\n   *\n   * @readonly\n   * @private\n   */\n  runtimePrimitive: {\n    get: function () {\n      return this._runtimePrimitive;\n    },\n  },\n\n  /**\n   * The batch lengths used to generate multiple draw commands.\n   *\n   * @memberof ClassificationModelDrawCommand.prototype\n   * @type {number[]}\n   *\n   * @readonly\n   * @private\n   */\n  batchLengths: {\n    get: function () {\n      return this._runtimePrimitive.batchLengths;\n    },\n  },\n\n  /**\n   * The batch offsets used to generate multiple draw commands.\n   *\n   * @memberof ClassificationModelDrawCommand.prototype\n   * @type {number[]}\n   *\n   * @readonly\n   * @private\n   */\n  batchOffsets: {\n    get: function () {\n      return this._runtimePrimitive.batchOffsets;\n    },\n  },\n\n  /**\n   * The model that the draw command belongs to.\n   *\n   * @memberof ClassificationModelDrawCommand.prototype\n   * @type {Model}\n   *\n   * @readonly\n   * @private\n   */\n  model: {\n    get: function () {\n      return this._model;\n    },\n  },\n\n  /**\n   * The classification type of the model that this draw command belongs to.\n   *\n   * @memberof ClassificationModelDrawCommand.prototype\n   * @type {ClassificationType}\n   *\n   * @readonly\n   * @private\n   */\n  classificationType: {\n    get: function () {\n      return this._classificationType;\n    },\n  },\n\n  /**\n   * The current model matrix applied to the draw commands.\n   *\n   * @memberof ClassificationModelDrawCommand.prototype\n   * @type {Matrix4}\n   *\n   * @readonly\n   * @private\n   */\n  modelMatrix: {\n    get: function () {\n      return this._modelMatrix;\n    },\n    set: function (value) {\n      this._modelMatrix = Matrix4.clone(value, this._modelMatrix);\n      const boundingSphere = this._runtimePrimitive.boundingSphere;\n      this._boundingVolume = BoundingSphere.transform(\n        boundingSphere,\n        this._modelMatrix,\n        this._boundingVolume,\n      );\n    },\n  },\n\n  /**\n   * The bounding volume of the main draw command. This is equivalent\n   * to the primitive's bounding sphere transformed by the draw\n   * command's model matrix.\n   *\n   * @memberof ClassificationModelDrawCommand.prototype\n   * @type {BoundingSphere}\n   *\n   * @readonly\n   * @private\n   */\n  boundingVolume: {\n    get: function () {\n      return this._boundingVolume;\n    },\n  },\n\n  /**\n   * Culling is disabled for classification models, so this has no effect on\n   * how the model renders. This only exists to match the interface of\n   * {@link ModelDrawCommand}.\n   *\n   * @memberof ClassificationModelDrawCommand.prototype\n   * @type {CullFace}\n   *\n   * @private\n   */\n  cullFace: {\n    get: function () {\n      return this._cullFace;\n    },\n    set: function (value) {\n      this._cullFace = value;\n    },\n  },\n});\n\n/**\n * Pushes the draw commands necessary to render the primitive.\n *\n * @param {FrameState} frameState The frame state.\n * @param {DrawCommand[]} result The array to push the draw commands to.\n *\n * @returns {DrawCommand[]} The modified result parameter.\n *\n * @private\n */\nClassificationModelDrawCommand.prototype.pushCommands = function (\n  frameState,\n  result,\n) {\n  const passes = frameState.passes;\n  if (passes.render) {\n    if (this._useDebugWireframe) {\n      addAllToArray(result, this._commandListDebugWireframe);\n      return;\n    }\n\n    if (this._classifiesTerrain) {\n      addAllToArray(result, this._commandListTerrain);\n    }\n\n    if (this._classifies3DTiles) {\n      addAllToArray(result, this._commandList3DTiles);\n    }\n\n    const useIgnoreShowCommands =\n      frameState.invertClassification && this._classifies3DTiles;\n\n    if (useIgnoreShowCommands) {\n      if (this._commandListIgnoreShow.length === 0) {\n        const pass = Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;\n        const command = deriveStencilDepthCommand(this._command, pass);\n\n        const derivedCommands = scratchDerivedCommands;\n        derivedCommands.length = 0;\n        derivedCommands.push(command);\n\n        this._commandListIgnoreShow = createBatchCommands(\n          this,\n          derivedCommands,\n          this._commandListIgnoreShow,\n        );\n      }\n\n      addAllToArray(result, this._commandListIgnoreShow);\n    }\n  }\n\n  if (passes.pick) {\n    if (this._classifiesTerrain) {\n      addAllToArray(result, this._commandListTerrainPicking);\n    }\n\n    if (this._classifies3DTiles) {\n      addAllToArray(result, this._commandList3DTilesPicking);\n    }\n  }\n\n  return result;\n};\n\nexport default ClassificationModelDrawCommand;\n"],"names":["ClassificationModelDrawCommand","options","EMPTY_OBJECT","command","renderResources","primitiveRenderResources","typeOf","object","model","_command","_model","_runtimePrimitive","runtimePrimitive","_modelMatrix","modelMatrix","_boundingVolume","boundingVolume","_cullFace","renderState","cull","face","type","classificationType","_classificationType","_classifiesTerrain","CESIUM_3D_TILE","_classifies3DTiles","TERRAIN","_useDebugWireframe","_enableDebugWireframe","debugWireframe","_pickId","pickId","_commandListTerrain","_commandList3DTiles","_commandListIgnoreShow","_commandListDebugWireframe","_commandListTerrainPicking","_commandList3DTilesPicking","initialize","getStencilDepthRenderState","stencilFunction","colorMask","red","green","blue","alpha","stencilTest","enabled","frontFunction","frontOperation","fail","KEEP","zFail","DECREMENT_WRAP","zPass","backFunction","backOperation","INCREMENT_WRAP","reference","CESIUM_3D_TILE_MASK","mask","stencilMask","CLASSIFICATION_MASK","depthTest","func","LESS_OR_EQUAL","depthMask","colorRenderState","NOT_EQUAL","ZERO","blending","PRE_MULTIPLIED_ALPHA_BLEND","pickRenderState","scratchDerivedCommands","drawCommand","derivedCommands","pass","OPAQUE","length","push","createBatchCommands","commandList","i","count","offset","allowPicking","TERRAIN_CLASSIFICATION","stencilDepthCommand","deriveStencilDepthCommand","colorCommand","deriveColorCommand","createPickCommands","CESIUM_3D_TILE_CLASSIFICATION","result","batchLengths","batchOffsets","numBatches","numDerivedCommands","batchLength","batchOffset","j","derivedCommand","batchCommand","shallowClone","ALWAYS","EQUAL","fromCache","scratchPickCommands","pickStencilDepthCommand","pickOnly","pickColorCommand","pickCommands","Object","defineProperties","prototype","get","set","value","clone","boundingSphere","transform","cullFace","pushCommands","frameState","passes","render","useIgnoreShowCommands","invertClassification","CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW","pick"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 17756, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelDrawCommand.js"],"sourcesContent":["import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../../Core/Cartesian2.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport Check from \"../../Core/Check.js\";\nimport clone from \"../../Core/clone.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\nimport DrawCommand from \"../../Renderer/DrawCommand.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport RenderState from \"../../Renderer/RenderState.js\";\nimport BlendingState from \"../BlendingState.js\";\nimport CullFace from \"../CullFace.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ShadowMode from \"../ShadowMode.js\";\nimport StencilConstants from \"../StencilConstants.js\";\nimport StencilFunction from \"../StencilFunction.js\";\nimport StencilOperation from \"../StencilOperation.js\";\nimport StyleCommandsNeeded from \"./StyleCommandsNeeded.js\";\n\n/**\n * A wrapper around the draw commands used to render a {@link ModelRuntimePrimitive}.\n * This manages the derived commands and pushes only the necessary commands depending\n * on the given frame state.\n *\n * @param {object} options An object containing the following options:\n * @param {DrawCommand} options.command The draw command from which to derive other commands from.\n * @param {PrimitiveRenderResources} options.primitiveRenderResources The render resources of the primitive associated with the command.\n *\n * @alias ModelDrawCommand\n * @constructor\n *\n * @private\n */\nfunction ModelDrawCommand(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const command = options.command;\n  const renderResources = options.primitiveRenderResources;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.command\", command);\n  Check.typeOf.object(\"options.primitiveRenderResources\", renderResources);\n  //>>includeEnd('debug');\n\n  const model = renderResources.model;\n  this._model = model;\n\n  const runtimePrimitive = renderResources.runtimePrimitive;\n  this._runtimePrimitive = runtimePrimitive;\n\n  // Store render resources for edge command creation\n  this._primitiveRenderResources = renderResources;\n\n  // If the command is translucent, or if the primitive's material is\n  // double-sided, then back-face culling is automatically disabled for\n  // the command. The user value for back-face culling will be ignored.\n  const isTranslucent = command.pass === Pass.TRANSLUCENT;\n  const isDoubleSided = runtimePrimitive.primitive.material.doubleSided;\n  const usesBackFaceCulling = !isDoubleSided && !isTranslucent;\n  const hasSilhouette = renderResources.hasSilhouette;\n\n  // If the command was already translucent, there's no need to derive a new\n  // translucent command. As of now, a style can't change an originally\n  // translucent feature to opaque since the style's alpha is modulated,\n  // not replaced. When this changes, we need to derive new opaque commands\n  // in initialize().\n  //\n  // Silhouettes for primitives with both opaque and translucent features\n  // are not yet supported.\n  const needsTranslucentCommand = !isTranslucent && !hasSilhouette;\n\n  const needsSkipLevelOfDetailCommands =\n    renderResources.hasSkipLevelOfDetail && !isTranslucent;\n\n  const needsSilhouetteCommands = hasSilhouette;\n\n  const needsEdgeCommands = defined(renderResources.edgeGeometry);\n\n  this._command = command;\n\n  // None of the derived commands (non-2D) use a different model matrix\n  // or bounding volume than the original, so they all point to the\n  // ModelDrawCommand's copy to save update time and memory.\n  this._modelMatrix = Matrix4.clone(command.modelMatrix);\n  this._boundingVolume = BoundingSphere.clone(command.boundingVolume);\n\n  // The 2D model matrix depends on the frame state's map projection,\n  // so it must be updated when the commands are handled in pushCommands.\n  this._modelMatrix2D = new Matrix4();\n  this._boundingVolume2D = new BoundingSphere();\n  this._modelMatrix2DDirty = false;\n\n  this._backFaceCulling = command.renderState.cull.enabled;\n  this._cullFace = command.renderState.cull.face;\n  this._shadows = model.shadows;\n  this._debugShowBoundingVolume = command.debugShowBoundingVolume;\n\n  this._usesBackFaceCulling = usesBackFaceCulling;\n  this._needsTranslucentCommand = needsTranslucentCommand;\n  this._needsSkipLevelOfDetailCommands = needsSkipLevelOfDetailCommands;\n  this._needsSilhouetteCommands = needsSilhouetteCommands;\n  this._needsEdgeCommands = needsEdgeCommands;\n\n  // Derived commands\n  this._originalCommand = undefined;\n  this._translucentCommand = undefined;\n  this._skipLodBackfaceCommand = undefined;\n  this._skipLodStencilCommand = undefined;\n  this._silhouetteModelCommand = undefined;\n  this._silhouetteColorCommand = undefined;\n  this._edgeCommand = undefined;\n\n  // All derived commands (including 2D commands)\n  this._derivedCommands = [];\n  this._has2DCommands = false;\n\n  initialize(this);\n}\n\nfunction ModelDerivedCommand(options) {\n  // The DrawCommand managed by this derived command.\n  this.command = options.command;\n\n  // These control whether the derived command should update the\n  // values of the DrawCommand for the corresponding properties.\n  this.updateShadows = options.updateShadows;\n  this.updateBackFaceCulling = options.updateBackFaceCulling;\n  this.updateCullFace = options.updateCullFace;\n  this.updateDebugShowBoundingVolume = options.updateDebugShowBoundingVolume;\n\n  // Whether this ModelDerivedCommand is in 2D.\n  this.is2D = options.is2D ?? false;\n\n  // A ModelDerivedCommand that is the 2D version of this one.\n  this.derivedCommand2D = undefined;\n}\n\nModelDerivedCommand.clone = function (derivedCommand) {\n  return new ModelDerivedCommand({\n    command: derivedCommand.command,\n    updateShadows: derivedCommand.updateShadows,\n    updateBackFaceCulling: derivedCommand.updateBackFaceCulling,\n    updateCullFace: derivedCommand.updateCullFace,\n    updateDebugShowBoundingVolume: derivedCommand.updateDebugShowBoundingVolume,\n    is2D: derivedCommand.is2D,\n    derivedCommand2D: derivedCommand.derivedCommand2D,\n  });\n};\n\nfunction initialize(drawCommand) {\n  const command = drawCommand._command;\n  command.modelMatrix = drawCommand._modelMatrix;\n  command.boundingVolume = drawCommand._boundingVolume;\n\n  const model = drawCommand._model;\n  const usesBackFaceCulling = drawCommand._usesBackFaceCulling;\n  const derivedCommands = drawCommand._derivedCommands;\n\n  drawCommand._originalCommand = new ModelDerivedCommand({\n    command: command,\n    updateShadows: true,\n    updateBackFaceCulling: usesBackFaceCulling,\n    updateCullFace: usesBackFaceCulling,\n    updateDebugShowBoundingVolume: true,\n    is2D: false,\n  });\n\n  derivedCommands.push(drawCommand._originalCommand);\n\n  if (drawCommand._needsTranslucentCommand) {\n    drawCommand._translucentCommand = new ModelDerivedCommand({\n      command: deriveTranslucentCommand(command),\n      updateShadows: true,\n      updateBackFaceCulling: false,\n      updateCullFace: false,\n      updateDebugShowBoundingVolume: true,\n    });\n\n    derivedCommands.push(drawCommand._translucentCommand);\n  }\n\n  if (drawCommand._needsSkipLevelOfDetailCommands) {\n    drawCommand._skipLodBackfaceCommand = new ModelDerivedCommand({\n      command: deriveSkipLodBackfaceCommand(command),\n      updateShadows: false,\n      updateBackFaceCulling: false,\n      updateCullFace: usesBackFaceCulling,\n      updateDebugShowBoundingVolume: false,\n    });\n\n    drawCommand._skipLodStencilCommand = new ModelDerivedCommand({\n      command: deriveSkipLodStencilCommand(command, model),\n      updateShadows: true,\n      updateBackFaceCulling: usesBackFaceCulling,\n      updateCullFace: usesBackFaceCulling,\n      updateDebugShowBoundingVolume: true,\n    });\n\n    derivedCommands.push(drawCommand._skipLodBackfaceCommand);\n    derivedCommands.push(drawCommand._skipLodStencilCommand);\n  }\n\n  if (drawCommand._needsSilhouetteCommands) {\n    drawCommand._silhouetteModelCommand = new ModelDerivedCommand({\n      command: deriveSilhouetteModelCommand(command, model),\n      updateShadows: true,\n      updateBackFaceCulling: usesBackFaceCulling,\n      updateCullFace: usesBackFaceCulling,\n      updateDebugShowBoundingVolume: true,\n    });\n\n    drawCommand._silhouetteColorCommand = new ModelDerivedCommand({\n      command: deriveSilhouetteColorCommand(command, model),\n      updateShadows: false,\n      updateBackFaceCulling: false,\n      updateCullFace: false,\n      updateDebugShowBoundingVolume: false,\n    });\n\n    derivedCommands.push(drawCommand._silhouetteModelCommand);\n    derivedCommands.push(drawCommand._silhouetteColorCommand);\n  }\n\n  if (drawCommand._needsEdgeCommands) {\n    const renderResources = drawCommand._primitiveRenderResources;\n    drawCommand._edgeCommand = new ModelDerivedCommand({\n      command: deriveEdgeCommand(command, renderResources, model),\n      updateShadows: false,\n      updateBackFaceCulling: false,\n      updateCullFace: false,\n      updateDebugShowBoundingVolume: false,\n    });\n\n    derivedCommands.push(drawCommand._edgeCommand);\n  }\n}\n\nObject.defineProperties(ModelDrawCommand.prototype, {\n  /**\n   * The main draw command that the other commands are derived from.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {DrawCommand}\n   *\n   * @readonly\n   * @private\n   */\n  command: {\n    get: function () {\n      return this._command;\n    },\n  },\n\n  /**\n   * The runtime primitive that the draw command belongs to.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {ModelRuntimePrimitive}\n   *\n   * @readonly\n   * @private\n   */\n  runtimePrimitive: {\n    get: function () {\n      return this._runtimePrimitive;\n    },\n  },\n\n  /**\n   * The model that the draw command belongs to.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {Model}\n   *\n   * @readonly\n   * @private\n   */\n  model: {\n    get: function () {\n      return this._model;\n    },\n  },\n\n  /**\n   * The primitive type of the draw command.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {PrimitiveType}\n   *\n   * @readonly\n   * @private\n   */\n  primitiveType: {\n    get: function () {\n      return this._command.primitiveType;\n    },\n  },\n\n  /**\n   * The current model matrix applied to the draw commands. If there are\n   * 2D draw commands, their model matrix will be derived from the 3D one.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {Matrix4}\n   *\n   * @readonly\n   * @private\n   */\n  modelMatrix: {\n    get: function () {\n      return this._modelMatrix;\n    },\n    set: function (value) {\n      this._modelMatrix = Matrix4.clone(value, this._modelMatrix);\n      this._modelMatrix2DDirty = true;\n\n      this._boundingVolume = BoundingSphere.transform(\n        this.runtimePrimitive.boundingSphere,\n        this._modelMatrix,\n        this._boundingVolume,\n      );\n    },\n  },\n\n  /**\n   * The bounding volume of the main draw command. This is equivalent\n   * to the primitive's bounding sphere transformed by the draw\n   * command's model matrix.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {BoundingSphere}\n   *\n   * @readonly\n   * @private\n   */\n  boundingVolume: {\n    get: function () {\n      return this._boundingVolume;\n    },\n  },\n\n  /**\n   * Whether the geometry casts or receives shadows from light sources.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {ShadowMode}\n   *\n   * @private\n   */\n  shadows: {\n    get: function () {\n      return this._shadows;\n    },\n    set: function (value) {\n      this._shadows = value;\n      updateShadows(this);\n    },\n  },\n\n  /**\n   * Whether to cull back-facing geometry. When true, back face culling is\n   * determined by the material's doubleSided property; when false, back face\n   * culling is disabled. Back faces are not culled if the command is\n   * translucent.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {boolean}\n   *\n   * @private\n   */\n  backFaceCulling: {\n    get: function () {\n      return this._backFaceCulling;\n    },\n    set: function (value) {\n      if (this._backFaceCulling === value) {\n        return;\n      }\n\n      this._backFaceCulling = value;\n      updateBackFaceCulling(this);\n    },\n  },\n\n  /**\n   * Determines which faces to cull, if culling is enabled.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {CullFace}\n   *\n   * @private\n   */\n  cullFace: {\n    get: function () {\n      return this._cullFace;\n    },\n    set: function (value) {\n      if (this._cullFace === value) {\n        return;\n      }\n\n      this._cullFace = value;\n      updateCullFace(this);\n    },\n  },\n\n  /**\n   * Whether to draw the bounding sphere associated with this draw command.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {boolean}\n   *\n   * @private\n   */\n  debugShowBoundingVolume: {\n    get: function () {\n      return this._debugShowBoundingVolume;\n    },\n    set: function (value) {\n      if (this._debugShowBoundingVolume === value) {\n        return;\n      }\n\n      this._debugShowBoundingVolume = value;\n      updateDebugShowBoundingVolume(this);\n    },\n  },\n});\n\nfunction updateModelMatrix2D(drawCommand, frameState) {\n  const modelMatrix = drawCommand._modelMatrix;\n  drawCommand._modelMatrix2D = Matrix4.clone(\n    modelMatrix,\n    drawCommand._modelMatrix2D,\n  );\n\n  // Change the translation's y-component so it appears on the opposite side\n  // of the map.\n  drawCommand._modelMatrix2D[13] -=\n    CesiumMath.sign(modelMatrix[13]) *\n    2.0 *\n    CesiumMath.PI *\n    frameState.mapProjection.ellipsoid.maximumRadius;\n\n  drawCommand._boundingVolume2D = BoundingSphere.transform(\n    drawCommand.runtimePrimitive.boundingSphere,\n    drawCommand._modelMatrix2D,\n    drawCommand._boundingVolume2D,\n  );\n}\n\nfunction updateShadows(drawCommand) {\n  const shadows = drawCommand.shadows;\n  const castShadows = ShadowMode.castShadows(shadows);\n  const receiveShadows = ShadowMode.receiveShadows(shadows);\n\n  const derivedCommands = drawCommand._derivedCommands;\n\n  for (let i = 0; i < derivedCommands.length; ++i) {\n    const derivedCommand = derivedCommands[i];\n    if (derivedCommand.updateShadows) {\n      const command = derivedCommand.command;\n      command.castShadows = castShadows;\n      command.receiveShadows = receiveShadows;\n    }\n  }\n}\n\nfunction updateBackFaceCulling(drawCommand) {\n  const backFaceCulling = drawCommand.backFaceCulling;\n  const derivedCommands = drawCommand._derivedCommands;\n\n  for (let i = 0; i < derivedCommands.length; ++i) {\n    const derivedCommand = derivedCommands[i];\n    if (derivedCommand.updateBackFaceCulling) {\n      const command = derivedCommand.command;\n      const renderState = clone(command.renderState, true);\n      renderState.cull.enabled = backFaceCulling;\n      command.renderState = RenderState.fromCache(renderState);\n    }\n  }\n}\n\nfunction updateCullFace(drawCommand) {\n  const cullFace = drawCommand.cullFace;\n  const derivedCommands = drawCommand._derivedCommands;\n\n  for (let i = 0; i < derivedCommands.length; ++i) {\n    const derivedCommand = derivedCommands[i];\n    if (derivedCommand.updateCullFace) {\n      const command = derivedCommand.command;\n      const renderState = clone(command.renderState, true);\n      renderState.cull.face = cullFace;\n      command.renderState = RenderState.fromCache(renderState);\n    }\n  }\n}\n\nfunction updateDebugShowBoundingVolume(drawCommand) {\n  const debugShowBoundingVolume = drawCommand.debugShowBoundingVolume;\n  const derivedCommands = drawCommand._derivedCommands;\n\n  for (let i = 0; i < derivedCommands.length; ++i) {\n    const derivedCommand = derivedCommands[i];\n    if (derivedCommand.updateDebugShowBoundingVolume) {\n      const command = derivedCommand.command;\n      command.debugShowBoundingVolume = debugShowBoundingVolume;\n    }\n  }\n}\n\n/**\n * Pushes the draw commands necessary to render the primitive.\n * This does not include the draw commands that render its silhouette.\n *\n * @param {FrameState} frameState The frame state.\n * @param {DrawCommand[]} result The array to push the draw commands to.\n *\n * @returns {DrawCommand[]} The modified result parameter.\n *\n * @private\n */\nModelDrawCommand.prototype.pushCommands = function (frameState, result) {\n  const use2D = shouldUse2DCommands(this, frameState);\n\n  if (use2D && !this._has2DCommands) {\n    derive2DCommands(this);\n    this._has2DCommands = true;\n    this._modelMatrix2DDirty = true;\n  }\n\n  if (this._modelMatrix2DDirty) {\n    updateModelMatrix2D(this, frameState);\n    this._modelMatrix2DDirty = false;\n  }\n\n  const styleCommandsNeeded = this.model.styleCommandsNeeded;\n  if (this._needsTranslucentCommand && defined(styleCommandsNeeded)) {\n    // StyleCommandsNeeded has three values: all opaque, all translucent, or both.\n    if (styleCommandsNeeded !== StyleCommandsNeeded.ALL_OPAQUE) {\n      pushCommand(result, this._translucentCommand, use2D);\n    }\n\n    // Continue only if opaque commands are needed.\n    if (styleCommandsNeeded === StyleCommandsNeeded.ALL_TRANSLUCENT) {\n      return;\n    }\n  }\n\n  if (this._needsSkipLevelOfDetailCommands) {\n    const { tileset, tile } = this._model.content;\n\n    if (tileset.hasMixedContent) {\n      if (!tile._finalResolution) {\n        pushCommand(\n          tileset._backfaceCommands,\n          this._skipLodBackfaceCommand,\n          use2D,\n        );\n      }\n\n      updateSkipLodStencilCommand(this, tile, use2D);\n      pushCommand(result, this._skipLodStencilCommand, use2D);\n      return;\n    }\n  }\n\n  if (this._needsSilhouetteCommands) {\n    pushCommand(result, this._silhouetteModelCommand, use2D);\n    return;\n  }\n\n  pushCommand(result, this._originalCommand, use2D);\n\n  return result;\n};\n\n/**\n * Pushes the draw commands necessary to render the silhouette. These should\n * be added to the command list after the draw commands of all primitives\n * in the model have been added. This way, the silhouette won't render on\n * top of the model.\n * <p>\n * This should only be called after pushCommands() has been invoked for\n * the ModelDrawCommand this frame. Otherwise, the silhouette commands may\n * not have been derived for 2D. The model matrix will also not have been\n * updated for 2D commands.\n * </p>\n *\n * @param {FrameState} frameState The frame state.\n * @param {DrawCommand[]} result The array to push the silhouette commands to.\n *\n * @returns {DrawCommand[]} The modified result parameter.\n *\n * @private\n */\nModelDrawCommand.prototype.pushSilhouetteCommands = function (\n  frameState,\n  result,\n) {\n  const use2D = shouldUse2DCommands(this, frameState);\n  pushCommand(result, this._silhouetteColorCommand, use2D);\n\n  return result;\n};\n\n/**\n * @param {FrameState} frameState The frame state.\n * @param {DrawCommand[]} result The draw commands to push to.\n * @returns {DrawCommand[]} The modified command list.\n *\n * @private\n */\nModelDrawCommand.prototype.pushEdgeCommands = function (frameState, result) {\n  if (!defined(this._edgeCommand)) {\n    return result;\n  }\n\n  const use2D = shouldUse2DCommands(this, frameState);\n  pushCommand(result, this._edgeCommand, use2D);\n\n  return result;\n};\n\nfunction pushCommand(commandList, derivedCommand, use2D) {\n  commandList.push(derivedCommand.command);\n  if (use2D) {\n    commandList.push(derivedCommand.derivedCommand2D.command);\n  }\n}\n\nfunction shouldUse2DCommands(drawCommand, frameState) {\n  if (frameState.mode !== SceneMode.SCENE2D || drawCommand.model._projectTo2D) {\n    return false;\n  }\n\n  // The draw command's bounding sphere might cause primitives not to render\n  // over the IDL, even if they are part of the same model. Use the scene graph's\n  // bounding sphere instead.\n  const model = drawCommand.model;\n  const boundingSphere = model.sceneGraph._boundingSphere2D;\n\n  const left = boundingSphere.center.y - boundingSphere.radius;\n  const right = boundingSphere.center.y + boundingSphere.radius;\n  const idl2D =\n    frameState.mapProjection.ellipsoid.maximumRadius * CesiumMath.PI;\n\n  return (left < idl2D && right > idl2D) || (left < -idl2D && right > -idl2D);\n}\n\nfunction derive2DCommand(drawCommand, derivedCommand) {\n  if (!defined(derivedCommand)) {\n    return;\n  }\n\n  // If the model crosses the IDL in 2D, it will be drawn in one viewport but get\n  // clipped by the other viewport. We create a second command that translates\n  // the model matrix to the opposite side of the map so the part that was clipped\n  // in one viewport is drawn in the other.\n  const derivedCommand2D = ModelDerivedCommand.clone(derivedCommand);\n\n  const command2D = DrawCommand.shallowClone(derivedCommand.command);\n  command2D.modelMatrix = drawCommand._modelMatrix2D;\n  command2D.boundingVolume = drawCommand._boundingVolume2D;\n\n  derivedCommand2D.command = command2D;\n  derivedCommand2D.updateShadows = false; // Shadows are disabled for 2D\n  derivedCommand2D.is2D = true;\n\n  derivedCommand.derivedCommand2D = derivedCommand2D;\n  drawCommand._derivedCommands.push(derivedCommand2D);\n\n  return derivedCommand2D;\n}\n\nfunction derive2DCommands(drawCommand) {\n  derive2DCommand(drawCommand, drawCommand._originalCommand);\n  derive2DCommand(drawCommand, drawCommand._translucentCommand);\n  derive2DCommand(drawCommand, drawCommand._skipLodBackfaceCommand);\n  derive2DCommand(drawCommand, drawCommand._skipLodStencilCommand);\n  derive2DCommand(drawCommand, drawCommand._silhouetteModelCommand);\n  derive2DCommand(drawCommand, drawCommand._silhouetteColorCommand);\n  derive2DCommand(drawCommand, drawCommand._edgeCommand);\n}\n\nfunction deriveTranslucentCommand(command) {\n  const derivedCommand = DrawCommand.shallowClone(command);\n  derivedCommand.pass = Pass.TRANSLUCENT;\n  const rs = clone(command.renderState, true);\n  rs.cull.enabled = false;\n  rs.depthMask = false;\n  rs.blending = BlendingState.ALPHA_BLEND;\n  derivedCommand.renderState = RenderState.fromCache(rs);\n\n  return derivedCommand;\n}\n\nfunction deriveSilhouetteModelCommand(command, model) {\n  // Wrap around after exceeding the 8-bit stencil limit.\n  // The reference is unique to each model until this point.\n  const stencilReference = model._silhouetteId % 255;\n  const silhouetteModelCommand = DrawCommand.shallowClone(command);\n  const renderState = clone(command.renderState, true);\n\n  // Write the reference value into the stencil buffer.\n  renderState.stencilTest = {\n    enabled: true,\n    frontFunction: WebGLConstants.ALWAYS,\n    backFunction: WebGLConstants.ALWAYS,\n    reference: stencilReference,\n    mask: ~0,\n    frontOperation: {\n      fail: WebGLConstants.KEEP,\n      zFail: WebGLConstants.KEEP,\n      zPass: WebGLConstants.REPLACE,\n    },\n    backOperation: {\n      fail: WebGLConstants.KEEP,\n      zFail: WebGLConstants.KEEP,\n      zPass: WebGLConstants.REPLACE,\n    },\n  };\n\n  if (model.isInvisible()) {\n    renderState.colorMask = {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false,\n    };\n  }\n\n  silhouetteModelCommand.renderState = RenderState.fromCache(renderState);\n\n  return silhouetteModelCommand;\n}\n\nfunction deriveSilhouetteColorCommand(command, model) {\n  // Wrap around after exceeding the 8-bit stencil limit.\n  // The reference is unique to each model until this point.\n  const stencilReference = model._silhouetteId % 255;\n  const silhouetteColorCommand = DrawCommand.shallowClone(command);\n  const renderState = clone(command.renderState, true);\n  renderState.cull.enabled = false;\n\n  // Render the silhouette in the translucent pass if either the command\n  // pass or the silhouette color is translucent. This will account for\n  // translucent model color, since ModelColorPipelineStage sets the pass\n  // to translucent.\n  const silhouetteTranslucent =\n    command.pass === Pass.TRANSLUCENT || model.silhouetteColor.alpha < 1.0;\n  if (silhouetteTranslucent) {\n    silhouetteColorCommand.pass = Pass.TRANSLUCENT;\n    renderState.depthMask = false;\n    renderState.blending = BlendingState.ALPHA_BLEND;\n  }\n\n  // Only render the pixels of the silhouette that don't conflict with\n  // the stencil buffer. This way, the silhouette doesn't render over\n  // the original model.\n  renderState.stencilTest = {\n    enabled: true,\n    frontFunction: WebGLConstants.NOTEQUAL,\n    backFunction: WebGLConstants.NOTEQUAL,\n    reference: stencilReference,\n    mask: ~0,\n    frontOperation: {\n      fail: WebGLConstants.KEEP,\n      zFail: WebGLConstants.KEEP,\n      zPass: WebGLConstants.KEEP,\n    },\n    backOperation: {\n      fail: WebGLConstants.KEEP,\n      zFail: WebGLConstants.KEEP,\n      zPass: WebGLConstants.KEEP,\n    },\n  };\n\n  const uniformMap = clone(command.uniformMap);\n  uniformMap.model_silhouettePass = function () {\n    return true;\n  };\n\n  silhouetteColorCommand.renderState = RenderState.fromCache(renderState);\n  silhouetteColorCommand.uniformMap = uniformMap;\n  silhouetteColorCommand.castShadows = false;\n  silhouetteColorCommand.receiveShadows = false;\n\n  return silhouetteColorCommand;\n}\n\nfunction deriveEdgeCommand(command, renderResources) {\n  const edgeGeometry = renderResources.edgeGeometry;\n  const edgeCommand = DrawCommand.shallowClone(command);\n\n  // Use the edge geometry instead of the original geometry\n  edgeCommand.vertexArray = edgeGeometry.vertexArray;\n  edgeCommand.primitiveType = edgeGeometry.primitiveType;\n  edgeCommand.count = edgeGeometry.indexCount;\n\n  // Use the edge shader program if available\n  if (defined(edgeGeometry.shaderProgram)) {\n    edgeCommand.shaderProgram = edgeGeometry.shaderProgram;\n  }\n\n  // Set pass for edge rendering (use the pass specified in edgeGeometry)\n  edgeCommand.pass = edgeGeometry.pass;\n\n  // Override uniformMap to set u_isEdgePass to true for the edge pass\n  const uniformMap = clone(command.uniformMap);\n  uniformMap.u_isEdgePass = function () {\n    return true; // This is the edge pass\n  };\n  edgeCommand.uniformMap = uniformMap;\n\n  edgeCommand.castShadows = false;\n  edgeCommand.receiveShadows = false;\n\n  return edgeCommand;\n}\n\nfunction updateSkipLodStencilCommand(drawCommand, tile, use2D) {\n  const stencilDerivedComand = drawCommand._skipLodStencilCommand;\n  const stencilCommand = stencilDerivedComand.command;\n\n  const selectionDepth = tile._selectionDepth;\n  const lastSelectionDepth = getLastSelectionDepth(stencilCommand);\n\n  if (selectionDepth !== lastSelectionDepth) {\n    const skipLodStencilReference = getStencilReference(selectionDepth);\n    const renderState = clone(stencilCommand.renderState, true);\n    renderState.stencilTest.reference = skipLodStencilReference;\n    stencilCommand.renderState = RenderState.fromCache(renderState);\n\n    if (use2D) {\n      stencilDerivedComand.derivedCommand2D.renderState = renderState;\n    }\n  }\n}\n\nfunction getLastSelectionDepth(stencilCommand) {\n  // Isolate the selection depth from the stencil reference.\n  const reference = stencilCommand.renderState.stencilTest.reference;\n  return (\n    (reference & StencilConstants.SKIP_LOD_MASK) >>>\n    StencilConstants.SKIP_LOD_BIT_SHIFT\n  );\n}\n\nfunction getStencilReference(selectionDepth) {\n  // Stencil test is masked to the most significant 3 bits so the reference is shifted.\n  // Writes 0 for the terrain bit.\n  return (\n    StencilConstants.CESIUM_3D_TILE_MASK |\n    (selectionDepth << StencilConstants.SKIP_LOD_BIT_SHIFT)\n  );\n}\n\nfunction deriveSkipLodBackfaceCommand(command) {\n  // Write just backface depth of unresolved tiles so resolved stenciled tiles\n  // do not appear in front.\n  const backfaceCommand = DrawCommand.shallowClone(command);\n  const renderState = clone(command.renderState, true);\n  renderState.cull.enabled = true;\n  renderState.cull.face = CullFace.FRONT;\n  // Back faces do not need to write color.\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false,\n  };\n  // Push back face depth away from the camera so it is less likely that back faces and front faces of the same tile\n  // intersect and overlap. This helps avoid flickering for very thin double-sided walls.\n  renderState.polygonOffset = {\n    enabled: true,\n    factor: 5.0,\n    units: 5.0,\n  };\n\n  // The stencil test is set in TilesetPipelineStage.\n\n  const uniformMap = clone(backfaceCommand.uniformMap);\n  const polygonOffset = new Cartesian2(5.0, 5.0);\n\n  uniformMap.u_polygonOffset = function () {\n    return polygonOffset;\n  };\n\n  backfaceCommand.renderState = RenderState.fromCache(renderState);\n  backfaceCommand.uniformMap = uniformMap;\n  backfaceCommand.castShadows = false;\n  backfaceCommand.receiveShadows = false;\n\n  return backfaceCommand;\n}\n\nfunction deriveSkipLodStencilCommand(command) {\n  // Tiles only draw if their selection depth is >= the tile drawn already. They write their\n  // selection depth to the stencil buffer to prevent ancestor tiles from drawing on top\n  const stencilCommand = DrawCommand.shallowClone(command);\n  const renderState = clone(command.renderState, true);\n  // The stencil reference is updated dynamically; see updateSkipLodStencilCommand().\n  const { stencilTest } = renderState;\n  stencilTest.enabled = true;\n  stencilTest.mask = StencilConstants.SKIP_LOD_MASK;\n  stencilTest.reference = StencilConstants.CESIUM_3D_TILE_MASK;\n  stencilTest.frontFunction = StencilFunction.GREATER_OR_EQUAL;\n  stencilTest.frontOperation.zPass = StencilOperation.REPLACE;\n  stencilTest.backFunction = StencilFunction.GREATER_OR_EQUAL;\n  stencilTest.backOperation.zPass = StencilOperation.REPLACE;\n  renderState.stencilMask =\n    StencilConstants.CESIUM_3D_TILE_MASK | StencilConstants.SKIP_LOD_MASK;\n\n  stencilCommand.renderState = RenderState.fromCache(renderState);\n\n  return stencilCommand;\n}\n\nexport default ModelDrawCommand;\n"],"names":["ModelDrawCommand","options","EMPTY_OBJECT","command","renderResources","primitiveRenderResources","typeOf","object","model","_model","runtimePrimitive","_runtimePrimitive","_primitiveRenderResources","isTranslucent","pass","TRANSLUCENT","isDoubleSided","primitive","material","doubleSided","usesBackFaceCulling","hasSilhouette","needsTranslucentCommand","needsSkipLevelOfDetailCommands","hasSkipLevelOfDetail","needsSilhouetteCommands","needsEdgeCommands","edgeGeometry","_command","_modelMatrix","clone","modelMatrix","_boundingVolume","boundingVolume","_modelMatrix2D","_boundingVolume2D","_modelMatrix2DDirty","_backFaceCulling","renderState","cull","enabled","_cullFace","face","_shadows","shadows","_debugShowBoundingVolume","debugShowBoundingVolume","_usesBackFaceCulling","_needsTranslucentCommand","_needsSkipLevelOfDetailCommands","_needsSilhouetteCommands","_needsEdgeCommands","_originalCommand","undefined","_translucentCommand","_skipLodBackfaceCommand","_skipLodStencilCommand","_silhouetteModelCommand","_silhouetteColorCommand","_edgeCommand","_derivedCommands","_has2DCommands","initialize","ModelDerivedCommand","updateShadows","updateBackFaceCulling","updateCullFace","updateDebugShowBoundingVolume","is2D","derivedCommand2D","derivedCommand","drawCommand","derivedCommands","push","deriveTranslucentCommand","deriveSkipLodBackfaceCommand","deriveSkipLodStencilCommand","deriveSilhouetteModelCommand","deriveSilhouetteColorCommand","deriveEdgeCommand","Object","defineProperties","prototype","get","primitiveType","set","value","transform","boundingSphere","backFaceCulling","cullFace","updateModelMatrix2D","frameState","sign","PI","mapProjection","ellipsoid","maximumRadius","castShadows","receiveShadows","i","length","fromCache","pushCommands","result","use2D","shouldUse2DCommands","derive2DCommands","styleCommandsNeeded","ALL_OPAQUE","pushCommand","ALL_TRANSLUCENT","tileset","tile","content","hasMixedContent","_finalResolution","_backfaceCommands","updateSkipLodStencilCommand","pushSilhouetteCommands","pushEdgeCommands","commandList","mode","SCENE2D","_projectTo2D","sceneGraph","_boundingSphere2D","left","center","y","radius","right","idl2D","derive2DCommand","command2D","shallowClone","rs","depthMask","blending","ALPHA_BLEND","stencilReference","_silhouetteId","silhouetteModelCommand","stencilTest","frontFunction","ALWAYS","backFunction","reference","mask","frontOperation","fail","KEEP","zFail","zPass","REPLACE","backOperation","isInvisible","colorMask","red","green","blue","alpha","silhouetteColorCommand","silhouetteTranslucent","silhouetteColor","NOTEQUAL","uniformMap","model_silhouettePass","edgeCommand","vertexArray","count","indexCount","shaderProgram","u_isEdgePass","stencilDerivedComand","stencilCommand","selectionDepth","_selectionDepth","lastSelectionDepth","getLastSelectionDepth","skipLodStencilReference","getStencilReference","SKIP_LOD_MASK","SKIP_LOD_BIT_SHIFT","CESIUM_3D_TILE_MASK","backfaceCommand","FRONT","polygonOffset","factor","units","u_polygonOffset","GREATER_OR_EQUAL","stencilMask"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 18532, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelDrawCommands.js"],"sourcesContent":["import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport clone from \"../../Core/clone.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport DrawCommand from \"../../Renderer/DrawCommand.js\";\nimport RenderState from \"../../Renderer/RenderState.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ShadowMode from \"../ShadowMode.js\";\nimport ClassificationModelDrawCommand from \"./ClassificationModelDrawCommand.js\";\nimport ModelDrawCommand from \"./ModelDrawCommand.js\";\nimport VertexArray from \"../../Renderer/VertexArray.js\";\nimport ModelVS from \"../../Shaders/Model/ModelVS.js\";\nimport ModelFS from \"../../Shaders/Model/ModelFS.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\n\n/**\n * Internal functions to build draw commands for models.\n *\n * (The core of these functions was taken from `buildDrawCommand.jsÂ´,\n * as of commit hash 7b93161da1cc03bdc796b204e7aa51fb7acebf04)\n *\n * @private\n */\nfunction ModelDrawCommands() {}\n\n/**\n * Builds the {@link ModelDrawCommand} for a {@link ModelRuntimePrimitive}\n * using its render resources. If the model classifies another asset, it\n * builds a {@link ClassificationModelDrawCommand} instead.\n *\n * @param {PrimitiveRenderResources} primitiveRenderResources The render resources for a primitive.\n * @param {FrameState} frameState The frame state for creating GPU resources.\n * @returns {ModelDrawCommand|ClassificationModelDrawCommand} The generated ModelDrawCommand or ClassificationModelDrawCommand.\n *\n * @private\n */\nModelDrawCommands.buildModelDrawCommand = function (\n  primitiveRenderResources,\n  frameState,\n) {\n  const shaderBuilder = primitiveRenderResources.shaderBuilder;\n  const shaderProgram = createShaderProgram(\n    primitiveRenderResources,\n    shaderBuilder,\n    frameState,\n  );\n\n  const command = buildDrawCommandForModel(\n    primitiveRenderResources,\n    shaderProgram,\n    frameState,\n  );\n\n  const model = primitiveRenderResources.model;\n  const hasClassification = defined(model.classificationType);\n  if (hasClassification) {\n    return new ClassificationModelDrawCommand({\n      primitiveRenderResources: primitiveRenderResources,\n      command: command,\n    });\n  }\n\n  return new ModelDrawCommand({\n    primitiveRenderResources: primitiveRenderResources,\n    command: command,\n  });\n};\n\n/**\n * @private\n */\nfunction createShaderProgram(\n  primitiveRenderResources,\n  shaderBuilder,\n  frameState,\n) {\n  shaderBuilder.addVertexLines(ModelVS);\n  shaderBuilder.addFragmentLines(ModelFS);\n\n  const model = primitiveRenderResources.model;\n  const shaderProgram = shaderBuilder.buildShaderProgram(frameState.context);\n  model._pipelineResources.push(shaderProgram);\n  return shaderProgram;\n}\n\n/**\n * Builds the {@link DrawCommand} that serves as the basis for either creating\n * a {@link ModelDrawCommand} or a {@link ModelRuntimePrimitive}\n *\n * @param {PrimitiveRenderResources} primitiveRenderResources The render resources for a primitive.\n * @param {ShaderProgram} shaderProgram The shader program\n * @param {FrameState} frameState The frame state for creating GPU resources.\n *\n * @returns {DrawCommand} The generated DrawCommand, to be passed to\n * the ModelDrawCommand or ClassificationModelDrawCommand\n *\n * @private\n */\nfunction buildDrawCommandForModel(\n  primitiveRenderResources,\n  shaderProgram,\n  frameState,\n) {\n  const indexBuffer = getIndexBuffer(primitiveRenderResources);\n\n  const vertexArray = new VertexArray({\n    context: frameState.context,\n    indexBuffer: indexBuffer,\n    attributes: primitiveRenderResources.attributes,\n  });\n\n  const model = primitiveRenderResources.model;\n  model._pipelineResources.push(vertexArray);\n\n  const pass = primitiveRenderResources.alphaOptions.pass;\n  const sceneGraph = model.sceneGraph;\n\n  const is3D = frameState.mode === SceneMode.SCENE3D;\n  let modelMatrix, boundingSphere;\n\n  if (!is3D && !frameState.scene3DOnly && model._projectTo2D) {\n    modelMatrix = Matrix4.multiplyTransformation(\n      sceneGraph._computedModelMatrix,\n      primitiveRenderResources.runtimeNode.computedTransform,\n      new Matrix4(),\n    );\n\n    const runtimePrimitive = primitiveRenderResources.runtimePrimitive;\n    boundingSphere = runtimePrimitive.boundingSphere2D;\n  } else {\n    const computedModelMatrix = is3D\n      ? sceneGraph._computedModelMatrix\n      : sceneGraph._computedModelMatrix2D;\n\n    modelMatrix = Matrix4.multiplyTransformation(\n      computedModelMatrix,\n      primitiveRenderResources.runtimeNode.computedTransform,\n      new Matrix4(),\n    );\n\n    boundingSphere = BoundingSphere.transform(\n      primitiveRenderResources.boundingSphere,\n      modelMatrix,\n    );\n  }\n\n  // Initialize render state with default values\n  let renderState = clone(\n    RenderState.fromCache(primitiveRenderResources.renderStateOptions),\n    true,\n  );\n\n  renderState.cull.face = ModelUtility.getCullFace(\n    modelMatrix,\n    primitiveRenderResources.primitiveType,\n  );\n  renderState = RenderState.fromCache(renderState);\n\n  const hasClassification = defined(model.classificationType);\n  const castShadows = hasClassification\n    ? false\n    : ShadowMode.castShadows(model.shadows);\n  const receiveShadows = hasClassification\n    ? false\n    : ShadowMode.receiveShadows(model.shadows);\n  // Pick IDs are only added to specific draw commands for classification.\n  // This behavior is handled by ClassificationModelDrawCommand.\n  const pickId = hasClassification\n    ? undefined\n    : primitiveRenderResources.pickId;\n\n  const command = new DrawCommand({\n    boundingVolume: boundingSphere,\n    modelMatrix: modelMatrix,\n    uniformMap: primitiveRenderResources.uniformMap,\n    renderState: renderState,\n    vertexArray: vertexArray,\n    shaderProgram: shaderProgram,\n    cull: model.cull,\n    pass: pass,\n    count: primitiveRenderResources.count,\n    owner: model,\n    pickId: pickId,\n    pickMetadataAllowed: true,\n    instanceCount: primitiveRenderResources.instanceCount,\n    primitiveType: primitiveRenderResources.primitiveType,\n    debugShowBoundingVolume: model.debugShowBoundingVolume,\n    castShadows: castShadows,\n    receiveShadows: receiveShadows,\n  });\n  return command;\n}\n\n/**\n * @private\n */\nfunction getIndexBuffer(primitiveRenderResources) {\n  const wireframeIndexBuffer = primitiveRenderResources.wireframeIndexBuffer;\n  if (defined(wireframeIndexBuffer)) {\n    return wireframeIndexBuffer;\n  }\n\n  const indices = primitiveRenderResources.indices;\n  if (!defined(indices)) {\n    return undefined;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(indices.buffer)) {\n    throw new DeveloperError(\"Indices must be provided as a Buffer\");\n  }\n  //>>includeEnd('debug');\n\n  return indices.buffer;\n}\n\nexport default ModelDrawCommands;\n"],"names":["ModelDrawCommands","buildModelDrawCommand","primitiveRenderResources","frameState","shaderBuilder","shaderProgram","createShaderProgram","command","buildDrawCommandForModel","model","hasClassification","classificationType","addVertexLines","addFragmentLines","buildShaderProgram","context","_pipelineResources","push","indexBuffer","getIndexBuffer","vertexArray","attributes","pass","alphaOptions","sceneGraph","is3D","mode","SCENE3D","modelMatrix","boundingSphere","scene3DOnly","_projectTo2D","multiplyTransformation","_computedModelMatrix","runtimeNode","computedTransform","runtimePrimitive","boundingSphere2D","computedModelMatrix","_computedModelMatrix2D","transform","renderState","fromCache","renderStateOptions","cull","face","getCullFace","primitiveType","castShadows","shadows","receiveShadows","pickId","undefined","boundingVolume","uniformMap","count","owner","pickMetadataAllowed","instanceCount","debugShowBoundingVolume","wireframeIndexBuffer","indices","buffer"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 18699, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelSceneGraph.js"],"sourcesContent":["import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport SplitDirection from \"../SplitDirection.js\";\nimport TilesetPipelineStage from \"./TilesetPipelineStage.js\";\nimport AtmospherePipelineStage from \"./AtmospherePipelineStage.js\";\nimport ImageBasedLightingPipelineStage from \"./ImageBasedLightingPipelineStage.js\";\nimport ModelArticulation from \"./ModelArticulation.js\";\nimport ModelColorPipelineStage from \"./ModelColorPipelineStage.js\";\nimport ModelClippingPlanesPipelineStage from \"./ModelClippingPlanesPipelineStage.js\";\nimport ModelClippingPolygonsPipelineStage from \"./ModelClippingPolygonsPipelineStage.js\";\nimport ModelNode from \"./ModelNode.js\";\nimport ModelRuntimeNode from \"./ModelRuntimeNode.js\";\nimport ModelRuntimePrimitive from \"./ModelRuntimePrimitive.js\";\nimport ModelSkin from \"./ModelSkin.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport ModelRenderResources from \"./ModelRenderResources.js\";\nimport ModelSilhouettePipelineStage from \"./ModelSilhouettePipelineStage.js\";\nimport ModelSplitterPipelineStage from \"./ModelSplitterPipelineStage.js\";\nimport ModelType from \"./ModelType.js\";\nimport NodeRenderResources from \"./NodeRenderResources.js\";\nimport PrimitiveRenderResources from \"./PrimitiveRenderResources.js\";\nimport ModelDrawCommands from \"./ModelDrawCommands.js\";\nimport addAllToArray from \"../../Core/addAllToArray.js\";\n\n/**\n * An in memory representation of the scene graph for a {@link Model}\n *\n * @param {object} options An object containing the following options\n * @param {Model} options.model The model this scene graph belongs to\n * @param {ModelComponents} options.modelComponents The model components describing the model\n *\n * @alias ModelSceneGraph\n * @constructor\n *\n * @private\n */\nfunction ModelSceneGraph(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const components = options.modelComponents;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.model\", options.model);\n  Check.typeOf.object(\"options.modelComponents\", components);\n  //>>includeEnd('debug');\n\n  /**\n   * A reference to the {@link Model} that owns this scene graph.\n   *\n   * @type {Model}\n   * @readonly\n   *\n   * @private\n   */\n  this._model = options.model;\n\n  /**\n   * The model components that represent the contents of the 3D model file.\n   *\n   * @type {ModelComponents}\n   * @readonly\n   *\n   * @private\n   */\n  this._components = components;\n\n  /**\n   * Pipeline stages to apply across the model.\n   *\n   * @type {object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._pipelineStages = [];\n\n  /**\n   * Update stages to apply across the model.\n   *\n   * @type {object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._updateStages = [];\n\n  /**\n   * The runtime nodes that make up the scene graph\n   *\n   * @type {ModelRuntimeNode[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._runtimeNodes = [];\n\n  /**\n   * The indices of the root nodes in the runtime nodes array.\n   *\n   * @type {number[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._rootNodes = [];\n\n  /**\n   * The indices of the skinned nodes in the runtime nodes array. These refer\n   * to the nodes that will be manipulated by their skin, as opposed to the nodes\n   * acting as joints for the skin.\n   *\n   * @type {number[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._skinnedNodes = [];\n\n  /**\n   * The runtime skins that affect nodes in the scene graph.\n   *\n   * @type {ModelSkin[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._runtimeSkins = [];\n\n  /**\n   * Pipeline stages to apply to this model. This\n   * is an array of classes, each with a static method called\n   * <code>process()</code>\n   *\n   * @type {object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.modelPipelineStages = [];\n\n  // The scene graph's bounding sphere is model space, so that\n  // the model's bounding sphere can be recomputed when given a\n  // new model matrix.\n  this._boundingSphere = undefined;\n\n  // The 2D bounding sphere is in world space. This is checked\n  // by the draw commands to see if the model is over the IDL,\n  // and if so, renders the primitives using extra commands.\n  this._boundingSphere2D = undefined;\n\n  this._computedModelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._computedModelMatrix2D = Matrix4.clone(Matrix4.IDENTITY);\n\n  this._axisCorrectionMatrix = ModelUtility.getAxisCorrectionMatrix(\n    components.upAxis,\n    components.forwardAxis,\n    new Matrix4(),\n  );\n\n  // Store articulations from the AGI_articulations extension\n  // by name in a dictionary for easy retrieval.\n  this._runtimeArticulations = {};\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelSceneGraph.prototype, {\n  /**\n   * The model components this scene graph represents.\n   *\n   * @type {ModelComponents}\n   * @readonly\n   *\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n\n  /**\n   * The axis-corrected model matrix.\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  computedModelMatrix: {\n    get: function () {\n      return this._computedModelMatrix;\n    },\n  },\n\n  /**\n   * A matrix to correct from y-up in some model formats (e.g. glTF) to the\n   * z-up coordinate system Cesium uses.\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  axisCorrectionMatrix: {\n    get: function () {\n      return this._axisCorrectionMatrix;\n    },\n  },\n\n  /**\n   * The bounding sphere containing all the primitives in the scene graph\n   * in model space.\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   *\n   * @private\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n});\n\nfunction initialize(sceneGraph) {\n  const components = sceneGraph._components;\n  const scene = components.scene;\n  const model = sceneGraph._model;\n\n  // If the model has a height reference that modifies the model matrix,\n  // it will be accounted for in updateModelMatrix.\n  const modelMatrix = model.modelMatrix;\n  computeModelMatrix(sceneGraph, modelMatrix);\n\n  const articulations = components.articulations;\n  const articulationsLength = articulations.length;\n\n  const runtimeArticulations = sceneGraph._runtimeArticulations;\n  for (let i = 0; i < articulationsLength; i++) {\n    const articulation = articulations[i];\n    const runtimeArticulation = new ModelArticulation({\n      articulation: articulation,\n      sceneGraph: sceneGraph,\n    });\n\n    const name = runtimeArticulation.name;\n    runtimeArticulations[name] = runtimeArticulation;\n  }\n\n  const nodes = components.nodes;\n  const nodesLength = nodes.length;\n\n  // Initialize this array to be the same size as the nodes array in\n  // the model file. This is so the node indices remain the same. However,\n  // only nodes reachable from the scene's root node will be populated, the\n  // rest will be undefined\n  sceneGraph._runtimeNodes = new Array(nodesLength);\n\n  const rootNodes = scene.nodes;\n  const rootNodesLength = rootNodes.length;\n  const transformToRoot = Matrix4.IDENTITY;\n  for (let i = 0; i < rootNodesLength; i++) {\n    const rootNode = scene.nodes[i];\n\n    const rootNodeIndex = traverseAndCreateSceneGraph(\n      sceneGraph,\n      rootNode,\n      transformToRoot,\n    );\n\n    sceneGraph._rootNodes.push(rootNodeIndex);\n  }\n\n  // Handle skins after all runtime nodes are created\n  const skins = components.skins;\n  const runtimeSkins = sceneGraph._runtimeSkins;\n\n  const skinsLength = skins.length;\n  for (let i = 0; i < skinsLength; i++) {\n    const skin = skins[i];\n    runtimeSkins.push(\n      new ModelSkin({\n        skin: skin,\n        sceneGraph: sceneGraph,\n      }),\n    );\n  }\n\n  const skinnedNodes = sceneGraph._skinnedNodes;\n  const skinnedNodesLength = skinnedNodes.length;\n  for (let i = 0; i < skinnedNodesLength; i++) {\n    const skinnedNodeIndex = skinnedNodes[i];\n    const skinnedNode = sceneGraph._runtimeNodes[skinnedNodeIndex];\n\n    // Use the index of the skin in the model components to find\n    // the corresponding runtime skin.\n    const skin = nodes[skinnedNodeIndex].skin;\n    const skinIndex = skin.index;\n\n    skinnedNode._runtimeSkin = runtimeSkins[skinIndex];\n    skinnedNode.updateJointMatrices();\n  }\n\n  // Ensure articulations are applied with their initial values to their target nodes.\n  sceneGraph.applyArticulations();\n}\n\nfunction computeModelMatrix(sceneGraph, modelMatrix) {\n  const components = sceneGraph._components;\n  const model = sceneGraph._model;\n\n  sceneGraph._computedModelMatrix = Matrix4.multiplyTransformation(\n    modelMatrix,\n    components.transform,\n    sceneGraph._computedModelMatrix,\n  );\n\n  sceneGraph._computedModelMatrix = Matrix4.multiplyTransformation(\n    sceneGraph._computedModelMatrix,\n    sceneGraph._axisCorrectionMatrix,\n    sceneGraph._computedModelMatrix,\n  );\n\n  sceneGraph._computedModelMatrix = Matrix4.multiplyByUniformScale(\n    sceneGraph._computedModelMatrix,\n    model.computedScale,\n    sceneGraph._computedModelMatrix,\n  );\n}\n\nconst scratchComputedTranslation = new Cartesian3();\n\nfunction computeModelMatrix2D(sceneGraph, frameState) {\n  const computedModelMatrix = sceneGraph._computedModelMatrix;\n  const translation = Matrix4.getTranslation(\n    computedModelMatrix,\n    scratchComputedTranslation,\n  );\n\n  if (!Cartesian3.equals(translation, Cartesian3.ZERO)) {\n    sceneGraph._computedModelMatrix2D = Transforms.basisTo2D(\n      frameState.mapProjection,\n      computedModelMatrix,\n      sceneGraph._computedModelMatrix2D,\n    );\n  } else {\n    const center = sceneGraph.boundingSphere.center;\n    const to2D = Transforms.ellipsoidTo2DModelMatrix(\n      frameState.mapProjection,\n      center,\n      sceneGraph._computedModelMatrix2D,\n    );\n    sceneGraph._computedModelMatrix2D = Matrix4.multiply(\n      to2D,\n      computedModelMatrix,\n      sceneGraph._computedModelMatrix2D,\n    );\n  }\n\n  sceneGraph._boundingSphere2D = BoundingSphere.transform(\n    sceneGraph._boundingSphere,\n    sceneGraph._computedModelMatrix2D,\n    sceneGraph._boundingSphere2D,\n  );\n}\n\n/**\n * Recursively traverse through the nodes in the scene graph to create\n * their runtime versions, using a post-order depth-first traversal.\n *\n * @param {ModelSceneGraph} sceneGraph The scene graph\n * @param {ModelComponents.Node} node The current node\n * @param {Matrix4} transformToRoot The transforms of this node's ancestors.\n * @returns {number} The index of this node in the runtimeNodes array.\n *\n * @private\n */\nfunction traverseAndCreateSceneGraph(sceneGraph, node, transformToRoot) {\n  // The indices of the children of this node in the runtimeNodes array.\n  const childrenIndices = [];\n  const transform = ModelUtility.getNodeTransform(node);\n\n  // Traverse through scene graph.\n  const childrenLength = node.children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const childNode = node.children[i];\n    const childNodeTransformToRoot = Matrix4.multiplyTransformation(\n      transformToRoot,\n      transform,\n      new Matrix4(),\n    );\n\n    const childIndex = traverseAndCreateSceneGraph(\n      sceneGraph,\n      childNode,\n      childNodeTransformToRoot,\n    );\n    childrenIndices.push(childIndex);\n  }\n\n  // Process node and mesh primitives.\n  const runtimeNode = new ModelRuntimeNode({\n    node: node,\n    transform: transform,\n    transformToRoot: transformToRoot,\n    children: childrenIndices,\n    sceneGraph: sceneGraph,\n  });\n\n  const primitivesLength = node.primitives.length;\n  for (let i = 0; i < primitivesLength; i++) {\n    runtimeNode.runtimePrimitives.push(\n      new ModelRuntimePrimitive({\n        primitive: node.primitives[i],\n        node: node,\n        model: sceneGraph._model,\n      }),\n    );\n  }\n\n  const index = node.index;\n  sceneGraph._runtimeNodes[index] = runtimeNode;\n  if (defined(node.skin)) {\n    sceneGraph._skinnedNodes.push(index);\n  }\n\n  // Create and store the public version of the runtime node.\n  const name = node.name;\n  if (defined(name)) {\n    const model = sceneGraph._model;\n    const publicNode = new ModelNode(model, runtimeNode);\n    model._nodesByName[name] = publicNode;\n  }\n\n  return index;\n}\n\nconst scratchModelPositionMin = new Cartesian3();\nconst scratchModelPositionMax = new Cartesian3();\nconst scratchPrimitivePositionMin = new Cartesian3();\nconst scratchPrimitivePositionMax = new Cartesian3();\n\n/**\n * Generates the {@link ModelDrawCommand} for each primitive in the model.\n * If the model is used for classification, a {@link ClassificationModelDrawCommand}\n * is generated for each primitive instead.\n *\n * @param {FrameState} frameState The current frame state. This is needed to\n * allocate GPU resources as needed.\n *\n * @private\n */\nModelSceneGraph.prototype.buildDrawCommands = function (frameState) {\n  const modelRenderResources = this.buildRenderResources(frameState);\n  this.computeBoundingVolumes(modelRenderResources);\n  this.createDrawCommands(modelRenderResources, frameState);\n};\n\n/**\n * Generates the {@link ModelRenderResources} for the model.\n *\n * This will traverse the model, nodes and primitives of the scene graph,\n * and perform the following tasks:\n *\n * - configure the pipeline stages by calling `configurePipeline`,\n *   `runtimeNode.configurePipeline`, and `runtimePrimitive.configurePipeline`\n * - create the `ModelRenderResources`, `NodeRenderResources`, and\n *   `PrimitiveRenderResources`\n * - Process the render resources with the respective pipelines\n *\n * @param {FrameState} frameState The current frame state. This is needed to\n * allocate GPU resources as needed.\n * @returns {ModelRenderResources} The model render resources\n *\n * @private\n */\nModelSceneGraph.prototype.buildRenderResources = function (frameState) {\n  const model = this._model;\n  const modelRenderResources = new ModelRenderResources(model);\n\n  // Reset the memory counts before running the pipeline\n  model.statistics.clear();\n\n  this.configurePipeline(frameState);\n  const modelPipelineStages = this.modelPipelineStages;\n\n  for (let i = 0; i < modelPipelineStages.length; i++) {\n    const modelPipelineStage = modelPipelineStages[i];\n    modelPipelineStage.process(modelRenderResources, model, frameState);\n  }\n\n  for (let i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    // If a node in the model was unreachable from the scene graph, there will\n    // be no corresponding runtime node and therefore should be skipped.\n    if (!defined(runtimeNode)) {\n      continue;\n    }\n\n    runtimeNode.configurePipeline();\n    const nodePipelineStages = runtimeNode.pipelineStages;\n\n    const nodeRenderResources = new NodeRenderResources(\n      modelRenderResources,\n      runtimeNode,\n    );\n    modelRenderResources.nodeRenderResources[i] = nodeRenderResources;\n\n    for (let j = 0; j < nodePipelineStages.length; j++) {\n      const nodePipelineStage = nodePipelineStages[j];\n\n      nodePipelineStage.process(\n        nodeRenderResources,\n        runtimeNode.node,\n        frameState,\n      );\n    }\n\n    for (let j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n\n      runtimePrimitive.configurePipeline(frameState);\n      const primitivePipelineStages = runtimePrimitive.pipelineStages;\n\n      const primitiveRenderResources = new PrimitiveRenderResources(\n        nodeRenderResources,\n        runtimePrimitive,\n      );\n      nodeRenderResources.primitiveRenderResources[j] =\n        primitiveRenderResources;\n\n      for (let k = 0; k < primitivePipelineStages.length; k++) {\n        const primitivePipelineStage = primitivePipelineStages[k];\n        primitivePipelineStage.process(\n          primitiveRenderResources,\n          runtimePrimitive.primitive,\n          frameState,\n        );\n      }\n    }\n  }\n  return modelRenderResources;\n};\n\n/**\n * Computes the bounding volumes for the scene graph and the model.\n *\n * This will traverse the model, nodes and primitives of the scene graph,\n * and compute the bounding volumes. Specifically, it will compute\n *\n * - this._boundingSphere\n * - model._boundingSphere\n *\n * With the latter being modified as of\n *\n * - model._initialRadius = model._boundingSphere.radius;\n * - model._boundingSphere.radius *= model._clampedScale;\n *\n * NOTE: This contains some bugs. See https://github.com/CesiumGS/cesium/issues/12108\n *\n * @param {ModelRenderResources} modelRenderResources The model render resources\n *\n * @private\n */\nModelSceneGraph.prototype.computeBoundingVolumes = function (\n  modelRenderResources,\n) {\n  const model = this._model;\n\n  const modelPositionMin = Cartesian3.fromElements(\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    scratchModelPositionMin,\n  );\n  const modelPositionMax = Cartesian3.fromElements(\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    scratchModelPositionMax,\n  );\n\n  for (let i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    // If a node in the model was unreachable from the scene graph, there will\n    // be no corresponding runtime node and therefore should be skipped.\n    if (!defined(runtimeNode)) {\n      continue;\n    }\n\n    const nodeRenderResources = modelRenderResources.nodeRenderResources[i];\n    const nodeTransform = runtimeNode.computedTransform;\n    for (let j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n\n      const primitiveRenderResources =\n        nodeRenderResources.primitiveRenderResources[j];\n\n      runtimePrimitive.boundingSphere = BoundingSphere.clone(\n        primitiveRenderResources.boundingSphere,\n        new BoundingSphere(),\n      );\n\n      const primitivePositionMin = Matrix4.multiplyByPoint(\n        nodeTransform,\n        primitiveRenderResources.positionMin,\n        scratchPrimitivePositionMin,\n      );\n      const primitivePositionMax = Matrix4.multiplyByPoint(\n        nodeTransform,\n        primitiveRenderResources.positionMax,\n        scratchPrimitivePositionMax,\n      );\n\n      Cartesian3.minimumByComponent(\n        modelPositionMin,\n        primitivePositionMin,\n        modelPositionMin,\n      );\n      Cartesian3.maximumByComponent(\n        modelPositionMax,\n        primitivePositionMax,\n        modelPositionMax,\n      );\n    }\n  }\n\n  this._boundingSphere = BoundingSphere.fromCornerPoints(\n    modelPositionMin,\n    modelPositionMax,\n    new BoundingSphere(),\n  );\n\n  this._boundingSphere = BoundingSphere.transformWithoutScale(\n    this._boundingSphere,\n    this._axisCorrectionMatrix,\n    this._boundingSphere,\n  );\n\n  this._boundingSphere = BoundingSphere.transform(\n    this._boundingSphere,\n    this._components.transform,\n    this._boundingSphere,\n  );\n\n  model._boundingSphere = BoundingSphere.transform(\n    this._boundingSphere,\n    model.modelMatrix,\n    model._boundingSphere,\n  );\n\n  model._initialRadius = model._boundingSphere.radius;\n  model._boundingSphere.radius *= model._clampedScale;\n};\n\n/**\n * Creates the draw commands for the primitives in the scene graph.\n *\n * This will traverse the model, nodes and primitives of the scene graph,\n * and create the respective draw commands for the primitives, storing\n * them as the `runtimePrimitive.drawCommand`, respectively.\n *\n * @param {ModelRenderResources} modelRenderResources The model render resources\n *\n * @private\n */\nModelSceneGraph.prototype.createDrawCommands = function (\n  modelRenderResources,\n  frameState,\n) {\n  for (let i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    // If a node in the model was unreachable from the scene graph, there will\n    // be no corresponding runtime node and therefore should be skipped.\n    if (!defined(runtimeNode)) {\n      continue;\n    }\n\n    const nodeRenderResources = modelRenderResources.nodeRenderResources[i];\n\n    for (let j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n\n      const primitiveRenderResources =\n        nodeRenderResources.primitiveRenderResources[j];\n\n      const drawCommand = ModelDrawCommands.buildModelDrawCommand(\n        primitiveRenderResources,\n        frameState,\n      );\n      runtimePrimitive.drawCommand = drawCommand;\n    }\n  }\n};\n\n/**\n * Configure the model pipeline stages. If the pipeline needs to be re-run, call\n * this method again to ensure the correct sequence of pipeline stages are\n * used.\n *\n * @param {FrameState} frameState\n * @private\n */\nModelSceneGraph.prototype.configurePipeline = function (frameState) {\n  const modelPipelineStages = this.modelPipelineStages;\n  modelPipelineStages.length = 0;\n\n  const model = this._model;\n  const fogRenderable = frameState.fog.enabled && frameState.fog.renderable;\n\n  if (defined(model.color)) {\n    modelPipelineStages.push(ModelColorPipelineStage);\n  }\n\n  // Skip these pipeline stages for classification models.\n  if (defined(model.classificationType)) {\n    return;\n  }\n\n  if (model.imageBasedLighting.enabled) {\n    modelPipelineStages.push(ImageBasedLightingPipelineStage);\n  }\n\n  if (model.isClippingEnabled()) {\n    modelPipelineStages.push(ModelClippingPlanesPipelineStage);\n  }\n\n  if (model.isClippingPolygonsEnabled()) {\n    modelPipelineStages.push(ModelClippingPolygonsPipelineStage);\n  }\n\n  if (model.hasSilhouette(frameState)) {\n    modelPipelineStages.push(ModelSilhouettePipelineStage);\n  }\n\n  if (\n    defined(model.splitDirection) &&\n    model.splitDirection !== SplitDirection.NONE\n  ) {\n    modelPipelineStages.push(ModelSplitterPipelineStage);\n  }\n\n  if (ModelType.is3DTiles(model.type)) {\n    modelPipelineStages.push(TilesetPipelineStage);\n  }\n\n  if (fogRenderable) {\n    modelPipelineStages.push(AtmospherePipelineStage);\n  }\n};\n\nModelSceneGraph.prototype.update = function (frameState, updateForAnimations) {\n  let i, j, k;\n\n  for (i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    // If a node in the model was unreachable from the scene graph, there will\n    // be no corresponding runtime node and therefore should be skipped.\n    if (!defined(runtimeNode)) {\n      continue;\n    }\n\n    for (j = 0; j < runtimeNode.updateStages.length; j++) {\n      const nodeUpdateStage = runtimeNode.updateStages[j];\n      nodeUpdateStage.update(runtimeNode, this, frameState);\n    }\n\n    const disableAnimations =\n      frameState.mode !== SceneMode.SCENE3D && this._model._projectTo2D;\n    if (updateForAnimations && !disableAnimations) {\n      this.updateJointMatrices();\n    }\n\n    for (j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n      for (k = 0; k < runtimePrimitive.updateStages.length; k++) {\n        const stage = runtimePrimitive.updateStages[k];\n        stage.update(runtimePrimitive, this);\n      }\n    }\n  }\n};\n\nModelSceneGraph.prototype.updateModelMatrix = function (\n  modelMatrix,\n  frameState,\n) {\n  computeModelMatrix(this, modelMatrix);\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    computeModelMatrix2D(this, frameState);\n  }\n\n  // Mark all root nodes as dirty. Any and all children will be\n  // affected recursively in the update stage.\n  const rootNodes = this._rootNodes;\n  for (let i = 0; i < rootNodes.length; i++) {\n    const node = this._runtimeNodes[rootNodes[i]];\n    node._transformDirty = true;\n  }\n};\n\n/**\n * Updates the joint matrices for the skins and nodes of the model.\n *\n * @private\n */\nModelSceneGraph.prototype.updateJointMatrices = function () {\n  const skinnedNodes = this._skinnedNodes;\n  const length = skinnedNodes.length;\n\n  for (let i = 0; i < length; i++) {\n    const nodeIndex = skinnedNodes[i];\n    const runtimeNode = this._runtimeNodes[nodeIndex];\n    runtimeNode.updateJointMatrices();\n  }\n};\n\n/**\n * A callback to be applied once at each runtime primitive in the\n * scene graph\n * @callback traverseSceneGraphCallback\n *\n * @param {ModelRuntimePrimitive} runtimePrimitive The runtime primitive for the current step of the traversal\n * @param {object} [options] A dictionary of additional options to be passed to the callback, or undefined if the callback does not need any additional information.\n *\n * @private\n */\n\n/**\n * Recursively traverse through the runtime nodes in the scene graph\n * using a post-order depth-first traversal to perform a callback on\n * their runtime primitives.\n *\n * @param {ModelSceneGraph} sceneGraph The scene graph.\n * @param {ModelRuntimeNode} runtimeNode The current runtime node.\n * @param {boolean} visibleNodesOnly Whether to only traverse nodes that are visible.\n * @param {traverseSceneGraphCallback} callback The callback to perform on the runtime primitives of the node.\n * @param {object} [callbackOptions] A dictionary of additional options to be passed to the callback, if needed.\n *\n * @private\n */\nfunction traverseSceneGraph(\n  sceneGraph,\n  runtimeNode,\n  visibleNodesOnly,\n  callback,\n  callbackOptions,\n) {\n  if (visibleNodesOnly && !runtimeNode.show) {\n    return;\n  }\n\n  const childrenLength = runtimeNode.children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const childRuntimeNode = runtimeNode.getChild(i);\n    traverseSceneGraph(\n      sceneGraph,\n      childRuntimeNode,\n      visibleNodesOnly,\n      callback,\n      callbackOptions,\n    );\n  }\n\n  const runtimePrimitives = runtimeNode.runtimePrimitives;\n  const runtimePrimitivesLength = runtimePrimitives.length;\n  for (let j = 0; j < runtimePrimitivesLength; j++) {\n    const runtimePrimitive = runtimePrimitives[j];\n    callback(runtimePrimitive, callbackOptions);\n  }\n}\n\nfunction forEachRuntimePrimitive(\n  sceneGraph,\n  visibleNodesOnly,\n  callback,\n  callbackOptions,\n) {\n  const rootNodes = sceneGraph._rootNodes;\n  const rootNodesLength = rootNodes.length;\n  for (let i = 0; i < rootNodesLength; i++) {\n    const rootNodeIndex = rootNodes[i];\n    const runtimeNode = sceneGraph._runtimeNodes[rootNodeIndex];\n    traverseSceneGraph(\n      sceneGraph,\n      runtimeNode,\n      visibleNodesOnly,\n      callback,\n      callbackOptions,\n    );\n  }\n}\n\nconst scratchBackFaceCullingOptions = {\n  backFaceCulling: undefined,\n};\n\n/**\n * Traverses through all draw commands and changes the back-face culling setting.\n *\n * @param {boolean} backFaceCulling The new value for the back-face culling setting.\n *\n * @private\n */\nModelSceneGraph.prototype.updateBackFaceCulling = function (backFaceCulling) {\n  const backFaceCullingOptions = scratchBackFaceCullingOptions;\n  backFaceCullingOptions.backFaceCulling = backFaceCulling;\n  forEachRuntimePrimitive(\n    this,\n    false,\n    updatePrimitiveBackFaceCulling,\n    backFaceCullingOptions,\n  );\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction updatePrimitiveBackFaceCulling(runtimePrimitive, options) {\n  const drawCommand = runtimePrimitive.drawCommand;\n  drawCommand.backFaceCulling = options.backFaceCulling;\n}\n\nconst scratchShadowOptions = {\n  shadowMode: undefined,\n};\n\n/**\n * Traverses through all draw commands and changes the shadow settings.\n *\n * @param {ShadowMode} shadowMode The new shadow settings.\n *\n * @private\n */\nModelSceneGraph.prototype.updateShadows = function (shadowMode) {\n  const shadowOptions = scratchShadowOptions;\n  shadowOptions.shadowMode = shadowMode;\n  forEachRuntimePrimitive(this, false, updatePrimitiveShadows, shadowOptions);\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction updatePrimitiveShadows(runtimePrimitive, options) {\n  const drawCommand = runtimePrimitive.drawCommand;\n  drawCommand.shadows = options.shadowMode;\n}\n\nconst scratchShowBoundingVolumeOptions = {\n  debugShowBoundingVolume: undefined,\n};\n\n/**\n * Traverses through all draw commands and changes whether to show the debug bounding volume.\n *\n * @param {boolean} debugShowBoundingVolume The new value for showing the debug bounding volume.\n *\n * @private\n */\nModelSceneGraph.prototype.updateShowBoundingVolume = function (\n  debugShowBoundingVolume,\n) {\n  const showBoundingVolumeOptions = scratchShowBoundingVolumeOptions;\n  showBoundingVolumeOptions.debugShowBoundingVolume = debugShowBoundingVolume;\n\n  forEachRuntimePrimitive(\n    this,\n    false,\n    updatePrimitiveShowBoundingVolume,\n    showBoundingVolumeOptions,\n  );\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction updatePrimitiveShowBoundingVolume(runtimePrimitive, options) {\n  const drawCommand = runtimePrimitive.drawCommand;\n  drawCommand.debugShowBoundingVolume = options.debugShowBoundingVolume;\n}\n\nconst scratchSilhouetteCommands = [];\nconst scratchEdgeCommands = [];\nconst scratchPushDrawCommandOptions = {\n  frameState: undefined,\n  hasSilhouette: undefined,\n};\n\n/**\n * Traverses through the scene graph and pushes the draw commands associated\n * with each primitive to the frame state's command list.\n *\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nModelSceneGraph.prototype.pushDrawCommands = function (frameState) {\n  // If a model has silhouettes, the commands that draw the silhouettes for\n  // each primitive can only be invoked after the entire model has drawn.\n  // Otherwise, the silhouette may draw on top of the model. This requires\n  // gathering the original commands and the silhouette commands separately.\n  const silhouetteCommands = scratchSilhouetteCommands;\n  silhouetteCommands.length = 0;\n\n  // Gather edge commands for the edge pass\n  const edgeCommands = scratchEdgeCommands;\n  edgeCommands.length = 0;\n\n  // Since this function is called each frame, the options object is\n  // preallocated in a scratch variable\n  const pushDrawCommandOptions = scratchPushDrawCommandOptions;\n  pushDrawCommandOptions.hasSilhouette = this._model.hasSilhouette(frameState);\n  pushDrawCommandOptions.frameState = frameState;\n\n  forEachRuntimePrimitive(\n    this,\n    true,\n    pushPrimitiveDrawCommands,\n    pushDrawCommandOptions,\n  );\n\n  addAllToArray(frameState.commandList, silhouetteCommands);\n  addAllToArray(frameState.commandList, edgeCommands);\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction pushPrimitiveDrawCommands(runtimePrimitive, options) {\n  const frameState = options.frameState;\n  const hasSilhouette = options.hasSilhouette;\n\n  const passes = frameState.passes;\n  const silhouetteCommands = scratchSilhouetteCommands;\n  const edgeCommands = scratchEdgeCommands;\n  const primitiveDrawCommand = runtimePrimitive.drawCommand;\n  primitiveDrawCommand.pushCommands(frameState, frameState.commandList);\n\n  // If a model has silhouettes, the commands that draw the silhouettes for\n  // each primitive can only be invoked after the entire model has drawn.\n  // Otherwise, the silhouette may draw on top of the model. This requires\n  // gathering the original commands and the silhouette commands separately.\n  if (hasSilhouette && !passes.pick) {\n    primitiveDrawCommand.pushSilhouetteCommands(frameState, silhouetteCommands);\n  }\n\n  // Add edge commands to the edge pass\n  if (defined(primitiveDrawCommand.pushEdgeCommands)) {\n    primitiveDrawCommand.pushEdgeCommands(frameState, edgeCommands);\n  }\n}\n\n/**\n * Sets the current value of an articulation stage.\n *\n * @param {string} articulationStageKey The name of the articulation, a space, and the name of the stage.\n * @param {number} value The numeric value of this stage of the articulation.\n *\n * @private\n */\nModelSceneGraph.prototype.setArticulationStage = function (\n  articulationStageKey,\n  value,\n) {\n  const names = articulationStageKey.split(\" \");\n  if (names.length !== 2) {\n    return;\n  }\n\n  const articulationName = names[0];\n  const stageName = names[1];\n\n  const runtimeArticulation = this._runtimeArticulations[articulationName];\n  if (defined(runtimeArticulation)) {\n    runtimeArticulation.setArticulationStage(stageName, value);\n  }\n};\n\n/**\n * Applies any modified articulation stages to the matrix of each node that participates\n * in any articulation.  Note that this will overwrite any nodeTransformations on participating nodes.\n *\n * @private\n */\nModelSceneGraph.prototype.applyArticulations = function () {\n  const runtimeArticulations = this._runtimeArticulations;\n  for (const articulationName in runtimeArticulations) {\n    if (runtimeArticulations.hasOwnProperty(articulationName)) {\n      const articulation = runtimeArticulations[articulationName];\n      articulation.apply();\n    }\n  }\n};\n\nexport default ModelSceneGraph;\n"],"names":["ModelSceneGraph","options","EMPTY_OBJECT","components","modelComponents","typeOf","object","model","_model","_components","_pipelineStages","_updateStages","_runtimeNodes","_rootNodes","_skinnedNodes","_runtimeSkins","modelPipelineStages","_boundingSphere","undefined","_boundingSphere2D","_computedModelMatrix","clone","IDENTITY","_computedModelMatrix2D","_axisCorrectionMatrix","getAxisCorrectionMatrix","upAxis","forwardAxis","_runtimeArticulations","initialize","Object","defineProperties","prototype","get","computedModelMatrix","axisCorrectionMatrix","boundingSphere","sceneGraph","scene","modelMatrix","computeModelMatrix","articulations","articulationsLength","length","runtimeArticulations","i","articulation","runtimeArticulation","name","nodes","nodesLength","Array","rootNodes","rootNodesLength","transformToRoot","rootNode","rootNodeIndex","traverseAndCreateSceneGraph","push","skins","runtimeSkins","skinsLength","skin","skinnedNodes","skinnedNodesLength","skinnedNodeIndex","skinnedNode","skinIndex","index","_runtimeSkin","updateJointMatrices","applyArticulations","multiplyTransformation","transform","multiplyByUniformScale","computedScale","scratchComputedTranslation","computeModelMatrix2D","frameState","translation","getTranslation","equals","ZERO","basisTo2D","mapProjection","center","to2D","ellipsoidTo2DModelMatrix","multiply","node","childrenIndices","getNodeTransform","childrenLength","children","childNode","childNodeTransformToRoot","childIndex","runtimeNode","primitivesLength","primitives","runtimePrimitives","primitive","publicNode","_nodesByName","scratchModelPositionMin","scratchModelPositionMax","scratchPrimitivePositionMin","scratchPrimitivePositionMax","buildDrawCommands","modelRenderResources","buildRenderResources","computeBoundingVolumes","createDrawCommands","statistics","clear","configurePipeline","modelPipelineStage","process","nodePipelineStages","pipelineStages","nodeRenderResources","j","nodePipelineStage","runtimePrimitive","primitivePipelineStages","primitiveRenderResources","k","primitivePipelineStage","modelPositionMin","fromElements","Number","MAX_VALUE","modelPositionMax","nodeTransform","computedTransform","primitivePositionMin","multiplyByPoint","positionMin","primitivePositionMax","positionMax","minimumByComponent","maximumByComponent","fromCornerPoints","transformWithoutScale","_initialRadius","radius","_clampedScale","drawCommand","buildModelDrawCommand","fogRenderable","fog","enabled","renderable","color","classificationType","imageBasedLighting","isClippingEnabled","isClippingPolygonsEnabled","hasSilhouette","splitDirection","NONE","is3DTiles","type","update","updateForAnimations","updateStages","nodeUpdateStage","disableAnimations","mode","SCENE3D","_projectTo2D","stage","updateModelMatrix","_transformDirty","nodeIndex","traverseSceneGraph","visibleNodesOnly","callback","callbackOptions","show","childRuntimeNode","getChild","runtimePrimitivesLength","forEachRuntimePrimitive","scratchBackFaceCullingOptions","backFaceCulling","updateBackFaceCulling","backFaceCullingOptions","updatePrimitiveBackFaceCulling","scratchShadowOptions","shadowMode","updateShadows","shadowOptions","updatePrimitiveShadows","shadows","scratchShowBoundingVolumeOptions","debugShowBoundingVolume","updateShowBoundingVolume","showBoundingVolumeOptions","updatePrimitiveShowBoundingVolume","scratchSilhouetteCommands","scratchEdgeCommands","scratchPushDrawCommandOptions","pushDrawCommands","silhouetteCommands","edgeCommands","pushDrawCommandOptions","pushPrimitiveDrawCommands","commandList","passes","primitiveDrawCommand","pushCommands","pick","pushSilhouetteCommands","pushEdgeCommands","setArticulationStage","articulationStageKey","value","names","split","articulationName","stageName","hasOwnProperty","apply"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 19494, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelStatistics.js"],"sourcesContent":["import AssociativeArray from \"../../Core/AssociativeArray.js\";\nimport Check from \"../../Core/Check.js\";\n\n/**\n * Rendering statistics for a single model.\n *\n * @alias ModelStatistics\n * @constructor\n *\n * @see Cesium3DTilesetStatistics\n *\n * @private\n */\nfunction ModelStatistics() {\n  /**\n   * Total number of points across all POINTS primitives in this model.\n   *\n   * @type {number}\n   * @private\n   */\n  this.pointsLength = 0;\n\n  /**\n   * Total number of triangles across all TRIANGLES, TRIANGLE_STRIP or\n   * TRIANGLE_FAN primitives in this model.\n   *\n   * @type {number}\n   * @private\n   */\n  this.trianglesLength = 0;\n\n  /**\n   * Total size of all geometry buffers in bytes. This accounts for the vertex\n   * attributes (which includes feature IDs and property attributes) and index\n   * buffers of all the model's primitives. Any attributes generated by the\n   * pipeline are included in this total.\n   *\n   * @type {number}\n   * @private\n   */\n  this.geometryByteLength = 0;\n\n  /**\n   * Total size of all textures in bytes. This includes materials,\n   * feature ID textures, and property textures.\n   *\n   * @type {number}\n   * @private\n   */\n  this.texturesByteLength = 0;\n\n  /**\n   * Total size of property tables. This excludes the batch textures used for\n   * picking and styling.\n   *\n   * @type {number}\n   * @private\n   */\n  this.propertyTablesByteLength = 0;\n\n  // Sets of buffers and textures that have already been counted.\n  // This is to prevent double-counting cached assets.\n  this._bufferIdSet = {};\n\n  /**\n   * The mapping from `texture.id` strings to the byte length of the\n   * respective texture\n   *\n   * @type {object}\n   * @private\n   */\n  this._textureIdByteLengths = {};\n\n  // Associated array of batch textures that have already been counted.\n  // This allows for quick look-up to check if a texture has been counted,\n  // while also allowing for dynamic texture counting.\n  this._batchTextureIdMap = new AssociativeArray();\n}\n\nObject.defineProperties(ModelStatistics.prototype, {\n  /**\n   * Total size of the batch textures used for picking and styling.\n   * Batch textures are created asynchronously, so this iterates\n   * over the textures to ensure their memory values are accurate.\n   *\n   * @memberof ModelStatistics.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  batchTexturesByteLength: {\n    get: function () {\n      const length = this._batchTextureIdMap.length;\n      const values = this._batchTextureIdMap.values;\n\n      let memory = 0;\n      for (let i = 0; i < length; i++) {\n        memory += values[i].byteLength;\n      }\n\n      return memory;\n    },\n  },\n});\n\n/**\n * Reset the memory counts for this model. This should be called each time the\n * draw command pipeline is rebuilt.\n *\n * @private\n */\nModelStatistics.prototype.clear = function () {\n  this.pointsLength = 0;\n  this.trianglesLength = 0;\n  this.geometryByteLength = 0;\n  this.texturesByteLength = 0;\n  this.propertyTablesByteLength = 0;\n\n  this._bufferIdSet = {};\n  this._textureIdByteLengths = {};\n  this._batchTextureIdMap.removeAll();\n};\n\n/**\n * Counts the given buffer's memory in bytes. If a buffer has\n * already been counted by these statistics, it will not be\n * counted again.\n *\n * @param {Buffer} buffer The GPU buffer associated with the model.\n * @param {boolean} hasCpuCopy Whether the buffer has a copy on the CPU via typed array.\n *\n * @private\n */\nModelStatistics.prototype.addBuffer = function (buffer, hasCpuCopy) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"buffer\", buffer);\n  Check.typeOf.bool(\"hasCpuCopy\", hasCpuCopy);\n  //>>includeEnd('debug');\n\n  if (!this._bufferIdSet.hasOwnProperty(buffer._id)) {\n    // If there's a CPU copy, count the memory twice.\n    const copies = hasCpuCopy ? 2 : 1;\n    this.geometryByteLength += buffer.sizeInBytes * copies;\n  }\n\n  // Simulate set insertion.\n  this._bufferIdSet[buffer._id] = true;\n};\n\n/**\n * Counts the given texture's memory in bytes. If a texture has\n * already been counted by these statistics, it will not be\n * counted again.\n * <p>\n * This is used to count the materials and property textures of\n * a model. Batch textures function differently and are counted\n * using <code>addBatchTexture</code> instead.\n * </p>\n *\n * @param {Texture} texture The texture associated with the model.\n *\n * @private\n */\nModelStatistics.prototype.addTexture = function (texture) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"texture\", texture);\n  //>>includeEnd('debug');\n\n  if (!this._textureIdByteLengths.hasOwnProperty(texture._id)) {\n    this.texturesByteLength += texture.sizeInBytes;\n    this._textureIdByteLengths[texture._id] = texture.sizeInBytes;\n  }\n};\n\n/**\n * Returns an array containing the `texture.id` values for all textures\n * that are part of the model.\n *\n * @returns {string[]} The texture IDs\n */\nModelStatistics.prototype.getTextureIds = function () {\n  return Object.keys(this._textureIdByteLengths);\n};\n\n/**\n * Returns the length, in bytes, of the texture data for the texture with\n * the given ID that is part of the model, or `undefined` if the model\n * does not contain the texture with the given ID.\n *\n * @param {string} textureId The texture ID\n * @returns {number|undefined} The texture byte length\n */\nModelStatistics.prototype.getTextureByteLengthById = function (textureId) {\n  return this._textureIdByteLengths[textureId];\n};\n\n/**\n * Counts the batch texture's memory in bytes. If a batch texture\n * has already been counted by these statistics, it will not be\n * counted again.\n * <p>\n * Batch textures are handled differently than other textures. They\n * include the batch and pick textures for the feature table, which\n * are created dynamically. As such, they may not have both textures\n * loaded by the time they are added to the statistics. Their memory\n * will thus be counted dynamically.\n * </p>\n *\n * @param {BatchTexture} batchTexture The batch texture associated with the model.\n *\n * @private\n */\nModelStatistics.prototype.addBatchTexture = function (batchTexture) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"batchTexture\", batchTexture);\n  //>>includeEnd('debug');\n\n  if (!this._batchTextureIdMap.contains(batchTexture._id)) {\n    this._batchTextureIdMap.set(batchTexture._id, batchTexture);\n  }\n};\n\nexport default ModelStatistics;\n"],"names":["ModelStatistics","pointsLength","trianglesLength","geometryByteLength","texturesByteLength","propertyTablesByteLength","_bufferIdSet","_textureIdByteLengths","_batchTextureIdMap","Object","defineProperties","prototype","batchTexturesByteLength","get","length","values","memory","i","byteLength","clear","removeAll","addBuffer","buffer","hasCpuCopy","typeOf","object","bool","hasOwnProperty","_id","copies","sizeInBytes","addTexture","texture","getTextureIds","keys","getTextureByteLengthById","textureId","addBatchTexture","batchTexture","contains","set"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 19692, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/PntsLoader.js"],"sourcesContent":["import AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Color from \"../../Core/Color.js\";\nimport Check from \"../../Core/Check.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\nimport MersenneTwister from \"mersenne-twister\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport AlphaMode from \"../AlphaMode.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport Axis from \"../Axis.js\";\nimport parseBatchTable from \"../parseBatchTable.js\";\nimport DracoLoader from \"../DracoLoader.js\";\nimport StructuralMetadata from \"../StructuralMetadata.js\";\nimport ResourceLoader from \"../ResourceLoader.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport PntsParser from \"../PntsParser.js\";\nimport ResourceLoaderState from \"../ResourceLoaderState.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\nconst Components = ModelComponents.Components;\nconst Scene = ModelComponents.Scene;\nconst Node = ModelComponents.Node;\nconst Primitive = ModelComponents.Primitive;\nconst Attribute = ModelComponents.Attribute;\nconst Quantization = ModelComponents.Quantization;\nconst FeatureIdAttribute = ModelComponents.FeatureIdAttribute;\nconst Material = ModelComponents.Material;\nconst MetallicRoughness = ModelComponents.MetallicRoughness;\n\n/**\n * Loads a .pnts point cloud and transcodes it into a {@link ModelComponents}\n *\n * @alias PntsLoader\n * @constructor\n * @augments ResourceLoader\n * @private\n *\n * @param {object} options An object containing the following properties\n * @param {ArrayBuffer} options.arrayBuffer The array buffer of the pnts contents\n * @param {number} [options.byteOffset] The byte offset to the beginning of the pnts contents in the array buffer\n * @param {boolean} [options.loadAttributesFor2D=false] If true, load the positions buffer as a typed array for accurately projecting models to 2D.\n */\nfunction PntsLoader(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const arrayBuffer = options.arrayBuffer;\n  const byteOffset = options.byteOffset ?? 0;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  this._arrayBuffer = arrayBuffer;\n  this._byteOffset = byteOffset;\n  this._loadAttributesFor2D = options.loadAttributesFor2D ?? false;\n\n  this._parsedContent = undefined;\n  this._decodePromise = undefined;\n  this._decodedAttributes = undefined;\n\n  this._promise = undefined;\n  this._error = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._buffers = [];\n\n  // The batch table object contains a json and a binary component access using keys of the same name.\n  this._components = undefined;\n  this._transform = Matrix4.IDENTITY;\n}\n\nif (defined(Object.create)) {\n  PntsLoader.prototype = Object.create(ResourceLoader.prototype);\n  PntsLoader.prototype.constructor = PntsLoader;\n}\n\nObject.defineProperties(PntsLoader.prototype, {\n  /**\n   * The cache key of the resource\n   *\n   * @memberof PntsLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * The loaded components.\n   *\n   * @memberof PntsLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n\n  /**\n   * A world-space transform to apply to the primitives.\n   * See {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/PointCloud#global-semantics}\n   *\n   * @memberof PntsLoader.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   * @private\n   */\n  transform: {\n    get: function () {\n      return this._transform;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise<PntsLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nPntsLoader.prototype.load = function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n\n  this._parsedContent = PntsParser.parse(this._arrayBuffer, this._byteOffset);\n  this._state = ResourceLoaderState.PROCESSING;\n\n  this._promise = Promise.resolve(this);\n};\n\nPntsLoader.prototype.process = function (frameState) {\n  if (defined(this._error)) {\n    const error = this._error;\n    this._error = undefined;\n    throw error;\n  }\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n\n  if (this._state === ResourceLoaderState.PROCESSING) {\n    if (defined(this._decodePromise)) {\n      return false;\n    }\n\n    this._decodePromise = decodeDraco(this, frameState.context);\n  }\n\n  return false;\n};\n\nfunction decodeDraco(loader, context) {\n  const parsedContent = loader._parsedContent;\n  const draco = parsedContent.draco;\n\n  let decodePromise;\n  if (!defined(draco)) {\n    // The draco extension wasn't present,\n    decodePromise = Promise.resolve();\n  } else {\n    decodePromise = DracoLoader.decodePointCloud(draco, context);\n  }\n\n  if (!defined(decodePromise)) {\n    // Could not schedule Draco decoding this frame.\n    return;\n  }\n\n  loader._decodePromise = decodePromise;\n  return decodePromise\n    .then(function (decodeDracoResult) {\n      if (loader.isDestroyed()) {\n        return;\n      }\n\n      if (defined(decodeDracoResult)) {\n        processDracoAttributes(loader, draco, decodeDracoResult);\n      }\n      makeComponents(loader, context);\n      loader._state = ResourceLoaderState.READY;\n      return loader;\n    })\n    .catch(function (error) {\n      loader.unload();\n      loader._state = ResourceLoaderState.FAILED;\n      const errorMessage = \"Failed to load Draco pnts\";\n      // This error will be thrown next time process is called;\n      loader._error = loader.getError(errorMessage, error);\n    });\n}\n\nfunction processDracoAttributes(loader, draco, result) {\n  loader._state = ResourceLoaderState.READY;\n  const parsedContent = loader._parsedContent;\n\n  let attribute;\n  if (defined(result.POSITION)) {\n    attribute = {\n      name: \"POSITION\",\n      semantic: VertexAttributeSemantic.POSITION,\n      typedArray: result.POSITION.array,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      isQuantized: false,\n    };\n\n    if (defined(result.POSITION.data.quantization)) {\n      // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n      // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n      const quantization = result.POSITION.data.quantization;\n      const range = quantization.range;\n      const quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n      const quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n      const quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n\n      attribute.isQuantized = true;\n      attribute.quantizedRange = quantizedRange;\n      attribute.quantizedVolumeOffset = quantizedVolumeOffset;\n      attribute.quantizedVolumeScale = quantizedVolumeScale;\n      attribute.quantizedComponentDatatype =\n        quantizedRange <= 255\n          ? ComponentDatatype.UNSIGNED_BYTE\n          : ComponentDatatype.UNSIGNED_SHORT;\n      attribute.quantizedType = AttributeType.VEC3;\n    }\n\n    parsedContent.positions = attribute;\n  }\n\n  if (defined(result.NORMAL)) {\n    attribute = {\n      name: \"NORMAL\",\n      semantic: VertexAttributeSemantic.NORMAL,\n      typedArray: result.NORMAL.array,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      isQuantized: false,\n      octEncoded: false,\n      octEncodedZXY: false,\n    };\n\n    if (defined(result.NORMAL.data.quantization)) {\n      const octEncodedRange =\n        (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n      attribute.quantizedRange = octEncodedRange;\n      attribute.octEncoded = true;\n      attribute.octEncodedZXY = true;\n      attribute.quantizedComponentDatatype = ComponentDatatype.UNSIGNED_BYTE;\n      attribute.quantizedType = AttributeType.VEC2;\n    }\n\n    parsedContent.normals = attribute;\n  }\n\n  if (defined(result.RGBA)) {\n    parsedContent.colors = {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: result.RGBA.array,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC4,\n      normalized: true,\n      isTranslucent: true,\n    };\n  } else if (defined(result.RGB)) {\n    parsedContent.colors = {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: result.RGB.array,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC3,\n      normalized: true,\n      isTranslucent: false,\n    };\n  }\n\n  // Transcode Batch ID (3D Tiles 1.0) -> Feature ID (3D Tiles Next)\n  if (defined(result.BATCH_ID)) {\n    const batchIds = result.BATCH_ID.array;\n    parsedContent.batchIds = {\n      name: \"_FEATURE_ID\",\n      semantic: VertexAttributeSemantic.FEATURE_ID,\n      setIndex: 0,\n      typedArray: batchIds,\n      componentDatatype: ComponentDatatype.fromTypedArray(batchIds),\n      type: AttributeType.SCALAR,\n    };\n  }\n\n  let batchTableJson = parsedContent.batchTableJson;\n\n  const batchTableProperties = draco.batchTableProperties;\n  for (const name in batchTableProperties) {\n    if (batchTableProperties.hasOwnProperty(name)) {\n      const property = result[name];\n\n      if (!defined(batchTableJson)) {\n        batchTableJson = {};\n      }\n\n      parsedContent.hasDracoBatchTable = true;\n\n      const data = property.data;\n      batchTableJson[name] = {\n        byteOffset: data.byteOffset,\n        // Draco returns the results like glTF values, but here\n        // we want to transcode to a batch table. It's redundant\n        // but necessary to use parseBatchTable()\n        type: transcodeAttributeType(data.componentsPerAttribute),\n        componentType: transcodeComponentType(data.componentDatatype),\n        // Each property is stored as a separate typed array, so\n        // store it here. parseBatchTable() will check for this\n        // instead of the entire binary body.\n        typedArray: property.array,\n      };\n    }\n  }\n  parsedContent.batchTableJson = batchTableJson;\n}\n\nfunction transcodeAttributeType(componentsPerAttribute) {\n  switch (componentsPerAttribute) {\n    case 1:\n      return \"SCALAR\";\n    case 2:\n      return \"VEC2\";\n    case 3:\n      return \"VEC3\";\n    case 4:\n      return \"VEC4\";\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\n        \"componentsPerAttribute must be a number from 1-4\",\n      );\n    //>>includeEnd('debug');\n  }\n}\n\nfunction transcodeComponentType(value) {\n  switch (value) {\n    case WebGLConstants.BYTE:\n      return \"BYTE\";\n    case WebGLConstants.UNSIGNED_BYTE:\n      return \"UNSIGNED_BYTE\";\n    case WebGLConstants.SHORT:\n      return \"SHORT\";\n    case WebGLConstants.UNSIGNED_SHORT:\n      return \"UNSIGNED_SHORT\";\n    case WebGLConstants.INT:\n      return \"INT\";\n    case WebGLConstants.UNSIGNED_INT:\n      return \"UNSIGNED_INT\";\n    case WebGLConstants.DOUBLE:\n      return \"DOUBLE\";\n    case WebGLConstants.FLOAT:\n      return \"FLOAT\";\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"value is not a valid WebGL constant\");\n    //>>includeEnd('debug');\n  }\n}\n\nfunction makeAttribute(loader, attributeInfo, context) {\n  let typedArray = attributeInfo.typedArray;\n  let quantization;\n  if (attributeInfo.octEncoded) {\n    quantization = new Quantization();\n    quantization.octEncoded = attributeInfo.octEncoded;\n    quantization.octEncodedZXY = attributeInfo.octEncodedZXY;\n    quantization.normalizationRange = attributeInfo.quantizedRange;\n    quantization.type = attributeInfo.quantizedType;\n    quantization.componentDatatype = attributeInfo.quantizedComponentDatatype;\n  }\n  if (attributeInfo.isQuantized) {\n    quantization = new Quantization();\n    const normalizationRange = attributeInfo.quantizedRange;\n    quantization.normalizationRange = normalizationRange;\n    // volume offset sometimes requires 64-bit precision so this is handled\n    // in the components.transform matrix.\n    quantization.quantizedVolumeOffset = Cartesian3.ZERO;\n    const quantizedVolumeDimensions = attributeInfo.quantizedVolumeScale;\n    quantization.quantizedVolumeDimensions = quantizedVolumeDimensions;\n    quantization.quantizedVolumeStepSize = Cartesian3.divideByScalar(\n      quantizedVolumeDimensions,\n      normalizationRange,\n      new Cartesian3(),\n    );\n    quantization.componentDatatype = attributeInfo.quantizedComponentDatatype;\n    quantization.type = attributeInfo.quantizedType;\n  }\n\n  const attribute = new Attribute();\n  attribute.name = attributeInfo.name;\n  attribute.semantic = attributeInfo.semantic;\n  attribute.setIndex = attributeInfo.setIndex;\n  attribute.componentDatatype = attributeInfo.componentDatatype;\n  attribute.type = attributeInfo.type;\n  attribute.normalized = attributeInfo.normalized ?? false;\n  attribute.min = attributeInfo.min;\n  attribute.max = attributeInfo.max;\n  attribute.quantization = quantization;\n\n  if (attributeInfo.isRGB565) {\n    typedArray = AttributeCompression.decodeRGB565(typedArray);\n  }\n\n  if (defined(attributeInfo.constantColor)) {\n    const packedColor = new Array(4);\n    attribute.constant = Color.pack(attributeInfo.constantColor, packedColor);\n  } else {\n    const buffer = Buffer.createVertexBuffer({\n      typedArray: typedArray,\n      context: context,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    buffer.vertexArrayDestroyable = false;\n    loader._buffers.push(buffer);\n    attribute.buffer = buffer;\n  }\n\n  const loadAttributesFor2D = loader._loadAttributesFor2D;\n  if (\n    attribute.semantic === VertexAttributeSemantic.POSITION &&\n    loadAttributesFor2D\n  ) {\n    attribute.typedArray = typedArray;\n  }\n\n  return attribute;\n}\n\nlet randomNumberGenerator;\nlet randomValues;\n\nfunction getRandomValues(samplesLength) {\n  // Use same random values across all runs\n  if (!defined(randomValues)) {\n    // Use MersenneTwister directly to avoid interfering with CesiumMath.nextRandomNumber()\n    // See https://github.com/CesiumGS/cesium/issues/9730\n    randomNumberGenerator = new MersenneTwister(0);\n    randomValues = new Array(samplesLength);\n    for (let i = 0; i < samplesLength; ++i) {\n      randomValues[i] = randomNumberGenerator.random();\n    }\n  }\n  return randomValues;\n}\n\nconst scratchMin = new Cartesian3();\nconst scratchMax = new Cartesian3();\nconst scratchPosition = new Cartesian3();\nfunction computeApproximateExtrema(positions) {\n  const positionsArray = positions.typedArray;\n  const maximumSamplesLength = 20;\n  const pointsLength = positionsArray.length / 3;\n  const samplesLength = Math.min(pointsLength, maximumSamplesLength);\n  const randomValues = getRandomValues(maximumSamplesLength);\n  const maxValue = Number.MAX_VALUE;\n  const minValue = -Number.MAX_VALUE;\n  let min = Cartesian3.fromElements(maxValue, maxValue, maxValue, scratchMin);\n  let max = Cartesian3.fromElements(minValue, minValue, minValue, scratchMax);\n  let i;\n  let index;\n  let position;\n  if (positions.isQuantized) {\n    // The quantized volume offset is not used here since it will become part of\n    // the model matrix.\n    min = Cartesian3.ZERO;\n    max = positions.quantizedVolumeScale;\n  } else {\n    for (i = 0; i < samplesLength; ++i) {\n      index = Math.floor(randomValues[i] * pointsLength);\n      position = Cartesian3.unpack(positionsArray, index * 3, scratchPosition);\n\n      Cartesian3.minimumByComponent(min, position, min);\n      Cartesian3.maximumByComponent(max, position, max);\n    }\n  }\n\n  positions.min = Cartesian3.clone(min);\n  positions.max = Cartesian3.clone(max);\n}\n\n// By default, point clouds are rendered as dark gray.\nconst defaultColorAttribute = {\n  name: VertexAttributeSemantic.COLOR,\n  semantic: VertexAttributeSemantic.COLOR,\n  setIndex: 0,\n  constantColor: Color.DARKGRAY,\n  componentDatatype: ComponentDatatype.FLOAT,\n  type: AttributeType.VEC4,\n  isQuantized: false,\n  isTranslucent: false,\n};\n\nfunction makeAttributes(loader, parsedContent, context) {\n  const attributes = [];\n  let attribute;\n  const positions = parsedContent.positions;\n  if (defined(positions)) {\n    computeApproximateExtrema(positions);\n    attribute = makeAttribute(loader, positions, context);\n    attribute.count = parsedContent.pointsLength;\n    attributes.push(attribute);\n  }\n\n  if (defined(parsedContent.normals)) {\n    attribute = makeAttribute(loader, parsedContent.normals, context);\n    attributes.push(attribute);\n  }\n\n  if (defined(parsedContent.colors)) {\n    attribute = makeAttribute(loader, parsedContent.colors, context);\n    attributes.push(attribute);\n  } else {\n    attribute = makeAttribute(loader, defaultColorAttribute, context);\n    attributes.push(attribute);\n  }\n\n  if (defined(parsedContent.batchIds)) {\n    attribute = makeAttribute(loader, parsedContent.batchIds, context);\n    attributes.push(attribute);\n  }\n\n  return attributes;\n}\n\nfunction makeStructuralMetadata(parsedContent, customAttributeOutput) {\n  const batchLength = parsedContent.batchLength;\n  const pointsLength = parsedContent.pointsLength;\n  const batchTableJson = parsedContent.batchTableJson;\n  const batchTableBinary = parsedContent.batchTableBinary;\n\n  // If there are batch IDs, parse as a property table. Otherwise, parse\n  // as property attributes.\n  const parseAsPropertyAttributes = !defined(parsedContent.batchIds);\n  if (\n    defined(batchTableBinary) ||\n    defined(batchTableJson) ||\n    parsedContent.hasDracoBatchTable\n  ) {\n    const count = batchLength ?? pointsLength;\n    return parseBatchTable({\n      count: count,\n      batchTable: batchTableJson,\n      binaryBody: batchTableBinary,\n      parseAsPropertyAttributes: parseAsPropertyAttributes,\n      customAttributeOutput: customAttributeOutput,\n    });\n  }\n\n  return new StructuralMetadata({\n    schema: {},\n    propertyTables: [],\n  });\n}\n\nfunction makeComponents(loader, context) {\n  const parsedContent = loader._parsedContent;\n\n  const metallicRoughness = new MetallicRoughness();\n  metallicRoughness.metallicFactor = 0;\n  metallicRoughness.roughnessFactor = 0.9;\n\n  const material = new Material();\n  material.metallicRoughness = metallicRoughness;\n\n  const colors = parsedContent.colors;\n  if (defined(colors) && colors.isTranslucent) {\n    material.alphaMode = AlphaMode.BLEND;\n  }\n\n  // Render point clouds as unlit, unless normals are present, in which case\n  // render as a PBR material.\n  const isUnlit = !defined(parsedContent.normals);\n  material.unlit = isUnlit;\n\n  const primitive = new Primitive();\n  primitive.attributes = makeAttributes(loader, parsedContent, context);\n  primitive.primitiveType = PrimitiveType.POINTS;\n  primitive.material = material;\n\n  if (defined(parsedContent.batchIds)) {\n    const featureIdAttribute = new FeatureIdAttribute();\n    featureIdAttribute.propertyTableId = 0;\n    featureIdAttribute.setIndex = 0;\n    featureIdAttribute.positionalLabel = \"featureId_0\";\n    primitive.featureIds.push(featureIdAttribute);\n  }\n\n  const node = new Node();\n  node.index = 0;\n  node.primitives = [primitive];\n\n  const scene = new Scene();\n  scene.nodes = [node];\n  scene.upAxis = Axis.Z;\n  scene.forwardAxis = Axis.X;\n\n  const components = new Components();\n  components.scene = scene;\n  components.nodes = [node];\n\n  // Per-point features will be parsed as property attributes and handled on\n  // the GPU since CPU styling would be too expensive. However, if batch IDs\n  // exist, features will be parsed as a property table.\n  //\n  // Property attributes refer to a custom attribute that will\n  // store the values; such attributes will be populated in this array\n  // as needed.\n  const customAttributeOutput = [];\n  components.structuralMetadata = makeStructuralMetadata(\n    parsedContent,\n    customAttributeOutput,\n  );\n\n  if (customAttributeOutput.length > 0) {\n    addPropertyAttributesToPrimitive(\n      loader,\n      primitive,\n      customAttributeOutput,\n      context,\n    );\n  }\n\n  if (defined(parsedContent.rtcCenter)) {\n    components.transform = Matrix4.multiplyByTranslation(\n      components.transform,\n      parsedContent.rtcCenter,\n      components.transform,\n    );\n  }\n\n  const positions = parsedContent.positions;\n  if (defined(positions) && positions.isQuantized) {\n    // The volume offset is sometimes in ECEF, so this is applied here rather\n    // than the dequantization shader to avoid jitter\n    components.transform = Matrix4.multiplyByTranslation(\n      components.transform,\n      positions.quantizedVolumeOffset,\n      components.transform,\n    );\n  }\n\n  loader._components = components;\n\n  // Free the parsed content and array buffer so we don't hold onto the large arrays.\n  loader._parsedContent = undefined;\n  loader._arrayBuffer = undefined;\n}\n\nfunction addPropertyAttributesToPrimitive(\n  loader,\n  primitive,\n  customAttributes,\n  context,\n) {\n  const attributes = primitive.attributes;\n\n  const length = customAttributes.length;\n  for (let i = 0; i < length; i++) {\n    const customAttribute = customAttributes[i];\n\n    // Upload the typed array to the GPU and free the CPU copy.\n    const buffer = Buffer.createVertexBuffer({\n      typedArray: customAttribute.typedArray,\n      context: context,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    buffer.vertexArrayDestroyable = false;\n    loader._buffers.push(buffer);\n    customAttribute.buffer = buffer;\n    customAttribute.typedArray = undefined;\n\n    attributes.push(customAttribute);\n  }\n\n  // The batch table is always transcoded as a single property attribute, so\n  // it will always be index 0\n  primitive.propertyAttributeIds = [0];\n}\n\nPntsLoader.prototype.unload = function () {\n  const buffers = this._buffers;\n  for (let i = 0; i < buffers.length; i++) {\n    buffers[i].destroy();\n  }\n  buffers.length = 0;\n\n  this._components = undefined;\n  this._parsedContent = undefined;\n  this._arrayBuffer = undefined;\n};\n\nexport default PntsLoader;\n"],"names":["Components","Scene","Node","Primitive","Attribute","Quantization","FeatureIdAttribute","Material","MetallicRoughness","PntsLoader","options","EMPTY_OBJECT","arrayBuffer","byteOffset","typeOf","object","_arrayBuffer","_byteOffset","_loadAttributesFor2D","loadAttributesFor2D","_parsedContent","undefined","_decodePromise","_decodedAttributes","_promise","_error","_state","UNLOADED","_buffers","_components","_transform","IDENTITY","Object","create","prototype","defineProperties","cacheKey","get","components","transform","load","parse","PROCESSING","Promise","resolve","process","frameState","error","READY","decodeDraco","context","loader","parsedContent","draco","decodePromise","decodePointCloud","then","decodeDracoResult","isDestroyed","processDracoAttributes","makeComponents","catch","unload","FAILED","errorMessage","getError","result","attribute","POSITION","name","semantic","typedArray","array","componentDatatype","FLOAT","type","VEC3","isQuantized","data","quantization","range","quantizedVolumeScale","fromElements","quantizedVolumeOffset","unpack","minValues","quantizedRange","quantizationBits","quantizedComponentDatatype","UNSIGNED_BYTE","UNSIGNED_SHORT","quantizedType","positions","NORMAL","octEncoded","octEncodedZXY","octEncodedRange","VEC2","normals","RGBA","colors","COLOR","setIndex","VEC4","normalized","isTranslucent","RGB","BATCH_ID","batchIds","FEATURE_ID","fromTypedArray","SCALAR","batchTableJson","batchTableProperties","hasOwnProperty","property","hasDracoBatchTable","transcodeAttributeType","componentsPerAttribute","componentType","transcodeComponentType","value","BYTE","SHORT","INT","UNSIGNED_INT","DOUBLE","makeAttribute","attributeInfo","normalizationRange","ZERO","quantizedVolumeDimensions","quantizedVolumeStepSize","divideByScalar","min","max","isRGB565","decodeRGB565","constantColor","packedColor","Array","constant","pack","buffer","createVertexBuffer","usage","STATIC_DRAW","vertexArrayDestroyable","push","randomNumberGenerator","randomValues","getRandomValues","samplesLength","i","random","scratchMin","scratchMax","scratchPosition","computeApproximateExtrema","positionsArray","maximumSamplesLength","pointsLength","length","Math","maxValue","Number","MAX_VALUE","minValue","index","position","floor","minimumByComponent","maximumByComponent","clone","defaultColorAttribute","DARKGRAY","makeAttributes","attributes","count","makeStructuralMetadata","customAttributeOutput","batchLength","batchTableBinary","parseAsPropertyAttributes","batchTable","binaryBody","schema","propertyTables","metallicRoughness","metallicFactor","roughnessFactor","material","alphaMode","BLEND","isUnlit","unlit","primitive","primitiveType","POINTS","featureIdAttribute","propertyTableId","positionalLabel","featureIds","node","primitives","scene","nodes","upAxis","Z","forwardAxis","X","structuralMetadata","addPropertyAttributesToPrimitive","rtcCenter","multiplyByTranslation","customAttributes","customAttribute","propertyAttributeIds","buffers","destroy"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 20316, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/pickModel.js"],"sourcesContent":["import AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartographic from \"../../Core/Cartographic.js\";\nimport Check from \"../../Core/Check.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\nimport Ellipsoid from \"../../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../../Core/IndexDatatype.js\";\nimport IntersectionTests from \"../../Core/IntersectionTests.js\";\nimport Ray from \"../../Core/Ray.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport VerticalExaggeration from \"../../Core/VerticalExaggeration.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\nconst scratchV0 = new Cartesian3();\nconst scratchV1 = new Cartesian3();\nconst scratchV2 = new Cartesian3();\nconst scratchNodeComputedTransform = new Matrix4();\nconst scratchModelMatrix = new Matrix4();\nconst scratchcomputedModelMatrix = new Matrix4();\nconst scratchPickCartographic = new Cartographic();\nconst scratchBoundingSphere = new BoundingSphere();\n\n/**\n * Find an intersection between a ray and the model surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Model} model The model to pick.\n * @param {Ray} ray The ray to test for intersection.\n * @param {FrameState} frameState The frame state.\n * @param {number} [verticalExaggeration=1.0] A scalar used to exaggerate the height of a position relative to the ellipsoid. If the value is 1.0 there will be no effect.\n * @param {number} [relativeHeight=0.0] The ellipsoid height relative to which a position is exaggerated. If the value is 0.0 the position will be exaggerated relative to the ellipsoid surface.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to which the exaggerated position is relative.\n * @param {Cartesian3|undefined} [result] The intersection or <code>undefined</code> if none was found.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.\n *\n * @private\n */\nexport default function pickModel(\n  model,\n  ray,\n  frameState,\n  verticalExaggeration,\n  relativeHeight,\n  ellipsoid,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"model\", model);\n  Check.typeOf.object(\"ray\", ray);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (!model._ready || frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  let minT = Number.MAX_VALUE;\n  const sceneGraph = model.sceneGraph;\n\n  const nodes = sceneGraph._runtimeNodes;\n  for (let i = 0; i < nodes.length; i++) {\n    const runtimeNode = nodes[i];\n    const node = runtimeNode.node;\n\n    let nodeComputedTransform = Matrix4.clone(\n      runtimeNode.computedTransform,\n      scratchNodeComputedTransform,\n    );\n    let modelMatrix = Matrix4.clone(\n      sceneGraph.computedModelMatrix,\n      scratchModelMatrix,\n    );\n\n    const instances = node.instances;\n    if (defined(instances)) {\n      if (instances.transformInWorldSpace) {\n        // Replicate the multiplication order in LegacyInstancingStageVS.\n        modelMatrix = Matrix4.multiplyTransformation(\n          model.modelMatrix,\n          sceneGraph.components.transform,\n          modelMatrix,\n        );\n\n        nodeComputedTransform = Matrix4.multiplyTransformation(\n          sceneGraph.axisCorrectionMatrix,\n          runtimeNode.computedTransform,\n          nodeComputedTransform,\n        );\n      }\n    }\n\n    let computedModelMatrix = Matrix4.multiplyTransformation(\n      modelMatrix,\n      nodeComputedTransform,\n      scratchcomputedModelMatrix,\n    );\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      computedModelMatrix = Transforms.basisTo2D(\n        frameState.mapProjection,\n        computedModelMatrix,\n        computedModelMatrix,\n      );\n    }\n\n    const transforms = [];\n    if (defined(instances)) {\n      const transformsCount = instances.attributes[0].count;\n      const instanceComponentDatatype =\n        instances.attributes[0].componentDatatype;\n\n      const transformElements = 12;\n      let transformsTypedArray = runtimeNode.transformsTypedArray;\n      if (!defined(transformsTypedArray)) {\n        const instanceTransformsBuffer = runtimeNode.instancingTransformsBuffer;\n        if (defined(instanceTransformsBuffer) && frameState.context.webgl2) {\n          transformsTypedArray = ComponentDatatype.createTypedArray(\n            instanceComponentDatatype,\n            transformsCount * transformElements,\n          );\n          instanceTransformsBuffer.getBufferData(transformsTypedArray);\n        }\n      }\n\n      if (defined(transformsTypedArray)) {\n        for (let i = 0; i < transformsCount; i++) {\n          const index = i * transformElements;\n\n          const transform = new Matrix4(\n            transformsTypedArray[index],\n            transformsTypedArray[index + 1],\n            transformsTypedArray[index + 2],\n            transformsTypedArray[index + 3],\n            transformsTypedArray[index + 4],\n            transformsTypedArray[index + 5],\n            transformsTypedArray[index + 6],\n            transformsTypedArray[index + 7],\n            transformsTypedArray[index + 8],\n            transformsTypedArray[index + 9],\n            transformsTypedArray[index + 10],\n            transformsTypedArray[index + 11],\n            0,\n            0,\n            0,\n            1,\n          );\n\n          if (instances.transformInWorldSpace) {\n            Matrix4.multiplyTransformation(\n              transform,\n              nodeComputedTransform,\n              transform,\n            );\n            Matrix4.multiplyTransformation(modelMatrix, transform, transform);\n          } else {\n            Matrix4.multiplyTransformation(\n              transform,\n              computedModelMatrix,\n              transform,\n            );\n          }\n          transforms.push(transform);\n        }\n      }\n    }\n\n    if (transforms.length === 0) {\n      transforms.push(computedModelMatrix);\n    }\n\n    const primitivesLength = runtimeNode.runtimePrimitives.length;\n    for (let j = 0; j < primitivesLength; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n      const primitive = runtimePrimitive.primitive;\n\n      if (defined(runtimePrimitive.boundingSphere) && !defined(instances)) {\n        const boundingSphere = BoundingSphere.transform(\n          runtimePrimitive.boundingSphere,\n          computedModelMatrix,\n          scratchBoundingSphere,\n        );\n        const boundsIntersection = IntersectionTests.raySphere(\n          ray,\n          boundingSphere,\n        );\n        if (!defined(boundsIntersection)) {\n          continue;\n        }\n      }\n\n      const positionAttribute = ModelUtility.getAttributeBySemantic(\n        primitive,\n        VertexAttributeSemantic.POSITION,\n      );\n      const byteOffset = positionAttribute.byteOffset;\n      const byteStride = positionAttribute.byteStride;\n      const vertexCount = positionAttribute.count;\n\n      if (!defined(primitive.indices)) {\n        // Point clouds\n        continue;\n      }\n\n      let indices = primitive.indices.typedArray;\n      if (!defined(indices)) {\n        const indicesBuffer = primitive.indices.buffer;\n        const indicesCount = primitive.indices.count;\n        const indexDatatype = primitive.indices.indexDatatype;\n        if (defined(indicesBuffer) && frameState.context.webgl2) {\n          if (indexDatatype === IndexDatatype.UNSIGNED_BYTE) {\n            indices = new Uint8Array(indicesCount);\n          } else if (indexDatatype === IndexDatatype.UNSIGNED_SHORT) {\n            indices = new Uint16Array(indicesCount);\n          } else if (indexDatatype === IndexDatatype.UNSIGNED_INT) {\n            indices = new Uint32Array(indicesCount);\n          }\n\n          indicesBuffer.getBufferData(indices);\n        }\n      }\n\n      let vertices = positionAttribute.typedArray;\n      let componentDatatype = positionAttribute.componentDatatype;\n      let attributeType = positionAttribute.type;\n\n      const quantization = positionAttribute.quantization;\n      if (defined(quantization)) {\n        componentDatatype = positionAttribute.quantization.componentDatatype;\n        attributeType = positionAttribute.quantization.type;\n      }\n\n      const numComponents = AttributeType.getNumberOfComponents(attributeType);\n      const bytes = ComponentDatatype.getSizeInBytes(componentDatatype);\n      const isInterleaved =\n        !defined(vertices) &&\n        defined(byteStride) &&\n        byteStride !== numComponents * bytes;\n\n      let elementStride = numComponents;\n      let offset = 0;\n      if (isInterleaved) {\n        elementStride = byteStride / bytes;\n        offset = byteOffset / bytes;\n      }\n      const elementCount = vertexCount * elementStride;\n\n      if (!defined(vertices)) {\n        const verticesBuffer = positionAttribute.buffer;\n\n        if (defined(verticesBuffer) && frameState.context.webgl2) {\n          vertices = ComponentDatatype.createTypedArray(\n            componentDatatype,\n            elementCount,\n          );\n          verticesBuffer.getBufferData(\n            vertices,\n            isInterleaved ? 0 : byteOffset,\n            0,\n            elementCount,\n          );\n        }\n\n        if (quantization && positionAttribute.normalized) {\n          vertices = AttributeCompression.dequantize(\n            vertices,\n            componentDatatype,\n            attributeType,\n            vertexCount,\n          );\n        }\n      }\n\n      if (!defined(indices) || !defined(vertices)) {\n        return;\n      }\n\n      ellipsoid = ellipsoid ?? Ellipsoid.default;\n      verticalExaggeration = verticalExaggeration ?? 1.0;\n      relativeHeight = relativeHeight ?? 0.0;\n\n      const indicesLength = indices.length;\n      for (let i = 0; i < indicesLength; i += 3) {\n        const i0 = indices[i];\n        const i1 = indices[i + 1];\n        const i2 = indices[i + 2];\n\n        for (const instanceTransform of transforms) {\n          const v0 = getVertexPosition(\n            vertices,\n            i0,\n            offset,\n            elementStride,\n            quantization,\n            instanceTransform,\n            verticalExaggeration,\n            relativeHeight,\n            ellipsoid,\n            scratchV0,\n          );\n          const v1 = getVertexPosition(\n            vertices,\n            i1,\n            offset,\n            elementStride,\n            quantization,\n            instanceTransform,\n            verticalExaggeration,\n            relativeHeight,\n            ellipsoid,\n            scratchV1,\n          );\n          const v2 = getVertexPosition(\n            vertices,\n            i2,\n            offset,\n            elementStride,\n            quantization,\n            instanceTransform,\n            verticalExaggeration,\n            relativeHeight,\n            ellipsoid,\n            scratchV2,\n          );\n\n          const t = IntersectionTests.rayTriangleParametric(\n            ray,\n            v0,\n            v1,\n            v2,\n            model.backFaceCulling ?? true,\n          );\n\n          if (defined(t)) {\n            if (t < minT && t >= 0.0) {\n              minT = t;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (minT === Number.MAX_VALUE) {\n    return undefined;\n  }\n\n  result = Ray.getPoint(ray, minT, result);\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    Cartesian3.fromElements(result.y, result.z, result.x, result);\n\n    const projection = frameState.mapProjection;\n    const ellipsoid = projection.ellipsoid;\n\n    const cartographic = projection.unproject(result, scratchPickCartographic);\n    ellipsoid.cartographicToCartesian(cartographic, result);\n  }\n\n  return result;\n}\n\nfunction getVertexPosition(\n  vertices,\n  index,\n  offset,\n  numElements,\n  quantization,\n  instanceTransform,\n  verticalExaggeration,\n  relativeHeight,\n  ellipsoid,\n  result,\n) {\n  const i = offset + index * numElements;\n  result.x = vertices[i];\n  result.y = vertices[i + 1];\n  result.z = vertices[i + 2];\n\n  if (defined(quantization)) {\n    if (quantization.octEncoded) {\n      result = AttributeCompression.octDecodeInRange(\n        result,\n        quantization.normalizationRange,\n        result,\n      );\n\n      if (quantization.octEncodedZXY) {\n        const x = result.x;\n        result.x = result.z;\n        result.z = result.y;\n        result.y = x;\n      }\n    } else {\n      result = Cartesian3.multiplyComponents(\n        result,\n        quantization.quantizedVolumeStepSize,\n        result,\n      );\n\n      result = Cartesian3.add(\n        result,\n        quantization.quantizedVolumeOffset,\n        result,\n      );\n    }\n  }\n\n  result = Matrix4.multiplyByPoint(instanceTransform, result, result);\n\n  if (verticalExaggeration !== 1.0) {\n    VerticalExaggeration.getPosition(\n      result,\n      ellipsoid,\n      verticalExaggeration,\n      relativeHeight,\n      result,\n    );\n  }\n\n  return result;\n}\n"],"names":["scratchV0","scratchV1","scratchV2","scratchNodeComputedTransform","scratchModelMatrix","scratchcomputedModelMatrix","scratchPickCartographic","scratchBoundingSphere","pickModel","model","ray","frameState","verticalExaggeration","relativeHeight","ellipsoid","result","typeOf","object","_ready","mode","MORPHING","minT","Number","MAX_VALUE","sceneGraph","nodes","_runtimeNodes","i","length","runtimeNode","node","nodeComputedTransform","clone","computedTransform","modelMatrix","computedModelMatrix","instances","transformInWorldSpace","multiplyTransformation","components","transform","axisCorrectionMatrix","SCENE3D","basisTo2D","mapProjection","transforms","transformsCount","attributes","count","instanceComponentDatatype","componentDatatype","transformElements","transformsTypedArray","instanceTransformsBuffer","instancingTransformsBuffer","context","webgl2","createTypedArray","getBufferData","index","push","primitivesLength","runtimePrimitives","j","runtimePrimitive","primitive","boundingSphere","boundsIntersection","raySphere","positionAttribute","getAttributeBySemantic","POSITION","byteOffset","byteStride","vertexCount","indices","typedArray","indicesBuffer","buffer","indicesCount","indexDatatype","UNSIGNED_BYTE","Uint8Array","UNSIGNED_SHORT","Uint16Array","UNSIGNED_INT","Uint32Array","vertices","attributeType","type","quantization","numComponents","getNumberOfComponents","bytes","getSizeInBytes","isInterleaved","elementStride","offset","elementCount","verticesBuffer","normalized","dequantize","default","indicesLength","i0","i1","i2","instanceTransform","v0","getVertexPosition","v1","v2","t","rayTriangleParametric","backFaceCulling","undefined","getPoint","fromElements","y","z","x","projection","cartographic","unproject","cartographicToCartesian","numElements","octEncoded","octDecodeInRange","normalizationRange","octEncodedZXY","multiplyComponents","quantizedVolumeStepSize","add","quantizedVolumeOffset","multiplyByPoint","getPosition"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 20552, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ImageryConfiguration.js"],"sourcesContent":["/**\n * A class containing a the values that affect the appearance of\n * an <code>ImageryLayer</code>.\n *\n * This is used in the <code>ModelImagery</code> to detect changes in\n * the imagery settings: The <code>ModelImagery</code> stores one\n * instance per imagery layer. During the <code>update</code>\n * call, it checks whether any of the settings was changed.\n * If this is the case, the draw commands of the model are reset.\n *\n * @private\n */\nclass ImageryConfiguration {\n  constructor(imageryLayer) {\n    this.show = imageryLayer.show;\n    this.alpha = imageryLayer.alpha;\n    this.brightness = imageryLayer.brightness;\n    this.contrast = imageryLayer.contrast;\n    this.hue = imageryLayer.hue;\n    this.saturation = imageryLayer.saturation;\n    this.gamma = imageryLayer.gamma;\n    this.colorToAlpha = imageryLayer.colorToAlpha;\n  }\n}\n\nexport default ImageryConfiguration;\n"],"names":["ImageryConfiguration","imageryLayer","show","alpha","brightness","contrast","hue","saturation","gamma","colorToAlpha"],"mappings":";;;;AAAA;;;;;;;;;;;CAWC,GACD,MAAMA;IACJA,YAAYC,YAAY,CAAE;QACxB,IAAI,CAACC,IAAI,GAAGD,aAAaC,IAAI;QAC7B,IAAI,CAACC,KAAK,GAAGF,aAAaE,KAAK;QAC/B,IAAI,CAACC,UAAU,GAAGH,aAAaG,UAAU;QACzC,IAAI,CAACC,QAAQ,GAAGJ,aAAaI,QAAQ;QACrC,IAAI,CAACC,GAAG,GAAGL,aAAaK,GAAG;QAC3B,IAAI,CAACC,UAAU,GAAGN,aAAaM,UAAU;QACzC,IAAI,CAACC,KAAK,GAAGP,aAAaO,KAAK;QAC/B,IAAI,CAACC,YAAY,GAAGR,aAAaQ,YAAY;IAC/C;AACF;uCAEeT","ignoreList":[0]}},
    {"offset": {"line": 20584, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/ModelImagery.js"],"sourcesContent":["import Check from \"../../Core/Check.js\";\nimport defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\n\nimport ImageryConfiguration from \"./ImageryConfiguration.js\";\nimport ModelPrimitiveImagery from \"./ModelPrimitiveImagery.js\";\n\n/**\n * A class managing the draping of imagery on a <code>Model</code>.\n *\n * An instance of this class is created in the Model constructor. It will\n * create the data structures that carry the information that is required\n * for mapping imagery textures on model primitives.\n *\n * It offers two functions for managing the lifecycle of this draping process:\n *\n * The <code>update</code> function is called from the <code>Model.update</code>\n * function in each frame. It will create one <code>ModelPrimitiveImagery</code>\n * instance for each primitive that appears in the model, and call the\n * <code>update</code> function of these instances, respectively.\n *\n * The <code>ready</code> getter will be used to determine whether the\n * draping computations are done, and the update process of the <code>Model</code>\n * can continue, eventually causing the <code>model.ready</code> flag to\n * become <code>true</code>. The model imagery counts as \"ready\" when all\n * the imagery layers of the model are <code>ready</code>, and all the\n * <code>ModelPrimitiveImagery</code> instances are <code>ready</code>.\n *\n * @private\n */\nclass ModelImagery {\n  /**\n   * Creates a new instance\n   *\n   * @param {Model} model The model\n   * @throws {DeveloperError} If the model is not defined\n   */\n  constructor(model) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"model\", model);\n    //>>includeEnd('debug');\n\n    /**\n     * The model that this instance was created for.\n     *\n     * @type {Model}\n     * @readonly\n     * @private\n     */\n    this._model = model;\n\n    /**\n     * One <code<ModelPrimitiveImagery</code> for each primitive\n     * that appears in the model.\n     *\n     * Initially, this is <code>undefined</code>. When the <code>update</code>\n     * function is called and all imagery layers that are associated with the\n     * model are <code>ready</code>, this is initialized with one instance\n     * of a <code>ModelPrimitiveImagery</code> per runtime primitive (i.e. one for\n     * each <code>model.sceneGraph._runtimeNodes[n]._runtimePrimitives[p]</code>)\n     *\n     * @type {ModelPrimitiveImagery[]|undefined}\n     * @private\n     */\n    this._modelPrimitiveImageries = undefined;\n\n    /**\n     * One <code>ImageryConfiguration</code> object for each <code>ImageryLayer</code>\n     * that is associated with the model.\n     *\n     * This is used for determining whether the configuration (relevant property\n     * values) of an imagery layer has been changed since the previous\n     * <code>update</code> call, which should cause the draw commands of the\n     * model to be reset.\n     *\n     * @type {ImageryConfiguration[]}\n     * @private\n     */\n    this._imageryConfigurations = [];\n  }\n\n  /**\n   * The update function that is called from <code>Model.update</code> in\n   * each frame.\n   *\n   * This checks whether the imagery layer objects that are associated\n   * with the model are all <code>ready</code>. If they are not yet\n   * ready, then nothing is done.\n   *\n   * Otherwise, this just calls the <code>update</code> function of\n   * the <code>_modelPrimitiveImageries</code> (creating them if they had\n   * not been created yet).\n   *\n   * @param {FrameState} frameState The frame state\n   */\n  update(frameState) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"frameState\", frameState);\n    //>>includeEnd('debug');\n\n    if (!this._hasImagery) {\n      // When there is no imagery, make sure to delete any model primitive\n      // imageries that may previously have been created\n      this._deleteModelPrimitiveImageries();\n      return;\n    }\n\n    if (!this._allImageryLayersReady) {\n      return;\n    }\n\n    if (!defined(this._modelPrimitiveImageries)) {\n      this._modelPrimitiveImageries = this._createModelPrimitiveImageries();\n    }\n    this._updateModelPrimitiveImageries(frameState);\n\n    this._checkForModifiedImageryConfigurations();\n  }\n\n  /**\n   * Creates the <code>ModelPrimitiveImagery</code> array that contains\n   * one <code>ModelPrimitiveImagery</code> for each primitive that is\n   * contained in the model.\n   *\n   * @returns {ModelPrimitiveImagery[]} The model primitive imageries\n   * @private\n   */\n  _createModelPrimitiveImageries() {\n    const model = this._model;\n    const runtimeNodesAndPrimitives = this._collectRuntimeNodesAndPrimitives();\n    const modelPrimitiveImageries = [];\n    const length = runtimeNodesAndPrimitives.length;\n    for (let i = 0; i < length; i++) {\n      const runtimeNodeAndPrimitive = runtimeNodesAndPrimitives[i];\n      const runtimeNode = runtimeNodeAndPrimitive.runtimeNode;\n      const runtimePrimitive = runtimeNodeAndPrimitive.runtimePrimitive;\n      const modelPrimitiveImagery = new ModelPrimitiveImagery(\n        model,\n        runtimeNode,\n        runtimePrimitive,\n      );\n      runtimePrimitive.primitive.modelPrimitiveImagery = modelPrimitiveImagery;\n      modelPrimitiveImageries.push(modelPrimitiveImagery);\n    }\n    return modelPrimitiveImageries;\n  }\n\n  /**\n   * Computes all runtime nodes and primitives of the model.\n   *\n   * This is just the array that contains a\n   * <code>{ runtimeNode, runtimePrimitive }</code>\n   * for each\n   * <code>model.sceneGraph._runtimeNodes[n]._runtimePrimitives[p]</code>.\n   *\n   * @returns {object[]} The runtime nodes and primitives\n   * @private\n   */\n  _collectRuntimeNodesAndPrimitives() {\n    const model = this._model;\n    const sceneGraph = model.sceneGraph;\n    const runtimeNodes = sceneGraph._runtimeNodes;\n    const runtimeNodesAndPrimitives = [];\n    for (let i = 0; i < runtimeNodes.length; i++) {\n      const runtimeNode = runtimeNodes[i];\n      if (!defined(runtimeNode)) {\n        continue;\n      }\n      for (let j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n        const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n        runtimeNodesAndPrimitives.push({\n          runtimeNode: runtimeNode,\n          runtimePrimitive: runtimePrimitive,\n        });\n      }\n    }\n    return runtimeNodesAndPrimitives;\n  }\n\n  /**\n   * Just calls <code>update</code> on each <code>ModelPrimitiveImagery</code>\n   * as part of the <code>update</code> of this class.\n   *\n   * @private\n   */\n  _updateModelPrimitiveImageries(frameState) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"frameState\", frameState);\n    //>>includeEnd('debug');\n\n    if (!defined(this._modelPrimitiveImageries)) {\n      throw new DeveloperError(\n        \"The modelPrimitiveImageries have not been created\",\n      );\n    }\n\n    const modelPrimitiveImageries = this._modelPrimitiveImageries;\n    const length = modelPrimitiveImageries.length;\n    for (let i = 0; i < length; i++) {\n      const modelPrimitiveImagery = modelPrimitiveImageries[i];\n      modelPrimitiveImagery.update(frameState);\n    }\n  }\n\n  /**\n   * Destroy and delete all <code>ModelPrimitiveImagery</code> instances\n   * if they already have been created.\n   */\n  _deleteModelPrimitiveImageries() {\n    const modelPrimitiveImageries = this._modelPrimitiveImageries;\n    if (!defined(modelPrimitiveImageries)) {\n      return;\n    }\n    const length = modelPrimitiveImageries.length;\n    for (let i = 0; i < length; i++) {\n      const modelPrimitiveImagery = modelPrimitiveImageries[i];\n      modelPrimitiveImagery.destroy();\n    }\n    delete this._modelPrimitiveImageries;\n    this._model.resetDrawCommands();\n  }\n\n  /**\n   * Returns whether this instance is \"ready\".\n   *\n   * This means that all imagery layers that are associated with the model\n   * are <code>ready</code>, and all <code>ModelPrimitiveImagery</code>\n   * instances are <code>ready</code>.\n   *\n   * When this is <code>true</code>, then the mapping computations are\n   * complete and the structures containing the mapping information have\n   * been initialized. Otherwise, subsequent calls to <code>update</code>\n   * will perform the necessary computation until this getter eventually\n   * returns <code>true</code>.\n   *\n   * @returns {boolean} Whether this instance is \"ready\"\n   */\n  get ready() {\n    if (!this._hasImagery) {\n      return true;\n    }\n    if (!this._allImageryLayersReady) {\n      return false;\n    }\n    if (!this._allModelPrimitiveImageriesReady) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the model has imagery layers associated with it.\n   *\n   * @private\n   */\n  get _hasImagery() {\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n    return defined(imageryLayers) && imageryLayers.length > 0;\n  }\n\n  /**\n   * Returns whether all imagery layers that are associated with the\n   * model are <code>ready</code>.\n   *\n   * If the model does not have imagery, then this always returns\n   * <code>true</code>. Otherwise, it returns whether each imagery\n   * layer is <code>ready</code>.\n   *\n   * @private\n   */\n  get _allImageryLayersReady() {\n    if (!this._hasImagery) {\n      return true;\n    }\n    const imageryLayers = this._model.imageryLayers;\n    const length = imageryLayers.length;\n    for (let i = 0; i < length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      if (!imageryLayer.ready) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether all <code>ModelPrimitiveImagery</code> instances\n   * are are <code>ready</code>.\n   *\n   * @private\n   */\n  get _allModelPrimitiveImageriesReady() {\n    const modelPrimitiveImageries = this._modelPrimitiveImageries;\n    if (!defined(modelPrimitiveImageries)) {\n      return false;\n    }\n    const length = modelPrimitiveImageries.length;\n    for (let i = 0; i < length; i++) {\n      const modelPrimitiveImagery = modelPrimitiveImageries[i];\n      if (!modelPrimitiveImagery.ready) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Check whether any of the settings of any imagery layer (like alpha\n   * or hue) has been changed since the last call to the <code>update</code>\n   * function.\n   *\n   * If this is the case, the draw commands of the model will be reset.\n   */\n  _checkForModifiedImageryConfigurations() {\n    if (this._imageryConfigurationsModified()) {\n      this._updateImageryConfigurations();\n      const model = this._model;\n      model.resetDrawCommands();\n    }\n  }\n\n  /**\n   * Returns whether any setting of an imagery layer (like alpha or hue) has\n   * been changed since the last time the <code>ImageryConfiguration</code>\n   * objects have been updated.\n   *\n   * @returns {boolean} Whether there was a modification\n   */\n  _imageryConfigurationsModified() {\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n    const imageryConfigurations = this._imageryConfigurations;\n    if (imageryLayers.length !== imageryConfigurations.length) {\n      return true;\n    }\n    for (let i = 0; i < imageryLayers.length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      const imageryConfiguration = imageryConfigurations[i];\n\n      if (imageryLayer.show !== imageryConfiguration.show) {\n        return true;\n      }\n      if (imageryLayer.alpha !== imageryConfiguration.alpha) {\n        return true;\n      }\n      if (imageryLayer.brightness !== imageryConfiguration.brightness) {\n        return true;\n      }\n      if (imageryLayer.contrast !== imageryConfiguration.contrast) {\n        return true;\n      }\n      if (imageryLayer.hue !== imageryConfiguration.hue) {\n        return true;\n      }\n      if (imageryLayer.saturation !== imageryConfiguration.saturation) {\n        return true;\n      }\n      if (imageryLayer.gamma !== imageryConfiguration.gamma) {\n        return true;\n      }\n      if (imageryLayer.colorToAlpha !== imageryConfiguration.colorToAlpha) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Create one <code>ImageryConfiguration</code> object for each imagery\n   * layer that appears in the model, and store them as the\n   * <code>_imageryConfigurations</code>.\n   */\n  _updateImageryConfigurations() {\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n    const imageryConfigurations = this._imageryConfigurations;\n    imageryConfigurations.length = imageryLayers.length;\n    for (let i = 0; i < imageryLayers.length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      imageryConfigurations[i] = new ImageryConfiguration(imageryLayer);\n    }\n  }\n\n  /**\n   * Returns whether this object was destroyed.\n   *\n   * If this object was destroyed, calling any function other than\n   * <code>isDestroyed</code> will result in a {@link DeveloperError}.\n   *\n   * @returns {boolean} Whether this object was destroyed\n   */\n  isDestroyed() {\n    return false;\n  }\n\n  /**\n   * Destroys this object and all its resources.\n   */\n  destroy() {\n    if (this.isDestroyed()) {\n      return;\n    }\n    this._deleteModelPrimitiveImageries();\n    return destroyObject(this);\n  }\n}\n\nexport default ModelImagery;\n"],"names":["ModelImagery","model","defined","_model","_modelPrimitiveImageries","undefined","_imageryConfigurations","update","frameState","_hasImagery","_deleteModelPrimitiveImageries","_allImageryLayersReady","_createModelPrimitiveImageries","_updateModelPrimitiveImageries","_checkForModifiedImageryConfigurations","runtimeNodesAndPrimitives","_collectRuntimeNodesAndPrimitives","modelPrimitiveImageries","length","i","runtimeNodeAndPrimitive","runtimeNode","runtimePrimitive","modelPrimitiveImagery","primitive","push","sceneGraph","runtimeNodes","_runtimeNodes","j","runtimePrimitives","destroy","resetDrawCommands","ready","_allModelPrimitiveImageriesReady","imageryLayers","imageryLayer","get","_imageryConfigurationsModified","_updateImageryConfigurations","imageryConfigurations","imageryConfiguration","show","alpha","brightness","contrast","hue","saturation","gamma","colorToAlpha","isDestroyed"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 20956, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/Model3DTileContent.js"],"sourcesContent":["import Color from \"../../Core/Color.js\";\nimport combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Ellipsoid from \"../../Core/Ellipsoid.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport ModelAnimationLoop from \"../ModelAnimationLoop.js\";\nimport Model from \"./Model.js\";\n\n/**\n * Represents the contents of a glTF, glb or\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Batched3DModel|Batched 3D Model}\n * tile in a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles} tileset.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n * This object is normally not instantiated directly, use {@link Model3DTileContent.fromGltf}, {@link Model3DTileContent.fromB3dm}, {@link Model3DTileContent.fromI3dm}, {@link Model3DTileContent.fromPnts}, or {@link Model3DTileContent.fromGeoJson}.\n *\n * @alias Model3DTileContent\n * @constructor\n * @private\n */\nfunction Model3DTileContent(tileset, tile, resource) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n\n  this._model = undefined;\n  this._metadata = undefined;\n  this._group = undefined;\n  this._ready = false;\n}\n\nObject.defineProperties(Model3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      const model = this._model;\n      const featureTables = model.featureTables;\n      const featureTableId = model.featureTableId;\n\n      if (defined(featureTables) && defined(featureTables[featureTableId])) {\n        return featureTables[featureTableId].featuresLength;\n      }\n\n      return 0;\n    },\n  },\n\n  pointsLength: {\n    get: function () {\n      return this._model.statistics.pointsLength;\n    },\n  },\n\n  trianglesLength: {\n    get: function () {\n      return this._model.statistics.trianglesLength;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      return this._model.statistics.geometryByteLength;\n    },\n  },\n\n  texturesByteLength: {\n    get: function () {\n      return this._model.statistics.texturesByteLength;\n    },\n  },\n\n  batchTableByteLength: {\n    get: function () {\n      const statistics = this._model.statistics;\n      return (\n        statistics.propertyTablesByteLength + statistics.batchTexturesByteLength\n      );\n    },\n  },\n\n  innerContents: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Returns true when the tile's content is ready to render; otherwise false\n   *\n   * @memberof Model3DTileContent.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n\n  url: {\n    get: function () {\n      return this._resource.getUrlComponent(true);\n    },\n  },\n\n  batchTable: {\n    get: function () {\n      const model = this._model;\n      const featureTables = model.featureTables;\n      const featureTableId = model.featureTableId;\n\n      if (defined(featureTables) && defined(featureTables[featureTableId])) {\n        return featureTables[featureTableId];\n      }\n\n      return undefined;\n    },\n  },\n\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n    set: function (value) {\n      this._metadata = value;\n    },\n  },\n\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    },\n  },\n});\n\n/**\n * Returns an array containing the `texture.id` values for all textures\n * that are part of this content.\n *\n * @returns {string[]} The texture IDs\n */\nModel3DTileContent.prototype.getTextureIds = function () {\n  return this._model.statistics.getTextureIds();\n};\n\n/**\n * Returns the length, in bytes, of the texture data for the texture with\n * the given ID that is part of this content, or `undefined` if this\n * content does not contain the texture with the given ID.\n *\n * @param {string} textureId The texture ID\n * @returns {number|undefined} The texture byte length\n */\nModel3DTileContent.prototype.getTextureByteLengthById = function (textureId) {\n  return this._model.statistics.getTextureByteLengthById(textureId);\n};\n\n/**\n * Returns the object that was created for the given extension.\n *\n * The given name may be the name of a glTF extension, like `\"EXT_example_extension\"`.\n * If the specified extension was present in the root of the underlying glTF asset,\n * and a loader for the specified extension has processed the extension data, then\n * this will return the model representation of the extension.\n *\n * @param {string} extensionName The name of the extension\n * @returns {object|undefined} The object, or `undefined`\n *\n * @private\n */\nModel3DTileContent.prototype.getExtension = function (extensionName) {\n  const model = this._model;\n  const extension = model.getExtension(extensionName);\n  return extension;\n};\n\nModel3DTileContent.prototype.getFeature = function (featureId) {\n  const model = this._model;\n  const featureTableId = model.featureTableId;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(featureTableId)) {\n    throw new DeveloperError(\n      \"No feature ID set is selected. Make sure Cesium3DTileset.featureIdLabel or Cesium3DTileset.instanceFeatureIdLabel is defined\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const featureTable = model.featureTables[featureTableId];\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(featureTable)) {\n    throw new DeveloperError(\n      \"No feature table found for the selected feature ID set\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  //>>includeStart('debug', pragmas.debug);\n  const featuresLength = featureTable.featuresLength;\n  if (!defined(featureId) || featureId < 0 || featureId >= featuresLength) {\n    throw new DeveloperError(\n      `featureId is required and must be between 0 and featuresLength - 1 (${\n        featuresLength - 1\n      }).`,\n    );\n  }\n  //>>includeEnd('debug');\n  return featureTable.getFeature(featureId);\n};\n\nModel3DTileContent.prototype.hasProperty = function (featureId, name) {\n  const model = this._model;\n  const featureTableId = model.featureTableId;\n  if (!defined(featureTableId)) {\n    return false;\n  }\n\n  const featureTable = model.featureTables[featureTableId];\n  return featureTable.hasProperty(featureId, name);\n};\n\nModel3DTileContent.prototype.applyDebugSettings = function (enabled, color) {\n  color = enabled ? color : Color.WHITE;\n  if (this.featuresLength === 0) {\n    this._model.color = color;\n  } else if (defined(this.batchTable)) {\n    this.batchTable.setAllColor(color);\n  }\n};\n\nModel3DTileContent.prototype.applyStyle = function (style) {\n  // the setter will call model.applyStyle()\n  this._model.style = style;\n};\n\nModel3DTileContent.prototype.update = function (tileset, frameState) {\n  const model = this._model;\n  const tile = this._tile;\n\n  model.colorBlendAmount = tileset.colorBlendAmount;\n  model.colorBlendMode = tileset.colorBlendMode;\n  model.modelMatrix = tile.computedTransform;\n  model.customShader = tileset.customShader;\n  model.featureIdLabel = tileset.featureIdLabel;\n  model.instanceFeatureIdLabel = tileset.instanceFeatureIdLabel;\n  model.lightColor = tileset.lightColor;\n  model.imageBasedLighting = tileset.imageBasedLighting;\n  model.backFaceCulling = tileset.backFaceCulling;\n  model.shadows = tileset.shadows;\n  model.showCreditsOnScreen = tileset.showCreditsOnScreen;\n  model.splitDirection = tileset.splitDirection;\n  model.debugWireframe = tileset.debugWireframe;\n  model.showOutline = tileset.showOutline;\n  model.outlineColor = tileset.outlineColor;\n  model.pointCloudShading = tileset.pointCloudShading;\n\n  // Updating clipping planes requires more effort because of ownership checks\n  const tilesetClippingPlanes = tileset.clippingPlanes;\n  model.referenceMatrix = tileset.clippingPlanesOriginMatrix;\n  if (defined(tilesetClippingPlanes) && tile.clippingPlanesDirty) {\n    // Dereference the clipping planes from the model if they are irrelevant.\n    model._clippingPlanes =\n      tilesetClippingPlanes.enabled && tile._isClipped\n        ? tilesetClippingPlanes\n        : undefined;\n  }\n\n  const tilesetEnvironmentMapManager = tileset.environmentMapManager;\n  if (model.environmentMapManager !== tilesetClippingPlanes) {\n    model._environmentMapManager = tilesetEnvironmentMapManager;\n  }\n\n  // If the model references a different ClippingPlaneCollection from the tileset,\n  // update the model to use the new ClippingPlaneCollection.\n  if (\n    defined(tilesetClippingPlanes) &&\n    defined(model._clippingPlanes) &&\n    model._clippingPlanes !== tilesetClippingPlanes\n  ) {\n    model._clippingPlanes = tilesetClippingPlanes;\n    model._clippingPlanesState = 0;\n  }\n\n  // Updating clipping polygons requires more effort because of ownership checks\n  const tilesetClippingPolygons = tileset.clippingPolygons;\n  if (defined(tilesetClippingPolygons) && tile.clippingPolygonsDirty) {\n    // Dereference the clipping polygons from the model if they are irrelevant.\n    model._clippingPolygons =\n      tilesetClippingPolygons.enabled && tile._isClippedByPolygon\n        ? tilesetClippingPolygons\n        : undefined;\n  }\n\n  // If the model references a different ClippingPolygonCollection from the tileset,\n  // update the model to use the new ClippingPolygonCollection.\n  if (\n    defined(tilesetClippingPolygons) &&\n    defined(model._clippingPolygons) &&\n    model._clippingPolygons !== tilesetClippingPolygons\n  ) {\n    model._clippingPolygons = tilesetClippingPolygons;\n    model._clippingPolygonsState = 0;\n  }\n\n  model.update(frameState);\n\n  if (!this._ready && model.ready) {\n    // Animation can only be added once the model is ready\n    model.activeAnimations.addAll({\n      loop: ModelAnimationLoop.REPEAT,\n    });\n\n    this._ready = true;\n  }\n};\n\nModel3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nModel3DTileContent.prototype.destroy = function () {\n  this._model = this._model && this._model.destroy();\n  return destroyObject(this);\n};\n\nModel3DTileContent.fromGltf = async function (tileset, tile, resource, gltf) {\n  const content = new Model3DTileContent(tileset, tile, resource);\n\n  const additionalOptions = {\n    gltf: gltf,\n    basePath: resource,\n  };\n\n  const modelOptions = makeModelOptions(\n    tileset,\n    tile,\n    content,\n    additionalOptions,\n  );\n\n  const classificationType = tileset.vectorClassificationOnly\n    ? undefined\n    : tileset.classificationType;\n\n  modelOptions.classificationType = classificationType;\n\n  const model = await Model.fromGltfAsync(modelOptions);\n  content._model = model;\n\n  return content;\n};\n\nModel3DTileContent.fromB3dm = async function (\n  tileset,\n  tile,\n  resource,\n  arrayBuffer,\n  byteOffset,\n) {\n  const content = new Model3DTileContent(tileset, tile, resource);\n\n  const additionalOptions = {\n    arrayBuffer: arrayBuffer,\n    byteOffset: byteOffset,\n    resource: resource,\n  };\n\n  const modelOptions = makeModelOptions(\n    tileset,\n    tile,\n    content,\n    additionalOptions,\n  );\n\n  const classificationType = tileset.vectorClassificationOnly\n    ? undefined\n    : tileset.classificationType;\n\n  modelOptions.classificationType = classificationType;\n\n  const model = await Model.fromB3dm(modelOptions);\n  content._model = model;\n\n  return content;\n};\n\nModel3DTileContent.fromI3dm = async function (\n  tileset,\n  tile,\n  resource,\n  arrayBuffer,\n  byteOffset,\n) {\n  const content = new Model3DTileContent(tileset, tile, resource);\n\n  const additionalOptions = {\n    arrayBuffer: arrayBuffer,\n    byteOffset: byteOffset,\n    resource: resource,\n  };\n\n  const modelOptions = makeModelOptions(\n    tileset,\n    tile,\n    content,\n    additionalOptions,\n  );\n\n  const model = await Model.fromI3dm(modelOptions);\n  content._model = model;\n\n  return content;\n};\n\nModel3DTileContent.fromPnts = async function (\n  tileset,\n  tile,\n  resource,\n  arrayBuffer,\n  byteOffset,\n) {\n  const content = new Model3DTileContent(tileset, tile, resource);\n\n  const additionalOptions = {\n    arrayBuffer: arrayBuffer,\n    byteOffset: byteOffset,\n    resource: resource,\n  };\n\n  const modelOptions = makeModelOptions(\n    tileset,\n    tile,\n    content,\n    additionalOptions,\n  );\n  const model = await Model.fromPnts(modelOptions);\n  content._model = model;\n\n  return content;\n};\n\nModel3DTileContent.fromGeoJson = async function (\n  tileset,\n  tile,\n  resource,\n  geoJson,\n) {\n  const content = new Model3DTileContent(tileset, tile, resource);\n\n  const additionalOptions = {\n    geoJson: geoJson,\n    resource: resource,\n  };\n\n  const modelOptions = makeModelOptions(\n    tileset,\n    tile,\n    content,\n    additionalOptions,\n  );\n  const model = await Model.fromGeoJson(modelOptions);\n  content._model = model;\n\n  return content;\n};\n\n/**\n * Find an intersection between a ray and the tile content surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {FrameState} frameState The frame state.\n * @param {Cartesian3|undefined} [result] The intersection or <code>undefined</code> if none was found.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.\n *\n * @private\n */\nModel3DTileContent.prototype.pick = function (ray, frameState, result) {\n  if (!defined(this._model) || !this._ready) {\n    return undefined;\n  }\n\n  const verticalExaggeration = frameState.verticalExaggeration;\n  const relativeHeight = frameState.verticalExaggerationRelativeHeight;\n\n  // All tilesets assume a WGS84 ellipsoid\n  return this._model.pick(\n    ray,\n    frameState,\n    verticalExaggeration,\n    relativeHeight,\n    Ellipsoid.WGS84,\n    result,\n  );\n};\n\nfunction makeModelOptions(tileset, tile, content, additionalOptions) {\n  const mainOptions = {\n    cull: false, // The model is already culled by 3D Tiles\n    releaseGltfJson: true, // Models are unique and will not benefit from caching so save memory\n    opaquePass: Pass.CESIUM_3D_TILE, // Draw opaque portions of the model during the 3D Tiles pass\n    modelMatrix: tile.computedTransform,\n    upAxis: tileset._modelUpAxis,\n    forwardAxis: tileset._modelForwardAxis,\n    incrementallyLoadTextures: false,\n    customShader: tileset.customShader,\n    content: content,\n    colorBlendMode: tileset.colorBlendMode,\n    colorBlendAmount: tileset.colorBlendAmount,\n    lightColor: tileset.lightColor,\n    imageBasedLighting: tileset.imageBasedLighting,\n    featureIdLabel: tileset.featureIdLabel,\n    instanceFeatureIdLabel: tileset.instanceFeatureIdLabel,\n    pointCloudShading: tileset.pointCloudShading,\n    clippingPlanes: tileset.clippingPlanes,\n    backFaceCulling: tileset.backFaceCulling,\n    shadows: tileset.shadows,\n    showCreditsOnScreen: tileset.showCreditsOnScreen,\n    splitDirection: tileset.splitDirection,\n    enableDebugWireframe: tileset._enableDebugWireframe,\n    debugWireframe: tileset.debugWireframe,\n    projectTo2D: tileset._projectTo2D,\n    enablePick: tileset._enablePick,\n    enableShowOutline: tileset._enableShowOutline,\n    showOutline: tileset.showOutline,\n    outlineColor: tileset.outlineColor,\n  };\n\n  return combine(additionalOptions, mainOptions);\n}\n\nexport default Model3DTileContent;\n"],"names":["Model3DTileContent","tileset","tile","resource","_tileset","_tile","_resource","_model","undefined","_metadata","_group","_ready","Object","defineProperties","prototype","featuresLength","get","model","featureTables","featureTableId","pointsLength","statistics","trianglesLength","geometryByteLength","texturesByteLength","batchTableByteLength","propertyTablesByteLength","batchTexturesByteLength","innerContents","ready","url","getUrlComponent","batchTable","metadata","set","value","group","getTextureIds","getTextureByteLengthById","textureId","getExtension","extensionName","extension","getFeature","featureId","featureTable","hasProperty","name","applyDebugSettings","enabled","color","WHITE","setAllColor","applyStyle","style","update","frameState","colorBlendAmount","colorBlendMode","modelMatrix","computedTransform","customShader","featureIdLabel","instanceFeatureIdLabel","lightColor","imageBasedLighting","backFaceCulling","shadows","showCreditsOnScreen","splitDirection","debugWireframe","showOutline","outlineColor","pointCloudShading","tilesetClippingPlanes","clippingPlanes","referenceMatrix","clippingPlanesOriginMatrix","clippingPlanesDirty","_clippingPlanes","_isClipped","tilesetEnvironmentMapManager","environmentMapManager","_environmentMapManager","_clippingPlanesState","tilesetClippingPolygons","clippingPolygons","clippingPolygonsDirty","_clippingPolygons","_isClippedByPolygon","_clippingPolygonsState","activeAnimations","addAll","loop","REPEAT","isDestroyed","destroy","fromGltf","gltf","content","additionalOptions","basePath","modelOptions","makeModelOptions","classificationType","vectorClassificationOnly","fromGltfAsync","fromB3dm","arrayBuffer","byteOffset","fromI3dm","fromPnts","fromGeoJson","geoJson","pick","ray","result","verticalExaggeration","relativeHeight","verticalExaggerationRelativeHeight","WGS84","mainOptions","cull","releaseGltfJson","opaquePass","CESIUM_3D_TILE","upAxis","_modelUpAxis","forwardAxis","_modelForwardAxis","incrementallyLoadTextures","enableDebugWireframe","_enableDebugWireframe","projectTo2D","_projectTo2D","enablePick","_enablePick","enableShowOutline","_enableShowOutline"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 21358, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/UniformType.js"],"sourcesContent":["/**\n * An enum of the basic GLSL uniform types. These can be used with\n * {@link CustomShader} to declare user-defined uniforms.\n *\n * @enum {string}\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst UniformType = {\n  /**\n   * A single floating point value.\n   *\n   * @type {string}\n   * @constant\n   */\n  FLOAT: \"float\",\n  /**\n   * A vector of 2 floating point values.\n   *\n   * @type {string}\n   * @constant\n   */\n  VEC2: \"vec2\",\n  /**\n   * A vector of 3 floating point values.\n   *\n   * @type {string}\n   * @constant\n   */\n  VEC3: \"vec3\",\n  /**\n   * A vector of 4 floating point values.\n   *\n   * @type {string}\n   * @constant\n   */\n  VEC4: \"vec4\",\n  /**\n   * A single integer value\n   *\n   * @type {string}\n   * @constant\n   */\n  INT: \"int\",\n  /**\n   * A vector of 2 integer values.\n   *\n   * @type {string}\n   * @constant\n   */\n  INT_VEC2: \"ivec2\",\n  /**\n   * A vector of 3 integer values.\n   *\n   * @type {string}\n   * @constant\n   */\n  INT_VEC3: \"ivec3\",\n  /**\n   * A vector of 4 integer values.\n   *\n   * @type {string}\n   * @constant\n   */\n  INT_VEC4: \"ivec4\",\n  /**\n   * A single boolean value.\n   *\n   * @type {string}\n   * @constant\n   */\n  BOOL: \"bool\",\n  /**\n   * A vector of 2 boolean values.\n   *\n   * @type {string}\n   * @constant\n   */\n  BOOL_VEC2: \"bvec2\",\n  /**\n   * A vector of 3 boolean values.\n   *\n   * @type {string}\n   * @constant\n   */\n  BOOL_VEC3: \"bvec3\",\n  /**\n   * A vector of 4 boolean values.\n   *\n   * @type {string}\n   * @constant\n   */\n  BOOL_VEC4: \"bvec4\",\n  /**\n   * A 2x2 matrix of floating point values.\n   *\n   * @type {string}\n   * @constant\n   */\n  MAT2: \"mat2\",\n  /**\n   * A 3x3 matrix of floating point values.\n   *\n   * @type {string}\n   * @constant\n   */\n  MAT3: \"mat3\",\n  /**\n   * A 4x4 matrix of floating point values.\n   *\n   * @type {string}\n   * @constant\n   */\n  MAT4: \"mat4\",\n  /**\n   * A 2D sampled texture.\n   * @type {string}\n   * @constant\n   */\n  SAMPLER_2D: \"sampler2D\",\n  SAMPLER_CUBE: \"samplerCube\",\n};\n\nexport default Object.freeze(UniformType);\n"],"names":["UniformType","FLOAT","VEC2","VEC3","VEC4","INT","INT_VEC2","INT_VEC3","INT_VEC4","BOOL","BOOL_VEC2","BOOL_VEC3","BOOL_VEC4","MAT2","MAT3","MAT4","SAMPLER_2D","SAMPLER_CUBE","Object","freeze"],"mappings":";;;;AAAA;;;;;;;CAOC,GACD,MAAMA,cAAc;IAClB;;;;;GAKC,GACDC,OAAO;IACP;;;;;GAKC,GACDC,MAAM;IACN;;;;;GAKC,GACDC,MAAM;IACN;;;;;GAKC,GACDC,MAAM;IACN;;;;;GAKC,GACDC,KAAK;IACL;;;;;GAKC,GACDC,UAAU;IACV;;;;;GAKC,GACDC,UAAU;IACV;;;;;GAKC,GACDC,UAAU;IACV;;;;;GAKC,GACDC,MAAM;IACN;;;;;GAKC,GACDC,WAAW;IACX;;;;;GAKC,GACDC,WAAW;IACX;;;;;GAKC,GACDC,WAAW;IACX;;;;;GAKC,GACDC,MAAM;IACN;;;;;GAKC,GACDC,MAAM;IACN;;;;;GAKC,GACDC,MAAM;IACN;;;;GAIC,GACDC,YAAY;IACZC,cAAc;AAChB;uCAEeC,OAAOC,MAAM,CAACnB","ignoreList":[0]}},
    {"offset": {"line": 21472, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/TextureManager.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport getImageFromTypedArray from \"../../Core/getImageFromTypedArray.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport resizeImageToNextPowerOfTwo from \"../../Core/resizeImageToNextPowerOfTwo.js\";\nimport PixelDatatype from \"../../Renderer/PixelDatatype.js\";\nimport Texture from \"../../Renderer/Texture.js\";\nimport TextureMinificationFilter from \"../../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../../Renderer/TextureWrap.js\";\n\n/**\n * An object to manage loading textures\n *\n * @alias TextureManager\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction TextureManager() {\n  this._defaultTexture = undefined;\n  this._textures = {};\n  this._loadedImages = [];\n\n  // Keep track of the last time update() was called to avoid\n  // calling update() twice.\n  this._lastUpdatedFrame = -1;\n}\n\n/**\n * Get one of the loaded textures\n * @param {string} textureId The unique ID of the texture loaded by {@link TextureManager#loadTexture2D}\n * @return {Texture} The texture or <code>undefined</code> if no texture exists\n */\nTextureManager.prototype.getTexture = function (textureId) {\n  return this._textures[textureId];\n};\n\nfunction fetchTexture2D(textureManager, textureId, textureUniform) {\n  textureUniform.resource\n    .fetchImage()\n    .then(function (image) {\n      textureManager._loadedImages.push({\n        id: textureId,\n        image: image,\n        textureUniform: textureUniform,\n      });\n    })\n    .catch(function () {\n      const texture = textureManager._textures[textureId];\n      if (defined(texture) && texture !== textureManager._defaultTexture) {\n        texture.destroy();\n      }\n\n      textureManager._textures[textureId] = textureManager._defaultTexture;\n    });\n}\n\n/**\n * Load a texture 2D asynchronously. Note that {@link TextureManager#update}\n * must be called in the render loop to finish processing the textures.\n *\n * @param {string} textureId A unique ID to identify this texture.\n * @param {TextureUniform} textureUniform A description of the texture\n *\n * @private\n */\nTextureManager.prototype.loadTexture2D = function (textureId, textureUniform) {\n  if (defined(textureUniform.typedArray)) {\n    this._loadedImages.push({\n      id: textureId,\n      textureUniform: textureUniform,\n    });\n  } else {\n    fetchTexture2D(this, textureId, textureUniform);\n  }\n};\n\nfunction createTexture(textureManager, loadedImage, context) {\n  const { id, textureUniform, image } = loadedImage;\n\n  // If the context is WebGL1, and the sampler needs mipmaps or repeating\n  // boundary conditions, the image may need to be resized first\n  const texture = context.webgl2\n    ? getTextureAndMips(textureUniform, image, context)\n    : getWebGL1Texture(textureUniform, image, context);\n\n  // Destroy the old texture once the new one is loaded for more seamless\n  // transitions between values\n  const oldTexture = textureManager._textures[id];\n  if (defined(oldTexture) && oldTexture !== context.defaultTexture) {\n    oldTexture.destroy();\n  }\n  textureManager._textures[id] = texture;\n}\n\nfunction getTextureAndMips(textureUniform, image, context) {\n  const { typedArray, sampler } = textureUniform;\n\n  const texture = defined(typedArray)\n    ? getTextureFromTypedArray(textureUniform, context)\n    : new Texture({ context, source: image, sampler });\n\n  if (samplerRequiresMipmap(sampler)) {\n    texture.generateMipmap();\n  }\n\n  return texture;\n}\n\nfunction getWebGL1Texture(textureUniform, image, context) {\n  const { typedArray, sampler } = textureUniform;\n\n  // WebGL1 requires power-of-two texture dimensions for mipmapping and REPEAT wrap modes\n  const needMipmap = samplerRequiresMipmap(sampler);\n\n  const samplerRepeats =\n    sampler.wrapS === TextureWrap.REPEAT ||\n    sampler.wrapS === TextureWrap.MIRRORED_REPEAT ||\n    sampler.wrapT === TextureWrap.REPEAT ||\n    sampler.wrapT === TextureWrap.MIRRORED_REPEAT;\n\n  const { width, height } = defined(typedArray) ? textureUniform : image;\n  const isPowerOfTwo = [width, height].every(CesiumMath.isPowerOfTwo);\n  const requiresResize = (needMipmap || samplerRepeats) && !isPowerOfTwo;\n\n  if (!requiresResize) {\n    return getTextureAndMips(textureUniform, image, context);\n  } else if (!defined(typedArray)) {\n    const resizedImage = resizeImageToNextPowerOfTwo(image);\n    return getTextureAndMips(textureUniform, resizedImage, context);\n  } else if (textureUniform.pixelDatatype === PixelDatatype.UNSIGNED_BYTE) {\n    const imageFromArray = getImageFromTypedArray(typedArray, width, height);\n    const resizedImage = resizeImageToNextPowerOfTwo(imageFromArray);\n    return getTextureAndMips({ sampler }, resizedImage, context);\n  }\n\n  // typedArray is non-power-of-two but can't be resized. Warn and return raw texture (no mipmaps)\n  if (needMipmap) {\n    console.warn(\n      \"Texture requires resizing for mipmaps but pixelDataType cannot be resized. The texture may be rendered incorrectly.\",\n    );\n  } else if (samplerRepeats) {\n    console.warn(\n      \"Texture requires resizing for wrapping but pixelDataType cannot be resized. The texture may be rendered incorrectly.\",\n    );\n  }\n  return getTextureFromTypedArray(textureUniform, context);\n}\n\nfunction samplerRequiresMipmap(sampler) {\n  return [\n    TextureMinificationFilter.NEAREST_MIPMAP_NEAREST,\n    TextureMinificationFilter.NEAREST_MIPMAP_LINEAR,\n    TextureMinificationFilter.LINEAR_MIPMAP_NEAREST,\n    TextureMinificationFilter.LINEAR_MIPMAP_LINEAR,\n  ].includes(sampler.minificationFilter);\n}\n\nfunction getTextureFromTypedArray(textureUniform, context) {\n  const {\n    pixelFormat,\n    pixelDatatype,\n    width,\n    height,\n    typedArray: arrayBufferView,\n    sampler,\n  } = textureUniform;\n\n  return new Texture({\n    context,\n    pixelFormat,\n    pixelDatatype,\n    source: { arrayBufferView, width, height },\n    sampler,\n    flipY: false,\n  });\n}\n\nTextureManager.prototype.update = function (frameState) {\n  // update only needs to be called once a frame.\n  if (frameState.frameNumber === this._lastUpdatedFrame) {\n    return;\n  }\n  this._lastUpdatedFrame = frameState.frameNumber;\n\n  const context = frameState.context;\n  this._defaultTexture = context.defaultTexture;\n\n  // If any images were loaded since the last frame, create Textures\n  // for them and store in the uniform dictionary\n  const loadedImages = this._loadedImages;\n  for (let i = 0; i < loadedImages.length; i++) {\n    const loadedImage = loadedImages[i];\n    createTexture(this, loadedImage, context);\n  }\n  loadedImages.length = 0;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see TextureManager#destroy\n * @private\n */\nTextureManager.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * textureManager = textureManager && textureManager.destroy();\n *\n * @see TextureManager#isDestroyed\n * @private\n */\nTextureManager.prototype.destroy = function () {\n  const textures = this._textures;\n  for (const texture in textures) {\n    if (textures.hasOwnProperty(texture)) {\n      const instance = textures[texture];\n      if (instance !== this._defaultTexture) {\n        instance.destroy();\n      }\n    }\n  }\n  return destroyObject(this);\n};\n\nexport default TextureManager;\n"],"names":["TextureManager","_defaultTexture","undefined","_textures","_loadedImages","_lastUpdatedFrame","prototype","getTexture","textureId","fetchTexture2D","textureManager","textureUniform","resource","fetchImage","then","image","push","id","catch","texture","destroy","loadTexture2D","typedArray","createTexture","loadedImage","context","webgl2","getTextureAndMips","getWebGL1Texture","oldTexture","defaultTexture","sampler","getTextureFromTypedArray","source","samplerRequiresMipmap","generateMipmap","needMipmap","samplerRepeats","wrapS","REPEAT","MIRRORED_REPEAT","wrapT","width","height","isPowerOfTwo","every","requiresResize","resizedImage","pixelDatatype","UNSIGNED_BYTE","imageFromArray","console","warn","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","includes","minificationFilter","pixelFormat","arrayBufferView","flipY","update","frameState","frameNumber","loadedImages","i","length","isDestroyed","textures","hasOwnProperty","instance"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 21691, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/CustomShader.js"],"sourcesContent":["import Check from \"../../Core/Check.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport CustomShaderMode from \"./CustomShaderMode.js\";\nimport UniformType from \"./UniformType.js\";\nimport TextureManager from \"./TextureManager.js\";\nimport CustomShaderTranslucencyMode from \"./CustomShaderTranslucencyMode.js\";\n\n/**\n * An object describing a uniform, its type, and an initial value\n *\n * @typedef {object} UniformSpecifier\n * @property {UniformType} type The Glsl type of the uniform.\n * @property {boolean|number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4|TextureUniform} value The initial value of the uniform\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\n\n/**\n * A set of variables parsed from the user-defined shader code. These can be\n * used for optimizations when generating the overall shader. Though they are\n * represented as JS objects, the intended use is like a set, so only the\n * existence of keys matter. The values will always be <code>true</code> if\n * defined. This data structure is used because:\n * <ul>\n *   <li>We cannot yet use ES6 Set objects</li>\n *   <li>Using a dictionary automatically de-duplicates variable names</li>\n *   <li>Queries such as <code>variableSet.hasOwnProperty(\"position\")</code> are straightforward</li>\n * </ul>\n * @typedef {Object<string, boolean>} VariableSet\n * @private\n */\n\n/**\n * Variable sets parsed from the user-defined vertex shader text.\n * @typedef {object} VertexVariableSets\n * @property {VariableSet} attributeSet A set of all unique attributes used in the vertex shader via the <code>vsInput.attributes</code> struct.\n * @property {VariableSet} featureIdSet A set of all unique feature ID sets used in the vertex shader via the <code>vsInput.featureIds</code> struct.\n * @property {VariableSet} metadataSet A set of all unique metadata properties used in the vertex shader via the <code>vsInput.metadata</code> struct.\n * @private\n */\n\n/**\n * Variable sets parsed from the user-defined fragment shader text.\n * @typedef {object} FragmentVariableSets\n * @property {VariableSet} attributeSet A set of all unique attributes used in the fragment shader via the <code>fsInput.attributes</code> struct\n * @property {VariableSet} featureIdSet A set of all unique feature ID sets used in the fragment shader via the <code>fsInput.featureIds</code> struct.\n * @property {VariableSet} metadataSet A set of all unique metadata properties used in the fragment shader via the <code>fsInput.metadata</code> struct.\n * @property {VariableSet} materialSet A set of all material variables such as diffuse, specular or alpha that are used in the fragment shader via the <code>material</code> struct.\n * @private\n */\n\n/**\n * A user defined GLSL shader used with {@link Model} as well\n * as {@link Cesium3DTileset}.\n * <p>\n * If texture uniforms are used, additional resource management must be done:\n * </p>\n * <ul>\n *   <li>\n *      The <code>update</code> function must be called each frame. When a\n *      custom shader is passed to a {@link Model} or a\n *      {@link Cesium3DTileset}, this step is handled automaticaly\n *   </li>\n *   <li>\n *      {@link CustomShader#destroy} must be called when the custom shader is\n *      no longer needed to clean up GPU resources properly. The application\n *      is responsible for calling this method.\n *   </li>\n * </ul>\n * <p>\n * See the {@link https://github.com/CesiumGS/cesium/tree/main/Documentation/CustomShaderGuide|Custom Shader Guide} for more detailed documentation.\n * </p>\n *\n * @param {object} options An object with the following options\n * @param {CustomShaderMode} [options.mode=CustomShaderMode.MODIFY_MATERIAL] The custom shader mode, which determines how the custom shader code is inserted into the fragment shader.\n * @param {LightingModel} [options.lightingModel] The lighting model (e.g. PBR or unlit). If present, this overrides the default lighting for the model.\n * @param {CustomShaderTranslucencyMode} [options.translucencyMode=CustomShaderTranslucencyMode.INHERIT] The translucency mode, which determines how the custom shader will be applied. If the value is CustomShaderTransulcencyMode.OPAQUE or CustomShaderTransulcencyMode.TRANSLUCENT, the custom shader will override settings from the model's material. If the value is CustomShaderTransulcencyMode.INHERIT, the custom shader will render as either opaque or translucent depending on the primitive's material settings.\n * @param {Object<string, UniformSpecifier>} [options.uniforms] A dictionary for user-defined uniforms. The key is the uniform name that will appear in the GLSL code. The value is an object that describes the uniform type and initial value\n * @param {Object<string, VaryingType>} [options.varyings] A dictionary for declaring additional GLSL varyings used in the shader. The key is the varying name that will appear in the GLSL code. The value is the data type of the varying. For each varying, the declaration will be added to the top of the shader automatically. The caller is responsible for assigning a value in the vertex shader and using the value in the fragment shader.\n * @param {string} [options.vertexShaderText] The custom vertex shader as a string of GLSL code. It must include a GLSL function called vertexMain. See the example for the expected signature. If not specified, the custom vertex shader step will be skipped in the computed vertex shader.\n * @param {string} [options.fragmentShaderText] The custom fragment shader as a string of GLSL code. It must include a GLSL function called fragmentMain. See the example for the expected signature. If not specified, the custom fragment shader step will be skipped in the computed fragment shader.\n *\n * @alias CustomShader\n * @constructor\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n *\n * @example\n * const customShader = new CustomShader({\n *   uniforms: {\n *     u_colorIndex: {\n *       type: Cesium.UniformType.FLOAT,\n *       value: 1.0\n *     },\n *     u_normalMap: {\n *       type: Cesium.UniformType.SAMPLER_2D,\n *       value: new Cesium.TextureUniform({\n *         url: \"http://example.com/normal.png\"\n *       })\n *     }\n *   },\n *   varyings: {\n *     v_selectedColor: Cesium.VaryingType.VEC3\n *   },\n *   vertexShaderText: `\n *   void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput) {\n *     v_selectedColor = mix(vsInput.attributes.color_0, vsInput.attributes.color_1, u_colorIndex);\n *     vsOutput.positionMC += 0.1 * vsInput.attributes.normal;\n *   }\n *   `,\n *   fragmentShaderText: `\n *   void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material) {\n *     material.normal = texture(u_normalMap, fsInput.attributes.texCoord_0);\n *     material.diffuse = v_selectedColor;\n *   }\n *   `\n * });\n */\nfunction CustomShader(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  /**\n   * A value determining how the custom shader interacts with the overall\n   * fragment shader. This is used by {@link CustomShaderPipelineStage}\n   *\n   * @type {CustomShaderMode}\n   * @readonly\n   */\n  this.mode = options.mode ?? CustomShaderMode.MODIFY_MATERIAL;\n  /**\n   * The lighting model to use when using the custom shader.\n   * This is used by {@link CustomShaderPipelineStage}\n   *\n   * @type {LightingModel}\n   * @readonly\n   */\n  this.lightingModel = options.lightingModel;\n  /**\n   * Additional uniforms as declared by the user.\n   *\n   * @type {Object<string, UniformSpecifier>}\n   * @readonly\n   */\n  this.uniforms = options.uniforms ?? Frozen.EMPTY_OBJECT;\n  /**\n   * Additional varyings as declared by the user.\n   * This is used by {@link CustomShaderPipelineStage}\n   *\n   * @type {Object<string, VaryingType>}\n   * @readonly\n   */\n  this.varyings = options.varyings ?? Frozen.EMPTY_OBJECT;\n  /**\n   * The user-defined GLSL code for the vertex shader\n   *\n   * @type {string}\n   * @readonly\n   */\n  this.vertexShaderText = options.vertexShaderText;\n  /**\n   * The user-defined GLSL code for the fragment shader\n   *\n   * @type {string}\n   * @readonly\n   */\n  this.fragmentShaderText = options.fragmentShaderText;\n\n  /**\n   * The translucency mode, which determines how the custom shader will be applied. If the value is\n   * CustomShaderTransulcencyMode.OPAQUE or CustomShaderTransulcencyMode.TRANSLUCENT, the custom shader\n   * will override settings from the model's material. If the value isCustomShaderTransulcencyMode.INHERIT,\n   * the custom shader will render as either opaque or translucent depending on the primitive's material settings.\n   *\n   * @type {CustomShaderTranslucencyMode}\n   * @default CustomShaderTranslucencyMode.INHERIT\n   * @readonly\n   */\n  this.translucencyMode =\n    options.translucencyMode ?? CustomShaderTranslucencyMode.INHERIT;\n\n  /**\n   * texture uniforms require some asynchronous processing. This is delegated\n   * to a texture manager.\n   *\n   * @type {TextureManager}\n   * @readonly\n   * @private\n   */\n  this._textureManager = new TextureManager();\n  /**\n   * The default texture (from the {@link Context}) to use while textures\n   * are loading\n   *\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  this._defaultTexture = undefined;\n  /**\n   * The map of uniform names to a function that returns a value. This map\n   * is combined with the overall uniform map used by the {@link DrawCommand}\n   *\n   * @type {Object<string, Function>}\n   * @readonly\n   * @private\n   */\n  this.uniformMap = buildUniformMap(this);\n\n  /**\n   * A collection of variables used in <code>vertexShaderText</code>. This\n   * is used only for optimizations in {@link CustomShaderPipelineStage}.\n   * @type {VertexVariableSets}\n   * @private\n   */\n  this.usedVariablesVertex = {\n    attributeSet: {},\n    featureIdSet: {},\n    metadataSet: {},\n  };\n  /**\n   * A collection of variables used in <code>fragmentShaderText</code>. This\n   * is used only for optimizations in {@link CustomShaderPipelineStage}.\n   * @type {FragmentVariableSets}\n   * @private\n   */\n  this.usedVariablesFragment = {\n    attributeSet: {},\n    featureIdSet: {},\n    metadataSet: {},\n    materialSet: {},\n  };\n\n  findUsedVariables(this);\n  validateBuiltinVariables(this);\n}\n\nfunction buildUniformMap(customShader) {\n  const uniforms = customShader.uniforms;\n  const uniformMap = {};\n  for (const uniformName in uniforms) {\n    if (uniforms.hasOwnProperty(uniformName)) {\n      const uniform = uniforms[uniformName];\n      const type = uniform.type;\n      //>>includeStart('debug', pragmas.debug);\n      if (type === UniformType.SAMPLER_CUBE) {\n        throw new DeveloperError(\n          \"CustomShader does not support samplerCube uniforms\",\n        );\n      }\n      //>>includeEnd('debug');\n\n      if (type === UniformType.SAMPLER_2D) {\n        customShader._textureManager.loadTexture2D(uniformName, uniform.value);\n        uniformMap[uniformName] = createUniformTexture2DFunction(\n          customShader,\n          uniformName,\n        );\n      } else {\n        uniformMap[uniformName] = createUniformFunction(\n          customShader,\n          uniformName,\n        );\n      }\n    }\n  }\n  return uniformMap;\n}\n\nfunction createUniformTexture2DFunction(customShader, uniformName) {\n  return function () {\n    return (\n      customShader._textureManager.getTexture(uniformName) ??\n      customShader._defaultTexture\n    );\n  };\n}\n\nfunction createUniformFunction(customShader, uniformName) {\n  return function () {\n    return customShader.uniforms[uniformName].value;\n  };\n}\n\nfunction getVariables(shaderText, regex, outputSet) {\n  let match;\n  while ((match = regex.exec(shaderText)) !== null) {\n    const variableName = match[1];\n\n    // Using a dictionary like a set. The value doesn't\n    // matter, as this will only be used for queries such as\n    // if (set.hasOwnProperty(variableName)) { ... }\n    outputSet[variableName] = true;\n  }\n}\n\nfunction findUsedVariables(customShader) {\n  const attributeRegex = /[vf]sInput\\.attributes\\.(\\w+)/g;\n  const featureIdRegex = /[vf]sInput\\.featureIds\\.(\\w+)/g;\n  const metadataRegex = /[vf]sInput\\.metadata.(\\w+)/g;\n  let attributeSet;\n\n  const vertexShaderText = customShader.vertexShaderText;\n  if (defined(vertexShaderText)) {\n    attributeSet = customShader.usedVariablesVertex.attributeSet;\n    getVariables(vertexShaderText, attributeRegex, attributeSet);\n\n    attributeSet = customShader.usedVariablesVertex.featureIdSet;\n    getVariables(vertexShaderText, featureIdRegex, attributeSet);\n\n    attributeSet = customShader.usedVariablesVertex.metadataSet;\n    getVariables(vertexShaderText, metadataRegex, attributeSet);\n  }\n\n  const fragmentShaderText = customShader.fragmentShaderText;\n  if (defined(fragmentShaderText)) {\n    attributeSet = customShader.usedVariablesFragment.attributeSet;\n    getVariables(fragmentShaderText, attributeRegex, attributeSet);\n\n    attributeSet = customShader.usedVariablesFragment.featureIdSet;\n    getVariables(fragmentShaderText, featureIdRegex, attributeSet);\n\n    attributeSet = customShader.usedVariablesFragment.metadataSet;\n    getVariables(fragmentShaderText, metadataRegex, attributeSet);\n\n    const materialRegex = /material\\.(\\w+)/g;\n    const materialSet = customShader.usedVariablesFragment.materialSet;\n    getVariables(fragmentShaderText, materialRegex, materialSet);\n  }\n}\n\nfunction expandCoordinateAbbreviations(variableName) {\n  const modelCoordinatesRegex = /^.*MC$/;\n  const worldCoordinatesRegex = /^.*WC$/;\n  const eyeCoordinatesRegex = /^.*EC$/;\n\n  if (modelCoordinatesRegex.test(variableName)) {\n    return `${variableName} (model coordinates)`;\n  }\n\n  if (worldCoordinatesRegex.test(variableName)) {\n    return `${variableName} (Cartesian world coordinates)`;\n  }\n\n  if (eyeCoordinatesRegex.test(variableName)) {\n    return `${variableName} (eye coordinates)`;\n  }\n\n  return variableName;\n}\n\nfunction validateVariableUsage(\n  variableSet,\n  incorrectVariable,\n  correctVariable,\n  vertexOrFragment,\n) {\n  if (variableSet.hasOwnProperty(incorrectVariable)) {\n    const message = `${expandCoordinateAbbreviations(\n      incorrectVariable,\n    )} is not available in the ${vertexOrFragment} shader. Did you mean ${expandCoordinateAbbreviations(\n      correctVariable,\n    )} instead?`;\n    throw new DeveloperError(message);\n  }\n}\n\nfunction validateBuiltinVariables(customShader) {\n  const attributesVS = customShader.usedVariablesVertex.attributeSet;\n\n  // names without MC/WC/EC are ambiguous\n  validateVariableUsage(attributesVS, \"position\", \"positionMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"normal\", \"normalMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"tangent\", \"tangentMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"bitangent\", \"bitangentMC\", \"vertex\");\n\n  // world and eye coordinate positions are only available in the fragment shader.\n  validateVariableUsage(attributesVS, \"positionWC\", \"positionMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"positionEC\", \"positionMC\", \"vertex\");\n\n  // normal, tangent and bitangent are in model coordinates in the vertex shader\n  validateVariableUsage(attributesVS, \"normalEC\", \"normalMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"tangentEC\", \"tangentMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"bitangentEC\", \"bitangentMC\", \"vertex\");\n\n  const attributesFS = customShader.usedVariablesFragment.attributeSet;\n\n  // names without MC/WC/EC are ambiguous\n  validateVariableUsage(attributesFS, \"position\", \"positionEC\", \"fragment\");\n  validateVariableUsage(attributesFS, \"normal\", \"normalEC\", \"fragment\");\n  validateVariableUsage(attributesFS, \"tangent\", \"tangentEC\", \"fragment\");\n  validateVariableUsage(attributesFS, \"bitangent\", \"bitangentEC\", \"fragment\");\n\n  // normal, tangent, and bitangent are in eye coordinates in the fragment\n  // shader.\n  validateVariableUsage(attributesFS, \"normalMC\", \"normalEC\", \"fragment\");\n  validateVariableUsage(attributesFS, \"tangentMC\", \"tangentEC\", \"fragment\");\n  validateVariableUsage(attributesFS, \"bitangentMC\", \"bitangentEC\", \"fragment\");\n}\n\n/**\n * Update the value of a uniform declared in the shader\n * @param {string} uniformName The GLSL name of the uniform. This must match one of the uniforms declared in the constructor\n * @param {boolean|number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4|string|Resource|TextureUniform} value The new value of the uniform.\n */\nCustomShader.prototype.setUniform = function (uniformName, value) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"uniformName\", uniformName);\n  Check.defined(\"value\", value);\n  if (!defined(this.uniforms[uniformName])) {\n    throw new DeveloperError(\n      `Uniform ${uniformName} must be declared in the CustomShader constructor.`,\n    );\n  }\n  //>>includeEnd('debug');\n  const uniform = this.uniforms[uniformName];\n  if (uniform.type === UniformType.SAMPLER_2D) {\n    // Textures are loaded asynchronously\n    this._textureManager.loadTexture2D(uniformName, value);\n  } else if (defined(value.clone)) {\n    // clone Cartesian and Matrix types.\n    uniform.value = value.clone(uniform.value);\n  } else {\n    uniform.value = value;\n  }\n};\n\nCustomShader.prototype.update = function (frameState) {\n  this._defaultTexture = frameState.context.defaultTexture;\n  this._textureManager.update(frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see CustomShader#destroy\n */\nCustomShader.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * customShader = customShader && customShader.destroy();\n *\n * @see CustomShader#isDestroyed\n */\nCustomShader.prototype.destroy = function () {\n  this._textureManager = this._textureManager && this._textureManager.destroy();\n  destroyObject(this);\n};\n\nexport default CustomShader;\n"],"names":["CustomShader","options","EMPTY_OBJECT","mode","MODIFY_MATERIAL","lightingModel","uniforms","varyings","vertexShaderText","fragmentShaderText","translucencyMode","INHERIT","_textureManager","_defaultTexture","undefined","uniformMap","buildUniformMap","usedVariablesVertex","attributeSet","featureIdSet","metadataSet","usedVariablesFragment","materialSet","findUsedVariables","validateBuiltinVariables","customShader","uniformName","hasOwnProperty","uniform","type","SAMPLER_CUBE","SAMPLER_2D","loadTexture2D","value","createUniformTexture2DFunction","createUniformFunction","getTexture","getVariables","shaderText","regex","outputSet","match","exec","variableName","attributeRegex","featureIdRegex","metadataRegex","materialRegex","expandCoordinateAbbreviations","modelCoordinatesRegex","worldCoordinatesRegex","eyeCoordinatesRegex","test","validateVariableUsage","variableSet","incorrectVariable","correctVariable","vertexOrFragment","message","attributesVS","attributesFS","prototype","setUniform","typeOf","string","defined","clone","update","frameState","context","defaultTexture","isDestroyed","destroy"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 22803, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/TextureUniform.js"],"sourcesContent":["import Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Resource from \"../../Core/Resource.js\";\nimport PixelFormat from \"../../Core/PixelFormat.js\";\nimport PixelDatatype from \"../../Renderer/PixelDatatype.js\";\nimport Sampler from \"../../Renderer/Sampler.js\";\nimport TextureWrap from \"../../Renderer/TextureWrap.js\";\n\n/**\n * A simple struct that serves as a value of a <code>sampler2D</code>-valued\n * uniform. This is used with {@link CustomShader} and {@link TextureManager}\n *\n * @param {object} options An object with the following properties:\n * @param {Uint8Array} [options.typedArray] A typed array storing the contents of a texture. Values are stored in row-major order. Since WebGL uses a y-up convention for textures, rows are listed from bottom to top.\n * @param {number} [options.width] The width of the image. Required when options.typedArray is present\n * @param {number} [options.height] The height of the image. Required when options.typedArray is present.\n * @param {string|Resource} [options.url] A URL string or resource pointing to a texture image.\n * @param {boolean} [options.repeat=true] When defined, the texture sampler will be set to wrap in both directions\n * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGBA] When options.typedArray is defined, this is used to determine the pixel format of the texture\n * @param {PixelDatatype} [options.pixelDatatype=PixelDatatype.UNSIGNED_BYTE] When options.typedArray is defined, this is the data type of pixel values in the typed array.\n * @param {TextureMinificationFilter} [options.minificationFilter=TextureMinificationFilter.LINEAR] The minification filter of the texture sampler.\n * @param {TextureMagnificationFilter} [options.magnificationFilter=TextureMagnificationFilter.LINEAR] The magnification filter of the texture sampler.\n * @param {number} [options.maximumAnisotropy=1.0] The maximum anisotropy of the texture sampler\n *\n * @alias TextureUniform\n * @constructor\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction TextureUniform(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  //>>includeStart('debug', pragmas.debug);\n  const hasTypedArray = defined(options.typedArray);\n  const hasUrl = defined(options.url);\n  if (hasTypedArray === hasUrl) {\n    throw new DeveloperError(\n      \"exactly one of options.typedArray, options.url must be defined\",\n    );\n  }\n  if (hasTypedArray && (!defined(options.width) || !defined(options.height))) {\n    throw new DeveloperError(\n      \"options.width and options.height are required when options.typedArray is defined\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this.typedArray = options.typedArray;\n  this.width = options.width;\n  this.height = options.height;\n  this.pixelFormat = options.pixelFormat ?? PixelFormat.RGBA;\n  this.pixelDatatype = options.pixelDatatype ?? PixelDatatype.UNSIGNED_BYTE;\n\n  let resource = options.url;\n  if (typeof resource === \"string\") {\n    resource = Resource.createIfNeeded(resource);\n  }\n  this.resource = resource;\n\n  const repeat = options.repeat ?? true;\n  const wrap = repeat ? TextureWrap.REPEAT : TextureWrap.CLAMP_TO_EDGE;\n  this.sampler = new Sampler({\n    wrapS: wrap,\n    wrapT: wrap,\n    minificationFilter: options.minificationFilter,\n    magnificationFilter: options.magnificationFilter,\n    maximumAnisotropy: options.maximumAnisotropy,\n  });\n}\n\nexport default TextureUniform;\n"],"names":["TextureUniform","options","EMPTY_OBJECT","hasTypedArray","typedArray","hasUrl","url","width","height","pixelFormat","RGBA","pixelDatatype","UNSIGNED_BYTE","resource","createIfNeeded","repeat","wrap","REPEAT","CLAMP_TO_EDGE","sampler","wrapS","wrapT","minificationFilter","magnificationFilter","maximumAnisotropy"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;CAoBC,GACD,SAASA,eAAeC,OAAO;IAC7BA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IACxC,yCAAyC;IACzC,MAAMC,gBAAgB,IAAA,6KAAO,EAACF,QAAQG,UAAU;IAChD,MAAMC,SAAS,IAAA,6KAAO,EAACJ,QAAQK,GAAG;IAClC,IAAIH,kBAAkBE,QAAQ;QAC5B,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,IAAIF,iBAAiB,CAAC,CAAC,IAAA,6KAAO,EAACF,QAAQM,KAAK,KAAK,CAAC,IAAA,6KAAO,EAACN,QAAQO,MAAM,CAAC,GAAG;QAC1E,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,wBAAwB;IAExB,IAAI,CAACJ,UAAU,GAAGH,QAAQG,UAAU;IACpC,IAAI,CAACG,KAAK,GAAGN,QAAQM,KAAK;IAC1B,IAAI,CAACC,MAAM,GAAGP,QAAQO,MAAM;IAC5B,IAAI,CAACC,WAAW,GAAGR,QAAQQ,WAAW,IAAI,iLAAW,CAACC,IAAI;IAC1D,IAAI,CAACC,aAAa,GAAGV,QAAQU,aAAa,IAAI,uLAAa,CAACC,aAAa;IAEzE,IAAIC,WAAWZ,QAAQK,GAAG;IAC1B,IAAI,OAAOO,aAAa,UAAU;QAChCA,WAAW,8KAAQ,CAACC,cAAc,CAACD;IACrC;IACA,IAAI,CAACA,QAAQ,GAAGA;IAEhB,MAAME,SAASd,QAAQc,MAAM,IAAI;IACjC,MAAMC,OAAOD,SAAS,qLAAW,CAACE,MAAM,GAAG,qLAAW,CAACC,aAAa;IACpE,IAAI,CAACC,OAAO,GAAG,IAAI,iLAAO,CAAC;QACzBC,OAAOJ;QACPK,OAAOL;QACPM,oBAAoBrB,QAAQqB,kBAAkB;QAC9CC,qBAAqBtB,QAAQsB,mBAAmB;QAChDC,mBAAmBvB,QAAQuB,iBAAiB;IAC9C;AACF;uCAEexB","ignoreList":[0]}},
    {"offset": {"line": 22907, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Model/VaryingType.js"],"sourcesContent":["/**\n * An enum for the GLSL varying types. These can be used for declaring varyings\n * in {@link CustomShader}\n *\n * @enum {string}\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst VaryingType = {\n  /**\n   * A single floating point value.\n   *\n   * @type {string}\n   * @constant\n   */\n  FLOAT: \"float\",\n  /**\n   * A vector of 2 floating point values.\n   *\n   * @type {string}\n   * @constant\n   */\n  VEC2: \"vec2\",\n  /**\n   * A vector of 3 floating point values.\n   *\n   * @type {string}\n   * @constant\n   */\n  VEC3: \"vec3\",\n  /**\n   * A vector of 4 floating point values.\n   *\n   * @type {string}\n   * @constant\n   */\n  VEC4: \"vec4\",\n  /**\n   * A 2x2 matrix of floating point values.\n   *\n   * @type {string}\n   * @constant\n   */\n  MAT2: \"mat2\",\n  /**\n   * A 3x3 matrix of floating point values.\n   *\n   * @type {string}\n   * @constant\n   */\n  MAT3: \"mat3\",\n  /**\n   * A 4x4 matrix of floating point values.\n   *\n   * @type {string}\n   * @constant\n   */\n  MAT4: \"mat4\",\n};\n\nexport default Object.freeze(VaryingType);\n"],"names":["VaryingType","FLOAT","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","Object","freeze"],"mappings":";;;;AAAA;;;;;;;CAOC,GACD,MAAMA,cAAc;IAClB;;;;;GAKC,GACDC,OAAO;IACP;;;;;GAKC,GACDC,MAAM;IACN;;;;;GAKC,GACDC,MAAM;IACN;;;;;GAKC,GACDC,MAAM;IACN;;;;;GAKC,GACDC,MAAM;IACN;;;;;GAKC,GACDC,MAAM;IACN;;;;;GAKC,GACDC,MAAM;AACR;uCAEeC,OAAOC,MAAM,CAACT","ignoreList":[0]}}]
}