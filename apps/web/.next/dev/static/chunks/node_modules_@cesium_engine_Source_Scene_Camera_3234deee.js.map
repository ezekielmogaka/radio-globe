{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Camera.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidGeodesic from \"../Core/EllipsoidGeodesic.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport HeadingPitchRange from \"../Core/HeadingPitchRange.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraFlightPath from \"./CameraFlightPath.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * @typedef {object} DirectionUp\n *\n * An orientation given by a pair of unit vectors\n *\n * @property {Cartesian3} direction The unit \"direction\" vector\n * @property {Cartesian3} up The unit \"up\" vector\n **/\n/**\n * @typedef {object} HeadingPitchRollValues\n *\n * An orientation given by numeric heading, pitch, and roll\n *\n * @property {number} [heading=0.0] The heading in radians\n * @property {number} [pitch=-CesiumMath.PI_OVER_TWO] The pitch in radians\n * @property {number} [roll=0.0] The roll in radians\n **/\n\n/**\n * The camera is defined by a position, orientation, and view frustum.\n * <br /><br />\n * The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.\n * <br /><br />\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias Camera\n *\n * @constructor\n *\n * @param {Scene} scene The scene.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera.html|Cesium Sandcastle Camera Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera%20Tutorial.html|Cesium Sandcastle Camera Tutorial Example}\n * @demo {@link https://cesium.com/learn/cesiumjs-learn/cesiumjs-camera|Camera Tutorial}\n *\n * @example\n * // Create a camera looking down the negative z-axis, positioned at the origin,\n * // with a field of view of 60 degrees, and 1:1 aspect ratio.\n * const camera = new Cesium.Camera(scene);\n * camera.position = new Cesium.Cartesian3();\n * camera.direction = Cesium.Cartesian3.negate(Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());\n * camera.up = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Y);\n * camera.frustum.fov = Cesium.Math.PI_OVER_THREE;\n * camera.frustum.near = 1.0;\n * camera.frustum.far = 2.0;\n */\nfunction Camera(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n  this._scene = scene;\n\n  this._transform = Matrix4.clone(Matrix4.IDENTITY);\n  this._invTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._actualTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._actualInvTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._transformChanged = false;\n\n  /**\n   * The position of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.position = new Cartesian3();\n  this._position = new Cartesian3();\n  this._positionWC = new Cartesian3();\n  this._positionCartographic = new Cartographic();\n  this._oldPositionWC = undefined;\n\n  /**\n   * The position delta magnitude.\n   *\n   * @private\n   */\n  this.positionWCDeltaMagnitude = 0.0;\n\n  /**\n   * The position delta magnitude last frame.\n   *\n   * @private\n   */\n  this.positionWCDeltaMagnitudeLastFrame = 0.0;\n\n  /**\n   * How long in seconds since the camera has stopped moving\n   *\n   * @private\n   */\n  this.timeSinceMoved = 0.0;\n  this._lastMovedTimestamp = 0.0;\n\n  /**\n   * The view direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.direction = new Cartesian3();\n  this._direction = new Cartesian3();\n  this._directionWC = new Cartesian3();\n\n  /**\n   * The up direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.up = new Cartesian3();\n  this._up = new Cartesian3();\n  this._upWC = new Cartesian3();\n\n  /**\n   * The right direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.right = new Cartesian3();\n  this._right = new Cartesian3();\n  this._rightWC = new Cartesian3();\n\n  /**\n   * The region of space in view.\n   *\n   * @type {PerspectiveFrustum|PerspectiveOffCenterFrustum|OrthographicFrustum}\n   * @default PerspectiveFrustum()\n   *\n   * @see PerspectiveFrustum\n   * @see PerspectiveOffCenterFrustum\n   * @see OrthographicFrustum\n   */\n  this.frustum = new PerspectiveFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = CesiumMath.toRadians(60.0);\n\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the move methods.\n   * @type {number}\n   * @default 100000.0;\n   */\n  this.defaultMoveAmount = 100000.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the look methods.\n   * @type {number}\n   * @default Math.PI / 60.0\n   */\n  this.defaultLookAmount = Math.PI / 60.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the rotate methods.\n   * @type {number}\n   * @default Math.PI / 3600.0\n   */\n  this.defaultRotateAmount = Math.PI / 3600.0;\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the zoom methods.\n   * @type {number}\n   * @default 100000.0;\n   */\n  this.defaultZoomAmount = 100000.0;\n  /**\n   * If set, the camera will not be able to rotate past this axis in either direction.\n   * @type {Cartesian3 | undefined}\n   * @default undefined\n   */\n  this.constrainedAxis = undefined;\n  /**\n   * The factor multiplied by the the map size used to determine where to clamp the camera position\n   * when zooming out from the surface. The default is 1.5. Only valid for 2D and the map is rotatable.\n   * @type {number}\n   * @default 1.5\n   */\n  this.maximumZoomFactor = 1.5;\n\n  this._moveStart = new Event();\n  this._moveEnd = new Event();\n\n  this._changed = new Event();\n  this._changedPosition = undefined;\n  this._changedDirection = undefined;\n  this._changedFrustum = undefined;\n  this._changedHeading = undefined;\n  this._changedRoll = undefined;\n\n  /**\n   * The amount the camera has to change before the <code>changed</code> event is raised. The value is a percentage in the [0, 1] range.\n   * @type {number}\n   * @default 0.5\n   */\n  this.percentageChanged = 0.5;\n\n  this._viewMatrix = new Matrix4();\n  this._invViewMatrix = new Matrix4();\n  updateViewMatrix(this);\n\n  this._mode = SceneMode.SCENE3D;\n  this._modeChanged = true;\n  const projection = scene.mapProjection;\n  this._projection = projection;\n  this._maxCoord = projection.project(\n    new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO),\n  );\n  this._max2Dfrustum = undefined;\n\n  // set default view\n  rectangleCameraPosition3D(\n    this,\n    Camera.DEFAULT_VIEW_RECTANGLE,\n    this.position,\n    true,\n  );\n\n  let mag = Cartesian3.magnitude(this.position);\n  mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n  Cartesian3.normalize(this.position, this.position);\n  Cartesian3.multiplyByScalar(this.position, mag, this.position);\n}\n\n/**\n * @private\n */\nCamera.TRANSFORM_2D = new Matrix4(\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0,\n);\n\n/**\n * @private\n */\nCamera.TRANSFORM_2D_INVERSE = Matrix4.inverseTransformation(\n  Camera.TRANSFORM_2D,\n  new Matrix4(),\n);\n\n/**\n * The default rectangle the camera will view on creation.\n * @type Rectangle\n */\nCamera.DEFAULT_VIEW_RECTANGLE = Rectangle.fromDegrees(\n  -95.0,\n  -20.0,\n  -70.0,\n  90.0,\n);\n\n/**\n * A scalar to multiply to the camera position and add it back after setting the camera to view the rectangle.\n * A value of zero means the camera will view the entire {@link Camera#DEFAULT_VIEW_RECTANGLE}, a value greater than zero\n * will move it further away from the extent, and a value less than zero will move it close to the extent.\n * @type {number}\n */\nCamera.DEFAULT_VIEW_FACTOR = 0.5;\n\n/**\n * The default heading/pitch/range that is used when the camera flies to a location that contains a bounding sphere.\n * @type HeadingPitchRange\n */\nCamera.DEFAULT_OFFSET = new HeadingPitchRange(\n  0.0,\n  -CesiumMath.PI_OVER_FOUR,\n  0.0,\n);\n\nfunction updateViewMatrix(camera) {\n  Matrix4.computeView(\n    camera._position,\n    camera._direction,\n    camera._up,\n    camera._right,\n    camera._viewMatrix,\n  );\n  Matrix4.multiply(\n    camera._viewMatrix,\n    camera._actualInvTransform,\n    camera._viewMatrix,\n  );\n  Matrix4.inverseTransformation(camera._viewMatrix, camera._invViewMatrix);\n}\n\nfunction updateCameraDeltas(camera) {\n  if (!defined(camera._oldPositionWC)) {\n    camera._oldPositionWC = Cartesian3.clone(\n      camera.positionWC,\n      camera._oldPositionWC,\n    );\n  } else {\n    camera.positionWCDeltaMagnitudeLastFrame = camera.positionWCDeltaMagnitude;\n    const delta = Cartesian3.subtract(\n      camera.positionWC,\n      camera._oldPositionWC,\n      camera._oldPositionWC,\n    );\n    camera.positionWCDeltaMagnitude = Cartesian3.magnitude(delta);\n    camera._oldPositionWC = Cartesian3.clone(\n      camera.positionWC,\n      camera._oldPositionWC,\n    );\n\n    // Update move timers\n    if (camera.positionWCDeltaMagnitude > 0.0) {\n      camera.timeSinceMoved = 0.0;\n      camera._lastMovedTimestamp = getTimestamp();\n    } else {\n      camera.timeSinceMoved =\n        Math.max(getTimestamp() - camera._lastMovedTimestamp, 0.0) / 1000.0;\n    }\n  }\n}\n\n/**\n * Checks if there's a camera flight with preload for this camera.\n *\n * @returns {boolean} Whether or not this camera has a current flight with a valid preloadFlightCamera in scene.\n *\n * @private\n *\n */\nCamera.prototype.canPreloadFlight = function () {\n  return defined(this._currentFlight) && this._mode !== SceneMode.SCENE2D;\n};\n\nCamera.prototype._updateCameraChanged = function () {\n  const camera = this;\n\n  updateCameraDeltas(camera);\n\n  if (camera._changed.numberOfListeners === 0) {\n    return;\n  }\n\n  const percentageChanged = camera.percentageChanged;\n\n  // check heading\n  const currentHeading = camera.heading;\n\n  if (!defined(camera._changedHeading)) {\n    camera._changedHeading = currentHeading;\n  }\n\n  let headingDelta =\n    Math.abs(camera._changedHeading - currentHeading) % CesiumMath.TWO_PI;\n  headingDelta =\n    headingDelta > CesiumMath.PI\n      ? CesiumMath.TWO_PI - headingDelta\n      : headingDelta;\n\n  // Since delta is computed as the shortest distance between two angles\n  // the percentage is relative to the half circle.\n  const headingChangedPercentage = headingDelta / Math.PI;\n\n  if (headingChangedPercentage > percentageChanged) {\n    camera._changedHeading = currentHeading;\n  }\n\n  // check roll\n  const currentRoll = camera.roll;\n\n  if (!defined(camera._changedRoll)) {\n    camera._changedRoll = currentRoll;\n  }\n\n  let rollDelta =\n    Math.abs(camera._changedRoll - currentRoll) % CesiumMath.TWO_PI;\n  rollDelta =\n    rollDelta > CesiumMath.PI ? CesiumMath.TWO_PI - rollDelta : rollDelta;\n\n  // Since delta is computed as the shortest distance between two angles\n  // the percentage is relative to the half circle.\n  const rollChangedPercentage = rollDelta / Math.PI;\n\n  if (rollChangedPercentage > percentageChanged) {\n    camera._changedRoll = currentRoll;\n  }\n  if (\n    rollChangedPercentage > percentageChanged ||\n    headingChangedPercentage > percentageChanged\n  ) {\n    camera._changed.raiseEvent(\n      Math.max(rollChangedPercentage, headingChangedPercentage),\n    );\n  }\n  if (camera._mode === SceneMode.SCENE2D) {\n    if (!defined(camera._changedFrustum)) {\n      camera._changedPosition = Cartesian3.clone(\n        camera.position,\n        camera._changedPosition,\n      );\n      camera._changedFrustum = camera.frustum.clone();\n      return;\n    }\n\n    const position = camera.position;\n    const lastPosition = camera._changedPosition;\n\n    const frustum = camera.frustum;\n    const lastFrustum = camera._changedFrustum;\n\n    const x0 = position.x + frustum.left;\n    const x1 = position.x + frustum.right;\n    const x2 = lastPosition.x + lastFrustum.left;\n    const x3 = lastPosition.x + lastFrustum.right;\n\n    const y0 = position.y + frustum.bottom;\n    const y1 = position.y + frustum.top;\n    const y2 = lastPosition.y + lastFrustum.bottom;\n    const y3 = lastPosition.y + lastFrustum.top;\n\n    const leftX = Math.max(x0, x2);\n    const rightX = Math.min(x1, x3);\n    const bottomY = Math.max(y0, y2);\n    const topY = Math.min(y1, y3);\n\n    let areaPercentage;\n    if (leftX >= rightX || bottomY >= y1) {\n      areaPercentage = 1.0;\n    } else {\n      let areaRef = lastFrustum;\n      if (x0 < x2 && x1 > x3 && y0 < y2 && y1 > y3) {\n        areaRef = frustum;\n      }\n      areaPercentage =\n        1.0 -\n        ((rightX - leftX) * (topY - bottomY)) /\n          ((areaRef.right - areaRef.left) * (areaRef.top - areaRef.bottom));\n    }\n\n    if (areaPercentage > percentageChanged) {\n      camera._changed.raiseEvent(areaPercentage);\n      camera._changedPosition = Cartesian3.clone(\n        camera.position,\n        camera._changedPosition,\n      );\n      camera._changedFrustum = camera.frustum.clone(camera._changedFrustum);\n    }\n    return;\n  }\n\n  if (!defined(camera._changedDirection)) {\n    camera._changedPosition = Cartesian3.clone(\n      camera.positionWC,\n      camera._changedPosition,\n    );\n    camera._changedDirection = Cartesian3.clone(\n      camera.directionWC,\n      camera._changedDirection,\n    );\n    return;\n  }\n\n  const dirAngle = CesiumMath.acosClamped(\n    Cartesian3.dot(camera.directionWC, camera._changedDirection),\n  );\n\n  let dirPercentage;\n  if (defined(camera.frustum.fovy)) {\n    dirPercentage = dirAngle / (camera.frustum.fovy * 0.5);\n  } else {\n    dirPercentage = dirAngle;\n  }\n\n  const distance = Cartesian3.distance(\n    camera.positionWC,\n    camera._changedPosition,\n  );\n  const heightPercentage = distance / camera.positionCartographic.height;\n\n  if (\n    dirPercentage > percentageChanged ||\n    heightPercentage > percentageChanged\n  ) {\n    camera._changed.raiseEvent(Math.max(dirPercentage, heightPercentage));\n    camera._changedPosition = Cartesian3.clone(\n      camera.positionWC,\n      camera._changedPosition,\n    );\n    camera._changedDirection = Cartesian3.clone(\n      camera.directionWC,\n      camera._changedDirection,\n    );\n  }\n};\n\nfunction convertTransformForColumbusView(camera) {\n  Transforms.basisTo2D(\n    camera._projection,\n    camera._transform,\n    camera._actualTransform,\n  );\n}\n\nconst scratchCartographic = new Cartographic();\nconst scratchCartesian3Projection = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4Origin = new Cartesian4();\nconst scratchCartesian4NewOrigin = new Cartesian4();\nconst scratchCartesian4NewXAxis = new Cartesian4();\nconst scratchCartesian4NewYAxis = new Cartesian4();\nconst scratchCartesian4NewZAxis = new Cartesian4();\n\nfunction convertTransformFor2D(camera) {\n  const projection = camera._projection;\n  const ellipsoid = projection.ellipsoid;\n\n  const origin = Matrix4.getColumn(\n    camera._transform,\n    3,\n    scratchCartesian4Origin,\n  );\n  const cartographic = ellipsoid.cartesianToCartographic(\n    origin,\n    scratchCartographic,\n  );\n\n  const projectedPosition = projection.project(\n    cartographic,\n    scratchCartesian3Projection,\n  );\n  const newOrigin = scratchCartesian4NewOrigin;\n  newOrigin.x = projectedPosition.z;\n  newOrigin.y = projectedPosition.x;\n  newOrigin.z = projectedPosition.y;\n  newOrigin.w = 1.0;\n\n  const newZAxis = Cartesian4.clone(\n    Cartesian4.UNIT_X,\n    scratchCartesian4NewZAxis,\n  );\n\n  const xAxis = Cartesian4.add(\n    Matrix4.getColumn(camera._transform, 0, scratchCartesian3),\n    origin,\n    scratchCartesian3,\n  );\n  ellipsoid.cartesianToCartographic(xAxis, cartographic);\n\n  projection.project(cartographic, projectedPosition);\n  const newXAxis = scratchCartesian4NewXAxis;\n  newXAxis.x = projectedPosition.z;\n  newXAxis.y = projectedPosition.x;\n  newXAxis.z = projectedPosition.y;\n  newXAxis.w = 0.0;\n\n  Cartesian3.subtract(newXAxis, newOrigin, newXAxis);\n  newXAxis.x = 0.0;\n\n  const newYAxis = scratchCartesian4NewYAxis;\n  if (Cartesian3.magnitudeSquared(newXAxis) > CesiumMath.EPSILON10) {\n    Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  } else {\n    const yAxis = Cartesian4.add(\n      Matrix4.getColumn(camera._transform, 1, scratchCartesian3),\n      origin,\n      scratchCartesian3,\n    );\n    ellipsoid.cartesianToCartographic(yAxis, cartographic);\n\n    projection.project(cartographic, projectedPosition);\n    newYAxis.x = projectedPosition.z;\n    newYAxis.y = projectedPosition.x;\n    newYAxis.z = projectedPosition.y;\n    newYAxis.w = 0.0;\n\n    Cartesian3.subtract(newYAxis, newOrigin, newYAxis);\n    newYAxis.x = 0.0;\n\n    if (Cartesian3.magnitudeSquared(newYAxis) < CesiumMath.EPSILON10) {\n      Cartesian4.clone(Cartesian4.UNIT_Y, newXAxis);\n      Cartesian4.clone(Cartesian4.UNIT_Z, newYAxis);\n    }\n  }\n\n  Cartesian3.cross(newYAxis, newZAxis, newXAxis);\n  Cartesian3.normalize(newXAxis, newXAxis);\n  Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  Cartesian3.normalize(newYAxis, newYAxis);\n\n  Matrix4.setColumn(\n    camera._actualTransform,\n    0,\n    newXAxis,\n    camera._actualTransform,\n  );\n  Matrix4.setColumn(\n    camera._actualTransform,\n    1,\n    newYAxis,\n    camera._actualTransform,\n  );\n  Matrix4.setColumn(\n    camera._actualTransform,\n    2,\n    newZAxis,\n    camera._actualTransform,\n  );\n  Matrix4.setColumn(\n    camera._actualTransform,\n    3,\n    newOrigin,\n    camera._actualTransform,\n  );\n}\n\nconst scratchCartesian = new Cartesian3();\n\nfunction updateMembers(camera) {\n  const mode = camera._mode;\n\n  let heightChanged = false;\n  let height = 0.0;\n  if (mode === SceneMode.SCENE2D) {\n    height = camera.frustum.right - camera.frustum.left;\n    heightChanged = height !== camera._positionCartographic.height;\n  }\n\n  let position = camera._position;\n  const positionChanged =\n    !Cartesian3.equals(position, camera.position) || heightChanged;\n  if (positionChanged) {\n    position = Cartesian3.clone(camera.position, camera._position);\n  }\n\n  let direction = camera._direction;\n  const directionChanged = !Cartesian3.equals(direction, camera.direction);\n  if (directionChanged) {\n    Cartesian3.normalize(camera.direction, camera.direction);\n    direction = Cartesian3.clone(camera.direction, camera._direction);\n  }\n\n  let up = camera._up;\n  const upChanged = !Cartesian3.equals(up, camera.up);\n  if (upChanged) {\n    Cartesian3.normalize(camera.up, camera.up);\n    up = Cartesian3.clone(camera.up, camera._up);\n  }\n\n  let right = camera._right;\n  const rightChanged = !Cartesian3.equals(right, camera.right);\n  if (rightChanged) {\n    Cartesian3.normalize(camera.right, camera.right);\n    right = Cartesian3.clone(camera.right, camera._right);\n  }\n\n  const transformChanged = camera._transformChanged || camera._modeChanged;\n  camera._transformChanged = false;\n\n  if (transformChanged) {\n    Matrix4.inverseTransformation(camera._transform, camera._invTransform);\n\n    if (\n      camera._mode === SceneMode.COLUMBUS_VIEW ||\n      camera._mode === SceneMode.SCENE2D\n    ) {\n      if (Matrix4.equals(Matrix4.IDENTITY, camera._transform)) {\n        Matrix4.clone(Camera.TRANSFORM_2D, camera._actualTransform);\n      } else if (camera._mode === SceneMode.COLUMBUS_VIEW) {\n        convertTransformForColumbusView(camera);\n      } else {\n        convertTransformFor2D(camera);\n      }\n    } else {\n      Matrix4.clone(camera._transform, camera._actualTransform);\n    }\n\n    Matrix4.inverseTransformation(\n      camera._actualTransform,\n      camera._actualInvTransform,\n    );\n\n    camera._modeChanged = false;\n  }\n\n  const transform = camera._actualTransform;\n\n  if (positionChanged || transformChanged) {\n    camera._positionWC = Matrix4.multiplyByPoint(\n      transform,\n      position,\n      camera._positionWC,\n    );\n\n    // Compute the Cartographic position of the camera.\n    if (mode === SceneMode.SCENE3D || mode === SceneMode.MORPHING) {\n      camera._positionCartographic =\n        camera._projection.ellipsoid.cartesianToCartographic(\n          camera._positionWC,\n          camera._positionCartographic,\n        );\n    } else {\n      // The camera position is expressed in the 2D coordinate system where the Y axis is to the East,\n      // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where\n      // X is to the East, Y is to the North, and Z is out of the local horizontal plane.\n      const positionENU = scratchCartesian;\n      positionENU.x = camera._positionWC.y;\n      positionENU.y = camera._positionWC.z;\n      positionENU.z = camera._positionWC.x;\n\n      // In 2D, the camera height is always 12.7 million meters.\n      // The apparent height is equal to half the frustum width.\n      if (mode === SceneMode.SCENE2D) {\n        positionENU.z = height;\n      }\n\n      camera._projection.unproject(positionENU, camera._positionCartographic);\n    }\n  }\n\n  if (directionChanged || upChanged || rightChanged) {\n    const det = Cartesian3.dot(\n      direction,\n      Cartesian3.cross(up, right, scratchCartesian),\n    );\n    if (Math.abs(1.0 - det) > CesiumMath.EPSILON2) {\n      //orthonormalize axes\n      const invUpMag = 1.0 / Cartesian3.magnitudeSquared(up);\n      const scalar = Cartesian3.dot(up, direction) * invUpMag;\n      const w0 = Cartesian3.multiplyByScalar(\n        direction,\n        scalar,\n        scratchCartesian,\n      );\n      up = Cartesian3.normalize(\n        Cartesian3.subtract(up, w0, camera._up),\n        camera._up,\n      );\n      Cartesian3.clone(up, camera.up);\n\n      right = Cartesian3.cross(direction, up, camera._right);\n      Cartesian3.clone(right, camera.right);\n    }\n  }\n\n  if (directionChanged || transformChanged) {\n    camera._directionWC = Matrix4.multiplyByPointAsVector(\n      transform,\n      direction,\n      camera._directionWC,\n    );\n    Cartesian3.normalize(camera._directionWC, camera._directionWC);\n  }\n\n  if (upChanged || transformChanged) {\n    camera._upWC = Matrix4.multiplyByPointAsVector(transform, up, camera._upWC);\n    Cartesian3.normalize(camera._upWC, camera._upWC);\n  }\n\n  if (rightChanged || transformChanged) {\n    camera._rightWC = Matrix4.multiplyByPointAsVector(\n      transform,\n      right,\n      camera._rightWC,\n    );\n    Cartesian3.normalize(camera._rightWC, camera._rightWC);\n  }\n\n  if (\n    positionChanged ||\n    directionChanged ||\n    upChanged ||\n    rightChanged ||\n    transformChanged\n  ) {\n    updateViewMatrix(camera);\n  }\n}\n\nfunction getHeading(direction, up) {\n  let heading;\n  if (\n    !CesiumMath.equalsEpsilon(Math.abs(direction.z), 1.0, CesiumMath.EPSILON3)\n  ) {\n    heading = Math.atan2(direction.y, direction.x) - CesiumMath.PI_OVER_TWO;\n  } else {\n    heading = Math.atan2(up.y, up.x) - CesiumMath.PI_OVER_TWO;\n  }\n\n  return CesiumMath.TWO_PI - CesiumMath.zeroToTwoPi(heading);\n}\n\nfunction getPitch(direction) {\n  return CesiumMath.PI_OVER_TWO - CesiumMath.acosClamped(direction.z);\n}\n\nfunction getRoll(direction, up, right) {\n  let roll = 0.0;\n  if (\n    !CesiumMath.equalsEpsilon(Math.abs(direction.z), 1.0, CesiumMath.EPSILON3)\n  ) {\n    roll = Math.atan2(-right.z, up.z);\n    roll = CesiumMath.zeroToTwoPi(roll + CesiumMath.TWO_PI);\n  }\n\n  return roll;\n}\n\nconst scratchHPRMatrix1 = new Matrix4();\nconst scratchHPRMatrix2 = new Matrix4();\n\nObject.defineProperties(Camera.prototype, {\n  /**\n   * Gets the camera's reference frame. The inverse of this transformation is appended to the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  transform: {\n    get: function () {\n      return this._transform;\n    },\n  },\n\n  /**\n   * Gets the inverse camera transform.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  inverseTransform: {\n    get: function () {\n      updateMembers(this);\n      return this._invTransform;\n    },\n  },\n\n  /**\n   * Gets the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#inverseViewMatrix\n   */\n  viewMatrix: {\n    get: function () {\n      updateMembers(this);\n      return this._viewMatrix;\n    },\n  },\n\n  /**\n   * Gets the inverse view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#viewMatrix\n   */\n  inverseViewMatrix: {\n    get: function () {\n      updateMembers(this);\n      return this._invViewMatrix;\n    },\n  },\n\n  /**\n   * Gets the {@link Cartographic} position of the camera, with longitude and latitude\n   * expressed in radians and height in meters.  In 2D and Columbus View, it is possible\n   * for the returned longitude and latitude to be outside the range of valid longitudes\n   * and latitudes when the camera is outside the map.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartographic}\n   * @readonly\n   */\n  positionCartographic: {\n    get: function () {\n      updateMembers(this);\n      return this._positionCartographic;\n    },\n  },\n\n  /**\n   * Gets the position of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  positionWC: {\n    get: function () {\n      updateMembers(this);\n      return this._positionWC;\n    },\n  },\n\n  /**\n   * Gets the view direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  directionWC: {\n    get: function () {\n      updateMembers(this);\n      return this._directionWC;\n    },\n  },\n\n  /**\n   * Gets the up direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  upWC: {\n    get: function () {\n      updateMembers(this);\n      return this._upWC;\n    },\n  },\n\n  /**\n   * Gets the right direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  rightWC: {\n    get: function () {\n      updateMembers(this);\n      return this._rightWC;\n    },\n  },\n\n  /**\n   * Gets the camera heading in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  heading: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        const ellipsoid = this._projection.ellipsoid;\n\n        const oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        const transform = Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2,\n        );\n        this._setTransform(transform);\n\n        const heading = getHeading(this.direction, this.up);\n\n        this._setTransform(oldTransform);\n\n        return heading;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the camera pitch in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  pitch: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        const ellipsoid = this._projection.ellipsoid;\n\n        const oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        const transform = Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2,\n        );\n        this._setTransform(transform);\n\n        const pitch = getPitch(this.direction);\n\n        this._setTransform(oldTransform);\n\n        return pitch;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the camera roll in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  roll: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        const ellipsoid = this._projection.ellipsoid;\n\n        const oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        const transform = Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2,\n        );\n        this._setTransform(transform);\n\n        const roll = getRoll(this.direction, this.up, this.right);\n\n        this._setTransform(oldTransform);\n\n        return roll;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised at when the camera starts to move.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveStart: {\n    get: function () {\n      return this._moveStart;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised when the camera has stopped moving.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveEnd: {\n    get: function () {\n      return this._moveEnd;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised when the camera has changed by <code>percentageChanged</code>.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  changed: {\n    get: function () {\n      return this._changed;\n    },\n  },\n});\n\n/**\n * @private\n */\nCamera.prototype.update = function (mode) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(mode)) {\n    throw new DeveloperError(\"mode is required.\");\n  }\n  if (\n    mode === SceneMode.SCENE2D &&\n    !(this.frustum instanceof OrthographicOffCenterFrustum)\n  ) {\n    throw new DeveloperError(\n      \"An OrthographicOffCenterFrustum is required in 2D.\",\n    );\n  }\n  if (\n    (mode === SceneMode.SCENE3D || mode === SceneMode.COLUMBUS_VIEW) &&\n    !(this.frustum instanceof PerspectiveFrustum) &&\n    !(this.frustum instanceof OrthographicFrustum)\n  ) {\n    throw new DeveloperError(\n      \"A PerspectiveFrustum or OrthographicFrustum is required in 3D and Columbus view\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  let updateFrustum = false;\n  if (mode !== this._mode) {\n    this._mode = mode;\n    this._modeChanged = mode !== SceneMode.MORPHING;\n    updateFrustum = this._mode === SceneMode.SCENE2D;\n  }\n\n  if (updateFrustum) {\n    const frustum = (this._max2Dfrustum = this.frustum.clone());\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!(frustum instanceof OrthographicOffCenterFrustum)) {\n      throw new DeveloperError(\n        \"The camera frustum is expected to be orthographic for 2D camera control.\",\n      );\n    }\n    //>>includeEnd('debug');\n\n    const maxZoomOut = 2.0;\n    const ratio = frustum.top / frustum.right;\n    frustum.right = this._maxCoord.x * maxZoomOut;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n  }\n\n  if (this._mode === SceneMode.SCENE2D) {\n    clampMove2D(this, this.position);\n  }\n};\n\nconst setTransformPosition = new Cartesian3();\nconst setTransformUp = new Cartesian3();\nconst setTransformDirection = new Cartesian3();\n\nCamera.prototype._setTransform = function (transform) {\n  const position = Cartesian3.clone(this.positionWC, setTransformPosition);\n  const up = Cartesian3.clone(this.upWC, setTransformUp);\n  const direction = Cartesian3.clone(this.directionWC, setTransformDirection);\n\n  Matrix4.clone(transform, this._transform);\n  this._transformChanged = true;\n  updateMembers(this);\n  const inverse = this._actualInvTransform;\n\n  Matrix4.multiplyByPoint(inverse, position, this.position);\n  Matrix4.multiplyByPointAsVector(inverse, direction, this.direction);\n  Matrix4.multiplyByPointAsVector(inverse, up, this.up);\n  Cartesian3.cross(this.direction, this.up, this.right);\n\n  updateMembers(this);\n};\n\nconst scratchAdjustOrthographicFrustumMousePosition = new Cartesian2();\nconst scratchPickRay = new Ray();\nconst scratchRayIntersection = new Cartesian3();\nconst scratchDepthIntersection = new Cartesian3();\n\nfunction calculateOrthographicFrustumWidth(camera) {\n  // Camera is fixed to an object, so keep frustum width constant.\n  if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {\n    return Cartesian3.magnitude(camera.position);\n  }\n\n  const scene = camera._scene;\n  const globe = scene.globe;\n\n  const mousePosition = scratchAdjustOrthographicFrustumMousePosition;\n  mousePosition.x = scene.drawingBufferWidth / scene.pixelRatio / 2.0;\n  mousePosition.y = scene.drawingBufferHeight / scene.pixelRatio / 2.0;\n\n  let rayIntersection;\n  if (defined(globe)) {\n    const ray = camera.getPickRay(mousePosition, scratchPickRay);\n    rayIntersection = globe.pickWorldCoordinates(\n      ray,\n      scene,\n      true,\n      scratchRayIntersection,\n    );\n  }\n\n  let depthIntersection;\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(\n      mousePosition,\n      scratchDepthIntersection,\n    );\n  }\n\n  let distance;\n  if (defined(rayIntersection) || defined(depthIntersection)) {\n    const depthDistance = defined(depthIntersection)\n      ? Cartesian3.distance(depthIntersection, camera.positionWC)\n      : Number.POSITIVE_INFINITY;\n    const rayDistance = defined(rayIntersection)\n      ? Cartesian3.distance(rayIntersection, camera.positionWC)\n      : Number.POSITIVE_INFINITY;\n    distance = Math.min(depthDistance, rayDistance);\n  } else {\n    distance = Math.max(camera.positionCartographic.height, 0.0);\n  }\n  return distance;\n}\n\nCamera.prototype._adjustOrthographicFrustum = function (zooming) {\n  if (!(this.frustum instanceof OrthographicFrustum)) {\n    return;\n  }\n\n  if (!zooming && this._positionCartographic.height < 150000.0) {\n    return;\n  }\n\n  this.frustum.width = calculateOrthographicFrustumWidth(this);\n};\n\nconst scratchSetViewCartesian = new Cartesian3();\nconst scratchSetViewTransform1 = new Matrix4();\nconst scratchSetViewTransform2 = new Matrix4();\nconst scratchSetViewQuaternion = new Quaternion();\nconst scratchSetViewMatrix3 = new Matrix3();\nconst scratchSetViewCartographic = new Cartographic();\n\nfunction setView3D(camera, position, hpr) {\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)) {\n    throw new DeveloperError(\"position has a NaN component\");\n  }\n  //>>includeEnd('debug');\n  const currentTransform = Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1,\n  );\n  const localTransform = Transforms.eastNorthUpToFixedFrame(\n    position,\n    camera._projection.ellipsoid,\n    scratchSetViewTransform2,\n  );\n  camera._setTransform(localTransform);\n\n  Cartesian3.clone(Cartesian3.ZERO, camera.position);\n  hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n\n  const rotQuat = Quaternion.fromHeadingPitchRoll(\n    hpr,\n    scratchSetViewQuaternion,\n  );\n  const rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n  Matrix3.getColumn(rotMat, 0, camera.direction);\n  Matrix3.getColumn(rotMat, 2, camera.up);\n  Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n  camera._setTransform(currentTransform);\n\n  camera._adjustOrthographicFrustum(true);\n}\n\nfunction setViewCV(camera, position, hpr, convert) {\n  const currentTransform = Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1,\n  );\n  camera._setTransform(Matrix4.IDENTITY);\n\n  if (!Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      const projection = camera._projection;\n      const cartographic = projection.ellipsoid.cartesianToCartographic(\n        position,\n        scratchSetViewCartographic,\n      );\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n    Cartesian3.clone(position, camera.position);\n  }\n  hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n\n  const rotQuat = Quaternion.fromHeadingPitchRoll(\n    hpr,\n    scratchSetViewQuaternion,\n  );\n  const rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n  Matrix3.getColumn(rotMat, 0, camera.direction);\n  Matrix3.getColumn(rotMat, 2, camera.up);\n  Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n  camera._setTransform(currentTransform);\n\n  camera._adjustOrthographicFrustum(true);\n}\n\nfunction setView2D(camera, position, hpr, convert) {\n  const currentTransform = Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1,\n  );\n  camera._setTransform(Matrix4.IDENTITY);\n\n  if (!Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      const projection = camera._projection;\n      const cartographic = projection.ellipsoid.cartesianToCartographic(\n        position,\n        scratchSetViewCartographic,\n      );\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n\n    Cartesian2.clone(position, camera.position);\n\n    const newLeft = -position.z * 0.5;\n    const newRight = -newLeft;\n\n    const frustum = camera.frustum;\n    if (newRight > newLeft) {\n      const ratio = frustum.top / frustum.right;\n      frustum.right = newRight;\n      frustum.left = newLeft;\n      frustum.top = frustum.right * ratio;\n      frustum.bottom = -frustum.top;\n    }\n  }\n\n  if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n    hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n    hpr.pitch = -CesiumMath.PI_OVER_TWO;\n    hpr.roll = 0.0;\n    const rotQuat = Quaternion.fromHeadingPitchRoll(\n      hpr,\n      scratchSetViewQuaternion,\n    );\n    const rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n    Matrix3.getColumn(rotMat, 2, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n  }\n\n  camera._setTransform(currentTransform);\n}\n\nconst scratchToHPRDirection = new Cartesian3();\nconst scratchToHPRUp = new Cartesian3();\nconst scratchToHPRRight = new Cartesian3();\n\nfunction directionUpToHeadingPitchRoll(camera, position, orientation, result) {\n  const direction = Cartesian3.clone(\n    orientation.direction,\n    scratchToHPRDirection,\n  );\n  const up = Cartesian3.clone(orientation.up, scratchToHPRUp);\n\n  if (camera._scene.mode === SceneMode.SCENE3D) {\n    const ellipsoid = camera._projection.ellipsoid;\n    const transform = Transforms.eastNorthUpToFixedFrame(\n      position,\n      ellipsoid,\n      scratchHPRMatrix1,\n    );\n    const invTransform = Matrix4.inverseTransformation(\n      transform,\n      scratchHPRMatrix2,\n    );\n\n    Matrix4.multiplyByPointAsVector(invTransform, direction, direction);\n    Matrix4.multiplyByPointAsVector(invTransform, up, up);\n  }\n\n  const right = Cartesian3.cross(direction, up, scratchToHPRRight);\n\n  result.heading = getHeading(direction, up);\n  result.pitch = getPitch(direction);\n  result.roll = getRoll(direction, up, right);\n\n  return result;\n}\n\nconst scratchSetViewOptions = {\n  destination: undefined,\n  orientation: {\n    direction: undefined,\n    up: undefined,\n    heading: undefined,\n    pitch: undefined,\n    roll: undefined,\n  },\n  convert: undefined,\n  endTransform: undefined,\n};\n\nconst scratchHpr = new HeadingPitchRoll();\n/**\n * Sets the camera position, orientation and transform.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} [options.destination] The final position of the camera in world coordinates or a rectangle that would be visible from a top-down view.\n * @param {HeadingPitchRollValues|DirectionUp} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view. Orientation is not used in 2D when in infinite scrolling mode.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame of the camera.\n * @param {boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n *\n * @example\n * // 1. Set position with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2 Set view with heading, pitch and roll\n * viewer.camera.setView({\n *     destination : cartesianPosition,\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n * // 3. Change heading, pitch and roll with the camera position remaining the same.\n * viewer.camera.setView({\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n *\n * // 4. View rectangle with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 5. Set position with an orientation using unit vectors.\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n */\nCamera.prototype.setView = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  let orientation = options.orientation ?? Frozen.EMPTY_OBJECT;\n\n  const mode = this._mode;\n  if (mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (defined(options.endTransform)) {\n    this._setTransform(options.endTransform);\n  }\n\n  let convert = options.convert ?? true;\n  let destination =\n    options.destination ??\n    Cartesian3.clone(this.positionWC, scratchSetViewCartesian);\n  if (defined(destination) && defined(destination.west)) {\n    destination = this.getRectangleCameraCoordinates(\n      destination,\n      scratchSetViewCartesian,\n    );\n    //>>includeStart('debug', pragmas.debug);\n    // destination.z may be null in 2D, but .x and .y should be numeric\n    if (isNaN(destination.x) || isNaN(destination.y)) {\n      throw new DeveloperError(`destination has a NaN component`);\n    }\n    //>>includeEnd('debug');\n    convert = false;\n  }\n\n  if (defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(\n      this,\n      destination,\n      orientation,\n      scratchSetViewOptions.orientation,\n    );\n  }\n\n  scratchHpr.heading = orientation.heading ?? 0.0;\n  scratchHpr.pitch = orientation.pitch ?? -CesiumMath.PI_OVER_TWO;\n  scratchHpr.roll = orientation.roll ?? 0.0;\n\n  if (mode === SceneMode.SCENE3D) {\n    setView3D(this, destination, scratchHpr);\n  } else if (mode === SceneMode.SCENE2D) {\n    setView2D(this, destination, scratchHpr, convert);\n  } else {\n    setViewCV(this, destination, scratchHpr, convert);\n  }\n};\n\nconst pitchScratch = new Cartesian3();\n/**\n * Fly the camera to the home view.  Use {@link Camera#.DEFAULT_VIEW_RECTANGLE} to set\n * the default view for the 3D scene.  The home view for 2D and columbus view shows the\n * entire map.\n *\n * @param {number} [duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight. See {@link Camera#flyTo}\n */\nCamera.prototype.flyHome = function (duration) {\n  const mode = this._mode;\n\n  if (mode === SceneMode.MORPHING) {\n    this._scene.completeMorph();\n  }\n\n  if (mode === SceneMode.SCENE2D) {\n    this.flyTo({\n      destination: Camera.DEFAULT_VIEW_RECTANGLE,\n      duration: duration,\n      endTransform: Matrix4.IDENTITY,\n    });\n  } else if (mode === SceneMode.SCENE3D) {\n    const destination = this.getRectangleCameraCoordinates(\n      Camera.DEFAULT_VIEW_RECTANGLE,\n    );\n\n    let mag = Cartesian3.magnitude(destination);\n    mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n    Cartesian3.normalize(destination, destination);\n    Cartesian3.multiplyByScalar(destination, mag, destination);\n\n    this.flyTo({\n      destination: destination,\n      duration: duration,\n      endTransform: Matrix4.IDENTITY,\n    });\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    const maxRadii = this._projection.ellipsoid.maximumRadius;\n    let position = new Cartesian3(0.0, -1.0, 1.0);\n    position = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(position, position),\n      5.0 * maxRadii,\n      position,\n    );\n    this.flyTo({\n      destination: position,\n      duration: duration,\n      orientation: {\n        heading: 0.0,\n        pitch: -Math.acos(Cartesian3.normalize(position, pitchScratch).z),\n        roll: 0.0,\n      },\n      endTransform: Matrix4.IDENTITY,\n      convert: false,\n    });\n  }\n};\n\n/**\n * Transform a vector or point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\nCamera.prototype.worldToCameraCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByVector(this._actualInvTransform, cartesian, result);\n};\n\n/**\n * Transform a point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\nCamera.prototype.worldToCameraCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPoint(this._actualInvTransform, cartesian, result);\n};\n\n/**\n * Transform a vector from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\nCamera.prototype.worldToCameraCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPointAsVector(\n    this._actualInvTransform,\n    cartesian,\n    result,\n  );\n};\n\n/**\n * Transform a vector or point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\nCamera.prototype.cameraToWorldCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByVector(this._actualTransform, cartesian, result);\n};\n\n/**\n * Transform a point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\nCamera.prototype.cameraToWorldCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPoint(this._actualTransform, cartesian, result);\n};\n\n/**\n * Transform a vector from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\nCamera.prototype.cameraToWorldCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPointAsVector(\n    this._actualTransform,\n    cartesian,\n    result,\n  );\n};\n\nfunction clampMove2D(camera, position) {\n  const rotatable2D = camera._scene.mapMode2D === MapMode2D.ROTATE;\n  const maxProjectedX = camera._maxCoord.x;\n  const maxProjectedY = camera._maxCoord.y;\n\n  let minX;\n  let maxX;\n  if (rotatable2D) {\n    maxX = maxProjectedX;\n    minX = -maxX;\n  } else {\n    maxX = position.x - maxProjectedX * 2.0;\n    minX = position.x + maxProjectedX * 2.0;\n  }\n\n  if (position.x > maxProjectedX) {\n    position.x = maxX;\n  }\n  if (position.x < -maxProjectedX) {\n    position.x = minX;\n  }\n\n  if (position.y > maxProjectedY) {\n    position.y = maxProjectedY;\n  }\n  if (position.y < -maxProjectedY) {\n    position.y = -maxProjectedY;\n  }\n}\n\nconst moveScratch = new Cartesian3();\n/**\n * Translates the camera's position by <code>amount</code> along <code>direction</code>.\n *\n * @param {Cartesian3} direction The direction to move.\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n * @see Camera#moveForward\n * @see Camera#moveLeft\n * @see Camera#moveRight\n * @see Camera#moveUp\n * @see Camera#moveDown\n */\nCamera.prototype.move = function (direction, amount) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const cameraPosition = this.position;\n  Cartesian3.multiplyByScalar(direction, amount, moveScratch);\n  Cartesian3.add(cameraPosition, moveScratch, cameraPosition);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    clampMove2D(this, cameraPosition);\n  }\n  this._adjustOrthographicFrustum(true);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's view vector.\n * When in 2D mode, this will zoom in the camera instead of translating the camera's position.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n */\nCamera.prototype.moveForward = function (amount) {\n  amount = amount ?? this.defaultMoveAmount;\n\n  if (this._mode === SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, amount);\n  }\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's view vector.\n * When in 2D mode, this will zoom out the camera instead of translating the camera's position.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveForward\n */\nCamera.prototype.moveBackward = function (amount) {\n  amount = amount ?? this.defaultMoveAmount;\n\n  if (this._mode === SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, -amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, -amount);\n  }\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's up vector.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveDown\n */\nCamera.prototype.moveUp = function (amount) {\n  amount = amount ?? this.defaultMoveAmount;\n  this.move(this.up, amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's up vector.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveUp\n */\nCamera.prototype.moveDown = function (amount) {\n  amount = amount ?? this.defaultMoveAmount;\n  this.move(this.up, -amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's right vector.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveLeft\n */\nCamera.prototype.moveRight = function (amount) {\n  amount = amount ?? this.defaultMoveAmount;\n  this.move(this.right, amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's right vector.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveRight\n */\nCamera.prototype.moveLeft = function (amount) {\n  amount = amount ?? this.defaultMoveAmount;\n  this.move(this.right, -amount);\n};\n\n/**\n * Rotates the camera around its up vector by amount, in radians, in the opposite direction\n * of its right vector if not in 2D mode.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookRight\n */\nCamera.prototype.lookLeft = function (amount) {\n  amount = amount ?? this.defaultLookAmount;\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.up, -amount);\n  }\n};\n\n/**\n * Rotates the camera around its up vector by amount, in radians, in the direction\n * of its right vector if not in 2D mode.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookLeft\n */\nCamera.prototype.lookRight = function (amount) {\n  amount = amount ?? this.defaultLookAmount;\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.up, amount);\n  }\n};\n\n/**\n * Rotates the camera around its right vector by amount, in radians, in the direction\n * of its up vector if not in 2D mode.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookDown\n */\nCamera.prototype.lookUp = function (amount) {\n  amount = amount ?? this.defaultLookAmount;\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.right, -amount);\n  }\n};\n\n/**\n * Rotates the camera around its right vector by amount, in radians, in the opposite direction\n * of its up vector if not in 2D mode.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n */\nCamera.prototype.lookDown = function (amount) {\n  amount = amount ?? this.defaultLookAmount;\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.right, amount);\n  }\n};\n\nconst lookScratchQuaternion = new Quaternion();\nconst lookScratchMatrix = new Matrix3();\n/**\n * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>\n *\n * @param {Cartesian3} axis The axis to rotate around.\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n * @see Camera#lookDown\n * @see Camera#lookLeft\n * @see Camera#lookRight\n */\nCamera.prototype.look = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(axis)) {\n    throw new DeveloperError(\"axis is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const turnAngle = angle ?? this.defaultLookAmount;\n  const quaternion = Quaternion.fromAxisAngle(\n    axis,\n    -turnAngle,\n    lookScratchQuaternion,\n  );\n  const rotation = Matrix3.fromQuaternion(quaternion, lookScratchMatrix);\n\n  const direction = this.direction;\n  const up = this.up;\n  const right = this.right;\n\n  Matrix3.multiplyByVector(rotation, direction, direction);\n  Matrix3.multiplyByVector(rotation, up, up);\n  Matrix3.multiplyByVector(rotation, right, right);\n};\n\n/**\n * Rotate the camera counter-clockwise around its direction vector by amount, in radians.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistRight\n */\nCamera.prototype.twistLeft = function (amount) {\n  amount = amount ?? this.defaultLookAmount;\n  this.look(this.direction, amount);\n};\n\n/**\n * Rotate the camera clockwise around its direction vector by amount, in radians.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistLeft\n */\nCamera.prototype.twistRight = function (amount) {\n  amount = amount ?? this.defaultLookAmount;\n  this.look(this.direction, -amount);\n};\n\nconst rotateScratchQuaternion = new Quaternion();\nconst rotateScratchMatrix = new Matrix3();\n/**\n * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance\n * of the camera's position to the center of the camera's reference frame remains the same.\n *\n * @param {Cartesian3} axis The axis to rotate around given in world coordinates.\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotateDown\n * @see Camera#rotateLeft\n * @see Camera#rotateRight\n */\nCamera.prototype.rotate = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(axis)) {\n    throw new DeveloperError(\"axis is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const turnAngle = angle ?? this.defaultRotateAmount;\n  const quaternion = Quaternion.fromAxisAngle(\n    axis,\n    -turnAngle,\n    rotateScratchQuaternion,\n  );\n  const rotation = Matrix3.fromQuaternion(quaternion, rotateScratchMatrix);\n  Matrix3.multiplyByVector(rotation, this.position, this.position);\n  Matrix3.multiplyByVector(rotation, this.direction, this.direction);\n  Matrix3.multiplyByVector(rotation, this.up, this.up);\n  Cartesian3.cross(this.direction, this.up, this.right);\n  Cartesian3.cross(this.right, this.direction, this.up);\n\n  this._adjustOrthographicFrustum(false);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle downwards.\n *\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotate\n */\nCamera.prototype.rotateDown = function (angle) {\n  angle = angle ?? this.defaultRotateAmount;\n  rotateVertical(this, angle);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle upwards.\n *\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateDown\n * @see Camera#rotate\n */\nCamera.prototype.rotateUp = function (angle) {\n  angle = angle ?? this.defaultRotateAmount;\n  rotateVertical(this, -angle);\n};\n\nconst rotateVertScratchP = new Cartesian3();\nconst rotateVertScratchA = new Cartesian3();\nconst rotateVertScratchTan = new Cartesian3();\nconst rotateVertScratchNegate = new Cartesian3();\nfunction rotateVertical(camera, angle) {\n  const position = camera.position;\n  if (\n    defined(camera.constrainedAxis) &&\n    !Cartesian3.equalsEpsilon(\n      camera.position,\n      Cartesian3.ZERO,\n      CesiumMath.EPSILON2,\n    )\n  ) {\n    const p = Cartesian3.normalize(position, rotateVertScratchP);\n    const northParallel = Cartesian3.equalsEpsilon(\n      p,\n      camera.constrainedAxis,\n      CesiumMath.EPSILON2,\n    );\n    const southParallel = Cartesian3.equalsEpsilon(\n      p,\n      Cartesian3.negate(camera.constrainedAxis, rotateVertScratchNegate),\n      CesiumMath.EPSILON2,\n    );\n    if (!northParallel && !southParallel) {\n      const constrainedAxis = Cartesian3.normalize(\n        camera.constrainedAxis,\n        rotateVertScratchA,\n      );\n\n      let dot = Cartesian3.dot(p, constrainedAxis);\n      let angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n\n      dot = Cartesian3.dot(\n        p,\n        Cartesian3.negate(constrainedAxis, rotateVertScratchNegate),\n      );\n      angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n\n      const tangent = Cartesian3.cross(\n        constrainedAxis,\n        p,\n        rotateVertScratchTan,\n      );\n      camera.rotate(tangent, angle);\n    } else if ((northParallel && angle < 0) || (southParallel && angle > 0)) {\n      camera.rotate(camera.right, angle);\n    }\n  } else {\n    camera.rotate(camera.right, angle);\n  }\n}\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the right.\n *\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateLeft\n * @see Camera#rotate\n */\nCamera.prototype.rotateRight = function (angle) {\n  angle = angle ?? this.defaultRotateAmount;\n  rotateHorizontal(this, -angle);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the left.\n *\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateRight\n * @see Camera#rotate\n */\nCamera.prototype.rotateLeft = function (angle) {\n  angle = angle ?? this.defaultRotateAmount;\n  rotateHorizontal(this, angle);\n};\n\nfunction rotateHorizontal(camera, angle) {\n  if (defined(camera.constrainedAxis)) {\n    camera.rotate(camera.constrainedAxis, angle);\n  } else {\n    camera.rotate(camera.up, angle);\n  }\n}\n\nfunction zoom2D(camera, amount) {\n  const frustum = camera.frustum;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !(frustum instanceof OrthographicOffCenterFrustum) ||\n    !defined(frustum.left) ||\n    !defined(frustum.right) ||\n    !defined(frustum.bottom) ||\n    !defined(frustum.top)\n  ) {\n    throw new DeveloperError(\n      \"The camera frustum is expected to be orthographic for 2D camera control.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  let ratio;\n  amount = amount * 0.5;\n\n  if (\n    Math.abs(frustum.top) + Math.abs(frustum.bottom) >\n    Math.abs(frustum.left) + Math.abs(frustum.right)\n  ) {\n    let newTop = frustum.top - amount;\n    let newBottom = frustum.bottom + amount;\n\n    let maxBottom = camera._maxCoord.y;\n    if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n      maxBottom *= camera.maximumZoomFactor;\n    }\n\n    if (newBottom > maxBottom) {\n      newBottom = maxBottom;\n      newTop = -maxBottom;\n    }\n\n    if (newTop <= newBottom) {\n      newTop = 1.0;\n      newBottom = -1.0;\n    }\n\n    ratio = frustum.right / frustum.top;\n    frustum.top = newTop;\n    frustum.bottom = newBottom;\n    frustum.right = frustum.top * ratio;\n    frustum.left = -frustum.right;\n  } else {\n    let newRight = frustum.right - amount;\n    let newLeft = frustum.left + amount;\n\n    let maxRight = camera._maxCoord.x;\n    if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n      maxRight *= camera.maximumZoomFactor;\n    }\n\n    if (newRight > maxRight) {\n      newRight = maxRight;\n      newLeft = -maxRight;\n    }\n\n    if (newRight <= newLeft) {\n      newRight = 1.0;\n      newLeft = -1.0;\n    }\n    ratio = frustum.top / frustum.right;\n    frustum.right = newRight;\n    frustum.left = newLeft;\n    frustum.top = frustum.right * ratio;\n    frustum.bottom = -frustum.top;\n  }\n}\n\nfunction zoom3D(camera, amount) {\n  camera.move(camera.direction, amount);\n}\n\n/**\n * Zooms <code>amount</code> along the camera's view vector.\n *\n * @param {number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomOut\n */\nCamera.prototype.zoomIn = function (amount) {\n  amount = amount ?? this.defaultZoomAmount;\n  if (this._mode === SceneMode.SCENE2D) {\n    zoom2D(this, amount);\n  } else {\n    zoom3D(this, amount);\n  }\n};\n\n/**\n * Zooms <code>amount</code> along the opposite direction of\n * the camera's view vector.\n *\n * @param {number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomIn\n */\nCamera.prototype.zoomOut = function (amount) {\n  amount = amount ?? this.defaultZoomAmount;\n  if (this._mode === SceneMode.SCENE2D) {\n    zoom2D(this, -amount);\n  } else {\n    zoom3D(this, -amount);\n  }\n};\n\n/**\n * Gets the magnitude of the camera position. In 3D, this is the vector magnitude. In 2D and\n * Columbus view, this is the distance to the map.\n *\n * @returns {number} The magnitude of the position.\n */\nCamera.prototype.getMagnitude = function () {\n  if (this._mode === SceneMode.SCENE3D) {\n    return Cartesian3.magnitude(this.position);\n  } else if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    return Math.abs(this.position.z);\n  } else if (this._mode === SceneMode.SCENE2D) {\n    return Math.max(\n      this.frustum.right - this.frustum.left,\n      this.frustum.top - this.frustum.bottom,\n    );\n  }\n};\n\nconst scratchLookAtMatrix4 = new Matrix4();\n\n/**\n * Sets the camera position and orientation using a target and offset. The target must be given in\n * world coordinates. The offset can be either a cartesian or heading/pitch/range in the local east-north-up reference frame centered at the target.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Cartesian3} target The target position in world coordinates.\n * @param {Cartesian3|HeadingPitchRange} offset The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAt is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * const center = Cesium.Cartesian3.fromDegrees(-98.0, 40.0);\n * viewer.camera.lookAt(center, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * const center = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * const heading = Cesium.Math.toRadians(50.0);\n * const pitch = Cesium.Math.toRadians(-20.0);\n * const range = 5000.0;\n * viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\nCamera.prototype.lookAt = function (target, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(target)) {\n    throw new DeveloperError(\"target is required\");\n  }\n  if (!defined(offset)) {\n    throw new DeveloperError(\"offset is required\");\n  }\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\"lookAt is not supported while morphing.\");\n  }\n  //>>includeEnd('debug');\n\n  const scene = this._scene;\n  const ellipsoid = scene.ellipsoid ?? Ellipsoid.default;\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    target,\n    ellipsoid,\n    scratchLookAtMatrix4,\n  );\n  this.lookAtTransform(transform, offset);\n};\n\nconst scratchLookAtHeadingPitchRangeOffset = new Cartesian3();\nconst scratchLookAtHeadingPitchRangeQuaternion1 = new Quaternion();\nconst scratchLookAtHeadingPitchRangeQuaternion2 = new Quaternion();\nconst scratchHeadingPitchRangeMatrix3 = new Matrix3();\n\nfunction offsetFromHeadingPitchRange(heading, pitch, range) {\n  pitch = CesiumMath.clamp(\n    pitch,\n    -CesiumMath.PI_OVER_TWO,\n    CesiumMath.PI_OVER_TWO,\n  );\n  heading = CesiumMath.zeroToTwoPi(heading) - CesiumMath.PI_OVER_TWO;\n\n  const pitchQuat = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Y,\n    -pitch,\n    scratchLookAtHeadingPitchRangeQuaternion1,\n  );\n  const headingQuat = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Z,\n    -heading,\n    scratchLookAtHeadingPitchRangeQuaternion2,\n  );\n  const rotQuat = Quaternion.multiply(headingQuat, pitchQuat, headingQuat);\n  const rotMatrix = Matrix3.fromQuaternion(\n    rotQuat,\n    scratchHeadingPitchRangeMatrix3,\n  );\n\n  const offset = Cartesian3.clone(\n    Cartesian3.UNIT_X,\n    scratchLookAtHeadingPitchRangeOffset,\n  );\n  Matrix3.multiplyByVector(rotMatrix, offset, offset);\n  Cartesian3.negate(offset, offset);\n  Cartesian3.multiplyByScalar(offset, range, offset);\n  return offset;\n}\n\n/**\n * Sets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the center of the reference frame. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Matrix4} transform The transformation matrix defining the reference frame.\n * @param {Cartesian3|HeadingPitchRange} [offset] The offset from the target in a reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAtTransform is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-98.0, 40.0));\n * viewer.camera.lookAtTransform(transform, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-72.0, 40.0));\n * const heading = Cesium.Math.toRadians(50.0);\n * const pitch = Cesium.Math.toRadians(-20.0);\n * const range = 5000.0;\n * viewer.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\nCamera.prototype.lookAtTransform = function (transform, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(transform)) {\n    throw new DeveloperError(\"transform is required\");\n  }\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\n      \"lookAtTransform is not supported while morphing.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._setTransform(transform);\n  if (!defined(offset)) {\n    return;\n  }\n\n  let cartesianOffset;\n  if (defined(offset.heading)) {\n    cartesianOffset = offsetFromHeadingPitchRange(\n      offset.heading,\n      offset.pitch,\n      offset.range,\n    );\n  } else {\n    cartesianOffset = offset;\n  }\n\n  if (this._mode === SceneMode.SCENE2D) {\n    Cartesian2.clone(Cartesian2.ZERO, this.position);\n\n    Cartesian3.negate(cartesianOffset, this.up);\n    this.up.z = 0.0;\n\n    if (Cartesian3.magnitudeSquared(this.up) < CesiumMath.EPSILON10) {\n      Cartesian3.clone(Cartesian3.UNIT_Y, this.up);\n    }\n\n    Cartesian3.normalize(this.up, this.up);\n\n    this._setTransform(Matrix4.IDENTITY);\n\n    Cartesian3.negate(Cartesian3.UNIT_Z, this.direction);\n    Cartesian3.cross(this.direction, this.up, this.right);\n    Cartesian3.normalize(this.right, this.right);\n\n    const frustum = this.frustum;\n    const ratio = frustum.top / frustum.right;\n    frustum.right = Cartesian3.magnitude(cartesianOffset) * 0.5;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n\n    this._setTransform(transform);\n\n    return;\n  }\n\n  Cartesian3.clone(cartesianOffset, this.position);\n  Cartesian3.negate(this.position, this.direction);\n  Cartesian3.normalize(this.direction, this.direction);\n  Cartesian3.cross(this.direction, Cartesian3.UNIT_Z, this.right);\n\n  if (Cartesian3.magnitudeSquared(this.right) < CesiumMath.EPSILON10) {\n    Cartesian3.clone(Cartesian3.UNIT_X, this.right);\n  }\n\n  Cartesian3.normalize(this.right, this.right);\n  Cartesian3.cross(this.right, this.direction, this.up);\n  Cartesian3.normalize(this.up, this.up);\n\n  this._adjustOrthographicFrustum(true);\n};\n\nconst viewRectangle3DCartographic1 = new Cartographic();\nconst viewRectangle3DCartographic2 = new Cartographic();\nconst viewRectangle3DNorthEast = new Cartesian3();\nconst viewRectangle3DSouthWest = new Cartesian3();\nconst viewRectangle3DNorthWest = new Cartesian3();\nconst viewRectangle3DSouthEast = new Cartesian3();\nconst viewRectangle3DNorthCenter = new Cartesian3();\nconst viewRectangle3DSouthCenter = new Cartesian3();\nconst viewRectangle3DCenter = new Cartesian3();\nconst viewRectangle3DEquator = new Cartesian3();\nconst defaultRF = {\n  direction: new Cartesian3(),\n  right: new Cartesian3(),\n  up: new Cartesian3(),\n};\nlet viewRectangle3DEllipsoidGeodesic;\n\nfunction computeD(direction, upOrRight, corner, tanThetaOrPhi) {\n  const opposite = Math.abs(Cartesian3.dot(upOrRight, corner));\n  return opposite / tanThetaOrPhi - Cartesian3.dot(direction, corner);\n}\n\nfunction rectangleCameraPosition3D(camera, rectangle, result, updateCamera) {\n  const ellipsoid = camera._projection.ellipsoid;\n  const cameraRF = updateCamera ? camera : defaultRF;\n\n  const { north, south, west } = rectangle;\n  let { east } = rectangle;\n\n  // If we go across the International Date Line\n  if (west > east) {\n    east += CesiumMath.TWO_PI;\n  }\n\n  // Find the midpoint latitude.\n  //\n  // EllipsoidGeodesic will fail if the north and south edges are very close to being on opposite sides of the ellipsoid.\n  // Ideally we'd just call EllipsoidGeodesic.setEndPoints and let it throw when it detects this case, but sadly it doesn't\n  // even look for this case in optimized builds, so we have to test for it here instead.\n  //\n  // Fortunately, this case can only happen (here) when north is very close to the north pole and south is very close to the south pole,\n  // so handle it just by using 0 latitude as the center.  It's certainliy possible to use a smaller tolerance\n  // than one degree here, but one degree is safe and putting the center at 0 latitude should be good enough for any\n  // rectangle that spans 178+ of the 180 degrees of latitude.\n  const longitude = (west + east) * 0.5;\n  let latitude;\n  if (\n    south < -CesiumMath.PI_OVER_TWO + CesiumMath.RADIANS_PER_DEGREE &&\n    north > CesiumMath.PI_OVER_TWO - CesiumMath.RADIANS_PER_DEGREE\n  ) {\n    latitude = 0.0;\n  } else {\n    const northCartographic = viewRectangle3DCartographic1;\n    northCartographic.longitude = longitude;\n    northCartographic.latitude = north;\n    northCartographic.height = 0.0;\n\n    const southCartographic = viewRectangle3DCartographic2;\n    southCartographic.longitude = longitude;\n    southCartographic.latitude = south;\n    southCartographic.height = 0.0;\n\n    let ellipsoidGeodesic = viewRectangle3DEllipsoidGeodesic;\n    if (\n      !defined(ellipsoidGeodesic) ||\n      ellipsoidGeodesic.ellipsoid !== ellipsoid\n    ) {\n      viewRectangle3DEllipsoidGeodesic = ellipsoidGeodesic =\n        new EllipsoidGeodesic(undefined, undefined, ellipsoid);\n    }\n\n    ellipsoidGeodesic.setEndPoints(northCartographic, southCartographic);\n    latitude = ellipsoidGeodesic.interpolateUsingFraction(\n      0.5,\n      viewRectangle3DCartographic1,\n    ).latitude;\n  }\n\n  const centerCartographic = viewRectangle3DCartographic1;\n  centerCartographic.longitude = longitude;\n  centerCartographic.latitude = latitude;\n  centerCartographic.height = 0.0;\n\n  const center = ellipsoid.cartographicToCartesian(\n    centerCartographic,\n    viewRectangle3DCenter,\n  );\n\n  const cart = viewRectangle3DCartographic1;\n  cart.longitude = east;\n  cart.latitude = north;\n  const northEast = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthEast,\n  );\n  cart.longitude = west;\n  const northWest = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthWest,\n  );\n  cart.longitude = longitude;\n  const northCenter = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthCenter,\n  );\n  cart.latitude = south;\n  const southCenter = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthCenter,\n  );\n  cart.longitude = east;\n  const southEast = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthEast,\n  );\n  cart.longitude = west;\n  const southWest = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthWest,\n  );\n\n  Cartesian3.subtract(northWest, center, northWest);\n  Cartesian3.subtract(southEast, center, southEast);\n  Cartesian3.subtract(northEast, center, northEast);\n  Cartesian3.subtract(southWest, center, southWest);\n  Cartesian3.subtract(northCenter, center, northCenter);\n  Cartesian3.subtract(southCenter, center, southCenter);\n\n  const direction = ellipsoid.geodeticSurfaceNormal(center, cameraRF.direction);\n  Cartesian3.negate(direction, direction);\n  const right = Cartesian3.cross(direction, Cartesian3.UNIT_Z, cameraRF.right);\n  Cartesian3.normalize(right, right);\n  const up = Cartesian3.cross(right, direction, cameraRF.up);\n\n  let d;\n  if (camera.frustum instanceof OrthographicFrustum) {\n    const width = Math.max(\n      Cartesian3.distance(northEast, northWest),\n      Cartesian3.distance(southEast, southWest),\n    );\n    const height = Math.max(\n      Cartesian3.distance(northEast, southEast),\n      Cartesian3.distance(northWest, southWest),\n    );\n\n    let rightScalar;\n    let topScalar;\n    const offCenterFrustum = camera.frustum._offCenterFrustum;\n    const ratio = offCenterFrustum.right / offCenterFrustum.top;\n    const heightRatio = height * ratio;\n    if (width > heightRatio) {\n      rightScalar = width;\n      topScalar = rightScalar / ratio;\n    } else {\n      topScalar = height;\n      rightScalar = heightRatio;\n    }\n\n    d = Math.max(rightScalar, topScalar);\n  } else {\n    const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    const tanTheta = camera.frustum.aspectRatio * tanPhi;\n\n    d = Math.max(\n      computeD(direction, up, northWest, tanPhi),\n      computeD(direction, up, southEast, tanPhi),\n      computeD(direction, up, northEast, tanPhi),\n      computeD(direction, up, southWest, tanPhi),\n      computeD(direction, up, northCenter, tanPhi),\n      computeD(direction, up, southCenter, tanPhi),\n      computeD(direction, right, northWest, tanTheta),\n      computeD(direction, right, southEast, tanTheta),\n      computeD(direction, right, northEast, tanTheta),\n      computeD(direction, right, southWest, tanTheta),\n      computeD(direction, right, northCenter, tanTheta),\n      computeD(direction, right, southCenter, tanTheta),\n    );\n\n    // If the rectangle crosses the equator, compute D at the equator, too, because that's the\n    // widest part of the rectangle when projected onto the globe.\n    if (south < 0 && north > 0) {\n      const equatorCartographic = viewRectangle3DCartographic1;\n      equatorCartographic.longitude = west;\n      equatorCartographic.latitude = 0.0;\n      equatorCartographic.height = 0.0;\n      let equatorPosition = ellipsoid.cartographicToCartesian(\n        equatorCartographic,\n        viewRectangle3DEquator,\n      );\n      Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(\n        d,\n        computeD(direction, up, equatorPosition, tanPhi),\n        computeD(direction, right, equatorPosition, tanTheta),\n      );\n\n      equatorCartographic.longitude = east;\n      equatorPosition = ellipsoid.cartographicToCartesian(\n        equatorCartographic,\n        viewRectangle3DEquator,\n      );\n      Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(\n        d,\n        computeD(direction, up, equatorPosition, tanPhi),\n        computeD(direction, right, equatorPosition, tanTheta),\n      );\n    }\n  }\n\n  return Cartesian3.add(\n    center,\n    Cartesian3.multiplyByScalar(direction, -d, viewRectangle3DEquator),\n    result,\n  );\n}\n\nconst viewRectangleCVCartographic = new Cartographic();\nconst viewRectangleCVNorthEast = new Cartesian3();\nconst viewRectangleCVSouthWest = new Cartesian3();\nfunction rectangleCameraPositionColumbusView(camera, rectangle, result) {\n  const projection = camera._projection;\n  if (rectangle.west > rectangle.east) {\n    rectangle = Rectangle.MAX_VALUE;\n  }\n  const transform = camera._actualTransform;\n  const invTransform = camera._actualInvTransform;\n\n  const cart = viewRectangleCVCartographic;\n  cart.longitude = rectangle.east;\n  cart.latitude = rectangle.north;\n  const northEast = projection.project(cart, viewRectangleCVNorthEast);\n  Matrix4.multiplyByPoint(transform, northEast, northEast);\n  Matrix4.multiplyByPoint(invTransform, northEast, northEast);\n\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  const southWest = projection.project(cart, viewRectangleCVSouthWest);\n  Matrix4.multiplyByPoint(transform, southWest, southWest);\n  Matrix4.multiplyByPoint(invTransform, southWest, southWest);\n\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n\n  if (defined(camera.frustum.fovy)) {\n    const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    const tanTheta = camera.frustum.aspectRatio * tanPhi;\n    result.z =\n      Math.max(\n        (northEast.x - southWest.x) / tanTheta,\n        (northEast.y - southWest.y) / tanPhi,\n      ) * 0.5;\n  } else {\n    const width = northEast.x - southWest.x;\n    const height = northEast.y - southWest.y;\n    result.z = Math.max(width, height);\n  }\n\n  return result;\n}\n\nconst viewRectangle2DCartographic = new Cartographic();\nconst viewRectangle2DNorthEast = new Cartesian3();\nconst viewRectangle2DSouthWest = new Cartesian3();\nfunction rectangleCameraPosition2D(camera, rectangle, result) {\n  const projection = camera._projection;\n\n  // Account for the rectangle crossing the International Date Line in 2D mode\n  let east = rectangle.east;\n  if (rectangle.west > rectangle.east) {\n    if (camera._scene.mapMode2D === MapMode2D.INFINITE_SCROLL) {\n      east += CesiumMath.TWO_PI;\n    } else {\n      rectangle = Rectangle.MAX_VALUE;\n      east = rectangle.east;\n    }\n  }\n\n  let cart = viewRectangle2DCartographic;\n  cart.longitude = east;\n  cart.latitude = rectangle.north;\n  const northEast = projection.project(cart, viewRectangle2DNorthEast);\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  const southWest = projection.project(cart, viewRectangle2DSouthWest);\n\n  const width = Math.abs(northEast.x - southWest.x) * 0.5;\n  let height = Math.abs(northEast.y - southWest.y) * 0.5;\n\n  let right, top;\n  const ratio = camera.frustum.right / camera.frustum.top;\n  const heightRatio = height * ratio;\n  if (width > heightRatio) {\n    right = width;\n    top = right / ratio;\n  } else {\n    top = height;\n    right = heightRatio;\n  }\n\n  height = Math.max(2.0 * right, 2.0 * top);\n\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n\n  cart = projection.unproject(result, cart);\n  cart.height = height;\n  result = projection.project(cart, result);\n\n  return result;\n}\n\n/**\n * Get the camera position needed to view a rectangle on an ellipsoid or map\n *\n * @param {Rectangle} rectangle The rectangle to view.\n * @param {Cartesian3} [result] The camera position needed to view the rectangle\n * @returns {Cartesian3} The camera position needed to view the rectangle\n */\nCamera.prototype.getRectangleCameraCoordinates = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  }\n  //>>includeEnd('debug');\n  const mode = this._mode;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  if (mode === SceneMode.SCENE3D) {\n    return rectangleCameraPosition3D(this, rectangle, result);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    return rectangleCameraPositionColumbusView(this, rectangle, result);\n  } else if (mode === SceneMode.SCENE2D) {\n    return rectangleCameraPosition2D(this, rectangle, result);\n  }\n\n  return undefined;\n};\n\nconst pickEllipsoid3DRay = new Ray();\nfunction pickEllipsoid3D(camera, windowPosition, ellipsoid, result) {\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n  const ray = camera.getPickRay(windowPosition, pickEllipsoid3DRay);\n  const intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n  if (!intersection) {\n    return undefined;\n  }\n\n  const t = intersection.start > 0.0 ? intersection.start : intersection.stop;\n  return Ray.getPoint(ray, t, result);\n}\n\nconst pickEllipsoid2DRay = new Ray();\nfunction pickMap2D(camera, windowPosition, projection, result) {\n  const ray = camera.getPickRay(windowPosition, pickEllipsoid2DRay);\n  let position = ray.origin;\n  position = Cartesian3.fromElements(position.y, position.z, 0.0, position);\n  const cart = projection.unproject(position);\n\n  if (\n    cart.latitude < -CesiumMath.PI_OVER_TWO ||\n    cart.latitude > CesiumMath.PI_OVER_TWO\n  ) {\n    return undefined;\n  }\n\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n\nconst pickEllipsoidCVRay = new Ray();\nfunction pickMapColumbusView(camera, windowPosition, projection, result) {\n  const ray = camera.getPickRay(windowPosition, pickEllipsoidCVRay);\n  const scalar = -ray.origin.x / ray.direction.x;\n  Ray.getPoint(ray, scalar, result);\n\n  const cart = projection.unproject(new Cartesian3(result.y, result.z, 0.0));\n\n  if (\n    cart.latitude < -CesiumMath.PI_OVER_TWO ||\n    cart.latitude > CesiumMath.PI_OVER_TWO ||\n    cart.longitude < -Math.PI ||\n    cart.longitude > Math.PI\n  ) {\n    return undefined;\n  }\n\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n\n/**\n * Pick an ellipsoid or map.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to pick.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3 | undefined} If the ellipsoid or map was picked,\n * returns the point on the surface of the ellipsoid or map in world\n * coordinates. If the ellipsoid or map was not picked, returns undefined.\n *\n * @example\n * const canvas = viewer.scene.canvas;\n * const center = new Cesium.Cartesian2(canvas.clientWidth / 2.0, canvas.clientHeight / 2.0);\n * const ellipsoid = viewer.scene.ellipsoid;\n * const result = viewer.camera.pickEllipsoid(center, ellipsoid);\n */\nCamera.prototype.pickEllipsoid = function (windowPosition, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const canvas = this._scene.canvas;\n  if (canvas.clientWidth === 0 || canvas.clientHeight === 0) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n\n  if (this._mode === SceneMode.SCENE3D) {\n    result = pickEllipsoid3D(this, windowPosition, ellipsoid, result);\n  } else if (this._mode === SceneMode.SCENE2D) {\n    result = pickMap2D(this, windowPosition, this._projection, result);\n  } else if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    result = pickMapColumbusView(\n      this,\n      windowPosition,\n      this._projection,\n      result,\n    );\n  } else {\n    return undefined;\n  }\n\n  return result;\n};\n\nconst pickPerspCenter = new Cartesian3();\nconst pickPerspXDir = new Cartesian3();\nconst pickPerspYDir = new Cartesian3();\nfunction getPickRayPerspective(camera, windowPosition, result) {\n  const canvas = camera._scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n\n  const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  const tanTheta = camera.frustum.aspectRatio * tanPhi;\n  const near = camera.frustum.near;\n\n  const x = (2.0 / width) * windowPosition.x - 1.0;\n  const y = (2.0 / height) * (height - windowPosition.y) - 1.0;\n\n  const position = camera.positionWC;\n  Cartesian3.clone(position, result.origin);\n\n  const nearCenter = Cartesian3.multiplyByScalar(\n    camera.directionWC,\n    near,\n    pickPerspCenter,\n  );\n  Cartesian3.add(position, nearCenter, nearCenter);\n  const xDir = Cartesian3.multiplyByScalar(\n    camera.rightWC,\n    x * near * tanTheta,\n    pickPerspXDir,\n  );\n  const yDir = Cartesian3.multiplyByScalar(\n    camera.upWC,\n    y * near * tanPhi,\n    pickPerspYDir,\n  );\n  const direction = Cartesian3.add(nearCenter, xDir, result.direction);\n  Cartesian3.add(direction, yDir, direction);\n  Cartesian3.subtract(direction, position, direction);\n  Cartesian3.normalize(direction, direction);\n\n  return result;\n}\n\nconst scratchDirection = new Cartesian3();\n\nfunction getPickRayOrthographic(camera, windowPosition, result) {\n  const canvas = camera._scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n\n  let frustum = camera.frustum;\n  const offCenterFrustum = frustum.offCenterFrustum;\n  if (defined(offCenterFrustum)) {\n    frustum = offCenterFrustum;\n  }\n  let x = (2.0 / width) * windowPosition.x - 1.0;\n  x *= (frustum.right - frustum.left) * 0.5;\n  let y = (2.0 / height) * (height - windowPosition.y) - 1.0;\n  y *= (frustum.top - frustum.bottom) * 0.5;\n\n  const origin = result.origin;\n  Cartesian3.clone(camera.positionWC, origin);\n\n  Cartesian3.multiplyByScalar(camera.rightWC, x, scratchDirection);\n  Cartesian3.add(scratchDirection, origin, origin);\n  Cartesian3.multiplyByScalar(camera.upWC, y, scratchDirection);\n  Cartesian3.add(scratchDirection, origin, origin);\n\n  Cartesian3.clone(camera.directionWC, result.direction);\n\n  return result;\n}\n\n/**\n * Create a ray from the camera position through the pixel at <code>windowPosition</code>\n * in world coordinates.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray|undefined} Returns the {@link Cartesian3} position and direction of the ray, or undefined if the pick ray cannot be determined.\n */\nCamera.prototype.getPickRay = function (windowPosition, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Ray();\n  }\n\n  const canvas = this._scene.canvas;\n  if (canvas.clientWidth <= 0 || canvas.clientHeight <= 0) {\n    return undefined;\n  }\n\n  const frustum = this.frustum;\n  if (\n    defined(frustum.aspectRatio) &&\n    defined(frustum.fov) &&\n    defined(frustum.near)\n  ) {\n    return getPickRayPerspective(this, windowPosition, result);\n  }\n\n  return getPickRayOrthographic(this, windowPosition, result);\n};\n\nconst scratchToCenter = new Cartesian3();\nconst scratchProj = new Cartesian3();\n\n/**\n * Return the distance from the camera to the front of the bounding sphere.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @returns {number} The distance to the bounding sphere.\n */\nCamera.prototype.distanceToBoundingSphere = function (boundingSphere) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const toCenter = Cartesian3.subtract(\n    this.positionWC,\n    boundingSphere.center,\n    scratchToCenter,\n  );\n  const proj = Cartesian3.multiplyByScalar(\n    this.directionWC,\n    Cartesian3.dot(toCenter, this.directionWC),\n    scratchProj,\n  );\n  return Math.max(0.0, Cartesian3.magnitude(proj) - boundingSphere.radius);\n};\n\nconst scratchPixelSize = new Cartesian2();\n\n/**\n * Return the pixel size in meters.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @param {number} drawingBufferWidth The drawing buffer width.\n * @param {number} drawingBufferHeight The drawing buffer height.\n * @returns {number} The pixel size in meters.\n */\nCamera.prototype.getPixelSize = function (\n  boundingSphere,\n  drawingBufferWidth,\n  drawingBufferHeight,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  if (!defined(drawingBufferWidth)) {\n    throw new DeveloperError(\"drawingBufferWidth is required.\");\n  }\n  if (!defined(drawingBufferHeight)) {\n    throw new DeveloperError(\"drawingBufferHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const distance = this.distanceToBoundingSphere(boundingSphere);\n  const pixelSize = this.frustum.getPixelDimensions(\n    drawingBufferWidth,\n    drawingBufferHeight,\n    distance,\n    this._scene.pixelRatio,\n    scratchPixelSize,\n  );\n  return Math.max(pixelSize.x, pixelSize.y);\n};\n\nfunction createAnimationTemplateCV(\n  camera,\n  position,\n  center,\n  maxX,\n  maxY,\n  duration,\n) {\n  const newPosition = Cartesian3.clone(position);\n\n  if (center.y > maxX) {\n    newPosition.y -= center.y - maxX;\n  } else if (center.y < -maxX) {\n    newPosition.y += -maxX - center.y;\n  }\n\n  if (center.z > maxY) {\n    newPosition.z -= center.z - maxY;\n  } else if (center.z < -maxY) {\n    newPosition.z += -maxY - center.z;\n  }\n\n  function updateCV(value) {\n    const interp = Cartesian3.lerp(\n      position,\n      newPosition,\n      value.time,\n      new Cartesian3(),\n    );\n    camera.worldToCameraCoordinatesPoint(interp, camera.position);\n  }\n  return {\n    easingFunction: EasingFunction.EXPONENTIAL_OUT,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: 1.0,\n    },\n    duration: duration,\n    update: updateCV,\n  };\n}\n\nconst normalScratch = new Cartesian3();\nconst centerScratch = new Cartesian3();\nconst posScratch = new Cartesian3();\nconst scratchCartesian3Subtract = new Cartesian3();\n\nfunction createAnimationCV(camera, duration) {\n  let position = camera.position;\n  const direction = camera.direction;\n\n  const normal = camera.worldToCameraCoordinatesVector(\n    Cartesian3.UNIT_X,\n    normalScratch,\n  );\n  const scalar =\n    -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  const center = Cartesian3.add(\n    position,\n    Cartesian3.multiplyByScalar(direction, scalar, centerScratch),\n    centerScratch,\n  );\n  camera.cameraToWorldCoordinatesPoint(center, center);\n\n  position = camera.cameraToWorldCoordinatesPoint(camera.position, posScratch);\n\n  const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  const tanTheta = camera.frustum.aspectRatio * tanPhi;\n  const distToC = Cartesian3.magnitude(\n    Cartesian3.subtract(position, center, scratchCartesian3Subtract),\n  );\n  const dWidth = tanTheta * distToC;\n  const dHeight = tanPhi * distToC;\n\n  const mapWidth = camera._maxCoord.x;\n  const mapHeight = camera._maxCoord.y;\n\n  const maxX = Math.max(dWidth - mapWidth, mapWidth);\n  const maxY = Math.max(dHeight - mapHeight, mapHeight);\n\n  if (\n    position.z < -maxX ||\n    position.z > maxX ||\n    position.y < -maxY ||\n    position.y > maxY\n  ) {\n    const translateX = center.y < -maxX || center.y > maxX;\n    const translateY = center.z < -maxY || center.z > maxY;\n    if (translateX || translateY) {\n      return createAnimationTemplateCV(\n        camera,\n        position,\n        center,\n        maxX,\n        maxY,\n        duration,\n      );\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Create an animation to move the map into view. This method is only valid for 2D and Columbus modes.\n *\n * @param {number} duration The duration, in seconds, of the animation.\n * @returns {object} The animation or undefined if the scene mode is 3D or the map is already ion view.\n *\n * @private\n */\nCamera.prototype.createCorrectPositionTween = function (duration) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(duration)) {\n    throw new DeveloperError(\"duration is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    return createAnimationCV(this, duration);\n  }\n\n  return undefined;\n};\n\nconst scratchFlyToDestination = new Cartesian3();\nconst newOptions = {\n  destination: undefined,\n  heading: undefined,\n  pitch: undefined,\n  roll: undefined,\n  duration: undefined,\n  complete: undefined,\n  cancel: undefined,\n  endTransform: undefined,\n  maximumHeight: undefined,\n  easingFunction: undefined,\n};\n\n/**\n * Cancels the current camera flight and leaves the camera at its current location.\n * If no flight is in progress, this function does nothing.\n */\nCamera.prototype.cancelFlight = function () {\n  if (defined(this._currentFlight)) {\n    this._currentFlight.cancelTween();\n    this._currentFlight = undefined;\n  }\n};\n\n/**\n * Completes the current camera flight and moves the camera immediately to its final destination.\n * If no flight is in progress, this function does nothing.\n */\nCamera.prototype.completeFlight = function () {\n  if (defined(this._currentFlight)) {\n    this._currentFlight.cancelTween();\n\n    const options = {\n      destination: undefined,\n      orientation: {\n        heading: undefined,\n        pitch: undefined,\n        roll: undefined,\n      },\n    };\n\n    options.destination = newOptions.destination;\n    options.orientation.heading = newOptions.heading;\n    options.orientation.pitch = newOptions.pitch;\n    options.orientation.roll = newOptions.roll;\n\n    this.setView(options);\n\n    if (defined(this._currentFlight.complete)) {\n      this._currentFlight.complete();\n    }\n\n    this._currentFlight = undefined;\n  }\n};\n\n/**\n * Flies the camera from its current position to a new position.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} options.destination The final position of the camera in world coordinates or a rectangle that would be visible from a top-down view.\n * @param {object} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view.  Orientation is not used in 2D when in infinite scrolling mode.\n * @param {number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {Camera.FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera.FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n * @param {EasingFunction.Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n *\n * @exception {DeveloperError} If either direction or up is given, then both are required.\n *\n * @example\n * // 1. Fly to a position with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2. Fly to a Rectangle with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 3. Fly to a position with an orientation using unit vectors.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n *\n * // 4. Fly to a position with an orientation using heading, pitch and roll.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         heading : Cesium.Math.toRadians(175.0),\n *         pitch : Cesium.Math.toRadians(-35.0),\n *         roll : 0.0\n *     }\n * });\n */\nCamera.prototype.flyTo = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  let destination = options.destination;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(destination)) {\n    throw new DeveloperError(\"destination is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const mode = this._mode;\n  if (mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  this.cancelFlight();\n\n  const isRectangle = destination instanceof Rectangle;\n  if (isRectangle) {\n    destination = this.getRectangleCameraCoordinates(\n      destination,\n      scratchFlyToDestination,\n    );\n  }\n\n  let orientation = options.orientation ?? Frozen.EMPTY_OBJECT;\n  if (defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(\n      this,\n      destination,\n      orientation,\n      scratchSetViewOptions.orientation,\n    );\n  }\n\n  if (defined(options.duration) && options.duration <= 0.0) {\n    const setViewOptions = scratchSetViewOptions;\n    setViewOptions.destination = options.destination;\n    setViewOptions.orientation.heading = orientation.heading;\n    setViewOptions.orientation.pitch = orientation.pitch;\n    setViewOptions.orientation.roll = orientation.roll;\n    setViewOptions.convert = options.convert;\n    setViewOptions.endTransform = options.endTransform;\n    this.setView(setViewOptions);\n    if (typeof options.complete === \"function\") {\n      options.complete();\n    }\n    return;\n  }\n\n  const that = this;\n  /* eslint-disable-next-line prefer-const */\n  let flightTween;\n\n  newOptions.destination = destination;\n  newOptions.heading = orientation.heading;\n  newOptions.pitch = orientation.pitch;\n  newOptions.roll = orientation.roll;\n  newOptions.duration = options.duration;\n  newOptions.complete = function () {\n    if (flightTween === that._currentFlight) {\n      that._currentFlight = undefined;\n    }\n    if (defined(options.complete)) {\n      options.complete();\n    }\n  };\n  newOptions.cancel = options.cancel;\n  newOptions.endTransform = options.endTransform;\n  newOptions.convert = isRectangle ? false : options.convert;\n  newOptions.maximumHeight = options.maximumHeight;\n  newOptions.pitchAdjustHeight = options.pitchAdjustHeight;\n  newOptions.flyOverLongitude = options.flyOverLongitude;\n  newOptions.flyOverLongitudeWeight = options.flyOverLongitudeWeight;\n  newOptions.easingFunction = options.easingFunction;\n\n  const scene = this._scene;\n  const tweenOptions = CameraFlightPath.createTween(scene, newOptions);\n  // If the camera doesn't actually need to go anywhere, duration\n  // will be 0 and we can just complete the current flight.\n  if (tweenOptions.duration === 0) {\n    if (typeof tweenOptions.complete === \"function\") {\n      tweenOptions.complete();\n    }\n    return;\n  }\n  flightTween = scene.tweens.add(tweenOptions);\n  this._currentFlight = flightTween;\n\n  // Save the final destination view information for the PRELOAD_FLIGHT pass.\n  let preloadFlightCamera = this._scene.preloadFlightCamera;\n  if (this._mode !== SceneMode.SCENE2D) {\n    if (!defined(preloadFlightCamera)) {\n      preloadFlightCamera = Camera.clone(this);\n    }\n    preloadFlightCamera.setView({\n      destination: destination,\n      orientation: orientation,\n    });\n\n    this._scene.preloadFlightCullingVolume =\n      preloadFlightCamera.frustum.computeCullingVolume(\n        preloadFlightCamera.positionWC,\n        preloadFlightCamera.directionWC,\n        preloadFlightCamera.upWC,\n      );\n  }\n};\n\nfunction distanceToBoundingSphere3D(camera, radius) {\n  const frustum = camera.frustum;\n  const tanPhi = Math.tan(frustum.fovy * 0.5);\n  const tanTheta = frustum.aspectRatio * tanPhi;\n  return Math.max(radius / tanTheta, radius / tanPhi);\n}\n\nfunction distanceToBoundingSphere2D(camera, radius) {\n  let frustum = camera.frustum;\n  const offCenterFrustum = frustum.offCenterFrustum;\n  if (defined(offCenterFrustum)) {\n    frustum = offCenterFrustum;\n  }\n\n  let right, top;\n  const ratio = frustum.right / frustum.top;\n  const heightRatio = radius * ratio;\n  if (radius > heightRatio) {\n    right = radius;\n    top = right / ratio;\n  } else {\n    top = radius;\n    right = heightRatio;\n  }\n\n  return Math.max(right, top) * 1.5;\n}\n\nconst MINIMUM_ZOOM = 100.0;\n\nfunction adjustBoundingSphereOffset(camera, boundingSphere, offset) {\n  offset = HeadingPitchRange.clone(\n    defined(offset) ? offset : Camera.DEFAULT_OFFSET,\n  );\n\n  const minimumZoom =\n    camera._scene.screenSpaceCameraController.minimumZoomDistance;\n  const maximumZoom =\n    camera._scene.screenSpaceCameraController.maximumZoomDistance;\n  const range = offset.range;\n  if (!defined(range) || range === 0.0) {\n    const radius = boundingSphere.radius;\n    if (radius === 0.0) {\n      offset.range = MINIMUM_ZOOM;\n    } else if (\n      camera.frustum instanceof OrthographicFrustum ||\n      camera._mode === SceneMode.SCENE2D\n    ) {\n      offset.range = distanceToBoundingSphere2D(camera, radius);\n    } else {\n      offset.range = distanceToBoundingSphere3D(camera, radius);\n    }\n    offset.range = CesiumMath.clamp(offset.range, minimumZoom, maximumZoom);\n  }\n\n  return offset;\n}\n\n/**\n * Sets the camera so that the current view contains the provided bounding sphere.\n *\n * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {HeadingPitchRange} [offset] The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} viewBoundingSphere is not supported while morphing.\n */\nCamera.prototype.viewBoundingSphere = function (boundingSphere, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\n      \"viewBoundingSphere is not supported while morphing.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  offset = adjustBoundingSphereOffset(this, boundingSphere, offset);\n  this.lookAt(boundingSphere.center, offset);\n};\n\nconst scratchflyToBoundingSphereTransform = new Matrix4();\nconst scratchflyToBoundingSphereDestination = new Cartesian3();\nconst scratchflyToBoundingSphereDirection = new Cartesian3();\nconst scratchflyToBoundingSphereUp = new Cartesian3();\nconst scratchflyToBoundingSphereRight = new Cartesian3();\nconst scratchFlyToBoundingSphereCart4 = new Cartesian4();\nconst scratchFlyToBoundingSphereQuaternion = new Quaternion();\nconst scratchFlyToBoundingSphereMatrix3 = new Matrix3();\n\n/**\n * Flies the camera to a location where the current view contains the provided bounding sphere.\n *\n * <p> The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D and Columbus View, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be aligned to local north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {object} [options] Object with the following properties:\n * @param {number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {HeadingPitchRange} [options.offset] The offset from the target in the local east-north-up reference frame centered at the target.\n * @param {Camera.FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera.FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {EasingFunction.Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n */\nCamera.prototype.flyToBoundingSphere = function (boundingSphere, options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const scene2D =\n    this._mode === SceneMode.SCENE2D || this._mode === SceneMode.COLUMBUS_VIEW;\n  this._setTransform(Matrix4.IDENTITY);\n  const offset = adjustBoundingSphereOffset(\n    this,\n    boundingSphere,\n    options.offset,\n  );\n\n  let position;\n  if (scene2D) {\n    position = Cartesian3.multiplyByScalar(\n      Cartesian3.UNIT_Z,\n      offset.range,\n      scratchflyToBoundingSphereDestination,\n    );\n  } else {\n    position = offsetFromHeadingPitchRange(\n      offset.heading,\n      offset.pitch,\n      offset.range,\n    );\n  }\n\n  const scene = this._scene;\n  const ellipsoid = scene.ellipsoid ?? Ellipsoid.default;\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    boundingSphere.center,\n    ellipsoid,\n    scratchflyToBoundingSphereTransform,\n  );\n  Matrix4.multiplyByPoint(transform, position, position);\n\n  let direction;\n  let up;\n\n  if (!scene2D) {\n    direction = Cartesian3.subtract(\n      boundingSphere.center,\n      position,\n      scratchflyToBoundingSphereDirection,\n    );\n    Cartesian3.normalize(direction, direction);\n\n    up = Matrix4.multiplyByPointAsVector(\n      transform,\n      Cartesian3.UNIT_Z,\n      scratchflyToBoundingSphereUp,\n    );\n    if (1.0 - Math.abs(Cartesian3.dot(direction, up)) < CesiumMath.EPSILON6) {\n      const rotateQuat = Quaternion.fromAxisAngle(\n        direction,\n        offset.heading,\n        scratchFlyToBoundingSphereQuaternion,\n      );\n      const rotation = Matrix3.fromQuaternion(\n        rotateQuat,\n        scratchFlyToBoundingSphereMatrix3,\n      );\n\n      Cartesian3.fromCartesian4(\n        Matrix4.getColumn(transform, 1, scratchFlyToBoundingSphereCart4),\n        up,\n      );\n      Matrix3.multiplyByVector(rotation, up, up);\n    }\n\n    const right = Cartesian3.cross(\n      direction,\n      up,\n      scratchflyToBoundingSphereRight,\n    );\n    Cartesian3.cross(right, direction, up);\n    Cartesian3.normalize(up, up);\n  }\n\n  this.flyTo({\n    destination: position,\n    orientation: {\n      direction: direction,\n      up: up,\n    },\n    duration: options.duration,\n    complete: options.complete,\n    cancel: options.cancel,\n    endTransform: options.endTransform,\n    maximumHeight: options.maximumHeight,\n    easingFunction: options.easingFunction,\n    flyOverLongitude: options.flyOverLongitude,\n    flyOverLongitudeWeight: options.flyOverLongitudeWeight,\n    pitchAdjustHeight: options.pitchAdjustHeight,\n  });\n};\n\nconst scratchCartesian3_1 = new Cartesian3();\nconst scratchCartesian3_2 = new Cartesian3();\nconst scratchCartesian3_3 = new Cartesian3();\nconst scratchCartesian3_4 = new Cartesian3();\nconst horizonPoints = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\n\nfunction computeHorizonQuad(camera, ellipsoid) {\n  const radii = ellipsoid.radii;\n  const p = camera.positionWC;\n\n  // Find the corresponding position in the scaled space of the ellipsoid.\n  const q = Cartesian3.multiplyComponents(\n    ellipsoid.oneOverRadii,\n    p,\n    scratchCartesian3_1,\n  );\n\n  const qMagnitude = Cartesian3.magnitude(q);\n  const qUnit = Cartesian3.normalize(q, scratchCartesian3_2);\n\n  // Determine the east and north directions at q.\n  let eUnit;\n  let nUnit;\n  if (\n    Cartesian3.equalsEpsilon(qUnit, Cartesian3.UNIT_Z, CesiumMath.EPSILON10)\n  ) {\n    eUnit = new Cartesian3(0, 1, 0);\n    nUnit = new Cartesian3(0, 0, 1);\n  } else {\n    eUnit = Cartesian3.normalize(\n      Cartesian3.cross(Cartesian3.UNIT_Z, qUnit, scratchCartesian3_3),\n      scratchCartesian3_3,\n    );\n    nUnit = Cartesian3.normalize(\n      Cartesian3.cross(qUnit, eUnit, scratchCartesian3_4),\n      scratchCartesian3_4,\n    );\n  }\n\n  // Determine the radius of the 'limb' of the ellipsoid.\n  const wMagnitude = Math.sqrt(Cartesian3.magnitudeSquared(q) - 1.0);\n\n  // Compute the center and offsets.\n  const center = Cartesian3.multiplyByScalar(\n    qUnit,\n    1.0 / qMagnitude,\n    scratchCartesian3_1,\n  );\n  const scalar = wMagnitude / qMagnitude;\n  const eastOffset = Cartesian3.multiplyByScalar(\n    eUnit,\n    scalar,\n    scratchCartesian3_2,\n  );\n  const northOffset = Cartesian3.multiplyByScalar(\n    nUnit,\n    scalar,\n    scratchCartesian3_3,\n  );\n\n  // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.\n  const upperLeft = Cartesian3.add(center, northOffset, horizonPoints[0]);\n  Cartesian3.subtract(upperLeft, eastOffset, upperLeft);\n  Cartesian3.multiplyComponents(radii, upperLeft, upperLeft);\n\n  const lowerLeft = Cartesian3.subtract(center, northOffset, horizonPoints[1]);\n  Cartesian3.subtract(lowerLeft, eastOffset, lowerLeft);\n  Cartesian3.multiplyComponents(radii, lowerLeft, lowerLeft);\n\n  const lowerRight = Cartesian3.subtract(center, northOffset, horizonPoints[2]);\n  Cartesian3.add(lowerRight, eastOffset, lowerRight);\n  Cartesian3.multiplyComponents(radii, lowerRight, lowerRight);\n\n  const upperRight = Cartesian3.add(center, northOffset, horizonPoints[3]);\n  Cartesian3.add(upperRight, eastOffset, upperRight);\n  Cartesian3.multiplyComponents(radii, upperRight, upperRight);\n\n  return horizonPoints;\n}\n\nconst scratchPickCartesian2 = new Cartesian2();\nconst scratchRectCartesian = new Cartesian3();\nconst cartoArray = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\nfunction addToResult(x, y, index, camera, ellipsoid, computedHorizonQuad) {\n  scratchPickCartesian2.x = x;\n  scratchPickCartesian2.y = y;\n  const r = camera.pickEllipsoid(\n    scratchPickCartesian2,\n    ellipsoid,\n    scratchRectCartesian,\n  );\n  if (defined(r)) {\n    cartoArray[index] = ellipsoid.cartesianToCartographic(r, cartoArray[index]);\n    return 1;\n  }\n  cartoArray[index] = ellipsoid.cartesianToCartographic(\n    computedHorizonQuad[index],\n    cartoArray[index],\n  );\n  return 0;\n}\n/**\n * Computes the approximate visible rectangle on the ellipsoid.\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid that you want to know the visible region.\n * @param {Rectangle} [result] The rectangle in which to store the result\n *\n * @returns {Rectangle|undefined} The visible rectangle or undefined if the ellipsoid isn't visible at all.\n */\nCamera.prototype.computeViewRectangle = function (ellipsoid, result) {\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n  const cullingVolume = this.frustum.computeCullingVolume(\n    this.positionWC,\n    this.directionWC,\n    this.upWC,\n  );\n  const boundingSphere = new BoundingSphere(\n    Cartesian3.ZERO,\n    ellipsoid.maximumRadius,\n  );\n  const visibility = cullingVolume.computeVisibility(boundingSphere);\n  if (visibility === Intersect.OUTSIDE) {\n    return undefined;\n  }\n\n  const canvas = this._scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n\n  let successfulPickCount = 0;\n\n  const computedHorizonQuad = computeHorizonQuad(this, ellipsoid);\n\n  successfulPickCount += addToResult(\n    0,\n    0,\n    0,\n    this,\n    ellipsoid,\n    computedHorizonQuad,\n  );\n  successfulPickCount += addToResult(\n    0,\n    height,\n    1,\n    this,\n    ellipsoid,\n    computedHorizonQuad,\n  );\n  successfulPickCount += addToResult(\n    width,\n    height,\n    2,\n    this,\n    ellipsoid,\n    computedHorizonQuad,\n  );\n  successfulPickCount += addToResult(\n    width,\n    0,\n    3,\n    this,\n    ellipsoid,\n    computedHorizonQuad,\n  );\n\n  if (successfulPickCount < 2) {\n    // If we have space non-globe in 3 or 4 corners then return the whole globe\n    return Rectangle.MAX_VALUE;\n  }\n\n  result = Rectangle.fromCartographicArray(cartoArray, result);\n\n  // Detect if we go over the poles\n  let distance = 0;\n  let lastLon = cartoArray[3].longitude;\n  for (let i = 0; i < 4; ++i) {\n    const lon = cartoArray[i].longitude;\n    const diff = Math.abs(lon - lastLon);\n    if (diff > CesiumMath.PI) {\n      // Crossed the dateline\n      distance += CesiumMath.TWO_PI - diff;\n    } else {\n      distance += diff;\n    }\n\n    lastLon = lon;\n  }\n\n  // We are over one of the poles so adjust the rectangle accordingly\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(distance),\n      CesiumMath.TWO_PI,\n      CesiumMath.EPSILON9,\n    )\n  ) {\n    result.west = -CesiumMath.PI;\n    result.east = CesiumMath.PI;\n    if (cartoArray[0].latitude >= 0.0) {\n      result.north = CesiumMath.PI_OVER_TWO;\n    } else {\n      result.south = -CesiumMath.PI_OVER_TWO;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Switches the frustum/projection to perspective.\n *\n * This function is a no-op in 2D which must always be orthographic.\n */\nCamera.prototype.switchToPerspectiveFrustum = function () {\n  if (\n    this._mode === SceneMode.SCENE2D ||\n    this.frustum instanceof PerspectiveFrustum\n  ) {\n    return;\n  }\n\n  const scene = this._scene;\n  this.frustum = new PerspectiveFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = CesiumMath.toRadians(60.0);\n};\n\n/**\n * Switches the frustum/projection to orthographic.\n *\n * This function is a no-op in 2D which will always be orthographic.\n */\nCamera.prototype.switchToOrthographicFrustum = function () {\n  if (\n    this._mode === SceneMode.SCENE2D ||\n    this.frustum instanceof OrthographicFrustum\n  ) {\n    return;\n  }\n\n  // This must be called before changing the frustum because it uses the previous\n  // frustum to reconstruct the world space position from the depth buffer.\n  const frustumWidth = calculateOrthographicFrustumWidth(this);\n\n  const scene = this._scene;\n  this.frustum = new OrthographicFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.width = frustumWidth;\n};\n\n/**\n * @private\n */\nCamera.clone = function (camera, result) {\n  if (!defined(result)) {\n    result = new Camera(camera._scene);\n  }\n\n  Cartesian3.clone(camera.position, result.position);\n  Cartesian3.clone(camera.direction, result.direction);\n  Cartesian3.clone(camera.up, result.up);\n  Cartesian3.clone(camera.right, result.right);\n  Matrix4.clone(camera._transform, result.transform);\n  result._transformChanged = true;\n  result.frustum = camera.frustum.clone();\n\n  return result;\n};\n\n/**\n * A function that will execute when a flight completes.\n * @callback Camera.FlightCompleteCallback\n */\n\n/**\n * A function that will execute when a flight is cancelled.\n * @callback Camera.FlightCancelledCallback\n */\nexport default Camera;\n"],"names":["Camera","scene","_scene","_transform","clone","IDENTITY","_invTransform","_actualTransform","_actualInvTransform","_transformChanged","position","_position","_positionWC","_positionCartographic","_oldPositionWC","undefined","positionWCDeltaMagnitude","positionWCDeltaMagnitudeLastFrame","timeSinceMoved","_lastMovedTimestamp","direction","_direction","_directionWC","up","_up","_upWC","right","_right","_rightWC","frustum","aspectRatio","drawingBufferWidth","drawingBufferHeight","fov","toRadians","defaultMoveAmount","defaultLookAmount","Math","PI","defaultRotateAmount","defaultZoomAmount","constrainedAxis","maximumZoomFactor","_moveStart","_moveEnd","_changed","_changedPosition","_changedDirection","_changedFrustum","_changedHeading","_changedRoll","percentageChanged","_viewMatrix","_invViewMatrix","updateViewMatrix","_mode","SCENE3D","_modeChanged","projection","mapProjection","_projection","_maxCoord","project","PI_OVER_TWO","_max2Dfrustum","rectangleCameraPosition3D","DEFAULT_VIEW_RECTANGLE","mag","magnitude","DEFAULT_VIEW_FACTOR","normalize","multiplyByScalar","TRANSFORM_2D","TRANSFORM_2D_INVERSE","inverseTransformation","fromDegrees","DEFAULT_OFFSET","PI_OVER_FOUR","camera","computeView","multiply","updateCameraDeltas","positionWC","delta","subtract","max","prototype","canPreloadFlight","_currentFlight","SCENE2D","_updateCameraChanged","numberOfListeners","currentHeading","heading","headingDelta","abs","TWO_PI","headingChangedPercentage","currentRoll","roll","rollDelta","rollChangedPercentage","raiseEvent","lastPosition","lastFrustum","x0","x","left","x1","x2","x3","y0","y","bottom","y1","top","y2","y3","leftX","rightX","min","bottomY","topY","areaPercentage","areaRef","directionWC","dirAngle","acosClamped","dot","dirPercentage","fovy","distance","heightPercentage","positionCartographic","height","convertTransformForColumbusView","basisTo2D","scratchCartographic","scratchCartesian3Projection","scratchCartesian3","scratchCartesian4Origin","scratchCartesian4NewOrigin","scratchCartesian4NewXAxis","scratchCartesian4NewYAxis","scratchCartesian4NewZAxis","convertTransformFor2D","ellipsoid","origin","getColumn","cartographic","cartesianToCartographic","projectedPosition","newOrigin","z","w","newZAxis","UNIT_X","xAxis","add","newXAxis","newYAxis","magnitudeSquared","EPSILON10","cross","yAxis","UNIT_Y","UNIT_Z","setColumn","scratchCartesian","updateMembers","mode","heightChanged","positionChanged","equals","directionChanged","upChanged","rightChanged","transformChanged","COLUMBUS_VIEW","transform","multiplyByPoint","MORPHING","positionENU","unproject","det","EPSILON2","invUpMag","scalar","w0","multiplyByPointAsVector","getHeading","equalsEpsilon","EPSILON3","atan2","zeroToTwoPi","getPitch","getRoll","scratchHPRMatrix1","scratchHPRMatrix2","Object","defineProperties","get","inverseTransform","viewMatrix","inverseViewMatrix","upWC","rightWC","oldTransform","eastNorthUpToFixedFrame","_setTransform","pitch","moveStart","moveEnd","changed","update","updateFrustum","maxZoomOut","ratio","clampMove2D","setTransformPosition","setTransformUp","setTransformDirection","inverse","scratchAdjustOrthographicFrustumMousePosition","scratchPickRay","scratchRayIntersection","scratchDepthIntersection","calculateOrthographicFrustumWidth","globe","mousePosition","pixelRatio","rayIntersection","ray","getPickRay","pickWorldCoordinates","depthIntersection","pickPositionSupported","pickPositionWorldCoordinates","depthDistance","Number","POSITIVE_INFINITY","rayDistance","_adjustOrthographicFrustum","zooming","width","scratchSetViewCartesian","scratchSetViewTransform1","scratchSetViewTransform2","scratchSetViewQuaternion","scratchSetViewMatrix3","scratchSetViewCartographic","setView3D","hpr","isNaN","currentTransform","localTransform","ZERO","rotQuat","fromHeadingPitchRoll","rotMat","fromQuaternion","setViewCV","convert","setView2D","newLeft","newRight","mapMode2D","ROTATE","scratchToHPRDirection","scratchToHPRUp","scratchToHPRRight","directionUpToHeadingPitchRoll","orientation","result","invTransform","scratchSetViewOptions","destination","endTransform","scratchHpr","setView","options","EMPTY_OBJECT","west","getRectangleCameraCoordinates","pitchScratch","flyHome","duration","completeMorph","flyTo","maxRadii","maximumRadius","acos","worldToCameraCoordinates","cartesian","multiplyByVector","worldToCameraCoordinatesPoint","worldToCameraCoordinatesVector","cameraToWorldCoordinates","cameraToWorldCoordinatesPoint","cameraToWorldCoordinatesVector","rotatable2D","maxProjectedX","maxProjectedY","minX","maxX","moveScratch","move","amount","cameraPosition","moveForward","zoom2D","moveBackward","moveUp","moveDown","moveRight","moveLeft","lookLeft","look","lookRight","lookUp","lookDown","lookScratchQuaternion","lookScratchMatrix","axis","angle","turnAngle","quaternion","fromAxisAngle","rotation","twistLeft","twistRight","rotateScratchQuaternion","rotateScratchMatrix","rotate","rotateDown","rotateVertical","rotateUp","rotateVertScratchP","rotateVertScratchA","rotateVertScratchTan","rotateVertScratchNegate","p","northParallel","southParallel","negate","angleToAxis","EPSILON4","tangent","rotateRight","rotateHorizontal","rotateLeft","newTop","newBottom","maxBottom","maxRight","zoom3D","zoomIn","zoomOut","getMagnitude","scratchLookAtMatrix4","lookAt","target","offset","default","lookAtTransform","scratchLookAtHeadingPitchRangeOffset","scratchLookAtHeadingPitchRangeQuaternion1","scratchLookAtHeadingPitchRangeQuaternion2","scratchHeadingPitchRangeMatrix3","offsetFromHeadingPitchRange","range","clamp","pitchQuat","headingQuat","rotMatrix","cartesianOffset","viewRectangle3DCartographic1","viewRectangle3DCartographic2","viewRectangle3DNorthEast","viewRectangle3DSouthWest","viewRectangle3DNorthWest","viewRectangle3DSouthEast","viewRectangle3DNorthCenter","viewRectangle3DSouthCenter","viewRectangle3DCenter","viewRectangle3DEquator","defaultRF","viewRectangle3DEllipsoidGeodesic","computeD","upOrRight","corner","tanThetaOrPhi","opposite","rectangle","updateCamera","cameraRF","north","south","east","longitude","latitude","RADIANS_PER_DEGREE","northCartographic","southCartographic","ellipsoidGeodesic","setEndPoints","interpolateUsingFraction","centerCartographic","center","cartographicToCartesian","cart","northEast","northWest","northCenter","southCenter","southEast","southWest","geodeticSurfaceNormal","d","rightScalar","topScalar","offCenterFrustum","_offCenterFrustum","heightRatio","tanPhi","tan","tanTheta","equatorCartographic","equatorPosition","viewRectangleCVCartographic","viewRectangleCVNorthEast","viewRectangleCVSouthWest","rectangleCameraPositionColumbusView","MAX_VALUE","viewRectangle2DCartographic","viewRectangle2DNorthEast","viewRectangle2DSouthWest","rectangleCameraPosition2D","INFINITE_SCROLL","pickEllipsoid3DRay","pickEllipsoid3D","windowPosition","intersection","rayEllipsoid","t","start","stop","getPoint","pickEllipsoid2DRay","pickMap2D","fromElements","pickEllipsoidCVRay","pickMapColumbusView","pickEllipsoid","canvas","clientWidth","clientHeight","pickPerspCenter","pickPerspXDir","pickPerspYDir","getPickRayPerspective","near","nearCenter","xDir","yDir","scratchDirection","getPickRayOrthographic","scratchToCenter","scratchProj","distanceToBoundingSphere","boundingSphere","toCenter","proj","radius","scratchPixelSize","getPixelSize","pixelSize","getPixelDimensions","createAnimationTemplateCV","maxY","newPosition","updateCV","value","interp","lerp","time","easingFunction","EXPONENTIAL_OUT","startObject","stopObject","normalScratch","centerScratch","posScratch","scratchCartesian3Subtract","createAnimationCV","normal","distToC","dWidth","dHeight","mapWidth","mapHeight","translateX","translateY","createCorrectPositionTween","scratchFlyToDestination","newOptions","complete","cancel","maximumHeight","cancelFlight","cancelTween","completeFlight","isRectangle","setViewOptions","that","flightTween","pitchAdjustHeight","flyOverLongitude","flyOverLongitudeWeight","tweenOptions","createTween","tweens","preloadFlightCamera","preloadFlightCullingVolume","computeCullingVolume","distanceToBoundingSphere3D","distanceToBoundingSphere2D","MINIMUM_ZOOM","adjustBoundingSphereOffset","minimumZoom","screenSpaceCameraController","minimumZoomDistance","maximumZoom","maximumZoomDistance","viewBoundingSphere","scratchflyToBoundingSphereTransform","scratchflyToBoundingSphereDestination","scratchflyToBoundingSphereDirection","scratchflyToBoundingSphereUp","scratchflyToBoundingSphereRight","scratchFlyToBoundingSphereCart4","scratchFlyToBoundingSphereQuaternion","scratchFlyToBoundingSphereMatrix3","flyToBoundingSphere","scene2D","EPSILON6","rotateQuat","fromCartesian4","scratchCartesian3_1","scratchCartesian3_2","scratchCartesian3_3","scratchCartesian3_4","horizonPoints","computeHorizonQuad","radii","q","multiplyComponents","oneOverRadii","qMagnitude","qUnit","eUnit","nUnit","wMagnitude","sqrt","eastOffset","northOffset","upperLeft","lowerLeft","lowerRight","upperRight","scratchPickCartesian2","scratchRectCartesian","cartoArray","addToResult","index","computedHorizonQuad","r","computeViewRectangle","cullingVolume","visibility","computeVisibility","OUTSIDE","successfulPickCount","fromCartographicArray","lastLon","i","lon","diff","EPSILON9","switchToPerspectiveFrustum","switchToOrthographicFrustum","frustumWidth"],"mappings":"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","ignoreList":[0]}}]
}