{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/GeometryPipeline.js"],"sourcesContent":["import AttributeCompression from \"./AttributeCompression.js\";\nimport barycentricCoordinates from \"./barycentricCoordinates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersect from \"./Intersect.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Tipsify from \"./Tipsify.js\";\n\n/**\n * Content pipeline functions for geometries.\n *\n * @namespace GeometryPipeline\n *\n * @see Geometry\n */\nconst GeometryPipeline = {};\n\nfunction addTriangle(lines, index, i0, i1, i2) {\n  lines[index++] = i0;\n  lines[index++] = i1;\n\n  lines[index++] = i1;\n  lines[index++] = i2;\n\n  lines[index++] = i2;\n  lines[index] = i0;\n}\n\nfunction trianglesToLines(triangles) {\n  const count = triangles.length;\n  const size = (count / 3) * 6;\n  const lines = IndexDatatype.createTypedArray(count, size);\n\n  let index = 0;\n  for (let i = 0; i < count; i += 3, index += 6) {\n    addTriangle(lines, index, triangles[i], triangles[i + 1], triangles[i + 2]);\n  }\n\n  return lines;\n}\n\nfunction triangleStripToLines(triangles) {\n  const count = triangles.length;\n  if (count >= 3) {\n    const size = (count - 2) * 6;\n    const lines = IndexDatatype.createTypedArray(count, size);\n\n    addTriangle(lines, 0, triangles[0], triangles[1], triangles[2]);\n    let index = 6;\n\n    for (let i = 3; i < count; ++i, index += 6) {\n      addTriangle(\n        lines,\n        index,\n        triangles[i - 1],\n        triangles[i],\n        triangles[i - 2],\n      );\n    }\n\n    return lines;\n  }\n\n  return new Uint16Array();\n}\n\nfunction triangleFanToLines(triangles) {\n  if (triangles.length > 0) {\n    const count = triangles.length - 1;\n    const size = (count - 1) * 6;\n    const lines = IndexDatatype.createTypedArray(count, size);\n\n    const base = triangles[0];\n    let index = 0;\n    for (let i = 1; i < count; ++i, index += 6) {\n      addTriangle(lines, index, base, triangles[i], triangles[i + 1]);\n    }\n\n    return lines;\n  }\n\n  return new Uint16Array();\n}\n\n/**\n * Converts a geometry's triangle indices to line indices.  If the geometry has an <code>indices</code>\n * and its <code>primitiveType</code> is <code>TRIANGLES</code>, <code>TRIANGLE_STRIP</code>,\n * <code>TRIANGLE_FAN</code>, it is converted to <code>LINES</code>; otherwise, the geometry is not changed.\n * <p>\n * This is commonly used to create a wireframe geometry for visual debugging.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its triangle indices converted to lines.\n *\n * @exception {DeveloperError} geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.toWireframe(geometry);\n */\nGeometryPipeline.toWireframe = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = geometry.indices;\n  if (defined(indices)) {\n    switch (geometry.primitiveType) {\n      case PrimitiveType.TRIANGLES:\n        geometry.indices = trianglesToLines(indices);\n        break;\n      case PrimitiveType.TRIANGLE_STRIP:\n        geometry.indices = triangleStripToLines(indices);\n        break;\n      case PrimitiveType.TRIANGLE_FAN:\n        geometry.indices = triangleFanToLines(indices);\n        break;\n      //>>includeStart('debug', pragmas.debug);\n      default:\n        throw new DeveloperError(\n          \"geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\",\n        );\n      //>>includeEnd('debug');\n    }\n\n    geometry.primitiveType = PrimitiveType.LINES;\n  }\n\n  return geometry;\n};\n\n/**\n * Creates a new {@link Geometry} with <code>LINES</code> representing the provided\n * attribute (<code>attributeName</code>) for the provided geometry.  This is used to\n * visualize vector attributes like normals, tangents, and bitangents.\n *\n * @param {Geometry} geometry The <code>Geometry</code> instance with the attribute.\n * @param {string} [attributeName='normal'] The name of the attribute.\n * @param {number} [length=10000.0] The length of each line segment in meters.  This can be negative to point the vector in the opposite direction.\n * @returns {Geometry} A new <code>Geometry</code> instance with line segments for the vector.\n *\n * @exception {DeveloperError} geometry.attributes must have an attribute with the same name as the attributeName parameter.\n *\n * @example\n * const geometry = Cesium.GeometryPipeline.createLineSegmentsForVectors(instance.geometry, 'bitangent', 100000.0);\n */\nGeometryPipeline.createLineSegmentsForVectors = function (\n  geometry,\n  attributeName,\n  length,\n) {\n  attributeName = attributeName ?? \"normal\";\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(geometry.attributes.position)) {\n    throw new DeveloperError(\"geometry.attributes.position is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\n      `geometry.attributes must have an attribute with the same name as the attributeName parameter, ${attributeName}.`,\n    );\n  }\n  //>>includeEnd('debug');\n\n  length = length ?? 10000.0;\n\n  const positions = geometry.attributes.position.values;\n  const vectors = geometry.attributes[attributeName].values;\n  const positionsLength = positions.length;\n\n  const newPositions = new Float64Array(2 * positionsLength);\n\n  let j = 0;\n  for (let i = 0; i < positionsLength; i += 3) {\n    newPositions[j++] = positions[i];\n    newPositions[j++] = positions[i + 1];\n    newPositions[j++] = positions[i + 2];\n\n    newPositions[j++] = positions[i] + vectors[i] * length;\n    newPositions[j++] = positions[i + 1] + vectors[i + 1] * length;\n    newPositions[j++] = positions[i + 2] + vectors[i + 2] * length;\n  }\n\n  let newBoundingSphere;\n  const bs = geometry.boundingSphere;\n  if (defined(bs)) {\n    newBoundingSphere = new BoundingSphere(bs.center, bs.radius + length);\n  }\n\n  return new Geometry({\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: newPositions,\n      }),\n    },\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: newBoundingSphere,\n  });\n};\n\n/**\n * Creates an object that maps attribute names to unique locations (indices)\n * for matching vertex attributes and shader programs.\n *\n * @param {Geometry} geometry The geometry, which is not modified, to create the object for.\n * @returns {object} An object with attribute name / index pairs.\n *\n * @example\n * const attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry);\n * // Example output\n * // {\n * //   'position' : 0,\n * //   'normal' : 1\n * // }\n */\nGeometryPipeline.createAttributeLocations = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // There can be a WebGL performance hit when attribute 0 is disabled, so\n  // assign attribute locations to well-known attributes.\n  const semantics = [\n    \"position\",\n    \"positionHigh\",\n    \"positionLow\",\n\n    // From VertexFormat.position - after 2D projection and high-precision encoding\n    \"position3DHigh\",\n    \"position3DLow\",\n    \"position2DHigh\",\n    \"position2DLow\",\n\n    // From Primitive\n    \"pickColor\",\n\n    // From VertexFormat\n    \"normal\",\n    \"st\",\n    \"tangent\",\n    \"bitangent\",\n\n    // For shadow volumes\n    \"extrudeDirection\",\n\n    // From compressing texture coordinates and normals\n    \"compressedAttributes\",\n  ];\n\n  const attributes = geometry.attributes;\n  const indices = {};\n  let j = 0;\n  let i;\n  const len = semantics.length;\n\n  // Attribute locations for well-known attributes\n  for (i = 0; i < len; ++i) {\n    const semantic = semantics[i];\n\n    if (defined(attributes[semantic])) {\n      indices[semantic] = j++;\n    }\n  }\n\n  // Locations for custom attributes\n  for (const name in attributes) {\n    if (attributes.hasOwnProperty(name) && !defined(indices[name])) {\n      indices[name] = j++;\n    }\n  }\n\n  return indices;\n};\n\n/**\n * Reorders a geometry's attributes and <code>indices</code> to achieve better performance from the GPU's pre-vertex-shader cache.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its attributes and indices reordered for the GPU's pre-vertex-shader cache.\n *\n * @exception {DeveloperError} Each attribute array in geometry.attributes must have the same number of attributes.\n *\n *\n * @example\n * geometry = Cesium.GeometryPipeline.reorderForPreVertexCache(geometry);\n *\n * @see GeometryPipeline.reorderForPostVertexCache\n */\nGeometryPipeline.reorderForPreVertexCache = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const numVertices = Geometry.computeNumberOfVertices(geometry);\n\n  const indices = geometry.indices;\n  if (defined(indices)) {\n    const indexCrossReferenceOldToNew = new Int32Array(numVertices);\n    for (let i = 0; i < numVertices; i++) {\n      indexCrossReferenceOldToNew[i] = -1;\n    }\n\n    // Construct cross reference and reorder indices\n    const indicesIn = indices;\n    const numIndices = indicesIn.length;\n    const indicesOut = IndexDatatype.createTypedArray(numVertices, numIndices);\n\n    let intoIndicesIn = 0;\n    let intoIndicesOut = 0;\n    let nextIndex = 0;\n    let tempIndex;\n    while (intoIndicesIn < numIndices) {\n      tempIndex = indexCrossReferenceOldToNew[indicesIn[intoIndicesIn]];\n      if (tempIndex !== -1) {\n        indicesOut[intoIndicesOut] = tempIndex;\n      } else {\n        tempIndex = indicesIn[intoIndicesIn];\n        indexCrossReferenceOldToNew[tempIndex] = nextIndex;\n\n        indicesOut[intoIndicesOut] = nextIndex;\n        ++nextIndex;\n      }\n      ++intoIndicesIn;\n      ++intoIndicesOut;\n    }\n    geometry.indices = indicesOut;\n\n    // Reorder attributes\n    const attributes = geometry.attributes;\n    for (const property in attributes) {\n      if (\n        attributes.hasOwnProperty(property) &&\n        defined(attributes[property]) &&\n        defined(attributes[property].values)\n      ) {\n        const attribute = attributes[property];\n        const elementsIn = attribute.values;\n        let intoElementsIn = 0;\n        const numComponents = attribute.componentsPerAttribute;\n        const elementsOut = ComponentDatatype.createTypedArray(\n          attribute.componentDatatype,\n          nextIndex * numComponents,\n        );\n        while (intoElementsIn < numVertices) {\n          const temp = indexCrossReferenceOldToNew[intoElementsIn];\n          if (temp !== -1) {\n            for (let j = 0; j < numComponents; j++) {\n              elementsOut[numComponents * temp + j] =\n                elementsIn[numComponents * intoElementsIn + j];\n            }\n          }\n          ++intoElementsIn;\n        }\n        attribute.values = elementsOut;\n      }\n    }\n  }\n\n  return geometry;\n};\n\n/**\n * Reorders a geometry's <code>indices</code> to achieve better performance from the GPU's\n * post vertex-shader cache by using the Tipsify algorithm.  If the geometry <code>primitiveType</code>\n * is not <code>TRIANGLES</code> or the geometry does not have an <code>indices</code>, this function has no effect.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {number} [cacheCapacity=24] The number of vertices that can be held in the GPU's vertex cache.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its indices reordered for the post-vertex-shader cache.\n *\n * @exception {DeveloperError} cacheCapacity must be greater than two.\n *\n *\n * @example\n * geometry = Cesium.GeometryPipeline.reorderForPostVertexCache(geometry);\n *\n * @see GeometryPipeline.reorderForPreVertexCache\n * @see {@link http://gfx.cs.princ0eton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf|Fast Triangle Reordering for Vertex Locality and Reduced Overdraw}\n * by Sander, Nehab, and Barczak\n */\nGeometryPipeline.reorderForPostVertexCache = function (\n  geometry,\n  cacheCapacity,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = geometry.indices;\n  if (geometry.primitiveType === PrimitiveType.TRIANGLES && defined(indices)) {\n    const numIndices = indices.length;\n    let maximumIndex = 0;\n    for (let j = 0; j < numIndices; j++) {\n      if (indices[j] > maximumIndex) {\n        maximumIndex = indices[j];\n      }\n    }\n    geometry.indices = Tipsify.tipsify({\n      indices: indices,\n      maximumIndex: maximumIndex,\n      cacheSize: cacheCapacity,\n    });\n  }\n\n  return geometry;\n};\n\nfunction copyAttributesDescriptions(attributes) {\n  const newAttributes = {};\n\n  for (const attribute in attributes) {\n    if (\n      attributes.hasOwnProperty(attribute) &&\n      defined(attributes[attribute]) &&\n      defined(attributes[attribute].values)\n    ) {\n      const attr = attributes[attribute];\n      newAttributes[attribute] = new GeometryAttribute({\n        componentDatatype: attr.componentDatatype,\n        componentsPerAttribute: attr.componentsPerAttribute,\n        normalize: attr.normalize,\n        values: [],\n      });\n    }\n  }\n\n  return newAttributes;\n}\n\nfunction copyVertex(destinationAttributes, sourceAttributes, index) {\n  for (const attribute in sourceAttributes) {\n    if (\n      sourceAttributes.hasOwnProperty(attribute) &&\n      defined(sourceAttributes[attribute]) &&\n      defined(sourceAttributes[attribute].values)\n    ) {\n      const attr = sourceAttributes[attribute];\n\n      for (let k = 0; k < attr.componentsPerAttribute; ++k) {\n        destinationAttributes[attribute].values.push(\n          attr.values[index * attr.componentsPerAttribute + k],\n        );\n      }\n    }\n  }\n}\n\n/**\n * Splits a geometry into multiple geometries, if necessary, to ensure that indices in the\n * <code>indices</code> fit into unsigned shorts.  This is used to meet the WebGL requirements\n * when unsigned int indices are not supported.\n * <p>\n * If the geometry does not have any <code>indices</code>, this function has no effect.\n * </p>\n *\n * @param {Geometry} geometry The geometry to be split into multiple geometries.\n * @returns {Geometry[]} An array of geometries, each with indices that fit into unsigned shorts.\n *\n * @exception {DeveloperError} geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS\n * @exception {DeveloperError} All geometry attribute lists must have the same number of attributes.\n *\n * @example\n * const geometries = Cesium.GeometryPipeline.fitToUnsignedShortIndices(geometry);\n */\nGeometryPipeline.fitToUnsignedShortIndices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (\n    defined(geometry.indices) &&\n    geometry.primitiveType !== PrimitiveType.TRIANGLES &&\n    geometry.primitiveType !== PrimitiveType.LINES &&\n    geometry.primitiveType !== PrimitiveType.POINTS\n  ) {\n    throw new DeveloperError(\n      \"geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const geometries = [];\n\n  // If there's an index list and more than 64K attributes, it is possible that\n  // some indices are outside the range of unsigned short [0, 64K - 1]\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n  if (\n    defined(geometry.indices) &&\n    numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES\n  ) {\n    let oldToNewIndex = [];\n    let newIndices = [];\n    let currentIndex = 0;\n    let newAttributes = copyAttributesDescriptions(geometry.attributes);\n\n    const originalIndices = geometry.indices;\n    const numberOfIndices = originalIndices.length;\n\n    let indicesPerPrimitive;\n\n    if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\n      indicesPerPrimitive = 3;\n    } else if (geometry.primitiveType === PrimitiveType.LINES) {\n      indicesPerPrimitive = 2;\n    } else if (geometry.primitiveType === PrimitiveType.POINTS) {\n      indicesPerPrimitive = 1;\n    }\n\n    for (let j = 0; j < numberOfIndices; j += indicesPerPrimitive) {\n      for (let k = 0; k < indicesPerPrimitive; ++k) {\n        const x = originalIndices[j + k];\n        let i = oldToNewIndex[x];\n        if (!defined(i)) {\n          i = currentIndex++;\n          oldToNewIndex[x] = i;\n          copyVertex(newAttributes, geometry.attributes, x);\n        }\n        newIndices.push(i);\n      }\n\n      if (\n        currentIndex + indicesPerPrimitive >=\n        CesiumMath.SIXTY_FOUR_KILOBYTES\n      ) {\n        geometries.push(\n          new Geometry({\n            attributes: newAttributes,\n            indices: newIndices,\n            primitiveType: geometry.primitiveType,\n            boundingSphere: geometry.boundingSphere,\n            boundingSphereCV: geometry.boundingSphereCV,\n          }),\n        );\n\n        // Reset for next vertex-array\n        oldToNewIndex = [];\n        newIndices = [];\n        currentIndex = 0;\n        newAttributes = copyAttributesDescriptions(geometry.attributes);\n      }\n    }\n\n    if (newIndices.length !== 0) {\n      geometries.push(\n        new Geometry({\n          attributes: newAttributes,\n          indices: newIndices,\n          primitiveType: geometry.primitiveType,\n          boundingSphere: geometry.boundingSphere,\n          boundingSphereCV: geometry.boundingSphereCV,\n        }),\n      );\n    }\n  } else {\n    // No need to split into multiple geometries\n    geometries.push(geometry);\n  }\n\n  return geometries;\n};\n\nconst scratchProjectTo2DCartesian3 = new Cartesian3();\nconst scratchProjectTo2DCartographic = new Cartographic();\n\n/**\n * Projects a geometry's 3D <code>position</code> attribute to 2D, replacing the <code>position</code>\n * attribute with separate <code>position3D</code> and <code>position2D</code> attributes.\n * <p>\n * If the geometry does not have a <code>position</code>, this function has no effect.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {string} attributeName The name of the attribute.\n * @param {string} attributeName3D The name of the attribute in 3D.\n * @param {string} attributeName2D The name of the attribute in 2D.\n * @param {object} [projection=new GeographicProjection()] The projection to use.\n * @returns {Geometry} The modified <code>geometry</code> argument with <code>position3D</code> and <code>position2D</code> attributes.\n *\n * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\n * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\n * @exception {DeveloperError} Could not project a point to 2D.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.projectTo2D(geometry, 'position', 'position3D', 'position2D');\n */\nGeometryPipeline.projectTo2D = function (\n  geometry,\n  attributeName,\n  attributeName3D,\n  attributeName2D,\n  projection,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(attributeName)) {\n    throw new DeveloperError(\"attributeName is required.\");\n  }\n  if (!defined(attributeName3D)) {\n    throw new DeveloperError(\"attributeName3D is required.\");\n  }\n  if (!defined(attributeName2D)) {\n    throw new DeveloperError(\"attributeName2D is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\n      `geometry must have attribute matching the attributeName argument: ${attributeName}.`,\n    );\n  }\n  if (\n    geometry.attributes[attributeName].componentDatatype !==\n    ComponentDatatype.DOUBLE\n  ) {\n    throw new DeveloperError(\n      \"The attribute componentDatatype must be ComponentDatatype.DOUBLE.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const attribute = geometry.attributes[attributeName];\n  projection = defined(projection) ? projection : new GeographicProjection();\n  const ellipsoid = projection.ellipsoid;\n\n  // Project original values to 2D.\n  const values3D = attribute.values;\n  const projectedValues = new Float64Array(values3D.length);\n  let index = 0;\n\n  for (let i = 0; i < values3D.length; i += 3) {\n    const value = Cartesian3.fromArray(\n      values3D,\n      i,\n      scratchProjectTo2DCartesian3,\n    );\n\n    const lonLat = ellipsoid.cartesianToCartographic(\n      value,\n      scratchProjectTo2DCartographic,\n    );\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(lonLat)) {\n      throw new DeveloperError(\n        `Could not project point (${value.x}, ${value.y}, ${value.z}) to 2D.`,\n      );\n    }\n    //>>includeEnd('debug');\n\n    const projectedLonLat = projection.project(\n      lonLat,\n      scratchProjectTo2DCartesian3,\n    );\n\n    projectedValues[index++] = projectedLonLat.x;\n    projectedValues[index++] = projectedLonLat.y;\n    projectedValues[index++] = projectedLonLat.z;\n  }\n\n  // Rename original cartesians to ellipsoid cartesians.\n  geometry.attributes[attributeName3D] = attribute;\n\n  // Replace original cartesians with 2D projected cartesians\n  geometry.attributes[attributeName2D] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: projectedValues,\n  });\n  delete geometry.attributes[attributeName];\n\n  return geometry;\n};\n\nconst encodedResult = {\n  high: 0.0,\n  low: 0.0,\n};\n\n/**\n * Encodes floating-point geometry attribute values as two separate attributes to improve\n * rendering precision.\n * <p>\n * This is commonly used to create high-precision position vertex attributes.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {string} attributeName The name of the attribute.\n * @param {string} attributeHighName The name of the attribute for the encoded high bits.\n * @param {string} attributeLowName The name of the attribute for the encoded low bits.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its encoded attribute.\n *\n * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\n * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.encodeAttribute(geometry, 'position3D', 'position3DHigh', 'position3DLow');\n */\nGeometryPipeline.encodeAttribute = function (\n  geometry,\n  attributeName,\n  attributeHighName,\n  attributeLowName,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(attributeName)) {\n    throw new DeveloperError(\"attributeName is required.\");\n  }\n  if (!defined(attributeHighName)) {\n    throw new DeveloperError(\"attributeHighName is required.\");\n  }\n  if (!defined(attributeLowName)) {\n    throw new DeveloperError(\"attributeLowName is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\n      `geometry must have attribute matching the attributeName argument: ${attributeName}.`,\n    );\n  }\n  if (\n    geometry.attributes[attributeName].componentDatatype !==\n    ComponentDatatype.DOUBLE\n  ) {\n    throw new DeveloperError(\n      \"The attribute componentDatatype must be ComponentDatatype.DOUBLE.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const attribute = geometry.attributes[attributeName];\n  const values = attribute.values;\n  const length = values.length;\n  const highValues = new Float32Array(length);\n  const lowValues = new Float32Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    EncodedCartesian3.encode(values[i], encodedResult);\n    highValues[i] = encodedResult.high;\n    lowValues[i] = encodedResult.low;\n  }\n\n  const componentsPerAttribute = attribute.componentsPerAttribute;\n\n  geometry.attributes[attributeHighName] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: componentsPerAttribute,\n    values: highValues,\n  });\n  geometry.attributes[attributeLowName] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: componentsPerAttribute,\n    values: lowValues,\n  });\n  delete geometry.attributes[attributeName];\n\n  return geometry;\n};\n\nlet scratchCartesian3 = new Cartesian3();\n\nfunction transformPoint(matrix, attribute) {\n  if (defined(attribute)) {\n    const values = attribute.values;\n    const length = values.length;\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.unpack(values, i, scratchCartesian3);\n      Matrix4.multiplyByPoint(matrix, scratchCartesian3, scratchCartesian3);\n      Cartesian3.pack(scratchCartesian3, values, i);\n    }\n  }\n}\n\nfunction transformVector(matrix, attribute) {\n  if (defined(attribute)) {\n    const values = attribute.values;\n    const length = values.length;\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.unpack(values, i, scratchCartesian3);\n      Matrix3.multiplyByVector(matrix, scratchCartesian3, scratchCartesian3);\n      scratchCartesian3 = Cartesian3.normalize(\n        scratchCartesian3,\n        scratchCartesian3,\n      );\n      Cartesian3.pack(scratchCartesian3, values, i);\n    }\n  }\n}\n\nconst inverseTranspose = new Matrix4();\nconst normalMatrix = new Matrix3();\n\n/**\n * Transforms a geometry instance to world coordinates.  This changes\n * the instance's <code>modelMatrix</code> to {@link Matrix4.IDENTITY} and transforms the\n * following attributes if they are present: <code>position</code>, <code>normal</code>,\n * <code>tangent</code>, and <code>bitangent</code>.\n *\n * @param {GeometryInstance} instance The geometry instance to modify.\n * @returns {GeometryInstance} The modified <code>instance</code> argument, with its attributes transforms to world coordinates.\n *\n * @example\n * Cesium.GeometryPipeline.transformToWorldCoordinates(instance);\n */\nGeometryPipeline.transformToWorldCoordinates = function (instance) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instance)) {\n    throw new DeveloperError(\"instance is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const modelMatrix = instance.modelMatrix;\n\n  if (Matrix4.equals(modelMatrix, Matrix4.IDENTITY)) {\n    // Already in world coordinates\n    return instance;\n  }\n\n  const attributes = instance.geometry.attributes;\n\n  // Transform attributes in known vertex formats\n  transformPoint(modelMatrix, attributes.position);\n  transformPoint(modelMatrix, attributes.prevPosition);\n  transformPoint(modelMatrix, attributes.nextPosition);\n\n  if (\n    defined(attributes.normal) ||\n    defined(attributes.tangent) ||\n    defined(attributes.bitangent)\n  ) {\n    Matrix4.inverse(modelMatrix, inverseTranspose);\n    Matrix4.transpose(inverseTranspose, inverseTranspose);\n    Matrix4.getMatrix3(inverseTranspose, normalMatrix);\n\n    transformVector(normalMatrix, attributes.normal);\n    transformVector(normalMatrix, attributes.tangent);\n    transformVector(normalMatrix, attributes.bitangent);\n  }\n\n  const boundingSphere = instance.geometry.boundingSphere;\n  if (defined(boundingSphere)) {\n    instance.geometry.boundingSphere = BoundingSphere.transform(\n      boundingSphere,\n      modelMatrix,\n      boundingSphere,\n    );\n  }\n\n  instance.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  return instance;\n};\n\nfunction findAttributesInAllGeometries(instances, propertyName) {\n  const length = instances.length;\n\n  const attributesInAllGeometries = {};\n\n  const attributes0 = instances[0][propertyName].attributes;\n  let name;\n\n  for (name in attributes0) {\n    if (\n      attributes0.hasOwnProperty(name) &&\n      defined(attributes0[name]) &&\n      defined(attributes0[name].values)\n    ) {\n      const attribute = attributes0[name];\n      let numberOfComponents = attribute.values.length;\n      let inAllGeometries = true;\n\n      // Does this same attribute exist in all geometries?\n      for (let i = 1; i < length; ++i) {\n        const otherAttribute = instances[i][propertyName].attributes[name];\n\n        if (\n          !defined(otherAttribute) ||\n          attribute.componentDatatype !== otherAttribute.componentDatatype ||\n          attribute.componentsPerAttribute !==\n            otherAttribute.componentsPerAttribute ||\n          attribute.normalize !== otherAttribute.normalize\n        ) {\n          inAllGeometries = false;\n          break;\n        }\n\n        numberOfComponents += otherAttribute.values.length;\n      }\n\n      if (inAllGeometries) {\n        attributesInAllGeometries[name] = new GeometryAttribute({\n          componentDatatype: attribute.componentDatatype,\n          componentsPerAttribute: attribute.componentsPerAttribute,\n          normalize: attribute.normalize,\n          values: ComponentDatatype.createTypedArray(\n            attribute.componentDatatype,\n            numberOfComponents,\n          ),\n        });\n      }\n    }\n  }\n\n  return attributesInAllGeometries;\n}\n\nconst tempScratch = new Cartesian3();\n\nfunction combineGeometries(instances, propertyName) {\n  const length = instances.length;\n\n  let name;\n  let i;\n  let j;\n  let k;\n\n  const m = instances[0].modelMatrix;\n  const haveIndices = defined(instances[0][propertyName].indices);\n  const primitiveType = instances[0][propertyName].primitiveType;\n\n  //>>includeStart('debug', pragmas.debug);\n  for (i = 1; i < length; ++i) {\n    if (!Matrix4.equals(instances[i].modelMatrix, m)) {\n      throw new DeveloperError(\"All instances must have the same modelMatrix.\");\n    }\n    if (defined(instances[i][propertyName].indices) !== haveIndices) {\n      throw new DeveloperError(\n        \"All instance geometries must have an indices or not have one.\",\n      );\n    }\n    if (instances[i][propertyName].primitiveType !== primitiveType) {\n      throw new DeveloperError(\n        \"All instance geometries must have the same primitiveType.\",\n      );\n    }\n  }\n  //>>includeEnd('debug');\n\n  // Find subset of attributes in all geometries\n  const attributes = findAttributesInAllGeometries(instances, propertyName);\n  let values;\n  let sourceValues;\n  let sourceValuesLength;\n\n  // Combine attributes from each geometry into a single typed array\n  for (name in attributes) {\n    if (attributes.hasOwnProperty(name)) {\n      values = attributes[name].values;\n\n      k = 0;\n      for (i = 0; i < length; ++i) {\n        sourceValues = instances[i][propertyName].attributes[name].values;\n        sourceValuesLength = sourceValues.length;\n\n        for (j = 0; j < sourceValuesLength; ++j) {\n          values[k++] = sourceValues[j];\n        }\n      }\n    }\n  }\n\n  // Combine index lists\n  let indices;\n\n  if (haveIndices) {\n    let numberOfIndices = 0;\n    for (i = 0; i < length; ++i) {\n      numberOfIndices += instances[i][propertyName].indices.length;\n    }\n\n    const numberOfVertices = Geometry.computeNumberOfVertices(\n      new Geometry({\n        attributes: attributes,\n        primitiveType: PrimitiveType.POINTS,\n      }),\n    );\n    const destIndices = IndexDatatype.createTypedArray(\n      numberOfVertices,\n      numberOfIndices,\n    );\n\n    let destOffset = 0;\n    let offset = 0;\n\n    for (i = 0; i < length; ++i) {\n      const sourceIndices = instances[i][propertyName].indices;\n      const sourceIndicesLen = sourceIndices.length;\n\n      for (k = 0; k < sourceIndicesLen; ++k) {\n        destIndices[destOffset++] = offset + sourceIndices[k];\n      }\n\n      offset += Geometry.computeNumberOfVertices(instances[i][propertyName]);\n    }\n\n    indices = destIndices;\n  }\n\n  // Create bounding sphere that includes all instances\n  let center = new Cartesian3();\n  let radius = 0.0;\n  let bs;\n\n  for (i = 0; i < length; ++i) {\n    bs = instances[i][propertyName].boundingSphere;\n    if (!defined(bs)) {\n      // If any geometries have an undefined bounding sphere, then so does the combined geometry\n      center = undefined;\n      break;\n    }\n\n    Cartesian3.add(bs.center, center, center);\n  }\n\n  if (defined(center)) {\n    Cartesian3.divideByScalar(center, length, center);\n\n    for (i = 0; i < length; ++i) {\n      bs = instances[i][propertyName].boundingSphere;\n      const tempRadius =\n        Cartesian3.magnitude(\n          Cartesian3.subtract(bs.center, center, tempScratch),\n        ) + bs.radius;\n\n      if (tempRadius > radius) {\n        radius = tempRadius;\n      }\n    }\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: primitiveType,\n    boundingSphere: defined(center)\n      ? new BoundingSphere(center, radius)\n      : undefined,\n  });\n}\n\n/**\n * Combines geometry from several {@link GeometryInstance} objects into one geometry.\n * This concatenates the attributes, concatenates and adjusts the indices, and creates\n * a bounding sphere encompassing all instances.\n * <p>\n * If the instances do not have the same attributes, a subset of attributes common\n * to all instances is used, and the others are ignored.\n * </p>\n * <p>\n * This is used by {@link Primitive} to efficiently render a large amount of static data.\n * </p>\n *\n * @private\n *\n * @param {GeometryInstance[]} [instances] The array of {@link GeometryInstance} objects whose geometry will be combined.\n * @returns {Geometry} A single geometry created from the provided geometry instances.\n *\n * @exception {DeveloperError} All instances must have the same modelMatrix.\n * @exception {DeveloperError} All instance geometries must have an indices or not have one.\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n *\n *\n * @example\n * for (let i = 0; i < instances.length; ++i) {\n *   Cesium.GeometryPipeline.transformToWorldCoordinates(instances[i]);\n * }\n * const geometries = Cesium.GeometryPipeline.combineInstances(instances);\n *\n * @see GeometryPipeline.transformToWorldCoordinates\n */\nGeometryPipeline.combineInstances = function (instances) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instances) || instances.length < 1) {\n    throw new DeveloperError(\n      \"instances is required and must have length greater than zero.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const instanceGeometry = [];\n  const instanceSplitGeometry = [];\n  const length = instances.length;\n  for (let i = 0; i < length; ++i) {\n    const instance = instances[i];\n\n    if (defined(instance.geometry)) {\n      instanceGeometry.push(instance);\n    } else if (\n      defined(instance.westHemisphereGeometry) &&\n      defined(instance.eastHemisphereGeometry)\n    ) {\n      instanceSplitGeometry.push(instance);\n    }\n  }\n\n  const geometries = [];\n  if (instanceGeometry.length > 0) {\n    geometries.push(combineGeometries(instanceGeometry, \"geometry\"));\n  }\n\n  if (instanceSplitGeometry.length > 0) {\n    geometries.push(\n      combineGeometries(instanceSplitGeometry, \"westHemisphereGeometry\"),\n    );\n    geometries.push(\n      combineGeometries(instanceSplitGeometry, \"eastHemisphereGeometry\"),\n    );\n  }\n\n  return geometries;\n};\n\nconst normal = new Cartesian3();\nconst v0 = new Cartesian3();\nconst v1 = new Cartesian3();\nconst v2 = new Cartesian3();\n\n/**\n * Computes per-vertex normals for a geometry containing <code>TRIANGLES</code> by averaging the normals of\n * all triangles incident to the vertex.  The result is a new <code>normal</code> attribute added to the geometry.\n * This assumes a counter-clockwise winding order.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>normal</code> attribute.\n *\n * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\n * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\n *\n * @example\n * Cesium.GeometryPipeline.computeNormal(geometry);\n */\nGeometryPipeline.computeNormal = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (\n    !defined(geometry.attributes.position) ||\n    !defined(geometry.attributes.position.values)\n  ) {\n    throw new DeveloperError(\n      \"geometry.attributes.position.values is required.\",\n    );\n  }\n  if (!defined(geometry.indices)) {\n    throw new DeveloperError(\"geometry.indices is required.\");\n  }\n  if (geometry.indices.length < 2 || geometry.indices.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"geometry.indices length must be greater than 0 and be a multiple of 3.\",\n    );\n  }\n  if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\n    throw new DeveloperError(\n      \"geometry.primitiveType must be PrimitiveType.TRIANGLES.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const indices = geometry.indices;\n  const attributes = geometry.attributes;\n  const vertices = attributes.position.values;\n  const numVertices = attributes.position.values.length / 3;\n  const numIndices = indices.length;\n  const normalsPerVertex = new Array(numVertices);\n  const normalsPerTriangle = new Array(numIndices / 3);\n  const normalIndices = new Array(numIndices);\n  let i;\n  for (i = 0; i < numVertices; i++) {\n    normalsPerVertex[i] = {\n      indexOffset: 0,\n      count: 0,\n      currentCount: 0,\n    };\n  }\n\n  let j = 0;\n  for (i = 0; i < numIndices; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n    const i03 = i0 * 3;\n    const i13 = i1 * 3;\n    const i23 = i2 * 3;\n\n    v0.x = vertices[i03];\n    v0.y = vertices[i03 + 1];\n    v0.z = vertices[i03 + 2];\n    v1.x = vertices[i13];\n    v1.y = vertices[i13 + 1];\n    v1.z = vertices[i13 + 2];\n    v2.x = vertices[i23];\n    v2.y = vertices[i23 + 1];\n    v2.z = vertices[i23 + 2];\n\n    normalsPerVertex[i0].count++;\n    normalsPerVertex[i1].count++;\n    normalsPerVertex[i2].count++;\n\n    Cartesian3.subtract(v1, v0, v1);\n    Cartesian3.subtract(v2, v0, v2);\n    normalsPerTriangle[j] = Cartesian3.cross(v1, v2, new Cartesian3());\n    j++;\n  }\n\n  let indexOffset = 0;\n  for (i = 0; i < numVertices; i++) {\n    normalsPerVertex[i].indexOffset += indexOffset;\n    indexOffset += normalsPerVertex[i].count;\n  }\n\n  j = 0;\n  let vertexNormalData;\n  for (i = 0; i < numIndices; i += 3) {\n    vertexNormalData = normalsPerVertex[indices[i]];\n    let index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n\n    vertexNormalData = normalsPerVertex[indices[i + 1]];\n    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n\n    vertexNormalData = normalsPerVertex[indices[i + 2]];\n    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n\n    j++;\n  }\n\n  const normalValues = new Float32Array(numVertices * 3);\n  for (i = 0; i < numVertices; i++) {\n    const i3 = i * 3;\n    vertexNormalData = normalsPerVertex[i];\n    Cartesian3.clone(Cartesian3.ZERO, normal);\n    if (vertexNormalData.count > 0) {\n      for (j = 0; j < vertexNormalData.count; j++) {\n        Cartesian3.add(\n          normal,\n          normalsPerTriangle[normalIndices[vertexNormalData.indexOffset + j]],\n          normal,\n        );\n      }\n\n      // We can run into an issue where a vertex is used with 2 primitives that have opposite winding order.\n      if (\n        Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)\n      ) {\n        Cartesian3.clone(\n          normalsPerTriangle[normalIndices[vertexNormalData.indexOffset]],\n          normal,\n        );\n      }\n    }\n\n    // We end up with a zero vector probably because of a degenerate triangle\n    if (\n      Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)\n    ) {\n      // Default to (0,0,1)\n      normal.z = 1.0;\n    }\n\n    Cartesian3.normalize(normal, normal);\n    normalValues[i3] = normal.x;\n    normalValues[i3 + 1] = normal.y;\n    normalValues[i3 + 2] = normal.z;\n  }\n\n  geometry.attributes.normal = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: normalValues,\n  });\n\n  return geometry;\n};\n\nconst normalScratch = new Cartesian3();\nconst normalScale = new Cartesian3();\nconst tScratch = new Cartesian3();\n\n/**\n * Computes per-vertex tangents and bitangents for a geometry containing <code>TRIANGLES</code>.\n * The result is new <code>tangent</code> and <code>bitangent</code> attributes added to the geometry.\n * This assumes a counter-clockwise winding order.\n * <p>\n * Based on <a href=\"http://www.terathon.com/code/tangent.html\">Computing Tangent Space Basis Vectors\n * for an Arbitrary Mesh</a> by Eric Lengyel.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>tangent</code> and <code>bitangent</code> attributes.\n *\n * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\n * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\n *\n * @example\n * Cesium.GeometryPipeline.computeTangentAndBiTangent(geometry);\n */\nGeometryPipeline.computeTangentAndBitangent = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const attributes = geometry.attributes;\n  const indices = geometry.indices;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(attributes.position) || !defined(attributes.position.values)) {\n    throw new DeveloperError(\n      \"geometry.attributes.position.values is required.\",\n    );\n  }\n  if (!defined(attributes.normal) || !defined(attributes.normal.values)) {\n    throw new DeveloperError(\"geometry.attributes.normal.values is required.\");\n  }\n  if (!defined(attributes.st) || !defined(attributes.st.values)) {\n    throw new DeveloperError(\"geometry.attributes.st.values is required.\");\n  }\n  if (!defined(indices)) {\n    throw new DeveloperError(\"geometry.indices is required.\");\n  }\n  if (indices.length < 2 || indices.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"geometry.indices length must be greater than 0 and be a multiple of 3.\",\n    );\n  }\n  if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\n    throw new DeveloperError(\n      \"geometry.primitiveType must be PrimitiveType.TRIANGLES.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const vertices = geometry.attributes.position.values;\n  const normals = geometry.attributes.normal.values;\n  const st = geometry.attributes.st.values;\n\n  const numVertices = geometry.attributes.position.values.length / 3;\n  const numIndices = indices.length;\n  const tan1 = new Array(numVertices * 3);\n\n  let i;\n  for (i = 0; i < tan1.length; i++) {\n    tan1[i] = 0;\n  }\n\n  let i03;\n  let i13;\n  let i23;\n  for (i = 0; i < numIndices; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n    i03 = i0 * 3;\n    i13 = i1 * 3;\n    i23 = i2 * 3;\n    const i02 = i0 * 2;\n    const i12 = i1 * 2;\n    const i22 = i2 * 2;\n\n    const ux = vertices[i03];\n    const uy = vertices[i03 + 1];\n    const uz = vertices[i03 + 2];\n\n    const wx = st[i02];\n    const wy = st[i02 + 1];\n    const t1 = st[i12 + 1] - wy;\n    const t2 = st[i22 + 1] - wy;\n\n    const r = 1.0 / ((st[i12] - wx) * t2 - (st[i22] - wx) * t1);\n    const sdirx = (t2 * (vertices[i13] - ux) - t1 * (vertices[i23] - ux)) * r;\n    const sdiry =\n      (t2 * (vertices[i13 + 1] - uy) - t1 * (vertices[i23 + 1] - uy)) * r;\n    const sdirz =\n      (t2 * (vertices[i13 + 2] - uz) - t1 * (vertices[i23 + 2] - uz)) * r;\n\n    tan1[i03] += sdirx;\n    tan1[i03 + 1] += sdiry;\n    tan1[i03 + 2] += sdirz;\n\n    tan1[i13] += sdirx;\n    tan1[i13 + 1] += sdiry;\n    tan1[i13 + 2] += sdirz;\n\n    tan1[i23] += sdirx;\n    tan1[i23 + 1] += sdiry;\n    tan1[i23 + 2] += sdirz;\n  }\n\n  const tangentValues = new Float32Array(numVertices * 3);\n  const bitangentValues = new Float32Array(numVertices * 3);\n\n  for (i = 0; i < numVertices; i++) {\n    i03 = i * 3;\n    i13 = i03 + 1;\n    i23 = i03 + 2;\n\n    const n = Cartesian3.fromArray(normals, i03, normalScratch);\n    const t = Cartesian3.fromArray(tan1, i03, tScratch);\n    const scalar = Cartesian3.dot(n, t);\n    Cartesian3.multiplyByScalar(n, scalar, normalScale);\n    Cartesian3.normalize(Cartesian3.subtract(t, normalScale, t), t);\n\n    tangentValues[i03] = t.x;\n    tangentValues[i13] = t.y;\n    tangentValues[i23] = t.z;\n\n    Cartesian3.normalize(Cartesian3.cross(n, t, t), t);\n\n    bitangentValues[i03] = t.x;\n    bitangentValues[i13] = t.y;\n    bitangentValues[i23] = t.z;\n  }\n\n  geometry.attributes.tangent = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: tangentValues,\n  });\n\n  geometry.attributes.bitangent = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: bitangentValues,\n  });\n\n  return geometry;\n};\n\nconst scratchCartesian2 = new Cartesian2();\nconst toEncode1 = new Cartesian3();\nconst toEncode2 = new Cartesian3();\nconst toEncode3 = new Cartesian3();\nlet encodeResult2 = new Cartesian2();\n/**\n * Compresses and packs geometry normal attribute values to save memory.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its normals compressed and packed.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.compressVertices(geometry);\n */\nGeometryPipeline.compressVertices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const extrudeAttribute = geometry.attributes.extrudeDirection;\n  let i;\n  let numVertices;\n  if (defined(extrudeAttribute)) {\n    //only shadow volumes use extrudeDirection, and shadow volumes use vertexFormat: POSITION_ONLY so we don't need to check other attributes\n    const extrudeDirections = extrudeAttribute.values;\n    numVertices = extrudeDirections.length / 3.0;\n    const compressedDirections = new Float32Array(numVertices * 2);\n\n    let i2 = 0;\n    for (i = 0; i < numVertices; ++i) {\n      Cartesian3.fromArray(extrudeDirections, i * 3.0, toEncode1);\n      if (Cartesian3.equals(toEncode1, Cartesian3.ZERO)) {\n        i2 += 2;\n        continue;\n      }\n      encodeResult2 = AttributeCompression.octEncodeInRange(\n        toEncode1,\n        65535,\n        encodeResult2,\n      );\n      compressedDirections[i2++] = encodeResult2.x;\n      compressedDirections[i2++] = encodeResult2.y;\n    }\n\n    geometry.attributes.compressedAttributes = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: compressedDirections,\n    });\n    delete geometry.attributes.extrudeDirection;\n    return geometry;\n  }\n\n  const normalAttribute = geometry.attributes.normal;\n  const stAttribute = geometry.attributes.st;\n\n  const hasNormal = defined(normalAttribute);\n  const hasSt = defined(stAttribute);\n  if (!hasNormal && !hasSt) {\n    return geometry;\n  }\n\n  const tangentAttribute = geometry.attributes.tangent;\n  const bitangentAttribute = geometry.attributes.bitangent;\n\n  const hasTangent = defined(tangentAttribute);\n  const hasBitangent = defined(bitangentAttribute);\n\n  let normals;\n  let st;\n  let tangents;\n  let bitangents;\n\n  if (hasNormal) {\n    normals = normalAttribute.values;\n  }\n  if (hasSt) {\n    st = stAttribute.values;\n  }\n  if (hasTangent) {\n    tangents = tangentAttribute.values;\n  }\n  if (hasBitangent) {\n    bitangents = bitangentAttribute.values;\n  }\n\n  const length = hasNormal ? normals.length : st.length;\n  const numComponents = hasNormal ? 3.0 : 2.0;\n  numVertices = length / numComponents;\n\n  let compressedLength = numVertices;\n  let numCompressedComponents = hasSt && hasNormal ? 2.0 : 1.0;\n  numCompressedComponents += hasTangent || hasBitangent ? 1.0 : 0.0;\n  compressedLength *= numCompressedComponents;\n\n  const compressedAttributes = new Float32Array(compressedLength);\n\n  let normalIndex = 0;\n  for (i = 0; i < numVertices; ++i) {\n    if (hasSt) {\n      Cartesian2.fromArray(st, i * 2.0, scratchCartesian2);\n      compressedAttributes[normalIndex++] =\n        AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n    }\n\n    const index = i * 3.0;\n    if (hasNormal && defined(tangents) && defined(bitangents)) {\n      Cartesian3.fromArray(normals, index, toEncode1);\n      Cartesian3.fromArray(tangents, index, toEncode2);\n      Cartesian3.fromArray(bitangents, index, toEncode3);\n\n      AttributeCompression.octPack(\n        toEncode1,\n        toEncode2,\n        toEncode3,\n        scratchCartesian2,\n      );\n      compressedAttributes[normalIndex++] = scratchCartesian2.x;\n      compressedAttributes[normalIndex++] = scratchCartesian2.y;\n    } else {\n      if (hasNormal) {\n        Cartesian3.fromArray(normals, index, toEncode1);\n        compressedAttributes[normalIndex++] =\n          AttributeCompression.octEncodeFloat(toEncode1);\n      }\n\n      if (hasTangent) {\n        Cartesian3.fromArray(tangents, index, toEncode1);\n        compressedAttributes[normalIndex++] =\n          AttributeCompression.octEncodeFloat(toEncode1);\n      }\n\n      if (hasBitangent) {\n        Cartesian3.fromArray(bitangents, index, toEncode1);\n        compressedAttributes[normalIndex++] =\n          AttributeCompression.octEncodeFloat(toEncode1);\n      }\n    }\n  }\n\n  geometry.attributes.compressedAttributes = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: numCompressedComponents,\n    values: compressedAttributes,\n  });\n\n  if (hasNormal) {\n    delete geometry.attributes.normal;\n  }\n  if (hasSt) {\n    delete geometry.attributes.st;\n  }\n  if (hasBitangent) {\n    delete geometry.attributes.bitangent;\n  }\n  if (hasTangent) {\n    delete geometry.attributes.tangent;\n  }\n\n  return geometry;\n};\n\nfunction indexTriangles(geometry) {\n  if (defined(geometry.indices)) {\n    return geometry;\n  }\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least three.\");\n  }\n  if (numberOfVertices % 3 !== 0) {\n    throw new DeveloperError(\n      \"The number of vertices must be a multiple of three.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    numberOfVertices,\n  );\n  for (let i = 0; i < numberOfVertices; ++i) {\n    indices[i] = i;\n  }\n\n  geometry.indices = indices;\n  return geometry;\n}\n\nfunction indexTriangleFan(geometry) {\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least three.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    (numberOfVertices - 2) * 3,\n  );\n  indices[0] = 1;\n  indices[1] = 0;\n  indices[2] = 2;\n\n  let indicesIndex = 3;\n  for (let i = 3; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = 0;\n    indices[indicesIndex++] = i;\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.TRIANGLES;\n  return geometry;\n}\n\nfunction indexTriangleStrip(geometry) {\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least 3.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    (numberOfVertices - 2) * 3,\n  );\n  indices[0] = 0;\n  indices[1] = 1;\n  indices[2] = 2;\n\n  if (numberOfVertices > 3) {\n    indices[3] = 0;\n    indices[4] = 2;\n    indices[5] = 3;\n  }\n\n  let indicesIndex = 6;\n  for (let i = 3; i < numberOfVertices - 1; i += 2) {\n    indices[indicesIndex++] = i;\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i + 1;\n\n    if (i + 2 < numberOfVertices) {\n      indices[indicesIndex++] = i;\n      indices[indicesIndex++] = i + 1;\n      indices[indicesIndex++] = i + 2;\n    }\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.TRIANGLES;\n  return geometry;\n}\n\nfunction indexLines(geometry) {\n  if (defined(geometry.indices)) {\n    return geometry;\n  }\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  if (numberOfVertices % 2 !== 0) {\n    throw new DeveloperError(\"The number of vertices must be a multiple of 2.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    numberOfVertices,\n  );\n  for (let i = 0; i < numberOfVertices; ++i) {\n    indices[i] = i;\n  }\n\n  geometry.indices = indices;\n  return geometry;\n}\n\nfunction indexLineStrip(geometry) {\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    (numberOfVertices - 1) * 2,\n  );\n  indices[0] = 0;\n  indices[1] = 1;\n  let indicesIndex = 2;\n  for (let i = 2; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i;\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.LINES;\n  return geometry;\n}\n\nfunction indexLineLoop(geometry) {\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    numberOfVertices * 2,\n  );\n\n  indices[0] = 0;\n  indices[1] = 1;\n\n  let indicesIndex = 2;\n  for (let i = 2; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i;\n  }\n\n  indices[indicesIndex++] = numberOfVertices - 1;\n  indices[indicesIndex] = 0;\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.LINES;\n  return geometry;\n}\n\nfunction indexPrimitive(geometry) {\n  switch (geometry.primitiveType) {\n    case PrimitiveType.TRIANGLE_FAN:\n      return indexTriangleFan(geometry);\n    case PrimitiveType.TRIANGLE_STRIP:\n      return indexTriangleStrip(geometry);\n    case PrimitiveType.TRIANGLES:\n      return indexTriangles(geometry);\n    case PrimitiveType.LINE_STRIP:\n      return indexLineStrip(geometry);\n    case PrimitiveType.LINE_LOOP:\n      return indexLineLoop(geometry);\n    case PrimitiveType.LINES:\n      return indexLines(geometry);\n  }\n\n  return geometry;\n}\n\nfunction offsetPointFromXZPlane(p, isBehind) {\n  if (Math.abs(p.y) < CesiumMath.EPSILON6) {\n    if (isBehind) {\n      p.y = -CesiumMath.EPSILON6;\n    } else {\n      p.y = CesiumMath.EPSILON6;\n    }\n  }\n}\n\nfunction offsetTriangleFromXZPlane(p0, p1, p2) {\n  if (p0.y !== 0.0 && p1.y !== 0.0 && p2.y !== 0.0) {\n    offsetPointFromXZPlane(p0, p0.y < 0.0);\n    offsetPointFromXZPlane(p1, p1.y < 0.0);\n    offsetPointFromXZPlane(p2, p2.y < 0.0);\n    return;\n  }\n\n  const p0y = Math.abs(p0.y);\n  const p1y = Math.abs(p1.y);\n  const p2y = Math.abs(p2.y);\n\n  let sign;\n  if (p0y > p1y) {\n    if (p0y > p2y) {\n      sign = CesiumMath.sign(p0.y);\n    } else {\n      sign = CesiumMath.sign(p2.y);\n    }\n  } else if (p1y > p2y) {\n    sign = CesiumMath.sign(p1.y);\n  } else {\n    sign = CesiumMath.sign(p2.y);\n  }\n\n  const isBehind = sign < 0.0;\n  offsetPointFromXZPlane(p0, isBehind);\n  offsetPointFromXZPlane(p1, isBehind);\n  offsetPointFromXZPlane(p2, isBehind);\n}\n\nconst c3 = new Cartesian3();\nfunction getXZIntersectionOffsetPoints(p, p1, u1, v1) {\n  Cartesian3.add(\n    p,\n    Cartesian3.multiplyByScalar(\n      Cartesian3.subtract(p1, p, c3),\n      p.y / (p.y - p1.y),\n      c3,\n    ),\n    u1,\n  );\n  Cartesian3.clone(u1, v1);\n  offsetPointFromXZPlane(u1, true);\n  offsetPointFromXZPlane(v1, false);\n}\n\nconst u1 = new Cartesian3();\nconst u2 = new Cartesian3();\nconst q1 = new Cartesian3();\nconst q2 = new Cartesian3();\n\nconst splitTriangleResult = {\n  positions: new Array(7),\n  indices: new Array(3 * 3),\n};\n\nfunction splitTriangle(p0, p1, p2) {\n  // In ellipsoid coordinates, for a triangle approximately on the\n  // ellipsoid to cross the IDL, first it needs to be on the\n  // negative side of the plane x = 0.\n  if (p0.x >= 0.0 || p1.x >= 0.0 || p2.x >= 0.0) {\n    return undefined;\n  }\n\n  offsetTriangleFromXZPlane(p0, p1, p2);\n\n  const p0Behind = p0.y < 0.0;\n  const p1Behind = p1.y < 0.0;\n  const p2Behind = p2.y < 0.0;\n\n  let numBehind = 0;\n  numBehind += p0Behind ? 1 : 0;\n  numBehind += p1Behind ? 1 : 0;\n  numBehind += p2Behind ? 1 : 0;\n\n  const indices = splitTriangleResult.indices;\n\n  if (numBehind === 1) {\n    indices[1] = 3;\n    indices[2] = 4;\n    indices[5] = 6;\n    indices[7] = 6;\n    indices[8] = 5;\n\n    if (p0Behind) {\n      getXZIntersectionOffsetPoints(p0, p1, u1, q1);\n      getXZIntersectionOffsetPoints(p0, p2, u2, q2);\n\n      indices[0] = 0;\n      indices[3] = 1;\n      indices[4] = 2;\n      indices[6] = 1;\n    } else if (p1Behind) {\n      getXZIntersectionOffsetPoints(p1, p2, u1, q1);\n      getXZIntersectionOffsetPoints(p1, p0, u2, q2);\n\n      indices[0] = 1;\n      indices[3] = 2;\n      indices[4] = 0;\n      indices[6] = 2;\n    } else if (p2Behind) {\n      getXZIntersectionOffsetPoints(p2, p0, u1, q1);\n      getXZIntersectionOffsetPoints(p2, p1, u2, q2);\n\n      indices[0] = 2;\n      indices[3] = 0;\n      indices[4] = 1;\n      indices[6] = 0;\n    }\n  } else if (numBehind === 2) {\n    indices[2] = 4;\n    indices[4] = 4;\n    indices[5] = 3;\n    indices[7] = 5;\n    indices[8] = 6;\n\n    if (!p0Behind) {\n      getXZIntersectionOffsetPoints(p0, p1, u1, q1);\n      getXZIntersectionOffsetPoints(p0, p2, u2, q2);\n\n      indices[0] = 1;\n      indices[1] = 2;\n      indices[3] = 1;\n      indices[6] = 0;\n    } else if (!p1Behind) {\n      getXZIntersectionOffsetPoints(p1, p2, u1, q1);\n      getXZIntersectionOffsetPoints(p1, p0, u2, q2);\n\n      indices[0] = 2;\n      indices[1] = 0;\n      indices[3] = 2;\n      indices[6] = 1;\n    } else if (!p2Behind) {\n      getXZIntersectionOffsetPoints(p2, p0, u1, q1);\n      getXZIntersectionOffsetPoints(p2, p1, u2, q2);\n\n      indices[0] = 0;\n      indices[1] = 1;\n      indices[3] = 0;\n      indices[6] = 2;\n    }\n  }\n\n  const positions = splitTriangleResult.positions;\n  positions[0] = p0;\n  positions[1] = p1;\n  positions[2] = p2;\n  positions.length = 3;\n\n  if (numBehind === 1 || numBehind === 2) {\n    positions[3] = u1;\n    positions[4] = u2;\n    positions[5] = q1;\n    positions[6] = q2;\n    positions.length = 7;\n  }\n\n  return splitTriangleResult;\n}\n\nfunction updateGeometryAfterSplit(geometry, computeBoundingSphere) {\n  const attributes = geometry.attributes;\n\n  if (attributes.position.values.length === 0) {\n    return undefined;\n  }\n\n  for (const property in attributes) {\n    if (\n      attributes.hasOwnProperty(property) &&\n      defined(attributes[property]) &&\n      defined(attributes[property].values)\n    ) {\n      const attribute = attributes[property];\n      attribute.values = ComponentDatatype.createTypedArray(\n        attribute.componentDatatype,\n        attribute.values,\n      );\n    }\n  }\n\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n  geometry.indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    geometry.indices,\n  );\n\n  if (computeBoundingSphere) {\n    geometry.boundingSphere = BoundingSphere.fromVertices(\n      attributes.position.values,\n    );\n  }\n\n  return geometry;\n}\n\nfunction copyGeometryForSplit(geometry) {\n  const attributes = geometry.attributes;\n  const copiedAttributes = {};\n\n  for (const property in attributes) {\n    if (\n      attributes.hasOwnProperty(property) &&\n      defined(attributes[property]) &&\n      defined(attributes[property].values)\n    ) {\n      const attribute = attributes[property];\n      copiedAttributes[property] = new GeometryAttribute({\n        componentDatatype: attribute.componentDatatype,\n        componentsPerAttribute: attribute.componentsPerAttribute,\n        normalize: attribute.normalize,\n        values: [],\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: copiedAttributes,\n    indices: [],\n    primitiveType: geometry.primitiveType,\n  });\n}\n\nfunction updateInstanceAfterSplit(instance, westGeometry, eastGeometry) {\n  const computeBoundingSphere = defined(instance.geometry.boundingSphere);\n\n  westGeometry = updateGeometryAfterSplit(westGeometry, computeBoundingSphere);\n  eastGeometry = updateGeometryAfterSplit(eastGeometry, computeBoundingSphere);\n\n  if (defined(eastGeometry) && !defined(westGeometry)) {\n    instance.geometry = eastGeometry;\n  } else if (!defined(eastGeometry) && defined(westGeometry)) {\n    instance.geometry = westGeometry;\n  } else {\n    instance.westHemisphereGeometry = westGeometry;\n    instance.eastHemisphereGeometry = eastGeometry;\n    instance.geometry = undefined;\n  }\n}\n\nfunction generateBarycentricInterpolateFunction(\n  CartesianType,\n  numberOfComponents,\n) {\n  const v0Scratch = new CartesianType();\n  const v1Scratch = new CartesianType();\n  const v2Scratch = new CartesianType();\n\n  return function (\n    i0,\n    i1,\n    i2,\n    coords,\n    sourceValues,\n    currentValues,\n    insertedIndex,\n    normalize,\n  ) {\n    const v0 = CartesianType.fromArray(\n      sourceValues,\n      i0 * numberOfComponents,\n      v0Scratch,\n    );\n    const v1 = CartesianType.fromArray(\n      sourceValues,\n      i1 * numberOfComponents,\n      v1Scratch,\n    );\n    const v2 = CartesianType.fromArray(\n      sourceValues,\n      i2 * numberOfComponents,\n      v2Scratch,\n    );\n\n    CartesianType.multiplyByScalar(v0, coords.x, v0);\n    CartesianType.multiplyByScalar(v1, coords.y, v1);\n    CartesianType.multiplyByScalar(v2, coords.z, v2);\n\n    const value = CartesianType.add(v0, v1, v0);\n    CartesianType.add(value, v2, value);\n\n    if (normalize) {\n      CartesianType.normalize(value, value);\n    }\n\n    CartesianType.pack(\n      value,\n      currentValues,\n      insertedIndex * numberOfComponents,\n    );\n  };\n}\n\nconst interpolateAndPackCartesian4 = generateBarycentricInterpolateFunction(\n  Cartesian4,\n  4,\n);\nconst interpolateAndPackCartesian3 = generateBarycentricInterpolateFunction(\n  Cartesian3,\n  3,\n);\nconst interpolateAndPackCartesian2 = generateBarycentricInterpolateFunction(\n  Cartesian2,\n  2,\n);\nconst interpolateAndPackBoolean = function (\n  i0,\n  i1,\n  i2,\n  coords,\n  sourceValues,\n  currentValues,\n  insertedIndex,\n) {\n  const v1 = sourceValues[i0] * coords.x;\n  const v2 = sourceValues[i1] * coords.y;\n  const v3 = sourceValues[i2] * coords.z;\n  currentValues[insertedIndex] = v1 + v2 + v3 > CesiumMath.EPSILON6 ? 1 : 0;\n};\n\nconst p0Scratch = new Cartesian3();\nconst p1Scratch = new Cartesian3();\nconst p2Scratch = new Cartesian3();\nconst barycentricScratch = new Cartesian3();\n\nfunction computeTriangleAttributes(\n  i0,\n  i1,\n  i2,\n  point,\n  positions,\n  normals,\n  tangents,\n  bitangents,\n  texCoords,\n  extrudeDirections,\n  applyOffset,\n  currentAttributes,\n  customAttributeNames,\n  customAttributesLength,\n  allAttributes,\n  insertedIndex,\n) {\n  if (\n    !defined(normals) &&\n    !defined(tangents) &&\n    !defined(bitangents) &&\n    !defined(texCoords) &&\n    !defined(extrudeDirections) &&\n    customAttributesLength === 0\n  ) {\n    return;\n  }\n\n  const p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n  const p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\n  const p2 = Cartesian3.fromArray(positions, i2 * 3, p2Scratch);\n  const coords = barycentricCoordinates(point, p0, p1, p2, barycentricScratch);\n  if (!defined(coords)) {\n    return;\n  }\n\n  if (defined(normals)) {\n    interpolateAndPackCartesian3(\n      i0,\n      i1,\n      i2,\n      coords,\n      normals,\n      currentAttributes.normal.values,\n      insertedIndex,\n      true,\n    );\n  }\n\n  if (defined(extrudeDirections)) {\n    const d0 = Cartesian3.fromArray(extrudeDirections, i0 * 3, p0Scratch);\n    const d1 = Cartesian3.fromArray(extrudeDirections, i1 * 3, p1Scratch);\n    const d2 = Cartesian3.fromArray(extrudeDirections, i2 * 3, p2Scratch);\n\n    Cartesian3.multiplyByScalar(d0, coords.x, d0);\n    Cartesian3.multiplyByScalar(d1, coords.y, d1);\n    Cartesian3.multiplyByScalar(d2, coords.z, d2);\n\n    let direction;\n    if (\n      !Cartesian3.equals(d0, Cartesian3.ZERO) ||\n      !Cartesian3.equals(d1, Cartesian3.ZERO) ||\n      !Cartesian3.equals(d2, Cartesian3.ZERO)\n    ) {\n      direction = Cartesian3.add(d0, d1, d0);\n      Cartesian3.add(direction, d2, direction);\n      Cartesian3.normalize(direction, direction);\n    } else {\n      direction = p0Scratch;\n      direction.x = 0;\n      direction.y = 0;\n      direction.z = 0;\n    }\n    Cartesian3.pack(\n      direction,\n      currentAttributes.extrudeDirection.values,\n      insertedIndex * 3,\n    );\n  }\n\n  if (defined(applyOffset)) {\n    interpolateAndPackBoolean(\n      i0,\n      i1,\n      i2,\n      coords,\n      applyOffset,\n      currentAttributes.applyOffset.values,\n      insertedIndex,\n    );\n  }\n\n  if (defined(tangents)) {\n    interpolateAndPackCartesian3(\n      i0,\n      i1,\n      i2,\n      coords,\n      tangents,\n      currentAttributes.tangent.values,\n      insertedIndex,\n      true,\n    );\n  }\n\n  if (defined(bitangents)) {\n    interpolateAndPackCartesian3(\n      i0,\n      i1,\n      i2,\n      coords,\n      bitangents,\n      currentAttributes.bitangent.values,\n      insertedIndex,\n      true,\n    );\n  }\n\n  if (defined(texCoords)) {\n    interpolateAndPackCartesian2(\n      i0,\n      i1,\n      i2,\n      coords,\n      texCoords,\n      currentAttributes.st.values,\n      insertedIndex,\n    );\n  }\n\n  if (customAttributesLength > 0) {\n    for (let i = 0; i < customAttributesLength; i++) {\n      const attributeName = customAttributeNames[i];\n      genericInterpolate(\n        i0,\n        i1,\n        i2,\n        coords,\n        insertedIndex,\n        allAttributes[attributeName],\n        currentAttributes[attributeName],\n      );\n    }\n  }\n}\n\nfunction genericInterpolate(\n  i0,\n  i1,\n  i2,\n  coords,\n  insertedIndex,\n  sourceAttribute,\n  currentAttribute,\n) {\n  const componentsPerAttribute = sourceAttribute.componentsPerAttribute;\n  const sourceValues = sourceAttribute.values;\n  const currentValues = currentAttribute.values;\n  switch (componentsPerAttribute) {\n    case 4:\n      interpolateAndPackCartesian4(\n        i0,\n        i1,\n        i2,\n        coords,\n        sourceValues,\n        currentValues,\n        insertedIndex,\n        false,\n      );\n      break;\n    case 3:\n      interpolateAndPackCartesian3(\n        i0,\n        i1,\n        i2,\n        coords,\n        sourceValues,\n        currentValues,\n        insertedIndex,\n        false,\n      );\n      break;\n    case 2:\n      interpolateAndPackCartesian2(\n        i0,\n        i1,\n        i2,\n        coords,\n        sourceValues,\n        currentValues,\n        insertedIndex,\n        false,\n      );\n      break;\n    default:\n      currentValues[insertedIndex] =\n        sourceValues[i0] * coords.x +\n        sourceValues[i1] * coords.y +\n        sourceValues[i2] * coords.z;\n  }\n}\n\nfunction insertSplitPoint(\n  currentAttributes,\n  currentIndices,\n  currentIndexMap,\n  indices,\n  currentIndex,\n  point,\n) {\n  const insertIndex = currentAttributes.position.values.length / 3;\n\n  if (currentIndex !== -1) {\n    const prevIndex = indices[currentIndex];\n    const newIndex = currentIndexMap[prevIndex];\n\n    if (newIndex === -1) {\n      currentIndexMap[prevIndex] = insertIndex;\n      currentAttributes.position.values.push(point.x, point.y, point.z);\n      currentIndices.push(insertIndex);\n      return insertIndex;\n    }\n\n    currentIndices.push(newIndex);\n    return newIndex;\n  }\n\n  currentAttributes.position.values.push(point.x, point.y, point.z);\n  currentIndices.push(insertIndex);\n  return insertIndex;\n}\n\nconst NAMED_ATTRIBUTES = {\n  position: true,\n  normal: true,\n  bitangent: true,\n  tangent: true,\n  st: true,\n  extrudeDirection: true,\n  applyOffset: true,\n};\nfunction splitLongitudeTriangles(instance) {\n  const geometry = instance.geometry;\n  const attributes = geometry.attributes;\n  const positions = attributes.position.values;\n  const normals = defined(attributes.normal)\n    ? attributes.normal.values\n    : undefined;\n  const bitangents = defined(attributes.bitangent)\n    ? attributes.bitangent.values\n    : undefined;\n  const tangents = defined(attributes.tangent)\n    ? attributes.tangent.values\n    : undefined;\n  const texCoords = defined(attributes.st) ? attributes.st.values : undefined;\n  const extrudeDirections = defined(attributes.extrudeDirection)\n    ? attributes.extrudeDirection.values\n    : undefined;\n  const applyOffset = defined(attributes.applyOffset)\n    ? attributes.applyOffset.values\n    : undefined;\n  const indices = geometry.indices;\n\n  const customAttributeNames = [];\n  for (const attributeName in attributes) {\n    if (\n      attributes.hasOwnProperty(attributeName) &&\n      !NAMED_ATTRIBUTES[attributeName] &&\n      defined(attributes[attributeName])\n    ) {\n      customAttributeNames.push(attributeName);\n    }\n  }\n  const customAttributesLength = customAttributeNames.length;\n\n  const eastGeometry = copyGeometryForSplit(geometry);\n  const westGeometry = copyGeometryForSplit(geometry);\n\n  let currentAttributes;\n  let currentIndices;\n  let currentIndexMap;\n  let insertedIndex;\n  let i;\n\n  const westGeometryIndexMap = [];\n  westGeometryIndexMap.length = positions.length / 3;\n\n  const eastGeometryIndexMap = [];\n  eastGeometryIndexMap.length = positions.length / 3;\n\n  for (i = 0; i < westGeometryIndexMap.length; ++i) {\n    westGeometryIndexMap[i] = -1;\n    eastGeometryIndexMap[i] = -1;\n  }\n\n  const len = indices.length;\n  for (i = 0; i < len; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n\n    let p0 = Cartesian3.fromArray(positions, i0 * 3);\n    let p1 = Cartesian3.fromArray(positions, i1 * 3);\n    let p2 = Cartesian3.fromArray(positions, i2 * 3);\n\n    const result = splitTriangle(p0, p1, p2);\n    if (defined(result) && result.positions.length > 3) {\n      const resultPositions = result.positions;\n      const resultIndices = result.indices;\n      const resultLength = resultIndices.length;\n\n      for (let j = 0; j < resultLength; ++j) {\n        const resultIndex = resultIndices[j];\n        const point = resultPositions[resultIndex];\n\n        if (point.y < 0.0) {\n          currentAttributes = westGeometry.attributes;\n          currentIndices = westGeometry.indices;\n          currentIndexMap = westGeometryIndexMap;\n        } else {\n          currentAttributes = eastGeometry.attributes;\n          currentIndices = eastGeometry.indices;\n          currentIndexMap = eastGeometryIndexMap;\n        }\n\n        insertedIndex = insertSplitPoint(\n          currentAttributes,\n          currentIndices,\n          currentIndexMap,\n          indices,\n          resultIndex < 3 ? i + resultIndex : -1,\n          point,\n        );\n        computeTriangleAttributes(\n          i0,\n          i1,\n          i2,\n          point,\n          positions,\n          normals,\n          tangents,\n          bitangents,\n          texCoords,\n          extrudeDirections,\n          applyOffset,\n          currentAttributes,\n          customAttributeNames,\n          customAttributesLength,\n          attributes,\n          insertedIndex,\n        );\n      }\n    } else {\n      if (defined(result)) {\n        p0 = result.positions[0];\n        p1 = result.positions[1];\n        p2 = result.positions[2];\n      }\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n        currentIndexMap = westGeometryIndexMap;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n        currentIndexMap = eastGeometryIndexMap;\n      }\n\n      insertedIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i,\n        p0,\n      );\n      computeTriangleAttributes(\n        i0,\n        i1,\n        i2,\n        p0,\n        positions,\n        normals,\n        tangents,\n        bitangents,\n        texCoords,\n        extrudeDirections,\n        applyOffset,\n        currentAttributes,\n        customAttributeNames,\n        customAttributesLength,\n        attributes,\n        insertedIndex,\n      );\n\n      insertedIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i + 1,\n        p1,\n      );\n      computeTriangleAttributes(\n        i0,\n        i1,\n        i2,\n        p1,\n        positions,\n        normals,\n        tangents,\n        bitangents,\n        texCoords,\n        extrudeDirections,\n        applyOffset,\n        currentAttributes,\n        customAttributeNames,\n        customAttributesLength,\n        attributes,\n        insertedIndex,\n      );\n\n      insertedIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i + 2,\n        p2,\n      );\n      computeTriangleAttributes(\n        i0,\n        i1,\n        i2,\n        p2,\n        positions,\n        normals,\n        tangents,\n        bitangents,\n        texCoords,\n        extrudeDirections,\n        applyOffset,\n        currentAttributes,\n        customAttributeNames,\n        customAttributesLength,\n        attributes,\n        insertedIndex,\n      );\n    }\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\nconst xzPlane = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\n\nconst offsetScratch = new Cartesian3();\nconst offsetPointScratch = new Cartesian3();\n\nfunction computeLineAttributes(\n  i0,\n  i1,\n  point,\n  positions,\n  insertIndex,\n  currentAttributes,\n  applyOffset,\n) {\n  if (!defined(applyOffset)) {\n    return;\n  }\n\n  const p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n  if (Cartesian3.equalsEpsilon(p0, point, CesiumMath.EPSILON10)) {\n    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i0];\n  } else {\n    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i1];\n  }\n}\n\nfunction splitLongitudeLines(instance) {\n  const geometry = instance.geometry;\n  const attributes = geometry.attributes;\n  const positions = attributes.position.values;\n  const applyOffset = defined(attributes.applyOffset)\n    ? attributes.applyOffset.values\n    : undefined;\n  const indices = geometry.indices;\n\n  const eastGeometry = copyGeometryForSplit(geometry);\n  const westGeometry = copyGeometryForSplit(geometry);\n\n  let i;\n  const length = indices.length;\n\n  const westGeometryIndexMap = [];\n  westGeometryIndexMap.length = positions.length / 3;\n\n  const eastGeometryIndexMap = [];\n  eastGeometryIndexMap.length = positions.length / 3;\n\n  for (i = 0; i < westGeometryIndexMap.length; ++i) {\n    westGeometryIndexMap[i] = -1;\n    eastGeometryIndexMap[i] = -1;\n  }\n\n  for (i = 0; i < length; i += 2) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n\n    const p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n    const p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\n    let insertIndex;\n\n    if (Math.abs(p0.y) < CesiumMath.EPSILON6) {\n      if (p0.y < 0.0) {\n        p0.y = -CesiumMath.EPSILON6;\n      } else {\n        p0.y = CesiumMath.EPSILON6;\n      }\n    }\n\n    if (Math.abs(p1.y) < CesiumMath.EPSILON6) {\n      if (p1.y < 0.0) {\n        p1.y = -CesiumMath.EPSILON6;\n      } else {\n        p1.y = CesiumMath.EPSILON6;\n      }\n    }\n\n    let p0Attributes = eastGeometry.attributes;\n    let p0Indices = eastGeometry.indices;\n    let p0IndexMap = eastGeometryIndexMap;\n    let p1Attributes = westGeometry.attributes;\n    let p1Indices = westGeometry.indices;\n    let p1IndexMap = westGeometryIndexMap;\n\n    const intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      xzPlane,\n      p2Scratch,\n    );\n    if (defined(intersection)) {\n      // move point on the xz-plane slightly away from the plane\n      const offset = Cartesian3.multiplyByScalar(\n        Cartesian3.UNIT_Y,\n        5.0 * CesiumMath.EPSILON9,\n        offsetScratch,\n      );\n      if (p0.y < 0.0) {\n        Cartesian3.negate(offset, offset);\n\n        p0Attributes = westGeometry.attributes;\n        p0Indices = westGeometry.indices;\n        p0IndexMap = westGeometryIndexMap;\n        p1Attributes = eastGeometry.attributes;\n        p1Indices = eastGeometry.indices;\n        p1IndexMap = eastGeometryIndexMap;\n      }\n\n      const offsetPoint = Cartesian3.add(\n        intersection,\n        offset,\n        offsetPointScratch,\n      );\n\n      insertIndex = insertSplitPoint(\n        p0Attributes,\n        p0Indices,\n        p0IndexMap,\n        indices,\n        i,\n        p0,\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p0,\n        positions,\n        insertIndex,\n        p0Attributes,\n        applyOffset,\n      );\n\n      insertIndex = insertSplitPoint(\n        p0Attributes,\n        p0Indices,\n        p0IndexMap,\n        indices,\n        -1,\n        offsetPoint,\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        offsetPoint,\n        positions,\n        insertIndex,\n        p0Attributes,\n        applyOffset,\n      );\n\n      Cartesian3.negate(offset, offset);\n      Cartesian3.add(intersection, offset, offsetPoint);\n      insertIndex = insertSplitPoint(\n        p1Attributes,\n        p1Indices,\n        p1IndexMap,\n        indices,\n        -1,\n        offsetPoint,\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        offsetPoint,\n        positions,\n        insertIndex,\n        p1Attributes,\n        applyOffset,\n      );\n\n      insertIndex = insertSplitPoint(\n        p1Attributes,\n        p1Indices,\n        p1IndexMap,\n        indices,\n        i + 1,\n        p1,\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p1,\n        positions,\n        insertIndex,\n        p1Attributes,\n        applyOffset,\n      );\n    } else {\n      let currentAttributes;\n      let currentIndices;\n      let currentIndexMap;\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n        currentIndexMap = westGeometryIndexMap;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n        currentIndexMap = eastGeometryIndexMap;\n      }\n\n      insertIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i,\n        p0,\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p0,\n        positions,\n        insertIndex,\n        currentAttributes,\n        applyOffset,\n      );\n\n      insertIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i + 1,\n        p1,\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p1,\n        positions,\n        insertIndex,\n        currentAttributes,\n        applyOffset,\n      );\n    }\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\nconst cartesian2Scratch0 = new Cartesian2();\nconst cartesian2Scratch1 = new Cartesian2();\n\nconst cartesian3Scratch0 = new Cartesian3();\nconst cartesian3Scratch2 = new Cartesian3();\nconst cartesian3Scratch3 = new Cartesian3();\nconst cartesian3Scratch4 = new Cartesian3();\nconst cartesian3Scratch5 = new Cartesian3();\nconst cartesian3Scratch6 = new Cartesian3();\n\nconst cartesian4Scratch0 = new Cartesian4();\n\nfunction updateAdjacencyAfterSplit(geometry) {\n  const attributes = geometry.attributes;\n  const positions = attributes.position.values;\n  const prevPositions = attributes.prevPosition.values;\n  const nextPositions = attributes.nextPosition.values;\n\n  const length = positions.length;\n  for (let j = 0; j < length; j += 3) {\n    const position = Cartesian3.unpack(positions, j, cartesian3Scratch0);\n    if (position.x > 0.0) {\n      continue;\n    }\n\n    const prevPosition = Cartesian3.unpack(\n      prevPositions,\n      j,\n      cartesian3Scratch2,\n    );\n    if (\n      (position.y < 0.0 && prevPosition.y > 0.0) ||\n      (position.y > 0.0 && prevPosition.y < 0.0)\n    ) {\n      if (j - 3 > 0) {\n        prevPositions[j] = positions[j - 3];\n        prevPositions[j + 1] = positions[j - 2];\n        prevPositions[j + 2] = positions[j - 1];\n      } else {\n        Cartesian3.pack(position, prevPositions, j);\n      }\n    }\n\n    const nextPosition = Cartesian3.unpack(\n      nextPositions,\n      j,\n      cartesian3Scratch3,\n    );\n    if (\n      (position.y < 0.0 && nextPosition.y > 0.0) ||\n      (position.y > 0.0 && nextPosition.y < 0.0)\n    ) {\n      if (j + 3 < length) {\n        nextPositions[j] = positions[j + 3];\n        nextPositions[j + 1] = positions[j + 4];\n        nextPositions[j + 2] = positions[j + 5];\n      } else {\n        Cartesian3.pack(position, nextPositions, j);\n      }\n    }\n  }\n}\n\nconst offsetScalar = 5.0 * CesiumMath.EPSILON9;\nconst coplanarOffset = CesiumMath.EPSILON6;\n\nfunction splitLongitudePolyline(instance) {\n  const geometry = instance.geometry;\n  const attributes = geometry.attributes;\n  const positions = attributes.position.values;\n  const prevPositions = attributes.prevPosition.values;\n  const nextPositions = attributes.nextPosition.values;\n  const expandAndWidths = attributes.expandAndWidth.values;\n\n  const texCoords = defined(attributes.st) ? attributes.st.values : undefined;\n  const colors = defined(attributes.color)\n    ? attributes.color.values\n    : undefined;\n\n  const eastGeometry = copyGeometryForSplit(geometry);\n  const westGeometry = copyGeometryForSplit(geometry);\n\n  let i;\n  let j;\n  let index;\n\n  let intersectionFound = false;\n\n  const length = positions.length / 3;\n  for (i = 0; i < length; i += 4) {\n    const i0 = i;\n    const i2 = i + 2;\n\n    const p0 = Cartesian3.fromArray(positions, i0 * 3, cartesian3Scratch0);\n    const p2 = Cartesian3.fromArray(positions, i2 * 3, cartesian3Scratch2);\n\n    // Offset points that are close to the 180 longitude and change the previous/next point\n    // to be the same offset point so it can be projected to 2D. There is special handling in the\n    // shader for when position == prevPosition || position == nextPosition.\n    if (Math.abs(p0.y) < coplanarOffset) {\n      p0.y = coplanarOffset * (p2.y < 0.0 ? -1.0 : 1.0);\n      positions[i * 3 + 1] = p0.y;\n      positions[(i + 1) * 3 + 1] = p0.y;\n\n      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\n        prevPositions[j] = positions[i * 3];\n        prevPositions[j + 1] = positions[i * 3 + 1];\n        prevPositions[j + 2] = positions[i * 3 + 2];\n      }\n    }\n\n    // Do the same but for when the line crosses 180 longitude in the opposite direction.\n    if (Math.abs(p2.y) < coplanarOffset) {\n      p2.y = coplanarOffset * (p0.y < 0.0 ? -1.0 : 1.0);\n      positions[(i + 2) * 3 + 1] = p2.y;\n      positions[(i + 3) * 3 + 1] = p2.y;\n\n      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\n        nextPositions[j] = positions[(i + 2) * 3];\n        nextPositions[j + 1] = positions[(i + 2) * 3 + 1];\n        nextPositions[j + 2] = positions[(i + 2) * 3 + 2];\n      }\n    }\n\n    let p0Attributes = eastGeometry.attributes;\n    let p0Indices = eastGeometry.indices;\n    let p2Attributes = westGeometry.attributes;\n    let p2Indices = westGeometry.indices;\n\n    const intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p2,\n      xzPlane,\n      cartesian3Scratch4,\n    );\n    if (defined(intersection)) {\n      intersectionFound = true;\n\n      // move point on the xz-plane slightly away from the plane\n      const offset = Cartesian3.multiplyByScalar(\n        Cartesian3.UNIT_Y,\n        offsetScalar,\n        cartesian3Scratch5,\n      );\n      if (p0.y < 0.0) {\n        Cartesian3.negate(offset, offset);\n        p0Attributes = westGeometry.attributes;\n        p0Indices = westGeometry.indices;\n        p2Attributes = eastGeometry.attributes;\n        p2Indices = eastGeometry.indices;\n      }\n\n      const offsetPoint = Cartesian3.add(\n        intersection,\n        offset,\n        cartesian3Scratch6,\n      );\n      p0Attributes.position.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\n      p0Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p0Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n\n      p0Attributes.prevPosition.values.push(\n        prevPositions[i0 * 3],\n        prevPositions[i0 * 3 + 1],\n        prevPositions[i0 * 3 + 2],\n      );\n      p0Attributes.prevPosition.values.push(\n        prevPositions[i0 * 3 + 3],\n        prevPositions[i0 * 3 + 4],\n        prevPositions[i0 * 3 + 5],\n      );\n      p0Attributes.prevPosition.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\n\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n\n      Cartesian3.negate(offset, offset);\n      Cartesian3.add(intersection, offset, offsetPoint);\n      p2Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p2Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p2Attributes.position.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\n\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n\n      p2Attributes.nextPosition.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\n      p2Attributes.nextPosition.values.push(\n        nextPositions[i2 * 3],\n        nextPositions[i2 * 3 + 1],\n        nextPositions[i2 * 3 + 2],\n      );\n      p2Attributes.nextPosition.values.push(\n        nextPositions[i2 * 3 + 3],\n        nextPositions[i2 * 3 + 4],\n        nextPositions[i2 * 3 + 5],\n      );\n\n      const ew0 = Cartesian2.fromArray(\n        expandAndWidths,\n        i0 * 2,\n        cartesian2Scratch0,\n      );\n      const width = Math.abs(ew0.y);\n\n      p0Attributes.expandAndWidth.values.push(-1, width, 1, width);\n      p0Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\n      p2Attributes.expandAndWidth.values.push(-1, width, 1, width);\n      p2Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\n\n      let t = Cartesian3.magnitudeSquared(\n        Cartesian3.subtract(intersection, p0, cartesian3Scratch3),\n      );\n      t /= Cartesian3.magnitudeSquared(\n        Cartesian3.subtract(p2, p0, cartesian3Scratch3),\n      );\n\n      if (defined(colors)) {\n        const c0 = Cartesian4.fromArray(colors, i0 * 4, cartesian4Scratch0);\n        const c2 = Cartesian4.fromArray(colors, i2 * 4, cartesian4Scratch0);\n\n        const r = CesiumMath.lerp(c0.x, c2.x, t);\n        const g = CesiumMath.lerp(c0.y, c2.y, t);\n        const b = CesiumMath.lerp(c0.z, c2.z, t);\n        const a = CesiumMath.lerp(c0.w, c2.w, t);\n\n        for (j = i0 * 4; j < i0 * 4 + 2 * 4; ++j) {\n          p0Attributes.color.values.push(colors[j]);\n        }\n        p0Attributes.color.values.push(r, g, b, a);\n        p0Attributes.color.values.push(r, g, b, a);\n        p2Attributes.color.values.push(r, g, b, a);\n        p2Attributes.color.values.push(r, g, b, a);\n        for (j = i2 * 4; j < i2 * 4 + 2 * 4; ++j) {\n          p2Attributes.color.values.push(colors[j]);\n        }\n      }\n\n      if (defined(texCoords)) {\n        const s0 = Cartesian2.fromArray(texCoords, i0 * 2, cartesian2Scratch0);\n        const s3 = Cartesian2.fromArray(\n          texCoords,\n          (i + 3) * 2,\n          cartesian2Scratch1,\n        );\n\n        const sx = CesiumMath.lerp(s0.x, s3.x, t);\n\n        for (j = i0 * 2; j < i0 * 2 + 2 * 2; ++j) {\n          p0Attributes.st.values.push(texCoords[j]);\n        }\n        p0Attributes.st.values.push(sx, s0.y);\n        p0Attributes.st.values.push(sx, s3.y);\n        p2Attributes.st.values.push(sx, s0.y);\n        p2Attributes.st.values.push(sx, s3.y);\n        for (j = i2 * 2; j < i2 * 2 + 2 * 2; ++j) {\n          p2Attributes.st.values.push(texCoords[j]);\n        }\n      }\n\n      index = p0Attributes.position.values.length / 3 - 4;\n      p0Indices.push(index, index + 2, index + 1);\n      p0Indices.push(index + 1, index + 2, index + 3);\n\n      index = p2Attributes.position.values.length / 3 - 4;\n      p2Indices.push(index, index + 2, index + 1);\n      p2Indices.push(index + 1, index + 2, index + 3);\n    } else {\n      let currentAttributes;\n      let currentIndices;\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n      }\n\n      currentAttributes.position.values.push(p0.x, p0.y, p0.z);\n      currentAttributes.position.values.push(p0.x, p0.y, p0.z);\n      currentAttributes.position.values.push(p2.x, p2.y, p2.z);\n      currentAttributes.position.values.push(p2.x, p2.y, p2.z);\n\n      for (j = i * 3; j < i * 3 + 4 * 3; ++j) {\n        currentAttributes.prevPosition.values.push(prevPositions[j]);\n        currentAttributes.nextPosition.values.push(nextPositions[j]);\n      }\n\n      for (j = i * 2; j < i * 2 + 4 * 2; ++j) {\n        currentAttributes.expandAndWidth.values.push(expandAndWidths[j]);\n        if (defined(texCoords)) {\n          currentAttributes.st.values.push(texCoords[j]);\n        }\n      }\n\n      if (defined(colors)) {\n        for (j = i * 4; j < i * 4 + 4 * 4; ++j) {\n          currentAttributes.color.values.push(colors[j]);\n        }\n      }\n\n      index = currentAttributes.position.values.length / 3 - 4;\n      currentIndices.push(index, index + 2, index + 1);\n      currentIndices.push(index + 1, index + 2, index + 3);\n    }\n  }\n\n  if (intersectionFound) {\n    updateAdjacencyAfterSplit(westGeometry);\n    updateAdjacencyAfterSplit(eastGeometry);\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\n/**\n * Splits the instances's geometry, by introducing new vertices and indices,that\n * intersect the International Date Line and Prime Meridian so that no primitives cross longitude\n * -180/180 degrees.  This is not required for 3D drawing, but is required for\n * correcting drawing in 2D and Columbus view.\n *\n * @private\n *\n * @param {GeometryInstance} instance The instance to modify.\n * @returns {GeometryInstance} The modified <code>instance</code> argument, with it's geometry split at the International Date Line.\n *\n * @example\n * instance = Cesium.GeometryPipeline.splitLongitude(instance);\n */\nGeometryPipeline.splitLongitude = function (instance) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instance)) {\n    throw new DeveloperError(\"instance is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const geometry = instance.geometry;\n  const boundingSphere = geometry.boundingSphere;\n  if (defined(boundingSphere)) {\n    const minX = boundingSphere.center.x - boundingSphere.radius;\n    if (\n      minX > 0 ||\n      BoundingSphere.intersectPlane(boundingSphere, Plane.ORIGIN_ZX_PLANE) !==\n        Intersect.INTERSECTING\n    ) {\n      return instance;\n    }\n  }\n\n  if (geometry.geometryType !== GeometryType.NONE) {\n    switch (geometry.geometryType) {\n      case GeometryType.POLYLINES:\n        splitLongitudePolyline(instance);\n        break;\n      case GeometryType.TRIANGLES:\n        splitLongitudeTriangles(instance);\n        break;\n      case GeometryType.LINES:\n        splitLongitudeLines(instance);\n        break;\n    }\n  } else {\n    indexPrimitive(geometry);\n    if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\n      splitLongitudeTriangles(instance);\n    } else if (geometry.primitiveType === PrimitiveType.LINES) {\n      splitLongitudeLines(instance);\n    }\n  }\n\n  return instance;\n};\nexport default GeometryPipeline;\n"],"names":["GeometryPipeline","addTriangle","lines","index","i0","i1","i2","trianglesToLines","triangles","count","length","size","createTypedArray","i","triangleStripToLines","Uint16Array","triangleFanToLines","base","toWireframe","geometry","indices","primitiveType","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","LINES","createLineSegmentsForVectors","attributeName","attributes","position","positions","values","vectors","positionsLength","newPositions","Float64Array","j","newBoundingSphere","bs","boundingSphere","center","radius","componentDatatype","DOUBLE","componentsPerAttribute","createAttributeLocations","semantics","len","semantic","name","hasOwnProperty","reorderForPreVertexCache","numVertices","computeNumberOfVertices","indexCrossReferenceOldToNew","Int32Array","indicesIn","numIndices","indicesOut","intoIndicesIn","intoIndicesOut","nextIndex","tempIndex","property","attribute","elementsIn","intoElementsIn","numComponents","elementsOut","temp","reorderForPostVertexCache","cacheCapacity","maximumIndex","tipsify","cacheSize","copyAttributesDescriptions","newAttributes","attr","normalize","copyVertex","destinationAttributes","sourceAttributes","k","push","fitToUnsignedShortIndices","POINTS","geometries","numberOfVertices","SIXTY_FOUR_KILOBYTES","oldToNewIndex","newIndices","currentIndex","originalIndices","numberOfIndices","indicesPerPrimitive","x","boundingSphereCV","scratchProjectTo2DCartesian3","scratchProjectTo2DCartographic","projectTo2D","attributeName3D","attributeName2D","projection","ellipsoid","values3D","projectedValues","value","fromArray","lonLat","cartesianToCartographic","y","z","projectedLonLat","project","encodedResult","high","low","encodeAttribute","attributeHighName","attributeLowName","highValues","Float32Array","lowValues","encode","FLOAT","scratchCartesian3","transformPoint","matrix","unpack","multiplyByPoint","pack","transformVector","multiplyByVector","inverseTranspose","normalMatrix","transformToWorldCoordinates","instance","modelMatrix","equals","IDENTITY","prevPosition","nextPosition","normal","tangent","bitangent","inverse","transpose","getMatrix3","transform","clone","findAttributesInAllGeometries","instances","propertyName","attributesInAllGeometries","attributes0","numberOfComponents","inAllGeometries","otherAttribute","tempScratch","combineGeometries","m","haveIndices","sourceValues","sourceValuesLength","destIndices","destOffset","offset","sourceIndices","sourceIndicesLen","undefined","add","divideByScalar","tempRadius","magnitude","subtract","combineInstances","instanceGeometry","instanceSplitGeometry","westHemisphereGeometry","eastHemisphereGeometry","v0","v1","v2","computeNormal","vertices","normalsPerVertex","Array","normalsPerTriangle","normalIndices","indexOffset","currentCount","i03","i13","i23","cross","vertexNormalData","normalValues","i3","ZERO","equalsEpsilon","EPSILON10","normalScratch","normalScale","tScratch","computeTangentAndBitangent","st","normals","tan1","i02","i12","i22","ux","uy","uz","wx","wy","t1","t2","r","sdirx","sdiry","sdirz","tangentValues","bitangentValues","n","t","scalar","dot","multiplyByScalar","scratchCartesian2","toEncode1","toEncode2","toEncode3","encodeResult2","compressVertices","extrudeAttribute","extrudeDirection","extrudeDirections","compressedDirections","octEncodeInRange","compressedAttributes","normalAttribute","stAttribute","hasNormal","hasSt","tangentAttribute","bitangentAttribute","hasTangent","hasBitangent","tangents","bitangents","compressedLength","numCompressedComponents","normalIndex","compressTextureCoordinates","octPack","octEncodeFloat","indexTriangles","indexTriangleFan","indicesIndex","indexTriangleStrip","indexLines","indexLineStrip","indexLineLoop","indexPrimitive","LINE_STRIP","LINE_LOOP","offsetPointFromXZPlane","p","isBehind","Math","abs","EPSILON6","offsetTriangleFromXZPlane","p0","p1","p2","p0y","p1y","p2y","sign","c3","getXZIntersectionOffsetPoints","u1","u2","q1","q2","splitTriangleResult","splitTriangle","p0Behind","p1Behind","p2Behind","numBehind","updateGeometryAfterSplit","computeBoundingSphere","fromVertices","copyGeometryForSplit","copiedAttributes","updateInstanceAfterSplit","westGeometry","eastGeometry","generateBarycentricInterpolateFunction","CartesianType","v0Scratch","v1Scratch","v2Scratch","coords","currentValues","insertedIndex","interpolateAndPackCartesian4","interpolateAndPackCartesian3","interpolateAndPackCartesian2","interpolateAndPackBoolean","v3","p0Scratch","p1Scratch","p2Scratch","barycentricScratch","computeTriangleAttributes","point","texCoords","applyOffset","currentAttributes","customAttributeNames","customAttributesLength","allAttributes","d0","d1","d2","direction","genericInterpolate","sourceAttribute","currentAttribute","insertSplitPoint","currentIndices","currentIndexMap","insertIndex","prevIndex","newIndex","NAMED_ATTRIBUTES","splitLongitudeTriangles","westGeometryIndexMap","eastGeometryIndexMap","result","resultPositions","resultIndices","resultLength","resultIndex","xzPlane","fromPointNormal","UNIT_Y","offsetScratch","offsetPointScratch","computeLineAttributes","splitLongitudeLines","p0Attributes","p0Indices","p0IndexMap","p1Attributes","p1Indices","p1IndexMap","intersection","lineSegmentPlane","EPSILON9","negate","offsetPoint","cartesian2Scratch0","cartesian2Scratch1","cartesian3Scratch0","cartesian3Scratch2","cartesian3Scratch3","cartesian3Scratch4","cartesian3Scratch5","cartesian3Scratch6","cartesian4Scratch0","updateAdjacencyAfterSplit","prevPositions","nextPositions","offsetScalar","coplanarOffset","splitLongitudePolyline","expandAndWidths","expandAndWidth","colors","color","intersectionFound","p2Attributes","p2Indices","ew0","width","magnitudeSquared","c0","c2","lerp","g","b","a","w","s0","s3","sx","splitLongitude","minX","intersectPlane","ORIGIN_ZX_PLANE","INTERSECTING","geometryType","NONE","POLYLINES"],"mappings":"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","ignoreList":[0]}}]
}