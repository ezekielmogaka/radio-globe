{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/Primitive.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport GeometryAttributes from \"../Core/GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"../Core/GeometryOffsetAttribute.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Plane from \"../Core/Plane.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport subdivideArray from \"../Core/subdivideArray.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport BatchTable from \"./BatchTable.js\";\nimport CullFace from \"./CullFace.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport PrimitivePipeline from \"./PrimitivePipeline.js\";\nimport PrimitiveState from \"./PrimitiveState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\n/**\n * A primitive represents geometry in the {@link Scene}.  The geometry can be from a single {@link GeometryInstance}\n * as shown in example 1 below, or from an array of instances, even if the geometry is from different\n * geometry types, e.g., an {@link RectangleGeometry} and an {@link EllipsoidGeometry} as shown in Code Example 2.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * </p>\n * <p>\n * Combining multiple instances into one primitive is called batching, and significantly improves performance for static data.\n * Instances can be individually picked; {@link Scene#pick} returns their {@link GeometryInstance#id}.  Using\n * per-instance appearances like {@link PerInstanceColorAppearance}, each instance can also have a unique color.\n * </p>\n * <p>\n * {@link Geometry} can either be created and batched on a web worker or the main thread. The first two examples\n * show geometry that will be created on a web worker by using the descriptions of the geometry. The third example\n * shows how to create the geometry on the main thread by explicitly calling the <code>createGeometry</code> method.\n * </p>\n *\n * @alias Primitive\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {GeometryInstance[]|GeometryInstance} [options.geometryInstances] The geometry instances - or a single geometry instance - to render.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive.\n * @param {Appearance} [options.depthFailAppearance] The appearance used to shade this primitive when it fails the depth test.\n * @param {boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.\n * @param {boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {boolean} [options.cull=true] When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands based on their bounding volume.  Set this to <code>false</code> for a small performance gain if you are manually culling the primitive.\n * @param {boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {ShadowMode} [options.shadows=ShadowMode.DISABLED] Determines whether this primitive casts or receives shadows from light sources.\n *\n * @example\n * // 1. Draw a translucent ellipse on the surface with a checkerboard pattern\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipseGeometry({\n *       center : Cesium.Cartesian3.fromDegrees(-100.0, 20.0),\n *       semiMinorAxis : 500000.0,\n *       semiMajorAxis : 1000000.0,\n *       rotation : Cesium.Math.PI_OVER_FOUR,\n *       vertexFormat : Cesium.VertexFormat.POSITION_AND_ST\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.EllipsoidSurfaceAppearance({\n *     material : Cesium.Material.fromType('Checkerboard')\n *   })\n * }));\n *\n * @example\n * // 2. Draw different instances each with a unique color\n * const rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0),\n *     vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)\n *   }\n * });\n * const ellipsoidInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipsoidGeometry({\n *     radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),\n *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),\n *   id : 'ellipsoid',\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *   }\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : [rectangleInstance, ellipsoidInstance],\n *   appearance : new Cesium.PerInstanceColorAppearance()\n * }));\n *\n * @example\n * // 3. Create the geometry on the main thread.\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *     geometry : Cesium.EllipsoidGeometry.createGeometry(new Cesium.EllipsoidGeometry({\n *       radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),\n *       vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL\n *     })),\n *     modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *       Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),\n *     id : 'ellipsoid',\n *     attributes : {\n *       color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *     }\n *   }),\n *   appearance : new Cesium.PerInstanceColorAppearance(),\n *   asynchronous : false\n * }));\n *\n * @see GeometryInstance\n * @see Appearance\n * @see ClassificationPrimitive\n * @see GroundPrimitive\n */\nfunction Primitive(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  /**\n   * The geometry instances rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type GeometryInstance[]|GeometryInstance\n   *\n   * @default undefined\n   */\n  this.geometryInstances = options.geometryInstances;\n\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.appearance = options.appearance;\n  this._appearance = undefined;\n  this._material = undefined;\n\n  /**\n   * The {@link Appearance} used to shade this primitive when it fails the depth test. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * <p>\n   * When using an appearance that requires a color attribute, like PerInstanceColorAppearance,\n   * add a depthFailColor per-instance attribute instead.\n   * </p>\n   *\n   * <p>\n   * Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported,\n   * there may be artifacts.\n   * </p>\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.depthFailAppearance = options.depthFailAppearance;\n  this._depthFailAppearance = undefined;\n  this._depthFailMaterial = undefined;\n\n  /**\n   * The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.\n   * When this is the identity matrix, the primitive is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * <p>\n   * This property is only supported in 3D mode.\n   * </p>\n   *\n   * @type Matrix4\n   *\n   * @default Matrix4.IDENTITY\n   *\n   * @example\n   * const origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * p.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n  this.modelMatrix = Matrix4.clone(options.modelMatrix ?? Matrix4.IDENTITY);\n  this._modelMatrix = new Matrix4();\n\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   */\n  this.show = options.show ?? true;\n\n  this._vertexCacheOptimize = options.vertexCacheOptimize ?? false;\n  this._interleave = options.interleave ?? false;\n  this._releaseGeometryInstances = options.releaseGeometryInstances ?? true;\n  this._allowPicking = options.allowPicking ?? true;\n  this._asynchronous = options.asynchronous ?? true;\n  this._compressVertices = options.compressVertices ?? true;\n\n  /**\n   * When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands\n   * based on their bounding volume.  Set this to <code>false</code> for a small performance gain\n   * if you are manually culling the primitive.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   */\n  this.cull = options.cull ?? true;\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = options.debugShowBoundingVolume ?? false;\n\n  /**\n   * @private\n   */\n  this.rtcCenter = options.rtcCenter;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    defined(this.rtcCenter) &&\n    (!defined(this.geometryInstances) ||\n      (Array.isArray(this.geometryInstances) &&\n        this.geometryInstances.length !== 1))\n  ) {\n    throw new DeveloperError(\n      \"Relative-to-center rendering only supports one geometry instance.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * Determines whether this primitive casts or receives shadows from light sources.\n   *\n   * @type {ShadowMode}\n   *\n   * @default ShadowMode.DISABLED\n   */\n  this.shadows = options.shadows ?? ShadowMode.DISABLED;\n\n  this._translucent = undefined;\n\n  this._state = PrimitiveState.READY;\n  this._geometries = [];\n  this._error = undefined;\n  this._numberOfInstances = 0;\n\n  this._boundingSpheres = [];\n  this._boundingSphereWC = [];\n  this._boundingSphereCV = [];\n  this._boundingSphere2D = [];\n  this._boundingSphereMorph = [];\n  this._perInstanceAttributeCache = new Map();\n  this._instanceIds = [];\n  this._lastPerInstanceAttributeIndex = 0;\n\n  this._va = [];\n  this._attributeLocations = undefined;\n  this._primitiveType = undefined;\n\n  this._frontFaceRS = undefined;\n  this._backFaceRS = undefined;\n  this._sp = undefined;\n\n  this._depthFailAppearance = undefined;\n  this._spDepthFail = undefined;\n  this._frontFaceDepthFailRS = undefined;\n  this._backFaceDepthFailRS = undefined;\n\n  this._pickIds = [];\n\n  this._colorCommands = [];\n  this._pickCommands = [];\n\n  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;\n  this._createRenderStatesFunction = options._createRenderStatesFunction;\n  this._createShaderProgramFunction = options._createShaderProgramFunction;\n  this._createCommandsFunction = options._createCommandsFunction;\n  this._updateAndQueueCommandsFunction =\n    options._updateAndQueueCommandsFunction;\n\n  this._createPickOffsets = options._createPickOffsets;\n  this._pickOffsets = undefined;\n\n  this._createGeometryResults = undefined;\n  this._ready = false;\n\n  this._batchTable = undefined;\n  this._batchTableAttributeIndices = undefined;\n  this._offsetInstanceExtend = undefined;\n  this._batchTableOffsetAttribute2DIndex = undefined;\n  this._batchTableOffsetsUpdated = false;\n  this._instanceBoundingSpheres = undefined;\n  this._instanceBoundingSpheresCV = undefined;\n  this._tempBoundingSpheres = undefined;\n  this._recomputeBoundingSpheres = false;\n  this._batchTableBoundingSpheresUpdated = false;\n  this._batchTableBoundingSphereAttributeIndices = undefined;\n}\n\nObject.defineProperties(Primitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._vertexCacheOptimize;\n    },\n  },\n\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._interleave;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._releaseGeometryInstances;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.         *\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    },\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._asynchronous;\n    },\n  },\n\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._compressVertices;\n    },\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link Primitive#update}\n   * is called.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @example\n   * // Wait for a primitive to become ready before accessing attributes\n   * const removeListener = scene.postRender.addEventListener(() => {\n   *   if (!frustumPrimitive.ready) {\n   *     return;\n   *   }\n   *\n   *   const attributes = primitive.getGeometryInstanceAttributes('an id');\n   *   attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n   *\n   *   removeListener();\n   * });\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n});\n\nfunction getCommonPerInstanceAttributeNames(instances) {\n  const length = instances.length;\n\n  const attributesInAllInstances = [];\n  const attributes0 = instances[0].attributes;\n  let name;\n\n  for (name in attributes0) {\n    if (attributes0.hasOwnProperty(name) && defined(attributes0[name])) {\n      const attribute = attributes0[name];\n      let inAllInstances = true;\n\n      // Does this same attribute exist in all instances?\n      for (let i = 1; i < length; ++i) {\n        const otherAttribute = instances[i].attributes[name];\n\n        if (\n          !defined(otherAttribute) ||\n          attribute.componentDatatype !== otherAttribute.componentDatatype ||\n          attribute.componentsPerAttribute !==\n            otherAttribute.componentsPerAttribute ||\n          attribute.normalize !== otherAttribute.normalize\n        ) {\n          inAllInstances = false;\n          break;\n        }\n      }\n\n      if (inAllInstances) {\n        attributesInAllInstances.push(name);\n      }\n    }\n  }\n\n  return attributesInAllInstances;\n}\n\nconst scratchGetAttributeCartesian2 = new Cartesian2();\nconst scratchGetAttributeCartesian3 = new Cartesian3();\nconst scratchGetAttributeCartesian4 = new Cartesian4();\n\nfunction getAttributeValue(value) {\n  const componentsPerAttribute = value.length;\n  if (componentsPerAttribute === 1) {\n    return value[0];\n  } else if (componentsPerAttribute === 2) {\n    return Cartesian2.unpack(value, 0, scratchGetAttributeCartesian2);\n  } else if (componentsPerAttribute === 3) {\n    return Cartesian3.unpack(value, 0, scratchGetAttributeCartesian3);\n  } else if (componentsPerAttribute === 4) {\n    return Cartesian4.unpack(value, 0, scratchGetAttributeCartesian4);\n  }\n}\n\nfunction createBatchTable(primitive, context) {\n  const geometryInstances = primitive.geometryInstances;\n  const instances = Array.isArray(geometryInstances)\n    ? geometryInstances\n    : [geometryInstances];\n  const numberOfInstances = instances.length;\n  if (numberOfInstances === 0) {\n    return;\n  }\n\n  const names = getCommonPerInstanceAttributeNames(instances);\n  const length = names.length;\n\n  const attributes = [];\n  const attributeIndices = {};\n  const boundingSphereAttributeIndices = {};\n  let offset2DIndex;\n\n  const firstInstance = instances[0];\n  let instanceAttributes = firstInstance.attributes;\n\n  let i;\n  let name;\n  let attribute;\n\n  for (i = 0; i < length; ++i) {\n    name = names[i];\n    attribute = instanceAttributes[name];\n\n    attributeIndices[name] = i;\n    attributes.push({\n      functionName: `czm_batchTable_${name}`,\n      componentDatatype: attribute.componentDatatype,\n      componentsPerAttribute: attribute.componentsPerAttribute,\n      normalize: attribute.normalize,\n    });\n  }\n\n  if (names.indexOf(\"distanceDisplayCondition\") !== -1) {\n    attributes.push(\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter3DHigh\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter3DLow\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter2DHigh\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter2DLow\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereRadius\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 1,\n      },\n    );\n    boundingSphereAttributeIndices.center3DHigh = attributes.length - 5;\n    boundingSphereAttributeIndices.center3DLow = attributes.length - 4;\n    boundingSphereAttributeIndices.center2DHigh = attributes.length - 3;\n    boundingSphereAttributeIndices.center2DLow = attributes.length - 2;\n    boundingSphereAttributeIndices.radius = attributes.length - 1;\n  }\n\n  if (names.indexOf(\"offset\") !== -1) {\n    attributes.push({\n      functionName: \"czm_batchTable_offset2D\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n    });\n    offset2DIndex = attributes.length - 1;\n  }\n\n  attributes.push({\n    functionName: \"czm_batchTable_pickColor\",\n    componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n    componentsPerAttribute: 4,\n    normalize: true,\n  });\n\n  const attributesLength = attributes.length;\n  const batchTable = new BatchTable(context, attributes, numberOfInstances);\n\n  for (i = 0; i < numberOfInstances; ++i) {\n    const instance = instances[i];\n    instanceAttributes = instance.attributes;\n\n    for (let j = 0; j < length; ++j) {\n      name = names[j];\n      attribute = instanceAttributes[name];\n      const value = getAttributeValue(attribute.value);\n      const attributeIndex = attributeIndices[name];\n      batchTable.setBatchedAttribute(i, attributeIndex, value);\n    }\n\n    const pickObject = {\n      primitive: instance.pickPrimitive ?? primitive,\n    };\n\n    if (defined(instance.id)) {\n      pickObject.id = instance.id;\n    }\n\n    const pickId = context.createPickId(pickObject);\n    primitive._pickIds.push(pickId);\n\n    const pickColor = pickId.color;\n    const color = scratchGetAttributeCartesian4;\n    color.x = Color.floatToByte(pickColor.red);\n    color.y = Color.floatToByte(pickColor.green);\n    color.z = Color.floatToByte(pickColor.blue);\n    color.w = Color.floatToByte(pickColor.alpha);\n\n    batchTable.setBatchedAttribute(i, attributesLength - 1, color);\n  }\n\n  primitive._batchTable = batchTable;\n  primitive._batchTableAttributeIndices = attributeIndices;\n  primitive._batchTableBoundingSphereAttributeIndices =\n    boundingSphereAttributeIndices;\n  primitive._batchTableOffsetAttribute2DIndex = offset2DIndex;\n}\n\nfunction cloneAttribute(attribute) {\n  let clonedValues;\n  if (Array.isArray(attribute.values)) {\n    clonedValues = attribute.values.slice(0);\n  } else {\n    clonedValues = new attribute.values.constructor(attribute.values);\n  }\n  return new GeometryAttribute({\n    componentDatatype: attribute.componentDatatype,\n    componentsPerAttribute: attribute.componentsPerAttribute,\n    normalize: attribute.normalize,\n    values: clonedValues,\n  });\n}\n\nfunction cloneGeometry(geometry) {\n  const attributes = geometry.attributes;\n  const newAttributes = new GeometryAttributes();\n  for (const property in attributes) {\n    if (attributes.hasOwnProperty(property) && defined(attributes[property])) {\n      newAttributes[property] = cloneAttribute(attributes[property]);\n    }\n  }\n\n  let indices;\n  if (defined(geometry.indices)) {\n    const sourceValues = geometry.indices;\n    if (Array.isArray(sourceValues)) {\n      indices = sourceValues.slice(0);\n    } else {\n      indices = new sourceValues.constructor(sourceValues);\n    }\n  }\n\n  return new Geometry({\n    attributes: newAttributes,\n    indices: indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: BoundingSphere.clone(geometry.boundingSphere),\n  });\n}\n\nfunction cloneInstance(instance, geometry) {\n  return {\n    geometry: geometry,\n    attributes: instance.attributes,\n    modelMatrix: Matrix4.clone(instance.modelMatrix),\n    pickPrimitive: instance.pickPrimitive,\n    id: instance.id,\n  };\n}\n\nconst positionRegex = /in\\s+vec(?:3|4)\\s+(.*)3DHigh;/g;\n\nPrimitive._modifyShaderPosition = function (\n  primitive,\n  vertexShaderSource,\n  scene3DOnly,\n) {\n  let match;\n\n  let forwardDecl = \"\";\n  let attributes = \"\";\n  let computeFunctions = \"\";\n\n  while ((match = positionRegex.exec(vertexShaderSource)) !== null) {\n    const name = match[1];\n\n    const functionName = `vec4 czm_compute${name[0].toUpperCase()}${name.substr(\n      1,\n    )}()`;\n\n    // Don't forward-declare czm_computePosition because computePosition.glsl already does.\n    if (functionName !== \"vec4 czm_computePosition()\") {\n      forwardDecl += `${functionName};\\n`;\n    }\n\n    if (!defined(primitive.rtcCenter)) {\n      // Use GPU RTE\n      if (!scene3DOnly) {\n        attributes += `in vec3 ${name}2DHigh;\\nin vec3 ${name}2DLow;\\n`;\n\n        computeFunctions +=\n          `${functionName}\\n` +\n          `{\\n` +\n          `    vec4 p;\\n` +\n          `    if (czm_morphTime == 1.0)\\n` +\n          `    {\\n` +\n          `        p = czm_translateRelativeToEye(${name}3DHigh, ${name}3DLow);\\n` +\n          `    }\\n` +\n          `    else if (czm_morphTime == 0.0)\\n` +\n          `    {\\n` +\n          `        p = czm_translateRelativeToEye(${name}2DHigh.zxy, ${name}2DLow.zxy);\\n` +\n          `    }\\n` +\n          `    else\\n` +\n          `    {\\n` +\n          `        p = czm_columbusViewMorph(\\n` +\n          `                czm_translateRelativeToEye(${name}2DHigh.zxy, ${name}2DLow.zxy),\\n` +\n          `                czm_translateRelativeToEye(${name}3DHigh, ${name}3DLow),\\n` +\n          `                czm_morphTime);\\n` +\n          `    }\\n` +\n          `    return p;\\n` +\n          `}\\n\\n`;\n      } else {\n        computeFunctions +=\n          `${functionName}\\n` +\n          `{\\n` +\n          `    return czm_translateRelativeToEye(${name}3DHigh, ${name}3DLow);\\n` +\n          `}\\n\\n`;\n      }\n    } else {\n      // Use RTC\n      vertexShaderSource = vertexShaderSource.replace(\n        /in\\s+vec(?:3|4)\\s+position3DHigh;/g,\n        \"\",\n      );\n      vertexShaderSource = vertexShaderSource.replace(\n        /in\\s+vec(?:3|4)\\s+position3DLow;/g,\n        \"\",\n      );\n\n      forwardDecl += \"uniform mat4 u_modifiedModelView;\\n\";\n      attributes += \"in vec4 position;\\n\";\n\n      computeFunctions +=\n        `${functionName}\\n` +\n        `{\\n` +\n        `    return u_modifiedModelView * position;\\n` +\n        `}\\n\\n`;\n\n      vertexShaderSource = vertexShaderSource.replace(\n        /czm_modelViewRelativeToEye\\s+\\*\\s+/g,\n        \"\",\n      );\n      vertexShaderSource = vertexShaderSource.replace(\n        /czm_modelViewProjectionRelativeToEye/g,\n        \"czm_projection\",\n      );\n    }\n  }\n\n  return [forwardDecl, attributes, vertexShaderSource, computeFunctions].join(\n    \"\\n\",\n  );\n};\n\nPrimitive._appendShowToShader = function (primitive, vertexShaderSource) {\n  if (!defined(primitive._batchTableAttributeIndices.show)) {\n    return vertexShaderSource;\n  }\n\n  const renamedVS = ShaderSource.replaceMain(\n    vertexShaderSource,\n    \"czm_non_show_main\",\n  );\n  const showMain =\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_show_main(); \\n\" +\n    \"    gl_Position *= czm_batchTable_show(batchId); \\n\" +\n    \"}\";\n\n  return `${renamedVS}\\n${showMain}`;\n};\n\nPrimitive._updateColorAttribute = function (\n  primitive,\n  vertexShaderSource,\n  isDepthFail,\n) {\n  // some appearances have a color attribute for per vertex color.\n  // only remove if color is a per instance attribute.\n  if (\n    !defined(primitive._batchTableAttributeIndices.color) &&\n    !defined(primitive._batchTableAttributeIndices.depthFailColor)\n  ) {\n    return vertexShaderSource;\n  }\n\n  if (vertexShaderSource.search(/in\\s+vec4\\s+color;/g) === -1) {\n    return vertexShaderSource;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    isDepthFail &&\n    !defined(primitive._batchTableAttributeIndices.depthFailColor)\n  ) {\n    throw new DeveloperError(\n      \"A depthFailColor per-instance attribute is required when using a depth fail appearance that uses a color attribute.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  let modifiedVS = vertexShaderSource;\n  modifiedVS = modifiedVS.replace(/in\\s+vec4\\s+color;/g, \"\");\n  if (!isDepthFail) {\n    modifiedVS = modifiedVS.replace(\n      /(\\b)color(\\b)/g,\n      \"$1czm_batchTable_color(batchId)$2\",\n    );\n  } else {\n    modifiedVS = modifiedVS.replace(\n      /(\\b)color(\\b)/g,\n      \"$1czm_batchTable_depthFailColor(batchId)$2\",\n    );\n  }\n  return modifiedVS;\n};\n\nfunction appendPickToVertexShader(source) {\n  const renamedVS = ShaderSource.replaceMain(source, \"czm_non_pick_main\");\n  const pickMain =\n    \"out vec4 v_pickColor; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_pick_main(); \\n\" +\n    \"    v_pickColor = czm_batchTable_pickColor(batchId); \\n\" +\n    \"}\";\n\n  return `${renamedVS}\\n${pickMain}`;\n}\n\nfunction appendPickToFragmentShader(source) {\n  return `in vec4 v_pickColor;\\n${source}`;\n}\n\nPrimitive._updatePickColorAttribute = function (source) {\n  let vsPick = source.replace(/in\\s+vec4\\s+pickColor;/g, \"\");\n  vsPick = vsPick.replace(\n    /(\\b)pickColor(\\b)/g,\n    \"$1czm_batchTable_pickColor(batchId)$2\",\n  );\n  return vsPick;\n};\n\nPrimitive._appendOffsetToShader = function (primitive, vertexShaderSource) {\n  if (!defined(primitive._batchTableAttributeIndices.offset)) {\n    return vertexShaderSource;\n  }\n\n  let attr = \"in float batchId;\\n\";\n  attr += \"in float applyOffset;\";\n  let modifiedShader = vertexShaderSource.replace(\n    /in\\s+float\\s+batchId;/g,\n    attr,\n  );\n\n  let str = \"vec4 $1 = czm_computePosition();\\n\";\n  str += \"    if (czm_sceneMode == czm_sceneMode3D)\\n\";\n  str += \"    {\\n\";\n  str +=\n    \"        $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);\";\n  str += \"    }\\n\";\n  str += \"    else\\n\";\n  str += \"    {\\n\";\n  str +=\n    \"        $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);\";\n  str += \"    }\\n\";\n  modifiedShader = modifiedShader.replace(\n    /vec4\\s+([A-Za-z0-9_]+)\\s+=\\s+czm_computePosition\\(\\);/g,\n    str,\n  );\n  return modifiedShader;\n};\n\nPrimitive._appendDistanceDisplayConditionToShader = function (\n  primitive,\n  vertexShaderSource,\n  scene3DOnly,\n) {\n  if (\n    !defined(primitive._batchTableAttributeIndices.distanceDisplayCondition)\n  ) {\n    return vertexShaderSource;\n  }\n\n  const renamedVS = ShaderSource.replaceMain(\n    vertexShaderSource,\n    \"czm_non_distanceDisplayCondition_main\",\n  );\n  let distanceDisplayConditionMain =\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_distanceDisplayCondition_main(); \\n\" +\n    \"    vec2 distanceDisplayCondition = czm_batchTable_distanceDisplayCondition(batchId);\\n\" +\n    \"    vec3 boundingSphereCenter3DHigh = czm_batchTable_boundingSphereCenter3DHigh(batchId);\\n\" +\n    \"    vec3 boundingSphereCenter3DLow = czm_batchTable_boundingSphereCenter3DLow(batchId);\\n\" +\n    \"    float boundingSphereRadius = czm_batchTable_boundingSphereRadius(batchId);\\n\";\n\n  if (!scene3DOnly) {\n    distanceDisplayConditionMain +=\n      \"    vec3 boundingSphereCenter2DHigh = czm_batchTable_boundingSphereCenter2DHigh(batchId);\\n\" +\n      \"    vec3 boundingSphereCenter2DLow = czm_batchTable_boundingSphereCenter2DLow(batchId);\\n\" +\n      \"    vec4 centerRTE;\\n\" +\n      \"    if (czm_morphTime == 1.0)\\n\" +\n      \"    {\\n\" +\n      \"        centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\\n\" +\n      \"    }\\n\" +\n      \"    else if (czm_morphTime == 0.0)\\n\" +\n      \"    {\\n\" +\n      \"        centerRTE = czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy);\\n\" +\n      \"    }\\n\" +\n      \"    else\\n\" +\n      \"    {\\n\" +\n      \"        centerRTE = czm_columbusViewMorph(\\n\" +\n      \"                czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy),\\n\" +\n      \"                czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow),\\n\" +\n      \"                czm_morphTime);\\n\" +\n      \"    }\\n\";\n  } else {\n    distanceDisplayConditionMain +=\n      \"    vec4 centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\\n\";\n  }\n\n  distanceDisplayConditionMain +=\n    \"    float radiusSq = boundingSphereRadius * boundingSphereRadius; \\n\" +\n    \"    float distanceSq; \\n\" +\n    \"    if (czm_sceneMode == czm_sceneMode2D) \\n\" +\n    \"    { \\n\" +\n    \"        distanceSq = czm_eyeHeight2D.y - radiusSq; \\n\" +\n    \"    } \\n\" +\n    \"    else \\n\" +\n    \"    { \\n\" +\n    \"        distanceSq = dot(centerRTE.xyz, centerRTE.xyz) - radiusSq; \\n\" +\n    \"    } \\n\" +\n    \"    distanceSq = max(distanceSq, 0.0); \\n\" +\n    \"    float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x; \\n\" +\n    \"    float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y; \\n\" +\n    \"    float show = (distanceSq >= nearSq && distanceSq <= farSq) ? 1.0 : 0.0; \\n\" +\n    \"    gl_Position *= show; \\n\" +\n    \"}\";\n  return `${renamedVS}\\n${distanceDisplayConditionMain}`;\n};\n\nfunction modifyForEncodedNormals(primitive, vertexShaderSource) {\n  if (!primitive.compressVertices) {\n    return vertexShaderSource;\n  }\n\n  const containsNormal =\n    vertexShaderSource.search(/in\\s+vec3\\s+normal;/g) !== -1;\n  const containsSt = vertexShaderSource.search(/in\\s+vec2\\s+st;/g) !== -1;\n  if (!containsNormal && !containsSt) {\n    return vertexShaderSource;\n  }\n\n  const containsTangent =\n    vertexShaderSource.search(/in\\s+vec3\\s+tangent;/g) !== -1;\n  const containsBitangent =\n    vertexShaderSource.search(/in\\s+vec3\\s+bitangent;/g) !== -1;\n\n  let numComponents = containsSt && containsNormal ? 2.0 : 1.0;\n  numComponents += containsTangent || containsBitangent ? 1 : 0;\n\n  const type = numComponents > 1 ? `vec${numComponents}` : \"float\";\n\n  const attributeName = \"compressedAttributes\";\n  const attributeDecl = `in ${type} ${attributeName};`;\n\n  let globalDecl = \"\";\n  let decode = \"\";\n\n  if (containsSt) {\n    globalDecl += \"vec2 st;\\n\";\n    const stComponent =\n      numComponents > 1 ? `${attributeName}.x` : attributeName;\n    decode += `    st = czm_decompressTextureCoordinates(${stComponent});\\n`;\n  }\n\n  if (containsNormal && containsTangent && containsBitangent) {\n    globalDecl += \"vec3 normal;\\n\" + \"vec3 tangent;\\n\" + \"vec3 bitangent;\\n\";\n    decode += `    czm_octDecode(${attributeName}.${\n      containsSt ? \"yz\" : \"xy\"\n    }, normal, tangent, bitangent);\\n`;\n  } else {\n    if (containsNormal) {\n      globalDecl += \"vec3 normal;\\n\";\n      decode += `    normal = czm_octDecode(${attributeName}${\n        numComponents > 1 ? `.${containsSt ? \"y\" : \"x\"}` : \"\"\n      });\\n`;\n    }\n\n    if (containsTangent) {\n      globalDecl += \"vec3 tangent;\\n\";\n      decode += `    tangent = czm_octDecode(${attributeName}.${\n        containsSt && containsNormal ? \"z\" : \"y\"\n      });\\n`;\n    }\n\n    if (containsBitangent) {\n      globalDecl += \"vec3 bitangent;\\n\";\n      decode += `    bitangent = czm_octDecode(${attributeName}.${\n        containsSt && containsNormal ? \"z\" : \"y\"\n      });\\n`;\n    }\n  }\n\n  let modifiedVS = vertexShaderSource;\n  modifiedVS = modifiedVS.replace(/in\\s+vec3\\s+normal;/g, \"\");\n  modifiedVS = modifiedVS.replace(/in\\s+vec2\\s+st;/g, \"\");\n  modifiedVS = modifiedVS.replace(/in\\s+vec3\\s+tangent;/g, \"\");\n  modifiedVS = modifiedVS.replace(/in\\s+vec3\\s+bitangent;/g, \"\");\n  modifiedVS = ShaderSource.replaceMain(modifiedVS, \"czm_non_compressed_main\");\n  const compressedMain =\n    `${\"void main() \\n\" + \"{ \\n\"}${decode}    czm_non_compressed_main(); \\n` +\n    `}`;\n\n  return [attributeDecl, globalDecl, modifiedVS, compressedMain].join(\"\\n\");\n}\n\nfunction depthClampVS(vertexShaderSource) {\n  let modifiedVS = ShaderSource.replaceMain(\n    vertexShaderSource,\n    \"czm_non_depth_clamp_main\",\n  );\n  modifiedVS +=\n    \"void main() {\\n\" +\n    \"    czm_non_depth_clamp_main();\\n\" +\n    \"    gl_Position = czm_depthClamp(gl_Position);\" +\n    \"}\\n\";\n  return modifiedVS;\n}\n\nfunction depthClampFS(fragmentShaderSource) {\n  let modifiedFS = ShaderSource.replaceMain(\n    fragmentShaderSource,\n    \"czm_non_depth_clamp_main\",\n  );\n  modifiedFS +=\n    \"void main() {\\n\" +\n    \"    czm_non_depth_clamp_main();\\n\" +\n    \"    #if defined(LOG_DEPTH)\\n\" +\n    \"        czm_writeLogDepth();\\n\" +\n    \"    #else\\n\" +\n    \"        czm_writeDepthClamp();\\n\" +\n    \"    #endif\\n\" +\n    \"}\\n\";\n  return modifiedFS;\n}\n\nfunction validateShaderMatching(shaderProgram, attributeLocations) {\n  // For a VAO and shader program to be compatible, the VAO must have\n  // all active attribute in the shader program.  The VAO may have\n  // extra attributes with the only concern being a potential\n  // performance hit due to extra memory bandwidth and cache pollution.\n  // The shader source could have extra attributes that are not used,\n  // but there is no guarantee they will be optimized out.\n  //\n  // Here, we validate that the VAO has all attributes required\n  // to match the shader program.\n  const shaderAttributes = shaderProgram.vertexAttributes;\n\n  //>>includeStart('debug', pragmas.debug);\n  for (const name in shaderAttributes) {\n    if (shaderAttributes.hasOwnProperty(name)) {\n      if (!defined(attributeLocations[name])) {\n        throw new DeveloperError(\n          `Appearance/Geometry mismatch.  The appearance requires vertex shader attribute input '${name}', which was not computed as part of the Geometry.  Use the appearance's vertexFormat property when constructing the geometry.`,\n        );\n      }\n    }\n  }\n  //>>includeEnd('debug');\n}\n\nfunction getUniformFunction(uniforms, name) {\n  return function () {\n    return uniforms[name];\n  };\n}\n\nconst numberOfCreationWorkers = Math.max(\n  FeatureDetection.hardwareConcurrency - 1,\n  1,\n);\nlet createGeometryTaskProcessors;\nconst combineGeometryTaskProcessor = new TaskProcessor(\"combineGeometry\");\n\nfunction loadAsynchronous(primitive, frameState) {\n  let instances;\n  let geometry;\n  let i;\n  let j;\n\n  const instanceIds = primitive._instanceIds;\n\n  if (primitive._state === PrimitiveState.READY) {\n    instances = Array.isArray(primitive.geometryInstances)\n      ? primitive.geometryInstances\n      : [primitive.geometryInstances];\n    const length = (primitive._numberOfInstances = instances.length);\n\n    const promises = [];\n    let subTasks = [];\n    for (i = 0; i < length; ++i) {\n      geometry = instances[i].geometry;\n      instanceIds.push(instances[i].id);\n\n      //>>includeStart('debug', pragmas.debug);\n      if (\n        (defined(geometry._workerName) && defined(geometry._workerPath)) ||\n        (!defined(geometry._workerName) && !defined(geometry._workerPath))\n      ) {\n        throw new DeveloperError(\n          \"Must define either _workerName or _workerPath for asynchronous geometry.\",\n        );\n      }\n      //>>includeEnd('debug');\n\n      subTasks.push({\n        moduleName: geometry._workerName,\n        modulePath: geometry._workerPath,\n        geometry: geometry,\n      });\n    }\n\n    if (!defined(createGeometryTaskProcessors)) {\n      createGeometryTaskProcessors = new Array(numberOfCreationWorkers);\n      for (i = 0; i < numberOfCreationWorkers; i++) {\n        createGeometryTaskProcessors[i] = new TaskProcessor(\"createGeometry\");\n      }\n    }\n\n    let subTask;\n    subTasks = subdivideArray(subTasks, numberOfCreationWorkers);\n\n    for (i = 0; i < subTasks.length; i++) {\n      let packedLength = 0;\n      const workerSubTasks = subTasks[i];\n      const workerSubTasksLength = workerSubTasks.length;\n      for (j = 0; j < workerSubTasksLength; ++j) {\n        subTask = workerSubTasks[j];\n        geometry = subTask.geometry;\n        if (defined(geometry.constructor.pack)) {\n          subTask.offset = packedLength;\n          packedLength +=\n            geometry.constructor.packedLength ?? geometry.packedLength;\n        }\n      }\n\n      let subTaskTransferableObjects;\n\n      if (packedLength > 0) {\n        const array = new Float64Array(packedLength);\n        subTaskTransferableObjects = [array.buffer];\n\n        for (j = 0; j < workerSubTasksLength; ++j) {\n          subTask = workerSubTasks[j];\n          geometry = subTask.geometry;\n          if (defined(geometry.constructor.pack)) {\n            geometry.constructor.pack(geometry, array, subTask.offset);\n            subTask.geometry = array;\n          }\n        }\n      }\n\n      promises.push(\n        createGeometryTaskProcessors[i].scheduleTask(\n          {\n            subTasks: subTasks[i],\n          },\n          subTaskTransferableObjects,\n        ),\n      );\n    }\n\n    primitive._state = PrimitiveState.CREATING;\n\n    Promise.all(promises)\n      .then(function (results) {\n        primitive._createGeometryResults = results;\n        primitive._state = PrimitiveState.CREATED;\n      })\n      .catch(function (error) {\n        setReady(primitive, frameState, PrimitiveState.FAILED, error);\n      });\n  } else if (primitive._state === PrimitiveState.CREATED) {\n    const transferableObjects = [];\n    instances = Array.isArray(primitive.geometryInstances)\n      ? primitive.geometryInstances\n      : [primitive.geometryInstances];\n\n    const scene3DOnly = frameState.scene3DOnly;\n    const projection = frameState.mapProjection;\n\n    const promise = combineGeometryTaskProcessor.scheduleTask(\n      PrimitivePipeline.packCombineGeometryParameters(\n        {\n          createGeometryResults: primitive._createGeometryResults,\n          instances: instances,\n          ellipsoid: projection.ellipsoid,\n          projection: projection,\n          elementIndexUintSupported: frameState.context.elementIndexUint,\n          scene3DOnly: scene3DOnly,\n          vertexCacheOptimize: primitive.vertexCacheOptimize,\n          compressVertices: primitive.compressVertices,\n          modelMatrix: primitive.modelMatrix,\n          createPickOffsets: primitive._createPickOffsets,\n        },\n        transferableObjects,\n      ),\n      transferableObjects,\n    );\n\n    primitive._createGeometryResults = undefined;\n    primitive._state = PrimitiveState.COMBINING;\n\n    Promise.resolve(promise)\n      .then(function (packedResult) {\n        const result =\n          PrimitivePipeline.unpackCombineGeometryResults(packedResult);\n        primitive._geometries = result.geometries;\n        primitive._attributeLocations = result.attributeLocations;\n        primitive.modelMatrix = Matrix4.clone(\n          result.modelMatrix,\n          primitive.modelMatrix,\n        );\n        primitive._pickOffsets = result.pickOffsets;\n        primitive._offsetInstanceExtend = result.offsetInstanceExtend;\n        primitive._instanceBoundingSpheres = result.boundingSpheres;\n        primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;\n\n        if (\n          defined(primitive._geometries) &&\n          primitive._geometries.length > 0\n        ) {\n          primitive._recomputeBoundingSpheres = true;\n          primitive._state = PrimitiveState.COMBINED;\n        } else {\n          setReady(primitive, frameState, PrimitiveState.FAILED, undefined);\n        }\n      })\n      .catch(function (error) {\n        setReady(primitive, frameState, PrimitiveState.FAILED, error);\n      });\n  }\n}\n\nfunction loadSynchronous(primitive, frameState) {\n  const instances = Array.isArray(primitive.geometryInstances)\n    ? primitive.geometryInstances\n    : [primitive.geometryInstances];\n  const length = (primitive._numberOfInstances = instances.length);\n  const clonedInstances = new Array(length);\n  const instanceIds = primitive._instanceIds;\n\n  let instance;\n  let i;\n\n  let geometryIndex = 0;\n  for (i = 0; i < length; i++) {\n    instance = instances[i];\n    const geometry = instance.geometry;\n\n    let createdGeometry;\n    if (defined(geometry.attributes) && defined(geometry.primitiveType)) {\n      createdGeometry = cloneGeometry(geometry);\n    } else {\n      createdGeometry = geometry.constructor.createGeometry(geometry);\n    }\n\n    clonedInstances[geometryIndex++] = cloneInstance(instance, createdGeometry);\n    instanceIds.push(instance.id);\n  }\n\n  clonedInstances.length = geometryIndex;\n\n  const scene3DOnly = frameState.scene3DOnly;\n  const projection = frameState.mapProjection;\n\n  const result = PrimitivePipeline.combineGeometry({\n    instances: clonedInstances,\n    ellipsoid: projection.ellipsoid,\n    projection: projection,\n    elementIndexUintSupported: frameState.context.elementIndexUint,\n    scene3DOnly: scene3DOnly,\n    vertexCacheOptimize: primitive.vertexCacheOptimize,\n    compressVertices: primitive.compressVertices,\n    modelMatrix: primitive.modelMatrix,\n    createPickOffsets: primitive._createPickOffsets,\n  });\n\n  primitive._geometries = result.geometries;\n  primitive._attributeLocations = result.attributeLocations;\n  primitive.modelMatrix = Matrix4.clone(\n    result.modelMatrix,\n    primitive.modelMatrix,\n  );\n  primitive._pickOffsets = result.pickOffsets;\n  primitive._offsetInstanceExtend = result.offsetInstanceExtend;\n  primitive._instanceBoundingSpheres = result.boundingSpheres;\n  primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;\n\n  if (defined(primitive._geometries) && primitive._geometries.length > 0) {\n    primitive._recomputeBoundingSpheres = true;\n    primitive._state = PrimitiveState.COMBINED;\n  } else {\n    setReady(primitive, frameState, PrimitiveState.FAILED, undefined);\n  }\n}\n\nfunction recomputeBoundingSpheres(primitive, frameState) {\n  const offsetIndex = primitive._batchTableAttributeIndices.offset;\n  if (!primitive._recomputeBoundingSpheres || !defined(offsetIndex)) {\n    primitive._recomputeBoundingSpheres = false;\n    return;\n  }\n\n  let i;\n  const offsetInstanceExtend = primitive._offsetInstanceExtend;\n  const boundingSpheres = primitive._instanceBoundingSpheres;\n  const length = boundingSpheres.length;\n  let newBoundingSpheres = primitive._tempBoundingSpheres;\n  if (!defined(newBoundingSpheres)) {\n    newBoundingSpheres = new Array(length);\n    for (i = 0; i < length; i++) {\n      newBoundingSpheres[i] = new BoundingSphere();\n    }\n    primitive._tempBoundingSpheres = newBoundingSpheres;\n  }\n  for (i = 0; i < length; ++i) {\n    let newBS = newBoundingSpheres[i];\n    const offset = primitive._batchTable.getBatchedAttribute(\n      i,\n      offsetIndex,\n      new Cartesian3(),\n    );\n    newBS = boundingSpheres[i].clone(newBS);\n    transformBoundingSphere(newBS, offset, offsetInstanceExtend[i]);\n  }\n  const combinedBS = [];\n  const combinedWestBS = [];\n  const combinedEastBS = [];\n\n  for (i = 0; i < length; ++i) {\n    const bs = newBoundingSpheres[i];\n\n    const minX = bs.center.x - bs.radius;\n    if (\n      minX > 0 ||\n      BoundingSphere.intersectPlane(bs, Plane.ORIGIN_ZX_PLANE) !==\n        Intersect.INTERSECTING\n    ) {\n      combinedBS.push(bs);\n    } else {\n      combinedWestBS.push(bs);\n      combinedEastBS.push(bs);\n    }\n  }\n\n  let resultBS1 = combinedBS[0];\n  let resultBS2 = combinedEastBS[0];\n  let resultBS3 = combinedWestBS[0];\n\n  for (i = 1; i < combinedBS.length; i++) {\n    resultBS1 = BoundingSphere.union(resultBS1, combinedBS[i]);\n  }\n  for (i = 1; i < combinedEastBS.length; i++) {\n    resultBS2 = BoundingSphere.union(resultBS2, combinedEastBS[i]);\n  }\n  for (i = 1; i < combinedWestBS.length; i++) {\n    resultBS3 = BoundingSphere.union(resultBS3, combinedWestBS[i]);\n  }\n  const result = [];\n  if (defined(resultBS1)) {\n    result.push(resultBS1);\n  }\n  if (defined(resultBS2)) {\n    result.push(resultBS2);\n  }\n  if (defined(resultBS3)) {\n    result.push(resultBS3);\n  }\n\n  for (i = 0; i < result.length; i++) {\n    const boundingSphere = result[i].clone(primitive._boundingSpheres[i]);\n    primitive._boundingSpheres[i] = boundingSphere;\n    primitive._boundingSphereCV[i] = BoundingSphere.projectTo2D(\n      boundingSphere,\n      frameState.mapProjection,\n      primitive._boundingSphereCV[i],\n    );\n  }\n\n  Primitive._updateBoundingVolumes(\n    primitive,\n    frameState,\n    primitive.modelMatrix,\n    true,\n  );\n  primitive._recomputeBoundingSpheres = false;\n}\n\nconst scratchBoundingSphereCenterEncoded = new EncodedCartesian3();\nconst scratchBoundingSphereCartographic = new Cartographic();\nconst scratchBoundingSphereCenter2D = new Cartesian3();\nconst scratchBoundingSphere = new BoundingSphere();\n\nfunction updateBatchTableBoundingSpheres(primitive, frameState) {\n  const hasDistanceDisplayCondition = defined(\n    primitive._batchTableAttributeIndices.distanceDisplayCondition,\n  );\n  if (\n    !hasDistanceDisplayCondition ||\n    primitive._batchTableBoundingSpheresUpdated\n  ) {\n    return;\n  }\n\n  const indices = primitive._batchTableBoundingSphereAttributeIndices;\n  const center3DHighIndex = indices.center3DHigh;\n  const center3DLowIndex = indices.center3DLow;\n  const center2DHighIndex = indices.center2DHigh;\n  const center2DLowIndex = indices.center2DLow;\n  const radiusIndex = indices.radius;\n\n  const projection = frameState.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n\n  const batchTable = primitive._batchTable;\n  const boundingSpheres = primitive._instanceBoundingSpheres;\n  const length = boundingSpheres.length;\n\n  for (let i = 0; i < length; ++i) {\n    let boundingSphere = boundingSpheres[i];\n    if (!defined(boundingSphere)) {\n      continue;\n    }\n\n    const modelMatrix = primitive.modelMatrix;\n    if (defined(modelMatrix)) {\n      boundingSphere = BoundingSphere.transform(\n        boundingSphere,\n        modelMatrix,\n        scratchBoundingSphere,\n      );\n    }\n\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n\n    let encodedCenter = EncodedCartesian3.fromCartesian(\n      center,\n      scratchBoundingSphereCenterEncoded,\n    );\n    batchTable.setBatchedAttribute(i, center3DHighIndex, encodedCenter.high);\n    batchTable.setBatchedAttribute(i, center3DLowIndex, encodedCenter.low);\n\n    if (!frameState.scene3DOnly) {\n      const cartographic = ellipsoid.cartesianToCartographic(\n        center,\n        scratchBoundingSphereCartographic,\n      );\n      const center2D = projection.project(\n        cartographic,\n        scratchBoundingSphereCenter2D,\n      );\n      encodedCenter = EncodedCartesian3.fromCartesian(\n        center2D,\n        scratchBoundingSphereCenterEncoded,\n      );\n      batchTable.setBatchedAttribute(i, center2DHighIndex, encodedCenter.high);\n      batchTable.setBatchedAttribute(i, center2DLowIndex, encodedCenter.low);\n    }\n\n    batchTable.setBatchedAttribute(i, radiusIndex, radius);\n  }\n\n  primitive._batchTableBoundingSpheresUpdated = true;\n}\n\nconst offsetScratchCartesian = new Cartesian3();\nconst offsetCenterScratch = new Cartesian3();\nfunction updateBatchTableOffsets(primitive, frameState) {\n  const hasOffset = defined(primitive._batchTableAttributeIndices.offset);\n  if (\n    !hasOffset ||\n    primitive._batchTableOffsetsUpdated ||\n    frameState.scene3DOnly\n  ) {\n    return;\n  }\n\n  const index2D = primitive._batchTableOffsetAttribute2DIndex;\n\n  const projection = frameState.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n\n  const batchTable = primitive._batchTable;\n  const boundingSpheres = primitive._instanceBoundingSpheres;\n  const length = boundingSpheres.length;\n\n  for (let i = 0; i < length; ++i) {\n    let boundingSphere = boundingSpheres[i];\n    if (!defined(boundingSphere)) {\n      continue;\n    }\n    const offset = batchTable.getBatchedAttribute(\n      i,\n      primitive._batchTableAttributeIndices.offset,\n    );\n    if (Cartesian3.equals(offset, Cartesian3.ZERO)) {\n      batchTable.setBatchedAttribute(i, index2D, Cartesian3.ZERO);\n      continue;\n    }\n\n    const modelMatrix = primitive.modelMatrix;\n    if (defined(modelMatrix)) {\n      boundingSphere = BoundingSphere.transform(\n        boundingSphere,\n        modelMatrix,\n        scratchBoundingSphere,\n      );\n    }\n\n    let center = boundingSphere.center;\n    center = ellipsoid.scaleToGeodeticSurface(center, offsetCenterScratch);\n    let cartographic = ellipsoid.cartesianToCartographic(\n      center,\n      scratchBoundingSphereCartographic,\n    );\n    const center2D = projection.project(\n      cartographic,\n      scratchBoundingSphereCenter2D,\n    );\n\n    const newPoint = Cartesian3.add(offset, center, offsetScratchCartesian);\n    cartographic = ellipsoid.cartesianToCartographic(newPoint, cartographic);\n\n    const newPointProjected = projection.project(\n      cartographic,\n      offsetScratchCartesian,\n    );\n\n    const newVector = Cartesian3.subtract(\n      newPointProjected,\n      center2D,\n      offsetScratchCartesian,\n    );\n\n    const x = newVector.x;\n    newVector.x = newVector.z;\n    newVector.z = newVector.y;\n    newVector.y = x;\n\n    batchTable.setBatchedAttribute(i, index2D, newVector);\n  }\n\n  primitive._batchTableOffsetsUpdated = true;\n}\n\nfunction createVertexArray(primitive, frameState) {\n  const attributeLocations = primitive._attributeLocations;\n  const geometries = primitive._geometries;\n  const scene3DOnly = frameState.scene3DOnly;\n  const context = frameState.context;\n\n  const va = [];\n  const length = geometries.length;\n  for (let i = 0; i < length; ++i) {\n    const geometry = geometries[i];\n\n    va.push(\n      VertexArray.fromGeometry({\n        context: context,\n        geometry: geometry,\n        attributeLocations: attributeLocations,\n        bufferUsage: BufferUsage.STATIC_DRAW,\n        interleave: primitive._interleave,\n      }),\n    );\n\n    if (defined(primitive._createBoundingVolumeFunction)) {\n      primitive._createBoundingVolumeFunction(frameState, geometry);\n    } else {\n      primitive._boundingSpheres.push(\n        BoundingSphere.clone(geometry.boundingSphere),\n      );\n      primitive._boundingSphereWC.push(new BoundingSphere());\n\n      if (!scene3DOnly) {\n        const center = geometry.boundingSphereCV.center;\n        const x = center.x;\n        const y = center.y;\n        const z = center.z;\n        center.x = z;\n        center.y = x;\n        center.z = y;\n\n        primitive._boundingSphereCV.push(\n          BoundingSphere.clone(geometry.boundingSphereCV),\n        );\n        primitive._boundingSphere2D.push(new BoundingSphere());\n        primitive._boundingSphereMorph.push(new BoundingSphere());\n      }\n    }\n  }\n\n  primitive._va = va;\n  primitive._primitiveType = geometries[0].primitiveType;\n\n  if (primitive.releaseGeometryInstances) {\n    primitive.geometryInstances = undefined;\n  }\n\n  primitive._geometries = undefined;\n  setReady(primitive, frameState, PrimitiveState.COMPLETE, undefined);\n}\n\nfunction createRenderStates(primitive, context, appearance, twoPasses) {\n  let renderState = appearance.getRenderState();\n  let rs;\n\n  if (twoPasses) {\n    rs = clone(renderState, false);\n    rs.cull = {\n      enabled: true,\n      face: CullFace.BACK,\n    };\n    primitive._frontFaceRS = RenderState.fromCache(rs);\n\n    rs.cull.face = CullFace.FRONT;\n    primitive._backFaceRS = RenderState.fromCache(rs);\n  } else {\n    primitive._frontFaceRS = RenderState.fromCache(renderState);\n    primitive._backFaceRS = primitive._frontFaceRS;\n  }\n\n  rs = clone(renderState, false);\n  if (defined(primitive._depthFailAppearance)) {\n    rs.depthTest.enabled = false;\n  }\n\n  if (defined(primitive._depthFailAppearance)) {\n    renderState = primitive._depthFailAppearance.getRenderState();\n    rs = clone(renderState, false);\n    rs.depthTest.func = DepthFunction.GREATER;\n    if (twoPasses) {\n      rs.cull = {\n        enabled: true,\n        face: CullFace.BACK,\n      };\n      primitive._frontFaceDepthFailRS = RenderState.fromCache(rs);\n\n      rs.cull.face = CullFace.FRONT;\n      primitive._backFaceDepthFailRS = RenderState.fromCache(rs);\n    } else {\n      primitive._frontFaceDepthFailRS = RenderState.fromCache(rs);\n      primitive._backFaceDepthFailRS = primitive._frontFaceRS;\n    }\n  }\n}\n\nfunction createShaderProgram(primitive, frameState, appearance) {\n  const context = frameState.context;\n\n  const attributeLocations = primitive._attributeLocations;\n\n  let vs = primitive._batchTable.getVertexShaderCallback()(\n    appearance.vertexShaderSource,\n  );\n  vs = Primitive._appendOffsetToShader(primitive, vs);\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vs = Primitive._appendDistanceDisplayConditionToShader(\n    primitive,\n    vs,\n    frameState.scene3DOnly,\n  );\n  vs = appendPickToVertexShader(vs);\n  vs = Primitive._updateColorAttribute(primitive, vs, false);\n  vs = modifyForEncodedNormals(primitive, vs);\n  vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);\n  let fs = appearance.getFragmentShaderSource();\n  fs = appendPickToFragmentShader(fs);\n\n  primitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: primitive._sp,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n  validateShaderMatching(primitive._sp, attributeLocations);\n\n  if (defined(primitive._depthFailAppearance)) {\n    vs = primitive._batchTable.getVertexShaderCallback()(\n      primitive._depthFailAppearance.vertexShaderSource,\n    );\n    vs = Primitive._appendShowToShader(primitive, vs);\n    vs = Primitive._appendDistanceDisplayConditionToShader(\n      primitive,\n      vs,\n      frameState.scene3DOnly,\n    );\n    vs = appendPickToVertexShader(vs);\n    vs = Primitive._updateColorAttribute(primitive, vs, true);\n    vs = modifyForEncodedNormals(primitive, vs);\n    vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);\n    vs = depthClampVS(vs);\n\n    fs = primitive._depthFailAppearance.getFragmentShaderSource();\n    fs = appendPickToFragmentShader(fs);\n    fs = depthClampFS(fs);\n\n    primitive._spDepthFail = ShaderProgram.replaceCache({\n      context: context,\n      shaderProgram: primitive._spDepthFail,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations,\n    });\n    validateShaderMatching(primitive._spDepthFail, attributeLocations);\n  }\n}\n\nconst modifiedModelViewScratch = new Matrix4();\nconst rtcScratch = new Cartesian3();\n\nfunction getUniforms(primitive, appearance, material, frameState) {\n  // Create uniform map by combining uniforms from the appearance and material if either have uniforms.\n  const materialUniformMap = defined(material) ? material._uniforms : undefined;\n  const appearanceUniformMap = {};\n  const appearanceUniforms = appearance.uniforms;\n  if (defined(appearanceUniforms)) {\n    // Convert to uniform map of functions for the renderer\n    for (const name in appearanceUniforms) {\n      if (appearanceUniforms.hasOwnProperty(name)) {\n        //>>includeStart('debug', pragmas.debug);\n        if (defined(materialUniformMap) && defined(materialUniformMap[name])) {\n          // Later, we could rename uniforms behind-the-scenes if needed.\n          throw new DeveloperError(\n            `Appearance and material have a uniform with the same name: ${name}`,\n          );\n        }\n        //>>includeEnd('debug');\n\n        appearanceUniformMap[name] = getUniformFunction(\n          appearanceUniforms,\n          name,\n        );\n      }\n    }\n  }\n  let uniforms = combine(appearanceUniformMap, materialUniformMap);\n  uniforms = primitive._batchTable.getUniformMapCallback()(uniforms);\n\n  if (defined(primitive.rtcCenter)) {\n    uniforms.u_modifiedModelView = function () {\n      const viewMatrix = frameState.context.uniformState.view;\n      Matrix4.multiply(\n        viewMatrix,\n        primitive._modelMatrix,\n        modifiedModelViewScratch,\n      );\n      Matrix4.multiplyByPoint(\n        modifiedModelViewScratch,\n        primitive.rtcCenter,\n        rtcScratch,\n      );\n      Matrix4.setTranslation(\n        modifiedModelViewScratch,\n        rtcScratch,\n        modifiedModelViewScratch,\n      );\n      return modifiedModelViewScratch;\n    };\n  }\n\n  return uniforms;\n}\n\nfunction createCommands(\n  primitive,\n  appearance,\n  material,\n  translucent,\n  twoPasses,\n  colorCommands,\n  pickCommands,\n  frameState,\n) {\n  const uniforms = getUniforms(primitive, appearance, material, frameState);\n\n  let depthFailUniforms;\n  if (defined(primitive._depthFailAppearance)) {\n    depthFailUniforms = getUniforms(\n      primitive,\n      primitive._depthFailAppearance,\n      primitive._depthFailAppearance.material,\n      frameState,\n    );\n  }\n\n  const pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n\n  let multiplier = twoPasses ? 2 : 1;\n  multiplier *= defined(primitive._depthFailAppearance) ? 2 : 1;\n  colorCommands.length = primitive._va.length * multiplier;\n\n  const length = colorCommands.length;\n  let vaIndex = 0;\n  for (let i = 0; i < length; ++i) {\n    let colorCommand;\n\n    if (twoPasses) {\n      colorCommand = colorCommands[i];\n      if (!defined(colorCommand)) {\n        colorCommand = colorCommands[i] = new DrawCommand({\n          owner: primitive,\n          primitiveType: primitive._primitiveType,\n        });\n      }\n      colorCommand.vertexArray = primitive._va[vaIndex];\n      colorCommand.renderState = primitive._backFaceRS;\n      colorCommand.shaderProgram = primitive._sp;\n      colorCommand.uniformMap = uniforms;\n      colorCommand.pass = pass;\n\n      ++i;\n    }\n\n    colorCommand = colorCommands[i];\n    if (!defined(colorCommand)) {\n      colorCommand = colorCommands[i] = new DrawCommand({\n        owner: primitive,\n        primitiveType: primitive._primitiveType,\n      });\n    }\n    colorCommand.vertexArray = primitive._va[vaIndex];\n    colorCommand.renderState = primitive._frontFaceRS;\n    colorCommand.shaderProgram = primitive._sp;\n    colorCommand.uniformMap = uniforms;\n    colorCommand.pass = pass;\n\n    if (defined(primitive._depthFailAppearance)) {\n      if (twoPasses) {\n        ++i;\n\n        colorCommand = colorCommands[i];\n        if (!defined(colorCommand)) {\n          colorCommand = colorCommands[i] = new DrawCommand({\n            owner: primitive,\n            primitiveType: primitive._primitiveType,\n          });\n        }\n        colorCommand.vertexArray = primitive._va[vaIndex];\n        colorCommand.renderState = primitive._backFaceDepthFailRS;\n        colorCommand.shaderProgram = primitive._spDepthFail;\n        colorCommand.uniformMap = depthFailUniforms;\n        colorCommand.pass = pass;\n      }\n\n      ++i;\n\n      colorCommand = colorCommands[i];\n      if (!defined(colorCommand)) {\n        colorCommand = colorCommands[i] = new DrawCommand({\n          owner: primitive,\n          primitiveType: primitive._primitiveType,\n        });\n      }\n      colorCommand.vertexArray = primitive._va[vaIndex];\n      colorCommand.renderState = primitive._frontFaceDepthFailRS;\n      colorCommand.shaderProgram = primitive._spDepthFail;\n      colorCommand.uniformMap = depthFailUniforms;\n      colorCommand.pass = pass;\n    }\n\n    ++vaIndex;\n  }\n}\n\nPrimitive._updateBoundingVolumes = function (\n  primitive,\n  frameState,\n  modelMatrix,\n  forceUpdate,\n) {\n  let i;\n  let length;\n  let boundingSphere;\n\n  if (forceUpdate || !Matrix4.equals(modelMatrix, primitive._modelMatrix)) {\n    Matrix4.clone(modelMatrix, primitive._modelMatrix);\n    length = primitive._boundingSpheres.length;\n    for (i = 0; i < length; ++i) {\n      boundingSphere = primitive._boundingSpheres[i];\n      if (defined(boundingSphere)) {\n        primitive._boundingSphereWC[i] = BoundingSphere.transform(\n          boundingSphere,\n          modelMatrix,\n          primitive._boundingSphereWC[i],\n        );\n        if (!frameState.scene3DOnly) {\n          primitive._boundingSphere2D[i] = BoundingSphere.clone(\n            primitive._boundingSphereCV[i],\n            primitive._boundingSphere2D[i],\n          );\n          primitive._boundingSphereMorph[i] = BoundingSphere.union(\n            primitive._boundingSphereWC[i],\n            primitive._boundingSphereCV[i],\n          );\n        }\n      }\n    }\n  }\n\n  // Update bounding volumes for primitives that are sized in pixels.\n  // The pixel size in meters varies based on the distance from the camera.\n  const pixelSize = primitive.appearance.pixelSize;\n  if (defined(pixelSize)) {\n    length = primitive._boundingSpheres.length;\n    for (i = 0; i < length; ++i) {\n      boundingSphere = primitive._boundingSpheres[i];\n      const boundingSphereWC = primitive._boundingSphereWC[i];\n      const pixelSizeInMeters = frameState.camera.getPixelSize(\n        boundingSphere,\n        frameState.context.drawingBufferWidth,\n        frameState.context.drawingBufferHeight,\n      );\n      const sizeInMeters = pixelSizeInMeters * pixelSize;\n      boundingSphereWC.radius = boundingSphere.radius + sizeInMeters;\n    }\n  }\n};\n\nfunction updateAndQueueCommands(\n  primitive,\n  frameState,\n  colorCommands,\n  pickCommands,\n  modelMatrix,\n  cull,\n  debugShowBoundingVolume,\n  twoPasses,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    frameState.mode !== SceneMode.SCENE3D &&\n    !Matrix4.equals(modelMatrix, Matrix4.IDENTITY)\n  ) {\n    throw new DeveloperError(\n      \"Primitive.modelMatrix is only supported in 3D mode.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix);\n\n  let boundingSpheres;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingSpheres = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingSpheres = primitive._boundingSphereCV;\n  } else if (\n    frameState.mode === SceneMode.SCENE2D &&\n    defined(primitive._boundingSphere2D)\n  ) {\n    boundingSpheres = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingSpheres = primitive._boundingSphereMorph;\n  }\n\n  const commandList = frameState.commandList;\n  const passes = frameState.passes;\n  if (passes.render || passes.pick) {\n    const allowPicking = primitive.allowPicking;\n    const castShadows = ShadowMode.castShadows(primitive.shadows);\n    const receiveShadows = ShadowMode.receiveShadows(primitive.shadows);\n    const colorLength = colorCommands.length;\n\n    let factor = twoPasses ? 2 : 1;\n    factor *= defined(primitive._depthFailAppearance) ? 2 : 1;\n\n    for (let j = 0; j < colorLength; ++j) {\n      const sphereIndex = Math.floor(j / factor);\n      const colorCommand = colorCommands[j];\n      colorCommand.modelMatrix = modelMatrix;\n      colorCommand.boundingVolume = boundingSpheres[sphereIndex];\n      colorCommand.cull = cull;\n      colorCommand.debugShowBoundingVolume = debugShowBoundingVolume;\n      colorCommand.castShadows = castShadows;\n      colorCommand.receiveShadows = receiveShadows;\n\n      if (allowPicking) {\n        colorCommand.pickId = \"v_pickColor\";\n      } else {\n        colorCommand.pickId = undefined;\n      }\n\n      commandList.push(colorCommand);\n    }\n  }\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n * @exception {DeveloperError} Primitive.modelMatrix is only supported in 3D mode.\n * @exception {RuntimeError} Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\n */\nPrimitive.prototype.update = function (frameState) {\n  if (\n    (!defined(this.geometryInstances) && this._va.length === 0) ||\n    (defined(this.geometryInstances) &&\n      Array.isArray(this.geometryInstances) &&\n      this.geometryInstances.length === 0) ||\n    !defined(this.appearance) ||\n    (frameState.mode !== SceneMode.SCENE3D && frameState.scene3DOnly) ||\n    (!frameState.passes.render && !frameState.passes.pick)\n  ) {\n    return;\n  }\n\n  if (defined(this._error)) {\n    throw this._error;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(this.rtcCenter) && !frameState.scene3DOnly) {\n    throw new DeveloperError(\n      \"RTC rendering is only available for 3D only scenes.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (this._state === PrimitiveState.FAILED) {\n    return;\n  }\n\n  const context = frameState.context;\n  if (!defined(this._batchTable)) {\n    createBatchTable(this, context);\n  }\n  if (this._batchTable.attributes.length > 0) {\n    if (ContextLimits.maximumVertexTextureImageUnits === 0) {\n      throw new RuntimeError(\n        \"Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\",\n      );\n    }\n    this._batchTable.update(frameState);\n  }\n\n  if (\n    this._state !== PrimitiveState.COMPLETE &&\n    this._state !== PrimitiveState.COMBINED\n  ) {\n    if (this.asynchronous) {\n      loadAsynchronous(this, frameState);\n    } else {\n      loadSynchronous(this, frameState);\n    }\n  }\n\n  if (this._state === PrimitiveState.COMBINED) {\n    updateBatchTableBoundingSpheres(this, frameState);\n    updateBatchTableOffsets(this, frameState);\n    createVertexArray(this, frameState);\n  }\n\n  if (!this.show || this._state !== PrimitiveState.COMPLETE) {\n    return;\n  }\n\n  if (!this._batchTableOffsetsUpdated) {\n    updateBatchTableOffsets(this, frameState);\n  }\n  if (this._recomputeBoundingSpheres) {\n    recomputeBoundingSpheres(this, frameState);\n  }\n\n  // Create or recreate render state and shader program if appearance/material changed\n  const appearance = this.appearance;\n  const material = appearance.material;\n  let createRS = false;\n  let createSP = false;\n\n  if (this._appearance !== appearance) {\n    this._appearance = appearance;\n    this._material = material;\n    createRS = true;\n    createSP = true;\n  } else if (this._material !== material) {\n    this._material = material;\n    createSP = true;\n  }\n\n  const depthFailAppearance = this.depthFailAppearance;\n  const depthFailMaterial = defined(depthFailAppearance)\n    ? depthFailAppearance.material\n    : undefined;\n\n  if (this._depthFailAppearance !== depthFailAppearance) {\n    this._depthFailAppearance = depthFailAppearance;\n    this._depthFailMaterial = depthFailMaterial;\n    createRS = true;\n    createSP = true;\n  } else if (this._depthFailMaterial !== depthFailMaterial) {\n    this._depthFailMaterial = depthFailMaterial;\n    createSP = true;\n  }\n\n  const translucent = this._appearance.isTranslucent();\n  if (this._translucent !== translucent) {\n    this._translucent = translucent;\n    createRS = true;\n  }\n\n  if (defined(this._material)) {\n    this._material.update(context);\n  }\n\n  const twoPasses = appearance.closed && translucent;\n\n  if (createRS) {\n    const rsFunc = this._createRenderStatesFunction ?? createRenderStates;\n    rsFunc(this, context, appearance, twoPasses);\n  }\n\n  if (createSP) {\n    const spFunc = this._createShaderProgramFunction ?? createShaderProgram;\n    spFunc(this, frameState, appearance);\n  }\n\n  if (createRS || createSP) {\n    const commandFunc = this._createCommandsFunction ?? createCommands;\n    commandFunc(\n      this,\n      appearance,\n      material,\n      translucent,\n      twoPasses,\n      this._colorCommands,\n      this._pickCommands,\n      frameState,\n    );\n  }\n\n  const updateAndQueueCommandsFunc =\n    this._updateAndQueueCommandsFunction ?? updateAndQueueCommands;\n  updateAndQueueCommandsFunc(\n    this,\n    frameState,\n    this._colorCommands,\n    this._pickCommands,\n    this.modelMatrix,\n    this.cull,\n    this.debugShowBoundingVolume,\n    twoPasses,\n  );\n};\n\nconst offsetBoundingSphereScratch1 = new BoundingSphere();\nconst offsetBoundingSphereScratch2 = new BoundingSphere();\nfunction transformBoundingSphere(boundingSphere, offset, offsetAttribute) {\n  if (offsetAttribute === GeometryOffsetAttribute.TOP) {\n    const origBS = BoundingSphere.clone(\n      boundingSphere,\n      offsetBoundingSphereScratch1,\n    );\n    const offsetBS = BoundingSphere.clone(\n      boundingSphere,\n      offsetBoundingSphereScratch2,\n    );\n    offsetBS.center = Cartesian3.add(offsetBS.center, offset, offsetBS.center);\n    boundingSphere = BoundingSphere.union(origBS, offsetBS, boundingSphere);\n  } else if (offsetAttribute === GeometryOffsetAttribute.ALL) {\n    boundingSphere.center = Cartesian3.add(\n      boundingSphere.center,\n      offset,\n      boundingSphere.center,\n    );\n  }\n\n  return boundingSphere;\n}\n\nfunction createGetFunction(batchTable, instanceIndex, attributeIndex) {\n  return function () {\n    const attributeValue = batchTable.getBatchedAttribute(\n      instanceIndex,\n      attributeIndex,\n    );\n    const attribute = batchTable.attributes[attributeIndex];\n    const componentsPerAttribute = attribute.componentsPerAttribute;\n    const value = ComponentDatatype.createTypedArray(\n      attribute.componentDatatype,\n      componentsPerAttribute,\n    );\n    if (defined(attributeValue.constructor.pack)) {\n      attributeValue.constructor.pack(attributeValue, value, 0);\n    } else {\n      value[0] = attributeValue;\n    }\n    return value;\n  };\n}\n\nfunction createSetFunction(\n  batchTable,\n  instanceIndex,\n  attributeIndex,\n  primitive,\n  name,\n) {\n  return function (value) {\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      !defined(value) ||\n      !defined(value.length) ||\n      value.length < 1 ||\n      value.length > 4\n    ) {\n      throw new DeveloperError(\n        \"value must be and array with length between 1 and 4.\",\n      );\n    }\n    //>>includeEnd('debug');\n    const attributeValue = getAttributeValue(value);\n    batchTable.setBatchedAttribute(\n      instanceIndex,\n      attributeIndex,\n      attributeValue,\n    );\n    if (name === \"offset\") {\n      primitive._recomputeBoundingSpheres = true;\n      primitive._batchTableOffsetsUpdated = false;\n    }\n  };\n}\n\nconst offsetScratch = new Cartesian3();\n\nfunction createBoundingSphereProperties(primitive, properties, index) {\n  properties.boundingSphere = {\n    get: function () {\n      let boundingSphere = primitive._instanceBoundingSpheres[index];\n      if (defined(boundingSphere)) {\n        boundingSphere = boundingSphere.clone();\n        const modelMatrix = primitive.modelMatrix;\n        const offset = properties.offset;\n        if (defined(offset)) {\n          transformBoundingSphere(\n            boundingSphere,\n            Cartesian3.fromArray(offset.get(), 0, offsetScratch),\n            primitive._offsetInstanceExtend[index],\n          );\n        }\n        if (defined(modelMatrix)) {\n          boundingSphere = BoundingSphere.transform(\n            boundingSphere,\n            modelMatrix,\n          );\n        }\n      }\n\n      return boundingSphere;\n    },\n  };\n  properties.boundingSphereCV = {\n    get: function () {\n      return primitive._instanceBoundingSpheresCV[index];\n    },\n  };\n}\n\nfunction createPickIdProperty(primitive, properties, index) {\n  properties.pickId = {\n    get: function () {\n      return primitive._pickIds[index];\n    },\n  };\n}\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(100.0, 10000.0);\n * attributes.offset = Cesium.OffsetGeometryInstanceAttribute.toValue(Cartesian3.IDENTITY);\n */\nPrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required\");\n  }\n  if (!defined(this._batchTable)) {\n    throw new DeveloperError(\n      \"must call update before calling getGeometryInstanceAttributes\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  let attributes = this._perInstanceAttributeCache.get(id);\n  if (defined(attributes)) {\n    return attributes;\n  }\n\n  let index = -1;\n  const lastIndex = this._lastPerInstanceAttributeIndex;\n  const ids = this._instanceIds;\n  const length = ids.length;\n  for (let i = 0; i < length; ++i) {\n    const curIndex = (lastIndex + i) % length;\n    if (id === ids[curIndex]) {\n      index = curIndex;\n      break;\n    }\n  }\n\n  if (index === -1) {\n    return undefined;\n  }\n\n  const batchTable = this._batchTable;\n  const perInstanceAttributeIndices = this._batchTableAttributeIndices;\n  attributes = {};\n  const properties = {};\n\n  for (const name in perInstanceAttributeIndices) {\n    if (perInstanceAttributeIndices.hasOwnProperty(name)) {\n      const attributeIndex = perInstanceAttributeIndices[name];\n      properties[name] = {\n        get: createGetFunction(batchTable, index, attributeIndex),\n        set: createSetFunction(batchTable, index, attributeIndex, this, name),\n      };\n    }\n  }\n\n  createBoundingSphereProperties(this, properties, index);\n  createPickIdProperty(this, properties, index);\n  Object.defineProperties(attributes, properties);\n\n  this._lastPerInstanceAttributeIndex = index;\n  this._perInstanceAttributeCache.set(id, attributes);\n  return attributes;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Primitive#destroy\n */\nPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * e = e && e.destroy();\n *\n * @see Primitive#isDestroyed\n */\nPrimitive.prototype.destroy = function () {\n  let length;\n  let i;\n\n  this._sp = this._sp && this._sp.destroy();\n  this._spDepthFail = this._spDepthFail && this._spDepthFail.destroy();\n\n  const va = this._va;\n  length = va.length;\n  for (i = 0; i < length; ++i) {\n    va[i].destroy();\n  }\n  this._va = undefined;\n\n  const pickIds = this._pickIds;\n  length = pickIds.length;\n  for (i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n  this._pickIds = undefined;\n\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n\n  //These objects may be fairly large and reference other large objects (like Entities)\n  //We explicitly set them to undefined here so that the memory can be freed\n  //even if a reference to the destroyed Primitive has been kept around.\n  this._instanceIds = undefined;\n  this._perInstanceAttributeCache = undefined;\n  this._attributeLocations = undefined;\n\n  return destroyObject(this);\n};\n\nfunction setReady(primitive, frameState, state, error) {\n  primitive._error = error;\n  primitive._state = state;\n\n  frameState.afterRender.push(function () {\n    primitive._ready =\n      primitive._state === PrimitiveState.COMPLETE ||\n      primitive._state === PrimitiveState.FAILED;\n\n    // Returning 'true' here will ensure that another rendering pass is\n    // triggered after the primitive actually became ready, to make sure\n    // that it is in fact rendered even in \"request render mode\"\n    return true;\n  });\n}\nexport default Primitive;\n"],"names":["Primitive","options","EMPTY_OBJECT","geometryInstances","appearance","_appearance","undefined","_material","depthFailAppearance","_depthFailAppearance","_depthFailMaterial","modelMatrix","clone","IDENTITY","_modelMatrix","show","_vertexCacheOptimize","vertexCacheOptimize","_interleave","interleave","_releaseGeometryInstances","releaseGeometryInstances","_allowPicking","allowPicking","_asynchronous","asynchronous","_compressVertices","compressVertices","cull","debugShowBoundingVolume","rtcCenter","Array","isArray","length","shadows","DISABLED","_translucent","_state","READY","_geometries","_error","_numberOfInstances","_boundingSpheres","_boundingSphereWC","_boundingSphereCV","_boundingSphere2D","_boundingSphereMorph","_perInstanceAttributeCache","Map","_instanceIds","_lastPerInstanceAttributeIndex","_va","_attributeLocations","_primitiveType","_frontFaceRS","_backFaceRS","_sp","_spDepthFail","_frontFaceDepthFailRS","_backFaceDepthFailRS","_pickIds","_colorCommands","_pickCommands","_createBoundingVolumeFunction","_createRenderStatesFunction","_createShaderProgramFunction","_createCommandsFunction","_updateAndQueueCommandsFunction","_createPickOffsets","_pickOffsets","_createGeometryResults","_ready","_batchTable","_batchTableAttributeIndices","_offsetInstanceExtend","_batchTableOffsetAttribute2DIndex","_batchTableOffsetsUpdated","_instanceBoundingSpheres","_instanceBoundingSpheresCV","_tempBoundingSpheres","_recomputeBoundingSpheres","_batchTableBoundingSpheresUpdated","_batchTableBoundingSphereAttributeIndices","Object","defineProperties","prototype","get","ready","getCommonPerInstanceAttributeNames","instances","attributesInAllInstances","attributes0","attributes","name","hasOwnProperty","attribute","inAllInstances","i","otherAttribute","componentDatatype","componentsPerAttribute","normalize","push","scratchGetAttributeCartesian2","scratchGetAttributeCartesian3","scratchGetAttributeCartesian4","getAttributeValue","value","unpack","createBatchTable","primitive","context","numberOfInstances","names","attributeIndices","boundingSphereAttributeIndices","offset2DIndex","firstInstance","instanceAttributes","functionName","indexOf","FLOAT","center3DHigh","center3DLow","center2DHigh","center2DLow","radius","UNSIGNED_BYTE","attributesLength","batchTable","instance","j","attributeIndex","setBatchedAttribute","pickObject","pickPrimitive","id","pickId","createPickId","pickColor","color","x","floatToByte","red","y","green","z","blue","w","alpha","cloneAttribute","clonedValues","values","slice","cloneGeometry","geometry","newAttributes","property","indices","sourceValues","primitiveType","boundingSphere","cloneInstance","positionRegex","_modifyShaderPosition","vertexShaderSource","scene3DOnly","match","forwardDecl","computeFunctions","exec","toUpperCase","substr","replace","join","_appendShowToShader","renamedVS","replaceMain","showMain","_updateColorAttribute","isDepthFail","depthFailColor","search","modifiedVS","appendPickToVertexShader","source","pickMain","appendPickToFragmentShader","_updatePickColorAttribute","vsPick","_appendOffsetToShader","offset","attr","modifiedShader","str","_appendDistanceDisplayConditionToShader","distanceDisplayCondition","distanceDisplayConditionMain","modifyForEncodedNormals","containsNormal","containsSt","containsTangent","containsBitangent","numComponents","type","attributeName","attributeDecl","globalDecl","decode","stComponent","compressedMain","depthClampVS","depthClampFS","fragmentShaderSource","modifiedFS","validateShaderMatching","shaderProgram","attributeLocations","shaderAttributes","vertexAttributes","getUniformFunction","uniforms","numberOfCreationWorkers","Math","max","hardwareConcurrency","createGeometryTaskProcessors","combineGeometryTaskProcessor","loadAsynchronous","frameState","instanceIds","promises","subTasks","_workerName","_workerPath","moduleName","modulePath","subTask","packedLength","workerSubTasks","workerSubTasksLength","pack","subTaskTransferableObjects","array","Float64Array","buffer","scheduleTask","CREATING","Promise","all","then","results","CREATED","catch","error","setReady","FAILED","transferableObjects","projection","mapProjection","promise","packCombineGeometryParameters","createGeometryResults","ellipsoid","elementIndexUintSupported","elementIndexUint","createPickOffsets","COMBINING","resolve","packedResult","result","unpackCombineGeometryResults","geometries","pickOffsets","offsetInstanceExtend","boundingSpheres","boundingSpheresCV","COMBINED","loadSynchronous","clonedInstances","geometryIndex","createdGeometry","createGeometry","combineGeometry","recomputeBoundingSpheres","offsetIndex","newBoundingSpheres","newBS","getBatchedAttribute","transformBoundingSphere","combinedBS","combinedWestBS","combinedEastBS","bs","minX","center","intersectPlane","ORIGIN_ZX_PLANE","INTERSECTING","resultBS1","resultBS2","resultBS3","union","projectTo2D","_updateBoundingVolumes","scratchBoundingSphereCenterEncoded","scratchBoundingSphereCartographic","scratchBoundingSphereCenter2D","scratchBoundingSphere","updateBatchTableBoundingSpheres","hasDistanceDisplayCondition","center3DHighIndex","center3DLowIndex","center2DHighIndex","center2DLowIndex","radiusIndex","transform","encodedCenter","fromCartesian","high","low","cartographic","cartesianToCartographic","center2D","project","offsetScratchCartesian","offsetCenterScratch","updateBatchTableOffsets","hasOffset","index2D","equals","ZERO","scaleToGeodeticSurface","newPoint","add","newPointProjected","newVector","subtract","createVertexArray","va","fromGeometry","bufferUsage","STATIC_DRAW","boundingSphereCV","COMPLETE","createRenderStates","twoPasses","renderState","getRenderState","rs","enabled","face","BACK","fromCache","FRONT","depthTest","func","GREATER","createShaderProgram","vs","getVertexShaderCallback","fs","getFragmentShaderSource","replaceCache","modifiedModelViewScratch","rtcScratch","getUniforms","material","materialUniformMap","_uniforms","appearanceUniformMap","appearanceUniforms","getUniformMapCallback","u_modifiedModelView","viewMatrix","uniformState","view","multiply","multiplyByPoint","setTranslation","createCommands","translucent","colorCommands","pickCommands","depthFailUniforms","pass","TRANSLUCENT","OPAQUE","multiplier","vaIndex","colorCommand","owner","vertexArray","uniformMap","forceUpdate","pixelSize","boundingSphereWC","pixelSizeInMeters","camera","getPixelSize","drawingBufferWidth","drawingBufferHeight","sizeInMeters","updateAndQueueCommands","mode","SCENE3D","COLUMBUS_VIEW","SCENE2D","commandList","passes","render","pick","castShadows","receiveShadows","colorLength","factor","sphereIndex","floor","boundingVolume","update","maximumVertexTextureImageUnits","createRS","createSP","depthFailMaterial","isTranslucent","closed","rsFunc","spFunc","commandFunc","updateAndQueueCommandsFunc","offsetBoundingSphereScratch1","offsetBoundingSphereScratch2","offsetAttribute","TOP","origBS","offsetBS","ALL","createGetFunction","instanceIndex","attributeValue","createTypedArray","createSetFunction","offsetScratch","createBoundingSphereProperties","properties","index","fromArray","createPickIdProperty","getGeometryInstanceAttributes","lastIndex","ids","curIndex","perInstanceAttributeIndices","set","isDestroyed","destroy","pickIds","state","afterRender"],"mappings":"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","ignoreList":[0]}}]
}