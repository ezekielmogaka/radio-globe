{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/GlobeSurfaceTileProvider.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport VerticalExaggeration from \"../Core/VerticalExaggeration.js\";\nimport TerrainQuantization from \"../Core/TerrainQuantization.js\";\nimport Visibility from \"../Core/Visibility.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport ClippingPolygonCollection from \"./ClippingPolygonCollection.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport GlobeSurfaceTile from \"./GlobeSurfaceTile.js\";\nimport ImageryLayer from \"./ImageryLayer.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport TerrainFillMesh from \"./TerrainFillMesh.js\";\nimport TerrainState from \"./TerrainState.js\";\nimport TileBoundingRegion from \"./TileBoundingRegion.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n\n/**\n * Provides quadtree tiles representing the surface of the globe.  This type is intended to be used\n * with {@link QuadtreePrimitive}.\n *\n * @alias GlobeSurfaceTileProvider\n * @constructor\n *\n * @param {TerrainProvider} options.terrainProvider The terrain provider that describes the surface geometry.\n * @param {ImageryLayerCollection} option.imageryLayers The collection of imagery layers describing the shading of the surface.\n * @param {GlobeSurfaceShaderSet} options.surfaceShaderSet The set of shaders used to render the surface.\n *\n * @private\n */\nfunction GlobeSurfaceTileProvider(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.terrainProvider)) {\n    throw new DeveloperError(\"options.terrainProvider is required.\");\n  } else if (!defined(options.imageryLayers)) {\n    throw new DeveloperError(\"options.imageryLayers is required.\");\n  } else if (!defined(options.surfaceShaderSet)) {\n    throw new DeveloperError(\"options.surfaceShaderSet is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this.lightingFadeOutDistance = 6500000.0;\n  this.lightingFadeInDistance = 9000000.0;\n  this.hasWaterMask = false;\n  this.showWaterEffect = false;\n  this.oceanNormalMap = undefined;\n  this.zoomedOutOceanSpecularIntensity = 0.5;\n  this.enableLighting = false;\n  this.dynamicAtmosphereLighting = false;\n  this.dynamicAtmosphereLightingFromSun = false;\n  this.showGroundAtmosphere = false;\n  this.shadows = ShadowMode.RECEIVE_ONLY;\n  this.vertexShadowDarkness = 0.3;\n\n  /**\n   * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not\n   * highlighted at all. The alpha value is used to alpha blend with the tile's\n   * actual color. Because terrain fill tiles do not represent the actual terrain surface,\n   * it may be useful in some applications to indicate visually that they are not to be trusted.\n   * @type {Color}\n   * @default undefined\n   */\n  this.fillHighlightColor = undefined;\n\n  this.hueShift = 0.0;\n  this.saturationShift = 0.0;\n  this.brightnessShift = 0.0;\n\n  this.showSkirts = true;\n  this.backFaceCulling = true;\n  this.undergroundColor = undefined;\n  this.undergroundColorAlphaByDistance = undefined;\n\n  this.lambertDiffuseMultiplier = 0.0;\n\n  this.materialUniformMap = undefined;\n  this._materialUniformMap = undefined;\n\n  this._quadtree = undefined;\n  this._terrainProvider = options.terrainProvider;\n  this._imageryLayers = options.imageryLayers;\n  this._surfaceShaderSet = options.surfaceShaderSet;\n\n  this._renderState = undefined;\n  this._blendRenderState = undefined;\n  this._disableCullingRenderState = undefined;\n  this._disableCullingBlendRenderState = undefined;\n\n  this._errorEvent = new Event();\n\n  this._removeLayerAddedListener =\n    this._imageryLayers.layerAdded.addEventListener(\n      GlobeSurfaceTileProvider.prototype._onLayerAdded,\n      this,\n    );\n  this._removeLayerRemovedListener =\n    this._imageryLayers.layerRemoved.addEventListener(\n      GlobeSurfaceTileProvider.prototype._onLayerRemoved,\n      this,\n    );\n  this._removeLayerMovedListener =\n    this._imageryLayers.layerMoved.addEventListener(\n      GlobeSurfaceTileProvider.prototype._onLayerMoved,\n      this,\n    );\n  this._removeLayerShownListener =\n    this._imageryLayers.layerShownOrHidden.addEventListener(\n      GlobeSurfaceTileProvider.prototype._onLayerShownOrHidden,\n      this,\n    );\n  this._imageryLayersUpdatedEvent = new Event();\n\n  this._layerOrderChanged = false;\n\n  this._tilesToRenderByTextureCount = [];\n  this._drawCommands = [];\n  this._uniformMaps = [];\n  this._usedDrawCommands = 0;\n\n  this._vertexArraysToDestroy = [];\n\n  this._debug = {\n    wireframe: false,\n    boundingSphereTile: undefined,\n  };\n\n  this._baseColor = undefined;\n  this._firstPassInitialColor = undefined;\n  this.baseColor = new Color(0.0, 0.0, 0.5, 1.0);\n\n  /**\n   * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.\n   * @type {ClippingPlaneCollection}\n   * @private\n   */\n  this._clippingPlanes = undefined;\n\n  /**\n   * A property specifying a {@link ClippingPolygonCollection} used to selectively disable rendering inside or outside a list of polygons.\n   * @type {ClippingPolygonCollection}\n   * @private\n   */\n  this._clippingPolygons = undefined;\n\n  /**\n   * A property specifying a {@link Rectangle} used to selectively limit terrain and imagery rendering.\n   * @type {Rectangle}\n   */\n  this.cartographicLimitRectangle = Rectangle.clone(Rectangle.MAX_VALUE);\n\n  this._hasLoadedTilesThisFrame = false;\n  this._hasFillTilesThisFrame = false;\n\n  this._oldVerticalExaggeration = undefined;\n  this._oldVerticalExaggerationRelativeHeight = undefined;\n  this._oldSceneMode = SceneMode.SCENE3D;\n}\n\nObject.defineProperties(GlobeSurfaceTileProvider.prototype, {\n  /**\n   * Gets or sets the color of the globe when no imagery is available.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Color}\n   */\n  baseColor: {\n    get: function () {\n      return this._baseColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      this._baseColor = value;\n      this._firstPassInitialColor = Cartesian4.fromColor(\n        value,\n        this._firstPassInitialColor,\n      );\n    },\n  },\n  /**\n   * Gets or sets the {@link QuadtreePrimitive} for which this provider is\n   * providing tiles.  This property may be undefined if the provider is not yet associated\n   * with a {@link QuadtreePrimitive}.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {QuadtreePrimitive}\n   */\n  quadtree: {\n    get: function () {\n      return this._quadtree;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      this._quadtree = value;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {TilingScheme}\n   */\n  tilingScheme: {\n    get: function () {\n      if (!defined(this._terrainProvider)) {\n        return undefined;\n      }\n\n      return this._terrainProvider.tilingScheme;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the geometry provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when an imagery layer is added, shown, hidden, moved, or removed.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Event}\n   */\n  imageryLayersUpdatedEvent: {\n    get: function () {\n      return this._imageryLayersUpdatedEvent;\n    },\n  },\n\n  /**\n   * Gets or sets the terrain provider that describes the surface geometry.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {TerrainProvider}\n   */\n  terrainProvider: {\n    get: function () {\n      return this._terrainProvider;\n    },\n    set: function (terrainProvider) {\n      if (this._terrainProvider === terrainProvider) {\n        return;\n      }\n\n      this._terrainProvider = terrainProvider;\n\n      if (defined(this._quadtree)) {\n        this._quadtree.invalidateAllTiles();\n      }\n    },\n  },\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering.\n   *\n   * @type {ClippingPlaneCollection}\n   *\n   * @private\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    },\n  },\n\n  /**\n   * The {@link ClippingPolygonCollection} used to selectively disable rendering inside or outside a list of polygons.\n   *\n   * @type {ClippingPolygonCollection}\n   *\n   * @private\n   */\n  clippingPolygons: {\n    get: function () {\n      return this._clippingPolygons;\n    },\n    set: function (value) {\n      ClippingPolygonCollection.setOwner(value, this, \"_clippingPolygons\");\n    },\n  },\n});\n\nfunction sortTileImageryByLayerIndex(a, b) {\n  let aImagery = a.loadingImagery;\n  if (!defined(aImagery)) {\n    aImagery = a.readyImagery;\n  }\n\n  let bImagery = b.loadingImagery;\n  if (!defined(bImagery)) {\n    bImagery = b.readyImagery;\n  }\n\n  return aImagery.imageryLayer._layerIndex - bImagery.imageryLayer._layerIndex;\n}\n\n/**\n * Make updates to the tile provider that are not involved in rendering. Called before the render update cycle.\n */\nGlobeSurfaceTileProvider.prototype.update = function (frameState) {\n  // update collection: imagery indices, base layers, raise layer show/hide event\n  this._imageryLayers._update();\n};\n\nfunction updateCredits(surface, frameState) {\n  const creditDisplay = frameState.creditDisplay;\n  const terrainProvider = surface._terrainProvider;\n  if (defined(terrainProvider) && defined(terrainProvider.credit)) {\n    creditDisplay.addCreditToNextFrame(terrainProvider.credit);\n  }\n\n  const imageryLayers = surface._imageryLayers;\n  for (let i = 0, len = imageryLayers.length; i < len; ++i) {\n    const layer = imageryLayers.get(i);\n    if (layer.ready && layer.show && defined(layer.imageryProvider.credit)) {\n      creditDisplay.addCreditToNextFrame(layer.imageryProvider.credit);\n    }\n  }\n}\n\n/**\n * Called at the beginning of each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.initialize = function (frameState) {\n  // update each layer for texture reprojection.\n  this._imageryLayers.queueReprojectionCommands(frameState);\n\n  if (this._layerOrderChanged) {\n    this._layerOrderChanged = false;\n\n    // Sort the TileImagery instances in each tile by the layer index.\n    this._quadtree.forEachLoadedTile(function (tile) {\n      tile.data.imagery.sort(sortTileImageryByLayerIndex);\n    });\n  }\n\n  // Add credits for terrain and imagery providers.\n  updateCredits(this, frameState);\n\n  const vertexArraysToDestroy = this._vertexArraysToDestroy;\n  const length = vertexArraysToDestroy.length;\n  for (let j = 0; j < length; ++j) {\n    GlobeSurfaceTile._freeVertexArray(vertexArraysToDestroy[j]);\n  }\n  vertexArraysToDestroy.length = 0;\n};\n\n/**\n * Called at the beginning of the update cycle for each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * or any other functions.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.beginUpdate = function (frameState) {\n  const tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;\n  for (let i = 0, len = tilesToRenderByTextureCount.length; i < len; ++i) {\n    const tiles = tilesToRenderByTextureCount[i];\n    if (defined(tiles)) {\n      tiles.length = 0;\n    }\n  }\n  // update clipping planes\n  const clippingPlanes = this._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    clippingPlanes.update(frameState);\n  }\n\n  // update clipping polygons\n  const clippingPolygons = this._clippingPolygons;\n  if (defined(clippingPolygons) && clippingPolygons.enabled) {\n    clippingPolygons.update(frameState);\n    clippingPolygons.queueCommands(frameState);\n  }\n\n  this._usedDrawCommands = 0;\n\n  this._hasLoadedTilesThisFrame = false;\n  this._hasFillTilesThisFrame = false;\n};\n\n/**\n * Called at the end of the update cycle for each render frame, after {@link QuadtreeTileProvider#showTileThisFrame}\n * and any other functions.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.endUpdate = function (frameState) {\n  if (!defined(this._renderState)) {\n    this._renderState = RenderState.fromCache({\n      // Write color and depth\n      cull: {\n        enabled: true,\n      },\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS,\n      },\n    });\n\n    this._blendRenderState = RenderState.fromCache({\n      // Write color and depth\n      cull: {\n        enabled: true,\n      },\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS_OR_EQUAL,\n      },\n      blending: BlendingState.ALPHA_BLEND,\n    });\n\n    let rs = clone(this._renderState, true);\n    rs.cull.enabled = false;\n    this._disableCullingRenderState = RenderState.fromCache(rs);\n\n    rs = clone(this._blendRenderState, true);\n    rs.cull.enabled = false;\n    this._disableCullingBlendRenderState = RenderState.fromCache(rs);\n  }\n\n  // If this frame has a mix of loaded and fill tiles, we need to propagate\n  // loaded heights to the fill tiles.\n  if (this._hasFillTilesThisFrame && this._hasLoadedTilesThisFrame) {\n    TerrainFillMesh.updateFillTiles(\n      this,\n      this._quadtree._tilesToRender,\n      frameState,\n      this._vertexArraysToDestroy,\n    );\n  }\n\n  // When vertical exaggeration changes, all of the loaded tiles need to generate\n  // geodetic surface normals so they can scale properly when rendered.\n  // When exaggeration is reset, geodetic surface normals are removed to decrease\n  // memory usage. Some tiles might have been constructed with the correct\n  // exaggeration already, so skip over them.\n\n  // If the geodetic surface normals can't be created because the tile doesn't\n  // have a mesh, keep checking until the tile does have a mesh. This can happen\n  // if the tile's mesh starts construction in a worker thread right before the\n  // exaggeration changes.\n\n  const quadtree = this.quadtree;\n  const exaggeration = frameState.verticalExaggeration;\n  const exaggerationRelativeHeight =\n    frameState.verticalExaggerationRelativeHeight;\n  const exaggerationChanged =\n    this._oldVerticalExaggeration !== exaggeration ||\n    this._oldVerticalExaggerationRelativeHeight !== exaggerationRelativeHeight;\n\n  // Keep track of the next time there is a change in exaggeration\n  this._oldVerticalExaggeration = exaggeration;\n  this._oldVerticalExaggerationRelativeHeight = exaggerationRelativeHeight;\n\n  if (exaggerationChanged) {\n    quadtree.forEachLoadedTile(function (tile) {\n      const surfaceTile = tile.data;\n      surfaceTile.updateExaggeration(tile, frameState, quadtree);\n    });\n  }\n\n  const sceneModeChanged = this._oldSceneMode !== frameState.mode;\n  this._oldSceneMode = frameState.mode;\n\n  if (sceneModeChanged) {\n    quadtree.forEachLoadedTile(function (tile) {\n      const surfaceTile = tile.data;\n      surfaceTile.updateSceneMode(frameState.mode);\n    });\n  }\n\n  // Add the tile render commands to the command list, sorted by texture count.\n  const tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;\n  for (\n    let textureCountIndex = 0,\n      textureCountLength = tilesToRenderByTextureCount.length;\n    textureCountIndex < textureCountLength;\n    ++textureCountIndex\n  ) {\n    const tilesToRender = tilesToRenderByTextureCount[textureCountIndex];\n    if (!defined(tilesToRender)) {\n      continue;\n    }\n\n    for (\n      let tileIndex = 0, tileLength = tilesToRender.length;\n      tileIndex < tileLength;\n      ++tileIndex\n    ) {\n      const tile = tilesToRender[tileIndex];\n      const tileBoundingRegion = tile.data.tileBoundingRegion;\n      addDrawCommandsForTile(this, tile, frameState);\n      frameState.minimumTerrainHeight = Math.min(\n        frameState.minimumTerrainHeight,\n        tileBoundingRegion.minimumHeight,\n      );\n    }\n  }\n};\n\nfunction pushCommand(command, frameState) {\n  const globeTranslucencyState = frameState.globeTranslucencyState;\n  if (globeTranslucencyState.translucent) {\n    const isBlendCommand = command.renderState.blending.enabled;\n    globeTranslucencyState.pushDerivedCommands(\n      command,\n      isBlendCommand,\n      frameState,\n    );\n  } else {\n    frameState.commandList.push(command);\n  }\n}\n\n/**\n * Adds draw commands for tiles rendered in the previous frame for a pick pass.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.updateForPick = function (frameState) {\n  // Add the tile pick commands from the tiles drawn last frame.\n  const drawCommands = this._drawCommands;\n  for (let i = 0, length = this._usedDrawCommands; i < length; ++i) {\n    pushCommand(drawCommands[i], frameState);\n  }\n};\n\n/**\n * Cancels any imagery re-projections in the queue.\n */\nGlobeSurfaceTileProvider.prototype.cancelReprojections = function () {\n  this._imageryLayers.cancelReprojections();\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level, in meters.\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error in meters.\n */\nGlobeSurfaceTileProvider.prototype.getLevelMaximumGeometricError = function (\n  level,\n) {\n  if (!defined(this._terrainProvider)) {\n    return 0;\n  }\n\n  return this._terrainProvider.getLevelMaximumGeometricError(level);\n};\n\n/**\n * Loads, or continues loading, a given tile.  This function will continue to be called\n * until {@link QuadtreeTile#state} is no longer {@link QuadtreeTileLoadState#LOADING}.\n *\n * @param {FrameState} frameState The frame state.\n * @param {QuadtreeTile} tile The tile to load.\n */\nGlobeSurfaceTileProvider.prototype.loadTile = function (frameState, tile) {\n  // We don't want to load imagery until we're certain that the terrain tiles are actually visible.\n  // So if our bounding volume isn't accurate because it came from another tile, load terrain only\n  // initially. If we load some terrain and suddenly have a more accurate bounding volume and the\n  // tile is _still_ visible, give the tile a chance to load imagery immediately rather than\n  // waiting for next frame.\n\n  let surfaceTile = tile.data;\n  let terrainOnly = true;\n  let terrainStateBefore;\n  if (defined(surfaceTile)) {\n    terrainOnly =\n      surfaceTile.boundingVolumeSourceTile !== tile ||\n      tile._lastSelectionResult === TileSelectionResult.CULLED_BUT_NEEDED;\n    terrainStateBefore = surfaceTile.terrainState;\n  }\n\n  GlobeSurfaceTile.processStateMachine(\n    tile,\n    frameState,\n    this.terrainProvider,\n    this._imageryLayers,\n    this.quadtree,\n    this._vertexArraysToDestroy,\n    terrainOnly,\n  );\n\n  surfaceTile = tile.data;\n  if (terrainOnly && terrainStateBefore !== tile.data.terrainState) {\n    // Terrain state changed. If:\n    // a) The tile is visible, and\n    // b) The bounding volume is accurate (updated as a side effect of computing visibility)\n    // Then we'll load imagery, too.\n    if (\n      this.computeTileVisibility(tile, frameState, this.quadtree.occluders) !==\n        Visibility.NONE &&\n      surfaceTile.boundingVolumeSourceTile === tile\n    ) {\n      terrainOnly = false;\n      GlobeSurfaceTile.processStateMachine(\n        tile,\n        frameState,\n        this.terrainProvider,\n        this._imageryLayers,\n        this.quadtree,\n        this._vertexArraysToDestroy,\n        terrainOnly,\n      );\n    }\n  }\n};\n\nconst boundingSphereScratch = new BoundingSphere();\nconst rectangleIntersectionScratch = new Rectangle();\nconst splitCartographicLimitRectangleScratch = new Rectangle();\nconst rectangleCenterScratch = new Cartographic();\n\n// cartographicLimitRectangle may span the IDL, but tiles never will.\nfunction clipRectangleAntimeridian(tileRectangle, cartographicLimitRectangle) {\n  if (cartographicLimitRectangle.west < cartographicLimitRectangle.east) {\n    return cartographicLimitRectangle;\n  }\n  const splitRectangle = Rectangle.clone(\n    cartographicLimitRectangle,\n    splitCartographicLimitRectangleScratch,\n  );\n  const tileCenter = Rectangle.center(tileRectangle, rectangleCenterScratch);\n  if (tileCenter.longitude > 0.0) {\n    splitRectangle.east = CesiumMath.PI;\n  } else {\n    splitRectangle.west = -CesiumMath.PI;\n  }\n  return splitRectangle;\n}\n\nfunction isUndergroundVisible(tileProvider, frameState) {\n  if (frameState.cameraUnderground) {\n    return true;\n  }\n\n  if (frameState.globeTranslucencyState.translucent) {\n    return true;\n  }\n\n  if (tileProvider.backFaceCulling) {\n    return false;\n  }\n\n  const clippingPlanes = tileProvider._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    return true;\n  }\n\n  const clippingPolygons = tileProvider._clippingPolygons;\n  if (defined(clippingPolygons) && clippingPolygons.enabled) {\n    return true;\n  }\n\n  if (\n    !Rectangle.equals(\n      tileProvider.cartographicLimitRectangle,\n      Rectangle.MAX_VALUE,\n    )\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Determines the visibility of a given tile.  The tile may be fully visible, partially visible, or not\n * visible at all.  Tiles that are renderable and are at least partially visible will be shown by a call\n * to {@link GlobeSurfaceTileProvider#showTileThisFrame}.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information about the current frame.\n * @param {QuadtreeOccluders} occluders The objects that may occlude this tile.\n *\n * @returns {Visibility} Visibility.NONE if the tile is not visible,\n *                       Visibility.PARTIAL if the tile is partially visible, or\n *                       Visibility.FULL if the tile is fully visible.\n */\nGlobeSurfaceTileProvider.prototype.computeTileVisibility = function (\n  tile,\n  frameState,\n  occluders,\n) {\n  const distance = this.computeDistanceToTile(tile, frameState);\n  tile._distance = distance;\n\n  const undergroundVisible = isUndergroundVisible(this, frameState);\n\n  if (frameState.fog.enabled && !undergroundVisible) {\n    if (CesiumMath.fog(distance, frameState.fog.density) >= 1.0) {\n      // Tile is completely in fog so return that it is not visible.\n      return Visibility.NONE;\n    }\n  }\n\n  const surfaceTile = tile.data;\n  const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  if (surfaceTile.boundingVolumeSourceTile === undefined) {\n    // We have no idea where this tile is, so let's just call it partially visible.\n    return Visibility.PARTIAL;\n  }\n\n  const cullingVolume = frameState.cullingVolume;\n  let boundingVolume = tileBoundingRegion.boundingVolume;\n\n  if (!defined(boundingVolume)) {\n    boundingVolume = tileBoundingRegion.boundingSphere;\n  }\n\n  // Check if the tile is outside the limit area in cartographic space\n  surfaceTile.clippedByBoundaries = false;\n  const clippedCartographicLimitRectangle = clipRectangleAntimeridian(\n    tile.rectangle,\n    this.cartographicLimitRectangle,\n  );\n  const areaLimitIntersection = Rectangle.simpleIntersection(\n    clippedCartographicLimitRectangle,\n    tile.rectangle,\n    rectangleIntersectionScratch,\n  );\n  if (!defined(areaLimitIntersection)) {\n    return Visibility.NONE;\n  }\n  if (!Rectangle.equals(areaLimitIntersection, tile.rectangle)) {\n    surfaceTile.clippedByBoundaries = true;\n  }\n\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    boundingVolume = boundingSphereScratch;\n    BoundingSphere.fromRectangleWithHeights2D(\n      tile.rectangle,\n      frameState.mapProjection,\n      tileBoundingRegion.minimumHeight,\n      tileBoundingRegion.maximumHeight,\n      boundingVolume,\n    );\n    Cartesian3.fromElements(\n      boundingVolume.center.z,\n      boundingVolume.center.x,\n      boundingVolume.center.y,\n      boundingVolume.center,\n    );\n\n    if (\n      frameState.mode === SceneMode.MORPHING &&\n      defined(surfaceTile.renderedMesh)\n    ) {\n      boundingVolume = BoundingSphere.union(\n        tileBoundingRegion.boundingSphere,\n        boundingVolume,\n        boundingVolume,\n      );\n    }\n  }\n\n  if (!defined(boundingVolume)) {\n    return Visibility.PARTIAL;\n  }\n\n  const clippingPlanes = this._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    const planeIntersection =\n      clippingPlanes.computeIntersectionWithBoundingVolume(boundingVolume);\n    tile.isClipped = planeIntersection !== Intersect.INSIDE;\n    if (planeIntersection === Intersect.OUTSIDE) {\n      return Visibility.NONE;\n    }\n  }\n\n  const clippingPolygons = this._clippingPolygons;\n  if (defined(clippingPolygons) && clippingPolygons.enabled) {\n    const polygonIntersection =\n      clippingPolygons.computeIntersectionWithBoundingVolume(\n        tileBoundingRegion,\n      );\n    tile.isClipped = polygonIntersection !== Intersect.OUTSIDE;\n    // Polygon clipping intersections are determined by outer rectangles, therefore we cannot\n    // preemptively determine if a tile is completely clipped or not here.\n  }\n\n  let visibility;\n  const intersection = cullingVolume.computeVisibility(boundingVolume);\n\n  if (intersection === Intersect.OUTSIDE) {\n    visibility = Visibility.NONE;\n  } else if (intersection === Intersect.INTERSECTING) {\n    visibility = Visibility.PARTIAL;\n  } else if (intersection === Intersect.INSIDE) {\n    visibility = Visibility.FULL;\n  }\n\n  if (visibility === Visibility.NONE) {\n    return visibility;\n  }\n\n  const ortho3D =\n    frameState.mode === SceneMode.SCENE3D &&\n    frameState.camera.frustum instanceof OrthographicFrustum;\n  if (\n    frameState.mode === SceneMode.SCENE3D &&\n    !ortho3D &&\n    defined(occluders) &&\n    !undergroundVisible\n  ) {\n    const occludeePointInScaledSpace = surfaceTile.occludeePointInScaledSpace;\n    if (!defined(occludeePointInScaledSpace)) {\n      return visibility;\n    }\n\n    if (\n      occluders.ellipsoid.isScaledSpacePointVisiblePossiblyUnderEllipsoid(\n        occludeePointInScaledSpace,\n        tileBoundingRegion.minimumHeight,\n      )\n    ) {\n      return visibility;\n    }\n\n    return Visibility.NONE;\n  }\n\n  return visibility;\n};\n\n/**\n * Determines if the given tile can be refined\n * @param {QuadtreeTile} tile The tile to check.\n * @returns {boolean} True if the tile can be refined, false if it cannot.\n */\nGlobeSurfaceTileProvider.prototype.canRefine = function (tile) {\n  // Only allow refinement it we know whether or not the children of this tile exist.\n  // For a tileset with `availability`, we'll always be able to refine.\n  // We can ask for availability of _any_ child tile because we only need to confirm\n  // that we get a yes or no answer, it doesn't matter what the answer is.\n  if (defined(tile.data.terrainData)) {\n    return true;\n  }\n  const childAvailable = this.terrainProvider.getTileDataAvailable(\n    tile.x * 2,\n    tile.y * 2,\n    tile.level + 1,\n  );\n  return childAvailable !== undefined;\n};\n\nconst readyImageryScratch = [];\nconst canRenderTraversalStack = [];\n\n/**\n * Determines if the given not-fully-loaded tile can be rendered without losing detail that\n * was present last frame as a result of rendering descendant tiles. This method will only be\n * called if this tile's descendants were rendered last frame. If the tile is fully loaded,\n * it is assumed that this method will return true and it will not be called.\n * @param {QuadtreeTile} tile The tile to check.\n * @returns {boolean} True if the tile can be rendered without losing detail.\n */\nGlobeSurfaceTileProvider.prototype.canRenderWithoutLosingDetail = function (\n  tile,\n  frameState,\n) {\n  const surfaceTile = tile.data;\n\n  const readyImagery = readyImageryScratch;\n  readyImagery.length = this._imageryLayers.length;\n\n  let terrainReady = false;\n  let initialImageryState = false;\n  let imagery;\n\n  if (defined(surfaceTile)) {\n    // We can render even with non-ready terrain as long as all our rendered descendants\n    // are missing terrain geometry too. i.e. if we rendered fills for more detailed tiles\n    // last frame, it's ok to render a fill for this tile this frame.\n    terrainReady = surfaceTile.terrainState === TerrainState.READY;\n\n    // Initially assume all imagery layers are ready, unless imagery hasn't been initialized at all.\n    initialImageryState = true;\n\n    imagery = surfaceTile.imagery;\n  }\n\n  let i;\n  let len;\n\n  for (i = 0, len = readyImagery.length; i < len; ++i) {\n    readyImagery[i] = initialImageryState;\n  }\n\n  if (defined(imagery)) {\n    for (i = 0, len = imagery.length; i < len; ++i) {\n      const tileImagery = imagery[i];\n      const loadingImagery = tileImagery.loadingImagery;\n      const isReady =\n        !defined(loadingImagery) ||\n        loadingImagery.state === ImageryState.FAILED ||\n        loadingImagery.state === ImageryState.INVALID;\n      const layerIndex = (\n        tileImagery.loadingImagery || tileImagery.readyImagery\n      ).imageryLayer._layerIndex;\n\n      // For a layer to be ready, all tiles belonging to that layer must be ready.\n      readyImagery[layerIndex] = isReady && readyImagery[layerIndex];\n    }\n  }\n\n  const lastFrame = this.quadtree._lastSelectionFrameNumber;\n\n  // Traverse the descendants looking for one with terrain or imagery that is not loaded on this tile.\n  const stack = canRenderTraversalStack;\n  stack.length = 0;\n  stack.push(\n    tile.southwestChild,\n    tile.southeastChild,\n    tile.northwestChild,\n    tile.northeastChild,\n  );\n\n  while (stack.length > 0) {\n    const descendant = stack.pop();\n    const lastFrameSelectionResult =\n      descendant._lastSelectionResultFrame === lastFrame\n        ? descendant._lastSelectionResult\n        : TileSelectionResult.NONE;\n\n    if (lastFrameSelectionResult === TileSelectionResult.RENDERED) {\n      const descendantSurface = descendant.data;\n\n      if (!defined(descendantSurface)) {\n        // Descendant has no data, so it can't block rendering.\n        continue;\n      }\n\n      if (\n        !terrainReady &&\n        descendant.data.terrainState === TerrainState.READY\n      ) {\n        // Rendered descendant has real terrain, but we don't. Rendering is blocked.\n        return false;\n      }\n\n      const descendantImagery = descendant.data.imagery;\n      for (i = 0, len = descendantImagery.length; i < len; ++i) {\n        const descendantTileImagery = descendantImagery[i];\n        const descendantLoadingImagery = descendantTileImagery.loadingImagery;\n        const descendantIsReady =\n          !defined(descendantLoadingImagery) ||\n          descendantLoadingImagery.state === ImageryState.FAILED ||\n          descendantLoadingImagery.state === ImageryState.INVALID;\n        const descendantLayerIndex = (\n          descendantTileImagery.loadingImagery ||\n          descendantTileImagery.readyImagery\n        ).imageryLayer._layerIndex;\n\n        // If this imagery tile of a descendant is ready but the layer isn't ready in this tile,\n        // then rendering is blocked.\n        if (descendantIsReady && !readyImagery[descendantLayerIndex]) {\n          return false;\n        }\n      }\n    } else if (lastFrameSelectionResult === TileSelectionResult.REFINED) {\n      stack.push(\n        descendant.southwestChild,\n        descendant.southeastChild,\n        descendant.northwestChild,\n        descendant.northeastChild,\n      );\n    }\n  }\n\n  return true;\n};\n\nconst tileDirectionScratch = new Cartesian3();\n\n/**\n * Determines the priority for loading this tile. Lower priority values load sooner.\n * @param {QuadtreeTile} tile The tile.\n * @param {FrameState} frameState The frame state.\n * @returns {number} The load priority value.\n */\nGlobeSurfaceTileProvider.prototype.computeTileLoadPriority = function (\n  tile,\n  frameState,\n) {\n  const surfaceTile = tile.data;\n  if (surfaceTile === undefined) {\n    return 0.0;\n  }\n\n  const obb = surfaceTile.tileBoundingRegion.boundingVolume;\n  if (obb === undefined) {\n    return 0.0;\n  }\n\n  const cameraPosition = frameState.camera.positionWC;\n  const cameraDirection = frameState.camera.directionWC;\n  const tileDirection = Cartesian3.subtract(\n    obb.center,\n    cameraPosition,\n    tileDirectionScratch,\n  );\n  const magnitude = Cartesian3.magnitude(tileDirection);\n  if (magnitude < CesiumMath.EPSILON5) {\n    return 0.0;\n  }\n  Cartesian3.divideByScalar(tileDirection, magnitude, tileDirection);\n  return (\n    (1.0 - Cartesian3.dot(tileDirection, cameraDirection)) * tile._distance\n  );\n};\n\nconst modifiedModelViewScratch = new Matrix4();\nconst modifiedModelViewProjectionScratch = new Matrix4();\nconst tileRectangleScratch = new Cartesian4();\nconst localizedCartographicLimitRectangleScratch = new Cartesian4();\nconst localizedTranslucencyRectangleScratch = new Cartesian4();\nconst rtcScratch = new Cartesian3();\nconst centerEyeScratch = new Cartesian3();\nconst southwestScratch = new Cartesian3();\nconst northeastScratch = new Cartesian3();\n\n/**\n * Shows a specified tile in this frame.  The provider can cause the tile to be shown by adding\n * render commands to the commandList, or use any other method as appropriate.  The tile is not\n * expected to be visible next frame as well, unless this method is called next frame, too.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n */\nGlobeSurfaceTileProvider.prototype.showTileThisFrame = function (\n  tile,\n  frameState,\n) {\n  let readyTextureCount = 0;\n  const tileImageryCollection = tile.data.imagery;\n  for (let i = 0, len = tileImageryCollection.length; i < len; ++i) {\n    const tileImagery = tileImageryCollection[i];\n    if (\n      defined(tileImagery.readyImagery) &&\n      tileImagery.readyImagery.imageryLayer.alpha !== 0.0\n    ) {\n      ++readyTextureCount;\n    }\n  }\n\n  let tileSet = this._tilesToRenderByTextureCount[readyTextureCount];\n  if (!defined(tileSet)) {\n    tileSet = [];\n    this._tilesToRenderByTextureCount[readyTextureCount] = tileSet;\n  }\n\n  tileSet.push(tile);\n\n  const surfaceTile = tile.data;\n  if (!defined(surfaceTile.vertexArray)) {\n    this._hasFillTilesThisFrame = true;\n  } else {\n    this._hasLoadedTilesThisFrame = true;\n  }\n\n  const debug = this._debug;\n  ++debug.tilesRendered;\n  debug.texturesRendered += readyTextureCount;\n};\n\nconst cornerPositionsScratch = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\n\nfunction computeOccludeePoint(\n  tileProvider,\n  center,\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  result,\n) {\n  const ellipsoidalOccluder = tileProvider.quadtree._occluders.ellipsoid;\n  const ellipsoid = ellipsoidalOccluder.ellipsoid;\n\n  const cornerPositions = cornerPositionsScratch;\n  Cartesian3.fromRadians(\n    rectangle.west,\n    rectangle.south,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[0],\n  );\n  Cartesian3.fromRadians(\n    rectangle.east,\n    rectangle.south,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[1],\n  );\n  Cartesian3.fromRadians(\n    rectangle.west,\n    rectangle.north,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[2],\n  );\n  Cartesian3.fromRadians(\n    rectangle.east,\n    rectangle.north,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[3],\n  );\n\n  return ellipsoidalOccluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n    center,\n    cornerPositions,\n    minimumHeight,\n    result,\n  );\n}\n\n/**\n * Gets the distance from the camera to the closest point on the tile.  This is used for level-of-detail selection.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n *\n * @returns {number} The distance from the camera to the closest point on the tile, in meters.\n */\nGlobeSurfaceTileProvider.prototype.computeDistanceToTile = function (\n  tile,\n  frameState,\n) {\n  // The distance should be:\n  // 1. the actual distance to the tight-fitting bounding volume, or\n  // 2. a distance that is equal to or greater than the actual distance to the tight-fitting bounding volume.\n  //\n  // When we don't know the min/max heights for a tile, but we do know the min/max of an ancestor tile, we can\n  // build a tight-fitting bounding volume horizontally, but not vertically. The min/max heights from the\n  // ancestor will likely form a volume that is much bigger than it needs to be. This means that the volume may\n  // be deemed to be much closer to the camera than it really is, causing us to select tiles that are too detailed.\n  // Loading too-detailed tiles is super expensive, so we don't want to do that. We don't know where the child\n  // tile really lies within the parent range of heights, but we _do_ know the child tile can't be any closer than\n  // the ancestor height surface (min or max) that is _farthest away_ from the camera. So if we compute distance\n  // based on that conservative metric, we may end up loading tiles that are not detailed enough, but that's much\n  // better (faster) than loading tiles that are too detailed.\n\n  updateTileBoundingRegion(tile, this, frameState);\n\n  const surfaceTile = tile.data;\n  const boundingVolumeSourceTile = surfaceTile.boundingVolumeSourceTile;\n  if (boundingVolumeSourceTile === undefined) {\n    // Can't find any min/max heights anywhere? Ok, let's just say the\n    // tile is really far away so we'll load and render it rather than\n    // refining.\n    return 9999999999.0;\n  }\n\n  const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n  const min = tileBoundingRegion.minimumHeight;\n  const max = tileBoundingRegion.maximumHeight;\n\n  if (surfaceTile.boundingVolumeSourceTile !== tile) {\n    const cameraHeight = frameState.camera.positionCartographic.height;\n    const distanceToMin = Math.abs(cameraHeight - min);\n    const distanceToMax = Math.abs(cameraHeight - max);\n    if (distanceToMin > distanceToMax) {\n      tileBoundingRegion.minimumHeight = min;\n      tileBoundingRegion.maximumHeight = min;\n    } else {\n      tileBoundingRegion.minimumHeight = max;\n      tileBoundingRegion.maximumHeight = max;\n    }\n  }\n\n  const result = tileBoundingRegion.distanceToCamera(frameState);\n\n  tileBoundingRegion.minimumHeight = min;\n  tileBoundingRegion.maximumHeight = max;\n\n  return result;\n};\n\nfunction updateTileBoundingRegion(tile, tileProvider, frameState) {\n  let surfaceTile = tile.data;\n  if (surfaceTile === undefined) {\n    surfaceTile = tile.data = new GlobeSurfaceTile();\n  }\n\n  const ellipsoid = tile.tilingScheme.ellipsoid;\n  if (surfaceTile.tileBoundingRegion === undefined) {\n    surfaceTile.tileBoundingRegion = new TileBoundingRegion({\n      computeBoundingVolumes: false,\n      rectangle: tile.rectangle,\n      ellipsoid: ellipsoid,\n      minimumHeight: 0.0,\n      maximumHeight: 0.0,\n    });\n  }\n\n  const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n  const oldMinimumHeight = tileBoundingRegion.minimumHeight;\n  const oldMaximumHeight = tileBoundingRegion.maximumHeight;\n  let hasBoundingVolumesFromMesh = false;\n  let sourceTile = tile;\n\n  // Get min and max heights from the mesh.\n  // If the mesh is not available, get them from the terrain data.\n  // If the terrain data is not available either, get them from an ancestor.\n  // If none of the ancestors are available, then there are no min and max heights for this tile at this time.\n  const mesh = surfaceTile.mesh;\n  const terrainData = surfaceTile.terrainData;\n  if (\n    mesh !== undefined &&\n    mesh.minimumHeight !== undefined &&\n    mesh.maximumHeight !== undefined\n  ) {\n    tileBoundingRegion.minimumHeight = mesh.minimumHeight;\n    tileBoundingRegion.maximumHeight = mesh.maximumHeight;\n    hasBoundingVolumesFromMesh = true;\n  } else if (\n    terrainData !== undefined &&\n    terrainData._minimumHeight !== undefined &&\n    terrainData._maximumHeight !== undefined\n  ) {\n    tileBoundingRegion.minimumHeight = terrainData._minimumHeight;\n    tileBoundingRegion.maximumHeight = terrainData._maximumHeight;\n  } else {\n    // No accurate min/max heights available, so we're stuck with min/max heights from an ancestor tile.\n    tileBoundingRegion.minimumHeight = Number.NaN;\n    tileBoundingRegion.maximumHeight = Number.NaN;\n\n    let ancestorTile = tile.parent;\n    while (ancestorTile !== undefined) {\n      const ancestorSurfaceTile = ancestorTile.data;\n      if (ancestorSurfaceTile !== undefined) {\n        const ancestorMesh = ancestorSurfaceTile.mesh;\n        const ancestorTerrainData = ancestorSurfaceTile.terrainData;\n        if (\n          ancestorMesh !== undefined &&\n          ancestorMesh.minimumHeight !== undefined &&\n          ancestorMesh.maximumHeight !== undefined\n        ) {\n          tileBoundingRegion.minimumHeight = ancestorMesh.minimumHeight;\n          tileBoundingRegion.maximumHeight = ancestorMesh.maximumHeight;\n          break;\n        } else if (\n          ancestorTerrainData !== undefined &&\n          ancestorTerrainData._minimumHeight !== undefined &&\n          ancestorTerrainData._maximumHeight !== undefined\n        ) {\n          tileBoundingRegion.minimumHeight = ancestorTerrainData._minimumHeight;\n          tileBoundingRegion.maximumHeight = ancestorTerrainData._maximumHeight;\n          break;\n        }\n      }\n      ancestorTile = ancestorTile.parent;\n    }\n    sourceTile = ancestorTile;\n  }\n\n  // Update bounding regions from the min and max heights\n  if (sourceTile !== undefined) {\n    const exaggeration = frameState.verticalExaggeration;\n    const exaggerationRelativeHeight =\n      frameState.verticalExaggerationRelativeHeight;\n    const hasExaggeration = exaggeration !== 1.0;\n    if (hasExaggeration) {\n      hasBoundingVolumesFromMesh = false;\n      tileBoundingRegion.minimumHeight = VerticalExaggeration.getHeight(\n        tileBoundingRegion.minimumHeight,\n        exaggeration,\n        exaggerationRelativeHeight,\n      );\n      tileBoundingRegion.maximumHeight = VerticalExaggeration.getHeight(\n        tileBoundingRegion.maximumHeight,\n        exaggeration,\n        exaggerationRelativeHeight,\n      );\n    }\n\n    if (hasBoundingVolumesFromMesh) {\n      if (!surfaceTile.boundingVolumeIsFromMesh) {\n        tileBoundingRegion._orientedBoundingBox = OrientedBoundingBox.clone(\n          mesh.orientedBoundingBox,\n          tileBoundingRegion._orientedBoundingBox,\n        );\n        tileBoundingRegion._boundingSphere = BoundingSphere.clone(\n          mesh.boundingSphere3D,\n          tileBoundingRegion._boundingSphere,\n        );\n        surfaceTile.occludeePointInScaledSpace = Cartesian3.clone(\n          mesh.occludeePointInScaledSpace,\n          surfaceTile.occludeePointInScaledSpace,\n        );\n\n        // If the occludee point is not defined, fallback to calculating it from the OBB\n        if (!defined(surfaceTile.occludeePointInScaledSpace)) {\n          surfaceTile.occludeePointInScaledSpace = computeOccludeePoint(\n            tileProvider,\n            tileBoundingRegion._orientedBoundingBox.center,\n            tile.rectangle,\n            tileBoundingRegion.minimumHeight,\n            tileBoundingRegion.maximumHeight,\n            surfaceTile.occludeePointInScaledSpace,\n          );\n        }\n      }\n    } else {\n      const needsBounds =\n        tileBoundingRegion._orientedBoundingBox === undefined ||\n        tileBoundingRegion._boundingSphere === undefined;\n      const heightChanged =\n        tileBoundingRegion.minimumHeight !== oldMinimumHeight ||\n        tileBoundingRegion.maximumHeight !== oldMaximumHeight;\n      if (heightChanged || needsBounds) {\n        // Bounding volumes need to be recomputed in some circumstances\n        tileBoundingRegion.computeBoundingVolumes(ellipsoid);\n        surfaceTile.occludeePointInScaledSpace = computeOccludeePoint(\n          tileProvider,\n          tileBoundingRegion._orientedBoundingBox.center,\n          tile.rectangle,\n          tileBoundingRegion.minimumHeight,\n          tileBoundingRegion.maximumHeight,\n          surfaceTile.occludeePointInScaledSpace,\n        );\n      }\n    }\n    surfaceTile.boundingVolumeSourceTile = sourceTile;\n    surfaceTile.boundingVolumeIsFromMesh = hasBoundingVolumesFromMesh;\n  } else {\n    surfaceTile.boundingVolumeSourceTile = undefined;\n    surfaceTile.boundingVolumeIsFromMesh = false;\n  }\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see GlobeSurfaceTileProvider#destroy\n */\nGlobeSurfaceTileProvider.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * provider = provider && provider();\n *\n * @see GlobeSurfaceTileProvider#isDestroyed\n */\nGlobeSurfaceTileProvider.prototype.destroy = function () {\n  this._tileProvider = this._tileProvider && this._tileProvider.destroy();\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n  this._clippingPolygons =\n    this._clippingPolygons && this._clippingPolygons.destroy();\n  this._removeLayerAddedListener =\n    this._removeLayerAddedListener && this._removeLayerAddedListener();\n  this._removeLayerRemovedListener =\n    this._removeLayerRemovedListener && this._removeLayerRemovedListener();\n  this._removeLayerMovedListener =\n    this._removeLayerMovedListener && this._removeLayerMovedListener();\n  this._removeLayerShownListener =\n    this._removeLayerShownListener && this._removeLayerShownListener();\n\n  return destroyObject(this);\n};\n\nfunction getTileReadyCallback(tileImageriesToFree, layer, terrainProvider) {\n  return function (tile) {\n    let tileImagery;\n    let imagery;\n    let startIndex = -1;\n    const tileImageryCollection = tile.data.imagery;\n    const length = tileImageryCollection.length;\n    let i;\n    for (i = 0; i < length; ++i) {\n      tileImagery = tileImageryCollection[i];\n      imagery = tileImagery.readyImagery ?? tileImagery.loadingImagery;\n      if (imagery.imageryLayer === layer) {\n        startIndex = i;\n        break;\n      }\n    }\n\n    if (startIndex !== -1) {\n      const endIndex = startIndex + tileImageriesToFree;\n      tileImagery = tileImageryCollection[endIndex];\n      imagery = defined(tileImagery)\n        ? (tileImagery.readyImagery ?? tileImagery.loadingImagery)\n        : undefined;\n      if (!defined(imagery) || imagery.imageryLayer !== layer) {\n        // Return false to keep the callback if we have to wait on the skeletons\n        // Return true to remove the callback if something went wrong\n        return !layer._createTileImagerySkeletons(\n          tile,\n          terrainProvider,\n          endIndex,\n        );\n      }\n\n      for (i = startIndex; i < endIndex; ++i) {\n        tileImageryCollection[i].freeResources();\n      }\n\n      tileImageryCollection.splice(startIndex, tileImageriesToFree);\n    }\n\n    return true; // Everything is done, so remove the callback\n  };\n}\n\nGlobeSurfaceTileProvider.prototype._onLayerAdded = function (layer, index) {\n  if (this.isDestroyed()) {\n    return;\n  }\n\n  if (layer.show) {\n    const terrainProvider = this._terrainProvider;\n\n    const that = this;\n    const tileImageryUpdatedEvent = this._imageryLayersUpdatedEvent;\n    const reloadFunction = function () {\n      // Clear the layer's cache\n      layer._imageryCache = {};\n\n      that._quadtree.forEachLoadedTile(function (tile) {\n        // If this layer is still waiting to for the loaded callback, just return\n        if (defined(tile._loadedCallbacks[layer._layerIndex])) {\n          return;\n        }\n\n        let i;\n\n        // Figure out how many TileImageries we will need to remove and where to insert new ones\n        const tileImageryCollection = tile.data.imagery;\n        const length = tileImageryCollection.length;\n        let startIndex = -1;\n        let tileImageriesToFree = 0;\n        for (i = 0; i < length; ++i) {\n          const tileImagery = tileImageryCollection[i];\n          const imagery =\n            tileImagery.readyImagery ?? tileImagery.loadingImagery;\n          if (imagery.imageryLayer === layer) {\n            if (startIndex === -1) {\n              startIndex = i;\n            }\n\n            ++tileImageriesToFree;\n          } else if (startIndex !== -1) {\n            // iterated past the section of TileImageries belonging to this layer, no need to continue.\n            break;\n          }\n        }\n\n        if (startIndex === -1) {\n          return;\n        }\n\n        // Insert immediately after existing TileImageries\n        const insertionPoint = startIndex + tileImageriesToFree;\n\n        // Create new TileImageries for all loaded tiles\n        if (\n          layer._createTileImagerySkeletons(\n            tile,\n            terrainProvider,\n            insertionPoint,\n          )\n        ) {\n          // Add callback to remove old TileImageries when the new TileImageries are ready\n          tile._loadedCallbacks[layer._layerIndex] = getTileReadyCallback(\n            tileImageriesToFree,\n            layer,\n            terrainProvider,\n          );\n\n          tile.state = QuadtreeTileLoadState.LOADING;\n        }\n      });\n    };\n\n    if (layer.ready) {\n      const imageryProvider = layer.imageryProvider;\n      imageryProvider._reload = reloadFunction;\n    }\n\n    // create TileImageries for this layer for all previously loaded tiles\n    this._quadtree.forEachLoadedTile(function (tile) {\n      if (layer._createTileImagerySkeletons(tile, terrainProvider)) {\n        tile.state = QuadtreeTileLoadState.LOADING;\n\n        // Tiles that are not currently being rendered need to load the new layer before they're renderable.\n        // We don't mark the rendered tiles non-renderable, though, because that would make the globe disappear.\n        if (\n          tile.level !== 0 &&\n          (tile._lastSelectionResultFrame !==\n            that.quadtree._lastSelectionFrameNumber ||\n            tile._lastSelectionResult !== TileSelectionResult.RENDERED)\n        ) {\n          tile.renderable = false;\n        }\n      }\n    });\n\n    this._layerOrderChanged = true;\n    tileImageryUpdatedEvent.raiseEvent();\n  }\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerRemoved = function (layer, index) {\n  // destroy TileImagerys for this layer for all previously loaded tiles\n  this._quadtree.forEachLoadedTile(function (tile) {\n    const tileImageryCollection = tile.data.imagery;\n\n    let startIndex = -1;\n    let numDestroyed = 0;\n    for (let i = 0, len = tileImageryCollection.length; i < len; ++i) {\n      const tileImagery = tileImageryCollection[i];\n      let imagery = tileImagery.loadingImagery;\n      if (!defined(imagery)) {\n        imagery = tileImagery.readyImagery;\n      }\n      if (imagery.imageryLayer === layer) {\n        if (startIndex === -1) {\n          startIndex = i;\n        }\n\n        tileImagery.freeResources();\n        ++numDestroyed;\n      } else if (startIndex !== -1) {\n        // iterated past the section of TileImagerys belonging to this layer, no need to continue.\n        break;\n      }\n    }\n\n    if (startIndex !== -1) {\n      tileImageryCollection.splice(startIndex, numDestroyed);\n    }\n  });\n\n  if (defined(layer.imageryProvider)) {\n    layer.imageryProvider._reload = undefined;\n  }\n\n  this._imageryLayersUpdatedEvent.raiseEvent();\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerMoved = function (\n  layer,\n  newIndex,\n  oldIndex,\n) {\n  this._layerOrderChanged = true;\n  this._imageryLayersUpdatedEvent.raiseEvent();\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerShownOrHidden = function (\n  layer,\n  index,\n  show,\n) {\n  if (show) {\n    this._onLayerAdded(layer, index);\n  } else {\n    this._onLayerRemoved(layer, index);\n  }\n};\n\nconst scratchClippingPlanesMatrix = new Matrix4();\nconst scratchInverseTransposeClippingPlanesMatrix = new Matrix4();\nfunction createTileUniformMap(frameState, globeSurfaceTileProvider) {\n  const uniformMap = {\n    u_initialColor: function () {\n      return this.properties.initialColor;\n    },\n    u_fillHighlightColor: function () {\n      return this.properties.fillHighlightColor;\n    },\n    u_zoomedOutOceanSpecularIntensity: function () {\n      return this.properties.zoomedOutOceanSpecularIntensity;\n    },\n    u_oceanNormalMap: function () {\n      return this.properties.oceanNormalMap;\n    },\n    u_atmosphereLightIntensity: function () {\n      return this.properties.atmosphereLightIntensity;\n    },\n    u_atmosphereRayleighCoefficient: function () {\n      return this.properties.atmosphereRayleighCoefficient;\n    },\n    u_atmosphereMieCoefficient: function () {\n      return this.properties.atmosphereMieCoefficient;\n    },\n    u_atmosphereRayleighScaleHeight: function () {\n      return this.properties.atmosphereRayleighScaleHeight;\n    },\n    u_atmosphereMieScaleHeight: function () {\n      return this.properties.atmosphereMieScaleHeight;\n    },\n    u_atmosphereMieAnisotropy: function () {\n      return this.properties.atmosphereMieAnisotropy;\n    },\n    u_lightingFadeDistance: function () {\n      return this.properties.lightingFadeDistance;\n    },\n    u_nightFadeDistance: function () {\n      return this.properties.nightFadeDistance;\n    },\n    u_center3D: function () {\n      return this.properties.center3D;\n    },\n    u_verticalExaggerationAndRelativeHeight: function () {\n      return this.properties.verticalExaggerationAndRelativeHeight;\n    },\n    u_tileRectangle: function () {\n      return this.properties.tileRectangle;\n    },\n    u_modifiedModelView: function () {\n      const viewMatrix = frameState.context.uniformState.view;\n      const centerEye = Matrix4.multiplyByPoint(\n        viewMatrix,\n        this.properties.rtc,\n        centerEyeScratch,\n      );\n      Matrix4.setTranslation(viewMatrix, centerEye, modifiedModelViewScratch);\n      return modifiedModelViewScratch;\n    },\n    u_modifiedModelViewProjection: function () {\n      const viewMatrix = frameState.context.uniformState.view;\n      const projectionMatrix = frameState.context.uniformState.projection;\n      const centerEye = Matrix4.multiplyByPoint(\n        viewMatrix,\n        this.properties.rtc,\n        centerEyeScratch,\n      );\n      Matrix4.setTranslation(\n        viewMatrix,\n        centerEye,\n        modifiedModelViewProjectionScratch,\n      );\n      Matrix4.multiply(\n        projectionMatrix,\n        modifiedModelViewProjectionScratch,\n        modifiedModelViewProjectionScratch,\n      );\n      return modifiedModelViewProjectionScratch;\n    },\n    u_dayTextures: function () {\n      return this.properties.dayTextures;\n    },\n    u_dayTextureTranslationAndScale: function () {\n      return this.properties.dayTextureTranslationAndScale;\n    },\n    u_dayTextureTexCoordsRectangle: function () {\n      return this.properties.dayTextureTexCoordsRectangle;\n    },\n    u_dayTextureUseWebMercatorT: function () {\n      return this.properties.dayTextureUseWebMercatorT;\n    },\n    u_dayTextureAlpha: function () {\n      return this.properties.dayTextureAlpha;\n    },\n    u_dayTextureNightAlpha: function () {\n      return this.properties.dayTextureNightAlpha;\n    },\n    u_dayTextureDayAlpha: function () {\n      return this.properties.dayTextureDayAlpha;\n    },\n    u_dayTextureBrightness: function () {\n      return this.properties.dayTextureBrightness;\n    },\n    u_dayTextureContrast: function () {\n      return this.properties.dayTextureContrast;\n    },\n    u_dayTextureHue: function () {\n      return this.properties.dayTextureHue;\n    },\n    u_dayTextureSaturation: function () {\n      return this.properties.dayTextureSaturation;\n    },\n    u_dayTextureOneOverGamma: function () {\n      return this.properties.dayTextureOneOverGamma;\n    },\n    u_dayIntensity: function () {\n      return this.properties.dayIntensity;\n    },\n    u_southAndNorthLatitude: function () {\n      return this.properties.southAndNorthLatitude;\n    },\n    u_southMercatorYAndOneOverHeight: function () {\n      return this.properties.southMercatorYAndOneOverHeight;\n    },\n    u_waterMask: function () {\n      return this.properties.waterMask;\n    },\n    u_waterMaskTranslationAndScale: function () {\n      return this.properties.waterMaskTranslationAndScale;\n    },\n    u_minMaxHeight: function () {\n      return this.properties.minMaxHeight;\n    },\n    u_scaleAndBias: function () {\n      return this.properties.scaleAndBias;\n    },\n    u_dayTextureSplit: function () {\n      return this.properties.dayTextureSplit;\n    },\n    u_dayTextureCutoutRectangles: function () {\n      return this.properties.dayTextureCutoutRectangles;\n    },\n    u_clippingPlanes: function () {\n      const clippingPlanes = globeSurfaceTileProvider._clippingPlanes;\n      if (defined(clippingPlanes) && defined(clippingPlanes.texture)) {\n        // Check in case clippingPlanes hasn't been updated yet.\n        return clippingPlanes.texture;\n      }\n      return frameState.context.defaultTexture;\n    },\n    u_cartographicLimitRectangle: function () {\n      return this.properties.localizedCartographicLimitRectangle;\n    },\n    u_clippingPlanesMatrix: function () {\n      const clippingPlanes = globeSurfaceTileProvider._clippingPlanes;\n      const transform = defined(clippingPlanes)\n        ? Matrix4.multiply(\n            frameState.context.uniformState.view,\n            clippingPlanes.modelMatrix,\n            scratchClippingPlanesMatrix,\n          )\n        : Matrix4.IDENTITY;\n\n      return Matrix4.inverseTranspose(\n        transform,\n        scratchInverseTransposeClippingPlanesMatrix,\n      );\n    },\n    u_clippingPlanesEdgeStyle: function () {\n      const style = this.properties.clippingPlanesEdgeColor;\n      style.alpha = this.properties.clippingPlanesEdgeWidth;\n      return style;\n    },\n    u_clippingDistance: function () {\n      const texture =\n        globeSurfaceTileProvider._clippingPolygons.clippingTexture;\n      if (defined(texture)) {\n        return texture;\n      }\n      return frameState.context.defaultTexture;\n    },\n    u_clippingExtents: function () {\n      const texture = globeSurfaceTileProvider._clippingPolygons.extentsTexture;\n      if (defined(texture)) {\n        return texture;\n      }\n      return frameState.context.defaultTexture;\n    },\n    u_minimumBrightness: function () {\n      return frameState.fog.minimumBrightness;\n    },\n    u_hsbShift: function () {\n      return this.properties.hsbShift;\n    },\n    u_colorsToAlpha: function () {\n      return this.properties.colorsToAlpha;\n    },\n    u_frontFaceAlphaByDistance: function () {\n      return this.properties.frontFaceAlphaByDistance;\n    },\n    u_backFaceAlphaByDistance: function () {\n      return this.properties.backFaceAlphaByDistance;\n    },\n    u_translucencyRectangle: function () {\n      return this.properties.localizedTranslucencyRectangle;\n    },\n    u_undergroundColor: function () {\n      return this.properties.undergroundColor;\n    },\n    u_undergroundColorAlphaByDistance: function () {\n      return this.properties.undergroundColorAlphaByDistance;\n    },\n    u_lambertDiffuseMultiplier: function () {\n      return this.properties.lambertDiffuseMultiplier;\n    },\n    u_vertexShadowDarkness: function () {\n      return this.properties.vertexShadowDarkness;\n    },\n\n    // make a separate object so that changes to the properties are seen on\n    // derived commands that combine another uniform map with this one.\n    properties: {\n      initialColor: new Cartesian4(0.0, 0.0, 0.5, 1.0),\n      fillHighlightColor: new Color(0.0, 0.0, 0.0, 0.0),\n      zoomedOutOceanSpecularIntensity: 0.5,\n      oceanNormalMap: undefined,\n      lightingFadeDistance: new Cartesian2(6500000.0, 9000000.0),\n      nightFadeDistance: new Cartesian2(10000000.0, 40000000.0),\n      atmosphereLightIntensity: 10.0,\n      atmosphereRayleighCoefficient: new Cartesian3(5.5e-6, 13.0e-6, 28.4e-6),\n      atmosphereMieCoefficient: new Cartesian3(21e-6, 21e-6, 21e-6),\n      atmosphereRayleighScaleHeight: 10000.0,\n      atmosphereMieScaleHeight: 3200.0,\n      atmosphereMieAnisotropy: 0.9,\n      hsbShift: new Cartesian3(),\n\n      center3D: undefined,\n      rtc: new Cartesian3(),\n      modifiedModelView: new Matrix4(),\n      tileRectangle: new Cartesian4(),\n\n      verticalExaggerationAndRelativeHeight: new Cartesian2(1.0, 0.0),\n\n      dayTextures: [],\n      dayTextureTranslationAndScale: [],\n      dayTextureTexCoordsRectangle: [],\n      dayTextureUseWebMercatorT: [],\n      dayTextureAlpha: [],\n      dayTextureNightAlpha: [],\n      dayTextureDayAlpha: [],\n      dayTextureBrightness: [],\n      dayTextureContrast: [],\n      dayTextureHue: [],\n      dayTextureSaturation: [],\n      dayTextureOneOverGamma: [],\n      dayTextureSplit: [],\n      dayTextureCutoutRectangles: [],\n      dayIntensity: 0.0,\n      colorsToAlpha: [],\n\n      southAndNorthLatitude: new Cartesian2(),\n      southMercatorYAndOneOverHeight: new Cartesian2(),\n\n      waterMask: undefined,\n      waterMaskTranslationAndScale: new Cartesian4(),\n\n      minMaxHeight: new Cartesian2(),\n      scaleAndBias: new Matrix4(),\n      clippingPlanesEdgeColor: Color.clone(Color.WHITE),\n      clippingPlanesEdgeWidth: 0.0,\n\n      localizedCartographicLimitRectangle: new Cartesian4(),\n\n      frontFaceAlphaByDistance: new Cartesian4(),\n      backFaceAlphaByDistance: new Cartesian4(),\n      localizedTranslucencyRectangle: new Cartesian4(),\n      undergroundColor: Color.clone(Color.TRANSPARENT),\n      undergroundColorAlphaByDistance: new Cartesian4(),\n      lambertDiffuseMultiplier: 0.0,\n      vertexShadowDarkness: 0.0,\n    },\n  };\n\n  if (defined(globeSurfaceTileProvider.materialUniformMap)) {\n    return combine(uniformMap, globeSurfaceTileProvider.materialUniformMap);\n  }\n\n  return uniformMap;\n}\n\nfunction createWireframeVertexArrayIfNecessary(context, provider, tile) {\n  const surfaceTile = tile.data;\n\n  let mesh;\n  let vertexArray;\n\n  if (defined(surfaceTile.vertexArray)) {\n    mesh = surfaceTile.mesh;\n    vertexArray = surfaceTile.vertexArray;\n  } else if (\n    defined(surfaceTile.fill) &&\n    defined(surfaceTile.fill.vertexArray)\n  ) {\n    mesh = surfaceTile.fill.mesh;\n    vertexArray = surfaceTile.fill.vertexArray;\n  }\n\n  if (!defined(mesh) || !defined(vertexArray)) {\n    return;\n  }\n\n  if (defined(surfaceTile.wireframeVertexArray)) {\n    if (surfaceTile.wireframeVertexArray.mesh === mesh) {\n      return;\n    }\n\n    surfaceTile.wireframeVertexArray.destroy();\n    surfaceTile.wireframeVertexArray = undefined;\n  }\n\n  surfaceTile.wireframeVertexArray = createWireframeVertexArray(\n    context,\n    vertexArray,\n    mesh,\n  );\n  surfaceTile.wireframeVertexArray.mesh = mesh;\n}\n\n/**\n * Creates a vertex array for wireframe rendering of a terrain tile.\n *\n * @private\n *\n * @param {Context} context The context in which to create the vertex array.\n * @param {VertexArray} vertexArray The existing, non-wireframe vertex array.  The new vertex array\n *                      will share vertex buffers with this existing one.\n * @param {TerrainMesh} terrainMesh The terrain mesh containing non-wireframe indices.\n * @returns {VertexArray} The vertex array for wireframe rendering.\n */\nfunction createWireframeVertexArray(context, vertexArray, terrainMesh) {\n  const indices = terrainMesh.indices;\n\n  const geometry = {\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  };\n\n  GeometryPipeline.toWireframe(geometry);\n\n  const wireframeIndices = geometry.indices;\n  const wireframeIndexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: wireframeIndices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.fromSizeInBytes(\n      wireframeIndices.BYTES_PER_ELEMENT,\n    ),\n  });\n  return new VertexArray({\n    context: context,\n    attributes: vertexArray._attributes,\n    indexBuffer: wireframeIndexBuffer,\n  });\n}\n\nlet getDebugOrientedBoundingBox;\nlet getDebugBoundingSphere;\nlet debugDestroyPrimitive;\n\n(function () {\n  const instanceOBB = new GeometryInstance({\n    geometry: BoxOutlineGeometry.fromDimensions({\n      dimensions: new Cartesian3(2.0, 2.0, 2.0),\n    }),\n  });\n  const instanceSphere = new GeometryInstance({\n    geometry: new SphereOutlineGeometry({ radius: 1.0 }),\n  });\n  let modelMatrix = new Matrix4();\n  let previousVolume;\n  let primitive;\n\n  function createDebugPrimitive(instance) {\n    return new Primitive({\n      geometryInstances: instance,\n      appearance: new PerInstanceColorAppearance({\n        translucent: false,\n        flat: true,\n      }),\n      asynchronous: false,\n    });\n  }\n\n  getDebugOrientedBoundingBox = function (obb, color) {\n    if (obb === previousVolume) {\n      return primitive;\n    }\n    debugDestroyPrimitive();\n\n    previousVolume = obb;\n    modelMatrix = Matrix4.fromRotationTranslation(\n      obb.halfAxes,\n      obb.center,\n      modelMatrix,\n    );\n\n    instanceOBB.modelMatrix = modelMatrix;\n    instanceOBB.attributes.color =\n      ColorGeometryInstanceAttribute.fromColor(color);\n\n    primitive = createDebugPrimitive(instanceOBB);\n    return primitive;\n  };\n\n  getDebugBoundingSphere = function (sphere, color) {\n    if (sphere === previousVolume) {\n      return primitive;\n    }\n    debugDestroyPrimitive();\n\n    previousVolume = sphere;\n    modelMatrix = Matrix4.fromTranslation(sphere.center, modelMatrix);\n    modelMatrix = Matrix4.multiplyByUniformScale(\n      modelMatrix,\n      sphere.radius,\n      modelMatrix,\n    );\n\n    instanceSphere.modelMatrix = modelMatrix;\n    instanceSphere.attributes.color =\n      ColorGeometryInstanceAttribute.fromColor(color);\n\n    primitive = createDebugPrimitive(instanceSphere);\n    return primitive;\n  };\n\n  debugDestroyPrimitive = function () {\n    if (defined(primitive)) {\n      primitive.destroy();\n      primitive = undefined;\n      previousVolume = undefined;\n    }\n  };\n})();\n\nconst otherPassesInitialColor = new Cartesian4(0.0, 0.0, 0.0, 0.0);\nconst surfaceShaderSetOptionsScratch = {\n  frameState: undefined,\n  surfaceTile: undefined,\n  numberOfDayTextures: undefined,\n  applyBrightness: undefined,\n  applyContrast: undefined,\n  applyHue: undefined,\n  applySaturation: undefined,\n  applyGamma: undefined,\n  applyAlpha: undefined,\n  applyDayNightAlpha: undefined,\n  applySplit: undefined,\n  showReflectiveOcean: undefined,\n  showOceanWaves: undefined,\n  enableLighting: undefined,\n  dynamicAtmosphereLighting: undefined,\n  dynamicAtmosphereLightingFromSun: undefined,\n  showGroundAtmosphere: undefined,\n  perFragmentGroundAtmosphere: undefined,\n  hasVertexNormals: undefined,\n  useWebMercatorProjection: undefined,\n  enableFog: undefined,\n  enableClippingPlanes: undefined,\n  clippingPlanes: undefined,\n  enableClippingPolygons: undefined,\n  clippingPolygons: undefined,\n  clippedByBoundaries: undefined,\n  hasImageryLayerCutout: undefined,\n  colorCorrect: undefined,\n  colorToAlpha: undefined,\n  hasGeodeticSurfaceNormals: undefined,\n  hasExaggeration: undefined,\n};\n\nconst defaultUndergroundColor = Color.TRANSPARENT;\nconst defaultUndergroundColorAlphaByDistance = new NearFarScalar();\n\nfunction addDrawCommandsForTile(tileProvider, tile, frameState) {\n  const surfaceTile = tile.data;\n\n  if (!defined(surfaceTile.vertexArray)) {\n    if (surfaceTile.fill === undefined) {\n      // No fill was created for this tile, probably because this tile is not connected to\n      // any renderable tiles. So create a simple tile in the middle of the tile's possible\n      // height range.\n      surfaceTile.fill = new TerrainFillMesh(tile);\n    }\n    surfaceTile.fill.update(tileProvider, frameState);\n  }\n\n  const creditDisplay = frameState.creditDisplay;\n\n  const terrainData = surfaceTile.terrainData;\n  if (defined(terrainData) && defined(terrainData.credits)) {\n    const tileCredits = terrainData.credits;\n    for (\n      let tileCreditIndex = 0, tileCreditLength = tileCredits.length;\n      tileCreditIndex < tileCreditLength;\n      ++tileCreditIndex\n    ) {\n      creditDisplay.addCreditToNextFrame(tileCredits[tileCreditIndex]);\n    }\n  }\n\n  let maxTextures = ContextLimits.maximumTextureImageUnits;\n\n  let waterMaskTexture = surfaceTile.waterMaskTexture;\n  let waterMaskTranslationAndScale = surfaceTile.waterMaskTranslationAndScale;\n  if (!defined(waterMaskTexture) && defined(surfaceTile.fill)) {\n    waterMaskTexture = surfaceTile.fill.waterMaskTexture;\n    waterMaskTranslationAndScale =\n      surfaceTile.fill.waterMaskTranslationAndScale;\n  }\n\n  const cameraUnderground = frameState.cameraUnderground;\n\n  const globeTranslucencyState = frameState.globeTranslucencyState;\n  const translucent = globeTranslucencyState.translucent;\n  const frontFaceAlphaByDistance =\n    globeTranslucencyState.frontFaceAlphaByDistance;\n  const backFaceAlphaByDistance =\n    globeTranslucencyState.backFaceAlphaByDistance;\n  const translucencyRectangle = globeTranslucencyState.rectangle;\n\n  const undergroundColor =\n    tileProvider.undergroundColor ?? defaultUndergroundColor;\n  const undergroundColorAlphaByDistance =\n    tileProvider.undergroundColorAlphaByDistance ??\n    defaultUndergroundColorAlphaByDistance;\n  const showUndergroundColor =\n    isUndergroundVisible(tileProvider, frameState) &&\n    frameState.mode === SceneMode.SCENE3D &&\n    undergroundColor.alpha > 0.0 &&\n    (undergroundColorAlphaByDistance.nearValue > 0.0 ||\n      undergroundColorAlphaByDistance.farValue > 0.0);\n\n  const lambertDiffuseMultiplier = tileProvider.lambertDiffuseMultiplier;\n  const vertexShadowDarkness = tileProvider.vertexShadowDarkness;\n\n  const hasWaterMask = tileProvider.hasWaterMask && defined(waterMaskTexture);\n  const showReflectiveOcean = hasWaterMask && tileProvider.showWaterEffect;\n  const oceanNormalMap = tileProvider.oceanNormalMap;\n  const showOceanWaves = showReflectiveOcean && defined(oceanNormalMap);\n  const terrainProvider = tileProvider.terrainProvider;\n  const hasVertexNormals =\n    defined(terrainProvider) && tileProvider.terrainProvider.hasVertexNormals;\n  const enableFog =\n    frameState.fog.enabled && frameState.fog.renderable && !cameraUnderground;\n  const showGroundAtmosphere =\n    tileProvider.showGroundAtmosphere && frameState.mode === SceneMode.SCENE3D;\n  const castShadows =\n    ShadowMode.castShadows(tileProvider.shadows) && !translucent;\n  const receiveShadows =\n    ShadowMode.receiveShadows(tileProvider.shadows) && !translucent;\n\n  const hueShift = tileProvider.hueShift;\n  const saturationShift = tileProvider.saturationShift;\n  const brightnessShift = tileProvider.brightnessShift;\n\n  let colorCorrect = !(\n    CesiumMath.equalsEpsilon(hueShift, 0.0, CesiumMath.EPSILON7) &&\n    CesiumMath.equalsEpsilon(saturationShift, 0.0, CesiumMath.EPSILON7) &&\n    CesiumMath.equalsEpsilon(brightnessShift, 0.0, CesiumMath.EPSILON7)\n  );\n\n  let perFragmentGroundAtmosphere = false;\n  if (showGroundAtmosphere) {\n    const cameraDistance = Cartesian3.magnitude(frameState.camera.positionWC);\n    const fadeOutDistance = tileProvider.nightFadeOutDistance;\n    perFragmentGroundAtmosphere = cameraDistance > fadeOutDistance;\n  }\n\n  if (hasWaterMask) {\n    --maxTextures;\n  }\n  if (showOceanWaves) {\n    --maxTextures;\n  }\n  if (\n    defined(frameState.shadowState) &&\n    frameState.shadowState.shadowsEnabled\n  ) {\n    --maxTextures;\n  }\n  if (\n    defined(tileProvider.clippingPlanes) &&\n    tileProvider.clippingPlanes.enabled\n  ) {\n    --maxTextures;\n  }\n  if (\n    defined(tileProvider.clippingPolygons) &&\n    tileProvider.clippingPolygons.enabled\n  ) {\n    --maxTextures;\n    --maxTextures;\n  }\n\n  maxTextures -= globeTranslucencyState.numberOfTextureUniforms;\n\n  const mesh = surfaceTile.renderedMesh;\n  let rtc = mesh.center;\n  const encoding = mesh.encoding;\n  const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  const exaggeration = frameState.verticalExaggeration;\n  const exaggerationRelativeHeight =\n    frameState.verticalExaggerationRelativeHeight;\n  const hasExaggeration = exaggeration !== 1.0;\n  const hasGeodeticSurfaceNormals = encoding.hasGeodeticSurfaceNormals;\n\n  // Not used in 3D.\n  const tileRectangle = tileRectangleScratch;\n\n  // Only used for Mercator projections.\n  let southLatitude = 0.0;\n  let northLatitude = 0.0;\n  let southMercatorY = 0.0;\n  let oneOverMercatorHeight = 0.0;\n\n  let useWebMercatorProjection = false;\n\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    const projection = frameState.mapProjection;\n    const southwest = projection.project(\n      Rectangle.southwest(tile.rectangle),\n      southwestScratch,\n    );\n    const northeast = projection.project(\n      Rectangle.northeast(tile.rectangle),\n      northeastScratch,\n    );\n\n    tileRectangle.x = southwest.x;\n    tileRectangle.y = southwest.y;\n    tileRectangle.z = northeast.x;\n    tileRectangle.w = northeast.y;\n\n    // In 2D and Columbus View, use the center of the tile for RTC rendering.\n    if (frameState.mode !== SceneMode.MORPHING) {\n      rtc = rtcScratch;\n      rtc.x = 0.0;\n      rtc.y = (tileRectangle.z + tileRectangle.x) * 0.5;\n      rtc.z = (tileRectangle.w + tileRectangle.y) * 0.5;\n      tileRectangle.x -= rtc.y;\n      tileRectangle.y -= rtc.z;\n      tileRectangle.z -= rtc.y;\n      tileRectangle.w -= rtc.z;\n    }\n\n    if (\n      frameState.mode === SceneMode.SCENE2D &&\n      encoding.quantization === TerrainQuantization.BITS12\n    ) {\n      // In 2D, the texture coordinates of the tile are interpolated over the rectangle to get the position in the vertex shader.\n      // When the texture coordinates are quantized, error is introduced. This can be seen through the 1px wide cracking\n      // between the quantized tiles in 2D. To compensate for the error, move the expand the rectangle in each direction by\n      // half the error amount.\n      const epsilon = (1.0 / (Math.pow(2.0, 12.0) - 1.0)) * 0.5;\n      const widthEpsilon = (tileRectangle.z - tileRectangle.x) * epsilon;\n      const heightEpsilon = (tileRectangle.w - tileRectangle.y) * epsilon;\n      tileRectangle.x -= widthEpsilon;\n      tileRectangle.y -= heightEpsilon;\n      tileRectangle.z += widthEpsilon;\n      tileRectangle.w += heightEpsilon;\n    }\n\n    if (projection instanceof WebMercatorProjection) {\n      southLatitude = tile.rectangle.south;\n      northLatitude = tile.rectangle.north;\n\n      southMercatorY =\n        WebMercatorProjection.geodeticLatitudeToMercatorAngle(southLatitude);\n\n      oneOverMercatorHeight =\n        1.0 /\n        (WebMercatorProjection.geodeticLatitudeToMercatorAngle(northLatitude) -\n          southMercatorY);\n\n      useWebMercatorProjection = true;\n    }\n  }\n\n  const surfaceShaderSetOptions = surfaceShaderSetOptionsScratch;\n  surfaceShaderSetOptions.frameState = frameState;\n  surfaceShaderSetOptions.surfaceTile = surfaceTile;\n  surfaceShaderSetOptions.hasWaterMask = hasWaterMask;\n  surfaceShaderSetOptions.showReflectiveOcean = showReflectiveOcean;\n  surfaceShaderSetOptions.showOceanWaves = showOceanWaves;\n  surfaceShaderSetOptions.enableLighting = tileProvider.enableLighting;\n  surfaceShaderSetOptions.dynamicAtmosphereLighting =\n    tileProvider.dynamicAtmosphereLighting;\n  surfaceShaderSetOptions.dynamicAtmosphereLightingFromSun =\n    tileProvider.dynamicAtmosphereLightingFromSun;\n  surfaceShaderSetOptions.showGroundAtmosphere = showGroundAtmosphere;\n  surfaceShaderSetOptions.atmosphereLightIntensity =\n    tileProvider.atmosphereLightIntensity;\n  surfaceShaderSetOptions.atmosphereRayleighCoefficient =\n    tileProvider.atmosphereRayleighCoefficient;\n  surfaceShaderSetOptions.atmosphereMieCoefficient =\n    tileProvider.atmosphereMieCoefficient;\n  surfaceShaderSetOptions.atmosphereRayleighScaleHeight =\n    tileProvider.atmosphereRayleighScaleHeight;\n  surfaceShaderSetOptions.atmosphereMieScaleHeight =\n    tileProvider.atmosphereMieScaleHeight;\n  surfaceShaderSetOptions.atmosphereMieAnisotropy =\n    tileProvider.atmosphereMieAnisotropy;\n  surfaceShaderSetOptions.perFragmentGroundAtmosphere =\n    perFragmentGroundAtmosphere;\n  surfaceShaderSetOptions.hasVertexNormals = hasVertexNormals;\n  surfaceShaderSetOptions.useWebMercatorProjection = useWebMercatorProjection;\n  surfaceShaderSetOptions.clippedByBoundaries = surfaceTile.clippedByBoundaries;\n  surfaceShaderSetOptions.hasGeodeticSurfaceNormals = hasGeodeticSurfaceNormals;\n  surfaceShaderSetOptions.hasExaggeration = hasExaggeration;\n\n  const tileImageryCollection = surfaceTile.imagery;\n  let imageryIndex = 0;\n  const imageryLen = tileImageryCollection.length;\n\n  const showSkirts =\n    tileProvider.showSkirts && !cameraUnderground && !translucent;\n  const backFaceCulling =\n    tileProvider.backFaceCulling && !cameraUnderground && !translucent;\n  const firstPassRenderState = backFaceCulling\n    ? tileProvider._renderState\n    : tileProvider._disableCullingRenderState;\n  const otherPassesRenderState = backFaceCulling\n    ? tileProvider._blendRenderState\n    : tileProvider._disableCullingBlendRenderState;\n  let renderState = firstPassRenderState;\n\n  let initialColor = tileProvider._firstPassInitialColor;\n\n  const context = frameState.context;\n\n  if (!defined(tileProvider._debug.boundingSphereTile)) {\n    debugDestroyPrimitive();\n  }\n\n  const materialUniformMapChanged =\n    tileProvider._materialUniformMap !== tileProvider.materialUniformMap;\n  if (materialUniformMapChanged) {\n    tileProvider._materialUniformMap = tileProvider.materialUniformMap;\n    const drawCommandsLength = tileProvider._drawCommands.length;\n    for (let i = 0; i < drawCommandsLength; ++i) {\n      tileProvider._uniformMaps[i] = createTileUniformMap(\n        frameState,\n        tileProvider,\n      );\n    }\n  }\n\n  do {\n    let numberOfDayTextures = 0;\n\n    let command;\n    let uniformMap;\n\n    if (tileProvider._drawCommands.length <= tileProvider._usedDrawCommands) {\n      command = new DrawCommand();\n      command.owner = tile;\n      command.cull = false;\n      command.boundingVolume = new BoundingSphere();\n      command.orientedBoundingBox = undefined;\n\n      uniformMap = createTileUniformMap(frameState, tileProvider);\n\n      tileProvider._drawCommands.push(command);\n      tileProvider._uniformMaps.push(uniformMap);\n    } else {\n      command = tileProvider._drawCommands[tileProvider._usedDrawCommands];\n      uniformMap = tileProvider._uniformMaps[tileProvider._usedDrawCommands];\n    }\n\n    command.owner = tile;\n\n    ++tileProvider._usedDrawCommands;\n\n    if (tile === tileProvider._debug.boundingSphereTile) {\n      const obb = tileBoundingRegion.boundingVolume;\n      const boundingSphere = tileBoundingRegion.boundingSphere;\n      // If a debug primitive already exists for this tile, it will not be\n      // re-created, to avoid allocation every frame. If it were possible\n      // to have more than one selected tile, this would have to change.\n      if (defined(obb)) {\n        getDebugOrientedBoundingBox(obb, Color.RED).update(frameState);\n      } else if (defined(boundingSphere)) {\n        getDebugBoundingSphere(boundingSphere, Color.RED).update(frameState);\n      }\n    }\n\n    const uniformMapProperties = uniformMap.properties;\n    Cartesian4.clone(initialColor, uniformMapProperties.initialColor);\n    uniformMapProperties.oceanNormalMap = oceanNormalMap;\n    uniformMapProperties.lightingFadeDistance.x =\n      tileProvider.lightingFadeOutDistance;\n    uniformMapProperties.lightingFadeDistance.y =\n      tileProvider.lightingFadeInDistance;\n    uniformMapProperties.nightFadeDistance.x =\n      tileProvider.nightFadeOutDistance;\n    uniformMapProperties.nightFadeDistance.y = tileProvider.nightFadeInDistance;\n    uniformMapProperties.atmosphereLightIntensity =\n      tileProvider.atmosphereLightIntensity;\n    uniformMapProperties.atmosphereRayleighCoefficient =\n      tileProvider.atmosphereRayleighCoefficient;\n    uniformMapProperties.atmosphereMieCoefficient =\n      tileProvider.atmosphereMieCoefficient;\n    uniformMapProperties.atmosphereRayleighScaleHeight =\n      tileProvider.atmosphereRayleighScaleHeight;\n    uniformMapProperties.atmosphereMieScaleHeight =\n      tileProvider.atmosphereMieScaleHeight;\n    uniformMapProperties.atmosphereMieAnisotropy =\n      tileProvider.atmosphereMieAnisotropy;\n    uniformMapProperties.zoomedOutOceanSpecularIntensity =\n      tileProvider.zoomedOutOceanSpecularIntensity;\n\n    const frontFaceAlphaByDistanceFinal = cameraUnderground\n      ? backFaceAlphaByDistance\n      : frontFaceAlphaByDistance;\n    const backFaceAlphaByDistanceFinal = cameraUnderground\n      ? frontFaceAlphaByDistance\n      : backFaceAlphaByDistance;\n\n    if (defined(frontFaceAlphaByDistanceFinal)) {\n      Cartesian4.fromElements(\n        frontFaceAlphaByDistanceFinal.near,\n        frontFaceAlphaByDistanceFinal.nearValue,\n        frontFaceAlphaByDistanceFinal.far,\n        frontFaceAlphaByDistanceFinal.farValue,\n        uniformMapProperties.frontFaceAlphaByDistance,\n      );\n      Cartesian4.fromElements(\n        backFaceAlphaByDistanceFinal.near,\n        backFaceAlphaByDistanceFinal.nearValue,\n        backFaceAlphaByDistanceFinal.far,\n        backFaceAlphaByDistanceFinal.farValue,\n        uniformMapProperties.backFaceAlphaByDistance,\n      );\n    }\n\n    Cartesian4.fromElements(\n      undergroundColorAlphaByDistance.near,\n      undergroundColorAlphaByDistance.nearValue,\n      undergroundColorAlphaByDistance.far,\n      undergroundColorAlphaByDistance.farValue,\n      uniformMapProperties.undergroundColorAlphaByDistance,\n    );\n    Color.clone(undergroundColor, uniformMapProperties.undergroundColor);\n\n    uniformMapProperties.lambertDiffuseMultiplier = lambertDiffuseMultiplier;\n    uniformMapProperties.vertexShadowDarkness = vertexShadowDarkness;\n\n    const highlightFillTile =\n      !defined(surfaceTile.vertexArray) &&\n      defined(tileProvider.fillHighlightColor) &&\n      tileProvider.fillHighlightColor.alpha > 0.0;\n    if (highlightFillTile) {\n      Color.clone(\n        tileProvider.fillHighlightColor,\n        uniformMapProperties.fillHighlightColor,\n      );\n    }\n\n    uniformMapProperties.verticalExaggerationAndRelativeHeight.x = exaggeration;\n    uniformMapProperties.verticalExaggerationAndRelativeHeight.y =\n      exaggerationRelativeHeight;\n\n    uniformMapProperties.center3D = mesh.center;\n    Cartesian3.clone(rtc, uniformMapProperties.rtc);\n\n    Cartesian4.clone(tileRectangle, uniformMapProperties.tileRectangle);\n    uniformMapProperties.southAndNorthLatitude.x = southLatitude;\n    uniformMapProperties.southAndNorthLatitude.y = northLatitude;\n    uniformMapProperties.southMercatorYAndOneOverHeight.x = southMercatorY;\n    uniformMapProperties.southMercatorYAndOneOverHeight.y =\n      oneOverMercatorHeight;\n\n    // Convert tile limiter rectangle from cartographic to texture space using the tileRectangle.\n    const localizedCartographicLimitRectangle =\n      localizedCartographicLimitRectangleScratch;\n    const cartographicLimitRectangle = clipRectangleAntimeridian(\n      tile.rectangle,\n      tileProvider.cartographicLimitRectangle,\n    );\n\n    const localizedTranslucencyRectangle =\n      localizedTranslucencyRectangleScratch;\n    const clippedTranslucencyRectangle = clipRectangleAntimeridian(\n      tile.rectangle,\n      translucencyRectangle,\n    );\n\n    Cartesian3.fromElements(\n      hueShift,\n      saturationShift,\n      brightnessShift,\n      uniformMapProperties.hsbShift,\n    );\n\n    const cartographicTileRectangle = tile.rectangle;\n    const inverseTileWidth = 1.0 / cartographicTileRectangle.width;\n    const inverseTileHeight = 1.0 / cartographicTileRectangle.height;\n    localizedCartographicLimitRectangle.x =\n      (cartographicLimitRectangle.west - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedCartographicLimitRectangle.y =\n      (cartographicLimitRectangle.south - cartographicTileRectangle.south) *\n      inverseTileHeight;\n    localizedCartographicLimitRectangle.z =\n      (cartographicLimitRectangle.east - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedCartographicLimitRectangle.w =\n      (cartographicLimitRectangle.north - cartographicTileRectangle.south) *\n      inverseTileHeight;\n\n    Cartesian4.clone(\n      localizedCartographicLimitRectangle,\n      uniformMapProperties.localizedCartographicLimitRectangle,\n    );\n\n    localizedTranslucencyRectangle.x =\n      (clippedTranslucencyRectangle.west - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedTranslucencyRectangle.y =\n      (clippedTranslucencyRectangle.south - cartographicTileRectangle.south) *\n      inverseTileHeight;\n    localizedTranslucencyRectangle.z =\n      (clippedTranslucencyRectangle.east - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedTranslucencyRectangle.w =\n      (clippedTranslucencyRectangle.north - cartographicTileRectangle.south) *\n      inverseTileHeight;\n\n    Cartesian4.clone(\n      localizedTranslucencyRectangle,\n      uniformMapProperties.localizedTranslucencyRectangle,\n    );\n\n    // For performance, render fog only when fog is enabled and the effect of\n    // fog would be non-negligible. This prevents the shader from running when\n    // the camera is in space, for example.\n    const applyFog =\n      enableFog &&\n      CesiumMath.fog(tile._distance, frameState.fog.density) >\n        CesiumMath.EPSILON3;\n    colorCorrect = colorCorrect && (applyFog || showGroundAtmosphere);\n\n    let applyBrightness = false;\n    let applyContrast = false;\n    let applyHue = false;\n    let applySaturation = false;\n    let applyGamma = false;\n    let applyAlpha = false;\n    let applyDayNightAlpha = false;\n    let applySplit = false;\n    let applyCutout = false;\n    let applyColorToAlpha = false;\n\n    while (numberOfDayTextures < maxTextures && imageryIndex < imageryLen) {\n      const tileImagery = tileImageryCollection[imageryIndex];\n      const imagery = tileImagery.readyImagery;\n      ++imageryIndex;\n\n      if (!defined(imagery) || imagery.imageryLayer.alpha === 0.0) {\n        continue;\n      }\n\n      const texture = tileImagery.useWebMercatorT\n        ? imagery.textureWebMercator\n        : imagery.texture;\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(texture)) {\n        // Our \"ready\" texture isn't actually ready.  This should never happen.\n        //\n        // Side note: It IS possible for it to not be in the READY ImageryState, though.\n        // This can happen when a single imagery tile is shared by two terrain tiles (common)\n        // and one of them (A) needs a geographic version of the tile because it is near the poles,\n        // and the other (B) does not.  B can and will transition the imagery tile to the READY state\n        // without reprojecting to geographic.  Then, later, A will deem that same tile not-ready-yet\n        // because it only has the Web Mercator texture, and flip it back to the TRANSITIONING state.\n        // The imagery tile won't be in the READY state anymore, but it's still READY enough for B's\n        // purposes.\n        throw new DeveloperError(\"readyImagery is not actually ready!\");\n      }\n      //>>includeEnd('debug');\n\n      const imageryLayer = imagery.imageryLayer;\n\n      if (!defined(tileImagery.textureTranslationAndScale)) {\n        tileImagery.textureTranslationAndScale =\n          imageryLayer._calculateTextureTranslationAndScale(tile, tileImagery);\n      }\n\n      uniformMapProperties.dayTextures[numberOfDayTextures] = texture;\n      uniformMapProperties.dayTextureTranslationAndScale[numberOfDayTextures] =\n        tileImagery.textureTranslationAndScale;\n      uniformMapProperties.dayTextureTexCoordsRectangle[numberOfDayTextures] =\n        tileImagery.textureCoordinateRectangle;\n      uniformMapProperties.dayTextureUseWebMercatorT[numberOfDayTextures] =\n        tileImagery.useWebMercatorT;\n\n      uniformMapProperties.dayTextureAlpha[numberOfDayTextures] =\n        imageryLayer.alpha;\n      applyAlpha =\n        applyAlpha ||\n        uniformMapProperties.dayTextureAlpha[numberOfDayTextures] !== 1.0;\n\n      uniformMapProperties.dayTextureNightAlpha[numberOfDayTextures] =\n        imageryLayer.nightAlpha;\n      applyDayNightAlpha =\n        applyDayNightAlpha ||\n        uniformMapProperties.dayTextureNightAlpha[numberOfDayTextures] !== 1.0;\n\n      uniformMapProperties.dayTextureDayAlpha[numberOfDayTextures] =\n        imageryLayer.dayAlpha;\n      applyDayNightAlpha =\n        applyDayNightAlpha ||\n        uniformMapProperties.dayTextureDayAlpha[numberOfDayTextures] !== 1.0;\n\n      uniformMapProperties.dayTextureBrightness[numberOfDayTextures] =\n        imageryLayer.brightness;\n      applyBrightness =\n        applyBrightness ||\n        uniformMapProperties.dayTextureBrightness[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_BRIGHTNESS;\n\n      uniformMapProperties.dayTextureContrast[numberOfDayTextures] =\n        imageryLayer.contrast;\n      applyContrast =\n        applyContrast ||\n        uniformMapProperties.dayTextureContrast[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_CONTRAST;\n\n      uniformMapProperties.dayTextureHue[numberOfDayTextures] =\n        imageryLayer.hue;\n      applyHue =\n        applyHue ||\n        uniformMapProperties.dayTextureHue[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_HUE;\n\n      uniformMapProperties.dayTextureSaturation[numberOfDayTextures] =\n        imageryLayer.saturation;\n      applySaturation =\n        applySaturation ||\n        uniformMapProperties.dayTextureSaturation[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_SATURATION;\n\n      uniformMapProperties.dayTextureOneOverGamma[numberOfDayTextures] =\n        1.0 / imageryLayer.gamma;\n      applyGamma =\n        applyGamma ||\n        uniformMapProperties.dayTextureOneOverGamma[numberOfDayTextures] !==\n          1.0 / ImageryLayer.DEFAULT_GAMMA;\n\n      uniformMapProperties.dayTextureSplit[numberOfDayTextures] =\n        imageryLayer.splitDirection;\n      applySplit =\n        applySplit ||\n        uniformMapProperties.dayTextureSplit[numberOfDayTextures] !== 0.0;\n\n      // Update cutout rectangle\n      let dayTextureCutoutRectangle =\n        uniformMapProperties.dayTextureCutoutRectangles[numberOfDayTextures];\n      if (!defined(dayTextureCutoutRectangle)) {\n        dayTextureCutoutRectangle =\n          uniformMapProperties.dayTextureCutoutRectangles[numberOfDayTextures] =\n            new Cartesian4();\n      }\n\n      Cartesian4.clone(Cartesian4.ZERO, dayTextureCutoutRectangle);\n      if (defined(imageryLayer.cutoutRectangle)) {\n        const cutoutRectangle = clipRectangleAntimeridian(\n          cartographicTileRectangle,\n          imageryLayer.cutoutRectangle,\n        );\n        const intersection = Rectangle.simpleIntersection(\n          cutoutRectangle,\n          cartographicTileRectangle,\n          rectangleIntersectionScratch,\n        );\n        applyCutout = defined(intersection) || applyCutout;\n\n        dayTextureCutoutRectangle.x =\n          (cutoutRectangle.west - cartographicTileRectangle.west) *\n          inverseTileWidth;\n        dayTextureCutoutRectangle.y =\n          (cutoutRectangle.south - cartographicTileRectangle.south) *\n          inverseTileHeight;\n        dayTextureCutoutRectangle.z =\n          (cutoutRectangle.east - cartographicTileRectangle.west) *\n          inverseTileWidth;\n        dayTextureCutoutRectangle.w =\n          (cutoutRectangle.north - cartographicTileRectangle.south) *\n          inverseTileHeight;\n      }\n\n      // Update color to alpha\n      let colorToAlpha =\n        uniformMapProperties.colorsToAlpha[numberOfDayTextures];\n      if (!defined(colorToAlpha)) {\n        colorToAlpha = uniformMapProperties.colorsToAlpha[numberOfDayTextures] =\n          new Cartesian4();\n      }\n\n      const hasColorToAlpha =\n        defined(imageryLayer.colorToAlpha) &&\n        imageryLayer.colorToAlphaThreshold > 0.0;\n      applyColorToAlpha = applyColorToAlpha || hasColorToAlpha;\n\n      if (hasColorToAlpha) {\n        const color = imageryLayer.colorToAlpha;\n        colorToAlpha.x = color.red;\n        colorToAlpha.y = color.green;\n        colorToAlpha.z = color.blue;\n        colorToAlpha.w = imageryLayer.colorToAlphaThreshold;\n      } else {\n        colorToAlpha.w = -1.0;\n      }\n\n      if (defined(imagery.credits)) {\n        const credits = imagery.credits;\n        for (\n          let creditIndex = 0, creditLength = credits.length;\n          creditIndex < creditLength;\n          ++creditIndex\n        ) {\n          creditDisplay.addCreditToNextFrame(credits[creditIndex]);\n        }\n      }\n\n      ++numberOfDayTextures;\n    }\n\n    // trim texture array to the used length so we don't end up using old textures\n    // which might get destroyed eventually\n    uniformMapProperties.dayTextures.length = numberOfDayTextures;\n    uniformMapProperties.waterMask = waterMaskTexture;\n    Cartesian4.clone(\n      waterMaskTranslationAndScale,\n      uniformMapProperties.waterMaskTranslationAndScale,\n    );\n\n    uniformMapProperties.minMaxHeight.x = encoding.minimumHeight;\n    uniformMapProperties.minMaxHeight.y = encoding.maximumHeight;\n    Matrix4.clone(encoding.matrix, uniformMapProperties.scaleAndBias);\n\n    // update clipping planes\n    const clippingPlanes = tileProvider._clippingPlanes;\n    const clippingPlanesEnabled =\n      defined(clippingPlanes) && clippingPlanes.enabled && tile.isClipped;\n    if (clippingPlanesEnabled) {\n      uniformMapProperties.clippingPlanesEdgeColor = Color.clone(\n        clippingPlanes.edgeColor,\n        uniformMapProperties.clippingPlanesEdgeColor,\n      );\n      uniformMapProperties.clippingPlanesEdgeWidth = clippingPlanes.edgeWidth;\n    }\n\n    // update clipping polygons\n    const clippingPolygons = tileProvider._clippingPolygons;\n    const clippingPolygonsEnabled =\n      defined(clippingPolygons) && clippingPolygons.enabled && tile.isClipped;\n\n    surfaceShaderSetOptions.numberOfDayTextures = numberOfDayTextures;\n    surfaceShaderSetOptions.applyBrightness = applyBrightness;\n    surfaceShaderSetOptions.applyContrast = applyContrast;\n    surfaceShaderSetOptions.applyHue = applyHue;\n    surfaceShaderSetOptions.applySaturation = applySaturation;\n    surfaceShaderSetOptions.applyGamma = applyGamma;\n    surfaceShaderSetOptions.applyAlpha = applyAlpha;\n    surfaceShaderSetOptions.applyDayNightAlpha = applyDayNightAlpha;\n    surfaceShaderSetOptions.applySplit = applySplit;\n    surfaceShaderSetOptions.enableFog = applyFog;\n    surfaceShaderSetOptions.enableClippingPlanes = clippingPlanesEnabled;\n    surfaceShaderSetOptions.clippingPlanes = clippingPlanes;\n    surfaceShaderSetOptions.enableClippingPolygons = clippingPolygonsEnabled;\n    surfaceShaderSetOptions.clippingPolygons = clippingPolygons;\n    surfaceShaderSetOptions.hasImageryLayerCutout = applyCutout;\n    surfaceShaderSetOptions.colorCorrect = colorCorrect;\n    surfaceShaderSetOptions.highlightFillTile = highlightFillTile;\n    surfaceShaderSetOptions.colorToAlpha = applyColorToAlpha;\n    surfaceShaderSetOptions.showUndergroundColor = showUndergroundColor;\n    surfaceShaderSetOptions.translucent = translucent;\n\n    let count = surfaceTile.renderedMesh.indices.length;\n    if (!showSkirts) {\n      count = surfaceTile.renderedMesh.indexCountWithoutSkirts;\n    }\n\n    command.shaderProgram = tileProvider._surfaceShaderSet.getShaderProgram(\n      surfaceShaderSetOptions,\n    );\n    command.castShadows = castShadows;\n    command.receiveShadows = receiveShadows;\n    command.renderState = renderState;\n    command.primitiveType = PrimitiveType.TRIANGLES;\n    command.vertexArray =\n      surfaceTile.vertexArray || surfaceTile.fill.vertexArray;\n    command.count = count;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.GLOBE;\n\n    if (tileProvider._debug.wireframe) {\n      createWireframeVertexArrayIfNecessary(context, tileProvider, tile);\n      if (defined(surfaceTile.wireframeVertexArray)) {\n        command.vertexArray = surfaceTile.wireframeVertexArray;\n        command.primitiveType = PrimitiveType.LINES;\n        command.count = count * 2;\n      }\n    }\n\n    let boundingVolume = command.boundingVolume;\n    const orientedBoundingBox = command.orientedBoundingBox;\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      BoundingSphere.fromRectangleWithHeights2D(\n        tile.rectangle,\n        frameState.mapProjection,\n        tileBoundingRegion.minimumHeight,\n        tileBoundingRegion.maximumHeight,\n        boundingVolume,\n      );\n      Cartesian3.fromElements(\n        boundingVolume.center.z,\n        boundingVolume.center.x,\n        boundingVolume.center.y,\n        boundingVolume.center,\n      );\n\n      if (frameState.mode === SceneMode.MORPHING) {\n        boundingVolume = BoundingSphere.union(\n          tileBoundingRegion.boundingSphere,\n          boundingVolume,\n          boundingVolume,\n        );\n      }\n    } else {\n      command.boundingVolume = BoundingSphere.clone(\n        tileBoundingRegion.boundingSphere,\n        boundingVolume,\n      );\n      command.orientedBoundingBox = OrientedBoundingBox.clone(\n        tileBoundingRegion.boundingVolume,\n        orientedBoundingBox,\n      );\n    }\n\n    command.dirty = true;\n\n    if (translucent) {\n      globeTranslucencyState.updateDerivedCommands(command, frameState);\n    }\n\n    pushCommand(command, frameState);\n\n    renderState = otherPassesRenderState;\n    initialColor = otherPassesInitialColor;\n  } while (imageryIndex < imageryLen);\n}\nexport default GlobeSurfaceTileProvider;\n"],"names":["GlobeSurfaceTileProvider","options","terrainProvider","imageryLayers","surfaceShaderSet","lightingFadeOutDistance","lightingFadeInDistance","hasWaterMask","showWaterEffect","oceanNormalMap","undefined","zoomedOutOceanSpecularIntensity","enableLighting","dynamicAtmosphereLighting","dynamicAtmosphereLightingFromSun","showGroundAtmosphere","shadows","RECEIVE_ONLY","vertexShadowDarkness","fillHighlightColor","hueShift","saturationShift","brightnessShift","showSkirts","backFaceCulling","undergroundColor","undergroundColorAlphaByDistance","lambertDiffuseMultiplier","materialUniformMap","_materialUniformMap","_quadtree","_terrainProvider","_imageryLayers","_surfaceShaderSet","_renderState","_blendRenderState","_disableCullingRenderState","_disableCullingBlendRenderState","_errorEvent","_removeLayerAddedListener","layerAdded","addEventListener","prototype","_onLayerAdded","_removeLayerRemovedListener","layerRemoved","_onLayerRemoved","_removeLayerMovedListener","layerMoved","_onLayerMoved","_removeLayerShownListener","layerShownOrHidden","_onLayerShownOrHidden","_imageryLayersUpdatedEvent","_layerOrderChanged","_tilesToRenderByTextureCount","_drawCommands","_uniformMaps","_usedDrawCommands","_vertexArraysToDestroy","_debug","wireframe","boundingSphereTile","_baseColor","_firstPassInitialColor","baseColor","_clippingPlanes","_clippingPolygons","cartographicLimitRectangle","clone","MAX_VALUE","_hasLoadedTilesThisFrame","_hasFillTilesThisFrame","_oldVerticalExaggeration","_oldVerticalExaggerationRelativeHeight","_oldSceneMode","SCENE3D","Object","defineProperties","get","set","value","fromColor","quadtree","tilingScheme","errorEvent","imageryLayersUpdatedEvent","invalidateAllTiles","clippingPlanes","setOwner","clippingPolygons","sortTileImageryByLayerIndex","a","b","aImagery","loadingImagery","readyImagery","bImagery","imageryLayer","_layerIndex","update","frameState","_update","updateCredits","surface","creditDisplay","credit","addCreditToNextFrame","i","len","length","layer","ready","show","imageryProvider","initialize","queueReprojectionCommands","forEachLoadedTile","tile","data","imagery","sort","vertexArraysToDestroy","j","_freeVertexArray","beginUpdate","tilesToRenderByTextureCount","tiles","enabled","queueCommands","endUpdate","fromCache","cull","depthTest","func","LESS","LESS_OR_EQUAL","blending","ALPHA_BLEND","rs","updateFillTiles","_tilesToRender","exaggeration","verticalExaggeration","exaggerationRelativeHeight","verticalExaggerationRelativeHeight","exaggerationChanged","surfaceTile","updateExaggeration","sceneModeChanged","mode","updateSceneMode","textureCountIndex","textureCountLength","tilesToRender","tileIndex","tileLength","tileBoundingRegion","addDrawCommandsForTile","minimumTerrainHeight","Math","min","minimumHeight","pushCommand","command","globeTranslucencyState","translucent","isBlendCommand","renderState","pushDerivedCommands","commandList","push","updateForPick","drawCommands","cancelReprojections","getLevelMaximumGeometricError","level","loadTile","terrainOnly","terrainStateBefore","boundingVolumeSourceTile","_lastSelectionResult","CULLED_BUT_NEEDED","terrainState","processStateMachine","computeTileVisibility","occluders","NONE","boundingSphereScratch","rectangleIntersectionScratch","splitCartographicLimitRectangleScratch","rectangleCenterScratch","clipRectangleAntimeridian","tileRectangle","west","east","splitRectangle","tileCenter","center","longitude","PI","isUndergroundVisible","tileProvider","cameraUnderground","equals","distance","computeDistanceToTile","_distance","undergroundVisible","fog","density","PARTIAL","cullingVolume","boundingVolume","boundingSphere","clippedByBoundaries","clippedCartographicLimitRectangle","rectangle","areaLimitIntersection","simpleIntersection","fromRectangleWithHeights2D","mapProjection","maximumHeight","fromElements","z","x","y","MORPHING","renderedMesh","union","planeIntersection","computeIntersectionWithBoundingVolume","isClipped","INSIDE","OUTSIDE","polygonIntersection","visibility","intersection","computeVisibility","INTERSECTING","FULL","ortho3D","camera","frustum","occludeePointInScaledSpace","ellipsoid","isScaledSpacePointVisiblePossiblyUnderEllipsoid","canRefine","terrainData","childAvailable","getTileDataAvailable","readyImageryScratch","canRenderTraversalStack","canRenderWithoutLosingDetail","terrainReady","initialImageryState","READY","tileImagery","isReady","state","FAILED","INVALID","layerIndex","lastFrame","_lastSelectionFrameNumber","stack","southwestChild","southeastChild","northwestChild","northeastChild","descendant","pop","lastFrameSelectionResult","_lastSelectionResultFrame","RENDERED","descendantSurface","descendantImagery","descendantTileImagery","descendantLoadingImagery","descendantIsReady","descendantLayerIndex","REFINED","tileDirectionScratch","computeTileLoadPriority","obb","cameraPosition","positionWC","cameraDirection","directionWC","tileDirection","subtract","magnitude","EPSILON5","divideByScalar","dot","modifiedModelViewScratch","modifiedModelViewProjectionScratch","tileRectangleScratch","localizedCartographicLimitRectangleScratch","localizedTranslucencyRectangleScratch","rtcScratch","centerEyeScratch","southwestScratch","northeastScratch","showTileThisFrame","readyTextureCount","tileImageryCollection","alpha","tileSet","vertexArray","debug","tilesRendered","texturesRendered","cornerPositionsScratch","computeOccludeePoint","result","ellipsoidalOccluder","_occluders","cornerPositions","fromRadians","south","north","computeHorizonCullingPointPossiblyUnderEllipsoid","updateTileBoundingRegion","max","cameraHeight","positionCartographic","height","distanceToMin","abs","distanceToMax","distanceToCamera","computeBoundingVolumes","oldMinimumHeight","oldMaximumHeight","hasBoundingVolumesFromMesh","sourceTile","mesh","_minimumHeight","_maximumHeight","Number","NaN","ancestorTile","parent","ancestorSurfaceTile","ancestorMesh","ancestorTerrainData","hasExaggeration","getHeight","boundingVolumeIsFromMesh","_orientedBoundingBox","orientedBoundingBox","_boundingSphere","boundingSphere3D","needsBounds","heightChanged","isDestroyed","destroy","_tileProvider","getTileReadyCallback","tileImageriesToFree","startIndex","endIndex","_createTileImagerySkeletons","freeResources","splice","index","that","tileImageryUpdatedEvent","reloadFunction","_imageryCache","_loadedCallbacks","insertionPoint","LOADING","_reload","renderable","raiseEvent","numDestroyed","newIndex","oldIndex","scratchClippingPlanesMatrix","scratchInverseTransposeClippingPlanesMatrix","createTileUniformMap","globeSurfaceTileProvider","uniformMap","u_initialColor","properties","initialColor","u_fillHighlightColor","u_zoomedOutOceanSpecularIntensity","u_oceanNormalMap","u_atmosphereLightIntensity","atmosphereLightIntensity","u_atmosphereRayleighCoefficient","atmosphereRayleighCoefficient","u_atmosphereMieCoefficient","atmosphereMieCoefficient","u_atmosphereRayleighScaleHeight","atmosphereRayleighScaleHeight","u_atmosphereMieScaleHeight","atmosphereMieScaleHeight","u_atmosphereMieAnisotropy","atmosphereMieAnisotropy","u_lightingFadeDistance","lightingFadeDistance","u_nightFadeDistance","nightFadeDistance","u_center3D","center3D","u_verticalExaggerationAndRelativeHeight","verticalExaggerationAndRelativeHeight","u_tileRectangle","u_modifiedModelView","viewMatrix","context","uniformState","view","centerEye","multiplyByPoint","rtc","setTranslation","u_modifiedModelViewProjection","projectionMatrix","projection","multiply","u_dayTextures","dayTextures","u_dayTextureTranslationAndScale","dayTextureTranslationAndScale","u_dayTextureTexCoordsRectangle","dayTextureTexCoordsRectangle","u_dayTextureUseWebMercatorT","dayTextureUseWebMercatorT","u_dayTextureAlpha","dayTextureAlpha","u_dayTextureNightAlpha","dayTextureNightAlpha","u_dayTextureDayAlpha","dayTextureDayAlpha","u_dayTextureBrightness","dayTextureBrightness","u_dayTextureContrast","dayTextureContrast","u_dayTextureHue","dayTextureHue","u_dayTextureSaturation","dayTextureSaturation","u_dayTextureOneOverGamma","dayTextureOneOverGamma","u_dayIntensity","dayIntensity","u_southAndNorthLatitude","southAndNorthLatitude","u_southMercatorYAndOneOverHeight","southMercatorYAndOneOverHeight","u_waterMask","waterMask","u_waterMaskTranslationAndScale","waterMaskTranslationAndScale","u_minMaxHeight","minMaxHeight","u_scaleAndBias","scaleAndBias","u_dayTextureSplit","dayTextureSplit","u_dayTextureCutoutRectangles","dayTextureCutoutRectangles","u_clippingPlanes","texture","defaultTexture","u_cartographicLimitRectangle","localizedCartographicLimitRectangle","u_clippingPlanesMatrix","transform","modelMatrix","IDENTITY","inverseTranspose","u_clippingPlanesEdgeStyle","style","clippingPlanesEdgeColor","clippingPlanesEdgeWidth","u_clippingDistance","clippingTexture","u_clippingExtents","extentsTexture","u_minimumBrightness","minimumBrightness","u_hsbShift","hsbShift","u_colorsToAlpha","colorsToAlpha","u_frontFaceAlphaByDistance","frontFaceAlphaByDistance","u_backFaceAlphaByDistance","backFaceAlphaByDistance","u_translucencyRectangle","localizedTranslucencyRectangle","u_undergroundColor","u_undergroundColorAlphaByDistance","u_lambertDiffuseMultiplier","u_vertexShadowDarkness","modifiedModelView","WHITE","TRANSPARENT","createWireframeVertexArrayIfNecessary","provider","fill","wireframeVertexArray","createWireframeVertexArray","terrainMesh","indices","geometry","primitiveType","TRIANGLES","toWireframe","wireframeIndices","wireframeIndexBuffer","createIndexBuffer","typedArray","usage","STATIC_DRAW","indexDatatype","fromSizeInBytes","BYTES_PER_ELEMENT","attributes","_attributes","indexBuffer","getDebugOrientedBoundingBox","getDebugBoundingSphere","debugDestroyPrimitive","instanceOBB","fromDimensions","dimensions","instanceSphere","radius","previousVolume","primitive","createDebugPrimitive","instance","geometryInstances","appearance","flat","asynchronous","color","fromRotationTranslation","halfAxes","sphere","fromTranslation","multiplyByUniformScale","otherPassesInitialColor","surfaceShaderSetOptionsScratch","numberOfDayTextures","applyBrightness","applyContrast","applyHue","applySaturation","applyGamma","applyAlpha","applyDayNightAlpha","applySplit","showReflectiveOcean","showOceanWaves","perFragmentGroundAtmosphere","hasVertexNormals","useWebMercatorProjection","enableFog","enableClippingPlanes","enableClippingPolygons","hasImageryLayerCutout","colorCorrect","colorToAlpha","hasGeodeticSurfaceNormals","defaultUndergroundColor","defaultUndergroundColorAlphaByDistance","credits","tileCredits","tileCreditIndex","tileCreditLength","maxTextures","maximumTextureImageUnits","waterMaskTexture","translucencyRectangle","showUndergroundColor","nearValue","farValue","castShadows","receiveShadows","equalsEpsilon","EPSILON7","cameraDistance","fadeOutDistance","nightFadeOutDistance","shadowState","shadowsEnabled","numberOfTextureUniforms","encoding","southLatitude","northLatitude","southMercatorY","oneOverMercatorHeight","southwest","project","northeast","w","SCENE2D","quantization","BITS12","epsilon","pow","widthEpsilon","heightEpsilon","geodeticLatitudeToMercatorAngle","surfaceShaderSetOptions","imageryIndex","imageryLen","firstPassRenderState","otherPassesRenderState","materialUniformMapChanged","drawCommandsLength","owner","RED","uniformMapProperties","nightFadeInDistance","frontFaceAlphaByDistanceFinal","backFaceAlphaByDistanceFinal","near","far","highlightFillTile","clippedTranslucencyRectangle","cartographicTileRectangle","inverseTileWidth","width","inverseTileHeight","applyFog","EPSILON3","applyCutout","applyColorToAlpha","useWebMercatorT","textureWebMercator","textureTranslationAndScale","_calculateTextureTranslationAndScale","textureCoordinateRectangle","nightAlpha","dayAlpha","brightness","DEFAULT_BRIGHTNESS","contrast","DEFAULT_CONTRAST","hue","DEFAULT_HUE","saturation","DEFAULT_SATURATION","gamma","DEFAULT_GAMMA","splitDirection","dayTextureCutoutRectangle","ZERO","cutoutRectangle","hasColorToAlpha","colorToAlphaThreshold","red","green","blue","creditIndex","creditLength","matrix","clippingPlanesEnabled","edgeColor","edgeWidth","clippingPolygonsEnabled","count","indexCountWithoutSkirts","shaderProgram","getShaderProgram","pass","GLOBE","LINES","dirty","updateDerivedCommands"],"mappings":"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","ignoreList":[0]}}]
}