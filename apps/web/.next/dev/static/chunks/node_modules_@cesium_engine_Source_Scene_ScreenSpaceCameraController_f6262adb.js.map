{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Scene/ScreenSpaceCameraController.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport KeyboardEventModifier from \"../Core/KeyboardEventModifier.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport VerticalExaggeration from \"../Core/VerticalExaggeration.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraEventAggregator from \"./CameraEventAggregator.js\";\nimport CameraEventType from \"./CameraEventType.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport TweenCollection from \"./TweenCollection.js\";\n\n/**\n * Modifies the camera position and orientation based on mouse input to a canvas.\n * @alias ScreenSpaceCameraController\n * @constructor\n *\n * @param {Scene} scene The scene.\n */\nfunction ScreenSpaceCameraController(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * If true, inputs are allowed conditionally with the flags enableTranslate, enableZoom,\n   * enableRotate, enableTilt, and enableLook.  If false, all inputs are disabled.\n   *\n   * NOTE: This setting is for temporary use cases, such as camera flights and\n   * drag-selection of regions (see Picking demo).  It is typically set to false at the\n   * start of such events, and set true on completion.  To keep inputs disabled\n   * past the end of camera flights, you must use the other booleans (enableTranslate,\n   * enableZoom, enableRotate, enableTilt, and enableLook).\n   * @type {boolean}\n   * @default true\n   */\n  this.enableInputs = true;\n  /**\n   * If true, allows the user to pan around the map.  If false, the camera stays locked at the current position.\n   * This flag only applies in 2D and Columbus view modes.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableTranslate = true;\n  /**\n   * If true, allows the user to zoom in and out.  If false, the camera is locked to the current distance from the ellipsoid.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableZoom = true;\n  /**\n   * If true, allows the user to rotate the world which translates the user's position.\n   * This flag only applies in 2D and 3D.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableRotate = true;\n  /**\n   * If true, allows the user to tilt the camera.  If false, the camera is locked to the current heading.\n   * This flag only applies in 3D and Columbus view.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableTilt = true;\n  /**\n   * If true, allows the user to use free-look. If false, the camera view direction can only be changed through translating\n   * or rotating. This flag only applies in 3D and Columbus view modes.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableLook = true;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to spin because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {number}\n   * @default 0.9\n   */\n  this.inertiaSpin = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to translate because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {number}\n   * @default 0.9\n   */\n  this.inertiaTranslate = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to zoom because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {number}\n   * @default 0.8\n   */\n  this.inertiaZoom = 0.8;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to limit the range\n   * of various user inputs to a percentage of the window width/height per animation frame.\n   * This helps keep the camera under control in low-frame-rate situations.\n   * @type {number}\n   * @default 0.1\n   */\n  this.maximumMovementRatio = 0.1;\n  /**\n   * Sets the duration, in seconds, of the bounce back animations in 2D and Columbus view.\n   * @type {number}\n   * @default 3.0\n   */\n  this.bounceAnimationTime = 3.0;\n  /**\n   * The minimum magnitude, in meters, of the camera position when zooming. Defaults to 1.0.\n   * @type {number}\n   * @default 1.0\n   */\n  this.minimumZoomDistance = 1.0;\n  /**\n   * The maximum magnitude, in meters, of the camera position when zooming. Defaults to positive infinity.\n   * @type {number}\n   * @default {@link Number.POSITIVE_INFINITY}\n   */\n  this.maximumZoomDistance = Number.POSITIVE_INFINITY;\n\n  /**\n   * A multiplier for the speed at which the camera will zoom.\n   * @type {number}\n   * @default 5.0\n   */\n  this.zoomFactor = 5.0;\n\n  /**\n   * The input that allows the user to pan around the map. This only applies in 2D and Columbus view modes.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n  this.translateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to zoom in/out.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.RIGHT_DRAG}, {@link CameraEventType.WHEEL}, {@link CameraEventType.PINCH}]\n   */\n  this.zoomEventTypes = [\n    CameraEventType.RIGHT_DRAG,\n    CameraEventType.WHEEL,\n    CameraEventType.PINCH,\n  ];\n  /**\n   * The input that allows the user to rotate around the globe or another object. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n  this.rotateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to tilt in 3D and Columbus view or twist in 2D.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.MIDDLE_DRAG}, {@link CameraEventType.PINCH}, {\n   *     eventType : {@link CameraEventType.LEFT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }, {\n   *     eventType : {@link CameraEventType.RIGHT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }]\n   */\n  this.tiltEventTypes = [\n    CameraEventType.MIDDLE_DRAG,\n    CameraEventType.PINCH,\n    {\n      eventType: CameraEventType.LEFT_DRAG,\n      modifier: KeyboardEventModifier.CTRL,\n    },\n    {\n      eventType: CameraEventType.RIGHT_DRAG,\n      modifier: KeyboardEventModifier.CTRL,\n    },\n  ];\n  /**\n   * The input that allows the user to change the direction the camera is viewing. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default { eventType : {@link CameraEventType.LEFT_DRAG}, modifier : {@link KeyboardEventModifier.SHIFT} }\n   */\n  this.lookEventTypes = {\n    eventType: CameraEventType.LEFT_DRAG,\n    modifier: KeyboardEventModifier.SHIFT,\n  };\n\n  const ellipsoid = scene.ellipsoid ?? Ellipsoid.default;\n\n  /**\n   * The minimum height the camera must be before picking the terrain or scene content instead of the ellipsoid. Defaults to scene.ellipsoid.minimumRadius * 0.025 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 150000.0 or scene.ellipsoid.minimumRadius * 0.025\n   */\n  this.minimumPickingTerrainHeight = Ellipsoid.WGS84.equals(ellipsoid)\n    ? 150000.0\n    : ellipsoid.minimumRadius * 0.025;\n  this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight;\n  /**\n   * The minimum distance the camera must be before testing for collision with terrain when zoom with inertia. Default to scene.ellipsoid.minimumRadius * 0.00063 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 4000.0 or scene.ellipsoid.minimumRadius * 0.00063\n   */\n  this.minimumPickingTerrainDistanceWithInertia = Ellipsoid.WGS84.equals(\n    ellipsoid,\n  )\n    ? 4000.0\n    : ellipsoid.minimumRadius * 0.00063;\n  /**\n   * The minimum height the camera must be before testing for collision with terrain. Default to scene.ellipsoid.minimumRadius * 0.0025 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 15000.0 or scene.ellipsoid.minimumRadius * 0.0025.\n   */\n  this.minimumCollisionTerrainHeight = Ellipsoid.WGS84.equals(ellipsoid)\n    ? 15000.0\n    : ellipsoid.minimumRadius * 0.0025;\n  this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight;\n  /**\n   * The minimum height the camera must be before switching from rotating a track ball to\n   * free look when clicks originate on the sky or in space. Defaults to ellipsoid.minimumRadius * 1.175 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 7500000.0 or scene.ellipsoid.minimumRadius * 1.175\n   */\n  this.minimumTrackBallHeight = Ellipsoid.WGS84.equals(ellipsoid)\n    ? 7500000.0\n    : ellipsoid.minimumRadius * 1.175;\n  this._minimumTrackBallHeight = this.minimumTrackBallHeight;\n  /**\n   * When disabled, the values of <code>maximumZoomDistance</code> and <code>minimumZoomDistance</code> are ignored.\n   * Also used in conjunction with {@link Cesium3DTileset#enableCollision} to prevent the camera from moving through or below a 3D Tileset surface.\n   * This may also affect clamping behavior when using {@link HeightReference.CLAMP_TO_GROUND} on 3D Tiles.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableCollisionDetection = true;\n  /**\n   * The angle, relative to the ellipsoid normal, restricting the maximum amount that the user can tilt the camera. If <code>undefined</code>, the angle of the camera tilt is unrestricted.\n   * @type {number|undefined}\n   * @default undefined\n   *\n   * @example\n   * // Prevent the camera from tilting below the ellipsoid surface\n   * viewer.scene.screenSpaceCameraController.maximumTiltAngle = Math.PI / 2.0;\n   */\n  this.maximumTiltAngle = undefined;\n\n  this._scene = scene;\n  this._globe = undefined;\n  this._ellipsoid = ellipsoid;\n\n  this._lastGlobeHeight = 0.0;\n\n  this._aggregator = new CameraEventAggregator(scene.canvas);\n\n  this._lastInertiaSpinMovement = undefined;\n  this._lastInertiaZoomMovement = undefined;\n  this._lastInertiaTranslateMovement = undefined;\n  this._lastInertiaTiltMovement = undefined;\n\n  // Zoom disables tilt, spin, and translate inertia\n  // Tilt disables spin and translate inertia\n  this._inertiaDisablers = {\n    _lastInertiaZoomMovement: [\n      \"_lastInertiaSpinMovement\",\n      \"_lastInertiaTranslateMovement\",\n      \"_lastInertiaTiltMovement\",\n    ],\n    _lastInertiaTiltMovement: [\n      \"_lastInertiaSpinMovement\",\n      \"_lastInertiaTranslateMovement\",\n    ],\n  };\n\n  this._tweens = new TweenCollection();\n  this._tween = undefined;\n\n  this._horizontalRotationAxis = undefined;\n\n  this._tiltCenterMousePosition = new Cartesian2(-1.0, -1.0);\n  this._tiltCenter = new Cartesian3();\n  this._rotateMousePosition = new Cartesian2(-1.0, -1.0);\n  this._rotateStartPosition = new Cartesian3();\n  this._strafeStartPosition = new Cartesian3();\n  this._strafeMousePosition = new Cartesian2();\n  this._strafeEndMousePosition = new Cartesian2();\n  this._zoomMouseStart = new Cartesian2(-1.0, -1.0);\n  this._zoomWorldPosition = new Cartesian3();\n  this._useZoomWorldPosition = false;\n  this._panLastMousePosition = new Cartesian2();\n  this._panLastWorldPosition = new Cartesian3();\n  this._tiltCVOffMap = false;\n  this._looking = false;\n  this._rotating = false;\n  this._strafing = false;\n  this._zoomingOnVector = false;\n  this._zoomingUnderground = false;\n  this._rotatingZoom = false;\n  this._adjustedHeightForTerrain = false;\n  this._cameraUnderground = false;\n\n  const projection = scene.mapProjection;\n  this._maxCoord = projection.project(\n    new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO),\n  );\n\n  // Constants, Make any of these public?\n  this._rotateFactor = undefined;\n  this._rotateRateRangeAdjustment = undefined;\n  this._maximumRotateRate = 1.77;\n  this._minimumRotateRate = 1.0 / 5000.0;\n  this._minimumZoomRate = 20.0;\n  this._maximumZoomRate = 5906376272000.0; // distance from the Sun to Pluto in meters.\n  this._minimumUndergroundPickDistance = 2000.0;\n  this._maximumUndergroundPickDistance = 10000.0;\n}\n\nfunction decay(time, coefficient) {\n  if (time < 0) {\n    return 0.0;\n  }\n\n  const tau = (1.0 - coefficient) * 25.0;\n  return Math.exp(-tau * time);\n}\n\nfunction sameMousePosition(movement) {\n  return Cartesian2.equalsEpsilon(\n    movement.startPosition,\n    movement.endPosition,\n    CesiumMath.EPSILON14,\n  );\n}\n\n// If the time between mouse down and mouse up is not between\n// these thresholds, the camera will not move with inertia.\n// This value is probably dependent on the browser and/or the\n// hardware. Should be investigated further.\nconst inertiaMaxClickTimeThreshold = 0.4;\n\nfunction maintainInertia(\n  aggregator,\n  type,\n  modifier,\n  decayCoef,\n  action,\n  object,\n  lastMovementName,\n) {\n  let movementState = object[lastMovementName];\n  if (!defined(movementState)) {\n    movementState = object[lastMovementName] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      motion: new Cartesian2(),\n      inertiaEnabled: true,\n    };\n  }\n\n  const ts = aggregator.getButtonPressTime(type, modifier);\n  const tr = aggregator.getButtonReleaseTime(type, modifier);\n\n  const threshold = ts && tr && (tr.getTime() - ts.getTime()) / 1000.0;\n  const now = new Date();\n  const fromNow = tr && (now.getTime() - tr.getTime()) / 1000.0;\n\n  if (ts && tr && threshold < inertiaMaxClickTimeThreshold) {\n    const d = decay(fromNow, decayCoef);\n\n    const lastMovement = aggregator.getLastMovement(type, modifier);\n    if (\n      !defined(lastMovement) ||\n      sameMousePosition(lastMovement) ||\n      !movementState.inertiaEnabled\n    ) {\n      return;\n    }\n\n    movementState.motion.x =\n      (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;\n    movementState.motion.y =\n      (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;\n\n    movementState.startPosition = Cartesian2.clone(\n      lastMovement.startPosition,\n      movementState.startPosition,\n    );\n\n    movementState.endPosition = Cartesian2.multiplyByScalar(\n      movementState.motion,\n      d,\n      movementState.endPosition,\n    );\n    movementState.endPosition = Cartesian2.add(\n      movementState.startPosition,\n      movementState.endPosition,\n      movementState.endPosition,\n    );\n\n    // If value from the decreasing exponential function is close to zero,\n    // the end coordinates may be NaN.\n    if (\n      isNaN(movementState.endPosition.x) ||\n      isNaN(movementState.endPosition.y) ||\n      Cartesian2.distance(\n        movementState.startPosition,\n        movementState.endPosition,\n      ) < 0.5\n    ) {\n      return;\n    }\n\n    if (!aggregator.isButtonDown(type, modifier)) {\n      const startPosition = aggregator.getStartMousePosition(type, modifier);\n      action(object, startPosition, movementState);\n    }\n  }\n}\n\nfunction activateInertia(controller, inertiaStateName) {\n  if (defined(inertiaStateName)) {\n    // Re-enable inertia if it was disabled\n    let movementState = controller[inertiaStateName];\n    if (defined(movementState)) {\n      movementState.inertiaEnabled = true;\n    }\n    // Disable inertia on other movements\n    const inertiasToDisable = controller._inertiaDisablers[inertiaStateName];\n    if (defined(inertiasToDisable)) {\n      const length = inertiasToDisable.length;\n      for (let i = 0; i < length; ++i) {\n        movementState = controller[inertiasToDisable[i]];\n        if (defined(movementState)) {\n          movementState.inertiaEnabled = false;\n        }\n      }\n    }\n  }\n}\n\nconst scratchEventTypeArray = [];\n\nfunction reactToInput(\n  controller,\n  enabled,\n  eventTypes,\n  action,\n  inertiaConstant,\n  inertiaStateName,\n) {\n  if (!defined(eventTypes)) {\n    return;\n  }\n\n  const aggregator = controller._aggregator;\n\n  if (!Array.isArray(eventTypes)) {\n    scratchEventTypeArray[0] = eventTypes;\n    eventTypes = scratchEventTypeArray;\n  }\n\n  const length = eventTypes.length;\n  for (let i = 0; i < length; ++i) {\n    const eventType = eventTypes[i];\n    const type = defined(eventType.eventType) ? eventType.eventType : eventType;\n    const modifier = eventType.modifier;\n\n    const movement =\n      aggregator.isMoving(type, modifier) &&\n      aggregator.getMovement(type, modifier);\n    const startPosition = aggregator.getStartMousePosition(type, modifier);\n\n    if (controller.enableInputs && enabled) {\n      if (movement) {\n        action(controller, startPosition, movement);\n        activateInertia(controller, inertiaStateName);\n      } else if (inertiaConstant < 1.0) {\n        maintainInertia(\n          aggregator,\n          type,\n          modifier,\n          inertiaConstant,\n          action,\n          controller,\n          inertiaStateName,\n        );\n      }\n    }\n  }\n}\n\nconst scratchZoomPickRay = new Ray();\nconst scratchPickCartesian = new Cartesian3();\nconst scratchZoomOffset = new Cartesian2();\nconst scratchZoomDirection = new Cartesian3();\nconst scratchCenterPixel = new Cartesian2();\nconst scratchCenterPosition = new Cartesian3();\nconst scratchPositionNormal = new Cartesian3();\nconst scratchPickNormal = new Cartesian3();\nconst scratchZoomAxis = new Cartesian3();\nconst scratchCameraPositionNormal = new Cartesian3();\n\n// Scratch variables used in zooming algorithm\nconst scratchTargetNormal = new Cartesian3();\nconst scratchCameraPosition = new Cartesian3();\nconst scratchCameraUpNormal = new Cartesian3();\nconst scratchCameraRightNormal = new Cartesian3();\nconst scratchForwardNormal = new Cartesian3();\nconst scratchPositionToTarget = new Cartesian3();\nconst scratchPositionToTargetNormal = new Cartesian3();\nconst scratchPan = new Cartesian3();\nconst scratchCenterMovement = new Cartesian3();\nconst scratchCenter = new Cartesian3();\nconst scratchCartesian = new Cartesian3();\nconst scratchCartesianTwo = new Cartesian3();\nconst scratchCartesianThree = new Cartesian3();\nconst scratchZoomViewOptions = {\n  orientation: new HeadingPitchRoll(),\n};\n\nfunction handleZoom(\n  object,\n  startPosition,\n  movement,\n  zoomFactor,\n  distanceMeasure,\n  unitPositionDotDirection,\n) {\n  let percentage = 1.0;\n  if (defined(unitPositionDotDirection)) {\n    percentage = CesiumMath.clamp(\n      Math.abs(unitPositionDotDirection),\n      0.25,\n      1.0,\n    );\n  }\n\n  const diff = movement.endPosition.y - movement.startPosition.y;\n\n  // distanceMeasure should be the height above the ellipsoid.\n  // When approaching the surface, the zoomRate slows and stops minimumZoomDistance above it.\n  const approachingSurface = diff > 0;\n  const minHeight = approachingSurface\n    ? object.minimumZoomDistance * percentage\n    : 0;\n  const maxHeight = object.maximumZoomDistance;\n\n  const minDistance = distanceMeasure - minHeight;\n  let zoomRate = zoomFactor * minDistance;\n  zoomRate = CesiumMath.clamp(\n    zoomRate,\n    object._minimumZoomRate,\n    object._maximumZoomRate,\n  );\n\n  let rangeWindowRatio = diff / object._scene.canvas.clientHeight;\n  rangeWindowRatio = Math.min(rangeWindowRatio, object.maximumMovementRatio);\n  let distance = zoomRate * rangeWindowRatio;\n\n  if (\n    object.enableCollisionDetection ||\n    object.minimumZoomDistance === 0.0 ||\n    !defined(object._globe) // look-at mode\n  ) {\n    if (distance > 0.0 && Math.abs(distanceMeasure - minHeight) < 1.0) {\n      return;\n    }\n\n    if (distance < 0.0 && Math.abs(distanceMeasure - maxHeight) < 1.0) {\n      return;\n    }\n\n    if (distanceMeasure - distance < minHeight) {\n      distance = distanceMeasure - minHeight - 1.0;\n    } else if (distanceMeasure - distance > maxHeight) {\n      distance = distanceMeasure - maxHeight;\n    }\n  }\n\n  const scene = object._scene;\n  const camera = scene.camera;\n  const mode = scene.mode;\n\n  const orientation = scratchZoomViewOptions.orientation;\n  orientation.heading = camera.heading;\n  orientation.pitch = camera.pitch;\n  orientation.roll = camera.roll;\n\n  const sameStartPosition =\n    movement.inertiaEnabled ??\n    Cartesian2.equals(startPosition, object._zoomMouseStart);\n  let zoomingOnVector = object._zoomingOnVector;\n  let rotatingZoom = object._rotatingZoom;\n  let pickedPosition;\n\n  if (!sameStartPosition) {\n    object._zoomMouseStart = Cartesian2.clone(\n      startPosition,\n      object._zoomMouseStart,\n    );\n\n    // When camera transform is set, such as tracking an entity, object._globe will be undefined, and no position should be picked\n    if (defined(object._globe) && mode === SceneMode.SCENE2D) {\n      pickedPosition = camera.getPickRay(\n        startPosition,\n        scratchZoomPickRay,\n      ).origin;\n      pickedPosition = Cartesian3.fromElements(\n        pickedPosition.y,\n        pickedPosition.z,\n        pickedPosition.x,\n      );\n    } else if (defined(object._globe)) {\n      pickedPosition = pickPosition(\n        object,\n        startPosition,\n        scratchPickCartesian,\n      );\n    }\n\n    if (defined(pickedPosition)) {\n      object._useZoomWorldPosition = true;\n      object._zoomWorldPosition = Cartesian3.clone(\n        pickedPosition,\n        object._zoomWorldPosition,\n      );\n    } else {\n      object._useZoomWorldPosition = false;\n    }\n\n    zoomingOnVector = object._zoomingOnVector = false;\n    rotatingZoom = object._rotatingZoom = false;\n    object._zoomingUnderground = object._cameraUnderground;\n  }\n\n  if (!object._useZoomWorldPosition) {\n    camera.zoomIn(distance);\n    return;\n  }\n\n  let zoomOnVector = mode === SceneMode.COLUMBUS_VIEW;\n\n  if (camera.positionCartographic.height < 2000000) {\n    rotatingZoom = true;\n  }\n\n  if (!sameStartPosition || rotatingZoom) {\n    if (mode === SceneMode.SCENE2D) {\n      const worldPosition = object._zoomWorldPosition;\n      const endPosition = camera.position;\n\n      if (\n        !Cartesian3.equals(worldPosition, endPosition) &&\n        camera.positionCartographic.height < object._maxCoord.x * 2.0\n      ) {\n        const savedX = camera.position.x;\n\n        const direction = Cartesian3.subtract(\n          worldPosition,\n          endPosition,\n          scratchZoomDirection,\n        );\n        Cartesian3.normalize(direction, direction);\n\n        const d =\n          (Cartesian3.distance(worldPosition, endPosition) * distance) /\n          (camera.getMagnitude() * 0.5);\n        camera.move(direction, d * 0.5);\n\n        if (\n          (camera.position.x < 0.0 && savedX > 0.0) ||\n          (camera.position.x > 0.0 && savedX < 0.0)\n        ) {\n          pickedPosition = camera.getPickRay(\n            startPosition,\n            scratchZoomPickRay,\n          ).origin;\n          pickedPosition = Cartesian3.fromElements(\n            pickedPosition.y,\n            pickedPosition.z,\n            pickedPosition.x,\n          );\n          object._zoomWorldPosition = Cartesian3.clone(\n            pickedPosition,\n            object._zoomWorldPosition,\n          );\n        }\n      }\n    } else if (mode === SceneMode.SCENE3D) {\n      const cameraPositionNormal = Cartesian3.normalize(\n        camera.position,\n        scratchCameraPositionNormal,\n      );\n      if (\n        object._cameraUnderground ||\n        object._zoomingUnderground ||\n        (camera.positionCartographic.height < 3000.0 &&\n          Math.abs(Cartesian3.dot(camera.direction, cameraPositionNormal)) <\n            0.6)\n      ) {\n        zoomOnVector = true;\n      } else {\n        const canvas = scene.canvas;\n\n        const centerPixel = scratchCenterPixel;\n        centerPixel.x = canvas.clientWidth / 2;\n        centerPixel.y = canvas.clientHeight / 2;\n        const centerPosition = pickPosition(\n          object,\n          centerPixel,\n          scratchCenterPosition,\n        );\n        // If centerPosition is not defined, it means the globe does not cover the center position of screen\n\n        if (!defined(centerPosition)) {\n          zoomOnVector = true;\n        } else if (camera.positionCartographic.height < 1000000) {\n          // The math in the else block assumes the camera\n          // points toward the earth surface, so we check it here.\n          // Theoretically, we should check for 90 degree, but it doesn't behave well when parallel\n          // to the earth surface\n          if (Cartesian3.dot(camera.direction, cameraPositionNormal) >= -0.5) {\n            zoomOnVector = true;\n          } else {\n            const cameraPosition = scratchCameraPosition;\n            Cartesian3.clone(camera.position, cameraPosition);\n            const target = object._zoomWorldPosition;\n\n            let targetNormal = scratchTargetNormal;\n\n            targetNormal = Cartesian3.normalize(target, targetNormal);\n\n            if (Cartesian3.dot(targetNormal, cameraPositionNormal) < 0.0) {\n              return;\n            }\n\n            const center = scratchCenter;\n            const forward = scratchForwardNormal;\n            Cartesian3.clone(camera.direction, forward);\n            Cartesian3.add(\n              cameraPosition,\n              Cartesian3.multiplyByScalar(forward, 1000, scratchCartesian),\n              center,\n            );\n\n            const positionToTarget = scratchPositionToTarget;\n            const positionToTargetNormal = scratchPositionToTargetNormal;\n            Cartesian3.subtract(target, cameraPosition, positionToTarget);\n\n            Cartesian3.normalize(positionToTarget, positionToTargetNormal);\n\n            const alphaDot = Cartesian3.dot(\n              cameraPositionNormal,\n              positionToTargetNormal,\n            );\n            if (alphaDot >= 0.0) {\n              // We zoomed past the target, and this zoom is not valid anymore.\n              // This line causes the next zoom movement to pick a new starting point.\n              object._zoomMouseStart.x = -1;\n              return;\n            }\n            const alpha = Math.acos(-alphaDot);\n            const cameraDistance = Cartesian3.magnitude(cameraPosition);\n            const targetDistance = Cartesian3.magnitude(target);\n            const remainingDistance = cameraDistance - distance;\n            const positionToTargetDistance =\n              Cartesian3.magnitude(positionToTarget);\n\n            const gamma = Math.asin(\n              CesiumMath.clamp(\n                (positionToTargetDistance / targetDistance) * Math.sin(alpha),\n                -1.0,\n                1.0,\n              ),\n            );\n            const delta = Math.asin(\n              CesiumMath.clamp(\n                (remainingDistance / targetDistance) * Math.sin(alpha),\n                -1.0,\n                1.0,\n              ),\n            );\n            const beta = gamma - delta + alpha;\n\n            const up = scratchCameraUpNormal;\n            Cartesian3.normalize(cameraPosition, up);\n            let right = scratchCameraRightNormal;\n            right = Cartesian3.cross(positionToTargetNormal, up, right);\n            right = Cartesian3.normalize(right, right);\n\n            Cartesian3.normalize(\n              Cartesian3.cross(up, right, scratchCartesian),\n              forward,\n            );\n\n            // Calculate new position to move to\n            Cartesian3.multiplyByScalar(\n              Cartesian3.normalize(center, scratchCartesian),\n              Cartesian3.magnitude(center) - distance,\n              center,\n            );\n            Cartesian3.normalize(cameraPosition, cameraPosition);\n            Cartesian3.multiplyByScalar(\n              cameraPosition,\n              remainingDistance,\n              cameraPosition,\n            );\n\n            // Pan\n            const pMid = scratchPan;\n            Cartesian3.multiplyByScalar(\n              Cartesian3.add(\n                Cartesian3.multiplyByScalar(\n                  up,\n                  Math.cos(beta) - 1,\n                  scratchCartesianTwo,\n                ),\n                Cartesian3.multiplyByScalar(\n                  forward,\n                  Math.sin(beta),\n                  scratchCartesianThree,\n                ),\n                scratchCartesian,\n              ),\n              remainingDistance,\n              pMid,\n            );\n            Cartesian3.add(cameraPosition, pMid, cameraPosition);\n\n            Cartesian3.normalize(center, up);\n            Cartesian3.normalize(\n              Cartesian3.cross(up, right, scratchCartesian),\n              forward,\n            );\n\n            const cMid = scratchCenterMovement;\n            Cartesian3.multiplyByScalar(\n              Cartesian3.add(\n                Cartesian3.multiplyByScalar(\n                  up,\n                  Math.cos(beta) - 1,\n                  scratchCartesianTwo,\n                ),\n                Cartesian3.multiplyByScalar(\n                  forward,\n                  Math.sin(beta),\n                  scratchCartesianThree,\n                ),\n                scratchCartesian,\n              ),\n              Cartesian3.magnitude(center),\n              cMid,\n            );\n            Cartesian3.add(center, cMid, center);\n\n            // Update camera\n\n            // Set new position\n            Cartesian3.clone(cameraPosition, camera.position);\n\n            // Set new direction\n            Cartesian3.normalize(\n              Cartesian3.subtract(center, cameraPosition, scratchCartesian),\n              camera.direction,\n            );\n            Cartesian3.clone(camera.direction, camera.direction);\n\n            // Set new right & up vectors\n            Cartesian3.cross(camera.direction, camera.up, camera.right);\n            Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n            camera.setView(scratchZoomViewOptions);\n            return;\n          }\n        } else {\n          const positionNormal = Cartesian3.normalize(\n            centerPosition,\n            scratchPositionNormal,\n          );\n          const pickedNormal = Cartesian3.normalize(\n            object._zoomWorldPosition,\n            scratchPickNormal,\n          );\n          const dotProduct = Cartesian3.dot(pickedNormal, positionNormal);\n\n          if (dotProduct > 0.0 && dotProduct < 1.0) {\n            const angle = CesiumMath.acosClamped(dotProduct);\n            const axis = Cartesian3.cross(\n              pickedNormal,\n              positionNormal,\n              scratchZoomAxis,\n            );\n\n            const denom =\n              Math.abs(angle) > CesiumMath.toRadians(20.0)\n                ? camera.positionCartographic.height * 0.75\n                : camera.positionCartographic.height - distance;\n            const scalar = distance / denom;\n            camera.rotate(axis, angle * scalar);\n          }\n        }\n      }\n    }\n\n    object._rotatingZoom = !zoomOnVector;\n  }\n\n  if ((!sameStartPosition && zoomOnVector) || zoomingOnVector) {\n    let ray;\n    const zoomMouseStart = SceneTransforms.worldToWindowCoordinates(\n      scene,\n      object._zoomWorldPosition,\n      scratchZoomOffset,\n    );\n    if (\n      mode !== SceneMode.COLUMBUS_VIEW &&\n      Cartesian2.equals(startPosition, object._zoomMouseStart) &&\n      defined(zoomMouseStart)\n    ) {\n      ray = camera.getPickRay(zoomMouseStart, scratchZoomPickRay);\n    } else {\n      ray = camera.getPickRay(startPosition, scratchZoomPickRay);\n    }\n\n    const rayDirection = ray.direction;\n    if (mode === SceneMode.COLUMBUS_VIEW || mode === SceneMode.SCENE2D) {\n      Cartesian3.fromElements(\n        rayDirection.y,\n        rayDirection.z,\n        rayDirection.x,\n        rayDirection,\n      );\n    }\n\n    camera.move(rayDirection, distance);\n\n    object._zoomingOnVector = true;\n  } else {\n    camera.zoomIn(distance);\n  }\n\n  if (!object._cameraUnderground) {\n    camera.setView(scratchZoomViewOptions);\n  }\n}\n\nconst translate2DStart = new Ray();\nconst translate2DEnd = new Ray();\nconst scratchTranslateP0 = new Cartesian3();\n\nfunction translate2D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  let start = camera.getPickRay(\n    movement.startPosition,\n    translate2DStart,\n  ).origin;\n  let end = camera.getPickRay(movement.endPosition, translate2DEnd).origin;\n\n  start = Cartesian3.fromElements(start.y, start.z, start.x, start);\n  end = Cartesian3.fromElements(end.y, end.z, end.x, end);\n\n  const direction = Cartesian3.subtract(start, end, scratchTranslateP0);\n  const distance = Cartesian3.magnitude(direction);\n\n  if (distance > 0.0) {\n    Cartesian3.normalize(direction, direction);\n    camera.move(direction, distance);\n  }\n}\n\nfunction zoom2D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller.zoomFactor,\n    camera.getMagnitude(),\n  );\n}\n\nconst twist2DStart = new Cartesian2();\nconst twist2DEnd = new Cartesian2();\n\nfunction twist2D(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    singleAxisTwist2D(controller, startPosition, movement.angleAndHeight);\n    return;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n\n  let start = twist2DStart;\n  start.x = (2.0 / width) * movement.startPosition.x - 1.0;\n  start.y = (2.0 / height) * (height - movement.startPosition.y) - 1.0;\n  start = Cartesian2.normalize(start, start);\n\n  let end = twist2DEnd;\n  end.x = (2.0 / width) * movement.endPosition.x - 1.0;\n  end.y = (2.0 / height) * (height - movement.endPosition.y) - 1.0;\n  end = Cartesian2.normalize(end, end);\n\n  let startTheta = CesiumMath.acosClamped(start.x);\n  if (start.y < 0) {\n    startTheta = CesiumMath.TWO_PI - startTheta;\n  }\n  let endTheta = CesiumMath.acosClamped(end.x);\n  if (end.y < 0) {\n    endTheta = CesiumMath.TWO_PI - endTheta;\n  }\n  const theta = endTheta - startTheta;\n\n  camera.twistRight(theta);\n}\n\nfunction singleAxisTwist2D(controller, startPosition, movement) {\n  let rotateRate =\n    controller._rotateFactor * controller._rotateRateRangeAdjustment;\n\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  let phiWindowRatio =\n    (movement.endPosition.x - movement.startPosition.x) / canvas.clientWidth;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n\n  const deltaPhi = rotateRate * phiWindowRatio * Math.PI * 4.0;\n\n  camera.twistRight(deltaPhi);\n}\n\nfunction update2D(controller) {\n  const rotatable2D = controller._scene.mapMode2D === MapMode2D.ROTATE;\n  if (!Matrix4.equals(Matrix4.IDENTITY, controller._scene.camera.transform)) {\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom2D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\",\n    );\n    if (rotatable2D) {\n      reactToInput(\n        controller,\n        controller.enableRotate,\n        controller.translateEventTypes,\n        twist2D,\n        controller.inertiaSpin,\n        \"_lastInertiaSpinMovement\",\n      );\n    }\n  } else {\n    reactToInput(\n      controller,\n      controller.enableTranslate,\n      controller.translateEventTypes,\n      translate2D,\n      controller.inertiaTranslate,\n      \"_lastInertiaTranslateMovement\",\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom2D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\",\n    );\n    if (rotatable2D) {\n      reactToInput(\n        controller,\n        controller.enableRotate,\n        controller.tiltEventTypes,\n        twist2D,\n        controller.inertiaSpin,\n        \"_lastInertiaTiltMovement\",\n      );\n    }\n  }\n}\n\nconst pickGlobeScratchRay = new Ray();\nconst scratchDepthIntersection = new Cartesian3();\nconst scratchRayIntersection = new Cartesian3();\n\nfunction pickPosition(controller, mousePosition, result) {\n  const scene = controller._scene;\n  const globe = controller._globe;\n  const camera = scene.camera;\n\n  let depthIntersection;\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(\n      mousePosition,\n      scratchDepthIntersection,\n    );\n  }\n\n  if (!defined(globe)) {\n    return Cartesian3.clone(depthIntersection, result);\n  }\n\n  const cullBackFaces = !controller._cameraUnderground;\n  const ray = camera.getPickRay(mousePosition, pickGlobeScratchRay);\n  const rayIntersection = globe.pickWorldCoordinates(\n    ray,\n    scene,\n    cullBackFaces,\n    scratchRayIntersection,\n  );\n\n  const pickDistance = defined(depthIntersection)\n    ? Cartesian3.distance(depthIntersection, camera.positionWC)\n    : Number.POSITIVE_INFINITY;\n  const rayDistance = defined(rayIntersection)\n    ? Cartesian3.distance(rayIntersection, camera.positionWC)\n    : Number.POSITIVE_INFINITY;\n\n  if (pickDistance < rayDistance) {\n    return Cartesian3.clone(depthIntersection, result);\n  }\n\n  return Cartesian3.clone(rayIntersection, result);\n}\n\nconst scratchDistanceCartographic = new Cartographic();\n\nfunction getDistanceFromSurface(controller) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const mode = scene.mode;\n\n  let height = 0.0;\n  if (mode === SceneMode.SCENE3D) {\n    const cartographic = ellipsoid.cartesianToCartographic(\n      camera.position,\n      scratchDistanceCartographic,\n    );\n    if (defined(cartographic)) {\n      height = cartographic.height;\n    }\n  } else {\n    height = camera.position.z;\n  }\n  const globeHeight = controller._scene.globeHeight ?? 0.0;\n  const distanceFromSurface = Math.abs(globeHeight - height);\n  return distanceFromSurface;\n}\n\nconst scratchSurfaceNormal = new Cartesian3();\n\nfunction getZoomDistanceUnderground(controller, ray) {\n  const origin = ray.origin;\n  const direction = ray.direction;\n  const distanceFromSurface = getDistanceFromSurface(controller);\n\n  // Weight zoom distance based on how strongly the pick ray is pointing inward.\n  // Geocentric normal is accurate enough for these purposes\n  const surfaceNormal = Cartesian3.normalize(origin, scratchSurfaceNormal);\n  let strength = Math.abs(Cartesian3.dot(surfaceNormal, direction));\n  strength = Math.max(strength, 0.5) * 2.0;\n  return distanceFromSurface * strength;\n}\n\nfunction getTiltCenterUnderground(controller, ray, pickedPosition, result) {\n  let distance = Cartesian3.distance(ray.origin, pickedPosition);\n  const distanceFromSurface = getDistanceFromSurface(controller);\n\n  const maximumDistance = CesiumMath.clamp(\n    distanceFromSurface * 5.0,\n    controller._minimumUndergroundPickDistance,\n    controller._maximumUndergroundPickDistance,\n  );\n\n  if (distance > maximumDistance) {\n    // Simulate look-at behavior by tilting around a small invisible sphere\n    distance = Math.min(distance, distanceFromSurface / 5.0);\n    distance = Math.max(distance, 100.0);\n  }\n\n  return Ray.getPoint(ray, distance, result);\n}\n\nfunction getStrafeStartPositionUnderground(\n  controller,\n  ray,\n  pickedPosition,\n  result,\n) {\n  let distance;\n  if (!defined(pickedPosition)) {\n    distance = getDistanceFromSurface(controller);\n  } else {\n    distance = Cartesian3.distance(ray.origin, pickedPosition);\n    if (distance > controller._maximumUndergroundPickDistance) {\n      // If the picked position is too far away set the strafe speed based on the\n      // camera's height from the globe surface\n      distance = getDistanceFromSurface(controller);\n    }\n  }\n\n  return Ray.getPoint(ray, distance, result);\n}\n\nconst scratchInertialDelta = new Cartesian2();\n\nfunction continueStrafing(controller, movement) {\n  // Update the end position continually based on the inertial delta\n  const originalEndPosition = movement.endPosition;\n  const inertialDelta = Cartesian2.subtract(\n    movement.endPosition,\n    movement.startPosition,\n    scratchInertialDelta,\n  );\n  const endPosition = controller._strafeEndMousePosition;\n  Cartesian2.add(endPosition, inertialDelta, endPosition);\n  movement.endPosition = endPosition;\n  strafe(controller, movement, controller._strafeStartPosition);\n  movement.endPosition = originalEndPosition;\n}\n\nconst translateCVStartRay = new Ray();\nconst translateCVEndRay = new Ray();\nconst translateCVStartPos = new Cartesian3();\nconst translateCVEndPos = new Cartesian3();\nconst translateCVDifference = new Cartesian3();\nconst translateCVOrigin = new Cartesian3();\nconst translateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst translateCVStartMouse = new Cartesian2();\nconst translateCVEndMouse = new Cartesian2();\n\nfunction translateCV(controller, startPosition, movement) {\n  if (!Cartesian3.equals(startPosition, controller._translateMousePosition)) {\n    controller._looking = false;\n  }\n\n  if (!Cartesian3.equals(startPosition, controller._strafeMousePosition)) {\n    controller._strafing = false;\n  }\n\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n\n  if (controller._strafing) {\n    continueStrafing(controller, movement);\n    return;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n  const startMouse = Cartesian2.clone(\n    movement.startPosition,\n    translateCVStartMouse,\n  );\n  const endMouse = Cartesian2.clone(movement.endPosition, translateCVEndMouse);\n  let startRay = camera.getPickRay(startMouse, translateCVStartRay);\n\n  const origin = Cartesian3.clone(Cartesian3.ZERO, translateCVOrigin);\n  const normal = Cartesian3.UNIT_X;\n\n  let globePos;\n  if (camera.position.z < controller._minimumPickingTerrainHeight) {\n    globePos = pickPosition(controller, startMouse, translateCVStartPos);\n\n    if (defined(globePos)) {\n      origin.x = globePos.x;\n    }\n  }\n\n  if (\n    cameraUnderground ||\n    (origin.x > camera.position.z && defined(globePos))\n  ) {\n    let pickPosition = globePos;\n    if (cameraUnderground) {\n      pickPosition = getStrafeStartPositionUnderground(\n        controller,\n        startRay,\n        globePos,\n        translateCVStartPos,\n      );\n    }\n    Cartesian2.clone(startPosition, controller._strafeMousePosition);\n    Cartesian2.clone(startPosition, controller._strafeEndMousePosition);\n    Cartesian3.clone(pickPosition, controller._strafeStartPosition);\n    controller._strafing = true;\n    strafe(controller, movement, controller._strafeStartPosition);\n    return;\n  }\n\n  const plane = Plane.fromPointNormal(origin, normal, translateCVPlane);\n\n  startRay = camera.getPickRay(startMouse, translateCVStartRay);\n  const startPlanePos = IntersectionTests.rayPlane(\n    startRay,\n    plane,\n    translateCVStartPos,\n  );\n\n  const endRay = camera.getPickRay(endMouse, translateCVEndRay);\n  const endPlanePos = IntersectionTests.rayPlane(\n    endRay,\n    plane,\n    translateCVEndPos,\n  );\n\n  if (!defined(startPlanePos) || !defined(endPlanePos)) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._translateMousePosition);\n    return;\n  }\n\n  const diff = Cartesian3.subtract(\n    startPlanePos,\n    endPlanePos,\n    translateCVDifference,\n  );\n  const temp = diff.x;\n  diff.x = diff.y;\n  diff.y = diff.z;\n  diff.z = temp;\n  const mag = Cartesian3.magnitude(diff);\n  if (mag > CesiumMath.EPSILON6) {\n    Cartesian3.normalize(diff, diff);\n    camera.move(diff, mag);\n  }\n}\n\nconst rotateCVWindowPos = new Cartesian2();\nconst rotateCVWindowRay = new Ray();\nconst rotateCVCenter = new Cartesian3();\nconst rotateCVVerticalCenter = new Cartesian3();\nconst rotateCVTransform = new Matrix4();\nconst rotateCVVerticalTransform = new Matrix4();\nconst rotateCVOrigin = new Cartesian3();\nconst rotateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst rotateCVCartesian3 = new Cartesian3();\nconst rotateCVCart = new Cartographic();\nconst rotateCVOldTransform = new Matrix4();\nconst rotateCVQuaternion = new Quaternion();\nconst rotateCVMatrix = new Matrix3();\nconst tilt3DCartesian3 = new Cartesian3();\n\nfunction rotateCV(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltCVOffMap = false;\n    controller._looking = false;\n  }\n\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  if (\n    controller._tiltCVOffMap ||\n    !controller.onMap() ||\n    Math.abs(camera.position.z) > controller._minimumPickingTerrainHeight\n  ) {\n    controller._tiltCVOffMap = true;\n    rotateCVOnPlane(controller, startPosition, movement);\n  } else {\n    rotateCVOnTerrain(controller, startPosition, movement);\n  }\n}\n\nfunction rotateCVOnPlane(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  const windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  const ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n  const normal = Cartesian3.UNIT_X;\n\n  const position = ray.origin;\n  const direction = ray.direction;\n  let scalar;\n  const normalDotDirection = Cartesian3.dot(normal, direction);\n  if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n    scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n  }\n\n  if (!defined(scalar) || scalar <= 0.0) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n\n  const center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n  Cartesian3.add(position, center, center);\n\n  const projection = scene.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  const cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    rotateCVTransform,\n  );\n\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  const oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n  camera._setTransform(transform);\n\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\n\nfunction rotateCVOnTerrain(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n\n  let center;\n  let ray;\n  const normal = Cartesian3.UNIT_X;\n\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, rotateCVCenter);\n  } else {\n    if (camera.position.z < controller._minimumPickingTerrainHeight) {\n      center = pickPosition(controller, startPosition, rotateCVCenter);\n    }\n\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      const position = ray.origin;\n      const direction = ray.direction;\n\n      let scalar;\n      const normalDotDirection = Cartesian3.dot(normal, direction);\n      if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n        scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n      }\n\n      if (!defined(scalar) || scalar <= 0.0) {\n        controller._looking = true;\n        look3D(controller, startPosition, movement);\n        Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        return;\n      }\n\n      center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n      Cartesian3.add(position, center, center);\n    }\n\n    if (cameraUnderground) {\n      if (!defined(ray)) {\n        ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      }\n      getTiltCenterUnderground(controller, ray, center, center);\n    }\n\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n\n  const canvas = scene.canvas;\n\n  const windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n\n  const origin = Cartesian3.clone(Cartesian3.ZERO, rotateCVOrigin);\n  origin.x = center.x;\n\n  const plane = Plane.fromPointNormal(origin, normal, rotateCVPlane);\n  const verticalCenter = IntersectionTests.rayPlane(\n    ray,\n    plane,\n    rotateCVVerticalCenter,\n  );\n\n  const projection = camera._projection;\n  const ellipsoid = projection.ellipsoid;\n\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  let cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    rotateCVTransform,\n  );\n\n  let verticalTransform;\n  if (defined(verticalCenter)) {\n    Cartesian3.fromElements(\n      verticalCenter.y,\n      verticalCenter.z,\n      verticalCenter.x,\n      verticalCenter,\n    );\n    cart = projection.unproject(verticalCenter, rotateCVCart);\n    ellipsoid.cartographicToCartesian(cart, verticalCenter);\n\n    verticalTransform = Transforms.eastNorthUpToFixedFrame(\n      verticalCenter,\n      ellipsoid,\n      rotateCVVerticalTransform,\n    );\n  } else {\n    verticalTransform = transform;\n  }\n\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  let constrainedAxis = Cartesian3.UNIT_Z;\n\n  const oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n  camera._setTransform(transform);\n\n  const tangent = Cartesian3.cross(\n    Cartesian3.UNIT_Z,\n    Cartesian3.normalize(camera.position, rotateCVCartesian3),\n    rotateCVCartesian3,\n  );\n  const dot = Cartesian3.dot(camera.right, tangent);\n\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n\n  camera._setTransform(verticalTransform);\n  if (dot < 0.0) {\n    const movementDelta = movement.startPosition.y - movement.endPosition.y;\n    if (\n      (cameraUnderground && movementDelta < 0.0) ||\n      (!cameraUnderground && movementDelta > 0.0)\n    ) {\n      // Prevent camera from flipping past the up axis\n      constrainedAxis = undefined;\n    }\n\n    const oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n\n  if (defined(camera.constrainedAxis)) {\n    const right = Cartesian3.cross(\n      camera.direction,\n      camera.constrainedAxis,\n      tilt3DCartesian3,\n    );\n    if (\n      !Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)\n    ) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n\n  const originalPosition = Cartesian3.clone(\n    camera.positionWC,\n    rotateCVCartesian3,\n  );\n\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller, true);\n  }\n\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n\n    const magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.sqrt(magSqrd),\n        camera.position,\n      );\n    }\n\n    const angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    const axis = Cartesian3.cross(\n      originalPosition,\n      camera.position,\n      originalPosition,\n    );\n    Cartesian3.normalize(axis, axis);\n\n    const quaternion = Quaternion.fromAxisAngle(\n      axis,\n      angle,\n      rotateCVQuaternion,\n    );\n    const rotation = Matrix3.fromQuaternion(quaternion, rotateCVMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n    camera._setTransform(oldTransform);\n  }\n}\n\nconst zoomCVWindowPos = new Cartesian2();\nconst zoomCVWindowRay = new Ray();\nconst zoomCVIntersection = new Cartesian3();\n\nfunction zoomCV(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  const cameraUnderground = controller._cameraUnderground;\n\n  let windowPosition;\n\n  if (cameraUnderground) {\n    windowPosition = startPosition;\n  } else {\n    windowPosition = zoomCVWindowPos;\n    windowPosition.x = canvas.clientWidth / 2;\n    windowPosition.y = canvas.clientHeight / 2;\n  }\n\n  const ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n  const position = ray.origin;\n  const direction = ray.direction;\n  const height = camera.position.z;\n\n  let intersection;\n  if (height < controller._minimumPickingTerrainHeight) {\n    intersection = pickPosition(controller, windowPosition, zoomCVIntersection);\n  }\n\n  let distance;\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(position, intersection);\n  }\n\n  if (cameraUnderground) {\n    const distanceUnderground = getZoomDistanceUnderground(\n      controller,\n      ray,\n      height,\n    );\n    if (defined(distance)) {\n      distance = Math.min(distance, distanceUnderground);\n    } else {\n      distance = distanceUnderground;\n    }\n  }\n\n  if (!defined(distance)) {\n    const normal = Cartesian3.UNIT_X;\n    distance =\n      -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  }\n\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller.zoomFactor,\n    distance,\n  );\n}\n\nfunction updateCV(controller) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {\n    reactToInput(\n      controller,\n      controller.enableRotate,\n      controller.rotateEventTypes,\n      rotate3D,\n      controller.inertiaSpin,\n      \"_lastInertiaSpinMovement\",\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom3D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\",\n    );\n  } else {\n    const tweens = controller._tweens;\n\n    if (controller._aggregator.anyButtonDown) {\n      tweens.removeAll();\n    }\n\n    reactToInput(\n      controller,\n      controller.enableTilt,\n      controller.tiltEventTypes,\n      rotateCV,\n      controller.inertiaSpin,\n      \"_lastInertiaTiltMovement\",\n    );\n    reactToInput(\n      controller,\n      controller.enableTranslate,\n      controller.translateEventTypes,\n      translateCV,\n      controller.inertiaTranslate,\n      \"_lastInertiaTranslateMovement\",\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoomCV,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\",\n    );\n    reactToInput(\n      controller,\n      controller.enableLook,\n      controller.lookEventTypes,\n      look3D,\n    );\n\n    if (\n      !controller._aggregator.anyButtonDown &&\n      !tweens.contains(controller._tween)\n    ) {\n      const tween = camera.createCorrectPositionTween(\n        controller.bounceAnimationTime,\n      );\n      if (defined(tween)) {\n        controller._tween = tweens.add(tween);\n      }\n    }\n\n    tweens.update();\n  }\n}\n\nconst scratchStrafeRay = new Ray();\nconst scratchStrafePlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst scratchStrafeIntersection = new Cartesian3();\nconst scratchStrafeDirection = new Cartesian3();\n\nfunction strafe(controller, movement, strafeStartPosition) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  const ray = camera.getPickRay(movement.endPosition, scratchStrafeRay);\n\n  let direction = Cartesian3.clone(camera.direction, scratchStrafeDirection);\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.z, direction.x, direction.y, direction);\n  }\n\n  const plane = Plane.fromPointNormal(\n    strafeStartPosition,\n    direction,\n    scratchStrafePlane,\n  );\n  const intersection = IntersectionTests.rayPlane(\n    ray,\n    plane,\n    scratchStrafeIntersection,\n  );\n  if (!defined(intersection)) {\n    return;\n  }\n\n  direction = Cartesian3.subtract(strafeStartPosition, intersection, direction);\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.y, direction.z, direction.x, direction);\n  }\n\n  Cartesian3.add(camera.position, direction, camera.position);\n}\n\nconst spin3DPick = new Cartesian3();\nconst scratchCartographic = new Cartographic();\nconst scratchRadii = new Cartesian3();\nconst scratchEllipsoid = new Ellipsoid();\nconst scratchLookUp = new Cartesian3();\nconst scratchNormal = new Cartesian3();\nconst scratchMousePosition = new Cartesian3();\n\nfunction spin3D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n  let ellipsoid = controller._ellipsoid;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n\n  let magnitude;\n  let radii;\n\n  const up = ellipsoid.geodeticSurfaceNormal(camera.position, scratchLookUp);\n\n  if (Cartesian2.equals(startPosition, controller._rotateMousePosition)) {\n    if (controller._looking) {\n      look3D(controller, startPosition, movement, up);\n    } else if (controller._rotating) {\n      rotate3D(controller, startPosition, movement);\n    } else if (controller._strafing) {\n      continueStrafing(controller, movement);\n    } else {\n      if (\n        Cartesian3.magnitude(camera.position) <\n        Cartesian3.magnitude(controller._rotateStartPosition)\n      ) {\n        // Pan action is no longer valid if camera moves below the pan ellipsoid\n        return;\n      }\n      magnitude = Cartesian3.magnitude(controller._rotateStartPosition);\n      radii = scratchRadii;\n      radii.x = radii.y = radii.z = magnitude;\n      ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n      pan3D(controller, startPosition, movement, ellipsoid);\n    }\n    return;\n  }\n  controller._looking = false;\n  controller._rotating = false;\n  controller._strafing = false;\n\n  const height = ellipsoid.cartesianToCartographic(\n    camera.positionWC,\n    scratchCartographic,\n  ).height;\n  const globe = controller._globe;\n\n  if (defined(globe) && height < controller._minimumPickingTerrainHeight) {\n    const mousePos = pickPosition(\n      controller,\n      movement.startPosition,\n      scratchMousePosition,\n    );\n    if (defined(mousePos)) {\n      let strafing = false;\n      const ray = camera.getPickRay(\n        movement.startPosition,\n        pickGlobeScratchRay,\n      );\n\n      if (cameraUnderground) {\n        strafing = true;\n        getStrafeStartPositionUnderground(controller, ray, mousePos, mousePos);\n      } else {\n        const normal = ellipsoid.geodeticSurfaceNormal(mousePos, scratchNormal);\n        const tangentPick =\n          Math.abs(Cartesian3.dot(ray.direction, normal)) < 0.05;\n\n        if (tangentPick) {\n          strafing = true;\n        } else {\n          strafing =\n            Cartesian3.magnitude(camera.position) <\n            Cartesian3.magnitude(mousePos);\n        }\n      }\n\n      if (strafing) {\n        Cartesian2.clone(startPosition, controller._strafeEndMousePosition);\n        Cartesian3.clone(mousePos, controller._strafeStartPosition);\n        controller._strafing = true;\n        strafe(controller, movement, controller._strafeStartPosition);\n      } else {\n        magnitude = Cartesian3.magnitude(mousePos);\n        radii = scratchRadii;\n        radii.x = radii.y = radii.z = magnitude;\n        ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n        pan3D(controller, startPosition, movement, ellipsoid);\n\n        Cartesian3.clone(mousePos, controller._rotateStartPosition);\n      }\n    } else {\n      controller._looking = true;\n      look3D(controller, startPosition, movement, up);\n    }\n  } else if (\n    defined(\n      camera.pickEllipsoid(\n        movement.startPosition,\n        controller._ellipsoid,\n        spin3DPick,\n      ),\n    )\n  ) {\n    pan3D(controller, startPosition, movement, controller._ellipsoid);\n    Cartesian3.clone(spin3DPick, controller._rotateStartPosition);\n  } else if (height > controller._minimumTrackBallHeight) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n  } else {\n    controller._looking = true;\n    look3D(controller, startPosition, movement, up);\n  }\n\n  Cartesian2.clone(startPosition, controller._rotateMousePosition);\n}\n\nfunction rotate3D(\n  controller,\n  startPosition,\n  movement,\n  constrainedAxis,\n  rotateOnlyVertical,\n  rotateOnlyHorizontal,\n) {\n  rotateOnlyVertical = rotateOnlyVertical ?? false;\n  rotateOnlyHorizontal = rotateOnlyHorizontal ?? false;\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  const oldAxis = camera.constrainedAxis;\n  if (defined(constrainedAxis)) {\n    camera.constrainedAxis = constrainedAxis;\n  }\n\n  const rho = Cartesian3.magnitude(camera.position);\n  let rotateRate =\n    controller._rotateFactor * (rho - controller._rotateRateRangeAdjustment);\n\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n\n  let phiWindowRatio =\n    (movement.startPosition.x - movement.endPosition.x) / canvas.clientWidth;\n  let thetaWindowRatio =\n    (movement.startPosition.y - movement.endPosition.y) / canvas.clientHeight;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n  thetaWindowRatio = Math.min(\n    thetaWindowRatio,\n    controller.maximumMovementRatio,\n  );\n\n  const deltaPhi = rotateRate * phiWindowRatio * Math.PI * 2.0;\n  let deltaTheta = rotateRate * thetaWindowRatio * Math.PI;\n\n  if (defined(constrainedAxis) && defined(controller.maximumTiltAngle)) {\n    const maximumTiltAngle = controller.maximumTiltAngle;\n    const dotProduct = Cartesian3.dot(camera.direction, constrainedAxis);\n    const tilt = Math.PI - Math.acos(dotProduct) + deltaTheta;\n    if (tilt > maximumTiltAngle) {\n      deltaTheta -= tilt - maximumTiltAngle;\n    }\n  }\n\n  if (!rotateOnlyVertical) {\n    camera.rotateRight(deltaPhi);\n  }\n\n  if (!rotateOnlyHorizontal) {\n    camera.rotateUp(deltaTheta);\n  }\n\n  camera.constrainedAxis = oldAxis;\n}\n\nconst pan3DP0 = Cartesian4.clone(Cartesian4.UNIT_W);\nconst pan3DP1 = Cartesian4.clone(Cartesian4.UNIT_W);\nconst pan3DTemp0 = new Cartesian3();\nconst pan3DTemp1 = new Cartesian3();\nconst pan3DTemp2 = new Cartesian3();\nconst pan3DTemp3 = new Cartesian3();\nconst pan3DStartMousePosition = new Cartesian2();\nconst pan3DEndMousePosition = new Cartesian2();\nconst pan3DDiffMousePosition = new Cartesian2();\nconst pan3DPixelDimensions = new Cartesian2();\nconst panRay = new Ray();\n\nfunction pan3D(controller, startPosition, movement, ellipsoid) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  const startMousePosition = Cartesian2.clone(\n    movement.startPosition,\n    pan3DStartMousePosition,\n  );\n  const endMousePosition = Cartesian2.clone(\n    movement.endPosition,\n    pan3DEndMousePosition,\n  );\n  const height = ellipsoid.cartesianToCartographic(\n    camera.positionWC,\n    scratchCartographic,\n  ).height;\n\n  let p0, p1;\n\n  if (\n    !movement.inertiaEnabled &&\n    height < controller._minimumPickingTerrainHeight\n  ) {\n    p0 = Cartesian3.clone(controller._panLastWorldPosition, pan3DP0);\n\n    // Use the last picked world position unless we're starting a new drag\n    if (\n      !defined(controller._globe) &&\n      !Cartesian2.equalsEpsilon(\n        startMousePosition,\n        controller._panLastMousePosition,\n      )\n    ) {\n      p0 = pickPosition(controller, startMousePosition, pan3DP0);\n    }\n\n    if (!defined(controller._globe) && defined(p0)) {\n      const toCenter = Cartesian3.subtract(p0, camera.positionWC, pan3DTemp1);\n      const toCenterProj = Cartesian3.multiplyByScalar(\n        camera.directionWC,\n        Cartesian3.dot(camera.directionWC, toCenter),\n        pan3DTemp1,\n      );\n      const distanceToNearPlane = Cartesian3.magnitude(toCenterProj);\n      const pixelDimensions = camera.frustum.getPixelDimensions(\n        scene.drawingBufferWidth,\n        scene.drawingBufferHeight,\n        distanceToNearPlane,\n        scene.pixelRatio,\n        pan3DPixelDimensions,\n      );\n\n      const dragDelta = Cartesian2.subtract(\n        endMousePosition,\n        startMousePosition,\n        pan3DDiffMousePosition,\n      );\n\n      // Move the camera to the the distance the cursor moved in worldspace\n      const right = Cartesian3.multiplyByScalar(\n        camera.rightWC,\n        dragDelta.x * pixelDimensions.x,\n        pan3DTemp1,\n      );\n\n      // Move the camera towards the picked position in worldspace as the camera is pointed towards a horizon view\n      const cameraPositionNormal = Cartesian3.normalize(\n        camera.positionWC,\n        scratchCameraPositionNormal,\n      );\n      const endPickDirection = camera.getPickRay(\n        endMousePosition,\n        panRay,\n      ).direction;\n      const endPickProj = Cartesian3.subtract(\n        endPickDirection,\n        Cartesian3.projectVector(endPickDirection, camera.rightWC, pan3DTemp2),\n        pan3DTemp2,\n      );\n      const angle = Cartesian3.angleBetween(endPickProj, camera.directionWC);\n      let forward = 1.0;\n      if (defined(camera.frustum.fov)) {\n        forward = Math.max(Math.tan(angle), 0.1); // Clamp so we don't make the magnitude infinitely large when the angle is small\n      }\n      let dot = Math.abs(\n        Cartesian3.dot(camera.directionWC, cameraPositionNormal),\n      );\n      const magnitude =\n        ((-dragDelta.y * pixelDimensions.y * 2.0) / Math.sqrt(forward)) *\n        (1.0 - dot);\n      const direction = Cartesian3.multiplyByScalar(\n        endPickDirection,\n        magnitude,\n        pan3DTemp2,\n      );\n\n      // Move the camera up the distance the cursor moved in worldspace as the camera is pointed towards the center\n      dot = Math.abs(Cartesian3.dot(camera.upWC, cameraPositionNormal));\n      const up = Cartesian3.multiplyByScalar(\n        camera.upWC,\n        -dragDelta.y * (1.0 - dot) * pixelDimensions.y,\n        pan3DTemp3,\n      );\n\n      p1 = Cartesian3.add(p0, right, pan3DP1);\n      p1 = Cartesian3.add(p1, direction, p1);\n      p1 = Cartesian3.add(p1, up, p1);\n\n      Cartesian3.clone(p1, controller._panLastWorldPosition);\n      Cartesian2.clone(endMousePosition, controller._panLastMousePosition);\n    }\n  }\n\n  if (!defined(p0) || !defined(p1)) {\n    p0 = camera.pickEllipsoid(startMousePosition, ellipsoid, pan3DP0);\n    p1 = camera.pickEllipsoid(endMousePosition, ellipsoid, pan3DP1);\n  }\n\n  if (!defined(p0) || !defined(p1)) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n\n  p0 = camera.worldToCameraCoordinates(p0, p0);\n  p1 = camera.worldToCameraCoordinates(p1, p1);\n\n  if (!defined(camera.constrainedAxis)) {\n    Cartesian3.normalize(p0, p0);\n    Cartesian3.normalize(p1, p1);\n    const dot = Cartesian3.dot(p0, p1);\n    const axis = Cartesian3.cross(p0, p1, pan3DTemp0);\n\n    if (\n      dot < 1.0 &&\n      !Cartesian3.equalsEpsilon(axis, Cartesian3.ZERO, CesiumMath.EPSILON14)\n    ) {\n      // dot is in [0, 1]\n      const angle = Math.acos(dot);\n      camera.rotate(axis, angle);\n    }\n  } else {\n    const basis0 = camera.constrainedAxis;\n    const basis1 = Cartesian3.mostOrthogonalAxis(basis0, pan3DTemp0);\n    Cartesian3.cross(basis1, basis0, basis1);\n    Cartesian3.normalize(basis1, basis1);\n    const basis2 = Cartesian3.cross(basis0, basis1, pan3DTemp1);\n\n    const startRho = Cartesian3.magnitude(p0);\n    const startDot = Cartesian3.dot(basis0, p0);\n    const startTheta = Math.acos(startDot / startRho);\n    const startRej = Cartesian3.multiplyByScalar(basis0, startDot, pan3DTemp2);\n    Cartesian3.subtract(p0, startRej, startRej);\n    Cartesian3.normalize(startRej, startRej);\n\n    const endRho = Cartesian3.magnitude(p1);\n    const endDot = Cartesian3.dot(basis0, p1);\n    const endTheta = Math.acos(endDot / endRho);\n    const endRej = Cartesian3.multiplyByScalar(basis0, endDot, pan3DTemp3);\n    Cartesian3.subtract(p1, endRej, endRej);\n    Cartesian3.normalize(endRej, endRej);\n\n    let startPhi = Math.acos(Cartesian3.dot(startRej, basis1));\n    if (Cartesian3.dot(startRej, basis2) < 0) {\n      startPhi = CesiumMath.TWO_PI - startPhi;\n    }\n\n    let endPhi = Math.acos(Cartesian3.dot(endRej, basis1));\n    if (Cartesian3.dot(endRej, basis2) < 0) {\n      endPhi = CesiumMath.TWO_PI - endPhi;\n    }\n\n    const deltaPhi = startPhi - endPhi;\n\n    let east;\n    if (\n      Cartesian3.equalsEpsilon(basis0, camera.position, CesiumMath.EPSILON2)\n    ) {\n      east = camera.right;\n    } else {\n      east = Cartesian3.cross(basis0, camera.position, pan3DTemp0);\n    }\n\n    const planeNormal = Cartesian3.cross(basis0, east, pan3DTemp0);\n    const side0 = Cartesian3.dot(\n      planeNormal,\n      Cartesian3.subtract(p0, basis0, pan3DTemp1),\n    );\n    const side1 = Cartesian3.dot(\n      planeNormal,\n      Cartesian3.subtract(p1, basis0, pan3DTemp1),\n    );\n\n    let deltaTheta;\n    if (side0 > 0 && side1 > 0) {\n      deltaTheta = endTheta - startTheta;\n    } else if (side0 > 0 && side1 <= 0) {\n      if (Cartesian3.dot(camera.position, basis0) > 0) {\n        deltaTheta = -startTheta - endTheta;\n      } else {\n        deltaTheta = startTheta + endTheta;\n      }\n    } else {\n      deltaTheta = startTheta - endTheta;\n    }\n\n    camera.rotateRight(deltaPhi);\n    camera.rotateUp(deltaTheta);\n  }\n}\n\nconst zoom3DUnitPosition = new Cartesian3();\nconst zoom3DCartographic = new Cartographic();\n\nlet preIntersectionDistance = 0;\n\nfunction zoom3D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n  const inertiaMovement = movement.inertiaEnabled;\n\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  const cameraUnderground = controller._cameraUnderground;\n\n  let windowPosition;\n\n  if (cameraUnderground) {\n    windowPosition = startPosition;\n  } else {\n    windowPosition = zoomCVWindowPos;\n    windowPosition.x = canvas.clientWidth / 2;\n    windowPosition.y = canvas.clientHeight / 2;\n  }\n\n  const ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n\n  let intersection;\n  const height = ellipsoid.cartesianToCartographic(\n    camera.position,\n    zoom3DCartographic,\n  ).height;\n\n  const approachingCollision =\n    Math.abs(preIntersectionDistance) <\n    controller.minimumPickingTerrainDistanceWithInertia;\n\n  const needPickGlobe = inertiaMovement\n    ? approachingCollision\n    : height < controller._minimumPickingTerrainHeight;\n  if (needPickGlobe) {\n    intersection = pickPosition(controller, windowPosition, zoomCVIntersection);\n  }\n\n  let distance;\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(ray.origin, intersection);\n    preIntersectionDistance = distance;\n  }\n\n  if (cameraUnderground) {\n    const distanceUnderground = getZoomDistanceUnderground(\n      controller,\n      ray,\n      height,\n    );\n    if (defined(distance)) {\n      distance = Math.min(distance, distanceUnderground);\n    } else {\n      distance = distanceUnderground;\n    }\n  }\n\n  if (!defined(distance)) {\n    distance = height;\n  }\n\n  const unitPosition = Cartesian3.normalize(\n    camera.position,\n    zoom3DUnitPosition,\n  );\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller.zoomFactor,\n    distance,\n    Cartesian3.dot(unitPosition, camera.direction),\n  );\n}\n\nconst tilt3DWindowPos = new Cartesian2();\nconst tilt3DRay = new Ray();\nconst tilt3DCenter = new Cartesian3();\nconst tilt3DVerticalCenter = new Cartesian3();\nconst tilt3DTransform = new Matrix4();\nconst tilt3DVerticalTransform = new Matrix4();\nconst tilt3DOldTransform = new Matrix4();\nconst tilt3DQuaternion = new Quaternion();\nconst tilt3DMatrix = new Matrix3();\nconst tilt3DCart = new Cartographic();\nconst tilt3DLookUp = new Cartesian3();\n\nfunction tilt3D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    return;\n  }\n\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltOnEllipsoid = false;\n    controller._looking = false;\n  }\n\n  if (controller._looking) {\n    const up = controller._ellipsoid.geodeticSurfaceNormal(\n      camera.position,\n      tilt3DLookUp,\n    );\n    look3D(controller, startPosition, movement, up);\n    return;\n  }\n\n  const ellipsoid = controller._ellipsoid;\n  const cartographic = ellipsoid.cartesianToCartographic(\n    camera.position,\n    tilt3DCart,\n  );\n\n  if (\n    controller._tiltOnEllipsoid ||\n    cartographic.height > controller._minimumCollisionTerrainHeight\n  ) {\n    controller._tiltOnEllipsoid = true;\n    tilt3DOnEllipsoid(controller, startPosition, movement);\n  } else {\n    tilt3DOnTerrain(controller, startPosition, movement);\n  }\n}\n\nconst tilt3DOnEllipsoidCartographic = new Cartographic();\n\nfunction tilt3DOnEllipsoid(controller, startPosition, movement) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const minHeight = controller.minimumZoomDistance * 0.25;\n  const height = ellipsoid.cartesianToCartographic(\n    camera.positionWC,\n    tilt3DOnEllipsoidCartographic,\n  ).height;\n  if (\n    height - minHeight - 1.0 < CesiumMath.EPSILON3 &&\n    movement.endPosition.y - movement.startPosition.y < 0\n  ) {\n    return;\n  }\n\n  const canvas = scene.canvas;\n\n  const windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  const ray = camera.getPickRay(windowPosition, tilt3DRay);\n\n  let center;\n  const intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n  if (defined(intersection)) {\n    center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n  } else if (height > controller._minimumTrackBallHeight) {\n    const grazingAltitudeLocation = IntersectionTests.grazingAltitudeLocation(\n      ray,\n      ellipsoid,\n    );\n    if (!defined(grazingAltitudeLocation)) {\n      return;\n    }\n    const grazingAltitudeCart = ellipsoid.cartesianToCartographic(\n      grazingAltitudeLocation,\n      tilt3DCart,\n    );\n    grazingAltitudeCart.height = 0.0;\n    center = ellipsoid.cartographicToCartesian(\n      grazingAltitudeCart,\n      tilt3DCenter,\n    );\n  } else {\n    controller._looking = true;\n    const up = controller._ellipsoid.geodeticSurfaceNormal(\n      camera.position,\n      tilt3DLookUp,\n    );\n    look3D(controller, startPosition, movement, up);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    tilt3DTransform,\n  );\n\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  const oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n  camera._setTransform(transform);\n\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\n\nfunction tilt3DOnTerrain(controller, startPosition, movement) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n\n  let center;\n  let ray;\n  let intersection;\n\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, tilt3DCenter);\n  } else {\n    center = pickPosition(controller, startPosition, tilt3DCenter);\n\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, tilt3DRay);\n      intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n      if (!defined(intersection)) {\n        const cartographic = ellipsoid.cartesianToCartographic(\n          camera.position,\n          tilt3DCart,\n        );\n        if (cartographic.height <= controller._minimumTrackBallHeight) {\n          controller._looking = true;\n          const up = controller._ellipsoid.geodeticSurfaceNormal(\n            camera.position,\n            tilt3DLookUp,\n          );\n          look3D(controller, startPosition, movement, up);\n          Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        }\n        return;\n      }\n      center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n    }\n\n    if (cameraUnderground) {\n      if (!defined(ray)) {\n        ray = camera.getPickRay(startPosition, tilt3DRay);\n      }\n      getTiltCenterUnderground(controller, ray, center, center);\n    }\n\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n\n  const canvas = scene.canvas;\n\n  const windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, tilt3DRay);\n\n  const mag = Cartesian3.magnitude(center);\n  const radii = Cartesian3.fromElements(mag, mag, mag, scratchRadii);\n  const newEllipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n\n  intersection = IntersectionTests.rayEllipsoid(ray, newEllipsoid);\n  if (!defined(intersection)) {\n    return;\n  }\n\n  const t =\n    Cartesian3.magnitude(ray.origin) > mag\n      ? intersection.start\n      : intersection.stop;\n  const verticalCenter = Ray.getPoint(ray, t, tilt3DVerticalCenter);\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    tilt3DTransform,\n  );\n  const verticalTransform = Transforms.eastNorthUpToFixedFrame(\n    verticalCenter,\n    newEllipsoid,\n    tilt3DVerticalTransform,\n  );\n\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  let constrainedAxis = Cartesian3.UNIT_Z;\n\n  const oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n  camera._setTransform(verticalTransform);\n\n  const tangent = Cartesian3.cross(\n    verticalCenter,\n    camera.positionWC,\n    tilt3DCartesian3,\n  );\n  const dot = Cartesian3.dot(camera.rightWC, tangent);\n\n  if (dot < 0.0) {\n    const movementDelta = movement.startPosition.y - movement.endPosition.y;\n    if (\n      (cameraUnderground && movementDelta < 0.0) ||\n      (!cameraUnderground && movementDelta > 0.0)\n    ) {\n      // Prevent camera from flipping past the up axis\n      constrainedAxis = undefined;\n    }\n\n    const oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n\n  camera._setTransform(transform);\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n\n  if (defined(camera.constrainedAxis)) {\n    const right = Cartesian3.cross(\n      camera.direction,\n      camera.constrainedAxis,\n      tilt3DCartesian3,\n    );\n    if (\n      !Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)\n    ) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n\n  const originalPosition = Cartesian3.clone(\n    camera.positionWC,\n    tilt3DCartesian3,\n  );\n\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller, true);\n  }\n\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n\n    const magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.sqrt(magSqrd),\n        camera.position,\n      );\n    }\n\n    const angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    const axis = Cartesian3.cross(\n      originalPosition,\n      camera.position,\n      originalPosition,\n    );\n    Cartesian3.normalize(axis, axis);\n\n    const quaternion = Quaternion.fromAxisAngle(axis, angle, tilt3DQuaternion);\n    const rotation = Matrix3.fromQuaternion(quaternion, tilt3DMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n    camera._setTransform(oldTransform);\n  }\n}\n\nconst look3DStartPos = new Cartesian2();\nconst look3DEndPos = new Cartesian2();\nconst look3DStartRay = new Ray();\nconst look3DEndRay = new Ray();\nconst look3DNegativeRot = new Cartesian3();\nconst look3DTan = new Cartesian3();\n\nfunction look3D(controller, startPosition, movement, rotationAxis) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  const startPos = look3DStartPos;\n  startPos.x = movement.startPosition.x;\n  startPos.y = 0.0;\n  const endPos = look3DEndPos;\n  endPos.x = movement.endPosition.x;\n  endPos.y = 0.0;\n\n  let startRay = camera.getPickRay(startPos, look3DStartRay);\n  let endRay = camera.getPickRay(endPos, look3DEndRay);\n  let angle = 0.0;\n  let start;\n  let end;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n\n  let dot = Cartesian3.dot(start, end);\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n\n  angle = movement.startPosition.x > movement.endPosition.x ? -angle : angle;\n\n  const horizontalRotationAxis = controller._horizontalRotationAxis;\n  if (defined(rotationAxis)) {\n    camera.look(rotationAxis, -angle);\n  } else if (defined(horizontalRotationAxis)) {\n    camera.look(horizontalRotationAxis, -angle);\n  } else {\n    camera.lookLeft(angle);\n  }\n\n  startPos.x = 0.0;\n  startPos.y = movement.startPosition.y;\n  endPos.x = 0.0;\n  endPos.y = movement.endPosition.y;\n\n  startRay = camera.getPickRay(startPos, look3DStartRay);\n  endRay = camera.getPickRay(endPos, look3DEndRay);\n  angle = 0.0;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n\n  dot = Cartesian3.dot(start, end);\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n  angle = movement.startPosition.y > movement.endPosition.y ? -angle : angle;\n\n  rotationAxis = rotationAxis ?? horizontalRotationAxis;\n  if (defined(rotationAxis)) {\n    const direction = camera.direction;\n    const negativeRotationAxis = Cartesian3.negate(\n      rotationAxis,\n      look3DNegativeRot,\n    );\n    const northParallel = Cartesian3.equalsEpsilon(\n      direction,\n      rotationAxis,\n      CesiumMath.EPSILON2,\n    );\n    const southParallel = Cartesian3.equalsEpsilon(\n      direction,\n      negativeRotationAxis,\n      CesiumMath.EPSILON2,\n    );\n    if (!northParallel && !southParallel) {\n      dot = Cartesian3.dot(direction, rotationAxis);\n      let angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n\n      dot = Cartesian3.dot(direction, negativeRotationAxis);\n      angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n\n      const tangent = Cartesian3.cross(rotationAxis, direction, look3DTan);\n      camera.look(tangent, angle);\n    } else if ((northParallel && angle < 0) || (southParallel && angle > 0)) {\n      camera.look(camera.right, -angle);\n    }\n  } else {\n    camera.lookUp(angle);\n  }\n}\n\nfunction update3D(controller) {\n  reactToInput(\n    controller,\n    controller.enableRotate,\n    controller.rotateEventTypes,\n    spin3D,\n    controller.inertiaSpin,\n    \"_lastInertiaSpinMovement\",\n  );\n  reactToInput(\n    controller,\n    controller.enableZoom,\n    controller.zoomEventTypes,\n    zoom3D,\n    controller.inertiaZoom,\n    \"_lastInertiaZoomMovement\",\n  );\n  reactToInput(\n    controller,\n    controller.enableTilt,\n    controller.tiltEventTypes,\n    tilt3D,\n    controller.inertiaSpin,\n    \"_lastInertiaTiltMovement\",\n  );\n  reactToInput(\n    controller,\n    controller.enableLook,\n    controller.lookEventTypes,\n    look3D,\n  );\n}\n\nconst scratchAdjustHeightTransform = new Matrix4();\nconst scratchAdjustHeightCartographic = new Cartographic();\n\nfunction adjustHeightForTerrain(controller, cameraChanged) {\n  controller._adjustedHeightForTerrain = true;\n\n  const scene = controller._scene;\n  const mode = scene.mode;\n\n  if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  const camera = scene.camera;\n  const ellipsoid = scene.ellipsoid ?? Ellipsoid.WGS84;\n  const projection = scene.mapProjection;\n\n  let transform;\n  let mag;\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    transform = Matrix4.clone(camera.transform, scratchAdjustHeightTransform);\n    mag = Cartesian3.magnitude(camera.position);\n    camera._setTransform(Matrix4.IDENTITY);\n  }\n\n  const cartographic = scratchAdjustHeightCartographic;\n  if (mode === SceneMode.SCENE3D) {\n    ellipsoid.cartesianToCartographic(camera.position, cartographic);\n  } else {\n    projection.unproject(camera.position, cartographic);\n  }\n\n  let heightUpdated = false;\n  if (cartographic.height < controller._minimumCollisionTerrainHeight) {\n    const globeHeight = controller._scene.globeHeight;\n    if (defined(globeHeight)) {\n      const height = globeHeight + controller.minimumZoomDistance;\n      const difference = globeHeight - controller._lastGlobeHeight;\n      const percentDifference = difference / controller._lastGlobeHeight;\n\n      // Unless the camera has been moved by user input, to avoid big jumps during tile loads\n      // only make height updates when the globe height has been fairly stable across several frames\n      if (\n        cartographic.height < height &&\n        (cameraChanged || Math.abs(percentDifference) <= 0.1)\n      ) {\n        cartographic.height = height;\n        if (mode === SceneMode.SCENE3D) {\n          ellipsoid.cartographicToCartesian(cartographic, camera.position);\n        } else {\n          projection.project(cartographic, camera.position);\n        }\n        heightUpdated = true;\n      }\n\n      if (cameraChanged || Math.abs(percentDifference) <= 0.1) {\n        controller._lastGlobeHeight = globeHeight;\n      } else {\n        controller._lastGlobeHeight += difference * 0.1;\n      }\n    }\n  }\n\n  if (defined(transform)) {\n    camera._setTransform(transform);\n    if (heightUpdated) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.negate(camera.position, camera.direction);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.max(mag, controller.minimumZoomDistance),\n        camera.position,\n      );\n      Cartesian3.normalize(camera.direction, camera.direction);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.cross(camera.right, camera.direction, camera.up);\n    }\n  }\n}\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.onMap = function () {\n  const scene = this._scene;\n  const mode = scene.mode;\n  const camera = scene.camera;\n\n  if (mode === SceneMode.COLUMBUS_VIEW) {\n    return (\n      Math.abs(camera.position.x) - this._maxCoord.x < 0 &&\n      Math.abs(camera.position.y) - this._maxCoord.y < 0\n    );\n  }\n\n  return true;\n};\n\nconst scratchPreviousPosition = new Cartesian3();\nconst scratchPreviousDirection = new Cartesian3();\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.update = function () {\n  const scene = this._scene;\n  const { camera, globe, mode } = scene;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    this._globe = undefined;\n    this._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  } else {\n    this._globe = globe;\n    this._ellipsoid = scene.ellipsoid ?? Ellipsoid.default;\n  }\n\n  const { verticalExaggeration, verticalExaggerationRelativeHeight } = scene;\n  this._minimumCollisionTerrainHeight = VerticalExaggeration.getHeight(\n    this.minimumCollisionTerrainHeight,\n    verticalExaggeration,\n    verticalExaggerationRelativeHeight,\n  );\n  this._minimumPickingTerrainHeight = VerticalExaggeration.getHeight(\n    this.minimumPickingTerrainHeight,\n    verticalExaggeration,\n    verticalExaggerationRelativeHeight,\n  );\n  this._minimumTrackBallHeight = VerticalExaggeration.getHeight(\n    this.minimumTrackBallHeight,\n    verticalExaggeration,\n    verticalExaggerationRelativeHeight,\n  );\n\n  this._cameraUnderground = scene.cameraUnderground && defined(this._globe);\n\n  const radius = this._ellipsoid.maximumRadius;\n  this._rotateFactor = 1.0 / radius;\n  this._rotateRateRangeAdjustment = radius;\n\n  this._adjustedHeightForTerrain = false;\n  const previousPosition = Cartesian3.clone(\n    camera.positionWC,\n    scratchPreviousPosition,\n  );\n  const previousDirection = Cartesian3.clone(\n    camera.directionWC,\n    scratchPreviousDirection,\n  );\n\n  if (mode === SceneMode.SCENE2D) {\n    update2D(this);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    this._horizontalRotationAxis = Cartesian3.UNIT_Z;\n    updateCV(this);\n  } else if (mode === SceneMode.SCENE3D) {\n    this._horizontalRotationAxis = undefined;\n    update3D(this);\n  }\n\n  if (this.enableCollisionDetection && !this._adjustedHeightForTerrain) {\n    // Adjust the camera height if the camera moved at all (user input or inertia) and an action didn't already adjust the camera height\n    const cameraChanged =\n      !Cartesian3.equals(previousPosition, camera.positionWC) ||\n      !Cartesian3.equals(previousDirection, camera.directionWC);\n    adjustHeightForTerrain(this, cameraChanged);\n  }\n\n  this._aggregator.reset();\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ScreenSpaceCameraController#destroy\n */\nScreenSpaceCameraController.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes mouse listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * controller = controller && controller.destroy();\n *\n * @see ScreenSpaceCameraController#isDestroyed\n */\nScreenSpaceCameraController.prototype.destroy = function () {\n  this._tweens.removeAll();\n  this._aggregator = this._aggregator && this._aggregator.destroy();\n  return destroyObject(this);\n};\nexport default ScreenSpaceCameraController;\n"],"names":["ScreenSpaceCameraController","scene","enableInputs","enableTranslate","enableZoom","enableRotate","enableTilt","enableLook","inertiaSpin","inertiaTranslate","inertiaZoom","maximumMovementRatio","bounceAnimationTime","minimumZoomDistance","maximumZoomDistance","Number","POSITIVE_INFINITY","zoomFactor","translateEventTypes","LEFT_DRAG","zoomEventTypes","RIGHT_DRAG","WHEEL","PINCH","rotateEventTypes","tiltEventTypes","MIDDLE_DRAG","eventType","modifier","CTRL","lookEventTypes","SHIFT","ellipsoid","default","minimumPickingTerrainHeight","WGS84","equals","minimumRadius","_minimumPickingTerrainHeight","minimumPickingTerrainDistanceWithInertia","minimumCollisionTerrainHeight","_minimumCollisionTerrainHeight","minimumTrackBallHeight","_minimumTrackBallHeight","enableCollisionDetection","maximumTiltAngle","undefined","_scene","_globe","_ellipsoid","_lastGlobeHeight","_aggregator","canvas","_lastInertiaSpinMovement","_lastInertiaZoomMovement","_lastInertiaTranslateMovement","_lastInertiaTiltMovement","_inertiaDisablers","_tweens","_tween","_horizontalRotationAxis","_tiltCenterMousePosition","_tiltCenter","_rotateMousePosition","_rotateStartPosition","_strafeStartPosition","_strafeMousePosition","_strafeEndMousePosition","_zoomMouseStart","_zoomWorldPosition","_useZoomWorldPosition","_panLastMousePosition","_panLastWorldPosition","_tiltCVOffMap","_looking","_rotating","_strafing","_zoomingOnVector","_zoomingUnderground","_rotatingZoom","_adjustedHeightForTerrain","_cameraUnderground","projection","mapProjection","_maxCoord","project","Math","PI","PI_OVER_TWO","_rotateFactor","_rotateRateRangeAdjustment","_maximumRotateRate","_minimumRotateRate","_minimumZoomRate","_maximumZoomRate","_minimumUndergroundPickDistance","_maximumUndergroundPickDistance","decay","time","coefficient","tau","exp","sameMousePosition","movement","equalsEpsilon","startPosition","endPosition","EPSILON14","inertiaMaxClickTimeThreshold","maintainInertia","aggregator","type","decayCoef","action","object","lastMovementName","movementState","motion","inertiaEnabled","ts","getButtonPressTime","tr","getButtonReleaseTime","threshold","getTime","now","Date","fromNow","d","lastMovement","getLastMovement","x","y","clone","multiplyByScalar","add","isNaN","distance","isButtonDown","getStartMousePosition","activateInertia","controller","inertiaStateName","inertiasToDisable","length","i","scratchEventTypeArray","reactToInput","enabled","eventTypes","inertiaConstant","Array","isArray","isMoving","getMovement","scratchZoomPickRay","scratchPickCartesian","scratchZoomOffset","scratchZoomDirection","scratchCenterPixel","scratchCenterPosition","scratchPositionNormal","scratchPickNormal","scratchZoomAxis","scratchCameraPositionNormal","scratchTargetNormal","scratchCameraPosition","scratchCameraUpNormal","scratchCameraRightNormal","scratchForwardNormal","scratchPositionToTarget","scratchPositionToTargetNormal","scratchPan","scratchCenterMovement","scratchCenter","scratchCartesian","scratchCartesianTwo","scratchCartesianThree","scratchZoomViewOptions","orientation","handleZoom","distanceMeasure","unitPositionDotDirection","percentage","clamp","abs","diff","approachingSurface","minHeight","maxHeight","minDistance","zoomRate","rangeWindowRatio","clientHeight","min","camera","mode","heading","pitch","roll","sameStartPosition","zoomingOnVector","rotatingZoom","pickedPosition","SCENE2D","getPickRay","origin","fromElements","z","pickPosition","zoomIn","zoomOnVector","COLUMBUS_VIEW","positionCartographic","height","worldPosition","position","savedX","direction","subtract","normalize","getMagnitude","move","SCENE3D","cameraPositionNormal","dot","centerPixel","clientWidth","centerPosition","cameraPosition","target","targetNormal","center","forward","positionToTarget","positionToTargetNormal","alphaDot","alpha","acos","cameraDistance","magnitude","targetDistance","remainingDistance","positionToTargetDistance","gamma","asin","sin","delta","beta","up","right","cross","pMid","cos","cMid","setView","positionNormal","pickedNormal","dotProduct","angle","acosClamped","axis","denom","toRadians","scalar","rotate","ray","zoomMouseStart","worldToWindowCoordinates","rayDirection","translate2DStart","translate2DEnd","scratchTranslateP0","translate2D","start","end","zoom2D","twist2DStart","twist2DEnd","twist2D","angleAndHeight","singleAxisTwist2D","width","startTheta","TWO_PI","endTheta","theta","twistRight","rotateRate","phiWindowRatio","deltaPhi","update2D","rotatable2D","mapMode2D","ROTATE","IDENTITY","transform","pickGlobeScratchRay","scratchDepthIntersection","scratchRayIntersection","mousePosition","result","globe","depthIntersection","pickPositionSupported","pickPositionWorldCoordinates","cullBackFaces","rayIntersection","pickWorldCoordinates","pickDistance","positionWC","rayDistance","scratchDistanceCartographic","getDistanceFromSurface","cartographic","cartesianToCartographic","globeHeight","distanceFromSurface","scratchSurfaceNormal","getZoomDistanceUnderground","surfaceNormal","strength","max","getTiltCenterUnderground","maximumDistance","getPoint","getStrafeStartPositionUnderground","scratchInertialDelta","continueStrafing","originalEndPosition","inertialDelta","strafe","translateCVStartRay","translateCVEndRay","translateCVStartPos","translateCVEndPos","translateCVDifference","translateCVOrigin","translateCVPlane","UNIT_X","translateCVStartMouse","translateCVEndMouse","translateCV","_translateMousePosition","look3D","cameraUnderground","startMouse","endMouse","startRay","ZERO","normal","globePos","plane","fromPointNormal","startPlanePos","rayPlane","endRay","endPlanePos","temp","mag","EPSILON6","rotateCVWindowPos","rotateCVWindowRay","rotateCVCenter","rotateCVVerticalCenter","rotateCVTransform","rotateCVVerticalTransform","rotateCVOrigin","rotateCVPlane","rotateCVCartesian3","rotateCVCart","rotateCVOldTransform","rotateCVQuaternion","rotateCVMatrix","tilt3DCartesian3","rotateCV","onMap","rotateCVOnPlane","rotateCVOnTerrain","windowPosition","normalDotDirection","cart","unproject","cartographicToCartesian","eastNorthUpToFixedFrame","oldGlobe","oldEllipsoid","UNIT_SPHERE","oldTransform","_setTransform","rotate3D","UNIT_Z","radius","maximumRadius","verticalCenter","_projection","verticalTransform","constrainedAxis","tangent","movementDelta","oldConstrainedAxis","negate","originalPosition","adjustHeightForTerrain","worldToCameraCoordinatesPoint","magSqrd","magnitudeSquared","sqrt","angleBetween","quaternion","fromAxisAngle","rotation","fromQuaternion","multiplyByVector","zoomCVWindowPos","zoomCVWindowRay","zoomCVIntersection","zoomCV","intersection","distanceUnderground","updateCV","zoom3D","tweens","anyButtonDown","removeAll","contains","tween","createCorrectPositionTween","update","scratchStrafeRay","scratchStrafePlane","scratchStrafeIntersection","scratchStrafeDirection","strafeStartPosition","spin3DPick","scratchCartographic","scratchRadii","scratchEllipsoid","scratchLookUp","scratchNormal","scratchMousePosition","spin3D","radii","geodeticSurfaceNormal","fromCartesian3","pan3D","mousePos","strafing","tangentPick","pickEllipsoid","rotateOnlyVertical","rotateOnlyHorizontal","oldAxis","rho","thetaWindowRatio","deltaTheta","tilt","rotateRight","rotateUp","pan3DP0","UNIT_W","pan3DP1","pan3DTemp0","pan3DTemp1","pan3DTemp2","pan3DTemp3","pan3DStartMousePosition","pan3DEndMousePosition","pan3DDiffMousePosition","pan3DPixelDimensions","panRay","startMousePosition","endMousePosition","p0","p1","toCenter","toCenterProj","directionWC","distanceToNearPlane","pixelDimensions","frustum","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","pixelRatio","dragDelta","rightWC","endPickDirection","endPickProj","projectVector","fov","tan","upWC","worldToCameraCoordinates","basis0","basis1","mostOrthogonalAxis","basis2","startRho","startDot","startRej","endRho","endDot","endRej","startPhi","endPhi","east","EPSILON2","planeNormal","side0","side1","zoom3DUnitPosition","zoom3DCartographic","preIntersectionDistance","inertiaMovement","approachingCollision","needPickGlobe","unitPosition","tilt3DWindowPos","tilt3DRay","tilt3DCenter","tilt3DVerticalCenter","tilt3DTransform","tilt3DVerticalTransform","tilt3DOldTransform","tilt3DQuaternion","tilt3DMatrix","tilt3DCart","tilt3DLookUp","tilt3D","_tiltOnEllipsoid","tilt3DOnEllipsoid","tilt3DOnTerrain","tilt3DOnEllipsoidCartographic","EPSILON3","rayEllipsoid","grazingAltitudeLocation","grazingAltitudeCart","newEllipsoid","t","stop","look3DStartPos","look3DEndPos","look3DStartRay","look3DEndRay","look3DNegativeRot","look3DTan","rotationAxis","startPos","endPos","horizontalRotationAxis","look","lookLeft","negativeRotationAxis","northParallel","southParallel","angleToAxis","EPSILON4","lookUp","update3D","scratchAdjustHeightTransform","scratchAdjustHeightCartographic","cameraChanged","MORPHING","heightUpdated","difference","percentDifference","prototype","scratchPreviousPosition","scratchPreviousDirection","verticalExaggeration","verticalExaggerationRelativeHeight","getHeight","previousPosition","previousDirection","reset","isDestroyed","destroy"],"mappings":"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","ignoreList":[0]}}]
}