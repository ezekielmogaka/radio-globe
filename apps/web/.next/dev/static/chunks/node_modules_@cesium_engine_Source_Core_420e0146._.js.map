{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/defined.js"],"sourcesContent":["/**\n * @function\n *\n * @param {*} value The object.\n * @returns {boolean} Returns true if the object is defined, returns false otherwise.\n *\n * @example\n * if (Cesium.defined(positions)) {\n *      doSomething();\n * } else {\n *      doSomethingElse();\n * }\n */\nfunction defined(value) {\n  return value !== undefined && value !== null;\n}\nexport default defined;\n"],"names":["defined","value","undefined"],"mappings":";;;;AAAA;;;;;;;;;;;;CAYC,GACD,SAASA,QAAQC,KAAK;IACpB,OAAOA,UAAUC,aAAaD,UAAU;AAC1C;uCACeD","ignoreList":[0]}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/DeveloperError.js"],"sourcesContent":["import defined from \"./defined.js\";\n\n/**\n * Constructs an exception object that is thrown due to a developer error, e.g., invalid argument,\n * argument out of range, etc.  This exception should only be thrown during development;\n * it usually indicates a bug in the calling code.  This exception should never be\n * caught; instead the calling code should strive not to generate it.\n * <br /><br />\n * On the other hand, a {@link RuntimeError} indicates an exception that may\n * be thrown at runtime, e.g., out of memory, that the calling code should be prepared\n * to catch.\n *\n * @alias DeveloperError\n * @constructor\n * @extends Error\n *\n * @param {string} [message] The error message for this exception.\n *\n * @see RuntimeError\n */\nfunction DeveloperError(message) {\n  /**\n   * 'DeveloperError' indicating that this exception was thrown due to a developer error.\n   * @type {string}\n   * @readonly\n   */\n  this.name = \"DeveloperError\";\n\n  /**\n   * The explanation for why this exception was thrown.\n   * @type {string}\n   * @readonly\n   */\n  this.message = message;\n\n  //Browsers such as IE don't have a stack property until you actually throw the error.\n  let stack;\n  try {\n    throw new Error();\n  } catch (e) {\n    stack = e.stack;\n  }\n\n  /**\n   * The stack trace of this exception, if available.\n   * @type {string}\n   * @readonly\n   */\n  this.stack = stack;\n}\n\nif (defined(Object.create)) {\n  DeveloperError.prototype = Object.create(Error.prototype);\n  DeveloperError.prototype.constructor = DeveloperError;\n}\n\nDeveloperError.prototype.toString = function () {\n  let str = `${this.name}: ${this.message}`;\n\n  if (defined(this.stack)) {\n    str += `\\n${this.stack.toString()}`;\n  }\n\n  return str;\n};\n\n/**\n * @private\n */\nDeveloperError.throwInstantiationError = function () {\n  throw new DeveloperError(\n    \"This function defines an interface and should not be called directly.\",\n  );\n};\nexport default DeveloperError;\n"],"names":["DeveloperError","message","name","stack","Error","e","Object","create","prototype","toString","str","throwInstantiationError"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;;;;;;;;;CAiBC,GACD,SAASA,eAAeC,OAAO;IAC7B;;;;GAIC,GACD,IAAI,CAACC,IAAI,GAAG;IAEZ;;;;GAIC,GACD,IAAI,CAACD,OAAO,GAAGA;IAEf,qFAAqF;IACrF,IAAIE;IACJ,IAAI;QACF,MAAM,IAAIC;IACZ,EAAE,OAAOC,GAAG;QACVF,QAAQE,EAAEF,KAAK;IACjB;IAEA;;;;GAIC,GACD,IAAI,CAACA,KAAK,GAAGA;AACf;AAEA,IAAI,IAAA,6KAAO,EAACG,OAAOC,MAAM,GAAG;IAC1BP,eAAeQ,SAAS,GAAGF,OAAOC,MAAM,CAACH,MAAMI,SAAS;IACxDR,eAAeQ,SAAS,CAAC,WAAW,GAAGR;AACzC;AAEAA,eAAeQ,SAAS,CAACC,QAAQ,GAAG;IAClC,IAAIC,MAAM,GAAG,IAAI,CAACR,IAAI,CAAC,EAAE,EAAE,IAAI,CAACD,OAAO,EAAE;IAEzC,IAAI,IAAA,6KAAO,EAAC,IAAI,CAACE,KAAK,GAAG;QACvBO,OAAO,CAAC,EAAE,EAAE,IAAI,CAACP,KAAK,CAACM,QAAQ,IAAI;IACrC;IAEA,OAAOC;AACT;AAEA;;CAEC,GACDV,eAAeW,uBAAuB,GAAG;IACvC,MAAM,IAAIX,eACR;AAEJ;uCACeA","ignoreList":[0]}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Check.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Contains functions for checking that supplied arguments are of a specified type\n * or meet specified conditions\n */\nconst Check = {};\n\n/**\n * Contains type checking functions, all using the typeof operator\n */\nCheck.typeOf = {};\n\nfunction getUndefinedErrorMessage(name) {\n  return `${name} is required, actual value was undefined`;\n}\n\nfunction getFailedTypeErrorMessage(actual, expected, name) {\n  return `Expected ${name} to be typeof ${expected}, actual typeof was ${actual}`;\n}\n\n/**\n * Throws if test is not defined\n *\n * @param {string} name The name of the variable being tested\n * @param {*} test The value that is to be checked\n * @exception {DeveloperError} test must be defined\n */\nCheck.defined = function (name, test) {\n  if (!defined(test)) {\n    throw new DeveloperError(getUndefinedErrorMessage(name));\n  }\n};\n\n/**\n * Throws if test is not typeof 'function'\n *\n * @param {string} name The name of the variable being tested\n * @param {*} test The value to test\n * @exception {DeveloperError} test must be typeof 'function'\n */\nCheck.typeOf.func = function (name, test) {\n  if (typeof test !== \"function\") {\n    throw new DeveloperError(\n      getFailedTypeErrorMessage(typeof test, \"function\", name),\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'string'\n *\n * @param {string} name The name of the variable being tested\n * @param {*} test The value to test\n * @exception {DeveloperError} test must be typeof 'string'\n */\nCheck.typeOf.string = function (name, test) {\n  if (typeof test !== \"string\") {\n    throw new DeveloperError(\n      getFailedTypeErrorMessage(typeof test, \"string\", name),\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'number'\n *\n * @param {string} name The name of the variable being tested\n * @param {*} test The value to test\n * @exception {DeveloperError} test must be typeof 'number'\n */\nCheck.typeOf.number = function (name, test) {\n  if (typeof test !== \"number\") {\n    throw new DeveloperError(\n      getFailedTypeErrorMessage(typeof test, \"number\", name),\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'number' and less than limit\n *\n * @param {string} name The name of the variable being tested\n * @param {*} test The value to test\n * @param {number} limit The limit value to compare against\n * @exception {DeveloperError} test must be typeof 'number' and less than limit\n */\nCheck.typeOf.number.lessThan = function (name, test, limit) {\n  Check.typeOf.number(name, test);\n  if (test >= limit) {\n    throw new DeveloperError(\n      `Expected ${name} to be less than ${limit}, actual value was ${test}`,\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'number' and less than or equal to limit\n *\n * @param {string} name The name of the variable being tested\n * @param {*} test The value to test\n * @param {number} limit The limit value to compare against\n * @exception {DeveloperError} test must be typeof 'number' and less than or equal to limit\n */\nCheck.typeOf.number.lessThanOrEquals = function (name, test, limit) {\n  Check.typeOf.number(name, test);\n  if (test > limit) {\n    throw new DeveloperError(\n      `Expected ${name} to be less than or equal to ${limit}, actual value was ${test}`,\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'number' and greater than limit\n *\n * @param {string} name The name of the variable being tested\n * @param {*} test The value to test\n * @param {number} limit The limit value to compare against\n * @exception {DeveloperError} test must be typeof 'number' and greater than limit\n */\nCheck.typeOf.number.greaterThan = function (name, test, limit) {\n  Check.typeOf.number(name, test);\n  if (test <= limit) {\n    throw new DeveloperError(\n      `Expected ${name} to be greater than ${limit}, actual value was ${test}`,\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'number' and greater than or equal to limit\n *\n * @param {string} name The name of the variable being tested\n * @param {*} test The value to test\n * @param {number} limit The limit value to compare against\n * @exception {DeveloperError} test must be typeof 'number' and greater than or equal to limit\n */\nCheck.typeOf.number.greaterThanOrEquals = function (name, test, limit) {\n  Check.typeOf.number(name, test);\n  if (test < limit) {\n    throw new DeveloperError(\n      `Expected ${name} to be greater than or equal to ${limit}, actual value was ${test}`,\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'object'\n *\n * @param {string} name The name of the variable being tested\n * @param {*} test The value to test\n * @exception {DeveloperError} test must be typeof 'object'\n */\nCheck.typeOf.object = function (name, test) {\n  if (typeof test !== \"object\") {\n    throw new DeveloperError(\n      getFailedTypeErrorMessage(typeof test, \"object\", name),\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'boolean'\n *\n * @param {string} name The name of the variable being tested\n * @param {*} test The value to test\n * @exception {DeveloperError} test must be typeof 'boolean'\n */\nCheck.typeOf.bool = function (name, test) {\n  if (typeof test !== \"boolean\") {\n    throw new DeveloperError(\n      getFailedTypeErrorMessage(typeof test, \"boolean\", name),\n    );\n  }\n};\n\n/**\n * Throws if test is not typeof 'bigint'\n *\n * @param {string} name The name of the variable being tested\n * @param {*} test The value to test\n * @exception {DeveloperError} test must be typeof 'bigint'\n */\nCheck.typeOf.bigint = function (name, test) {\n  if (typeof test !== \"bigint\") {\n    throw new DeveloperError(\n      getFailedTypeErrorMessage(typeof test, \"bigint\", name),\n    );\n  }\n};\n\n/**\n * Throws if test1 and test2 is not typeof 'number' and not equal in value\n *\n * @param {string} name1 The name of the first variable being tested\n * @param {string} name2 The name of the second variable being tested against\n * @param {*} test1 The value to test\n * @param {*} test2 The value to test against\n * @exception {DeveloperError} test1 and test2 should be type of 'number' and be equal in value\n */\nCheck.typeOf.number.equals = function (name1, name2, test1, test2) {\n  Check.typeOf.number(name1, test1);\n  Check.typeOf.number(name2, test2);\n  if (test1 !== test2) {\n    throw new DeveloperError(\n      `${name1} must be equal to ${name2}, the actual values are ${test1} and ${test2}`,\n    );\n  }\n};\nexport default Check;\n"],"names":["Check","typeOf","getUndefinedErrorMessage","name","getFailedTypeErrorMessage","actual","expected","defined","test","func","string","number","lessThan","limit","lessThanOrEquals","greaterThan","greaterThanOrEquals","object","bool","bigint","equals","name1","name2","test1","test2"],"mappings":";;;;AAAA;AACA;;;AAEA;;;CAGC,GACD,MAAMA,QAAQ,CAAC;AAEf;;CAEC,GACDA,MAAMC,MAAM,GAAG,CAAC;AAEhB,SAASC,yBAAyBC,IAAI;IACpC,OAAO,GAAGA,KAAK,wCAAwC,CAAC;AAC1D;AAEA,SAASC,0BAA0BC,MAAM,EAAEC,QAAQ,EAAEH,IAAI;IACvD,OAAO,CAAC,SAAS,EAAEA,KAAK,cAAc,EAAEG,SAAS,oBAAoB,EAAED,QAAQ;AACjF;AAEA;;;;;;CAMC,GACDL,MAAMO,OAAO,GAAG,SAAUJ,IAAI,EAAEK,IAAI;IAClC,IAAI,CAAC,IAAA,6KAAO,EAACA,OAAO;QAClB,MAAM,IAAI,oLAAc,CAACN,yBAAyBC;IACpD;AACF;AAEA;;;;;;CAMC,GACDH,MAAMC,MAAM,CAACQ,IAAI,GAAG,SAAUN,IAAI,EAAEK,IAAI;IACtC,IAAI,OAAOA,SAAS,YAAY;QAC9B,MAAM,IAAI,oLAAc,CACtBJ,0BAA0B,OAAOI,MAAM,YAAYL;IAEvD;AACF;AAEA;;;;;;CAMC,GACDH,MAAMC,MAAM,CAACS,MAAM,GAAG,SAAUP,IAAI,EAAEK,IAAI;IACxC,IAAI,OAAOA,SAAS,UAAU;QAC5B,MAAM,IAAI,oLAAc,CACtBJ,0BAA0B,OAAOI,MAAM,UAAUL;IAErD;AACF;AAEA;;;;;;CAMC,GACDH,MAAMC,MAAM,CAACU,MAAM,GAAG,SAAUR,IAAI,EAAEK,IAAI;IACxC,IAAI,OAAOA,SAAS,UAAU;QAC5B,MAAM,IAAI,oLAAc,CACtBJ,0BAA0B,OAAOI,MAAM,UAAUL;IAErD;AACF;AAEA;;;;;;;CAOC,GACDH,MAAMC,MAAM,CAACU,MAAM,CAACC,QAAQ,GAAG,SAAUT,IAAI,EAAEK,IAAI,EAAEK,KAAK;IACxDb,MAAMC,MAAM,CAACU,MAAM,CAACR,MAAMK;IAC1B,IAAIA,QAAQK,OAAO;QACjB,MAAM,IAAI,oLAAc,CACtB,CAAC,SAAS,EAAEV,KAAK,iBAAiB,EAAEU,MAAM,mBAAmB,EAAEL,MAAM;IAEzE;AACF;AAEA;;;;;;;CAOC,GACDR,MAAMC,MAAM,CAACU,MAAM,CAACG,gBAAgB,GAAG,SAAUX,IAAI,EAAEK,IAAI,EAAEK,KAAK;IAChEb,MAAMC,MAAM,CAACU,MAAM,CAACR,MAAMK;IAC1B,IAAIA,OAAOK,OAAO;QAChB,MAAM,IAAI,oLAAc,CACtB,CAAC,SAAS,EAAEV,KAAK,6BAA6B,EAAEU,MAAM,mBAAmB,EAAEL,MAAM;IAErF;AACF;AAEA;;;;;;;CAOC,GACDR,MAAMC,MAAM,CAACU,MAAM,CAACI,WAAW,GAAG,SAAUZ,IAAI,EAAEK,IAAI,EAAEK,KAAK;IAC3Db,MAAMC,MAAM,CAACU,MAAM,CAACR,MAAMK;IAC1B,IAAIA,QAAQK,OAAO;QACjB,MAAM,IAAI,oLAAc,CACtB,CAAC,SAAS,EAAEV,KAAK,oBAAoB,EAAEU,MAAM,mBAAmB,EAAEL,MAAM;IAE5E;AACF;AAEA;;;;;;;CAOC,GACDR,MAAMC,MAAM,CAACU,MAAM,CAACK,mBAAmB,GAAG,SAAUb,IAAI,EAAEK,IAAI,EAAEK,KAAK;IACnEb,MAAMC,MAAM,CAACU,MAAM,CAACR,MAAMK;IAC1B,IAAIA,OAAOK,OAAO;QAChB,MAAM,IAAI,oLAAc,CACtB,CAAC,SAAS,EAAEV,KAAK,gCAAgC,EAAEU,MAAM,mBAAmB,EAAEL,MAAM;IAExF;AACF;AAEA;;;;;;CAMC,GACDR,MAAMC,MAAM,CAACgB,MAAM,GAAG,SAAUd,IAAI,EAAEK,IAAI;IACxC,IAAI,OAAOA,SAAS,UAAU;QAC5B,MAAM,IAAI,oLAAc,CACtBJ,0BAA0B,OAAOI,MAAM,UAAUL;IAErD;AACF;AAEA;;;;;;CAMC,GACDH,MAAMC,MAAM,CAACiB,IAAI,GAAG,SAAUf,IAAI,EAAEK,IAAI;IACtC,IAAI,OAAOA,SAAS,WAAW;QAC7B,MAAM,IAAI,oLAAc,CACtBJ,0BAA0B,OAAOI,MAAM,WAAWL;IAEtD;AACF;AAEA;;;;;;CAMC,GACDH,MAAMC,MAAM,CAACkB,MAAM,GAAG,SAAUhB,IAAI,EAAEK,IAAI;IACxC,IAAI,OAAOA,SAAS,UAAU;QAC5B,MAAM,IAAI,oLAAc,CACtBJ,0BAA0B,OAAOI,MAAM,UAAUL;IAErD;AACF;AAEA;;;;;;;;CAQC,GACDH,MAAMC,MAAM,CAACU,MAAM,CAACS,MAAM,GAAG,SAAUC,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEC,KAAK;IAC/DxB,MAAMC,MAAM,CAACU,MAAM,CAACU,OAAOE;IAC3BvB,MAAMC,MAAM,CAACU,MAAM,CAACW,OAAOE;IAC3B,IAAID,UAAUC,OAAO;QACnB,MAAM,IAAI,oLAAc,CACtB,GAAGH,MAAM,kBAAkB,EAAEC,MAAM,wBAAwB,EAAEC,MAAM,KAAK,EAAEC,OAAO;IAErF;AACF;uCACexB","ignoreList":[0]}},
    {"offset": {"line": 266, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Credit.js"],"sourcesContent":["import DOMPurify from \"dompurify\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\n\nlet nextCreditId = 0;\nconst creditToId = {};\n\n/**\n * A credit contains data pertaining to how to display attributions/credits for certain content on the screen.\n * @param {string} html An string representing an html code snippet\n * @param {boolean} [showOnScreen=false] If true, the credit will be visible in the main credit container.  Otherwise, it will appear in a popover. All credits are displayed `inline`, if you have an image we recommend sizing it correctly to match the text or use css to `vertical-align` it.\n *\n * @alias Credit\n * @constructor\n *\n * @exception {DeveloperError} html is required.\n *\n * @example\n * // Create a credit with a tooltip, image and link\n * const credit = new Cesium.Credit('<a href=\"https://cesium.com/\" target=\"_blank\"><img src=\"/images/cesium_logo.png\"  style=\"vertical-align: -7px\" title=\"Cesium\"/></a>');\n */\nfunction Credit(html, showOnScreen) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"html\", html);\n  //>>includeEnd('debug');\n  let id;\n  const key = html;\n\n  if (defined(creditToId[key])) {\n    id = creditToId[key];\n  } else {\n    id = nextCreditId++;\n    creditToId[key] = id;\n  }\n\n  showOnScreen = showOnScreen ?? false;\n\n  // Credits are immutable so generate an id to use to optimize equal()\n  this._id = id;\n  this._html = html;\n  this._showOnScreen = showOnScreen;\n  this._element = undefined;\n}\n\nObject.defineProperties(Credit.prototype, {\n  /**\n   * The credit content\n   * @memberof Credit.prototype\n   * @type {string}\n   * @readonly\n   */\n  html: {\n    get: function () {\n      return this._html;\n    },\n  },\n\n  /**\n   * @memberof Credit.prototype\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n\n  /**\n   * Whether the credit should be displayed on screen or in a lightbox\n   * @memberof Credit.prototype\n   * @type {boolean}\n   */\n  showOnScreen: {\n    get: function () {\n      return this._showOnScreen;\n    },\n    set: function (value) {\n      this._showOnScreen = value;\n    },\n  },\n\n  /**\n   * Gets the credit element\n   * @memberof Credit.prototype\n   * @type {HTMLElement}\n   * @readonly\n   */\n  element: {\n    get: function () {\n      if (!defined(this._element)) {\n        const html = DOMPurify.sanitize(this._html);\n\n        const div = document.createElement(\"div\");\n        div.className = \"cesium-credit-wrapper\";\n        div._creditId = this._id;\n        div.style.display = \"inline\";\n        div.innerHTML = html;\n\n        const links = div.querySelectorAll(\"a\");\n        for (let i = 0; i < links.length; i++) {\n          links[i].setAttribute(\"target\", \"_blank\");\n        }\n\n        this._element = div;\n      }\n      return this._element;\n    },\n  },\n});\n\n/**\n * Returns true if the credits are equal\n *\n * @param {Credit} [left] The first credit\n * @param {Credit} [right] The second credit\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCredit.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left._id === right._id &&\n      left._showOnScreen === right._showOnScreen)\n  );\n};\n\n/**\n * Returns true if the credits are equal\n *\n * @param {Credit} [credit] The credit to compare to.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCredit.prototype.equals = function (credit) {\n  return Credit.equals(this, credit);\n};\n\n/**\n * @private\n */\nCredit.prototype.isIon = function () {\n  return this.html.indexOf(\"ion-credit.png\") !== -1;\n};\n\n/**\n * @private\n * @param attribution\n * @return {Credit}\n */\nCredit.getIonCredit = function (attribution) {\n  const showOnScreen =\n    defined(attribution.collapsible) && !attribution.collapsible;\n  const credit = new Credit(attribution.html, showOnScreen);\n\n  return credit;\n};\n\n/**\n * Duplicates a Credit instance.\n *\n * @param {Credit} [credit] The Credit to duplicate.\n * @returns {Credit} A new Credit instance that is a duplicate of the one provided. (Returns undefined if the credit is undefined)\n */\nCredit.clone = function (credit) {\n  if (defined(credit)) {\n    return new Credit(credit.html, credit.showOnScreen);\n  }\n};\nexport default Credit;\n"],"names":["nextCreditId","creditToId","Credit","html","showOnScreen","typeOf","string","id","key","_id","_html","_showOnScreen","_element","undefined","Object","defineProperties","prototype","get","set","value","element","sanitize","div","document","createElement","className","_creditId","style","display","innerHTML","links","querySelectorAll","i","length","setAttribute","equals","left","right","credit","isIon","indexOf","getIonCredit","attribution","collapsible","clone"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 414, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/appendForwardSlash.js"],"sourcesContent":["/**\n * @private\n */\nfunction appendForwardSlash(url) {\n  if (url.length === 0 || url[url.length - 1] !== \"/\") {\n    url = `${url}/`;\n  }\n  return url;\n}\nexport default appendForwardSlash;\n"],"names":["appendForwardSlash","url","length"],"mappings":";;;;AAAA;;CAEC,GACD,SAASA,mBAAmBC,GAAG;IAC7B,IAAIA,IAAIC,MAAM,KAAK,KAAKD,GAAG,CAACA,IAAIC,MAAM,GAAG,EAAE,KAAK,KAAK;QACnDD,MAAM,GAAGA,IAAI,CAAC,CAAC;IACjB;IACA,OAAOA;AACT;uCACeD","ignoreList":[0]}},
    {"offset": {"line": 431, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/clone.js"],"sourcesContent":["/**\n * Clones an object, returning a new object containing the same properties.\n *\n * @function\n *\n * @param {object} object The object to clone.\n * @param {boolean} [deep=false] If true, all properties will be deep cloned recursively.\n * @returns {object} The cloned object.\n */\nfunction clone(object, deep) {\n  if (object === null || typeof object !== \"object\") {\n    return object;\n  }\n\n  deep = deep ?? false;\n\n  const result = new object.constructor();\n  for (const propertyName in object) {\n    if (object.hasOwnProperty(propertyName)) {\n      let value = object[propertyName];\n      if (deep) {\n        value = clone(value, deep);\n      }\n      result[propertyName] = value;\n    }\n  }\n\n  return result;\n}\nexport default clone;\n"],"names":["clone","object","deep","result","propertyName","hasOwnProperty","value"],"mappings":";;;;AAAA;;;;;;;;CAQC,GACD,SAASA,MAAMC,MAAM,EAAEC,IAAI;IACzB,IAAID,WAAW,QAAQ,OAAOA,WAAW,UAAU;QACjD,OAAOA;IACT;IAEAC,OAAOA,QAAQ;IAEf,MAAMC,SAAS,IAAIF,OAAO,WAAW;IACrC,IAAK,MAAMG,gBAAgBH,OAAQ;QACjC,IAAIA,OAAOI,cAAc,CAACD,eAAe;YACvC,IAAIE,QAAQL,MAAM,CAACG,aAAa;YAChC,IAAIF,MAAM;gBACRI,QAAQN,MAAMM,OAAOJ;YACvB;YACAC,MAAM,CAACC,aAAa,GAAGE;QACzB;IACF;IAEA,OAAOH;AACT;uCACeH","ignoreList":[0]}},
    {"offset": {"line": 465, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/combine.js"],"sourcesContent":["import defined from \"./defined.js\";\n\n/**\n * Merges two objects, copying their properties onto a new combined object. When two objects have the same\n * property, the value of the property on the first object is used.  If either object is undefined,\n * it will be treated as an empty object.\n *\n * @example\n * const object1 = {\n *     propOne : 1,\n *     propTwo : {\n *         value1 : 10\n *     }\n * }\n * const object2 = {\n *     propTwo : 2\n * }\n * const final = Cesium.combine(object1, object2);\n *\n * // final === {\n * //     propOne : 1,\n * //     propTwo : {\n * //         value1 : 10\n * //     }\n * // }\n *\n * @param {object} [object1] The first object to merge.\n * @param {object} [object2] The second object to merge.\n * @param {boolean} [deep=false] Perform a recursive merge.\n * @returns {object} The combined object containing all properties from both objects.\n *\n * @function\n */\nfunction combine(object1, object2, deep) {\n  deep = deep ?? false;\n\n  const result = {};\n\n  const object1Defined = defined(object1);\n  const object2Defined = defined(object2);\n  let property;\n  let object1Value;\n  let object2Value;\n  if (object1Defined) {\n    for (property in object1) {\n      if (object1.hasOwnProperty(property)) {\n        object1Value = object1[property];\n        if (\n          object2Defined &&\n          deep &&\n          typeof object1Value === \"object\" &&\n          object2.hasOwnProperty(property)\n        ) {\n          object2Value = object2[property];\n          if (typeof object2Value === \"object\") {\n            result[property] = combine(object1Value, object2Value, deep);\n          } else {\n            result[property] = object1Value;\n          }\n        } else {\n          result[property] = object1Value;\n        }\n      }\n    }\n  }\n  if (object2Defined) {\n    for (property in object2) {\n      if (\n        object2.hasOwnProperty(property) &&\n        !result.hasOwnProperty(property)\n      ) {\n        object2Value = object2[property];\n        result[property] = object2Value;\n      }\n    }\n  }\n  return result;\n}\nexport default combine;\n"],"names":["combine","object1","object2","deep","result","object1Defined","object2Defined","property","object1Value","object2Value","hasOwnProperty"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8BC,GACD,SAASA,QAAQC,OAAO,EAAEC,OAAO,EAAEC,IAAI;IACrCA,OAAOA,QAAQ;IAEf,MAAMC,SAAS,CAAC;IAEhB,MAAMC,iBAAiB,IAAA,6KAAO,EAACJ;IAC/B,MAAMK,iBAAiB,IAAA,6KAAO,EAACJ;IAC/B,IAAIK;IACJ,IAAIC;IACJ,IAAIC;IACJ,IAAIJ,gBAAgB;QAClB,IAAKE,YAAYN,QAAS;YACxB,IAAIA,QAAQS,cAAc,CAACH,WAAW;gBACpCC,eAAeP,OAAO,CAACM,SAAS;gBAChC,IACED,kBACAH,QACA,OAAOK,iBAAiB,YACxBN,QAAQQ,cAAc,CAACH,WACvB;oBACAE,eAAeP,OAAO,CAACK,SAAS;oBAChC,IAAI,OAAOE,iBAAiB,UAAU;wBACpCL,MAAM,CAACG,SAAS,GAAGP,QAAQQ,cAAcC,cAAcN;oBACzD,OAAO;wBACLC,MAAM,CAACG,SAAS,GAAGC;oBACrB;gBACF,OAAO;oBACLJ,MAAM,CAACG,SAAS,GAAGC;gBACrB;YACF;QACF;IACF;IACA,IAAIF,gBAAgB;QAClB,IAAKC,YAAYL,QAAS;YACxB,IACEA,QAAQQ,cAAc,CAACH,aACvB,CAACH,OAAOM,cAAc,CAACH,WACvB;gBACAE,eAAeP,OAAO,CAACK,SAAS;gBAChCH,MAAM,CAACG,SAAS,GAAGE;YACrB;QACF;IACF;IACA,OAAOL;AACT;uCACeJ","ignoreList":[0]}},
    {"offset": {"line": 541, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Frozen.js"],"sourcesContent":["/**\n * Utilities helpful for setting a default value for a parameter.\n *\n * @namespace Frozen\n */\nconst Frozen = {};\n\n/**\n * A frozen empty object that can be used as the default value for options passed as\n * an object literal.\n * @type {object}\n * @memberof Frozen\n */\nFrozen.EMPTY_OBJECT = Object.freeze({});\n\n/**\n * A frozen empty array that can be used as the default value for options passed as\n * an array literal.\n * @type {array}\n * @memberof Frozen\n */\nFrozen.EMPTY_ARRAY = Object.freeze([]);\n\nexport default Frozen;\n"],"names":["Frozen","EMPTY_OBJECT","Object","freeze","EMPTY_ARRAY"],"mappings":";;;;AAAA;;;;CAIC,GACD,MAAMA,SAAS,CAAC;AAEhB;;;;;CAKC,GACDA,OAAOC,YAAY,GAAGC,OAAOC,MAAM,CAAC,CAAC;AAErC;;;;;CAKC,GACDH,OAAOI,WAAW,GAAGF,OAAOC,MAAM,CAAC,EAAE;uCAEtBH","ignoreList":[0]}},
    {"offset": {"line": 567, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/defer.js"],"sourcesContent":["/**\n * A function used to resolve a promise upon completion .\n * @callback defer.resolve\n *\n * @param {*} value The resulting value.\n */\n\n/**\n * A function used to reject a promise upon failure.\n * @callback defer.reject\n *\n * @param {*} error The error.\n */\n\n/**\n * An object which contains a promise object, and functions to resolve or reject the promise.\n *\n * @typedef {object} defer.deferred\n * @property {defer.resolve} resolve Resolves the promise when called.\n * @property {defer.reject} reject Rejects the promise when called.\n * @property {Promise} promise Promise object.\n */\n\n/**\n * Creates a deferred object, containing a promise object, and functions to resolve or reject the promise.\n * @returns {defer.deferred}\n * @private\n */\nfunction defer() {\n  let resolve;\n  let reject;\n  const promise = new Promise(function (res, rej) {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    resolve: resolve,\n    reject: reject,\n    promise: promise,\n  };\n}\n\nexport default defer;\n"],"names":["defer","resolve","reject","promise","Promise","res","rej"],"mappings":";;;;AAAA;;;;;CAKC,GAED;;;;;CAKC,GAED;;;;;;;CAOC,GAED;;;;CAIC,GACD,SAASA;IACP,IAAIC;IACJ,IAAIC;IACJ,MAAMC,UAAU,IAAIC,QAAQ,SAAUC,GAAG,EAAEC,GAAG;QAC5CL,UAAUI;QACVH,SAASI;IACX;IAEA,OAAO;QACLL,SAASA;QACTC,QAAQA;QACRC,SAASA;IACX;AACF;uCAEeH","ignoreList":[0]}},
    {"offset": {"line": 610, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/getAbsoluteUri.js"],"sourcesContent":["import Uri from \"urijs\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Given a relative Uri and a base Uri, returns the absolute Uri of the relative Uri.\n * @function\n *\n * @param {string} relative The relative Uri.\n * @param {string} [base] The base Uri.\n * @returns {string} The absolute Uri of the given relative Uri.\n *\n * @example\n * //absolute Uri will be \"https://test.com/awesome.png\";\n * const absoluteUri = Cesium.getAbsoluteUri('awesome.png', 'https://test.com');\n */\nfunction getAbsoluteUri(relative, base) {\n  let documentObject;\n  if (typeof document !== \"undefined\") {\n    documentObject = document;\n  }\n\n  return getAbsoluteUri._implementation(relative, base, documentObject);\n}\n\ngetAbsoluteUri._implementation = function (relative, base, documentObject) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(relative)) {\n    throw new DeveloperError(\"relative uri is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(base)) {\n    if (typeof documentObject === \"undefined\") {\n      return relative;\n    }\n    base = documentObject.baseURI ?? documentObject.location.href;\n  }\n\n  const relativeUri = new Uri(relative);\n  if (relativeUri.scheme() !== \"\") {\n    return relativeUri.toString();\n  }\n  return relativeUri.absoluteTo(base).toString();\n};\nexport default getAbsoluteUri;\n"],"names":["getAbsoluteUri","relative","base","documentObject","document","_implementation","baseURI","location","href","relativeUri","scheme","toString","absoluteTo"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;;;;CAWC,GACD,SAASA,eAAeC,QAAQ,EAAEC,IAAI;IACpC,IAAIC;IACJ,IAAI,OAAOC,aAAa,aAAa;QACnCD,iBAAiBC;IACnB;IAEA,OAAOJ,eAAeK,eAAe,CAACJ,UAAUC,MAAMC;AACxD;AAEAH,eAAeK,eAAe,GAAG,SAAUJ,QAAQ,EAAEC,IAAI,EAAEC,cAAc;IACvE,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACF,WAAW;QACtB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,IAAI,CAAC,IAAA,6KAAO,EAACC,OAAO;QAClB,IAAI,OAAOC,mBAAmB,aAAa;YACzC,OAAOF;QACT;QACAC,OAAOC,eAAeG,OAAO,IAAIH,eAAeI,QAAQ,CAACC,IAAI;IAC/D;IAEA,MAAMC,cAAc,IAAI,iJAAG,CAACR;IAC5B,IAAIQ,YAAYC,MAAM,OAAO,IAAI;QAC/B,OAAOD,YAAYE,QAAQ;IAC7B;IACA,OAAOF,YAAYG,UAAU,CAACV,MAAMS,QAAQ;AAC9C;uCACeX","ignoreList":[0]}},
    {"offset": {"line": 661, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/getBaseUri.js"],"sourcesContent":["import Uri from \"urijs\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Given a URI, returns the base path of the URI.\n * @function\n *\n * @param {string} uri The Uri.\n * @param {boolean} [includeQuery = false] Whether or not to include the query string and fragment form the uri\n * @returns {string} The base path of the Uri.\n *\n * @example\n * // basePath will be \"/Gallery/\";\n * const basePath = Cesium.getBaseUri('/Gallery/simple.czml?value=true&example=false');\n *\n * // basePath will be \"/Gallery/?value=true&example=false\";\n * const basePath = Cesium.getBaseUri('/Gallery/simple.czml?value=true&example=false', true);\n */\nfunction getBaseUri(uri, includeQuery) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(uri)) {\n    throw new DeveloperError(\"uri is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let basePath = \"\";\n  const i = uri.lastIndexOf(\"/\");\n  if (i !== -1) {\n    basePath = uri.substring(0, i + 1);\n  }\n\n  if (!includeQuery) {\n    return basePath;\n  }\n\n  uri = new Uri(uri);\n  if (uri.query().length !== 0) {\n    basePath += `?${uri.query()}`;\n  }\n  if (uri.fragment().length !== 0) {\n    basePath += `#${uri.fragment()}`;\n  }\n\n  return basePath;\n}\nexport default getBaseUri;\n"],"names":["getBaseUri","uri","includeQuery","basePath","i","lastIndexOf","substring","query","length","fragment"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;;;;;;;CAcC,GACD,SAASA,WAAWC,GAAG,EAAEC,YAAY;IACnC,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACD,MAAM;QACjB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,IAAIE,WAAW;IACf,MAAMC,IAAIH,IAAII,WAAW,CAAC;IAC1B,IAAID,MAAM,CAAC,GAAG;QACZD,WAAWF,IAAIK,SAAS,CAAC,GAAGF,IAAI;IAClC;IAEA,IAAI,CAACF,cAAc;QACjB,OAAOC;IACT;IAEAF,MAAM,IAAI,iJAAG,CAACA;IACd,IAAIA,IAAIM,KAAK,GAAGC,MAAM,KAAK,GAAG;QAC5BL,YAAY,CAAC,CAAC,EAAEF,IAAIM,KAAK,IAAI;IAC/B;IACA,IAAIN,IAAIQ,QAAQ,GAAGD,MAAM,KAAK,GAAG;QAC/BL,YAAY,CAAC,CAAC,EAAEF,IAAIQ,QAAQ,IAAI;IAClC;IAEA,OAAON;AACT;uCACeH","ignoreList":[0]}},
    {"offset": {"line": 713, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/getExtensionFromUri.js"],"sourcesContent":["import Uri from \"urijs\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Given a URI, returns the extension of the URI.\n * @function getExtensionFromUri\n *\n * @param {string} uri The Uri.\n * @returns {string} The extension of the Uri.\n *\n * @example\n * //extension will be \"czml\";\n * const extension = Cesium.getExtensionFromUri('/Gallery/simple.czml?value=true&example=false');\n */\nfunction getExtensionFromUri(uri) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(uri)) {\n    throw new DeveloperError(\"uri is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const uriObject = new Uri(uri);\n  uriObject.normalize();\n  let path = uriObject.path();\n  let index = path.lastIndexOf(\"/\");\n  if (index !== -1) {\n    path = path.substr(index + 1);\n  }\n  index = path.lastIndexOf(\".\");\n  if (index === -1) {\n    path = \"\";\n  } else {\n    path = path.substr(index + 1);\n  }\n  return path;\n}\nexport default getExtensionFromUri;\n"],"names":["getExtensionFromUri","uri","uriObject","normalize","path","index","lastIndexOf","substr"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;;;CAUC,GACD,SAASA,oBAAoBC,GAAG;IAC9B,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACA,MAAM;QACjB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAMC,YAAY,IAAI,iJAAG,CAACD;IAC1BC,UAAUC,SAAS;IACnB,IAAIC,OAAOF,UAAUE,IAAI;IACzB,IAAIC,QAAQD,KAAKE,WAAW,CAAC;IAC7B,IAAID,UAAU,CAAC,GAAG;QAChBD,OAAOA,KAAKG,MAAM,CAACF,QAAQ;IAC7B;IACAA,QAAQD,KAAKE,WAAW,CAAC;IACzB,IAAID,UAAU,CAAC,GAAG;QAChBD,OAAO;IACT,OAAO;QACLA,OAAOA,KAAKG,MAAM,CAACF,QAAQ;IAC7B;IACA,OAAOD;AACT;uCACeJ","ignoreList":[0]}},
    {"offset": {"line": 759, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/getImagePixels.js"],"sourcesContent":["import defined from \"./defined.js\";\n\nconst context2DsByWidthAndHeight = {};\n\n/**\n * Extract a pixel array from a loaded image.  Draws the image\n * into a canvas so it can read the pixels back.\n *\n * @function getImagePixels\n *\n * @param {HTMLImageElement|ImageBitmap} image The image to extract pixels from.\n * @param {number} width The width of the image. If not defined, then image.width is assigned.\n * @param {number} height The height of the image. If not defined, then image.height is assigned.\n * @returns {ImageData} The pixels of the image.\n */\nfunction getImagePixels(image, width, height) {\n  if (!defined(width)) {\n    width = image.width;\n  }\n  if (!defined(height)) {\n    height = image.height;\n  }\n\n  let context2DsByHeight = context2DsByWidthAndHeight[width];\n  if (!defined(context2DsByHeight)) {\n    context2DsByHeight = {};\n    context2DsByWidthAndHeight[width] = context2DsByHeight;\n  }\n\n  let context2d = context2DsByHeight[height];\n  if (!defined(context2d)) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    // Since we re-use contexts, use the willReadFrequently option â€“ See https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently\n    context2d = canvas.getContext(\"2d\", { willReadFrequently: true });\n    context2d.globalCompositeOperation = \"copy\";\n    context2DsByHeight[height] = context2d;\n  }\n\n  context2d.drawImage(image, 0, 0, width, height);\n  return context2d.getImageData(0, 0, width, height).data;\n}\nexport default getImagePixels;\n"],"names":["context2DsByWidthAndHeight","getImagePixels","image","width","height","context2DsByHeight","context2d","canvas","document","createElement","getContext","willReadFrequently","globalCompositeOperation","drawImage","getImageData","data"],"mappings":";;;;AAAA;;AAEA,MAAMA,6BAA6B,CAAC;AAEpC;;;;;;;;;;CAUC,GACD,SAASC,eAAeC,KAAK,EAAEC,KAAK,EAAEC,MAAM;IAC1C,IAAI,CAAC,IAAA,6KAAO,EAACD,QAAQ;QACnBA,QAAQD,MAAMC,KAAK;IACrB;IACA,IAAI,CAAC,IAAA,6KAAO,EAACC,SAAS;QACpBA,SAASF,MAAME,MAAM;IACvB;IAEA,IAAIC,qBAAqBL,0BAA0B,CAACG,MAAM;IAC1D,IAAI,CAAC,IAAA,6KAAO,EAACE,qBAAqB;QAChCA,qBAAqB,CAAC;QACtBL,0BAA0B,CAACG,MAAM,GAAGE;IACtC;IAEA,IAAIC,YAAYD,kBAAkB,CAACD,OAAO;IAC1C,IAAI,CAAC,IAAA,6KAAO,EAACE,YAAY;QACvB,MAAMC,SAASC,SAASC,aAAa,CAAC;QACtCF,OAAOJ,KAAK,GAAGA;QACfI,OAAOH,MAAM,GAAGA;QAChB,2JAA2J;QAC3JE,YAAYC,OAAOG,UAAU,CAAC,MAAM;YAAEC,oBAAoB;QAAK;QAC/DL,UAAUM,wBAAwB,GAAG;QACrCP,kBAAkB,CAACD,OAAO,GAAGE;IAC/B;IAEAA,UAAUO,SAAS,CAACX,OAAO,GAAG,GAAGC,OAAOC;IACxC,OAAOE,UAAUQ,YAAY,CAAC,GAAG,GAAGX,OAAOC,QAAQW,IAAI;AACzD;uCACed","ignoreList":[0]}},
    {"offset": {"line": 808, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/isBlobUri.js"],"sourcesContent":["import Check from \"./Check.js\";\n\nconst blobUriRegex = /^blob:/i;\n\n/**\n * Determines if the specified uri is a blob uri.\n *\n * @function isBlobUri\n *\n * @param {string} uri The uri to test.\n * @returns {boolean} true when the uri is a blob uri; otherwise, false.\n *\n * @private\n */\nfunction isBlobUri(uri) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"uri\", uri);\n  //>>includeEnd('debug');\n\n  return blobUriRegex.test(uri);\n}\nexport default isBlobUri;\n"],"names":["blobUriRegex","isBlobUri","uri","typeOf","string","test"],"mappings":";;;;AAAA;;AAEA,MAAMA,eAAe;AAErB;;;;;;;;;CASC,GACD,SAASC,UAAUC,GAAG;IACpB,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,OAAOF;IAC3B,wBAAwB;IAExB,OAAOF,aAAaK,IAAI,CAACH;AAC3B;uCACeD","ignoreList":[0]}},
    {"offset": {"line": 835, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/isCrossOriginUrl.js"],"sourcesContent":["import defined from \"./defined.js\";\n\nlet a;\n\n/**\n * Given a URL, determine whether that URL is considered cross-origin to the current page.\n *\n * @private\n */\nfunction isCrossOriginUrl(url) {\n  if (!defined(a)) {\n    a = document.createElement(\"a\");\n  }\n\n  // copy window location into the anchor to get consistent results\n  // when the port is default for the protocol (e.g. 80 for HTTP)\n  a.href = window.location.href;\n\n  // host includes both hostname and port if the port is not standard\n  const host = a.host;\n  const protocol = a.protocol;\n\n  a.href = url;\n  // IE only absolutizes href on get, not set\n  // eslint-disable-next-line no-self-assign\n  a.href = a.href;\n\n  return protocol !== a.protocol || host !== a.host;\n}\nexport default isCrossOriginUrl;\n"],"names":["a","isCrossOriginUrl","url","document","createElement","href","window","location","host","protocol"],"mappings":";;;;AAAA;;AAEA,IAAIA;AAEJ;;;;CAIC,GACD,SAASC,iBAAiBC,GAAG;IAC3B,IAAI,CAAC,IAAA,6KAAO,EAACF,IAAI;QACfA,IAAIG,SAASC,aAAa,CAAC;IAC7B;IAEA,iEAAiE;IACjE,+DAA+D;IAC/DJ,EAAEK,IAAI,GAAGC,OAAOC,QAAQ,CAACF,IAAI;IAE7B,mEAAmE;IACnE,MAAMG,OAAOR,EAAEQ,IAAI;IACnB,MAAMC,WAAWT,EAAES,QAAQ;IAE3BT,EAAEK,IAAI,GAAGH;IACT,2CAA2C;IAC3C,0CAA0C;IAC1CF,EAAEK,IAAI,GAAGL,EAAEK,IAAI;IAEf,OAAOI,aAAaT,EAAES,QAAQ,IAAID,SAASR,EAAEQ,IAAI;AACnD;uCACeP","ignoreList":[0]}},
    {"offset": {"line": 867, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/isDataUri.js"],"sourcesContent":["import Check from \"./Check.js\";\n\nconst dataUriRegex = /^data:/i;\n\n/**\n * Determines if the specified uri is a data uri.\n *\n * @function isDataUri\n *\n * @param {string} uri The uri to test.\n * @returns {boolean} true when the uri is a data uri; otherwise, false.\n *\n * @private\n */\nfunction isDataUri(uri) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"uri\", uri);\n  //>>includeEnd('debug');\n\n  return dataUriRegex.test(uri);\n}\nexport default isDataUri;\n"],"names":["dataUriRegex","isDataUri","uri","typeOf","string","test"],"mappings":";;;;AAAA;;AAEA,MAAMA,eAAe;AAErB;;;;;;;;;CASC,GACD,SAASC,UAAUC,GAAG;IACpB,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,OAAOF;IAC3B,wBAAwB;IAExB,OAAOF,aAAaK,IAAI,CAACH;AAC3B;uCACeD","ignoreList":[0]}},
    {"offset": {"line": 894, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/loadAndExecuteScript.js"],"sourcesContent":["/**\n * @private\n */\nfunction loadAndExecuteScript(url) {\n  const script = document.createElement(\"script\");\n  script.async = true;\n  script.src = url;\n\n  return new Promise((resolve, reject) => {\n    if (window.crossOriginIsolated) {\n      script.setAttribute(\"crossorigin\", \"anonymous\");\n    }\n\n    const head = document.getElementsByTagName(\"head\")[0];\n    script.onload = function () {\n      script.onload = undefined;\n      head.removeChild(script);\n      resolve();\n    };\n    script.onerror = function (e) {\n      reject(e);\n    };\n\n    head.appendChild(script);\n  });\n}\nexport default loadAndExecuteScript;\n"],"names":["loadAndExecuteScript","url","script","document","createElement","async","src","Promise","resolve","reject","window","crossOriginIsolated","setAttribute","head","getElementsByTagName","onload","undefined","removeChild","onerror","e","appendChild"],"mappings":";;;;AAAA;;CAEC,GACD,SAASA,qBAAqBC,GAAG;IAC/B,MAAMC,SAASC,SAASC,aAAa,CAAC;IACtCF,OAAOG,KAAK,GAAG;IACfH,OAAOI,GAAG,GAAGL;IAEb,OAAO,IAAIM,QAAQ,CAACC,SAASC;QAC3B,IAAIC,OAAOC,mBAAmB,EAAE;YAC9BT,OAAOU,YAAY,CAAC,eAAe;QACrC;QAEA,MAAMC,OAAOV,SAASW,oBAAoB,CAAC,OAAO,CAAC,EAAE;QACrDZ,OAAOa,MAAM,GAAG;YACdb,OAAOa,MAAM,GAAGC;YAChBH,KAAKI,WAAW,CAACf;YACjBM;QACF;QACAN,OAAOgB,OAAO,GAAG,SAAUC,CAAC;YAC1BV,OAAOU;QACT;QAEAN,KAAKO,WAAW,CAAClB;IACnB;AACF;uCACeF","ignoreList":[0]}},
    {"offset": {"line": 925, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Math.js"],"sourcesContent":["import MersenneTwister from \"mersenne-twister\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Math functions.\n *\n * @exports CesiumMath\n * @alias Math\n */\nconst CesiumMath = {};\n\n/**\n * 0.1\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON1 = 0.1;\n\n/**\n * 0.01\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON2 = 0.01;\n\n/**\n * 0.001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON3 = 0.001;\n\n/**\n * 0.0001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON4 = 0.0001;\n\n/**\n * 0.00001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON5 = 0.00001;\n\n/**\n * 0.000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON6 = 0.000001;\n\n/**\n * 0.0000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON7 = 0.0000001;\n\n/**\n * 0.00000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON8 = 0.00000001;\n\n/**\n * 0.000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON9 = 0.000000001;\n\n/**\n * 0.0000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON10 = 0.0000000001;\n\n/**\n * 0.00000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON11 = 0.00000000001;\n\n/**\n * 0.000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON12 = 0.000000000001;\n\n/**\n * 0.0000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON13 = 0.0000000000001;\n\n/**\n * 0.00000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON14 = 0.00000000000001;\n\n/**\n * 0.000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON15 = 0.000000000000001;\n\n/**\n * 0.0000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON16 = 0.0000000000000001;\n\n/**\n * 0.00000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON17 = 0.00000000000000001;\n\n/**\n * 0.000000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON18 = 0.000000000000000001;\n\n/**\n * 0.0000000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON19 = 0.0000000000000000001;\n\n/**\n * 0.00000000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON20 = 0.00000000000000000001;\n\n/**\n * 0.000000000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON21 = 0.000000000000000000001;\n\n/**\n * The gravitational parameter of the Earth in meters cubed\n * per second squared as defined by the WGS84 model: 3.986004418e14\n * @type {number}\n * @constant\n */\nCesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;\n\n/**\n * Radius of the sun in meters: 6.955e8\n * @type {number}\n * @constant\n */\nCesiumMath.SOLAR_RADIUS = 6.955e8;\n\n/**\n * The mean radius of the moon, according to the \"Report of the IAU/IAG Working Group on\n * Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000\",\n * Celestial Mechanics 82: 83-110, 2002.\n * @type {number}\n * @constant\n */\nCesiumMath.LUNAR_RADIUS = 1737400.0;\n\n/**\n * 64 * 1024\n * @type {number}\n * @constant\n */\nCesiumMath.SIXTY_FOUR_KILOBYTES = 64 * 1024;\n\n/**\n * 4 * 1024 * 1024 * 1024\n * @type {number}\n * @constant\n */\nCesiumMath.FOUR_GIGABYTES = 4 * 1024 * 1024 * 1024;\n\n/**\n * Returns the sign of the value; 1 if the value is positive, -1 if the value is\n * negative, or 0 if the value is 0.\n *\n * @function\n * @param {number} value The value to return the sign of.\n * @returns {number} The sign of value.\n */\nCesiumMath.sign =\n  Math.sign ??\n  function sign(value) {\n    value = +value; // coerce to number\n    if (value === 0 || value !== value) {\n      // zero or NaN\n      return value;\n    }\n    return value > 0 ? 1 : -1;\n  };\n\n/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.\n * This is similar to {@link CesiumMath#sign} except that returns 1.0 instead of\n * 0.0 when the input value is 0.0.\n * @param {number} value The value to return the sign of.\n * @returns {number} The sign of value.\n */\nCesiumMath.signNotZero = function (value) {\n  return value < 0.0 ? -1.0 : 1.0;\n};\n\n/**\n * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMaximum]\n * @param {number} value The scalar value in the range [-1.0, 1.0]\n * @param {number} [rangeMaximum=255] The maximum value in the mapped range, 255 by default.\n * @returns {number} A SNORM value, where 0 maps to -1.0 and rangeMaximum maps to 1.0.\n *\n * @see CesiumMath.fromSNorm\n */\nCesiumMath.toSNorm = function (value, rangeMaximum) {\n  rangeMaximum = rangeMaximum ?? 255;\n  return Math.round(\n    (CesiumMath.clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum,\n  );\n};\n\n/**\n * Converts a SNORM value in the range [0, rangeMaximum] to a scalar in the range [-1.0, 1.0].\n * @param {number} value SNORM value in the range [0, rangeMaximum]\n * @param {number} [rangeMaximum=255] The maximum value in the SNORM range, 255 by default.\n * @returns {number} Scalar in the range [-1.0, 1.0].\n *\n * @see CesiumMath.toSNorm\n */\nCesiumMath.fromSNorm = function (value, rangeMaximum) {\n  rangeMaximum = rangeMaximum ?? 255;\n  return (\n    (CesiumMath.clamp(value, 0.0, rangeMaximum) / rangeMaximum) * 2.0 - 1.0\n  );\n};\n\n/**\n * Converts a scalar value in the range [rangeMinimum, rangeMaximum] to a scalar in the range [0.0, 1.0]\n * @param {number} value The scalar value in the range [rangeMinimum, rangeMaximum]\n * @param {number} rangeMinimum The minimum value in the mapped range.\n * @param {number} rangeMaximum The maximum value in the mapped range.\n * @returns {number} A scalar value, where rangeMinimum maps to 0.0 and rangeMaximum maps to 1.0.\n */\nCesiumMath.normalize = function (value, rangeMinimum, rangeMaximum) {\n  rangeMaximum = Math.max(rangeMaximum - rangeMinimum, 0.0);\n  return rangeMaximum === 0.0\n    ? 0.0\n    : CesiumMath.clamp((value - rangeMinimum) / rangeMaximum, 0.0, 1.0);\n};\n\n/**\n * Returns the hyperbolic sine of a number.\n * The hyperbolic sine of <em>value</em> is defined to be\n * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0\n * where <i>e</i> is Euler's number, approximately 2.71828183.\n *\n * <p>Special cases:\n *   <ul>\n *     <li>If the argument is NaN, then the result is NaN.</li>\n *\n *     <li>If the argument is infinite, then the result is an infinity\n *     with the same sign as the argument.</li>\n *\n *     <li>If the argument is zero, then the result is a zero with the\n *     same sign as the argument.</li>\n *   </ul>\n *</p>\n *\n * @function\n * @param {number} value The number whose hyperbolic sine is to be returned.\n * @returns {number} The hyperbolic sine of <code>value</code>.\n */\nCesiumMath.sinh =\n  Math.sinh ??\n  function sinh(value) {\n    return (Math.exp(value) - Math.exp(-value)) / 2.0;\n  };\n\n/**\n * Returns the hyperbolic cosine of a number.\n * The hyperbolic cosine of <strong>value</strong> is defined to be\n * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0\n * where <i>e</i> is Euler's number, approximately 2.71828183.\n *\n * <p>Special cases:\n *   <ul>\n *     <li>If the argument is NaN, then the result is NaN.</li>\n *\n *     <li>If the argument is infinite, then the result is positive infinity.</li>\n *\n *     <li>If the argument is zero, then the result is 1.0.</li>\n *   </ul>\n *</p>\n *\n * @function\n * @param {number} value The number whose hyperbolic cosine is to be returned.\n * @returns {number} The hyperbolic cosine of <code>value</code>.\n */\nCesiumMath.cosh =\n  Math.cosh ??\n  function cosh(value) {\n    return (Math.exp(value) + Math.exp(-value)) / 2.0;\n  };\n\n/**\n * Computes the linear interpolation of two values.\n *\n * @param {number} p The start value to interpolate.\n * @param {number} q The end value to interpolate.\n * @param {number} time The time of interpolation generally in the range <code>[0.0, 1.0]</code>.\n * @returns {number} The linearly interpolated value.\n *\n * @example\n * const n = Cesium.Math.lerp(0.0, 2.0, 0.5); // returns 1.0\n */\nCesiumMath.lerp = function (p, q, time) {\n  return (1.0 - time) * p + time * q;\n};\n\n/**\n * pi\n *\n * @type {number}\n * @constant\n */\nCesiumMath.PI = Math.PI;\n\n/**\n * 1/pi\n *\n * @type {number}\n * @constant\n */\nCesiumMath.ONE_OVER_PI = 1.0 / Math.PI;\n\n/**\n * pi/2\n *\n * @type {number}\n * @constant\n */\nCesiumMath.PI_OVER_TWO = Math.PI / 2.0;\n\n/**\n * pi/3\n *\n * @type {number}\n * @constant\n */\nCesiumMath.PI_OVER_THREE = Math.PI / 3.0;\n\n/**\n * pi/4\n *\n * @type {number}\n * @constant\n */\nCesiumMath.PI_OVER_FOUR = Math.PI / 4.0;\n\n/**\n * pi/6\n *\n * @type {number}\n * @constant\n */\nCesiumMath.PI_OVER_SIX = Math.PI / 6.0;\n\n/**\n * 3pi/2\n *\n * @type {number}\n * @constant\n */\nCesiumMath.THREE_PI_OVER_TWO = (3.0 * Math.PI) / 2.0;\n\n/**\n * 2pi\n *\n * @type {number}\n * @constant\n */\nCesiumMath.TWO_PI = 2.0 * Math.PI;\n\n/**\n * 1/2pi\n *\n * @type {number}\n * @constant\n */\nCesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);\n\n/**\n * The number of radians in a degree.\n *\n * @type {number}\n * @constant\n */\nCesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;\n\n/**\n * The number of degrees in a radian.\n *\n * @type {number}\n * @constant\n */\nCesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;\n\n/**\n * The number of radians in an arc second.\n *\n * @type {number}\n * @constant\n */\nCesiumMath.RADIANS_PER_ARCSECOND = CesiumMath.RADIANS_PER_DEGREE / 3600.0;\n\n/**\n * Converts degrees to radians.\n * @param {number} degrees The angle to convert in degrees.\n * @returns {number} The corresponding angle in radians.\n */\nCesiumMath.toRadians = function (degrees) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(degrees)) {\n    throw new DeveloperError(\"degrees is required.\");\n  }\n  //>>includeEnd('debug');\n  return degrees * CesiumMath.RADIANS_PER_DEGREE;\n};\n\n/**\n * Converts radians to degrees.\n * @param {number} radians The angle to convert in radians.\n * @returns {number} The corresponding angle in degrees.\n */\nCesiumMath.toDegrees = function (radians) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(radians)) {\n    throw new DeveloperError(\"radians is required.\");\n  }\n  //>>includeEnd('debug');\n  return radians * CesiumMath.DEGREES_PER_RADIAN;\n};\n\n/**\n * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n *\n * @param {number} angle The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n * @returns {number} The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n *\n * @example\n * // Convert 270 degrees to -90 degrees longitude\n * const longitude = Cesium.Math.convertLongitudeRange(Cesium.Math.toRadians(270.0));\n */\nCesiumMath.convertLongitudeRange = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  const twoPi = CesiumMath.TWO_PI;\n\n  const simplified = angle - Math.floor(angle / twoPi) * twoPi;\n\n  if (simplified < -Math.PI) {\n    return simplified + twoPi;\n  }\n  if (simplified >= Math.PI) {\n    return simplified - twoPi;\n  }\n\n  return simplified;\n};\n\n/**\n * Convenience function that clamps a latitude value, in radians, to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n * Useful for sanitizing data before use in objects requiring correct range.\n *\n * @param {number} angle The latitude value, in radians, to clamp to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n * @returns {number} The latitude value clamped to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n *\n * @example\n * // Clamp 108 degrees latitude to 90 degrees latitude\n * const latitude = Cesium.Math.clampToLatitudeRange(Cesium.Math.toRadians(108.0));\n */\nCesiumMath.clampToLatitudeRange = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return CesiumMath.clamp(\n    angle,\n    -1 * CesiumMath.PI_OVER_TWO,\n    CesiumMath.PI_OVER_TWO,\n  );\n};\n\n/**\n * Produces an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.\n *\n * @param {number} angle in radians\n * @returns {number} The angle in the range [<code>-CesiumMath.PI</code>, <code>CesiumMath.PI</code>].\n */\nCesiumMath.negativePiToPi = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  if (angle >= -CesiumMath.PI && angle <= CesiumMath.PI) {\n    // Early exit if the input is already inside the range. This avoids\n    // unnecessary math which could introduce floating point error.\n    return angle;\n  }\n  return CesiumMath.zeroToTwoPi(angle + CesiumMath.PI) - CesiumMath.PI;\n};\n\n/**\n * Produces an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.\n *\n * @param {number} angle in radians\n * @returns {number} The angle in the range [0, <code>CesiumMath.TWO_PI</code>].\n */\nCesiumMath.zeroToTwoPi = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  if (angle >= 0 && angle <= CesiumMath.TWO_PI) {\n    // Early exit if the input is already inside the range. This avoids\n    // unnecessary math which could introduce floating point error.\n    return angle;\n  }\n  const mod = CesiumMath.mod(angle, CesiumMath.TWO_PI);\n  if (\n    Math.abs(mod) < CesiumMath.EPSILON14 &&\n    Math.abs(angle) > CesiumMath.EPSILON14\n  ) {\n    return CesiumMath.TWO_PI;\n  }\n  return mod;\n};\n\n/**\n * The modulo operation that also works for negative dividends.\n *\n * @param {number} m The dividend.\n * @param {number} n The divisor.\n * @returns {number} The remainder.\n */\nCesiumMath.mod = function (m, n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(m)) {\n    throw new DeveloperError(\"m is required.\");\n  }\n  if (!defined(n)) {\n    throw new DeveloperError(\"n is required.\");\n  }\n  if (n === 0.0) {\n    throw new DeveloperError(\"divisor cannot be 0.\");\n  }\n  //>>includeEnd('debug');\n  if (CesiumMath.sign(m) === CesiumMath.sign(n) && Math.abs(m) < Math.abs(n)) {\n    // Early exit if the input does not need to be modded. This avoids\n    // unnecessary math which could introduce floating point error.\n    return m;\n  }\n\n  return ((m % n) + n) % n;\n};\n\n/**\n * Determines if two values are equal using an absolute or relative tolerance test. This is useful\n * to avoid problems due to roundoff error when comparing floating-point values directly. The values are\n * first compared using an absolute tolerance test. If that fails, a relative tolerance test is performed.\n * Use this test if you are unsure of the magnitudes of left and right.\n *\n * @param {number} left The first value to compare.\n * @param {number} right The other value to compare.\n * @param {number} [relativeEpsilon=0] The maximum inclusive delta between <code>left</code> and <code>right</code> for the relative tolerance test.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The maximum inclusive delta between <code>left</code> and <code>right</code> for the absolute tolerance test.\n * @returns {boolean} <code>true</code> if the values are equal within the epsilon; otherwise, <code>false</code>.\n *\n * @example\n * const a = Cesium.Math.equalsEpsilon(0.0, 0.01, Cesium.Math.EPSILON2); // true\n * const b = Cesium.Math.equalsEpsilon(0.0, 0.1, Cesium.Math.EPSILON2);  // false\n * const c = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON7); // true\n * const d = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON9); // false\n */\nCesiumMath.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  relativeEpsilon = relativeEpsilon ?? 0.0;\n  absoluteEpsilon = absoluteEpsilon ?? relativeEpsilon;\n  const absDiff = Math.abs(left - right);\n  return (\n    absDiff <= absoluteEpsilon ||\n    absDiff <= relativeEpsilon * Math.max(Math.abs(left), Math.abs(right))\n  );\n};\n\n/**\n * Determines if the left value is less than the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.\n *\n * @param {number} left The first number to compare.\n * @param {number} right The second number to compare.\n * @param {number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {boolean} <code>true</code> if <code>left</code> is less than <code>right</code> by more than\n *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is greater or if the two\n *          values are nearly equal.\n */\nCesiumMath.lessThan = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right < -absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is less than or equal to the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.\n *\n * @param {number} left The first number to compare.\n * @param {number} right The second number to compare.\n * @param {number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {boolean} <code>true</code> if <code>left</code> is less than <code>right</code> or if the\n *          the values are nearly equal.\n */\nCesiumMath.lessThanOrEquals = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right < absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is greater the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.\n *\n * @param {number} left The first number to compare.\n * @param {number} right The second number to compare.\n * @param {number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {boolean} <code>true</code> if <code>left</code> is greater than <code>right</code> by more than\n *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is less or if the two\n *          values are nearly equal.\n */\nCesiumMath.greaterThan = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right > absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is greater than or equal to the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.\n *\n * @param {number} left The first number to compare.\n * @param {number} right The second number to compare.\n * @param {number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {boolean} <code>true</code> if <code>left</code> is greater than <code>right</code> or if the\n *          the values are nearly equal.\n */\nCesiumMath.greaterThanOrEquals = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right > -absoluteEpsilon;\n};\n\nconst factorials = [1];\n\n/**\n * Computes the factorial of the provided number.\n *\n * @param {number} n The number whose factorial is to be computed.\n * @returns {number} The factorial of the provided number or undefined if the number is less than 0.\n *\n * @exception {DeveloperError} A number greater than or equal to 0 is required.\n *\n *\n * @example\n * //Compute 7!, which is equal to 5040\n * const computedFactorial = Cesium.Math.factorial(7);\n *\n * @see {@link http://en.wikipedia.org/wiki/Factorial|Factorial on Wikipedia}\n */\nCesiumMath.factorial = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0) {\n    throw new DeveloperError(\n      \"A number greater than or equal to 0 is required.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = factorials.length;\n  if (n >= length) {\n    let sum = factorials[length - 1];\n    for (let i = length; i <= n; i++) {\n      const next = sum * i;\n      factorials.push(next);\n      sum = next;\n    }\n  }\n  return factorials[n];\n};\n\n/**\n * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.\n *\n * @param {number} [n] The number to be incremented.\n * @param {number} [maximumValue] The maximum incremented value before rolling over to the minimum value.\n * @param {number} [minimumValue=0.0] The number reset to after the maximum value has been exceeded.\n * @returns {number} The incremented number.\n *\n * @exception {DeveloperError} Maximum value must be greater than minimum value.\n *\n * @example\n * const n = Cesium.Math.incrementWrap(5, 10, 0); // returns 6\n * const m = Cesium.Math.incrementWrap(10, 10, 0); // returns 0\n */\nCesiumMath.incrementWrap = function (n, maximumValue, minimumValue) {\n  minimumValue = minimumValue ?? 0.0;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(n)) {\n    throw new DeveloperError(\"n is required.\");\n  }\n  if (maximumValue <= minimumValue) {\n    throw new DeveloperError(\"maximumValue must be greater than minimumValue.\");\n  }\n  //>>includeEnd('debug');\n\n  ++n;\n  if (n > maximumValue) {\n    n = minimumValue;\n  }\n  return n;\n};\n\n/**\n * Determines if a non-negative integer is a power of two.\n * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.\n *\n * @param {number} n The integer to test in the range [0, (2^32)-1].\n * @returns {boolean} <code>true</code> if the number if a power of two; otherwise, <code>false</code>.\n *\n * @exception {DeveloperError} A number between 0 and (2^32)-1 is required.\n *\n * @example\n * const t = Cesium.Math.isPowerOfTwo(16); // true\n * const f = Cesium.Math.isPowerOfTwo(20); // false\n */\nCesiumMath.isPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0 || n > 4294967295) {\n    throw new DeveloperError(\"A number between 0 and (2^32)-1 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return n !== 0 && (n & (n - 1)) === 0;\n};\n\n/**\n * Computes the next power-of-two integer greater than or equal to the provided non-negative integer.\n * The maximum allowed input is 2^31 due to 32-bit bitwise operator limitation in Javascript.\n *\n * @param {number} n The integer to test in the range [0, 2^31].\n * @returns {number} The next power-of-two integer.\n *\n * @exception {DeveloperError} A number between 0 and 2^31 is required.\n *\n * @example\n * const n = Cesium.Math.nextPowerOfTwo(29); // 32\n * const m = Cesium.Math.nextPowerOfTwo(32); // 32\n */\nCesiumMath.nextPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0 || n > 2147483648) {\n    throw new DeveloperError(\"A number between 0 and 2^31 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // From http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n  --n;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  ++n;\n\n  return n;\n};\n\n/**\n * Computes the previous power-of-two integer less than or equal to the provided non-negative integer.\n * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.\n *\n * @param {number} n The integer to test in the range [0, (2^32)-1].\n * @returns {number} The previous power-of-two integer.\n *\n * @exception {DeveloperError} A number between 0 and (2^32)-1 is required.\n *\n * @example\n * const n = Cesium.Math.previousPowerOfTwo(29); // 16\n * const m = Cesium.Math.previousPowerOfTwo(32); // 32\n */\nCesiumMath.previousPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0 || n > 4294967295) {\n    throw new DeveloperError(\"A number between 0 and (2^32)-1 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n |= n >> 32;\n\n  // The previous bitwise operations implicitly convert to signed 32-bit. Use `>>>` to convert to unsigned\n  n = (n >>> 0) - (n >>> 1);\n\n  return n;\n};\n\n/**\n * Constraint a value to lie between two values.\n *\n * @param {number} value The value to clamp.\n * @param {number} min The minimum value.\n * @param {number} max The maximum value.\n * @returns {number} The clamped value such that min <= result <= max.\n */\nCesiumMath.clamp = function (value, min, max) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  Check.typeOf.number(\"min\", min);\n  Check.typeOf.number(\"max\", max);\n  //>>includeEnd('debug');\n\n  return value < min ? min : value > max ? max : value;\n};\n\nlet randomNumberGenerator = new MersenneTwister();\n\n/**\n * Sets the seed used by the random number generator\n * in {@link CesiumMath#nextRandomNumber}.\n *\n * @param {number} seed An integer used as the seed.\n */\nCesiumMath.setRandomNumberSeed = function (seed) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(seed)) {\n    throw new DeveloperError(\"seed is required.\");\n  }\n  //>>includeEnd('debug');\n\n  randomNumberGenerator = new MersenneTwister(seed);\n};\n\n/**\n * Generates a random floating point number in the range of [0.0, 1.0)\n * using a Mersenne twister.\n *\n * @returns {number} A random number in the range of [0.0, 1.0).\n *\n * @see CesiumMath.setRandomNumberSeed\n * @see {@link http://en.wikipedia.org/wiki/Mersenne_twister|Mersenne twister on Wikipedia}\n */\nCesiumMath.nextRandomNumber = function () {\n  return randomNumberGenerator.random();\n};\n\n/**\n * Generates a random number between two numbers.\n *\n * @param {number} min The minimum value.\n * @param {number} max The maximum value.\n * @returns {number} A random number between the min and max.\n */\nCesiumMath.randomBetween = function (min, max) {\n  return CesiumMath.nextRandomNumber() * (max - min) + min;\n};\n\n/**\n * Computes <code>Math.acos(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]\n * so that the function will never return NaN.\n *\n * @param {number} value The value for which to compute acos.\n * @returns {number} The acos of the value if the value is in the range [-1.0, 1.0], or the acos of -1.0 or 1.0,\n *          whichever is closer, if the value is outside the range.\n */\nCesiumMath.acosClamped = function (value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.acos(CesiumMath.clamp(value, -1.0, 1.0));\n};\n\n/**\n * Computes <code>Math.asin(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]\n * so that the function will never return NaN.\n *\n * @param {number} value The value for which to compute asin.\n * @returns {number} The asin of the value if the value is in the range [-1.0, 1.0], or the asin of -1.0 or 1.0,\n *          whichever is closer, if the value is outside the range.\n */\nCesiumMath.asinClamped = function (value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.asin(CesiumMath.clamp(value, -1.0, 1.0));\n};\n\n/**\n * Finds the chord length between two points given the circle's radius and the angle between the points.\n *\n * @param {number} angle The angle between the two points.\n * @param {number} radius The radius of the circle.\n * @returns {number} The chord length.\n */\nCesiumMath.chordLength = function (angle, radius) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  if (!defined(radius)) {\n    throw new DeveloperError(\"radius is required.\");\n  }\n  //>>includeEnd('debug');\n  return 2.0 * radius * Math.sin(angle * 0.5);\n};\n\n/**\n * Finds the logarithm of a number to a base.\n *\n * @param {number} number The number.\n * @param {number} base The base.\n * @returns {number} The result.\n */\nCesiumMath.logBase = function (number, base) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(number)) {\n    throw new DeveloperError(\"number is required.\");\n  }\n  if (!defined(base)) {\n    throw new DeveloperError(\"base is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.log(number) / Math.log(base);\n};\n\n/**\n * Finds the cube root of a number.\n * Returns NaN if <code>number</code> is not provided.\n *\n * @function\n * @param {number} [number] The number.\n * @returns {number} The result.\n */\nCesiumMath.cbrt =\n  Math.cbrt ??\n  function cbrt(number) {\n    const result = Math.pow(Math.abs(number), 1.0 / 3.0);\n    return number < 0.0 ? -result : result;\n  };\n\n/**\n * Finds the base 2 logarithm of a number.\n *\n * @function\n * @param {number} number The number.\n * @returns {number} The result.\n */\nCesiumMath.log2 =\n  Math.log2 ??\n  function log2(number) {\n    return Math.log(number) * Math.LOG2E;\n  };\n\n/**\n * Calculate the fog impact at a given distance. Useful for culling.\n * Matches the equation in `fog.glsl`\n * @private\n */\nCesiumMath.fog = function (distanceToCamera, density) {\n  const scalar = distanceToCamera * density;\n  return 1.0 - Math.exp(-(scalar * scalar));\n};\n\n/**\n * Computes a fast approximation of Atan for input in the range [-1, 1].\n *\n * Based on Michal Drobot's approximation from ShaderFastLibs,\n * which in turn is based on \"Efficient approximations for the arctangent function,\"\n * Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.\n * Adapted from ShaderFastLibs under MIT License.\n *\n * @param {number} x An input number in the range [-1, 1]\n * @returns {number} An approximation of atan(x)\n */\nCesiumMath.fastApproximateAtan = function (x) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x\", x);\n  //>>includeEnd('debug');\n\n  return x * (-0.1784 * Math.abs(x) - 0.0663 * x * x + 1.0301);\n};\n\n/**\n * Computes a fast approximation of Atan2(x, y) for arbitrary input scalars.\n *\n * Range reduction math based on nvidia's cg reference implementation: http://developer.download.nvidia.com/cg/atan2.html\n *\n * @param {number} x An input number that isn't zero if y is zero.\n * @param {number} y An input number that isn't zero if x is zero.\n * @returns {number} An approximation of atan2(x, y)\n */\nCesiumMath.fastApproximateAtan2 = function (x, y) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  //>>includeEnd('debug');\n\n  // atan approximations are usually only reliable over [-1, 1]\n  // So reduce the range by flipping whether x or y is on top based on which is bigger.\n  let opposite;\n  let t = Math.abs(x); // t used as swap and atan result.\n  opposite = Math.abs(y);\n  const adjacent = Math.max(t, opposite);\n  opposite = Math.min(t, opposite);\n\n  const oppositeOverAdjacent = opposite / adjacent;\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(oppositeOverAdjacent)) {\n    throw new DeveloperError(\"either x or y must be nonzero\");\n  }\n  //>>includeEnd('debug');\n  t = CesiumMath.fastApproximateAtan(oppositeOverAdjacent);\n\n  // Undo range reduction\n  t = Math.abs(y) > Math.abs(x) ? CesiumMath.PI_OVER_TWO - t : t;\n  t = x < 0.0 ? CesiumMath.PI - t : t;\n  t = y < 0.0 ? -t : t;\n  return t;\n};\nexport default CesiumMath;\n"],"names":["CesiumMath","EPSILON1","EPSILON2","EPSILON3","EPSILON4","EPSILON5","EPSILON6","EPSILON7","EPSILON8","EPSILON9","EPSILON10","EPSILON11","EPSILON12","EPSILON13","EPSILON14","EPSILON15","EPSILON16","EPSILON17","EPSILON18","EPSILON19","EPSILON20","EPSILON21","GRAVITATIONALPARAMETER","SOLAR_RADIUS","LUNAR_RADIUS","SIXTY_FOUR_KILOBYTES","FOUR_GIGABYTES","sign","Math","value","signNotZero","toSNorm","rangeMaximum","round","clamp","fromSNorm","normalize","rangeMinimum","max","sinh","exp","cosh","lerp","p","q","time","PI","ONE_OVER_PI","PI_OVER_TWO","PI_OVER_THREE","PI_OVER_FOUR","PI_OVER_SIX","THREE_PI_OVER_TWO","TWO_PI","ONE_OVER_TWO_PI","RADIANS_PER_DEGREE","DEGREES_PER_RADIAN","RADIANS_PER_ARCSECOND","toRadians","degrees","toDegrees","radians","convertLongitudeRange","angle","twoPi","simplified","floor","clampToLatitudeRange","negativePiToPi","zeroToTwoPi","mod","abs","m","n","equalsEpsilon","left","right","relativeEpsilon","absoluteEpsilon","absDiff","lessThan","lessThanOrEquals","greaterThan","greaterThanOrEquals","factorials","factorial","length","sum","i","next","push","incrementWrap","maximumValue","minimumValue","isPowerOfTwo","nextPowerOfTwo","previousPowerOfTwo","min","typeOf","number","randomNumberGenerator","setRandomNumberSeed","seed","nextRandomNumber","random","randomBetween","acosClamped","acos","asinClamped","asin","chordLength","radius","sin","logBase","base","log","cbrt","result","pow","log2","LOG2E","fog","distanceToCamera","density","scalar","fastApproximateAtan","x","fastApproximateAtan2","y","opposite","t","adjacent","oppositeOverAdjacent","isNaN"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1854, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/objectToQuery.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Converts an object representing a set of name/value pairs into a query string,\n * with names and values encoded properly for use in a URL.  Values that are arrays\n * will produce multiple values with the same name.\n * @function objectToQuery\n *\n * @param {object} obj The object containing data to encode.\n * @returns {string} An encoded query string.\n *\n *\n * @example\n * const str = Cesium.objectToQuery({\n *     key1 : 'some value',\n *     key2 : 'a/b',\n *     key3 : ['x', 'y']\n * });\n *\n * @see queryToObject\n * // str will be:\n * // 'key1=some%20value&key2=a%2Fb&key3=x&key3=y'\n */\nfunction objectToQuery(obj) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(obj)) {\n    throw new DeveloperError(\"obj is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let result = \"\";\n  for (const propName in obj) {\n    if (obj.hasOwnProperty(propName)) {\n      const value = obj[propName];\n\n      const part = `${encodeURIComponent(propName)}=`;\n      if (Array.isArray(value)) {\n        for (let i = 0, len = value.length; i < len; ++i) {\n          result += `${part + encodeURIComponent(value[i])}&`;\n        }\n      } else {\n        result += `${part + encodeURIComponent(value)}&`;\n      }\n    }\n  }\n\n  // trim last &\n  result = result.slice(0, -1);\n\n  // This function used to replace %20 with + which is more compact and readable.\n  // However, some servers didn't properly handle + as a space.\n  // https://github.com/CesiumGS/cesium/issues/2192\n\n  return result;\n}\nexport default objectToQuery;\n"],"names":["objectToQuery","obj","result","propName","hasOwnProperty","value","part","encodeURIComponent","Array","isArray","i","len","length","slice"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;;;;;;;;;;;;;;CAoBC,GACD,SAASA,cAAcC,GAAG;IACxB,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACA,MAAM;QACjB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,IAAIC,SAAS;IACb,IAAK,MAAMC,YAAYF,IAAK;QAC1B,IAAIA,IAAIG,cAAc,CAACD,WAAW;YAChC,MAAME,QAAQJ,GAAG,CAACE,SAAS;YAE3B,MAAMG,OAAO,GAAGC,mBAAmBJ,UAAU,CAAC,CAAC;YAC/C,IAAIK,MAAMC,OAAO,CAACJ,QAAQ;gBACxB,IAAK,IAAIK,IAAI,GAAGC,MAAMN,MAAMO,MAAM,EAAEF,IAAIC,KAAK,EAAED,EAAG;oBAChDR,UAAU,GAAGI,OAAOC,mBAAmBF,KAAK,CAACK,EAAE,EAAE,CAAC,CAAC;gBACrD;YACF,OAAO;gBACLR,UAAU,GAAGI,OAAOC,mBAAmBF,OAAO,CAAC,CAAC;YAClD;QACF;IACF;IAEA,cAAc;IACdH,SAASA,OAAOW,KAAK,CAAC,GAAG,CAAC;IAE1B,+EAA+E;IAC/E,6DAA6D;IAC7D,iDAAiD;IAEjD,OAAOX;AACT;uCACeF","ignoreList":[0]}},
    {"offset": {"line": 1914, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/queryToObject.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Parses a query string into an object, where the keys and values of the object are the\n * name/value pairs from the query string, decoded. If a name appears multiple times,\n * the value in the object will be an array of values.\n * @function queryToObject\n *\n * @param {string} queryString The query string.\n * @returns {object} An object containing the parameters parsed from the query string.\n *\n *\n * @example\n * const obj = Cesium.queryToObject('key1=some%20value&key2=a%2Fb&key3=x&key3=y');\n * // obj will be:\n * // {\n * //   key1 : 'some value',\n * //   key2 : 'a/b',\n * //   key3 : ['x', 'y']\n * // }\n *\n * @see objectToQuery\n */\nfunction queryToObject(queryString) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(queryString)) {\n    throw new DeveloperError(\"queryString is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const result = {};\n  if (queryString === \"\") {\n    return result;\n  }\n  const parts = queryString.replace(/\\+/g, \"%20\").split(/[&;]/);\n  for (let i = 0, len = parts.length; i < len; ++i) {\n    const subparts = parts[i].split(\"=\");\n\n    const name = decodeURIComponent(subparts[0]);\n    let value = subparts[1];\n    if (defined(value)) {\n      value = decodeURIComponent(value);\n    } else {\n      value = \"\";\n    }\n\n    const resultValue = result[name];\n    if (typeof resultValue === \"string\") {\n      // expand the single value to an array\n      result[name] = [resultValue, value];\n    } else if (Array.isArray(resultValue)) {\n      resultValue.push(value);\n    } else {\n      result[name] = value;\n    }\n  }\n  return result;\n}\nexport default queryToObject;\n"],"names":["queryToObject","queryString","result","parts","replace","split","i","len","length","subparts","name","decodeURIComponent","value","resultValue","Array","isArray","push"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;;;;;;;;;;;;;;CAoBC,GACD,SAASA,cAAcC,WAAW;IAChC,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACA,cAAc;QACzB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAMC,SAAS,CAAC;IAChB,IAAID,gBAAgB,IAAI;QACtB,OAAOC;IACT;IACA,MAAMC,QAAQF,YAAYG,OAAO,CAAC,OAAO,OAAOC,KAAK,CAAC;IACtD,IAAK,IAAIC,IAAI,GAAGC,MAAMJ,MAAMK,MAAM,EAAEF,IAAIC,KAAK,EAAED,EAAG;QAChD,MAAMG,WAAWN,KAAK,CAACG,EAAE,CAACD,KAAK,CAAC;QAEhC,MAAMK,OAAOC,mBAAmBF,QAAQ,CAAC,EAAE;QAC3C,IAAIG,QAAQH,QAAQ,CAAC,EAAE;QACvB,IAAI,IAAA,6KAAO,EAACG,QAAQ;YAClBA,QAAQD,mBAAmBC;QAC7B,OAAO;YACLA,QAAQ;QACV;QAEA,MAAMC,cAAcX,MAAM,CAACQ,KAAK;QAChC,IAAI,OAAOG,gBAAgB,UAAU;YACnC,sCAAsC;YACtCX,MAAM,CAACQ,KAAK,GAAG;gBAACG;gBAAaD;aAAM;QACrC,OAAO,IAAIE,MAAMC,OAAO,CAACF,cAAc;YACrCA,YAAYG,IAAI,CAACJ;QACnB,OAAO;YACLV,MAAM,CAACQ,KAAK,GAAGE;QACjB;IACF;IACA,OAAOV;AACT;uCACeF","ignoreList":[0]}},
    {"offset": {"line": 1982, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/RequestState.js"],"sourcesContent":["/**\n * State of the request.\n *\n * @enum {number}\n */\nconst RequestState = {\n  /**\n   * Initial unissued state.\n   *\n   * @type {number}\n   * @constant\n   */\n  UNISSUED: 0,\n\n  /**\n   * Issued but not yet active. Will become active when open slots are available.\n   *\n   * @type {number}\n   * @constant\n   */\n  ISSUED: 1,\n\n  /**\n   * Actual http request has been sent.\n   *\n   * @type {number}\n   * @constant\n   */\n  ACTIVE: 2,\n\n  /**\n   * Request completed successfully.\n   *\n   * @type {number}\n   * @constant\n   */\n  RECEIVED: 3,\n\n  /**\n   * Request was cancelled, either explicitly or automatically because of low priority.\n   *\n   * @type {number}\n   * @constant\n   */\n  CANCELLED: 4,\n\n  /**\n   * Request failed.\n   *\n   * @type {number}\n   * @constant\n   */\n  FAILED: 5,\n};\nexport default Object.freeze(RequestState);\n"],"names":["RequestState","UNISSUED","ISSUED","ACTIVE","RECEIVED","CANCELLED","FAILED","Object","freeze"],"mappings":";;;;AAAA;;;;CAIC,GACD,MAAMA,eAAe;IACnB;;;;;GAKC,GACDC,UAAU;IAEV;;;;;GAKC,GACDC,QAAQ;IAER;;;;;GAKC,GACDC,QAAQ;IAER;;;;;GAKC,GACDC,UAAU;IAEV;;;;;GAKC,GACDC,WAAW;IAEX;;;;;GAKC,GACDC,QAAQ;AACV;uCACeC,OAAOC,MAAM,CAACR","ignoreList":[0]}},
    {"offset": {"line": 2033, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/RequestType.js"],"sourcesContent":["/**\n * An enum identifying the type of request. Used for finer grained logging and priority sorting.\n *\n * @enum {number}\n */\nconst RequestType = {\n  /**\n   * Terrain request.\n   *\n   * @type {number}\n   * @constant\n   */\n  TERRAIN: 0,\n\n  /**\n   * Imagery request.\n   *\n   * @type {number}\n   * @constant\n   */\n  IMAGERY: 1,\n\n  /**\n   * 3D Tiles request.\n   *\n   * @type {number}\n   * @constant\n   */\n  TILES3D: 2,\n\n  /**\n   * Other request.\n   *\n   * @type {number}\n   * @constant\n   */\n  OTHER: 3,\n};\nexport default Object.freeze(RequestType);\n"],"names":["RequestType","TERRAIN","IMAGERY","TILES3D","OTHER","Object","freeze"],"mappings":";;;;AAAA;;;;CAIC,GACD,MAAMA,cAAc;IAClB;;;;;GAKC,GACDC,SAAS;IAET;;;;;GAKC,GACDC,SAAS;IAET;;;;;GAKC,GACDC,SAAS;IAET;;;;;GAKC,GACDC,OAAO;AACT;uCACeC,OAAOC,MAAM,CAACN","ignoreList":[0]}},
    {"offset": {"line": 2072, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Request.js"],"sourcesContent":["import Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport RequestState from \"./RequestState.js\";\nimport RequestType from \"./RequestType.js\";\n\n/**\n * Stores information for making a request. In general this does not need to be constructed directly.\n *\n * @alias Request\n * @constructor\n\n * @param {object} [options] An object with the following properties:\n * @param {string} [options.url] The url to request.\n * @param {Request.RequestCallback} [options.requestFunction] The function that makes the actual data request.\n * @param {Request.CancelCallback} [options.cancelFunction] The function that is called when the request is cancelled.\n * @param {Request.PriorityCallback} [options.priorityFunction] The function that is called to update the request's priority, which occurs once per frame.\n * @param {number} [options.priority=0.0] The initial priority of the request.\n * @param {boolean} [options.throttle=false] Whether to throttle and prioritize the request. If false, the request will be sent immediately. If true, the request will be throttled and sent based on priority.\n * @param {boolean} [options.throttleByServer=false] Whether to throttle the request by server.\n * @param {RequestType} [options.type=RequestType.OTHER] The type of request.\n * @param {string} [options.serverKey] A key used to identify the server that a request is going to.\n */\nfunction Request(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const throttleByServer = options.throttleByServer ?? false;\n  const throttle = options.throttle ?? false;\n\n  /**\n   * The URL to request.\n   *\n   * @type {string}\n   */\n  this.url = options.url;\n\n  /**\n   * The function that makes the actual data request.\n   *\n   * @type {Request.RequestCallback}\n   */\n  this.requestFunction = options.requestFunction;\n\n  /**\n   * The function that is called when the request is cancelled.\n   *\n   * @type {Request.CancelCallback}\n   */\n  this.cancelFunction = options.cancelFunction;\n\n  /**\n   * The function that is called to update the request's priority, which occurs once per frame.\n   *\n   * @type {Request.PriorityCallback}\n   */\n  this.priorityFunction = options.priorityFunction;\n\n  /**\n   * Priority is a unit-less value where lower values represent higher priority.\n   * For world-based objects, this is usually the distance from the camera.\n   * A request that does not have a priority function defaults to a priority of 0.\n   *\n   * If priorityFunction is defined, this value is updated every frame with the result of that call.\n   *\n   * @type {number}\n   * @default 0.0\n   */\n  this.priority = options.priority ?? 0.0;\n\n  /**\n   * Whether to throttle and prioritize the request. If false, the request will be sent immediately. If true, the\n   * request will be throttled and sent based on priority.\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  this.throttle = throttle;\n\n  /**\n   * Whether to throttle the request by server. Browsers typically support about 6-8 parallel connections\n   * for HTTP/1 servers, and an unlimited amount of connections for HTTP/2 servers. Setting this value\n   * to <code>true</code> is preferable for requests going through HTTP/1 servers.\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  this.throttleByServer = throttleByServer;\n\n  /**\n   * Type of request.\n   *\n   * @type {RequestType}\n   * @readonly\n   *\n   * @default RequestType.OTHER\n   */\n  this.type = options.type ?? RequestType.OTHER;\n\n  /**\n   * A key used to identify the server that a request is going to. It is derived from the url's authority and scheme.\n   *\n   * @type {string}\n   *\n   * @private\n   */\n  this.serverKey = options.serverKey;\n\n  /**\n   * The current state of the request.\n   *\n   * @type {RequestState}\n   * @readonly\n   */\n  this.state = RequestState.UNISSUED;\n\n  /**\n   * The requests's deferred promise.\n   *\n   * @type {object}\n   *\n   * @private\n   */\n  this.deferred = undefined;\n\n  /**\n   * Whether the request was explicitly cancelled.\n   *\n   * @type {boolean}\n   *\n   * @private\n   */\n  this.cancelled = false;\n}\n\n/**\n * Mark the request as cancelled.\n *\n * @private\n */\nRequest.prototype.cancel = function () {\n  this.cancelled = true;\n};\n\n/**\n * Duplicates a Request instance.\n *\n * @param {Request} [result] The object onto which to store the result.\n *\n * @returns {Request} The modified result parameter or a new Resource instance if one was not provided.\n */\nRequest.prototype.clone = function (result) {\n  if (!defined(result)) {\n    return new Request(this);\n  }\n\n  result.url = this.url;\n  result.requestFunction = this.requestFunction;\n  result.cancelFunction = this.cancelFunction;\n  result.priorityFunction = this.priorityFunction;\n  result.priority = this.priority;\n  result.throttle = this.throttle;\n  result.throttleByServer = this.throttleByServer;\n  result.type = this.type;\n  result.serverKey = this.serverKey;\n\n  // These get defaulted because the cloned request hasn't been issued\n  result.state = RequestState.UNISSUED;\n  result.deferred = undefined;\n  result.cancelled = false;\n\n  return result;\n};\n\n/**\n * The function that makes the actual data request.\n * @callback Request.RequestCallback\n * @returns {Promise<void>} A promise for the requested data.\n */\n\n/**\n * The function that is called when the request is cancelled.\n * @callback Request.CancelCallback\n */\n\n/**\n * The function that is called to update the request's priority, which occurs once per frame.\n * @callback Request.PriorityCallback\n * @returns {number} The updated priority value.\n */\nexport default Request;\n"],"names":["Request","options","EMPTY_OBJECT","throttleByServer","throttle","url","requestFunction","cancelFunction","priorityFunction","priority","type","OTHER","serverKey","state","UNISSUED","deferred","undefined","cancelled","prototype","cancel","clone","result"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;;;;;;;;;;;;;;CAgBC,GACD,SAASA,QAAQC,OAAO;IACtBA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC,MAAMC,mBAAmBF,QAAQE,gBAAgB,IAAI;IACrD,MAAMC,WAAWH,QAAQG,QAAQ,IAAI;IAErC;;;;GAIC,GACD,IAAI,CAACC,GAAG,GAAGJ,QAAQI,GAAG;IAEtB;;;;GAIC,GACD,IAAI,CAACC,eAAe,GAAGL,QAAQK,eAAe;IAE9C;;;;GAIC,GACD,IAAI,CAACC,cAAc,GAAGN,QAAQM,cAAc;IAE5C;;;;GAIC,GACD,IAAI,CAACC,gBAAgB,GAAGP,QAAQO,gBAAgB;IAEhD;;;;;;;;;GASC,GACD,IAAI,CAACC,QAAQ,GAAGR,QAAQQ,QAAQ,IAAI;IAEpC;;;;;;;;GAQC,GACD,IAAI,CAACL,QAAQ,GAAGA;IAEhB;;;;;;;;;GASC,GACD,IAAI,CAACD,gBAAgB,GAAGA;IAExB;;;;;;;GAOC,GACD,IAAI,CAACO,IAAI,GAAGT,QAAQS,IAAI,IAAI,iLAAW,CAACC,KAAK;IAE7C;;;;;;GAMC,GACD,IAAI,CAACC,SAAS,GAAGX,QAAQW,SAAS;IAElC;;;;;GAKC,GACD,IAAI,CAACC,KAAK,GAAG,kLAAY,CAACC,QAAQ;IAElC;;;;;;GAMC,GACD,IAAI,CAACC,QAAQ,GAAGC;IAEhB;;;;;;GAMC,GACD,IAAI,CAACC,SAAS,GAAG;AACnB;AAEA;;;;CAIC,GACDjB,QAAQkB,SAAS,CAACC,MAAM,GAAG;IACzB,IAAI,CAACF,SAAS,GAAG;AACnB;AAEA;;;;;;CAMC,GACDjB,QAAQkB,SAAS,CAACE,KAAK,GAAG,SAAUC,MAAM;IACxC,IAAI,CAAC,IAAA,6KAAO,EAACA,SAAS;QACpB,OAAO,IAAIrB,QAAQ,IAAI;IACzB;IAEAqB,OAAOhB,GAAG,GAAG,IAAI,CAACA,GAAG;IACrBgB,OAAOf,eAAe,GAAG,IAAI,CAACA,eAAe;IAC7Ce,OAAOd,cAAc,GAAG,IAAI,CAACA,cAAc;IAC3Cc,OAAOb,gBAAgB,GAAG,IAAI,CAACA,gBAAgB;IAC/Ca,OAAOZ,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC/BY,OAAOjB,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC/BiB,OAAOlB,gBAAgB,GAAG,IAAI,CAACA,gBAAgB;IAC/CkB,OAAOX,IAAI,GAAG,IAAI,CAACA,IAAI;IACvBW,OAAOT,SAAS,GAAG,IAAI,CAACA,SAAS;IAEjC,oEAAoE;IACpES,OAAOR,KAAK,GAAG,kLAAY,CAACC,QAAQ;IACpCO,OAAON,QAAQ,GAAGC;IAClBK,OAAOJ,SAAS,GAAG;IAEnB,OAAOI;AACT;uCAkBerB","ignoreList":[0]}},
    {"offset": {"line": 2226, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/parseResponseHeaders.js"],"sourcesContent":["/**\n * Parses the result of XMLHttpRequest's getAllResponseHeaders() method into\n * a dictionary.\n *\n * @function parseResponseHeaders\n *\n * @param {string} headerString The header string returned by getAllResponseHeaders().  The format is\n *                 described here: http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders()-method\n * @returns {object} A dictionary of key/value pairs, where each key is the name of a header and the corresponding value\n *                   is that header's value.\n *\n * @private\n */\nfunction parseResponseHeaders(headerString) {\n  const headers = {};\n\n  if (!headerString) {\n    return headers;\n  }\n\n  const headerPairs = headerString.split(\"\\u000d\\u000a\");\n\n  for (let i = 0; i < headerPairs.length; ++i) {\n    const headerPair = headerPairs[i];\n    // Can't use split() here because it does the wrong thing\n    // if the header value has the string \": \" in it.\n    const index = headerPair.indexOf(\"\\u003a\\u0020\");\n    if (index > 0) {\n      const key = headerPair.substring(0, index);\n      const val = headerPair.substring(index + 2);\n      headers[key] = val;\n    }\n  }\n\n  return headers;\n}\nexport default parseResponseHeaders;\n"],"names":["parseResponseHeaders","headerString","headers","headerPairs","split","i","length","headerPair","index","indexOf","key","substring","val"],"mappings":";;;;AAAA;;;;;;;;;;;;CAYC,GACD,SAASA,qBAAqBC,YAAY;IACxC,MAAMC,UAAU,CAAC;IAEjB,IAAI,CAACD,cAAc;QACjB,OAAOC;IACT;IAEA,MAAMC,cAAcF,aAAaG,KAAK,CAAC;IAEvC,IAAK,IAAIC,IAAI,GAAGA,IAAIF,YAAYG,MAAM,EAAE,EAAED,EAAG;QAC3C,MAAME,aAAaJ,WAAW,CAACE,EAAE;QACjC,yDAAyD;QACzD,iDAAiD;QACjD,MAAMG,QAAQD,WAAWE,OAAO,CAAC;QACjC,IAAID,QAAQ,GAAG;YACb,MAAME,MAAMH,WAAWI,SAAS,CAAC,GAAGH;YACpC,MAAMI,MAAML,WAAWI,SAAS,CAACH,QAAQ;YACzCN,OAAO,CAACQ,IAAI,GAAGE;QACjB;IACF;IAEA,OAAOV;AACT;uCACeF","ignoreList":[0]}},
    {"offset": {"line": 2266, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/RequestErrorEvent.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport parseResponseHeaders from \"./parseResponseHeaders.js\";\n\n/**\n * An event that is raised when a request encounters an error.\n *\n * @constructor\n * @alias RequestErrorEvent\n *\n * @param {number} [statusCode] The HTTP error status code, such as 404.\n * @param {object} [response] The response included along with the error.\n * @param {string|object} [responseHeaders] The response headers, represented either as an object literal or as a\n *                        string in the format returned by XMLHttpRequest's getAllResponseHeaders() function.\n */\nfunction RequestErrorEvent(statusCode, response, responseHeaders) {\n  /**\n   * The HTTP error status code, such as 404.  If the error does not have a particular\n   * HTTP code, this property will be undefined.\n   *\n   * @type {number}\n   */\n  this.statusCode = statusCode;\n\n  /**\n   * The response included along with the error.  If the error does not include a response,\n   * this property will be undefined.\n   *\n   * @type {object}\n   */\n  this.response = response;\n\n  /**\n   * The headers included in the response, represented as an object literal of key/value pairs.\n   * If the error does not include any headers, this property will be undefined.\n   *\n   * @type {object}\n   */\n  this.responseHeaders = responseHeaders;\n\n  if (typeof this.responseHeaders === \"string\") {\n    this.responseHeaders = parseResponseHeaders(this.responseHeaders);\n  }\n}\n\n/**\n * Creates a string representing this RequestErrorEvent.\n * @memberof RequestErrorEvent\n *\n * @returns {string} A string representing the provided RequestErrorEvent.\n */\nRequestErrorEvent.prototype.toString = function () {\n  let str = \"Request has failed.\";\n  if (defined(this.statusCode)) {\n    str += ` Status Code: ${this.statusCode}`;\n  }\n  return str;\n};\nexport default RequestErrorEvent;\n"],"names":["RequestErrorEvent","statusCode","response","responseHeaders","prototype","toString","str"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;;;;CAUC,GACD,SAASA,kBAAkBC,UAAU,EAAEC,QAAQ,EAAEC,eAAe;IAC9D;;;;;GAKC,GACD,IAAI,CAACF,UAAU,GAAGA;IAElB;;;;;GAKC,GACD,IAAI,CAACC,QAAQ,GAAGA;IAEhB;;;;;GAKC,GACD,IAAI,CAACC,eAAe,GAAGA;IAEvB,IAAI,OAAO,IAAI,CAACA,eAAe,KAAK,UAAU;QAC5C,IAAI,CAACA,eAAe,GAAG,IAAA,0LAAoB,EAAC,IAAI,CAACA,eAAe;IAClE;AACF;AAEA;;;;;CAKC,GACDH,kBAAkBI,SAAS,CAACC,QAAQ,GAAG;IACrC,IAAIC,MAAM;IACV,IAAI,IAAA,6KAAO,EAAC,IAAI,CAACL,UAAU,GAAG;QAC5BK,OAAO,CAAC,cAAc,EAAE,IAAI,CAACL,UAAU,EAAE;IAC3C;IACA,OAAOK;AACT;uCACeN","ignoreList":[0]}},
    {"offset": {"line": 2324, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Event.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\n\n/**\n * A generic utility class for managing subscribers for a particular event.\n * This class is usually instantiated inside of a container class and\n * exposed as a property for others to subscribe to.\n *\n * @alias Event\n * @template Listener extends (...args: any[]) => void = (...args: any[]) => void\n * @constructor\n * @example\n * MyObject.prototype.myListener = function(arg1, arg2) {\n *     this.myArg1Copy = arg1;\n *     this.myArg2Copy = arg2;\n * }\n *\n * const myObjectInstance = new MyObject();\n * const evt = new Cesium.Event();\n * evt.addEventListener(MyObject.prototype.myListener, myObjectInstance);\n * evt.raiseEvent('1', '2');\n * evt.removeEventListener(MyObject.prototype.myListener);\n */\nfunction Event() {\n  /**\n   * @type {Map<Listener,Set<object>>}\n   * @private\n   */\n  this._listeners = new Map();\n  /**\n   * @type {Map<Listener,Set<object>>}\n   * @private\n   */\n  this._toRemove = new Map();\n  /**\n   * @type {Map<Listener,Set<object>>}\n   * @private\n   */\n  this._toAdd = new Map();\n  this._invokingListeners = false;\n  this._listenerCount = 0; // Tracks number of listener + scope pairs\n}\n\nObject.defineProperties(Event.prototype, {\n  /**\n   * The number of listeners currently subscribed to the event.\n   * @memberof Event.prototype\n   * @type {number}\n   * @readonly\n   */\n  numberOfListeners: {\n    get: function () {\n      return this._listenerCount;\n    },\n  },\n});\n\n/**\n * Registers a callback function to be executed whenever the event is raised.\n * An optional scope can be provided to serve as the <code>this</code> pointer\n * in which the function will execute.\n *\n * @param {Listener} listener The function to be executed when the event is raised.\n * @param {object} [scope] An optional object scope to serve as the <code>this</code>\n *        pointer in which the listener function will execute.\n * @returns {Event.RemoveCallback} A function that will remove this event listener when invoked.\n *\n * @see Event#raiseEvent\n * @see Event#removeEventListener\n */\nEvent.prototype.addEventListener = function (listener, scope) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"listener\", listener);\n  //>>includeEnd('debug');\n  const event = this;\n\n  const listenerMap = event._invokingListeners\n    ? event._toAdd\n    : event._listeners;\n  const added = addEventListener(this, listenerMap, listener, scope);\n  if (added) {\n    event._listenerCount++;\n  }\n\n  return function () {\n    event.removeEventListener(listener, scope);\n  };\n};\n\nfunction addEventListener(event, listenerMap, listener, scope) {\n  if (!listenerMap.has(listener)) {\n    listenerMap.set(listener, new Set());\n  }\n  const scopes = listenerMap.get(listener);\n  if (!scopes.has(scope)) {\n    scopes.add(scope);\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Unregisters a previously registered callback.\n *\n * @param {Listener} listener The function to be unregistered.\n * @param {object} [scope] The scope that was originally passed to addEventListener.\n * @returns {boolean} <code>true</code> if the listener was removed; <code>false</code> if the listener and scope are not registered with the event.\n *\n * @see Event#addEventListener\n * @see Event#raiseEvent\n */\nEvent.prototype.removeEventListener = function (listener, scope) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"listener\", listener);\n  //>>includeEnd('debug');\n\n  const removedFromListeners = removeEventListener(\n    this,\n    this._listeners,\n    listener,\n    scope,\n  );\n  const removedFromToAdd = removeEventListener(\n    this,\n    this._toAdd,\n    listener,\n    scope,\n  );\n\n  const removed = removedFromListeners || removedFromToAdd;\n  if (removed) {\n    this._listenerCount--;\n  }\n\n  return removed;\n};\n\nfunction removeEventListener(event, listenerMap, listener, scope) {\n  const scopes = listenerMap.get(listener);\n  if (!scopes || !scopes.has(scope)) {\n    return false;\n  }\n\n  if (event._invokingListeners) {\n    if (!addEventListener(event, event._toRemove, listener, scope)) {\n      // Already marked for removal\n      return false;\n    }\n  } else {\n    scopes.delete(scope);\n    if (scopes.size === 0) {\n      listenerMap.delete(listener);\n    }\n  }\n\n  return true;\n}\n\n/**\n * Raises the event by calling each registered listener with all supplied arguments.\n *\n * @param {...Parameters<Listener>} arguments This method takes any number of parameters and passes them through to the listener functions.\n *\n * @see Event#addEventListener\n * @see Event#removeEventListener\n */\nEvent.prototype.raiseEvent = function () {\n  this._invokingListeners = true;\n\n  for (const [listener, scopes] of this._listeners.entries()) {\n    if (!defined(listener)) {\n      continue;\n    }\n\n    for (const scope of scopes) {\n      listener.apply(scope, arguments);\n    }\n  }\n\n  this._invokingListeners = false;\n\n  // Actually add items marked for addition\n  for (const [listener, scopes] of this._toAdd.entries()) {\n    for (const scope of scopes) {\n      addEventListener(this, this._listeners, listener, scope);\n    }\n  }\n  this._toAdd.clear();\n\n  // Actually remove items marked for removal\n  for (const [listener, scopes] of this._toRemove.entries()) {\n    for (const scope of scopes) {\n      removeEventListener(this, this._listeners, listener, scope);\n    }\n  }\n  this._toRemove.clear();\n};\n\n/**\n * A function that removes a listener.\n * @callback Event.RemoveCallback\n */\n\nexport default Event;\n"],"names":["Event","_listeners","Map","_toRemove","_toAdd","_invokingListeners","_listenerCount","Object","defineProperties","prototype","numberOfListeners","get","addEventListener","listener","scope","typeOf","func","event","listenerMap","added","removeEventListener","has","set","Set","scopes","add","removedFromListeners","removedFromToAdd","removed","delete","size","raiseEvent","entries","apply","arguments","clear"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2493, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Heap.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Array implementation of a heap.\n *\n * @alias Heap\n * @constructor\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {Heap.ComparatorCallback} options.comparator The comparator to use for the heap. If comparator(a, b) is less than 0, sort a to a lower index than b, otherwise sort to a higher index.\n */\nfunction Heap(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.defined(\"options.comparator\", options.comparator);\n  //>>includeEnd('debug');\n\n  this._comparator = options.comparator;\n  this._array = [];\n  this._length = 0;\n  this._maximumLength = undefined;\n}\n\nObject.defineProperties(Heap.prototype, {\n  /**\n   * Gets the length of the heap.\n   *\n   * @memberof Heap.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._length;\n    },\n  },\n\n  /**\n   * Gets the internal array.\n   *\n   * @memberof Heap.prototype\n   *\n   * @type {Array}\n   * @readonly\n   */\n  internalArray: {\n    get: function () {\n      return this._array;\n    },\n  },\n\n  /**\n   * Gets and sets the maximum length of the heap.\n   *\n   * @memberof Heap.prototype\n   *\n   * @type {number}\n   */\n  maximumLength: {\n    get: function () {\n      return this._maximumLength;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThanOrEquals(\"maximumLength\", value, 0);\n      //>>includeEnd('debug');\n      const originalLength = this._length;\n      if (value < originalLength) {\n        const array = this._array;\n        // Remove trailing references\n        for (let i = value; i < originalLength; ++i) {\n          array[i] = undefined;\n        }\n        this._length = value;\n        array.length = value;\n      }\n      this._maximumLength = value;\n    },\n  },\n\n  /**\n   * The comparator to use for the heap. If comparator(a, b) is less than 0, sort a to a lower index than b, otherwise sort to a higher index.\n   *\n   * @memberof Heap.prototype\n   *\n   * @type {Heap.ComparatorCallback}\n   */\n  comparator: {\n    get: function () {\n      return this._comparator;\n    },\n  },\n});\n\nfunction swap(array, a, b) {\n  const temp = array[a];\n  array[a] = array[b];\n  array[b] = temp;\n}\n\n/**\n * Resizes the internal array of the heap.\n *\n * @param {number} [length] The length to resize internal array to. Defaults to the current length of the heap.\n */\nHeap.prototype.reserve = function (length) {\n  length = length ?? this._length;\n  this._array.length = length;\n};\n\n/**\n * Update the heap so that index and all descendants satisfy the heap property.\n *\n * @param {number} [index=0] The starting index to heapify from.\n */\nHeap.prototype.heapify = function (index) {\n  index = index ?? 0;\n  const length = this._length;\n  const comparator = this._comparator;\n  const array = this._array;\n  let candidate = -1;\n  let inserting = true;\n\n  while (inserting) {\n    const right = 2 * (index + 1);\n    const left = right - 1;\n\n    if (left < length && comparator(array[left], array[index]) < 0) {\n      candidate = left;\n    } else {\n      candidate = index;\n    }\n\n    if (right < length && comparator(array[right], array[candidate]) < 0) {\n      candidate = right;\n    }\n    if (candidate !== index) {\n      swap(array, candidate, index);\n      index = candidate;\n    } else {\n      inserting = false;\n    }\n  }\n};\n\n/**\n * Resort the heap.\n */\nHeap.prototype.resort = function () {\n  const length = this._length;\n  for (let i = Math.ceil(length / 2); i >= 0; --i) {\n    this.heapify(i);\n  }\n};\n\n/**\n * Insert an element into the heap. If the length would grow greater than maximumLength\n * of the heap, extra elements are removed.\n *\n * @param {*} element The element to insert\n *\n * @return {*} The element that was removed from the heap if the heap is at full capacity.\n */\nHeap.prototype.insert = function (element) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"element\", element);\n  //>>includeEnd('debug');\n\n  const array = this._array;\n  const comparator = this._comparator;\n  const maximumLength = this._maximumLength;\n\n  let index = this._length++;\n  if (index < array.length) {\n    array[index] = element;\n  } else {\n    array.push(element);\n  }\n\n  while (index !== 0) {\n    const parent = Math.floor((index - 1) / 2);\n    if (comparator(array[index], array[parent]) < 0) {\n      swap(array, index, parent);\n      index = parent;\n    } else {\n      break;\n    }\n  }\n\n  let removedElement;\n\n  if (defined(maximumLength) && this._length > maximumLength) {\n    removedElement = array[maximumLength];\n    this._length = maximumLength;\n  }\n\n  return removedElement;\n};\n\n/**\n * Remove the element specified by index from the heap and return it.\n *\n * @param {number} [index=0] The index to remove.\n * @returns {*} The specified element of the heap.\n */\nHeap.prototype.pop = function (index) {\n  index = index ?? 0;\n  if (this._length === 0) {\n    return undefined;\n  }\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.lessThan(\"index\", index, this._length);\n  //>>includeEnd('debug');\n\n  const array = this._array;\n  const root = array[index];\n  swap(array, index, --this._length);\n  this.heapify(index);\n  array[this._length] = undefined; // Remove trailing reference\n  return root;\n};\n\n/**\n * The comparator to use for the heap.\n * @callback Heap.ComparatorCallback\n * @param {*} a An element in the heap.\n * @param {*} b An element in the heap.\n * @returns {number} If the result of the comparison is less than 0, sort a to a lower index than b, otherwise sort to a higher index.\n */\nexport default Heap;\n"],"names":["Heap","options","typeOf","object","defined","comparator","_comparator","_array","_length","_maximumLength","undefined","Object","defineProperties","prototype","length","get","internalArray","maximumLength","set","value","number","greaterThanOrEquals","originalLength","array","i","swap","a","b","temp","reserve","heapify","index","candidate","inserting","right","left","resort","Math","ceil","insert","element","push","parent","floor","removedElement","pop","lessThan","root"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2696, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/RequestScheduler.js"],"sourcesContent":["import Uri from \"urijs\";\nimport Check from \"./Check.js\";\nimport defer from \"./defer.js\";\nimport defined from \"./defined.js\";\nimport Event from \"./Event.js\";\nimport Heap from \"./Heap.js\";\nimport isBlobUri from \"./isBlobUri.js\";\nimport isDataUri from \"./isDataUri.js\";\nimport RequestState from \"./RequestState.js\";\n\nfunction sortRequests(a, b) {\n  return a.priority - b.priority;\n}\n\nconst statistics = {\n  numberOfAttemptedRequests: 0,\n  numberOfActiveRequests: 0,\n  numberOfCancelledRequests: 0,\n  numberOfCancelledActiveRequests: 0,\n  numberOfFailedRequests: 0,\n  numberOfActiveRequestsEver: 0,\n  lastNumberOfActiveRequests: 0,\n};\n\nlet priorityHeapLength = 20;\nconst requestHeap = new Heap({\n  comparator: sortRequests,\n});\nrequestHeap.maximumLength = priorityHeapLength;\nrequestHeap.reserve(priorityHeapLength);\n\nconst activeRequests = [];\nlet numberOfActiveRequestsByServer = {};\n\nconst pageUri =\n  typeof document !== \"undefined\" ? new Uri(document.location.href) : new Uri();\n\nconst requestCompletedEvent = new Event();\n\n/**\n * The request scheduler is used to track and constrain the number of active requests in order to prioritize incoming requests. The ability\n * to retain control over the number of requests in CesiumJS is important because due to events such as changes in the camera position,\n * a lot of new requests may be generated and a lot of in-flight requests may become redundant. The request scheduler manually constrains the\n * number of requests so that newer requests wait in a shorter queue and don't have to compete for bandwidth with requests that have expired.\n *\n * @namespace RequestScheduler\n *\n */\nfunction RequestScheduler() {}\n\n/**\n * The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.\n * @type {number}\n * @default 50\n */\nRequestScheduler.maximumRequests = 50;\n\n/**\n * The maximum number of simultaneous active requests per server. Un-throttled requests or servers specifically\n * listed in {@link requestsByServer} do not observe this limit.\n * @type {number}\n * @default 18\n */\nRequestScheduler.maximumRequestsPerServer = 18;\n\n/**\n * A per server key list of overrides to use for throttling instead of <code>maximumRequestsPerServer</code>.\n * Useful when streaming data from a known HTTP/2 or HTTP/3 server.\n * @type {object}\n *\n * @example\n * RequestScheduler.requestsByServer[\"myserver.com:443\"] = 18;\n *\n * @example\n * RequestScheduler.requestsByServer = {\n *   \"api.cesium.com:443\": 18,\n *   \"assets.cesium.com:443\": 18,\n * };\n */\nRequestScheduler.requestsByServer = {};\n\n/**\n * Specifies if the request scheduler should throttle incoming requests, or let the browser queue requests under its control.\n * @type {boolean}\n * @default true\n */\nRequestScheduler.throttleRequests = true;\n\n/**\n * When true, log statistics to the console every frame\n * @type {boolean}\n * @default false\n * @private\n */\nRequestScheduler.debugShowStatistics = false;\n\n/**\n * An event that's raised when a request is completed.  Event handlers are passed\n * the error object if the request fails.\n *\n * @type {Event}\n * @default Event()\n * @private\n */\nRequestScheduler.requestCompletedEvent = requestCompletedEvent;\n\nObject.defineProperties(RequestScheduler, {\n  /**\n   * Returns the statistics used by the request scheduler.\n   *\n   * @memberof RequestScheduler\n   *\n   * @type {object}\n   * @readonly\n   * @private\n   */\n  statistics: {\n    get: function () {\n      return statistics;\n    },\n  },\n\n  /**\n   * The maximum size of the priority heap. This limits the number of requests that are sorted by priority. Only applies to requests that are not yet active.\n   *\n   * @memberof RequestScheduler\n   *\n   * @type {number}\n   * @default 20\n   * @private\n   */\n  priorityHeapLength: {\n    get: function () {\n      return priorityHeapLength;\n    },\n    set: function (value) {\n      // If the new length shrinks the heap, need to cancel some of the requests.\n      // Since this value is not intended to be tweaked regularly it is fine to just cancel the high priority requests.\n      if (value < priorityHeapLength) {\n        while (requestHeap.length > value) {\n          const request = requestHeap.pop();\n          cancelRequest(request);\n        }\n      }\n      priorityHeapLength = value;\n      requestHeap.maximumLength = value;\n      requestHeap.reserve(value);\n    },\n  },\n});\n\nfunction updatePriority(request) {\n  if (defined(request.priorityFunction)) {\n    request.priority = request.priorityFunction();\n  }\n}\n\n/**\n * Check if there are open slots for a particular server key. If desiredRequests is greater than 1, this checks if the queue has room for scheduling multiple requests.\n * @param {string} serverKey The server key returned by {@link RequestScheduler.getServerKey}.\n * @param {number} [desiredRequests=1] How many requests the caller plans to request\n * @return {boolean} True if there are enough open slots for <code>desiredRequests</code> more requests.\n * @private\n */\nRequestScheduler.serverHasOpenSlots = function (serverKey, desiredRequests) {\n  desiredRequests = desiredRequests ?? 1;\n\n  const maxRequests =\n    RequestScheduler.requestsByServer[serverKey] ??\n    RequestScheduler.maximumRequestsPerServer;\n  const hasOpenSlotsServer =\n    numberOfActiveRequestsByServer[serverKey] + desiredRequests <= maxRequests;\n\n  return hasOpenSlotsServer;\n};\n\n/**\n * Check if the priority heap has open slots, regardless of which server they\n * are from. This is used in {@link Multiple3DTileContent} for determining when\n * all requests can be scheduled\n * @param {number} desiredRequests The number of requests the caller intends to make\n * @return {boolean} <code>true</code> if the heap has enough available slots to meet the desiredRequests. <code>false</code> otherwise.\n *\n * @private\n */\nRequestScheduler.heapHasOpenSlots = function (desiredRequests) {\n  const hasOpenSlotsHeap =\n    requestHeap.length + desiredRequests <= priorityHeapLength;\n  return hasOpenSlotsHeap;\n};\n\nfunction issueRequest(request) {\n  if (request.state === RequestState.UNISSUED) {\n    request.state = RequestState.ISSUED;\n    request.deferred = defer();\n  }\n  return request.deferred.promise;\n}\n\nfunction getRequestReceivedFunction(request) {\n  return function (results) {\n    if (request.state === RequestState.CANCELLED) {\n      // If the data request comes back but the request is cancelled, ignore it.\n      return;\n    }\n    // explicitly set to undefined to ensure GC of request response data. See #8843\n    const deferred = request.deferred;\n\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    requestCompletedEvent.raiseEvent();\n    request.state = RequestState.RECEIVED;\n    request.deferred = undefined;\n\n    deferred.resolve(results);\n  };\n}\n\nfunction getRequestFailedFunction(request) {\n  return function (error) {\n    if (request.state === RequestState.CANCELLED) {\n      // If the data request comes back but the request is cancelled, ignore it.\n      return;\n    }\n    ++statistics.numberOfFailedRequests;\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    requestCompletedEvent.raiseEvent(error);\n    request.state = RequestState.FAILED;\n    request.deferred.reject(error);\n  };\n}\n\nfunction startRequest(request) {\n  const promise = issueRequest(request);\n  request.state = RequestState.ACTIVE;\n  activeRequests.push(request);\n  ++statistics.numberOfActiveRequests;\n  ++statistics.numberOfActiveRequestsEver;\n  ++numberOfActiveRequestsByServer[request.serverKey];\n  request\n    .requestFunction()\n    .then(getRequestReceivedFunction(request))\n    .catch(getRequestFailedFunction(request));\n  return promise;\n}\n\nfunction cancelRequest(request) {\n  const active = request.state === RequestState.ACTIVE;\n  request.state = RequestState.CANCELLED;\n  ++statistics.numberOfCancelledRequests;\n  // check that deferred has not been cleared since cancelRequest can be called\n  // on a finished request, e.g. by clearForSpecs during tests\n  if (defined(request.deferred)) {\n    const deferred = request.deferred;\n    request.deferred = undefined;\n    deferred.reject();\n  }\n\n  if (active) {\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    ++statistics.numberOfCancelledActiveRequests;\n  }\n\n  if (defined(request.cancelFunction)) {\n    request.cancelFunction();\n  }\n}\n\n/**\n * Sort requests by priority and start requests.\n * @private\n */\nRequestScheduler.update = function () {\n  let i;\n  let request;\n\n  // Loop over all active requests. Cancelled, failed, or received requests are removed from the array to make room for new requests.\n  let removeCount = 0;\n  const activeLength = activeRequests.length;\n  for (i = 0; i < activeLength; ++i) {\n    request = activeRequests[i];\n    if (request.cancelled) {\n      // Request was explicitly cancelled\n      cancelRequest(request);\n    }\n    if (request.state !== RequestState.ACTIVE) {\n      // Request is no longer active, remove from array\n      ++removeCount;\n      continue;\n    }\n    if (removeCount > 0) {\n      // Shift back to fill in vacated slots from completed requests\n      activeRequests[i - removeCount] = request;\n    }\n  }\n  activeRequests.length -= removeCount;\n\n  // Update priority of issued requests and resort the heap\n  const issuedRequests = requestHeap.internalArray;\n  const issuedLength = requestHeap.length;\n  for (i = 0; i < issuedLength; ++i) {\n    updatePriority(issuedRequests[i]);\n  }\n  requestHeap.resort();\n\n  // Get the number of open slots and fill with the highest priority requests.\n  // Un-throttled requests are automatically added to activeRequests, so activeRequests.length may exceed maximumRequests\n  const openSlots = Math.max(\n    RequestScheduler.maximumRequests - activeRequests.length,\n    0,\n  );\n  let filledSlots = 0;\n  while (filledSlots < openSlots && requestHeap.length > 0) {\n    // Loop until all open slots are filled or the heap becomes empty\n    request = requestHeap.pop();\n    if (request.cancelled) {\n      // Request was explicitly cancelled\n      cancelRequest(request);\n      continue;\n    }\n\n    if (\n      request.throttleByServer &&\n      !RequestScheduler.serverHasOpenSlots(request.serverKey)\n    ) {\n      // Open slots are available, but the request is throttled by its server. Cancel and try again later.\n      cancelRequest(request);\n      continue;\n    }\n\n    startRequest(request);\n    ++filledSlots;\n  }\n\n  updateStatistics();\n};\n\n/**\n * Get the server key from a given url.\n *\n * @param {string} url The url.\n * @returns {string} The server key.\n * @private\n */\nRequestScheduler.getServerKey = function (url) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"url\", url);\n  //>>includeEnd('debug');\n\n  let uri = new Uri(url);\n  if (uri.scheme() === \"\") {\n    uri = uri.absoluteTo(pageUri);\n    uri.normalize();\n  }\n\n  let serverKey = uri.authority();\n  if (!/:/.test(serverKey)) {\n    // If the authority does not contain a port number, add port 443 for https or port 80 for http\n    serverKey = `${serverKey}:${uri.scheme() === \"https\" ? \"443\" : \"80\"}`;\n  }\n\n  const length = numberOfActiveRequestsByServer[serverKey];\n  if (!defined(length)) {\n    numberOfActiveRequestsByServer[serverKey] = 0;\n  }\n\n  return serverKey;\n};\n\n/**\n * Issue a request. If request.throttle is false, the request is sent immediately. Otherwise the request will be\n * queued and sorted by priority before being sent.\n *\n * @param {Request} request The request object.\n *\n * @returns {Promise|undefined} A Promise for the requested data, or undefined if this request does not have high enough priority to be issued.\n *\n * @private\n */\nRequestScheduler.request = function (request) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"request\", request);\n  Check.typeOf.string(\"request.url\", request.url);\n  Check.typeOf.func(\"request.requestFunction\", request.requestFunction);\n  //>>includeEnd('debug');\n\n  if (isDataUri(request.url) || isBlobUri(request.url)) {\n    requestCompletedEvent.raiseEvent();\n    request.state = RequestState.RECEIVED;\n    return request.requestFunction();\n  }\n\n  ++statistics.numberOfAttemptedRequests;\n\n  if (!defined(request.serverKey)) {\n    request.serverKey = RequestScheduler.getServerKey(request.url);\n  }\n\n  if (\n    RequestScheduler.throttleRequests &&\n    request.throttleByServer &&\n    !RequestScheduler.serverHasOpenSlots(request.serverKey)\n  ) {\n    // Server is saturated. Try again later.\n    return undefined;\n  }\n\n  if (!RequestScheduler.throttleRequests || !request.throttle) {\n    return startRequest(request);\n  }\n\n  if (activeRequests.length >= RequestScheduler.maximumRequests) {\n    // Active requests are saturated. Try again later.\n    return undefined;\n  }\n\n  // Insert into the priority heap and see if a request was bumped off. If this request is the lowest\n  // priority it will be returned.\n  updatePriority(request);\n  const removedRequest = requestHeap.insert(request);\n\n  if (defined(removedRequest)) {\n    if (removedRequest === request) {\n      // Request does not have high enough priority to be issued\n      return undefined;\n    }\n    // A previously issued request has been bumped off the priority heap, so cancel it\n    cancelRequest(removedRequest);\n  }\n\n  return issueRequest(request);\n};\n\nfunction updateStatistics() {\n  if (!RequestScheduler.debugShowStatistics) {\n    return;\n  }\n\n  if (\n    statistics.numberOfActiveRequests === 0 &&\n    statistics.lastNumberOfActiveRequests > 0\n  ) {\n    if (statistics.numberOfAttemptedRequests > 0) {\n      console.log(\n        `Number of attempted requests: ${statistics.numberOfAttemptedRequests}`,\n      );\n      statistics.numberOfAttemptedRequests = 0;\n    }\n\n    if (statistics.numberOfCancelledRequests > 0) {\n      console.log(\n        `Number of cancelled requests: ${statistics.numberOfCancelledRequests}`,\n      );\n      statistics.numberOfCancelledRequests = 0;\n    }\n\n    if (statistics.numberOfCancelledActiveRequests > 0) {\n      console.log(\n        `Number of cancelled active requests: ${statistics.numberOfCancelledActiveRequests}`,\n      );\n      statistics.numberOfCancelledActiveRequests = 0;\n    }\n\n    if (statistics.numberOfFailedRequests > 0) {\n      console.log(\n        `Number of failed requests: ${statistics.numberOfFailedRequests}`,\n      );\n      statistics.numberOfFailedRequests = 0;\n    }\n  }\n\n  statistics.lastNumberOfActiveRequests = statistics.numberOfActiveRequests;\n}\n\n/**\n * For testing only. Clears any requests that may not have completed from previous tests.\n *\n * @private\n */\nRequestScheduler.clearForSpecs = function () {\n  while (requestHeap.length > 0) {\n    const request = requestHeap.pop();\n    cancelRequest(request);\n  }\n  const length = activeRequests.length;\n  for (let i = 0; i < length; ++i) {\n    cancelRequest(activeRequests[i]);\n  }\n  activeRequests.length = 0;\n  numberOfActiveRequestsByServer = {};\n\n  // Clear stats\n  statistics.numberOfAttemptedRequests = 0;\n  statistics.numberOfActiveRequests = 0;\n  statistics.numberOfCancelledRequests = 0;\n  statistics.numberOfCancelledActiveRequests = 0;\n  statistics.numberOfFailedRequests = 0;\n  statistics.numberOfActiveRequestsEver = 0;\n  statistics.lastNumberOfActiveRequests = 0;\n};\n\n/**\n * For testing only.\n *\n * @private\n */\nRequestScheduler.numberOfActiveRequestsByServer = function (serverKey) {\n  return numberOfActiveRequestsByServer[serverKey];\n};\n\n/**\n * For testing only.\n *\n * @private\n */\nRequestScheduler.requestHeap = requestHeap;\nexport default RequestScheduler;\n"],"names":["sortRequests","a","b","priority","statistics","numberOfAttemptedRequests","numberOfActiveRequests","numberOfCancelledRequests","numberOfCancelledActiveRequests","numberOfFailedRequests","numberOfActiveRequestsEver","lastNumberOfActiveRequests","priorityHeapLength","requestHeap","comparator","maximumLength","reserve","activeRequests","numberOfActiveRequestsByServer","pageUri","document","location","href","requestCompletedEvent","RequestScheduler","maximumRequests","maximumRequestsPerServer","requestsByServer","throttleRequests","debugShowStatistics","Object","defineProperties","get","set","value","length","request","pop","cancelRequest","updatePriority","priorityFunction","serverHasOpenSlots","serverKey","desiredRequests","maxRequests","hasOpenSlotsServer","heapHasOpenSlots","hasOpenSlotsHeap","issueRequest","state","UNISSUED","ISSUED","deferred","promise","getRequestReceivedFunction","results","CANCELLED","raiseEvent","RECEIVED","undefined","resolve","getRequestFailedFunction","error","FAILED","reject","startRequest","ACTIVE","push","requestFunction","then","catch","active","cancelFunction","update","i","removeCount","activeLength","cancelled","issuedRequests","internalArray","issuedLength","resort","openSlots","Math","max","filledSlots","throttleByServer","updateStatistics","getServerKey","url","typeOf","string","uri","scheme","absoluteTo","normalize","authority","test","object","func","throttle","removedRequest","insert","console","log","clearForSpecs"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3125, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/RuntimeError.js"],"sourcesContent":["import defined from \"./defined.js\";\n\n/**\n * Constructs an exception object that is thrown due to an error that can occur at runtime, e.g.,\n * out of memory, could not compile shader, etc.  If a function may throw this\n * exception, the calling code should be prepared to catch it.\n * <br /><br />\n * On the other hand, a {@link DeveloperError} indicates an exception due\n * to a developer error, e.g., invalid argument, that usually indicates a bug in the\n * calling code.\n *\n * @alias RuntimeError\n * @constructor\n * @extends Error\n *\n * @param {string} [message] The error message for this exception.\n *\n * @see DeveloperError\n */\nfunction RuntimeError(message) {\n  /**\n   * 'RuntimeError' indicating that this exception was thrown due to a runtime error.\n   * @type {string}\n   * @readonly\n   */\n  this.name = \"RuntimeError\";\n\n  /**\n   * The explanation for why this exception was thrown.\n   * @type {string}\n   * @readonly\n   */\n  this.message = message;\n\n  //Browsers such as IE don't have a stack property until you actually throw the error.\n  let stack;\n  try {\n    throw new Error();\n  } catch (e) {\n    stack = e.stack;\n  }\n\n  /**\n   * The stack trace of this exception, if available.\n   * @type {string}\n   * @readonly\n   */\n  this.stack = stack;\n}\n\nif (defined(Object.create)) {\n  RuntimeError.prototype = Object.create(Error.prototype);\n  RuntimeError.prototype.constructor = RuntimeError;\n}\n\nRuntimeError.prototype.toString = function () {\n  let str = `${this.name}: ${this.message}`;\n\n  if (defined(this.stack)) {\n    str += `\\n${this.stack.toString()}`;\n  }\n\n  return str;\n};\nexport default RuntimeError;\n"],"names":["RuntimeError","message","name","stack","Error","e","Object","create","prototype","toString","str"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;;;;;;;;CAgBC,GACD,SAASA,aAAaC,OAAO;IAC3B;;;;GAIC,GACD,IAAI,CAACC,IAAI,GAAG;IAEZ;;;;GAIC,GACD,IAAI,CAACD,OAAO,GAAGA;IAEf,qFAAqF;IACrF,IAAIE;IACJ,IAAI;QACF,MAAM,IAAIC;IACZ,EAAE,OAAOC,GAAG;QACVF,QAAQE,EAAEF,KAAK;IACjB;IAEA;;;;GAIC,GACD,IAAI,CAACA,KAAK,GAAGA;AACf;AAEA,IAAI,IAAA,6KAAO,EAACG,OAAOC,MAAM,GAAG;IAC1BP,aAAaQ,SAAS,GAAGF,OAAOC,MAAM,CAACH,MAAMI,SAAS;IACtDR,aAAaQ,SAAS,CAAC,WAAW,GAAGR;AACvC;AAEAA,aAAaQ,SAAS,CAACC,QAAQ,GAAG;IAChC,IAAIC,MAAM,GAAG,IAAI,CAACR,IAAI,CAAC,EAAE,EAAE,IAAI,CAACD,OAAO,EAAE;IAEzC,IAAI,IAAA,6KAAO,EAAC,IAAI,CAACE,KAAK,GAAG;QACvBO,OAAO,CAAC,EAAE,EAAE,IAAI,CAACP,KAAK,CAACM,QAAQ,IAAI;IACrC;IAEA,OAAOC;AACT;uCACeV","ignoreList":[0]}},
    {"offset": {"line": 3187, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TrustedServers.js"],"sourcesContent":["import Uri from \"urijs\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * A singleton that contains all of the servers that are trusted. Credentials will be sent with\n * any requests to these servers.\n *\n * @namespace TrustedServers\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n */\nconst TrustedServers = {};\nlet _servers = {};\n\n/**\n * Adds a trusted server to the registry\n *\n * @param {string} host The host to be added.\n * @param {number} port The port used to access the host.\n *\n * @example\n * // Add a trusted server\n * TrustedServers.add('my.server.com', 80);\n */\nTrustedServers.add = function (host, port) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(host)) {\n    throw new DeveloperError(\"host is required.\");\n  }\n  if (!defined(port) || port <= 0) {\n    throw new DeveloperError(\"port is required to be greater than 0.\");\n  }\n  //>>includeEnd('debug');\n\n  const authority = `${host.toLowerCase()}:${port}`;\n  if (!defined(_servers[authority])) {\n    _servers[authority] = true;\n  }\n};\n\n/**\n * Removes a trusted server from the registry\n *\n * @param {string} host The host to be removed.\n * @param {number} port The port used to access the host.\n *\n * @example\n * // Remove a trusted server\n * TrustedServers.remove('my.server.com', 80);\n */\nTrustedServers.remove = function (host, port) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(host)) {\n    throw new DeveloperError(\"host is required.\");\n  }\n  if (!defined(port) || port <= 0) {\n    throw new DeveloperError(\"port is required to be greater than 0.\");\n  }\n  //>>includeEnd('debug');\n\n  const authority = `${host.toLowerCase()}:${port}`;\n  if (defined(_servers[authority])) {\n    delete _servers[authority];\n  }\n};\n\nfunction getAuthority(url) {\n  const uri = new Uri(url);\n  uri.normalize();\n\n  // Removes username:password@ so we just have host[:port]\n  let authority = uri.authority();\n  if (authority.length === 0) {\n    return undefined; // Relative URL\n  }\n  uri.authority(authority);\n\n  if (authority.indexOf(\"@\") !== -1) {\n    const parts = authority.split(\"@\");\n    authority = parts[1];\n  }\n\n  // If the port is missing add one based on the scheme\n  if (authority.indexOf(\":\") === -1) {\n    let scheme = uri.scheme();\n    if (scheme.length === 0) {\n      scheme = window.location.protocol;\n      scheme = scheme.substring(0, scheme.length - 1);\n    }\n    if (scheme === \"http\") {\n      authority += \":80\";\n    } else if (scheme === \"https\") {\n      authority += \":443\";\n    } else {\n      return undefined;\n    }\n  }\n\n  return authority;\n}\n\n/**\n * Tests whether a server is trusted or not. The server must have been added with the port if it is included in the url.\n *\n * @param {string} url The url to be tested against the trusted list\n *\n * @returns {boolean} Returns true if url is trusted, false otherwise.\n *\n * @example\n * // Add server\n * TrustedServers.add('my.server.com', 81);\n *\n * // Check if server is trusted\n * if (TrustedServers.contains('https://my.server.com:81/path/to/file.png')) {\n *     // my.server.com:81 is trusted\n * }\n * if (TrustedServers.contains('https://my.server.com/path/to/file.png')) {\n *     // my.server.com isn't trusted\n * }\n */\nTrustedServers.contains = function (url) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(url)) {\n    throw new DeveloperError(\"url is required.\");\n  }\n  //>>includeEnd('debug');\n  const authority = getAuthority(url);\n  if (defined(authority) && defined(_servers[authority])) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Clears the registry\n *\n * @example\n * // Remove a trusted server\n * TrustedServers.clear();\n */\nTrustedServers.clear = function () {\n  _servers = {};\n};\nexport default TrustedServers;\n"],"names":["TrustedServers","_servers","add","host","port","authority","toLowerCase","remove","getAuthority","url","uri","normalize","length","undefined","indexOf","parts","split","scheme","window","location","protocol","substring","contains","clear"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;CAOC,GACD,MAAMA,iBAAiB,CAAC;AACxB,IAAIC,WAAW,CAAC;AAEhB;;;;;;;;;CASC,GACDD,eAAeE,GAAG,GAAG,SAAUC,IAAI,EAAEC,IAAI;IACvC,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACD,OAAO;QAClB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACC,SAASA,QAAQ,GAAG;QAC/B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAMC,YAAY,GAAGF,KAAKG,WAAW,GAAG,CAAC,EAAEF,MAAM;IACjD,IAAI,CAAC,IAAA,6KAAO,EAACH,QAAQ,CAACI,UAAU,GAAG;QACjCJ,QAAQ,CAACI,UAAU,GAAG;IACxB;AACF;AAEA;;;;;;;;;CASC,GACDL,eAAeO,MAAM,GAAG,SAAUJ,IAAI,EAAEC,IAAI;IAC1C,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACD,OAAO;QAClB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACC,SAASA,QAAQ,GAAG;QAC/B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAMC,YAAY,GAAGF,KAAKG,WAAW,GAAG,CAAC,EAAEF,MAAM;IACjD,IAAI,IAAA,6KAAO,EAACH,QAAQ,CAACI,UAAU,GAAG;QAChC,OAAOJ,QAAQ,CAACI,UAAU;IAC5B;AACF;AAEA,SAASG,aAAaC,GAAG;IACvB,MAAMC,MAAM,IAAI,iJAAG,CAACD;IACpBC,IAAIC,SAAS;IAEb,yDAAyD;IACzD,IAAIN,YAAYK,IAAIL,SAAS;IAC7B,IAAIA,UAAUO,MAAM,KAAK,GAAG;QAC1B,OAAOC,WAAW,eAAe;IACnC;IACAH,IAAIL,SAAS,CAACA;IAEd,IAAIA,UAAUS,OAAO,CAAC,SAAS,CAAC,GAAG;QACjC,MAAMC,QAAQV,UAAUW,KAAK,CAAC;QAC9BX,YAAYU,KAAK,CAAC,EAAE;IACtB;IAEA,qDAAqD;IACrD,IAAIV,UAAUS,OAAO,CAAC,SAAS,CAAC,GAAG;QACjC,IAAIG,SAASP,IAAIO,MAAM;QACvB,IAAIA,OAAOL,MAAM,KAAK,GAAG;YACvBK,SAASC,OAAOC,QAAQ,CAACC,QAAQ;YACjCH,SAASA,OAAOI,SAAS,CAAC,GAAGJ,OAAOL,MAAM,GAAG;QAC/C;QACA,IAAIK,WAAW,QAAQ;YACrBZ,aAAa;QACf,OAAO,IAAIY,WAAW,SAAS;YAC7BZ,aAAa;QACf,OAAO;YACL,OAAOQ;QACT;IACF;IAEA,OAAOR;AACT;AAEA;;;;;;;;;;;;;;;;;;CAkBC,GACDL,eAAesB,QAAQ,GAAG,SAAUb,GAAG;IACrC,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACA,MAAM;QACjB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IACxB,MAAMJ,YAAYG,aAAaC;IAC/B,IAAI,IAAA,6KAAO,EAACJ,cAAc,IAAA,6KAAO,EAACJ,QAAQ,CAACI,UAAU,GAAG;QACtD,OAAO;IACT;IAEA,OAAO;AACT;AAEA;;;;;;CAMC,GACDL,eAAeuB,KAAK,GAAG;IACrBtB,WAAW,CAAC;AACd;uCACeD","ignoreList":[0]}},
    {"offset": {"line": 3326, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Resource.js"],"sourcesContent":["import Uri from \"urijs\";\nimport appendForwardSlash from \"./appendForwardSlash.js\";\nimport Check from \"./Check.js\";\nimport clone from \"./clone.js\";\nimport combine from \"./combine.js\";\nimport Frozen from \"./Frozen.js\";\nimport defer from \"./defer.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport getAbsoluteUri from \"./getAbsoluteUri.js\";\nimport getBaseUri from \"./getBaseUri.js\";\nimport getExtensionFromUri from \"./getExtensionFromUri.js\";\nimport getImagePixels from \"./getImagePixels.js\";\nimport isBlobUri from \"./isBlobUri.js\";\nimport isCrossOriginUrl from \"./isCrossOriginUrl.js\";\nimport isDataUri from \"./isDataUri.js\";\nimport loadAndExecuteScript from \"./loadAndExecuteScript.js\";\nimport CesiumMath from \"./Math.js\";\nimport objectToQuery from \"./objectToQuery.js\";\nimport queryToObject from \"./queryToObject.js\";\nimport Request from \"./Request.js\";\nimport RequestErrorEvent from \"./RequestErrorEvent.js\";\nimport RequestScheduler from \"./RequestScheduler.js\";\nimport RequestState from \"./RequestState.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TrustedServers from \"./TrustedServers.js\";\n\nconst xhrBlobSupported = (function () {\n  try {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", \"#\", true);\n    xhr.responseType = \"blob\";\n    return xhr.responseType === \"blob\";\n  } catch (e) {\n    return false;\n  }\n})();\n\n/**\n * @typedef {object} Resource.ConstructorOptions\n *\n * Initialization options for the Resource constructor\n *\n * @property {string} url The url of the resource.\n * @property {object} [queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @property {object} [templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @property {object} [headers={}] Additional HTTP headers that will be sent.\n * @property {Proxy} [proxy] A proxy to be used when loading the resource.\n * @property {Resource.RetryCallback} [retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @property {number} [retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @property {Request} [request] A Request object that will be used. Intended for internal use only.\n * @property {boolean} [parseUrl=true] If true, parse the url for query parameters; otherwise store the url without change\n */\n\n/**\n * A resource that includes the location and any other parameters we need to retrieve it or create derived resources. It also provides the ability to retry requests.\n *\n * @alias Resource\n * @constructor\n *\n * @param {string|Resource.ConstructorOptions} options A url or an object describing initialization options\n *\n * @example\n * function refreshTokenRetryCallback(resource, error) {\n *   if (error.statusCode === 403) {\n *     // 403 status code means a new token should be generated\n *     return getNewAccessToken()\n *       .then(function(token) {\n *         resource.queryParameters.access_token = token;\n *         return true;\n *       })\n *       .catch(function() {\n *         return false;\n *       });\n *   }\n *\n *   return false;\n * }\n *\n * const resource = new Resource({\n *    url: 'http://server.com/path/to/resource.json',\n *    proxy: new DefaultProxy('/proxy/'),\n *    headers: {\n *      'X-My-Header': 'valueOfHeader'\n *    },\n *    queryParameters: {\n *      'access_token': '123-435-456-000'\n *    },\n *    retryCallback: refreshTokenRetryCallback,\n *    retryAttempts: 1\n * });\n */\nfunction Resource(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  if (typeof options === \"string\") {\n    options = {\n      url: options,\n    };\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.url\", options.url);\n  //>>includeEnd('debug');\n\n  this._url = undefined;\n  this._templateValues = defaultClone(options.templateValues, {});\n  this._queryParameters = defaultClone(options.queryParameters, {});\n\n  /**\n   * Additional HTTP headers that will be sent with the request.\n   *\n   * @type {object}\n   */\n  this.headers = defaultClone(options.headers, {});\n\n  /**\n   * A Request object that will be used. Intended for internal use only.\n   *\n   * @type {Request}\n   */\n  this.request = options.request ?? new Request();\n\n  /**\n   * A proxy to be used when loading the resource.\n   *\n   * @type {Proxy}\n   */\n  this.proxy = options.proxy;\n\n  /**\n   * Function to call when a request for this resource fails. If it returns true or a Promise that resolves to true, the request will be retried.\n   *\n   * @type {Function}\n   */\n  this.retryCallback = options.retryCallback;\n\n  /**\n   * The number of times the retryCallback should be called before giving up.\n   *\n   * @type {number}\n   */\n  this.retryAttempts = options.retryAttempts ?? 0;\n  this._retryCount = 0;\n\n  const parseUrl = options.parseUrl ?? true;\n  if (parseUrl) {\n    this.parseUrl(options.url, true, true);\n  } else {\n    this._url = options.url;\n  }\n\n  this._credits = options.credits;\n}\n\n/**\n * Clones a value if it is defined, otherwise returns the default value\n *\n * @param {object} [value] The value to clone.\n * @param {object} [defaultValue] The default value.\n *\n * @returns {object} A clone of value or the defaultValue.\n *\n * @private\n */\nfunction defaultClone(value, defaultValue) {\n  return defined(value) ? clone(value) : defaultValue;\n}\n\n/**\n * A helper function to create a resource depending on whether we have a String or a Resource\n *\n * @param {Resource|string} resource A Resource or a String to use when creating a new Resource.\n *\n * @returns {Resource} If resource is a String, a Resource constructed with the url and options. Otherwise the resource parameter is returned.\n *\n * @private\n */\nResource.createIfNeeded = function (resource) {\n  if (resource instanceof Resource) {\n    // Keep existing request object. This function is used internally to duplicate a Resource, so that it can't\n    //  be modified outside of a class that holds it (eg. an imagery or terrain provider). Since the Request objects\n    //  are managed outside of the providers, by the tile loading code, we want to keep the request property the same so if it is changed\n    //  in the underlying tiling code the requests for this resource will use it.\n    return resource.getDerivedResource({\n      request: resource.request,\n    });\n  }\n\n  if (typeof resource !== \"string\") {\n    return resource;\n  }\n\n  return new Resource({\n    url: resource,\n  });\n};\n\nlet supportsImageBitmapOptionsPromise;\n/**\n * A helper function to check whether createImageBitmap supports passing ImageBitmapOptions.\n *\n * @returns {Promise<boolean>} A promise that resolves to true if this browser supports creating an ImageBitmap with options.\n *\n * @private\n */\nResource.supportsImageBitmapOptions = function () {\n  // Until the HTML folks figure out what to do about this, we need to actually try loading an image to\n  // know if this browser supports passing options to the createImageBitmap function.\n  // https://github.com/whatwg/html/pull/4248\n  //\n  // We also need to check whether the colorSpaceConversion option is supported.\n  // We do this by loading a PNG with an embedded color profile, first with\n  // colorSpaceConversion: \"none\" and then with colorSpaceConversion: \"default\".\n  // If the pixel color is different then we know the option is working.\n  // As of Webkit 17612.3.6.1.6 the createImageBitmap promise resolves but the\n  // option is not actually supported.\n  if (defined(supportsImageBitmapOptionsPromise)) {\n    return supportsImageBitmapOptionsPromise;\n  }\n\n  if (typeof createImageBitmap !== \"function\") {\n    supportsImageBitmapOptionsPromise = Promise.resolve(false);\n    return supportsImageBitmapOptionsPromise;\n  }\n\n  const imageDataUri =\n    \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAABGdBTUEAAE4g3rEiDgAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAADElEQVQI12Ng6GAAAAEUAIngE3ZiAAAAAElFTkSuQmCC\";\n\n  supportsImageBitmapOptionsPromise = Resource.fetchBlob({\n    url: imageDataUri,\n  })\n    .then(function (blob) {\n      const imageBitmapOptions = {\n        // 'from-image' is deprecated, new option is 'none'. However, we still need to support older browsers,\n        // and there's no good way to detect support for these options. For now, continue to use 'from-image'. See: https://github.com/CesiumGS/cesium/issues/12846\n        imageOrientation: \"flipY\", // default is \"from-image\"\n        premultiplyAlpha: \"none\", // default is \"default\"\n        colorSpaceConversion: \"none\", // default is \"default\"\n      };\n      return Promise.all([\n        createImageBitmap(blob, imageBitmapOptions),\n        createImageBitmap(blob),\n      ]);\n    })\n    .then(function (imageBitmaps) {\n      // Check whether the colorSpaceConversion option had any effect on the green channel\n      const colorWithOptions = getImagePixels(imageBitmaps[0]);\n      const colorWithDefaults = getImagePixels(imageBitmaps[1]);\n      return colorWithOptions[1] !== colorWithDefaults[1];\n    })\n    .catch(function () {\n      return false;\n    });\n\n  return supportsImageBitmapOptionsPromise;\n};\n\nObject.defineProperties(Resource, {\n  /**\n   * Returns true if blobs are supported.\n   *\n   * @memberof Resource\n   * @type {boolean}\n   *\n   * @readonly\n   */\n  isBlobSupported: {\n    get: function () {\n      return xhrBlobSupported;\n    },\n  },\n});\n\nObject.defineProperties(Resource.prototype, {\n  /**\n   * Query parameters appended to the url.\n   *\n   * @memberof Resource.prototype\n   * @type {object}\n   *\n   * @readonly\n   */\n  queryParameters: {\n    get: function () {\n      return this._queryParameters;\n    },\n  },\n\n  /**\n   * The key/value pairs used to replace template parameters in the url.\n   *\n   * @memberof Resource.prototype\n   * @type {object}\n   *\n   * @readonly\n   */\n  templateValues: {\n    get: function () {\n      return this._templateValues;\n    },\n  },\n\n  /**\n   * The url to the resource with template values replaced, query string appended and encoded by proxy if one was set.\n   *\n   * @memberof Resource.prototype\n   * @type {string}\n   */\n  url: {\n    get: function () {\n      return this.getUrlComponent(true, true);\n    },\n    set: function (value) {\n      this.parseUrl(value, false, false);\n    },\n  },\n\n  /**\n   * The file extension of the resource.\n   *\n   * @memberof Resource.prototype\n   * @type {string}\n   *\n   * @readonly\n   */\n  extension: {\n    get: function () {\n      return getExtensionFromUri(this._url);\n    },\n  },\n\n  /**\n   * True if the Resource refers to a data URI.\n   *\n   * @memberof Resource.prototype\n   * @type {boolean}\n   */\n  isDataUri: {\n    get: function () {\n      return isDataUri(this._url);\n    },\n  },\n\n  /**\n   * True if the Resource refers to a blob URI.\n   *\n   * @memberof Resource.prototype\n   * @type {boolean}\n   */\n  isBlobUri: {\n    get: function () {\n      return isBlobUri(this._url);\n    },\n  },\n\n  /**\n   * True if the Resource refers to a cross origin URL.\n   *\n   * @memberof Resource.prototype\n   * @type {boolean}\n   */\n  isCrossOriginUrl: {\n    get: function () {\n      return isCrossOriginUrl(this._url);\n    },\n  },\n\n  /**\n   * True if the Resource has request headers. This is equivalent to checking if the headers property has any keys.\n   *\n   * @memberof Resource.prototype\n   * @type {boolean}\n   */\n  hasHeaders: {\n    get: function () {\n      return Object.keys(this.headers).length > 0;\n    },\n  },\n\n  /**\n   * Gets the credits required for attribution of an asset.\n   * @private\n   */\n  credits: {\n    get: function () {\n      return this._credits;\n    },\n  },\n});\n\n/**\n * Override Object#toString so that implicit string conversion gives the\n * complete URL represented by this Resource.\n *\n * @returns {string} The URL represented by this Resource\n */\nResource.prototype.toString = function () {\n  return this.getUrlComponent(true, true);\n};\n\n/**\n * Parse a url string, and store its info\n *\n * @param {string} url The input url string.\n * @param {boolean} merge If true, we'll merge with the resource's existing queryParameters. Otherwise they will be replaced.\n * @param {boolean} preserveQuery If true duplicate parameters will be concatenated into an array. If false, keys in url will take precedence.\n * @param {string} [baseUrl] If supplied, and input url is a relative url, it will be made absolute relative to baseUrl\n *\n * @private\n */\nResource.prototype.parseUrl = function (url, merge, preserveQuery, baseUrl) {\n  let uri = new Uri(url);\n  const query = parseQueryString(uri.query());\n\n  this._queryParameters = merge\n    ? combineQueryParameters(query, this.queryParameters, preserveQuery)\n    : query;\n\n  // Remove unneeded info from the Uri\n  uri.search(\"\");\n  uri.fragment(\"\");\n\n  if (defined(baseUrl) && uri.scheme() === \"\") {\n    uri = uri.absoluteTo(getAbsoluteUri(baseUrl));\n  }\n\n  this._url = uri.toString();\n};\n\n/**\n * Parses a query string and returns the object equivalent.\n *\n * @param {string} queryString The query string\n * @returns {object}\n *\n * @private\n */\nfunction parseQueryString(queryString) {\n  if (queryString.length === 0) {\n    return {};\n  }\n\n  // Special case where the querystring is just a string, not key/value pairs\n  if (queryString.indexOf(\"=\") === -1) {\n    return { [queryString]: undefined };\n  }\n\n  return queryToObject(queryString);\n}\n\n/**\n * This combines a map of query parameters.\n *\n * @param {object} q1 The first map of query parameters. Values in this map will take precedence if preserveQueryParameters is false.\n * @param {object} q2 The second map of query parameters.\n * @param {boolean} preserveQueryParameters If true duplicate parameters will be concatenated into an array. If false, keys in q1 will take precedence.\n *\n * @returns {object} The combined map of query parameters.\n *\n * @example\n * const q1 = {\n *   a: 1,\n *   b: 2\n * };\n * const q2 = {\n *   a: 3,\n *   c: 4\n * };\n * const q3 = {\n *   b: [5, 6],\n *   d: 7\n * }\n *\n * // Returns\n * // {\n * //   a: [1, 3],\n * //   b: 2,\n * //   c: 4\n * // };\n * combineQueryParameters(q1, q2, true);\n *\n * // Returns\n * // {\n * //   a: 1,\n * //   b: 2,\n * //   c: 4\n * // };\n * combineQueryParameters(q1, q2, false);\n *\n * // Returns\n * // {\n * //   a: 1,\n * //   b: [2, 5, 6],\n * //   d: 7\n * // };\n * combineQueryParameters(q1, q3, true);\n *\n * // Returns\n * // {\n * //   a: 1,\n * //   b: 2,\n * //   d: 7\n * // };\n * combineQueryParameters(q1, q3, false);\n *\n * @private\n */\nfunction combineQueryParameters(q1, q2, preserveQueryParameters) {\n  if (!preserveQueryParameters) {\n    return combine(q1, q2);\n  }\n\n  const result = clone(q1, true);\n  for (const param in q2) {\n    if (q2.hasOwnProperty(param)) {\n      let value = result[param];\n      const q2Value = q2[param];\n      if (defined(value)) {\n        if (!Array.isArray(value)) {\n          value = result[param] = [value];\n        }\n\n        result[param] = value.concat(q2Value);\n      } else {\n        result[param] = Array.isArray(q2Value) ? q2Value.slice() : q2Value;\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Returns the url, optional with the query string and processed by a proxy.\n *\n * @param {boolean} [query=false] If true, the query string is included.\n * @param {boolean} [proxy=false] If true, the url is processed by the proxy object, if defined.\n *\n * @returns {string} The url with all the requested components.\n */\nResource.prototype.getUrlComponent = function (query, proxy) {\n  if (this.isDataUri) {\n    return this._url;\n  }\n\n  let url = this._url;\n  if (query) {\n    url = `${url}${stringifyQuery(this.queryParameters)}`;\n  }\n\n  // Restore the placeholders, which may have been escaped in objectToQuery or elsewhere\n  url = url.replace(/%7B/g, \"{\").replace(/%7D/g, \"}\");\n\n  const templateValues = this._templateValues;\n  if (Object.keys(templateValues).length > 0) {\n    url = url.replace(/{(.*?)}/g, function (match, key) {\n      const replacement = templateValues[key];\n      if (defined(replacement)) {\n        // use the replacement value from templateValues if there is one...\n        return encodeURIComponent(replacement);\n      }\n      // otherwise leave it unchanged\n      return match;\n    });\n  }\n\n  if (proxy && defined(this.proxy)) {\n    url = this.proxy.getURL(url);\n  }\n\n  return url;\n};\n\n/**\n * Converts a query object into a string.\n *\n * @param {object} queryObject The object with query parameters\n * @returns {string}\n *\n * @private\n */\nfunction stringifyQuery(queryObject) {\n  const keys = Object.keys(queryObject);\n\n  if (keys.length === 0) {\n    return \"\";\n  }\n  if (keys.length === 1 && !defined(queryObject[keys[0]])) {\n    // We have 1 key with an undefined value, so this is just a string, not key/value pairs\n    return `?${keys[0]}`;\n  }\n\n  return `?${objectToQuery(queryObject)}`;\n}\n\n/**\n * Combines the specified object and the existing query parameters. This allows you to add many parameters at once,\n *  as opposed to adding them one at a time to the queryParameters property. If a value is already set, it will be replaced with the new value.\n *\n * @param {object} params The query parameters\n * @param {boolean} [useAsDefault=false] If true the params will be used as the default values, so they will only be set if they are undefined.\n */\nResource.prototype.setQueryParameters = function (params, useAsDefault) {\n  if (useAsDefault) {\n    this._queryParameters = combineQueryParameters(\n      this._queryParameters,\n      params,\n      false,\n    );\n  } else {\n    this._queryParameters = combineQueryParameters(\n      params,\n      this._queryParameters,\n      false,\n    );\n  }\n};\n\n/**\n * Combines the specified object and the existing query parameters. This allows you to add many parameters at once,\n *  as opposed to adding them one at a time to the queryParameters property.\n *\n * @param {object} params The query parameters\n */\nResource.prototype.appendQueryParameters = function (params) {\n  this._queryParameters = combineQueryParameters(\n    params,\n    this._queryParameters,\n    true,\n  );\n};\n\n/**\n * Combines the specified object and the existing template values. This allows you to add many values at once,\n *  as opposed to adding them one at a time to the templateValues property. If a value is already set, it will become an array and the new value will be appended.\n *\n * @param {object} template The template values\n * @param {boolean} [useAsDefault=false] If true the values will be used as the default values, so they will only be set if they are undefined.\n */\nResource.prototype.setTemplateValues = function (template, useAsDefault) {\n  if (useAsDefault) {\n    this._templateValues = combine(this._templateValues, template);\n  } else {\n    this._templateValues = combine(template, this._templateValues);\n  }\n};\n\n/**\n * Returns a resource relative to the current instance. All properties remain the same as the current instance unless overridden in options.\n *\n * @param {object} options An object with the following properties\n * @param {string} [options.url]  The url that will be resolved relative to the url of the current instance.\n * @param {object} [options.queryParameters] An object containing query parameters that will be combined with those of the current instance.\n * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}). These will be combined with those of the current instance.\n * @param {object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The function to call when loading the resource fails.\n * @param {number} [options.retryAttempts] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {boolean} [options.preserveQueryParameters=false] If true, this will keep all query parameters from the current resource and derived resource. If false, derived parameters will replace those of the current resource.\n *\n * @returns {Resource} The resource derived from the current one.\n */\nResource.prototype.getDerivedResource = function (options) {\n  const resource = this.clone();\n  resource._retryCount = 0;\n\n  if (defined(options.url)) {\n    const preserveQuery = options.preserveQueryParameters ?? false;\n    resource.parseUrl(options.url, true, preserveQuery, this._url);\n  }\n\n  if (defined(options.queryParameters)) {\n    resource._queryParameters = combine(\n      options.queryParameters,\n      resource.queryParameters,\n    );\n  }\n  if (defined(options.templateValues)) {\n    resource._templateValues = combine(\n      options.templateValues,\n      resource.templateValues,\n    );\n  }\n  if (defined(options.headers)) {\n    resource.headers = combine(options.headers, resource.headers);\n  }\n  if (defined(options.proxy)) {\n    resource.proxy = options.proxy;\n  }\n  if (defined(options.request)) {\n    resource.request = options.request;\n  }\n  if (defined(options.retryCallback)) {\n    resource.retryCallback = options.retryCallback;\n  }\n  if (defined(options.retryAttempts)) {\n    resource.retryAttempts = options.retryAttempts;\n  }\n\n  return resource;\n};\n\n/**\n * Called when a resource fails to load. This will call the retryCallback function if defined until retryAttempts is reached.\n *\n * @param {RequestErrorEvent} [error] The error that was encountered.\n *\n * @returns {Promise<boolean>} A promise to a boolean, that if true will cause the resource request to be retried.\n *\n * @private\n */\nResource.prototype.retryOnError = function (error) {\n  const retryCallback = this.retryCallback;\n  if (\n    typeof retryCallback !== \"function\" ||\n    this._retryCount >= this.retryAttempts\n  ) {\n    return Promise.resolve(false);\n  }\n\n  const that = this;\n  return Promise.resolve(retryCallback(this, error)).then(function (result) {\n    ++that._retryCount;\n\n    return result;\n  });\n};\n\n/**\n * Duplicates a Resource instance.\n *\n * @param {Resource} [result] The object onto which to store the result.\n *\n * @returns {Resource} The modified result parameter or a new Resource instance if one was not provided.\n */\nResource.prototype.clone = function (result) {\n  if (!defined(result)) {\n    return new Resource({\n      url: this._url,\n      queryParameters: this.queryParameters,\n      templateValues: this.templateValues,\n      headers: this.headers,\n      proxy: this.proxy,\n      retryCallback: this.retryCallback,\n      retryAttempts: this.retryAttempts,\n      request: this.request.clone(),\n      parseUrl: false,\n      credits: defined(this.credits) ? this.credits.slice() : undefined,\n    });\n  }\n\n  result._url = this._url;\n  result._queryParameters = clone(this._queryParameters);\n  result._templateValues = clone(this._templateValues);\n  result.headers = clone(this.headers);\n  result.proxy = this.proxy;\n  result.retryCallback = this.retryCallback;\n  result.retryAttempts = this.retryAttempts;\n  result._retryCount = 0;\n  result.request = this.request.clone();\n\n  return result;\n};\n\n/**\n * Returns the base path of the Resource.\n *\n * @param {boolean} [includeQuery = false] Whether or not to include the query string and fragment form the uri\n *\n * @returns {string} The base URI of the resource\n */\nResource.prototype.getBaseUri = function (includeQuery) {\n  return getBaseUri(this.getUrlComponent(includeQuery), includeQuery);\n};\n\n/**\n * Appends a forward slash to the URL.\n */\nResource.prototype.appendForwardSlash = function () {\n  this._url = appendForwardSlash(this._url);\n};\n\n/**\n * Asynchronously loads the resource as raw binary data.  Returns a promise that will resolve to\n * an ArrayBuffer once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @returns {Promise<ArrayBuffer>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n * @example\n * // load a single URL asynchronously\n * resource.fetchArrayBuffer().then(function(arrayBuffer) {\n *     // use the data\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.fetchArrayBuffer = function () {\n  return this.fetch({\n    responseType: \"arraybuffer\",\n  });\n};\n\n/**\n * Creates a Resource and calls fetchArrayBuffer() on it.\n *\n * @param {string|object} options A url or an object with the following properties\n * @param {string} options.url The url of the resource.\n * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @returns {Promise<ArrayBuffer>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.fetchArrayBuffer = function (options) {\n  const resource = new Resource(options);\n  return resource.fetchArrayBuffer();\n};\n\n/**\n * Asynchronously loads the given resource as a blob.  Returns a promise that will resolve to\n * a Blob once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @returns {Promise<Blob>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n * @example\n * // load a single URL asynchronously\n * resource.fetchBlob().then(function(blob) {\n *     // use the data\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.fetchBlob = function () {\n  return this.fetch({\n    responseType: \"blob\",\n  });\n};\n\n/**\n * Creates a Resource and calls fetchBlob() on it.\n *\n * @param {string|object} options A url or an object with the following properties\n * @param {string} options.url The url of the resource.\n * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @returns {Promise<Blob>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.fetchBlob = function (options) {\n  const resource = new Resource(options);\n  return resource.fetchBlob();\n};\n\n/**\n * Asynchronously loads the given image resource.  Returns a promise that will resolve to\n * an {@link https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap|ImageBitmap} if <code>preferImageBitmap</code> is true and the browser supports <code>createImageBitmap</code> or otherwise an\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement|Image} once loaded, or reject if the image failed to load.\n *\n * @param {object} [options] An object with the following properties.\n * @param {boolean} [options.preferBlob=false] If true, we will load the image via a blob.\n * @param {boolean} [options.preferImageBitmap=false] If true, image will be decoded during fetch and an <code>ImageBitmap</code> is returned.\n * @param {boolean} [options.flipY=false] If true, image will be vertically flipped during decode. Only applies if the browser supports <code>createImageBitmap</code>.\n * @param {boolean} [options.skipColorSpaceConversion=false] If true, any custom gamma or color profiles in the image will be ignored. Only applies if the browser supports <code>createImageBitmap</code>.\n * @returns {Promise<ImageBitmap|HTMLImageElement>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * // load a single image asynchronously\n * resource.fetchImage().then(function(image) {\n *     // use the loaded image\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n * // load several images in parallel\n * Promise.all([resource1.fetchImage(), resource2.fetchImage()]).then(function(images) {\n *     // images is an array containing all the loaded images\n * });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.fetchImage = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const preferImageBitmap = options.preferImageBitmap ?? false;\n  const preferBlob = options.preferBlob ?? false;\n  const flipY = options.flipY ?? false;\n  const skipColorSpaceConversion = options.skipColorSpaceConversion ?? false;\n\n  checkAndResetRequest(this.request);\n  // We try to load the image normally if\n  // 1. Blobs aren't supported\n  // 2. It's a data URI\n  // 3. It's a blob URI\n  // 4. It doesn't have request headers and we preferBlob is false\n  if (\n    !xhrBlobSupported ||\n    this.isDataUri ||\n    this.isBlobUri ||\n    (!this.hasHeaders && !preferBlob)\n  ) {\n    return this._fetchImage({\n      resource: this,\n      flipY: flipY,\n      skipColorSpaceConversion: skipColorSpaceConversion,\n      preferImageBitmap: preferImageBitmap,\n    });\n  }\n\n  const blobPromise = this.fetchBlob();\n  if (!defined(blobPromise)) {\n    return;\n  }\n\n  let supportsImageBitmap;\n  let useImageBitmap;\n  let generatedBlobResource;\n  let generatedBlob;\n  return Resource.supportsImageBitmapOptions()\n    .then(function (result) {\n      supportsImageBitmap = result;\n      useImageBitmap = supportsImageBitmap && preferImageBitmap;\n      return blobPromise;\n    })\n    .then(function (blob) {\n      if (!defined(blob)) {\n        return;\n      }\n      generatedBlob = blob;\n      if (useImageBitmap) {\n        return Resource.createImageBitmapFromBlob(blob, {\n          flipY: flipY,\n          premultiplyAlpha: false,\n          skipColorSpaceConversion: skipColorSpaceConversion,\n        });\n      }\n      const blobUrl = window.URL.createObjectURL(blob);\n      generatedBlobResource = new Resource({\n        url: blobUrl,\n      });\n\n      return generatedBlobResource._fetchImage({\n        flipY: flipY,\n        skipColorSpaceConversion: skipColorSpaceConversion,\n        preferImageBitmap: false,\n      });\n    })\n    .then(function (image) {\n      if (!defined(image)) {\n        return;\n      }\n\n      // The blob object may be needed for use by a TileDiscardPolicy,\n      // so attach it to the image.\n      image.blob = generatedBlob;\n\n      if (useImageBitmap) {\n        return image;\n      }\n\n      window.URL.revokeObjectURL(generatedBlobResource.url);\n      return image;\n    })\n    .catch(function (error) {\n      if (defined(generatedBlobResource)) {\n        window.URL.revokeObjectURL(generatedBlobResource.url);\n      }\n\n      // If the blob load succeeded but the image decode failed, attach the blob\n      // to the error object for use by a TileDiscardPolicy.\n      // In particular, BingMapsImageryProvider uses this to detect the\n      // zero-length response that is returned when a tile is not available.\n      error.blob = generatedBlob;\n\n      return Promise.reject(error);\n    });\n};\n\n/**\n * Fetches an image and returns a promise to it.\n * @param {object} [options] An object with the following properties.\n * @param {boolean} [options.preferImageBitmap] If true, image will be decoded during fetch and an <code>ImageBitmap</code> is returned.\n * @param {boolean} [options.flipY] If true, image will be vertically flipped during decode. Only applies if the browser supports <code>createImageBitmap</code>.\n * @param {boolean} [options.skipColorSpaceConversion=false] If true, any custom gamma or color profiles in the image will be ignored. Only applies if the browser supports <code>createImageBitmap</code>.\n * @returns {Promise<ImageBitmap|HTMLImageElement>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if the request has been throttled and cannot be made at this time.\n * @private\n */\nResource.prototype._fetchImage = function (options) {\n  const resource = this;\n  const flipY = options.flipY;\n  const skipColorSpaceConversion = options.skipColorSpaceConversion;\n  const preferImageBitmap = options.preferImageBitmap;\n\n  const request = resource.request;\n  request.url = resource.url;\n  request.requestFunction = function () {\n    let crossOrigin = false;\n\n    // data URIs can't have crossorigin set.\n    if (!resource.isDataUri && !resource.isBlobUri) {\n      crossOrigin = resource.isCrossOriginUrl;\n    }\n\n    const deferred = defer();\n    Resource._Implementations.createImage(\n      request,\n      crossOrigin,\n      deferred,\n      flipY,\n      skipColorSpaceConversion,\n      preferImageBitmap,\n    );\n\n    return deferred.promise;\n  };\n\n  const promise = RequestScheduler.request(request);\n  if (!defined(promise)) {\n    return;\n  }\n\n  return promise.catch(function (e) {\n    // Don't retry cancelled or otherwise aborted requests\n    if (request.state !== RequestState.FAILED) {\n      return Promise.reject(e);\n    }\n    return resource.retryOnError(e).then(function (retry) {\n      if (retry) {\n        // Reset request so it can try again\n        request.state = RequestState.UNISSUED;\n        request.deferred = undefined;\n\n        return resource._fetchImage({\n          flipY: flipY,\n          skipColorSpaceConversion: skipColorSpaceConversion,\n          preferImageBitmap: preferImageBitmap,\n        });\n      }\n      return Promise.reject(e);\n    });\n  });\n};\n\n/**\n * Creates a Resource and calls fetchImage() on it.\n *\n * @param {string|object} options A url or an object with the following properties\n * @param {string} options.url The url of the resource.\n * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {boolean} [options.flipY=false] Whether to vertically flip the image during fetch and decode. Only applies when requesting an image and the browser supports <code>createImageBitmap</code>.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {boolean} [options.preferBlob=false]  If true, we will load the image via a blob.\n * @param {boolean} [options.preferImageBitmap=false] If true, image will be decoded during fetch and an <code>ImageBitmap</code> is returned.\n * @param {boolean} [options.skipColorSpaceConversion=false] If true, any custom gamma or color profiles in the image will be ignored. Only applies when requesting an image and the browser supports <code>createImageBitmap</code>.\n * @returns {Promise<ImageBitmap|HTMLImageElement>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.fetchImage = function (options) {\n  const resource = new Resource(options);\n  return resource.fetchImage({\n    flipY: options.flipY,\n    skipColorSpaceConversion: options.skipColorSpaceConversion,\n    preferBlob: options.preferBlob,\n    preferImageBitmap: options.preferImageBitmap,\n  });\n};\n\n/**\n * Asynchronously loads the given resource as text.  Returns a promise that will resolve to\n * a String once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @returns {Promise<string>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n * @example\n * // load text from a URL, setting a custom header\n * const resource = new Resource({\n *   url: 'http://someUrl.com/someJson.txt',\n *   headers: {\n *     'X-Custom-Header' : 'some value'\n *   }\n * });\n * resource.fetchText().then(function(text) {\n *     // Do something with the text\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest|XMLHttpRequest}\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.fetchText = function () {\n  return this.fetch({\n    responseType: \"text\",\n  });\n};\n\n/**\n * Creates a Resource and calls fetchText() on it.\n *\n * @param {string|object} options A url or an object with the following properties\n * @param {string} options.url The url of the resource.\n * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @returns {Promise<string>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.fetchText = function (options) {\n  const resource = new Resource(options);\n  return resource.fetchText();\n};\n\n// note: &#42;&#47;&#42; below is */* but that ends the comment block early\n/**\n * Asynchronously loads the given resource as JSON.  Returns a promise that will resolve to\n * a JSON object once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled. This function\n * adds 'Accept: application/json,&#42;&#47;&#42;;q=0.01' to the request headers, if not\n * already specified.\n *\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * resource.fetchJson().then(function(jsonData) {\n *     // Do something with the JSON object\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.fetchJson = function () {\n  const promise = this.fetch({\n    responseType: \"text\",\n    headers: {\n      Accept: \"application/json,*/*;q=0.01\",\n    },\n  });\n\n  if (!defined(promise)) {\n    return undefined;\n  }\n\n  return promise.then(function (value) {\n    if (!defined(value)) {\n      return;\n    }\n    return JSON.parse(value);\n  });\n};\n\n/**\n * Creates a Resource and calls fetchJson() on it.\n *\n * @param {string|object} options A url or an object with the following properties\n * @param {string} options.url The url of the resource.\n * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.fetchJson = function (options) {\n  const resource = new Resource(options);\n  return resource.fetchJson();\n};\n\n/**\n * Asynchronously loads the given resource as XML.  Returns a promise that will resolve to\n * an XML Document once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @returns {Promise<XMLDocument>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * // load XML from a URL, setting a custom header\n * Cesium.loadXML('http://someUrl.com/someXML.xml', {\n *   'X-Custom-Header' : 'some value'\n * }).then(function(document) {\n *     // Do something with the document\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest|XMLHttpRequest}\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.fetchXML = function () {\n  return this.fetch({\n    responseType: \"document\",\n    overrideMimeType: \"text/xml\",\n  });\n};\n\n/**\n * Creates a Resource and calls fetchXML() on it.\n *\n * @param {string|object} options A url or an object with the following properties\n * @param {string} options.url The url of the resource.\n * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @returns {Promise<XMLDocument>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.fetchXML = function (options) {\n  const resource = new Resource(options);\n  return resource.fetchXML();\n};\n\n/**\n * Requests a resource using JSONP.\n *\n * @param {string} [callbackParameterName='callback'] The callback parameter name that the server expects.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * // load a data asynchronously\n * resource.fetchJsonp().then(function(data) {\n *     // use the loaded data\n * }).catch(function(error) {\n *     // an error occurred\n * });\n *\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.fetchJsonp = function (callbackParameterName) {\n  callbackParameterName = callbackParameterName ?? \"callback\";\n\n  checkAndResetRequest(this.request);\n\n  //generate a unique function name\n  let functionName;\n  do {\n    functionName = `loadJsonp${CesiumMath.nextRandomNumber()\n      .toString()\n      .substring(2, 8)}`;\n  } while (defined(window[functionName]));\n\n  return fetchJsonp(this, callbackParameterName, functionName);\n};\n\nfunction fetchJsonp(resource, callbackParameterName, functionName) {\n  const callbackQuery = {};\n  callbackQuery[callbackParameterName] = functionName;\n  resource.setQueryParameters(callbackQuery);\n\n  const request = resource.request;\n  const url = resource.url;\n  request.url = url;\n  request.requestFunction = function () {\n    const deferred = defer();\n\n    //assign a function with that name in the global scope\n    window[functionName] = function (data) {\n      deferred.resolve(data);\n\n      try {\n        delete window[functionName];\n      } catch (e) {\n        window[functionName] = undefined;\n      }\n    };\n\n    Resource._Implementations.loadAndExecuteScript(url, functionName, deferred);\n    return deferred.promise;\n  };\n\n  const promise = RequestScheduler.request(request);\n  if (!defined(promise)) {\n    return;\n  }\n\n  return promise.catch(function (e) {\n    if (request.state !== RequestState.FAILED) {\n      return Promise.reject(e);\n    }\n\n    return resource.retryOnError(e).then(function (retry) {\n      if (retry) {\n        // Reset request so it can try again\n        request.state = RequestState.UNISSUED;\n        request.deferred = undefined;\n\n        return fetchJsonp(resource, callbackParameterName, functionName);\n      }\n\n      return Promise.reject(e);\n    });\n  });\n}\n\n/**\n * Creates a Resource from a URL and calls fetchJsonp() on it.\n *\n * @param {string|object} options A url or an object with the following properties\n * @param {string} options.url The url of the resource.\n * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {string} [options.callbackParameterName='callback'] The callback parameter name that the server expects.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.fetchJsonp = function (options) {\n  const resource = new Resource(options);\n  return resource.fetchJsonp(options.callbackParameterName);\n};\n\n/**\n * @private\n */\nResource.prototype._makeRequest = function (options) {\n  const resource = this;\n  checkAndResetRequest(resource.request);\n\n  const request = resource.request;\n  const url = resource.url;\n  request.url = url;\n\n  request.requestFunction = function () {\n    const responseType = options.responseType;\n    const headers = combine(options.headers, resource.headers);\n    const overrideMimeType = options.overrideMimeType;\n    const method = options.method;\n    const data = options.data;\n    const deferred = defer();\n    const xhr = Resource._Implementations.loadWithXhr(\n      url,\n      responseType,\n      method,\n      data,\n      headers,\n      deferred,\n      overrideMimeType,\n    );\n    if (defined(xhr) && defined(xhr.abort)) {\n      request.cancelFunction = function () {\n        xhr.abort();\n      };\n    }\n    return deferred.promise;\n  };\n\n  const promise = RequestScheduler.request(request);\n  if (!defined(promise)) {\n    return;\n  }\n\n  return promise\n    .then(function (data) {\n      // explicitly set to undefined to ensure GC of request response data. See #8843\n      request.cancelFunction = undefined;\n      return data;\n    })\n    .catch(function (e) {\n      request.cancelFunction = undefined;\n      if (request.state !== RequestState.FAILED) {\n        return Promise.reject(e);\n      }\n\n      return resource.retryOnError(e).then(function (retry) {\n        if (retry) {\n          // Reset request so it can try again\n          request.state = RequestState.UNISSUED;\n          request.deferred = undefined;\n\n          return resource.fetch(options);\n        }\n\n        return Promise.reject(e);\n      });\n    });\n};\n\n/**\n * Checks to make sure the Resource isn't already being requested.\n *\n * @param {Request} request The request to check.\n *\n * @private\n */\nfunction checkAndResetRequest(request) {\n  if (\n    request.state === RequestState.ISSUED ||\n    request.state === RequestState.ACTIVE\n  ) {\n    throw new RuntimeError(\"The Resource is already being fetched.\");\n  }\n\n  request.state = RequestState.UNISSUED;\n  request.deferred = undefined;\n}\n\nconst dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\nfunction decodeDataUriText(isBase64, data) {\n  const result = decodeURIComponent(data);\n  if (isBase64) {\n    return atob(result);\n  }\n  return result;\n}\n\nfunction decodeDataUriArrayBuffer(isBase64, data) {\n  const byteString = decodeDataUriText(isBase64, data);\n  const buffer = new ArrayBuffer(byteString.length);\n  const view = new Uint8Array(buffer);\n  for (let i = 0; i < byteString.length; i++) {\n    view[i] = byteString.charCodeAt(i);\n  }\n  return buffer;\n}\n\nfunction decodeDataUri(dataUriRegexResult, responseType) {\n  responseType = responseType ?? \"\";\n  const mimeType = dataUriRegexResult[1];\n  const isBase64 = !!dataUriRegexResult[2];\n  const data = dataUriRegexResult[3];\n  let buffer;\n  let parser;\n\n  switch (responseType) {\n    case \"\":\n    case \"text\":\n      return decodeDataUriText(isBase64, data);\n    case \"arraybuffer\":\n      return decodeDataUriArrayBuffer(isBase64, data);\n    case \"blob\":\n      buffer = decodeDataUriArrayBuffer(isBase64, data);\n      return new Blob([buffer], {\n        type: mimeType,\n      });\n    case \"document\":\n      parser = new DOMParser();\n      return parser.parseFromString(\n        decodeDataUriText(isBase64, data),\n        mimeType,\n      );\n    case \"json\":\n      return JSON.parse(decodeDataUriText(isBase64, data));\n    default:\n      //>>includeStart('debug', pragmas.debug);\n      throw new DeveloperError(`Unhandled responseType: ${responseType}`);\n    //>>includeEnd('debug');\n  }\n}\n\n/**\n * Asynchronously loads the given resource.  Returns a promise that will resolve to\n * the result once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled. It's recommended that you use\n * the more specific functions eg. fetchJson, fetchBlob, etc.\n *\n * @param {object} [options] Object with the following properties:\n * @param {string} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {object} [options.headers] Additional HTTP headers to send with the request, if any.\n * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * resource.fetch()\n *   .then(function(body) {\n *       // use the data\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.fetch = function (options) {\n  options = defaultClone(options, {});\n  options.method = \"GET\";\n\n  return this._makeRequest(options);\n};\n\n/**\n * Creates a Resource from a URL and calls fetch() on it.\n *\n * @param {string|object} options A url or an object with the following properties\n * @param {string} options.url The url of the resource.\n * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {string} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.fetch = function (options) {\n  const resource = new Resource(options);\n  return resource.fetch({\n    // Make copy of just the needed fields because headers can be passed to both the constructor and to fetch\n    responseType: options.responseType,\n    overrideMimeType: options.overrideMimeType,\n  });\n};\n\n/**\n * Asynchronously deletes the given resource.  Returns a promise that will resolve to\n * the result once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @param {object} [options] Object with the following properties:\n * @param {string} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {object} [options.headers] Additional HTTP headers to send with the request, if any.\n * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * resource.delete()\n *   .then(function(body) {\n *       // use the data\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.delete = function (options) {\n  options = defaultClone(options, {});\n  options.method = \"DELETE\";\n\n  return this._makeRequest(options);\n};\n\n/**\n * Creates a Resource from a URL and calls delete() on it.\n *\n * @param {string|object} options A url or an object with the following properties\n * @param {string} options.url The url of the resource.\n * @param {object} [options.data] Data that is posted with the resource.\n * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {string} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.delete = function (options) {\n  const resource = new Resource(options);\n  return resource.delete({\n    // Make copy of just the needed fields because headers can be passed to both the constructor and to fetch\n    responseType: options.responseType,\n    overrideMimeType: options.overrideMimeType,\n    data: options.data,\n  });\n};\n\n/**\n * Asynchronously gets headers the given resource.  Returns a promise that will resolve to\n * the result once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @param {object} [options] Object with the following properties:\n * @param {string} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {object} [options.headers] Additional HTTP headers to send with the request, if any.\n * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * resource.head()\n *   .then(function(headers) {\n *       // use the data\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.head = function (options) {\n  options = defaultClone(options, {});\n  options.method = \"HEAD\";\n\n  return this._makeRequest(options);\n};\n\n/**\n * Creates a Resource from a URL and calls head() on it.\n *\n * @param {string|object} options A url or an object with the following properties\n * @param {string} options.url The url of the resource.\n * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {string} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.head = function (options) {\n  const resource = new Resource(options);\n  return resource.head({\n    // Make copy of just the needed fields because headers can be passed to both the constructor and to fetch\n    responseType: options.responseType,\n    overrideMimeType: options.overrideMimeType,\n  });\n};\n\n/**\n * Asynchronously gets options the given resource.  Returns a promise that will resolve to\n * the result once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @param {object} [options] Object with the following properties:\n * @param {string} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {object} [options.headers] Additional HTTP headers to send with the request, if any.\n * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * resource.options()\n *   .then(function(headers) {\n *       // use the data\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.options = function (options) {\n  options = defaultClone(options, {});\n  options.method = \"OPTIONS\";\n\n  return this._makeRequest(options);\n};\n\n/**\n * Creates a Resource from a URL and calls options() on it.\n *\n * @param {string|object} options A url or an object with the following properties\n * @param {string} options.url The url of the resource.\n * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {string} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.options = function (options) {\n  const resource = new Resource(options);\n  return resource.options({\n    // Make copy of just the needed fields because headers can be passed to both the constructor and to fetch\n    responseType: options.responseType,\n    overrideMimeType: options.overrideMimeType,\n  });\n};\n\n/**\n * Asynchronously posts data to the given resource.  Returns a promise that will resolve to\n * the result once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @param {object} data Data that is posted with the resource.\n * @param {object} [options] Object with the following properties:\n * @param {object} [options.data] Data that is posted with the resource.\n * @param {string} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {object} [options.headers] Additional HTTP headers to send with the request, if any.\n * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * resource.post(data)\n *   .then(function(result) {\n *       // use the result\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.post = function (data, options) {\n  Check.defined(\"data\", data);\n\n  options = defaultClone(options, {});\n  options.method = \"POST\";\n  options.data = data;\n\n  return this._makeRequest(options);\n};\n\n/**\n * Creates a Resource from a URL and calls post() on it.\n *\n * @param {object} options A url or an object with the following properties\n * @param {string} options.url The url of the resource.\n * @param {object} options.data Data that is posted with the resource.\n * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {string} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.post = function (options) {\n  const resource = new Resource(options);\n  return resource.post(options.data, {\n    // Make copy of just the needed fields because headers can be passed to both the constructor and to post\n    responseType: options.responseType,\n    overrideMimeType: options.overrideMimeType,\n  });\n};\n\n/**\n * Asynchronously puts data to the given resource.  Returns a promise that will resolve to\n * the result once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @param {object} data Data that is posted with the resource.\n * @param {object} [options] Object with the following properties:\n * @param {string} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {object} [options.headers] Additional HTTP headers to send with the request, if any.\n * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * resource.put(data)\n *   .then(function(result) {\n *       // use the result\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.put = function (data, options) {\n  Check.defined(\"data\", data);\n\n  options = defaultClone(options, {});\n  options.method = \"PUT\";\n  options.data = data;\n\n  return this._makeRequest(options);\n};\n\n/**\n * Creates a Resource from a URL and calls put() on it.\n *\n * @param {object} options A url or an object with the following properties\n * @param {string} options.url The url of the resource.\n * @param {object} options.data Data that is posted with the resource.\n * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {string} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.put = function (options) {\n  const resource = new Resource(options);\n  return resource.put(options.data, {\n    // Make copy of just the needed fields because headers can be passed to both the constructor and to post\n    responseType: options.responseType,\n    overrideMimeType: options.overrideMimeType,\n  });\n};\n\n/**\n * Asynchronously patches data to the given resource.  Returns a promise that will resolve to\n * the result once loaded, or reject if the resource failed to load.  The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n *\n * @param {object} data Data that is posted with the resource.\n * @param {object} [options] Object with the following properties:\n * @param {string} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {object} [options.headers] Additional HTTP headers to send with the request, if any.\n * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n *\n * @example\n * resource.patch(data)\n *   .then(function(result) {\n *       // use the result\n *   }).catch(function(error) {\n *       // an error occurred\n *   });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n */\nResource.prototype.patch = function (data, options) {\n  Check.defined(\"data\", data);\n\n  options = defaultClone(options, {});\n  options.method = \"PATCH\";\n  options.data = data;\n\n  return this._makeRequest(options);\n};\n\n/**\n * Creates a Resource from a URL and calls patch() on it.\n *\n * @param {object} options A url or an object with the following properties\n * @param {string} options.url The url of the resource.\n * @param {object} options.data Data that is posted with the resource.\n * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.\n * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).\n * @param {object} [options.headers={}] Additional HTTP headers that will be sent.\n * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.\n * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.\n * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.\n * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.\n * @param {string} [options.responseType] The type of response.  This controls the type of item returned.\n * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.\n * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n */\nResource.patch = function (options) {\n  const resource = new Resource(options);\n  return resource.patch(options.data, {\n    // Make copy of just the needed fields because headers can be passed to both the constructor and to post\n    responseType: options.responseType,\n    overrideMimeType: options.overrideMimeType,\n  });\n};\n\n/**\n * Contains implementations of functions that can be replaced for testing\n *\n * @private\n */\nResource._Implementations = {};\n\nResource._Implementations.loadImageElement = function (\n  url,\n  crossOrigin,\n  deferred,\n) {\n  const image = new Image();\n\n  image.onload = function () {\n    // work-around a known issue with Firefox and dimensionless SVG, see:\n    //   - https://github.com/whatwg/html/issues/3510\n    //   - https://bugzilla.mozilla.org/show_bug.cgi?id=700533\n    if (\n      image.naturalWidth === 0 &&\n      image.naturalHeight === 0 &&\n      image.width === 0 &&\n      image.height === 0\n    ) {\n      // these values affect rasterization and will likely mar the content\n      // until Firefox takes a stance on the issue, marred content is better than no content\n      // Chromium uses a more refined heuristic about its choice given nil viewBox, and a better stance and solution is\n      // proposed later in the original issue thread:\n      //   - Chromium behavior: https://github.com/CesiumGS/cesium/issues/9188#issuecomment-704400825\n      //   - Cesium's stance/solve: https://github.com/CesiumGS/cesium/issues/9188#issuecomment-720645777\n      image.width = 300;\n      image.height = 150;\n    }\n    deferred.resolve(image);\n  };\n\n  image.onerror = function (e) {\n    deferred.reject(e);\n  };\n\n  if (crossOrigin) {\n    if (TrustedServers.contains(url)) {\n      image.crossOrigin = \"use-credentials\";\n    } else {\n      image.crossOrigin = \"\";\n    }\n  }\n\n  image.src = url;\n};\n\nResource._Implementations.createImage = function (\n  request,\n  crossOrigin,\n  deferred,\n  flipY,\n  skipColorSpaceConversion,\n  preferImageBitmap,\n  headers,\n) {\n  const url = request.url;\n  // Passing an Image to createImageBitmap will force it to run on the main thread\n  // since DOM elements don't exist on workers. We convert it to a blob so it's non-blocking.\n  // See:\n  //    https://bugzilla.mozilla.org/show_bug.cgi?id=1044102#c38\n  //    https://bugs.chromium.org/p/chromium/issues/detail?id=580202#c10\n  Resource.supportsImageBitmapOptions()\n    .then(function (supportsImageBitmap) {\n      // We can only use ImageBitmap if we can flip on decode.\n      // See: https://github.com/CesiumGS/cesium/pull/7579#issuecomment-466146898\n      if (!(supportsImageBitmap && preferImageBitmap)) {\n        Resource._Implementations.loadImageElement(url, crossOrigin, deferred);\n        return;\n      }\n      const responseType = \"blob\";\n      const method = \"GET\";\n      const xhrDeferred = defer();\n      const xhr = Resource._Implementations.loadWithXhr(\n        url,\n        responseType,\n        method,\n        undefined,\n        headers,\n        xhrDeferred,\n        undefined,\n        undefined,\n        undefined,\n      );\n\n      if (defined(xhr) && defined(xhr.abort)) {\n        request.cancelFunction = function () {\n          xhr.abort();\n        };\n      }\n      return xhrDeferred.promise\n        .then(function (blob) {\n          if (!defined(blob)) {\n            deferred.reject(\n              new RuntimeError(\n                `Successfully retrieved ${url} but it contained no content.`,\n              ),\n            );\n            return;\n          }\n\n          return Resource.createImageBitmapFromBlob(blob, {\n            flipY: flipY,\n            premultiplyAlpha: false,\n            skipColorSpaceConversion: skipColorSpaceConversion,\n          });\n        })\n        .then(function (image) {\n          deferred.resolve(image);\n        });\n    })\n    .catch(function (e) {\n      deferred.reject(e);\n    });\n};\n\n/**\n * Wrapper for createImageBitmap\n *\n * @private\n * @param {Blob} blob The image blob.\n * @param {object} options An object containing the following properties:\n * @param {boolean} options.flipY Whether to flip the image Y axis.\n * @param {boolean} options.premultiplyAlpha Whether to premultiply the alpha channel.\n * @param {boolean} options.skipColorSpaceConversion Whether to skip color space conversion.\n * @returns {Promise<ImageBitmap>} A promise that resolves to the created image bitmap.\n */\nResource.createImageBitmapFromBlob = function (blob, options) {\n  Check.defined(\"options\", options);\n  Check.typeOf.bool(\"options.flipY\", options.flipY);\n  Check.typeOf.bool(\"options.premultiplyAlpha\", options.premultiplyAlpha);\n  Check.typeOf.bool(\n    \"options.skipColorSpaceConversion\",\n    options.skipColorSpaceConversion,\n  );\n\n  return createImageBitmap(blob, {\n    // 'from-image' is deprecated, new option is 'none'. However, we still need to support older browsers,\n    // and there's no good way to detect support for these options. For now, continue to use 'from-image'. See: https://github.com/CesiumGS/cesium/issues/12846\n    imageOrientation: options.flipY ? \"flipY\" : \"none\",\n    premultiplyAlpha: options.premultiplyAlpha ? \"premultiply\" : \"none\",\n    colorSpaceConversion: options.skipColorSpaceConversion ? \"none\" : \"default\",\n  });\n};\n\nfunction loadWithHttpRequest(\n  url,\n  responseType,\n  method,\n  data,\n  headers,\n  deferred,\n  overrideMimeType,\n) {\n  // Note: only the 'json' and 'text' responseTypes transforms the loaded buffer\n  fetch(url, {\n    method,\n    headers,\n  })\n    .then(async (response) => {\n      if (!response.ok) {\n        const responseHeaders = {};\n        response.headers.forEach((value, key) => {\n          responseHeaders[key] = value;\n        });\n        deferred.reject(\n          new RequestErrorEvent(response.status, response, responseHeaders),\n        );\n        return;\n      }\n\n      switch (responseType) {\n        case \"text\":\n          deferred.resolve(response.text());\n          break;\n        case \"json\":\n          deferred.resolve(response.json());\n          break;\n        default:\n          deferred.resolve(new Uint8Array(await response.arrayBuffer()).buffer);\n          break;\n      }\n    })\n    .catch(() => {\n      deferred.reject(new RequestErrorEvent());\n    });\n}\n\nconst noXMLHttpRequest = typeof XMLHttpRequest === \"undefined\";\nResource._Implementations.loadWithXhr = function (\n  url,\n  responseType,\n  method,\n  data,\n  headers,\n  deferred,\n  overrideMimeType,\n) {\n  const dataUriRegexResult = dataUriRegex.exec(url);\n  if (dataUriRegexResult !== null) {\n    deferred.resolve(decodeDataUri(dataUriRegexResult, responseType));\n    return;\n  }\n\n  if (noXMLHttpRequest) {\n    loadWithHttpRequest(\n      url,\n      responseType,\n      method,\n      data,\n      headers,\n      deferred,\n      overrideMimeType,\n    );\n    return;\n  }\n\n  const xhr = new XMLHttpRequest();\n\n  if (TrustedServers.contains(url)) {\n    xhr.withCredentials = true;\n  }\n\n  xhr.open(method, url, true);\n\n  if (defined(overrideMimeType) && defined(xhr.overrideMimeType)) {\n    xhr.overrideMimeType(overrideMimeType);\n  }\n\n  if (defined(headers)) {\n    for (const key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n  }\n\n  if (defined(responseType)) {\n    xhr.responseType = responseType;\n  }\n\n  // While non-standard, file protocol always returns a status of 0 on success\n  let localFile = false;\n  if (typeof url === \"string\") {\n    localFile =\n      url.indexOf(\"file://\") === 0 ||\n      (typeof window !== \"undefined\" && window.location.origin === \"file://\");\n  }\n\n  xhr.onload = function () {\n    if (\n      (xhr.status < 200 || xhr.status >= 300) &&\n      !(localFile && xhr.status === 0)\n    ) {\n      deferred.reject(\n        new RequestErrorEvent(\n          xhr.status,\n          xhr.response,\n          xhr.getAllResponseHeaders(),\n        ),\n      );\n      return;\n    }\n\n    const response = xhr.response;\n    const browserResponseType = xhr.responseType;\n\n    if (method === \"HEAD\" || method === \"OPTIONS\") {\n      const responseHeaderString = xhr.getAllResponseHeaders();\n      const splitHeaders = responseHeaderString.trim().split(/[\\r\\n]+/);\n\n      const responseHeaders = {};\n      splitHeaders.forEach(function (line) {\n        const parts = line.split(\": \");\n        const header = parts.shift();\n        responseHeaders[header] = parts.join(\": \");\n      });\n\n      deferred.resolve(responseHeaders);\n      return;\n    }\n\n    //All modern browsers will go into either the first or second if block or last else block.\n    //Other code paths support older browsers that either do not support the supplied responseType\n    //or do not support the xhr.response property.\n    if (xhr.status === 204) {\n      // accept no content\n      deferred.resolve(undefined);\n    } else if (\n      defined(response) &&\n      (!defined(responseType) || browserResponseType === responseType)\n    ) {\n      deferred.resolve(response);\n    } else if (responseType === \"json\" && typeof response === \"string\") {\n      try {\n        deferred.resolve(JSON.parse(response));\n      } catch (e) {\n        deferred.reject(e);\n      }\n    } else if (\n      (browserResponseType === \"\" || browserResponseType === \"document\") &&\n      defined(xhr.responseXML) &&\n      xhr.responseXML.hasChildNodes()\n    ) {\n      deferred.resolve(xhr.responseXML);\n    } else if (\n      (browserResponseType === \"\" || browserResponseType === \"text\") &&\n      defined(xhr.responseText)\n    ) {\n      deferred.resolve(xhr.responseText);\n    } else {\n      deferred.reject(\n        new RuntimeError(\"Invalid XMLHttpRequest response type.\"),\n      );\n    }\n  };\n\n  xhr.onerror = function (e) {\n    deferred.reject(new RequestErrorEvent());\n  };\n\n  xhr.send(data);\n\n  return xhr;\n};\n\nResource._Implementations.loadAndExecuteScript = function (\n  url,\n  functionName,\n  deferred,\n) {\n  return loadAndExecuteScript(url, functionName).catch(function (e) {\n    deferred.reject(e);\n  });\n};\n\n/**\n * The default implementations\n *\n * @private\n */\nResource._DefaultImplementations = {};\nResource._DefaultImplementations.createImage =\n  Resource._Implementations.createImage;\nResource._DefaultImplementations.loadWithXhr =\n  Resource._Implementations.loadWithXhr;\nResource._DefaultImplementations.loadAndExecuteScript =\n  Resource._Implementations.loadAndExecuteScript;\n\n/**\n * A resource instance initialized to the current browser location\n *\n * @type {Resource}\n * @constant\n */\nResource.DEFAULT = Object.freeze(\n  new Resource({\n    url:\n      typeof document === \"undefined\"\n        ? \"\"\n        : document.location.href.split(\"?\")[0],\n  }),\n);\n\n/**\n * A function that returns the value of the property.\n * @callback Resource.RetryCallback\n *\n * @param {Resource} [resource] The resource that failed to load.\n * @param {RequestErrorEvent} [error] The error that occurred during the loading of the resource.\n * @returns {boolean|Promise<boolean>} If true or a promise that resolved to true, the resource will be retried. Otherwise the failure will be returned.\n */\nexport default Resource;\n"],"names":["xhrBlobSupported","xhr","XMLHttpRequest","open","responseType","e","Resource","options","EMPTY_OBJECT","url","typeOf","string","_url","undefined","_templateValues","defaultClone","templateValues","_queryParameters","queryParameters","headers","request","proxy","retryCallback","retryAttempts","_retryCount","parseUrl","_credits","credits","value","defaultValue","createIfNeeded","resource","getDerivedResource","supportsImageBitmapOptionsPromise","supportsImageBitmapOptions","createImageBitmap","Promise","resolve","imageDataUri","fetchBlob","then","blob","imageBitmapOptions","imageOrientation","premultiplyAlpha","colorSpaceConversion","all","imageBitmaps","colorWithOptions","colorWithDefaults","catch","Object","defineProperties","isBlobSupported","get","prototype","getUrlComponent","set","extension","isDataUri","isBlobUri","isCrossOriginUrl","hasHeaders","keys","length","toString","merge","preserveQuery","baseUrl","uri","query","parseQueryString","combineQueryParameters","search","fragment","scheme","absoluteTo","queryString","indexOf","q1","q2","preserveQueryParameters","result","param","hasOwnProperty","q2Value","Array","isArray","concat","slice","stringifyQuery","replace","match","key","replacement","encodeURIComponent","getURL","queryObject","setQueryParameters","params","useAsDefault","appendQueryParameters","setTemplateValues","template","clone","retryOnError","error","that","getBaseUri","includeQuery","appendForwardSlash","fetchArrayBuffer","fetch","fetchImage","preferImageBitmap","preferBlob","flipY","skipColorSpaceConversion","checkAndResetRequest","_fetchImage","blobPromise","supportsImageBitmap","useImageBitmap","generatedBlobResource","generatedBlob","createImageBitmapFromBlob","blobUrl","window","URL","createObjectURL","image","revokeObjectURL","reject","requestFunction","crossOrigin","deferred","_Implementations","createImage","promise","state","FAILED","retry","UNISSUED","fetchText","fetchJson","Accept","JSON","parse","fetchXML","overrideMimeType","fetchJsonp","callbackParameterName","functionName","nextRandomNumber","substring","callbackQuery","data","loadAndExecuteScript","_makeRequest","method","loadWithXhr","abort","cancelFunction","ISSUED","ACTIVE","dataUriRegex","decodeDataUriText","isBase64","decodeURIComponent","atob","decodeDataUriArrayBuffer","byteString","buffer","ArrayBuffer","view","Uint8Array","i","charCodeAt","decodeDataUri","dataUriRegexResult","mimeType","parser","Blob","type","DOMParser","parseFromString","delete","head","post","defined","put","patch","loadImageElement","Image","onload","naturalWidth","naturalHeight","width","height","onerror","contains","src","xhrDeferred","bool","loadWithHttpRequest","response","ok","responseHeaders","forEach","status","text","json","arrayBuffer","noXMLHttpRequest","exec","withCredentials","setRequestHeader","localFile","location","origin","getAllResponseHeaders","browserResponseType","responseHeaderString","splitHeaders","trim","split","line","parts","header","shift","join","responseXML","hasChildNodes","responseText","send","_DefaultImplementations","DEFAULT","freeze","document","href"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5218, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Ion.js"],"sourcesContent":["import Credit from \"./Credit.js\";\nimport defined from \"./defined.js\";\nimport Resource from \"./Resource.js\";\n\nlet defaultTokenCredit;\nconst defaultAccessToken =\n  \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJlYmFiY2M4Yy00ZDE1LTQwY2YtODJkYS04MGJiNWVjNzkxZjMiLCJpZCI6MjU5LCJpYXQiOjE3Njc2MjcyMzR9.tShykOZPNZIHyBljG1bvvQMwpbLFjmq6vdhfI097SpI\";\n/**\n * Default settings for accessing the Cesium ion API.\n *\n * An ion access token is only required if you are using any ion related APIs.\n * A default access token is provided for evaluation purposes only.\n * Sign up for a free ion account and get your own access token at {@link https://cesium.com}\n *\n * @see IonResource\n * @see IonImageryProvider\n * @see IonGeocoderService\n * @see createWorldImagery\n * @see createWorldTerrain\n * @namespace Ion\n */\nconst Ion = {};\n\n/**\n * Gets or sets the default Cesium ion access token.\n *\n * @type {string}\n */\nIon.defaultAccessToken = defaultAccessToken;\n\n/**\n * Gets or sets the default Cesium ion server.\n *\n * @type {string|Resource}\n * @default https://api.cesium.com\n */\nIon.defaultServer = new Resource({ url: \"https://api.cesium.com/\" });\n\nIon.getDefaultTokenCredit = function (providedKey) {\n  if (providedKey !== defaultAccessToken) {\n    return undefined;\n  }\n\n  if (!defined(defaultTokenCredit)) {\n    const defaultTokenMessage =\n      '<b> \\\n            This application is using Cesium\\'s default ion access token. Please assign <i>Cesium.Ion.defaultAccessToken</i> \\\n            with an access token from your ion account before making any Cesium API calls. \\\n            You can sign up for a free ion account at <a href=\"https://cesium.com\">https://cesium.com</a>.</b>';\n\n    defaultTokenCredit = new Credit(defaultTokenMessage, true);\n  }\n\n  return defaultTokenCredit;\n};\nexport default Ion;\n"],"names":["defaultTokenCredit","defaultAccessToken","Ion","defaultServer","url","getDefaultTokenCredit","providedKey","undefined","defaultTokenMessage"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,IAAIA;AACJ,MAAMC,qBACJ;AACF;;;;;;;;;;;;;CAaC,GACD,MAAMC,MAAM,CAAC;AAEb;;;;CAIC,GACDA,IAAID,kBAAkB,GAAGA;AAEzB;;;;;CAKC,GACDC,IAAIC,aAAa,GAAG,IAAI,8KAAQ,CAAC;IAAEC,KAAK;AAA0B;AAElEF,IAAIG,qBAAqB,GAAG,SAAUC,WAAW;IAC/C,IAAIA,gBAAgBL,oBAAoB;QACtC,OAAOM;IACT;IAEA,IAAI,CAAC,IAAA,6KAAO,EAACP,qBAAqB;QAChC,MAAMQ,sBACJ;;;;QAKFR,qBAAqB,IAAI,4KAAM,CAACQ,qBAAqB;IACvD;IAEA,OAAOR;AACT;uCACeE","ignoreList":[0]}},
    {"offset": {"line": 5284, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Cartesian3.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 3D Cartesian point.\n * @alias Cartesian3\n * @constructor\n *\n * @param {number} [x=0.0] The X component.\n * @param {number} [y=0.0] The Y component.\n * @param {number} [z=0.0] The Z component.\n *\n * @see Cartesian2\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian3(x, y, z) {\n  /**\n   * The X component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = x ?? 0.0;\n\n  /**\n   * The Y component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = y ?? 0.0;\n\n  /**\n   * The Z component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.z = z ?? 0.0;\n}\n\n/**\n * Converts the provided Spherical into Cartesian3 coordinates.\n *\n * @param {Spherical} spherical The Spherical to be converted to Cartesian3.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromSpherical = function (spherical, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spherical\", spherical);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const clock = spherical.clock;\n  const cone = spherical.cone;\n  const magnitude = spherical.magnitude ?? 1.0;\n  const radial = magnitude * Math.sin(cone);\n  result.x = radial * Math.cos(clock);\n  result.y = radial * Math.sin(clock);\n  result.z = magnitude * Math.cos(cone);\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from x, y and z coordinates.\n *\n * @param {number} x The x coordinate.\n * @param {number} y The y coordinate.\n * @param {number} z The z coordinate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromElements = function (x, y, z, result) {\n  if (!defined(result)) {\n    return new Cartesian3(x, y, z);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian3 instance.\n *\n * @param {Cartesian3} cartesian The Cartesian to duplicate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian3.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the\n * x, y, and z properties of the Cartesian4 and drops w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromCartesian4 = Cartesian3.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nCartesian3.packedLength = 3;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian3} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCartesian3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex] = value.z;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian3} [result] The object into which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian3s into an array of components.\n *\n * @param {Cartesian3[]} array The array of cartesians to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 3 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 3) elements.\n * @returns {number[]} The packed array.\n */\nCartesian3.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 3;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 3 elements\",\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Cartesian3.pack(array[i], result, i * 3);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian3s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Cartesian3[]} [result] The array onto which to store the result.\n * @returns {Cartesian3[]} The unpacked array.\n */\nCartesian3.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 3);\n  if (array.length % 3 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 3.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (let i = 0; i < length; i += 3) {\n    const index = i / 3;\n    result[index] = Cartesian3.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian3 from three consecutive elements in an array.\n * @function\n *\n * @param {number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian3 with (1.0, 2.0, 3.0)\n * const v = [1.0, 2.0, 3.0];\n * const p = Cesium.Cartesian3.fromArray(v);\n *\n * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0];\n * const p2 = Cesium.Cartesian3.fromArray(v2, 2);\n */\nCartesian3.fromArray = Cartesian3.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {number} The value of the maximum component.\n */\nCartesian3.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {number} The value of the minimum component.\n */\nCartesian3.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the minimum components.\n */\nCartesian3.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the maximum components.\n */\nCartesian3.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  return result;\n};\n\n/**\n * Constrain a value to lie between two values.\n *\n * @param {Cartesian3} cartesian The value to clamp.\n * @param {Cartesian3} min The minimum bound.\n * @param {Cartesian3} max The maximum bound.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} The clamped value such that min <= value <= max.\n */\nCartesian3.clamp = function (value, min, max, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = CesiumMath.clamp(value.x, min.x, max.x);\n  const y = CesiumMath.clamp(value.y, min.y, max.y);\n  const z = CesiumMath.clamp(value.z, min.z, max.z);\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {number} The squared magnitude.\n */\nCartesian3.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return (\n    cartesian.x * cartesian.x +\n    cartesian.y * cartesian.y +\n    cartesian.z * cartesian.z\n  );\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {number} The magnitude.\n */\nCartesian3.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));\n};\n\nconst distanceScratch = new Cartesian3();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * const d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));\n */\nCartesian3.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));\n */\nCartesian3.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be normalized.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitude = Cartesian3.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {number} The dot product.\n */\nCartesian3.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y + left.z * right.z;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be divided.\n * @param {number} scalar The scalar to divide by.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be negated.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  return result;\n};\n\nconst lerpScratch = new Cartesian3();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian3} start The value corresponding to t at 0.0.\n * @param {Cartesian3} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian3.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian3.add(lerpScratch, result, result);\n};\n\nconst angleBetweenScratch = new Cartesian3();\nconst angleBetweenScratch2 = new Cartesian3();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {number} The angle between the Cartesians.\n */\nCartesian3.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.normalize(left, angleBetweenScratch);\n  Cartesian3.normalize(right, angleBetweenScratch2);\n  const cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);\n  const sine = Cartesian3.magnitude(\n    Cartesian3.cross(\n      angleBetweenScratch,\n      angleBetweenScratch2,\n      angleBetweenScratch,\n    ),\n  );\n  return Math.atan2(sine, cosine);\n};\n\nconst mostOrthogonalAxisScratch = new Cartesian3();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The most orthogonal axis.\n */\nCartesian3.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian3.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      result = Cartesian3.clone(Cartesian3.UNIT_X, result);\n    } else {\n      result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n  } else if (f.y <= f.z) {\n    result = Cartesian3.clone(Cartesian3.UNIT_Y, result);\n  } else {\n    result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n  }\n\n  return result;\n};\n\n/**\n * Projects vector a onto vector b\n * @param {Cartesian3} a The vector that needs projecting\n * @param {Cartesian3} b The vector to project onto\n * @param {Cartesian3} result The result cartesian\n * @returns {Cartesian3} The modified result parameter\n */\nCartesian3.projectVector = function (a, b, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"a\", a);\n  Check.defined(\"b\", b);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scalar = Cartesian3.dot(a, b) / Cartesian3.dot(b, b);\n  return Cartesian3.multiplyByScalar(b, scalar, result);\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian3.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z)\n  );\n};\n\n/**\n * @private\n */\nCartesian3.equalsArray = function (cartesian, array, offset) {\n  return (\n    cartesian.x === array[offset] &&\n    cartesian.y === array[offset + 1] &&\n    cartesian.z === array[offset + 2]\n  );\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.z,\n        right.z,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ))\n  );\n};\n\n/**\n * Computes the cross (outer) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The cross product.\n */\nCartesian3.cross = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const leftX = left.x;\n  const leftY = left.y;\n  const leftZ = left.z;\n  const rightX = right.x;\n  const rightY = right.y;\n  const rightZ = right.z;\n\n  const x = leftY * rightZ - leftZ * rightY;\n  const y = leftZ * rightX - leftX * rightZ;\n  const z = leftX * rightY - leftY * rightX;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the midpoint between the right and left Cartesian.\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The midpoint.\n */\nCartesian3.midpoint = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = (left.x + right.x) * 0.5;\n  result.y = (left.y + right.y) * 0.5;\n  result.z = (left.z + right.z) * 0.5;\n\n  return result;\n};\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in degrees.\n *\n * @param {number} longitude The longitude, in degrees\n * @param {number} latitude The latitude, in degrees\n * @param {number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * const position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);\n */\nCartesian3.fromDegrees = function (\n  longitude,\n  latitude,\n  height,\n  ellipsoid,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  longitude = CesiumMath.toRadians(longitude);\n  latitude = CesiumMath.toRadians(latitude);\n  return Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);\n};\n\nlet scratchN = new Cartesian3();\nlet scratchK = new Cartesian3();\n\n// To prevent a circular dependency, this value is overridden by Ellipsoid when Ellipsoid.default is set\nCartesian3._ellipsoidRadiiSquared = new Cartesian3(\n  6378137.0 * 6378137.0,\n  6378137.0 * 6378137.0,\n  6356752.3142451793 * 6356752.3142451793,\n);\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in radians.\n *\n * @param {number} longitude The longitude, in radians\n * @param {number} latitude The latitude, in radians\n * @param {number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * const position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);\n */\nCartesian3.fromRadians = function (\n  longitude,\n  latitude,\n  height,\n  ellipsoid,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  height = height ?? 0.0;\n\n  const radiiSquared = !defined(ellipsoid)\n    ? Cartesian3._ellipsoidRadiiSquared\n    : ellipsoid.radiiSquared;\n\n  const cosLatitude = Math.cos(latitude);\n  scratchN.x = cosLatitude * Math.cos(longitude);\n  scratchN.y = cosLatitude * Math.sin(longitude);\n  scratchN.z = Math.sin(latitude);\n  scratchN = Cartesian3.normalize(scratchN, scratchN);\n\n  Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);\n  const gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));\n  scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);\n  scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(scratchK, scratchN, result);\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.\n *\n * @param {number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);\n */\nCartesian3.fromDegreesArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 2 and at least 2\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (let i = 0; i < length; i += 2) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const index = i / 2;\n    result[index] = Cartesian3.fromDegrees(\n      longitude,\n      latitude,\n      0,\n      ellipsoid,\n      result[index],\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.\n *\n * @param {number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);\n */\nCartesian3.fromRadiansArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 2 and at least 2\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (let i = 0; i < length; i += 2) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const index = i / 2;\n    result[index] = Cartesian3.fromRadians(\n      longitude,\n      latitude,\n      0,\n      ellipsoid,\n      result[index],\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.\n *\n * @param {number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);\n */\nCartesian3.fromDegreesArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 3 and at least 3\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (let i = 0; i < length; i += 3) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const height = coordinates[i + 2];\n    const index = i / 3;\n    result[index] = Cartesian3.fromDegrees(\n      longitude,\n      latitude,\n      height,\n      ellipsoid,\n      result[index],\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.\n *\n * @param {number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);\n */\nCartesian3.fromRadiansArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 3 and at least 3\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (let i = 0; i < length; i += 3) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const height = coordinates[i + 2];\n    const index = i / 3;\n    result[index] = Cartesian3.fromRadians(\n      longitude,\n      latitude,\n      height,\n      ellipsoid,\n      result[index],\n    );\n  }\n\n  return result;\n};\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.ZERO = Object.freeze(new Cartesian3(0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 1.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.ONE = Object.freeze(new Cartesian3(1.0, 1.0, 1.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_X = Object.freeze(new Cartesian3(1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Y = Object.freeze(new Cartesian3(0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Z = Object.freeze(new Cartesian3(0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian3 instance.\n *\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.prototype.clone = function (result) {\n  return Cartesian3.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian3.prototype.equals = function (right) {\n  return Cartesian3.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return Cartesian3.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon,\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z)'.\n *\n * @returns {string} A string representing this Cartesian in the format '(x, y, z)'.\n */\nCartesian3.prototype.toString = function () {\n  return `(${this.x}, ${this.y}, ${this.z})`;\n};\nexport default Cartesian3;\n"],"names":["Cartesian3","x","y","z","fromSpherical","spherical","result","typeOf","object","clock","cone","magnitude","radial","Math","sin","cos","fromElements","clone","cartesian","undefined","fromCartesian4","packedLength","pack","value","array","startingIndex","defined","unpack","packArray","length","resultLength","Array","isArray","i","unpackArray","number","greaterThanOrEquals","index","fromArray","maximumComponent","max","minimumComponent","min","minimumByComponent","first","second","maximumByComponent","clamp","magnitudeSquared","sqrt","distanceScratch","distance","left","right","subtract","distanceSquared","normalize","isNaN","dot","multiplyComponents","divideComponents","add","multiplyByScalar","scalar","divideByScalar","negate","abs","lerpScratch","lerp","start","end","t","angleBetweenScratch","angleBetweenScratch2","angleBetween","cosine","sine","cross","atan2","mostOrthogonalAxisScratch","mostOrthogonalAxis","f","UNIT_X","UNIT_Z","UNIT_Y","projectVector","a","b","equals","equalsArray","offset","equalsEpsilon","relativeEpsilon","absoluteEpsilon","leftX","leftY","leftZ","rightX","rightY","rightZ","midpoint","fromDegrees","longitude","latitude","height","ellipsoid","toRadians","fromRadians","scratchN","scratchK","_ellipsoidRadiiSquared","radiiSquared","cosLatitude","gamma","fromDegreesArray","coordinates","fromRadiansArray","fromDegreesArrayHeights","fromRadiansArrayHeights","ZERO","Object","freeze","ONE","prototype","toString"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;;;;;;;;;;CAYC,GACD,SAASA,WAAWC,CAAC,EAAEC,CAAC,EAAEC,CAAC;IACzB;;;;GAIC,GACD,IAAI,CAACF,CAAC,GAAGA,KAAK;IAEd;;;;GAIC,GACD,IAAI,CAACC,CAAC,GAAGA,KAAK;IAEd;;;;GAIC,GACD,IAAI,CAACC,CAAC,GAAGA,KAAK;AAChB;AAEA;;;;;;CAMC,GACDH,WAAWI,aAAa,GAAG,SAAUC,SAAS,EAAEC,MAAM;IACpD,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,aAAaH;IACjC,wBAAwB;IAExB,IAAI,CAAC,IAAA,6KAAO,EAACC,SAAS;QACpBA,SAAS,IAAIN;IACf;IAEA,MAAMS,QAAQJ,UAAUI,KAAK;IAC7B,MAAMC,OAAOL,UAAUK,IAAI;IAC3B,MAAMC,YAAYN,UAAUM,SAAS,IAAI;IACzC,MAAMC,SAASD,YAAYE,KAAKC,GAAG,CAACJ;IACpCJ,OAAOL,CAAC,GAAGW,SAASC,KAAKE,GAAG,CAACN;IAC7BH,OAAOJ,CAAC,GAAGU,SAASC,KAAKC,GAAG,CAACL;IAC7BH,OAAOH,CAAC,GAAGQ,YAAYE,KAAKE,GAAG,CAACL;IAChC,OAAOJ;AACT;AAEA;;;;;;;;CAQC,GACDN,WAAWgB,YAAY,GAAG,SAAUf,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEG,MAAM;IACjD,IAAI,CAAC,IAAA,6KAAO,EAACA,SAAS;QACpB,OAAO,IAAIN,WAAWC,GAAGC,GAAGC;IAC9B;IAEAG,OAAOL,CAAC,GAAGA;IACXK,OAAOJ,CAAC,GAAGA;IACXI,OAAOH,CAAC,GAAGA;IACX,OAAOG;AACT;AAEA;;;;;;CAMC,GACDN,WAAWiB,KAAK,GAAG,SAAUC,SAAS,EAAEZ,MAAM;IAC5C,IAAI,CAAC,IAAA,6KAAO,EAACY,YAAY;QACvB,OAAOC;IACT;IACA,IAAI,CAAC,IAAA,6KAAO,EAACb,SAAS;QACpB,OAAO,IAAIN,WAAWkB,UAAUjB,CAAC,EAAEiB,UAAUhB,CAAC,EAAEgB,UAAUf,CAAC;IAC7D;IAEAG,OAAOL,CAAC,GAAGiB,UAAUjB,CAAC;IACtBK,OAAOJ,CAAC,GAAGgB,UAAUhB,CAAC;IACtBI,OAAOH,CAAC,GAAGe,UAAUf,CAAC;IACtB,OAAOG;AACT;AAEA;;;;;;;;CAQC,GACDN,WAAWoB,cAAc,GAAGpB,WAAWiB,KAAK;AAE5C;;;CAGC,GACDjB,WAAWqB,YAAY,GAAG;AAE1B;;;;;;;;CAQC,GACDrB,WAAWsB,IAAI,GAAG,SAAUC,KAAK,EAAEC,KAAK,EAAEC,aAAa;IACrD,yCAAyC;IACzC,2KAAK,CAAClB,MAAM,CAACC,MAAM,CAAC,SAASe;IAC7B,2KAAK,CAACG,OAAO,CAAC,SAASF;IACvB,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjCD,KAAK,CAACC,gBAAgB,GAAGF,MAAMtB,CAAC;IAChCuB,KAAK,CAACC,gBAAgB,GAAGF,MAAMrB,CAAC;IAChCsB,KAAK,CAACC,cAAc,GAAGF,MAAMpB,CAAC;IAE9B,OAAOqB;AACT;AAEA;;;;;;;CAOC,GACDxB,WAAW2B,MAAM,GAAG,SAAUH,KAAK,EAAEC,aAAa,EAAEnB,MAAM;IACxD,yCAAyC;IACzC,2KAAK,CAACoB,OAAO,CAAC,SAASF;IACvB,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjC,IAAI,CAAC,IAAA,6KAAO,EAACnB,SAAS;QACpBA,SAAS,IAAIN;IACf;IACAM,OAAOL,CAAC,GAAGuB,KAAK,CAACC,gBAAgB;IACjCnB,OAAOJ,CAAC,GAAGsB,KAAK,CAACC,gBAAgB;IACjCnB,OAAOH,CAAC,GAAGqB,KAAK,CAACC,cAAc;IAC/B,OAAOnB;AACT;AAEA;;;;;;CAMC,GACDN,WAAW4B,SAAS,GAAG,SAAUJ,KAAK,EAAElB,MAAM;IAC5C,yCAAyC;IACzC,2KAAK,CAACoB,OAAO,CAAC,SAASF;IACvB,wBAAwB;IAExB,MAAMK,SAASL,MAAMK,MAAM;IAC3B,MAAMC,eAAeD,SAAS;IAC9B,IAAI,CAAC,IAAA,6KAAO,EAACvB,SAAS;QACpBA,SAAS,IAAIyB,MAAMD;IACrB,OAAO,IAAI,CAACC,MAAMC,OAAO,CAAC1B,WAAWA,OAAOuB,MAAM,KAAKC,cAAc;QACnE,yCAAyC;QACzC,MAAM,IAAI,oLAAc,CACtB;IAEF,wBAAwB;IAC1B,OAAO,IAAIxB,OAAOuB,MAAM,KAAKC,cAAc;QACzCxB,OAAOuB,MAAM,GAAGC;IAClB;IAEA,IAAK,IAAIG,IAAI,GAAGA,IAAIJ,QAAQ,EAAEI,EAAG;QAC/BjC,WAAWsB,IAAI,CAACE,KAAK,CAACS,EAAE,EAAE3B,QAAQ2B,IAAI;IACxC;IACA,OAAO3B;AACT;AAEA;;;;;;CAMC,GACDN,WAAWkC,WAAW,GAAG,SAAUV,KAAK,EAAElB,MAAM;IAC9C,yCAAyC;IACzC,2KAAK,CAACoB,OAAO,CAAC,SAASF;IACvB,2KAAK,CAACjB,MAAM,CAAC4B,MAAM,CAACC,mBAAmB,CAAC,gBAAgBZ,MAAMK,MAAM,EAAE;IACtE,IAAIL,MAAMK,MAAM,GAAG,MAAM,GAAG;QAC1B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAMA,SAASL,MAAMK,MAAM;IAC3B,IAAI,CAAC,IAAA,6KAAO,EAACvB,SAAS;QACpBA,SAAS,IAAIyB,MAAMF,SAAS;IAC9B,OAAO;QACLvB,OAAOuB,MAAM,GAAGA,SAAS;IAC3B;IAEA,IAAK,IAAII,IAAI,GAAGA,IAAIJ,QAAQI,KAAK,EAAG;QAClC,MAAMI,QAAQJ,IAAI;QAClB3B,MAAM,CAAC+B,MAAM,GAAGrC,WAAW2B,MAAM,CAACH,OAAOS,GAAG3B,MAAM,CAAC+B,MAAM;IAC3D;IACA,OAAO/B;AACT;AAEA;;;;;;;;;;;;;;;;;CAiBC,GACDN,WAAWsC,SAAS,GAAGtC,WAAW2B,MAAM;AAExC;;;;;CAKC,GACD3B,WAAWuC,gBAAgB,GAAG,SAAUrB,SAAS;IAC/C,yCAAyC;IACzC,2KAAK,CAACX,MAAM,CAACC,MAAM,CAAC,aAAaU;IACjC,wBAAwB;IAExB,OAAOL,KAAK2B,GAAG,CAACtB,UAAUjB,CAAC,EAAEiB,UAAUhB,CAAC,EAAEgB,UAAUf,CAAC;AACvD;AAEA;;;;;CAKC,GACDH,WAAWyC,gBAAgB,GAAG,SAAUvB,SAAS;IAC/C,yCAAyC;IACzC,2KAAK,CAACX,MAAM,CAACC,MAAM,CAAC,aAAaU;IACjC,wBAAwB;IAExB,OAAOL,KAAK6B,GAAG,CAACxB,UAAUjB,CAAC,EAAEiB,UAAUhB,CAAC,EAAEgB,UAAUf,CAAC;AACvD;AAEA;;;;;;;CAOC,GACDH,WAAW2C,kBAAkB,GAAG,SAAUC,KAAK,EAAEC,MAAM,EAAEvC,MAAM;IAC7D,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,SAASoC;IAC7B,2KAAK,CAACrC,MAAM,CAACC,MAAM,CAAC,UAAUqC;IAC9B,2KAAK,CAACtC,MAAM,CAACC,MAAM,CAAC,UAAUF;IAC9B,wBAAwB;IAExBA,OAAOL,CAAC,GAAGY,KAAK6B,GAAG,CAACE,MAAM3C,CAAC,EAAE4C,OAAO5C,CAAC;IACrCK,OAAOJ,CAAC,GAAGW,KAAK6B,GAAG,CAACE,MAAM1C,CAAC,EAAE2C,OAAO3C,CAAC;IACrCI,OAAOH,CAAC,GAAGU,KAAK6B,GAAG,CAACE,MAAMzC,CAAC,EAAE0C,OAAO1C,CAAC;IAErC,OAAOG;AACT;AAEA;;;;;;;CAOC,GACDN,WAAW8C,kBAAkB,GAAG,SAAUF,KAAK,EAAEC,MAAM,EAAEvC,MAAM;IAC7D,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,SAASoC;IAC7B,2KAAK,CAACrC,MAAM,CAACC,MAAM,CAAC,UAAUqC;IAC9B,2KAAK,CAACtC,MAAM,CAACC,MAAM,CAAC,UAAUF;IAC9B,wBAAwB;IAExBA,OAAOL,CAAC,GAAGY,KAAK2B,GAAG,CAACI,MAAM3C,CAAC,EAAE4C,OAAO5C,CAAC;IACrCK,OAAOJ,CAAC,GAAGW,KAAK2B,GAAG,CAACI,MAAM1C,CAAC,EAAE2C,OAAO3C,CAAC;IACrCI,OAAOH,CAAC,GAAGU,KAAK2B,GAAG,CAACI,MAAMzC,CAAC,EAAE0C,OAAO1C,CAAC;IACrC,OAAOG;AACT;AAEA;;;;;;;;CAQC,GACDN,WAAW+C,KAAK,GAAG,SAAUxB,KAAK,EAAEmB,GAAG,EAAEF,GAAG,EAAElC,MAAM;IAClD,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,SAASe;IAC7B,2KAAK,CAAChB,MAAM,CAACC,MAAM,CAAC,OAAOkC;IAC3B,2KAAK,CAACnC,MAAM,CAACC,MAAM,CAAC,OAAOgC;IAC3B,2KAAK,CAACjC,MAAM,CAACC,MAAM,CAAC,UAAUF;IAC9B,wBAAwB;IAExB,MAAML,IAAI,0KAAU,CAAC8C,KAAK,CAACxB,MAAMtB,CAAC,EAAEyC,IAAIzC,CAAC,EAAEuC,IAAIvC,CAAC;IAChD,MAAMC,IAAI,0KAAU,CAAC6C,KAAK,CAACxB,MAAMrB,CAAC,EAAEwC,IAAIxC,CAAC,EAAEsC,IAAItC,CAAC;IAChD,MAAMC,IAAI,0KAAU,CAAC4C,KAAK,CAACxB,MAAMpB,CAAC,EAAEuC,IAAIvC,CAAC,EAAEqC,IAAIrC,CAAC;IAEhDG,OAAOL,CAAC,GAAGA;IACXK,OAAOJ,CAAC,GAAGA;IACXI,OAAOH,CAAC,GAAGA;IAEX,OAAOG;AACT;AAEA;;;;;CAKC,GACDN,WAAWgD,gBAAgB,GAAG,SAAU9B,SAAS;IAC/C,yCAAyC;IACzC,2KAAK,CAACX,MAAM,CAACC,MAAM,CAAC,aAAaU;IACjC,wBAAwB;IAExB,OACEA,UAAUjB,CAAC,GAAGiB,UAAUjB,CAAC,GACzBiB,UAAUhB,CAAC,GAAGgB,UAAUhB,CAAC,GACzBgB,UAAUf,CAAC,GAAGe,UAAUf,CAAC;AAE7B;AAEA;;;;;CAKC,GACDH,WAAWW,SAAS,GAAG,SAAUO,SAAS;IACxC,OAAOL,KAAKoC,IAAI,CAACjD,WAAWgD,gBAAgB,CAAC9B;AAC/C;AAEA,MAAMgC,kBAAkB,IAAIlD;AAE5B;;;;;;;;;;CAUC,GACDA,WAAWmD,QAAQ,GAAG,SAAUC,IAAI,EAAEC,KAAK;IACzC,yCAAyC;IACzC,2KAAK,CAAC9C,MAAM,CAACC,MAAM,CAAC,QAAQ4C;IAC5B,2KAAK,CAAC7C,MAAM,CAACC,MAAM,CAAC,SAAS6C;IAC7B,wBAAwB;IAExBrD,WAAWsD,QAAQ,CAACF,MAAMC,OAAOH;IACjC,OAAOlD,WAAWW,SAAS,CAACuC;AAC9B;AAEA;;;;;;;;;;;CAWC,GACDlD,WAAWuD,eAAe,GAAG,SAAUH,IAAI,EAAEC,KAAK;IAChD,yCAAyC;IACzC,2KAAK,CAAC9C,MAAM,CAACC,MAAM,CAAC,QAAQ4C;IAC5B,2KAAK,CAAC7C,MAAM,CAACC,MAAM,CAAC,SAAS6C;IAC7B,wBAAwB;IAExBrD,WAAWsD,QAAQ,CAACF,MAAMC,OAAOH;IACjC,OAAOlD,WAAWgD,gBAAgB,CAACE;AACrC;AAEA;;;;;;CAMC,GACDlD,WAAWwD,SAAS,GAAG,SAAUtC,SAAS,EAAEZ,MAAM;IAChD,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,aAAaU;IACjC,2KAAK,CAACX,MAAM,CAACC,MAAM,CAAC,UAAUF;IAC9B,wBAAwB;IAExB,MAAMK,YAAYX,WAAWW,SAAS,CAACO;IAEvCZ,OAAOL,CAAC,GAAGiB,UAAUjB,CAAC,GAAGU;IACzBL,OAAOJ,CAAC,GAAGgB,UAAUhB,CAAC,GAAGS;IACzBL,OAAOH,CAAC,GAAGe,UAAUf,CAAC,GAAGQ;IAEzB,yCAAyC;IACzC,IAAI8C,MAAMnD,OAAOL,CAAC,KAAKwD,MAAMnD,OAAOJ,CAAC,KAAKuD,MAAMnD,OAAOH,CAAC,GAAG;QACzD,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,OAAOG;AACT;AAEA;;;;;;CAMC,GACDN,WAAW0D,GAAG,GAAG,SAAUN,IAAI,EAAEC,KAAK;IACpC,yCAAyC;IACzC,2KAAK,CAAC9C,MAAM,CAACC,MAAM,CAAC,QAAQ4C;IAC5B,2KAAK,CAAC7C,MAAM,CAACC,MAAM,CAAC,SAAS6C;IAC7B,wBAAwB;IAExB,OAAOD,KAAKnD,CAAC,GAAGoD,MAAMpD,CAAC,GAAGmD,KAAKlD,CAAC,GAAGmD,MAAMnD,CAAC,GAAGkD,KAAKjD,CAAC,GAAGkD,MAAMlD,CAAC;AAC/D;AAEA;;;;;;;CAOC,GACDH,WAAW2D,kBAAkB,GAAG,SAAUP,IAAI,EAAEC,KAAK,EAAE/C,MAAM;IAC3D,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,QAAQ4C;IAC5B,2KAAK,CAAC7C,MAAM,CAACC,MAAM,CAAC,SAAS6C;IAC7B,2KAAK,CAAC9C,MAAM,CAACC,MAAM,CAAC,UAAUF;IAC9B,wBAAwB;IAExBA,OAAOL,CAAC,GAAGmD,KAAKnD,CAAC,GAAGoD,MAAMpD,CAAC;IAC3BK,OAAOJ,CAAC,GAAGkD,KAAKlD,CAAC,GAAGmD,MAAMnD,CAAC;IAC3BI,OAAOH,CAAC,GAAGiD,KAAKjD,CAAC,GAAGkD,MAAMlD,CAAC;IAC3B,OAAOG;AACT;AAEA;;;;;;;CAOC,GACDN,WAAW4D,gBAAgB,GAAG,SAAUR,IAAI,EAAEC,KAAK,EAAE/C,MAAM;IACzD,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,QAAQ4C;IAC5B,2KAAK,CAAC7C,MAAM,CAACC,MAAM,CAAC,SAAS6C;IAC7B,2KAAK,CAAC9C,MAAM,CAACC,MAAM,CAAC,UAAUF;IAC9B,wBAAwB;IAExBA,OAAOL,CAAC,GAAGmD,KAAKnD,CAAC,GAAGoD,MAAMpD,CAAC;IAC3BK,OAAOJ,CAAC,GAAGkD,KAAKlD,CAAC,GAAGmD,MAAMnD,CAAC;IAC3BI,OAAOH,CAAC,GAAGiD,KAAKjD,CAAC,GAAGkD,MAAMlD,CAAC;IAC3B,OAAOG;AACT;AAEA;;;;;;;CAOC,GACDN,WAAW6D,GAAG,GAAG,SAAUT,IAAI,EAAEC,KAAK,EAAE/C,MAAM;IAC5C,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,QAAQ4C;IAC5B,2KAAK,CAAC7C,MAAM,CAACC,MAAM,CAAC,SAAS6C;IAC7B,2KAAK,CAAC9C,MAAM,CAACC,MAAM,CAAC,UAAUF;IAC9B,wBAAwB;IAExBA,OAAOL,CAAC,GAAGmD,KAAKnD,CAAC,GAAGoD,MAAMpD,CAAC;IAC3BK,OAAOJ,CAAC,GAAGkD,KAAKlD,CAAC,GAAGmD,MAAMnD,CAAC;IAC3BI,OAAOH,CAAC,GAAGiD,KAAKjD,CAAC,GAAGkD,MAAMlD,CAAC;IAC3B,OAAOG;AACT;AAEA;;;;;;;CAOC,GACDN,WAAWsD,QAAQ,GAAG,SAAUF,IAAI,EAAEC,KAAK,EAAE/C,MAAM;IACjD,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,QAAQ4C;IAC5B,2KAAK,CAAC7C,MAAM,CAACC,MAAM,CAAC,SAAS6C;IAC7B,2KAAK,CAAC9C,MAAM,CAACC,MAAM,CAAC,UAAUF;IAC9B,wBAAwB;IAExBA,OAAOL,CAAC,GAAGmD,KAAKnD,CAAC,GAAGoD,MAAMpD,CAAC;IAC3BK,OAAOJ,CAAC,GAAGkD,KAAKlD,CAAC,GAAGmD,MAAMnD,CAAC;IAC3BI,OAAOH,CAAC,GAAGiD,KAAKjD,CAAC,GAAGkD,MAAMlD,CAAC;IAC3B,OAAOG;AACT;AAEA;;;;;;;CAOC,GACDN,WAAW8D,gBAAgB,GAAG,SAAU5C,SAAS,EAAE6C,MAAM,EAAEzD,MAAM;IAC/D,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,aAAaU;IACjC,2KAAK,CAACX,MAAM,CAAC4B,MAAM,CAAC,UAAU4B;IAC9B,2KAAK,CAACxD,MAAM,CAACC,MAAM,CAAC,UAAUF;IAC9B,wBAAwB;IAExBA,OAAOL,CAAC,GAAGiB,UAAUjB,CAAC,GAAG8D;IACzBzD,OAAOJ,CAAC,GAAGgB,UAAUhB,CAAC,GAAG6D;IACzBzD,OAAOH,CAAC,GAAGe,UAAUf,CAAC,GAAG4D;IACzB,OAAOzD;AACT;AAEA;;;;;;;CAOC,GACDN,WAAWgE,cAAc,GAAG,SAAU9C,SAAS,EAAE6C,MAAM,EAAEzD,MAAM;IAC7D,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,aAAaU;IACjC,2KAAK,CAACX,MAAM,CAAC4B,MAAM,CAAC,UAAU4B;IAC9B,2KAAK,CAACxD,MAAM,CAACC,MAAM,CAAC,UAAUF;IAC9B,wBAAwB;IAExBA,OAAOL,CAAC,GAAGiB,UAAUjB,CAAC,GAAG8D;IACzBzD,OAAOJ,CAAC,GAAGgB,UAAUhB,CAAC,GAAG6D;IACzBzD,OAAOH,CAAC,GAAGe,UAAUf,CAAC,GAAG4D;IACzB,OAAOzD;AACT;AAEA;;;;;;CAMC,GACDN,WAAWiE,MAAM,GAAG,SAAU/C,SAAS,EAAEZ,MAAM;IAC7C,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,aAAaU;IACjC,2KAAK,CAACX,MAAM,CAACC,MAAM,CAAC,UAAUF;IAC9B,wBAAwB;IAExBA,OAAOL,CAAC,GAAG,CAACiB,UAAUjB,CAAC;IACvBK,OAAOJ,CAAC,GAAG,CAACgB,UAAUhB,CAAC;IACvBI,OAAOH,CAAC,GAAG,CAACe,UAAUf,CAAC;IACvB,OAAOG;AACT;AAEA;;;;;;CAMC,GACDN,WAAWkE,GAAG,GAAG,SAAUhD,SAAS,EAAEZ,MAAM;IAC1C,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,aAAaU;IACjC,2KAAK,CAACX,MAAM,CAACC,MAAM,CAAC,UAAUF;IAC9B,wBAAwB;IAExBA,OAAOL,CAAC,GAAGY,KAAKqD,GAAG,CAAChD,UAAUjB,CAAC;IAC/BK,OAAOJ,CAAC,GAAGW,KAAKqD,GAAG,CAAChD,UAAUhB,CAAC;IAC/BI,OAAOH,CAAC,GAAGU,KAAKqD,GAAG,CAAChD,UAAUf,CAAC;IAC/B,OAAOG;AACT;AAEA,MAAM6D,cAAc,IAAInE;AACxB;;;;;;;;CAQC,GACDA,WAAWoE,IAAI,GAAG,SAAUC,KAAK,EAAEC,GAAG,EAAEC,CAAC,EAAEjE,MAAM;IAC/C,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,SAAS6D;IAC7B,2KAAK,CAAC9D,MAAM,CAACC,MAAM,CAAC,OAAO8D;IAC3B,2KAAK,CAAC/D,MAAM,CAAC4B,MAAM,CAAC,KAAKoC;IACzB,2KAAK,CAAChE,MAAM,CAACC,MAAM,CAAC,UAAUF;IAC9B,wBAAwB;IAExBN,WAAW8D,gBAAgB,CAACQ,KAAKC,GAAGJ;IACpC7D,SAASN,WAAW8D,gBAAgB,CAACO,OAAO,MAAME,GAAGjE;IACrD,OAAON,WAAW6D,GAAG,CAACM,aAAa7D,QAAQA;AAC7C;AAEA,MAAMkE,sBAAsB,IAAIxE;AAChC,MAAMyE,uBAAuB,IAAIzE;AACjC;;;;;;CAMC,GACDA,WAAW0E,YAAY,GAAG,SAAUtB,IAAI,EAAEC,KAAK;IAC7C,yCAAyC;IACzC,2KAAK,CAAC9C,MAAM,CAACC,MAAM,CAAC,QAAQ4C;IAC5B,2KAAK,CAAC7C,MAAM,CAACC,MAAM,CAAC,SAAS6C;IAC7B,wBAAwB;IAExBrD,WAAWwD,SAAS,CAACJ,MAAMoB;IAC3BxE,WAAWwD,SAAS,CAACH,OAAOoB;IAC5B,MAAME,SAAS3E,WAAW0D,GAAG,CAACc,qBAAqBC;IACnD,MAAMG,OAAO5E,WAAWW,SAAS,CAC/BX,WAAW6E,KAAK,CACdL,qBACAC,sBACAD;IAGJ,OAAO3D,KAAKiE,KAAK,CAACF,MAAMD;AAC1B;AAEA,MAAMI,4BAA4B,IAAI/E;AACtC;;;;;;CAMC,GACDA,WAAWgF,kBAAkB,GAAG,SAAU9D,SAAS,EAAEZ,MAAM;IACzD,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,aAAaU;IACjC,2KAAK,CAACX,MAAM,CAACC,MAAM,CAAC,UAAUF;IAC9B,wBAAwB;IAExB,MAAM2E,IAAIjF,WAAWwD,SAAS,CAACtC,WAAW6D;IAC1C/E,WAAWkE,GAAG,CAACe,GAAGA;IAElB,IAAIA,EAAEhF,CAAC,IAAIgF,EAAE/E,CAAC,EAAE;QACd,IAAI+E,EAAEhF,CAAC,IAAIgF,EAAE9E,CAAC,EAAE;YACdG,SAASN,WAAWiB,KAAK,CAACjB,WAAWkF,MAAM,EAAE5E;QAC/C,OAAO;YACLA,SAASN,WAAWiB,KAAK,CAACjB,WAAWmF,MAAM,EAAE7E;QAC/C;IACF,OAAO,IAAI2E,EAAE/E,CAAC,IAAI+E,EAAE9E,CAAC,EAAE;QACrBG,SAASN,WAAWiB,KAAK,CAACjB,WAAWoF,MAAM,EAAE9E;IAC/C,OAAO;QACLA,SAASN,WAAWiB,KAAK,CAACjB,WAAWmF,MAAM,EAAE7E;IAC/C;IAEA,OAAOA;AACT;AAEA;;;;;;CAMC,GACDN,WAAWqF,aAAa,GAAG,SAAUC,CAAC,EAAEC,CAAC,EAAEjF,MAAM;IAC/C,yCAAyC;IACzC,2KAAK,CAACoB,OAAO,CAAC,KAAK4D;IACnB,2KAAK,CAAC5D,OAAO,CAAC,KAAK6D;IACnB,2KAAK,CAAC7D,OAAO,CAAC,UAAUpB;IACxB,wBAAwB;IAExB,MAAMyD,SAAS/D,WAAW0D,GAAG,CAAC4B,GAAGC,KAAKvF,WAAW0D,GAAG,CAAC6B,GAAGA;IACxD,OAAOvF,WAAW8D,gBAAgB,CAACyB,GAAGxB,QAAQzD;AAChD;AAEA;;;;;;;CAOC,GACDN,WAAWwF,MAAM,GAAG,SAAUpC,IAAI,EAAEC,KAAK;IACvC,OACED,SAASC,SACR,IAAA,6KAAO,EAACD,SACP,IAAA,6KAAO,EAACC,UACRD,KAAKnD,CAAC,KAAKoD,MAAMpD,CAAC,IAClBmD,KAAKlD,CAAC,KAAKmD,MAAMnD,CAAC,IAClBkD,KAAKjD,CAAC,KAAKkD,MAAMlD,CAAC;AAExB;AAEA;;CAEC,GACDH,WAAWyF,WAAW,GAAG,SAAUvE,SAAS,EAAEM,KAAK,EAAEkE,MAAM;IACzD,OACExE,UAAUjB,CAAC,KAAKuB,KAAK,CAACkE,OAAO,IAC7BxE,UAAUhB,CAAC,KAAKsB,KAAK,CAACkE,SAAS,EAAE,IACjCxE,UAAUf,CAAC,KAAKqB,KAAK,CAACkE,SAAS,EAAE;AAErC;AAEA;;;;;;;;;;CAUC,GACD1F,WAAW2F,aAAa,GAAG,SACzBvC,IAAI,EACJC,KAAK,EACLuC,eAAe,EACfC,eAAe;IAEf,OACEzC,SAASC,SACR,IAAA,6KAAO,EAACD,SACP,IAAA,6KAAO,EAACC,UACR,0KAAU,CAACsC,aAAa,CACtBvC,KAAKnD,CAAC,EACNoD,MAAMpD,CAAC,EACP2F,iBACAC,oBAEF,0KAAU,CAACF,aAAa,CACtBvC,KAAKlD,CAAC,EACNmD,MAAMnD,CAAC,EACP0F,iBACAC,oBAEF,0KAAU,CAACF,aAAa,CACtBvC,KAAKjD,CAAC,EACNkD,MAAMlD,CAAC,EACPyF,iBACAC;AAGR;AAEA;;;;;;;CAOC,GACD7F,WAAW6E,KAAK,GAAG,SAAUzB,IAAI,EAAEC,KAAK,EAAE/C,MAAM;IAC9C,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,QAAQ4C;IAC5B,2KAAK,CAAC7C,MAAM,CAACC,MAAM,CAAC,SAAS6C;IAC7B,2KAAK,CAAC9C,MAAM,CAACC,MAAM,CAAC,UAAUF;IAC9B,wBAAwB;IAExB,MAAMwF,QAAQ1C,KAAKnD,CAAC;IACpB,MAAM8F,QAAQ3C,KAAKlD,CAAC;IACpB,MAAM8F,QAAQ5C,KAAKjD,CAAC;IACpB,MAAM8F,SAAS5C,MAAMpD,CAAC;IACtB,MAAMiG,SAAS7C,MAAMnD,CAAC;IACtB,MAAMiG,SAAS9C,MAAMlD,CAAC;IAEtB,MAAMF,IAAI8F,QAAQI,SAASH,QAAQE;IACnC,MAAMhG,IAAI8F,QAAQC,SAASH,QAAQK;IACnC,MAAMhG,IAAI2F,QAAQI,SAASH,QAAQE;IAEnC3F,OAAOL,CAAC,GAAGA;IACXK,OAAOJ,CAAC,GAAGA;IACXI,OAAOH,CAAC,GAAGA;IACX,OAAOG;AACT;AAEA;;;;;;CAMC,GACDN,WAAWoG,QAAQ,GAAG,SAAUhD,IAAI,EAAEC,KAAK,EAAE/C,MAAM;IACjD,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,QAAQ4C;IAC5B,2KAAK,CAAC7C,MAAM,CAACC,MAAM,CAAC,SAAS6C;IAC7B,2KAAK,CAAC9C,MAAM,CAACC,MAAM,CAAC,UAAUF;IAC9B,wBAAwB;IAExBA,OAAOL,CAAC,GAAG,CAACmD,KAAKnD,CAAC,GAAGoD,MAAMpD,CAAC,IAAI;IAChCK,OAAOJ,CAAC,GAAG,CAACkD,KAAKlD,CAAC,GAAGmD,MAAMnD,CAAC,IAAI;IAChCI,OAAOH,CAAC,GAAG,CAACiD,KAAKjD,CAAC,GAAGkD,MAAMlD,CAAC,IAAI;IAEhC,OAAOG;AACT;AAEA;;;;;;;;;;;;CAYC,GACDN,WAAWqG,WAAW,GAAG,SACvBC,SAAS,EACTC,QAAQ,EACRC,MAAM,EACNC,SAAS,EACTnG,MAAM;IAEN,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAAC4B,MAAM,CAAC,aAAamE;IACjC,2KAAK,CAAC/F,MAAM,CAAC4B,MAAM,CAAC,YAAYoE;IAChC,wBAAwB;IAExBD,YAAY,0KAAU,CAACI,SAAS,CAACJ;IACjCC,WAAW,0KAAU,CAACG,SAAS,CAACH;IAChC,OAAOvG,WAAW2G,WAAW,CAACL,WAAWC,UAAUC,QAAQC,WAAWnG;AACxE;AAEA,IAAIsG,WAAW,IAAI5G;AACnB,IAAI6G,WAAW,IAAI7G;AAEnB,wGAAwG;AACxGA,WAAW8G,sBAAsB,GAAG,IAAI9G,WACtC,YAAY,WACZ,YAAY,WACZ,qBAAqB;AAGvB;;;;;;;;;;;;CAYC,GACDA,WAAW2G,WAAW,GAAG,SACvBL,SAAS,EACTC,QAAQ,EACRC,MAAM,EACNC,SAAS,EACTnG,MAAM;IAEN,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAAC4B,MAAM,CAAC,aAAamE;IACjC,2KAAK,CAAC/F,MAAM,CAAC4B,MAAM,CAAC,YAAYoE;IAChC,wBAAwB;IAExBC,SAASA,UAAU;IAEnB,MAAMO,eAAe,CAAC,IAAA,6KAAO,EAACN,aAC1BzG,WAAW8G,sBAAsB,GACjCL,UAAUM,YAAY;IAE1B,MAAMC,cAAcnG,KAAKE,GAAG,CAACwF;IAC7BK,SAAS3G,CAAC,GAAG+G,cAAcnG,KAAKE,GAAG,CAACuF;IACpCM,SAAS1G,CAAC,GAAG8G,cAAcnG,KAAKC,GAAG,CAACwF;IACpCM,SAASzG,CAAC,GAAGU,KAAKC,GAAG,CAACyF;IACtBK,WAAW5G,WAAWwD,SAAS,CAACoD,UAAUA;IAE1C5G,WAAW2D,kBAAkB,CAACoD,cAAcH,UAAUC;IACtD,MAAMI,QAAQpG,KAAKoC,IAAI,CAACjD,WAAW0D,GAAG,CAACkD,UAAUC;IACjDA,WAAW7G,WAAWgE,cAAc,CAAC6C,UAAUI,OAAOJ;IACtDD,WAAW5G,WAAW8D,gBAAgB,CAAC8C,UAAUJ,QAAQI;IAEzD,IAAI,CAAC,IAAA,6KAAO,EAACtG,SAAS;QACpBA,SAAS,IAAIN;IACf;IACA,OAAOA,WAAW6D,GAAG,CAACgD,UAAUD,UAAUtG;AAC5C;AAEA;;;;;;;;;;CAUC,GACDN,WAAWkH,gBAAgB,GAAG,SAAUC,WAAW,EAAEV,SAAS,EAAEnG,MAAM;IACpE,yCAAyC;IACzC,2KAAK,CAACoB,OAAO,CAAC,eAAeyF;IAC7B,IAAIA,YAAYtF,MAAM,GAAG,KAAKsF,YAAYtF,MAAM,GAAG,MAAM,GAAG;QAC1D,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,wBAAwB;IAExB,MAAMA,SAASsF,YAAYtF,MAAM;IACjC,IAAI,CAAC,IAAA,6KAAO,EAACvB,SAAS;QACpBA,SAAS,IAAIyB,MAAMF,SAAS;IAC9B,OAAO;QACLvB,OAAOuB,MAAM,GAAGA,SAAS;IAC3B;IAEA,IAAK,IAAII,IAAI,GAAGA,IAAIJ,QAAQI,KAAK,EAAG;QAClC,MAAMqE,YAAYa,WAAW,CAAClF,EAAE;QAChC,MAAMsE,WAAWY,WAAW,CAAClF,IAAI,EAAE;QACnC,MAAMI,QAAQJ,IAAI;QAClB3B,MAAM,CAAC+B,MAAM,GAAGrC,WAAWqG,WAAW,CACpCC,WACAC,UACA,GACAE,WACAnG,MAAM,CAAC+B,MAAM;IAEjB;IAEA,OAAO/B;AACT;AAEA;;;;;;;;;;CAUC,GACDN,WAAWoH,gBAAgB,GAAG,SAAUD,WAAW,EAAEV,SAAS,EAAEnG,MAAM;IACpE,yCAAyC;IACzC,2KAAK,CAACoB,OAAO,CAAC,eAAeyF;IAC7B,IAAIA,YAAYtF,MAAM,GAAG,KAAKsF,YAAYtF,MAAM,GAAG,MAAM,GAAG;QAC1D,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,wBAAwB;IAExB,MAAMA,SAASsF,YAAYtF,MAAM;IACjC,IAAI,CAAC,IAAA,6KAAO,EAACvB,SAAS;QACpBA,SAAS,IAAIyB,MAAMF,SAAS;IAC9B,OAAO;QACLvB,OAAOuB,MAAM,GAAGA,SAAS;IAC3B;IAEA,IAAK,IAAII,IAAI,GAAGA,IAAIJ,QAAQI,KAAK,EAAG;QAClC,MAAMqE,YAAYa,WAAW,CAAClF,EAAE;QAChC,MAAMsE,WAAWY,WAAW,CAAClF,IAAI,EAAE;QACnC,MAAMI,QAAQJ,IAAI;QAClB3B,MAAM,CAAC+B,MAAM,GAAGrC,WAAW2G,WAAW,CACpCL,WACAC,UACA,GACAE,WACAnG,MAAM,CAAC+B,MAAM;IAEjB;IAEA,OAAO/B;AACT;AAEA;;;;;;;;;;CAUC,GACDN,WAAWqH,uBAAuB,GAAG,SAAUF,WAAW,EAAEV,SAAS,EAAEnG,MAAM;IAC3E,yCAAyC;IACzC,2KAAK,CAACoB,OAAO,CAAC,eAAeyF;IAC7B,IAAIA,YAAYtF,MAAM,GAAG,KAAKsF,YAAYtF,MAAM,GAAG,MAAM,GAAG;QAC1D,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,wBAAwB;IAExB,MAAMA,SAASsF,YAAYtF,MAAM;IACjC,IAAI,CAAC,IAAA,6KAAO,EAACvB,SAAS;QACpBA,SAAS,IAAIyB,MAAMF,SAAS;IAC9B,OAAO;QACLvB,OAAOuB,MAAM,GAAGA,SAAS;IAC3B;IAEA,IAAK,IAAII,IAAI,GAAGA,IAAIJ,QAAQI,KAAK,EAAG;QAClC,MAAMqE,YAAYa,WAAW,CAAClF,EAAE;QAChC,MAAMsE,WAAWY,WAAW,CAAClF,IAAI,EAAE;QACnC,MAAMuE,SAASW,WAAW,CAAClF,IAAI,EAAE;QACjC,MAAMI,QAAQJ,IAAI;QAClB3B,MAAM,CAAC+B,MAAM,GAAGrC,WAAWqG,WAAW,CACpCC,WACAC,UACAC,QACAC,WACAnG,MAAM,CAAC+B,MAAM;IAEjB;IAEA,OAAO/B;AACT;AAEA;;;;;;;;;;CAUC,GACDN,WAAWsH,uBAAuB,GAAG,SAAUH,WAAW,EAAEV,SAAS,EAAEnG,MAAM;IAC3E,yCAAyC;IACzC,2KAAK,CAACoB,OAAO,CAAC,eAAeyF;IAC7B,IAAIA,YAAYtF,MAAM,GAAG,KAAKsF,YAAYtF,MAAM,GAAG,MAAM,GAAG;QAC1D,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,wBAAwB;IAExB,MAAMA,SAASsF,YAAYtF,MAAM;IACjC,IAAI,CAAC,IAAA,6KAAO,EAACvB,SAAS;QACpBA,SAAS,IAAIyB,MAAMF,SAAS;IAC9B,OAAO;QACLvB,OAAOuB,MAAM,GAAGA,SAAS;IAC3B;IAEA,IAAK,IAAII,IAAI,GAAGA,IAAIJ,QAAQI,KAAK,EAAG;QAClC,MAAMqE,YAAYa,WAAW,CAAClF,EAAE;QAChC,MAAMsE,WAAWY,WAAW,CAAClF,IAAI,EAAE;QACnC,MAAMuE,SAASW,WAAW,CAAClF,IAAI,EAAE;QACjC,MAAMI,QAAQJ,IAAI;QAClB3B,MAAM,CAAC+B,MAAM,GAAGrC,WAAW2G,WAAW,CACpCL,WACAC,UACAC,QACAC,WACAnG,MAAM,CAAC+B,MAAM;IAEjB;IAEA,OAAO/B;AACT;AAEA;;;;;CAKC,GACDN,WAAWuH,IAAI,GAAGC,OAAOC,MAAM,CAAC,IAAIzH,WAAW,KAAK,KAAK;AAEzD;;;;;CAKC,GACDA,WAAW0H,GAAG,GAAGF,OAAOC,MAAM,CAAC,IAAIzH,WAAW,KAAK,KAAK;AAExD;;;;;CAKC,GACDA,WAAWkF,MAAM,GAAGsC,OAAOC,MAAM,CAAC,IAAIzH,WAAW,KAAK,KAAK;AAE3D;;;;;CAKC,GACDA,WAAWoF,MAAM,GAAGoC,OAAOC,MAAM,CAAC,IAAIzH,WAAW,KAAK,KAAK;AAE3D;;;;;CAKC,GACDA,WAAWmF,MAAM,GAAGqC,OAAOC,MAAM,CAAC,IAAIzH,WAAW,KAAK,KAAK;AAE3D;;;;;CAKC,GACDA,WAAW2H,SAAS,CAAC1G,KAAK,GAAG,SAAUX,MAAM;IAC3C,OAAON,WAAWiB,KAAK,CAAC,IAAI,EAAEX;AAChC;AAEA;;;;;;CAMC,GACDN,WAAW2H,SAAS,CAACnC,MAAM,GAAG,SAAUnC,KAAK;IAC3C,OAAOrD,WAAWwF,MAAM,CAAC,IAAI,EAAEnC;AACjC;AAEA;;;;;;;;;CASC,GACDrD,WAAW2H,SAAS,CAAChC,aAAa,GAAG,SACnCtC,KAAK,EACLuC,eAAe,EACfC,eAAe;IAEf,OAAO7F,WAAW2F,aAAa,CAC7B,IAAI,EACJtC,OACAuC,iBACAC;AAEJ;AAEA;;;;CAIC,GACD7F,WAAW2H,SAAS,CAACC,QAAQ,GAAG;IAC9B,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC3H,CAAC,CAAC,EAAE,EAAE,IAAI,CAACC,CAAC,CAAC,EAAE,EAAE,IAAI,CAACC,CAAC,CAAC,CAAC,CAAC;AAC5C;uCACeH","ignoreList":[0]}},
    {"offset": {"line": 6225, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/scaleToGeodeticSurface.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\nconst scaleToGeodeticSurfaceIntersection = new Cartesian3();\nconst scaleToGeodeticSurfaceGradient = new Cartesian3();\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} oneOverRadii One over radii of the ellipsoid.\n * @param {Cartesian3} oneOverRadiiSquared One over radii squared of the ellipsoid.\n * @param {number} centerToleranceSquared Tolerance for closeness to the center.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n *\n * @function scaleToGeodeticSurface\n *\n * @private\n */\nfunction scaleToGeodeticSurface(\n  cartesian,\n  oneOverRadii,\n  oneOverRadiiSquared,\n  centerToleranceSquared,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  if (!defined(oneOverRadii)) {\n    throw new DeveloperError(\"oneOverRadii is required.\");\n  }\n  if (!defined(oneOverRadiiSquared)) {\n    throw new DeveloperError(\"oneOverRadiiSquared is required.\");\n  }\n  if (!defined(centerToleranceSquared)) {\n    throw new DeveloperError(\"centerToleranceSquared is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const positionX = cartesian.x;\n  const positionY = cartesian.y;\n  const positionZ = cartesian.z;\n\n  const oneOverRadiiX = oneOverRadii.x;\n  const oneOverRadiiY = oneOverRadii.y;\n  const oneOverRadiiZ = oneOverRadii.z;\n\n  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n\n  // Compute the squared ellipsoid norm.\n  const squaredNorm = x2 + y2 + z2;\n  const ratio = Math.sqrt(1.0 / squaredNorm);\n\n  // As an initial approximation, assume that the radial intersection is the projection point.\n  const intersection = Cartesian3.multiplyByScalar(\n    cartesian,\n    ratio,\n    scaleToGeodeticSurfaceIntersection,\n  );\n\n  // If the position is near the center, the iteration will not converge.\n  if (squaredNorm < centerToleranceSquared) {\n    return !isFinite(ratio)\n      ? undefined\n      : Cartesian3.clone(intersection, result);\n  }\n\n  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n\n  // Use the gradient at the intersection point in place of the true unit normal.\n  // The difference in magnitude will be absorbed in the multiplier.\n  const gradient = scaleToGeodeticSurfaceGradient;\n  gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;\n  gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;\n  gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;\n\n  // Compute the initial guess at the normal vector multiplier, lambda.\n  let lambda =\n    ((1.0 - ratio) * Cartesian3.magnitude(cartesian)) /\n    (0.5 * Cartesian3.magnitude(gradient));\n  let correction = 0.0;\n\n  let func;\n  let denominator;\n  let xMultiplier;\n  let yMultiplier;\n  let zMultiplier;\n  let xMultiplier2;\n  let yMultiplier2;\n  let zMultiplier2;\n  let xMultiplier3;\n  let yMultiplier3;\n  let zMultiplier3;\n\n  do {\n    lambda -= correction;\n\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n\n    xMultiplier2 = xMultiplier * xMultiplier;\n    yMultiplier2 = yMultiplier * yMultiplier;\n    zMultiplier2 = zMultiplier * zMultiplier;\n\n    xMultiplier3 = xMultiplier2 * xMultiplier;\n    yMultiplier3 = yMultiplier2 * yMultiplier;\n    zMultiplier3 = zMultiplier2 * zMultiplier;\n\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n\n    // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n    // computations in the sections to follow.\n    denominator =\n      x2 * xMultiplier3 * oneOverRadiiSquaredX +\n      y2 * yMultiplier3 * oneOverRadiiSquaredY +\n      z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n\n    const derivative = -2.0 * denominator;\n\n    correction = func / derivative;\n  } while (Math.abs(func) > CesiumMath.EPSILON12);\n\n  if (!defined(result)) {\n    return new Cartesian3(\n      positionX * xMultiplier,\n      positionY * yMultiplier,\n      positionZ * zMultiplier,\n    );\n  }\n  result.x = positionX * xMultiplier;\n  result.y = positionY * yMultiplier;\n  result.z = positionZ * zMultiplier;\n  return result;\n}\nexport default scaleToGeodeticSurface;\n"],"names":["scaleToGeodeticSurfaceIntersection","scaleToGeodeticSurfaceGradient","scaleToGeodeticSurface","cartesian","oneOverRadii","oneOverRadiiSquared","centerToleranceSquared","result","positionX","x","positionY","y","positionZ","z","oneOverRadiiX","oneOverRadiiY","oneOverRadiiZ","x2","y2","z2","squaredNorm","ratio","Math","sqrt","intersection","multiplyByScalar","isFinite","undefined","clone","oneOverRadiiSquaredX","oneOverRadiiSquaredY","oneOverRadiiSquaredZ","gradient","lambda","magnitude","correction","func","denominator","xMultiplier","yMultiplier","zMultiplier","xMultiplier2","yMultiplier2","zMultiplier2","xMultiplier3","yMultiplier3","zMultiplier3","derivative","abs","EPSILON12"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6341, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Cartographic.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\n\n/**\n * A position defined by longitude, latitude, and height.\n * @alias Cartographic\n * @constructor\n *\n * @param {number} [longitude=0.0] The longitude, in radians.\n * @param {number} [latitude=0.0] The latitude, in radians.\n * @param {number} [height=0.0] The height, in meters, above the ellipsoid.\n *\n * @see Ellipsoid\n */\nfunction Cartographic(longitude, latitude, height) {\n  /**\n   * The longitude, in radians.\n   * @type {number}\n   * @default 0.0\n   */\n  this.longitude = longitude ?? 0.0;\n\n  /**\n   * The latitude, in radians.\n   * @type {number}\n   * @default 0.0\n   */\n  this.latitude = latitude ?? 0.0;\n\n  /**\n   * The height, in meters, above the ellipsoid.\n   * @type {number}\n   * @default 0.0\n   */\n  this.height = height ?? 0.0;\n}\n\n/**\n * Creates a new Cartographic instance from longitude and latitude\n * specified in radians.\n *\n * @param {number} longitude The longitude, in radians.\n * @param {number} latitude The latitude, in radians.\n * @param {number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.fromRadians = function (longitude, latitude, height, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  height = height ?? 0.0;\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Creates a new Cartographic instance from longitude and latitude\n * specified in degrees.  The values in the resulting object will\n * be in radians.\n *\n * @param {number} longitude The longitude, in degrees.\n * @param {number} latitude The latitude, in degrees.\n * @param {number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.fromDegrees = function (longitude, latitude, height, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  longitude = CesiumMath.toRadians(longitude);\n  latitude = CesiumMath.toRadians(latitude);\n\n  return Cartographic.fromRadians(longitude, latitude, height, result);\n};\n\nconst cartesianToCartographicN = new Cartesian3();\nconst cartesianToCartographicP = new Cartesian3();\nconst cartesianToCartographicH = new Cartesian3();\n\n// To avoid circular dependencies, these are set by Ellipsoid when Ellipsoid.default is set.\nCartographic._ellipsoidOneOverRadii = new Cartesian3(\n  1.0 / 6378137.0,\n  1.0 / 6378137.0,\n  1.0 / 6356752.3142451793,\n);\nCartographic._ellipsoidOneOverRadiiSquared = new Cartesian3(\n  1.0 / (6378137.0 * 6378137.0),\n  1.0 / (6378137.0 * 6378137.0),\n  1.0 / (6356752.3142451793 * 6356752.3142451793),\n);\nCartographic._ellipsoidCenterToleranceSquared = CesiumMath.EPSILON1;\n\n/**\n * Creates a new Cartographic instance from a Cartesian position. The values in the\n * resulting object will be in radians.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n */\nCartographic.fromCartesian = function (cartesian, ellipsoid, result) {\n  const oneOverRadii = defined(ellipsoid)\n    ? ellipsoid.oneOverRadii\n    : Cartographic._ellipsoidOneOverRadii;\n  const oneOverRadiiSquared = defined(ellipsoid)\n    ? ellipsoid.oneOverRadiiSquared\n    : Cartographic._ellipsoidOneOverRadiiSquared;\n  const centerToleranceSquared = defined(ellipsoid)\n    ? ellipsoid._centerToleranceSquared\n    : Cartographic._ellipsoidCenterToleranceSquared;\n\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  const p = scaleToGeodeticSurface(\n    cartesian,\n    oneOverRadii,\n    oneOverRadiiSquared,\n    centerToleranceSquared,\n    cartesianToCartographicP,\n  );\n\n  if (!defined(p)) {\n    return undefined;\n  }\n\n  let n = Cartesian3.multiplyComponents(\n    p,\n    oneOverRadiiSquared,\n    cartesianToCartographicN,\n  );\n  n = Cartesian3.normalize(n, n);\n\n  const h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n\n  const longitude = Math.atan2(n.y, n.x);\n  const latitude = Math.asin(n.z);\n  const height =\n    CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Creates a new Cartesian3 instance from a Cartographic input. The values in the inputted\n * object should be in radians.\n *\n * @param {Cartographic} cartographic Input to be converted into a Cartesian3 output.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n */\nCartographic.toCartesian = function (cartographic, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  return Cartesian3.fromRadians(\n    cartographic.longitude,\n    cartographic.latitude,\n    cartographic.height,\n    ellipsoid,\n    result,\n  );\n};\n\n/**\n * Duplicates a Cartographic instance.\n *\n * @param {Cartographic} cartographic The cartographic to duplicate.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)\n */\nCartographic.clone = function (cartographic, result) {\n  if (!defined(cartographic)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartographic(\n      cartographic.longitude,\n      cartographic.latitude,\n      cartographic.height,\n    );\n  }\n  result.longitude = cartographic.longitude;\n  result.latitude = cartographic.latitude;\n  result.height = cartographic.height;\n  return result;\n};\n\n/**\n * Compares the provided cartographics componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartographic} [left] The first cartographic.\n * @param {Cartographic} [right] The second cartographic.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartographic.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.longitude === right.longitude &&\n      left.latitude === right.latitude &&\n      left.height === right.height)\n  );\n};\n\n/**\n * Compares the provided cartographics componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Cartographic} [left] The first cartographic.\n * @param {Cartographic} [right] The second cartographic.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartographic.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = epsilon ?? 0;\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left.longitude - right.longitude) <= epsilon &&\n      Math.abs(left.latitude - right.latitude) <= epsilon &&\n      Math.abs(left.height - right.height) <= epsilon)\n  );\n};\n\n/**\n * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartographic}\n * @constant\n */\nCartographic.ZERO = Object.freeze(new Cartographic(0.0, 0.0, 0.0));\n\n/**\n * Duplicates this instance.\n *\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.prototype.clone = function (result) {\n  return Cartographic.clone(this, result);\n};\n\n/**\n * Compares the provided against this cartographic componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartographic} [right] The second cartographic.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartographic.prototype.equals = function (right) {\n  return Cartographic.equals(this, right);\n};\n\n/**\n * Compares the provided against this cartographic componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Cartographic} [right] The second cartographic.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartographic.prototype.equalsEpsilon = function (right, epsilon) {\n  return Cartographic.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.\n *\n * @returns {string} A string representing the provided cartographic in the format '(longitude, latitude, height)'.\n */\nCartographic.prototype.toString = function () {\n  return `(${this.longitude}, ${this.latitude}, ${this.height})`;\n};\nexport default Cartographic;\n"],"names":["Cartographic","longitude","latitude","height","fromRadians","result","typeOf","number","fromDegrees","toRadians","cartesianToCartographicN","cartesianToCartographicP","cartesianToCartographicH","_ellipsoidOneOverRadii","_ellipsoidOneOverRadiiSquared","_ellipsoidCenterToleranceSquared","EPSILON1","fromCartesian","cartesian","ellipsoid","oneOverRadii","oneOverRadiiSquared","centerToleranceSquared","_centerToleranceSquared","p","undefined","n","multiplyComponents","normalize","h","subtract","Math","atan2","y","x","asin","z","sign","dot","magnitude","toCartesian","cartographic","defined","clone","equals","left","right","equalsEpsilon","epsilon","abs","ZERO","Object","freeze","prototype","toString"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6563, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Cartesian2.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 2D Cartesian point.\n * @alias Cartesian2\n * @constructor\n *\n * @param {number} [x=0.0] The X component.\n * @param {number} [y=0.0] The Y component.\n *\n * @see Cartesian3\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian2(x, y) {\n  /**\n   * The X component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = x ?? 0.0;\n\n  /**\n   * The Y component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = y ?? 0.0;\n}\n\n/**\n * Creates a Cartesian2 instance from x and y coordinates.\n *\n * @param {number} x The x coordinate.\n * @param {number} y The y coordinate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromElements = function (x, y, result) {\n  if (!defined(result)) {\n    return new Cartesian2(x, y);\n  }\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian2 instance.\n *\n * @param {Cartesian2} cartesian The Cartesian to duplicate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian2.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartesian2(cartesian.x, cartesian.y);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  return result;\n};\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the\n * x and y properties of the Cartesian3 and drops z.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian3 = Cartesian2.clone;\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the\n * x and y properties of the Cartesian4 and drops z and w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian4 = Cartesian2.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nCartesian2.packedLength = 2;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian2} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCartesian2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value.x;\n  array[startingIndex] = value.y;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian2} [result] The object into which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian2s into an array of components.\n *\n * @param {Cartesian2[]} array The array of cartesians to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 2 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 2) elements.\n * @returns {number[]} The packed array.\n */\nCartesian2.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 2;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 2 elements\",\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Cartesian2.pack(array[i], result, i * 2);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian2s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Cartesian2[]} [result] The array onto which to store the result.\n * @returns {Cartesian2[]} The unpacked array.\n */\nCartesian2.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 2);\n  if (array.length % 2 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 2.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (let i = 0; i < length; i += 2) {\n    const index = i / 2;\n    result[index] = Cartesian2.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian2 from two consecutive elements in an array.\n * @function\n *\n * @param {number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian2 with (1.0, 2.0)\n * const v = [1.0, 2.0];\n * const p = Cesium.Cartesian2.fromArray(v);\n *\n * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0];\n * const p2 = Cesium.Cartesian2.fromArray(v2, 2);\n */\nCartesian2.fromArray = Cartesian2.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {number} The value of the maximum component.\n */\nCartesian2.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {number} The value of the minimum component.\n */\nCartesian2.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the minimum components.\n */\nCartesian2.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the maximum components.\n */\nCartesian2.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  return result;\n};\n\n/**\n * Constrain a value to lie between two values.\n *\n * @param {Cartesian2} value The value to clamp.\n * @param {Cartesian2} min The minimum bound.\n * @param {Cartesian2} max The maximum bound.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} The clamped value such that min <= result <= max.\n */\nCartesian2.clamp = function (value, min, max, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = CesiumMath.clamp(value.x, min.x, max.x);\n  const y = CesiumMath.clamp(value.y, min.y, max.y);\n\n  result.x = x;\n  result.y = y;\n\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {number} The squared magnitude.\n */\nCartesian2.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return cartesian.x * cartesian.x + cartesian.y * cartesian.y;\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {number} The magnitude.\n */\nCartesian2.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));\n};\n\nconst distanceScratch = new Cartesian2();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));\n */\nCartesian2.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));\n */\nCartesian2.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be normalized.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitude = Cartesian2.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {number} The dot product.\n */\nCartesian2.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y;\n};\n\n/**\n * Computes the magnitude of the cross product that would result from implicitly setting the Z coordinate of the input vectors to 0\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {number} The cross product.\n */\nCartesian2.cross = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.y - left.y * right.x;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be divided.\n * @param {number} scalar The scalar to divide by.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be negated.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  return result;\n};\n\nconst lerpScratch = new Cartesian2();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian2} start The value corresponding to t at 0.0.\n * @param {Cartesian2} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian2.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian2.add(lerpScratch, result, result);\n};\n\nconst angleBetweenScratch = new Cartesian2();\nconst angleBetweenScratch2 = new Cartesian2();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {number} The angle between the Cartesians.\n */\nCartesian2.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.normalize(left, angleBetweenScratch);\n  Cartesian2.normalize(right, angleBetweenScratch2);\n  return CesiumMath.acosClamped(\n    Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2),\n  );\n};\n\nconst mostOrthogonalAxisScratch = new Cartesian2();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The most orthogonal axis.\n */\nCartesian2.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian2.abs(f, f);\n\n  if (f.x <= f.y) {\n    result = Cartesian2.clone(Cartesian2.UNIT_X, result);\n  } else {\n    result = Cartesian2.clone(Cartesian2.UNIT_Y, result);\n  }\n\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian2.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y)\n  );\n};\n\n/**\n * @private\n */\nCartesian2.equalsArray = function (cartesian, array, offset) {\n  return cartesian.x === array[offset] && cartesian.y === array[offset + 1];\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ))\n  );\n};\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.ZERO = Object.freeze(new Cartesian2(0.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.ONE = Object.freeze(new Cartesian2(1.0, 1.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_X = Object.freeze(new Cartesian2(1.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_Y = Object.freeze(new Cartesian2(0.0, 1.0));\n\n/**\n * Duplicates this Cartesian2 instance.\n *\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.prototype.clone = function (result) {\n  return Cartesian2.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian2.prototype.equals = function (right) {\n  return Cartesian2.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return Cartesian2.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon,\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y)'.\n *\n * @returns {string} A string representing the provided Cartesian in the format '(x, y)'.\n */\nCartesian2.prototype.toString = function () {\n  return `(${this.x}, ${this.y})`;\n};\nexport default Cartesian2;\n"],"names":["Cartesian2","x","y","fromElements","result","clone","cartesian","undefined","fromCartesian3","fromCartesian4","packedLength","pack","value","array","startingIndex","typeOf","object","defined","unpack","packArray","length","resultLength","Array","isArray","i","unpackArray","number","greaterThanOrEquals","index","fromArray","maximumComponent","Math","max","minimumComponent","min","minimumByComponent","first","second","maximumByComponent","clamp","magnitudeSquared","magnitude","sqrt","distanceScratch","distance","left","right","subtract","distanceSquared","normalize","isNaN","dot","cross","multiplyComponents","divideComponents","add","multiplyByScalar","scalar","divideByScalar","negate","abs","lerpScratch","lerp","start","end","t","angleBetweenScratch","angleBetweenScratch2","angleBetween","acosClamped","mostOrthogonalAxisScratch","mostOrthogonalAxis","f","UNIT_X","UNIT_Y","equals","equalsArray","offset","equalsEpsilon","relativeEpsilon","absoluteEpsilon","ZERO","Object","freeze","ONE","prototype","toString"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;;;;;;;;;CAWC,GACD,SAASA,WAAWC,CAAC,EAAEC,CAAC;IACtB;;;;GAIC,GACD,IAAI,CAACD,CAAC,GAAGA,KAAK;IAEd;;;;GAIC,GACD,IAAI,CAACC,CAAC,GAAGA,KAAK;AAChB;AAEA;;;;;;;CAOC,GACDF,WAAWG,YAAY,GAAG,SAAUF,CAAC,EAAEC,CAAC,EAAEE,MAAM;IAC9C,IAAI,CAAC,IAAA,6KAAO,EAACA,SAAS;QACpB,OAAO,IAAIJ,WAAWC,GAAGC;IAC3B;IAEAE,OAAOH,CAAC,GAAGA;IACXG,OAAOF,CAAC,GAAGA;IACX,OAAOE;AACT;AAEA;;;;;;CAMC,GACDJ,WAAWK,KAAK,GAAG,SAAUC,SAAS,EAAEF,MAAM;IAC5C,IAAI,CAAC,IAAA,6KAAO,EAACE,YAAY;QACvB,OAAOC;IACT;IACA,IAAI,CAAC,IAAA,6KAAO,EAACH,SAAS;QACpB,OAAO,IAAIJ,WAAWM,UAAUL,CAAC,EAAEK,UAAUJ,CAAC;IAChD;IAEAE,OAAOH,CAAC,GAAGK,UAAUL,CAAC;IACtBG,OAAOF,CAAC,GAAGI,UAAUJ,CAAC;IACtB,OAAOE;AACT;AAEA;;;;;;;;CAQC,GACDJ,WAAWQ,cAAc,GAAGR,WAAWK,KAAK;AAE5C;;;;;;;;CAQC,GACDL,WAAWS,cAAc,GAAGT,WAAWK,KAAK;AAE5C;;;CAGC,GACDL,WAAWU,YAAY,GAAG;AAE1B;;;;;;;;CAQC,GACDV,WAAWW,IAAI,GAAG,SAAUC,KAAK,EAAEC,KAAK,EAAEC,aAAa;IACrD,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,SAASJ;IAC7B,2KAAK,CAACK,OAAO,CAAC,SAASJ;IACvB,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjCD,KAAK,CAACC,gBAAgB,GAAGF,MAAMX,CAAC;IAChCY,KAAK,CAACC,cAAc,GAAGF,MAAMV,CAAC;IAE9B,OAAOW;AACT;AAEA;;;;;;;CAOC,GACDb,WAAWkB,MAAM,GAAG,SAAUL,KAAK,EAAEC,aAAa,EAAEV,MAAM;IACxD,yCAAyC;IACzC,2KAAK,CAACa,OAAO,CAAC,SAASJ;IACvB,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjC,IAAI,CAAC,IAAA,6KAAO,EAACV,SAAS;QACpBA,SAAS,IAAIJ;IACf;IACAI,OAAOH,CAAC,GAAGY,KAAK,CAACC,gBAAgB;IACjCV,OAAOF,CAAC,GAAGW,KAAK,CAACC,cAAc;IAC/B,OAAOV;AACT;AAEA;;;;;;CAMC,GACDJ,WAAWmB,SAAS,GAAG,SAAUN,KAAK,EAAET,MAAM;IAC5C,yCAAyC;IACzC,2KAAK,CAACa,OAAO,CAAC,SAASJ;IACvB,wBAAwB;IAExB,MAAMO,SAASP,MAAMO,MAAM;IAC3B,MAAMC,eAAeD,SAAS;IAC9B,IAAI,CAAC,IAAA,6KAAO,EAAChB,SAAS;QACpBA,SAAS,IAAIkB,MAAMD;IACrB,OAAO,IAAI,CAACC,MAAMC,OAAO,CAACnB,WAAWA,OAAOgB,MAAM,KAAKC,cAAc;QACnE,yCAAyC;QACzC,MAAM,IAAI,oLAAc,CACtB;IAEF,wBAAwB;IAC1B,OAAO,IAAIjB,OAAOgB,MAAM,KAAKC,cAAc;QACzCjB,OAAOgB,MAAM,GAAGC;IAClB;IAEA,IAAK,IAAIG,IAAI,GAAGA,IAAIJ,QAAQ,EAAEI,EAAG;QAC/BxB,WAAWW,IAAI,CAACE,KAAK,CAACW,EAAE,EAAEpB,QAAQoB,IAAI;IACxC;IACA,OAAOpB;AACT;AAEA;;;;;;CAMC,GACDJ,WAAWyB,WAAW,GAAG,SAAUZ,KAAK,EAAET,MAAM;IAC9C,yCAAyC;IACzC,2KAAK,CAACa,OAAO,CAAC,SAASJ;IACvB,2KAAK,CAACE,MAAM,CAACW,MAAM,CAACC,mBAAmB,CAAC,gBAAgBd,MAAMO,MAAM,EAAE;IACtE,IAAIP,MAAMO,MAAM,GAAG,MAAM,GAAG;QAC1B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAMA,SAASP,MAAMO,MAAM;IAC3B,IAAI,CAAC,IAAA,6KAAO,EAAChB,SAAS;QACpBA,SAAS,IAAIkB,MAAMF,SAAS;IAC9B,OAAO;QACLhB,OAAOgB,MAAM,GAAGA,SAAS;IAC3B;IAEA,IAAK,IAAII,IAAI,GAAGA,IAAIJ,QAAQI,KAAK,EAAG;QAClC,MAAMI,QAAQJ,IAAI;QAClBpB,MAAM,CAACwB,MAAM,GAAG5B,WAAWkB,MAAM,CAACL,OAAOW,GAAGpB,MAAM,CAACwB,MAAM;IAC3D;IACA,OAAOxB;AACT;AAEA;;;;;;;;;;;;;;;;;CAiBC,GACDJ,WAAW6B,SAAS,GAAG7B,WAAWkB,MAAM;AAExC;;;;;CAKC,GACDlB,WAAW8B,gBAAgB,GAAG,SAAUxB,SAAS;IAC/C,yCAAyC;IACzC,2KAAK,CAACS,MAAM,CAACC,MAAM,CAAC,aAAaV;IACjC,wBAAwB;IAExB,OAAOyB,KAAKC,GAAG,CAAC1B,UAAUL,CAAC,EAAEK,UAAUJ,CAAC;AAC1C;AAEA;;;;;CAKC,GACDF,WAAWiC,gBAAgB,GAAG,SAAU3B,SAAS;IAC/C,yCAAyC;IACzC,2KAAK,CAACS,MAAM,CAACC,MAAM,CAAC,aAAaV;IACjC,wBAAwB;IAExB,OAAOyB,KAAKG,GAAG,CAAC5B,UAAUL,CAAC,EAAEK,UAAUJ,CAAC;AAC1C;AAEA;;;;;;;CAOC,GACDF,WAAWmC,kBAAkB,GAAG,SAAUC,KAAK,EAAEC,MAAM,EAAEjC,MAAM;IAC7D,yCAAyC;IACzC,2KAAK,CAACW,MAAM,CAACC,MAAM,CAAC,SAASoB;IAC7B,2KAAK,CAACrB,MAAM,CAACC,MAAM,CAAC,UAAUqB;IAC9B,2KAAK,CAACtB,MAAM,CAACC,MAAM,CAAC,UAAUZ;IAC9B,wBAAwB;IAExBA,OAAOH,CAAC,GAAG8B,KAAKG,GAAG,CAACE,MAAMnC,CAAC,EAAEoC,OAAOpC,CAAC;IACrCG,OAAOF,CAAC,GAAG6B,KAAKG,GAAG,CAACE,MAAMlC,CAAC,EAAEmC,OAAOnC,CAAC;IAErC,OAAOE;AACT;AAEA;;;;;;;CAOC,GACDJ,WAAWsC,kBAAkB,GAAG,SAAUF,KAAK,EAAEC,MAAM,EAAEjC,MAAM;IAC7D,yCAAyC;IACzC,2KAAK,CAACW,MAAM,CAACC,MAAM,CAAC,SAASoB;IAC7B,2KAAK,CAACrB,MAAM,CAACC,MAAM,CAAC,UAAUqB;IAC9B,2KAAK,CAACtB,MAAM,CAACC,MAAM,CAAC,UAAUZ;IAC9B,wBAAwB;IAExBA,OAAOH,CAAC,GAAG8B,KAAKC,GAAG,CAACI,MAAMnC,CAAC,EAAEoC,OAAOpC,CAAC;IACrCG,OAAOF,CAAC,GAAG6B,KAAKC,GAAG,CAACI,MAAMlC,CAAC,EAAEmC,OAAOnC,CAAC;IACrC,OAAOE;AACT;AAEA;;;;;;;;CAQC,GACDJ,WAAWuC,KAAK,GAAG,SAAU3B,KAAK,EAAEsB,GAAG,EAAEF,GAAG,EAAE5B,MAAM;IAClD,yCAAyC;IACzC,2KAAK,CAACW,MAAM,CAACC,MAAM,CAAC,SAASJ;IAC7B,2KAAK,CAACG,MAAM,CAACC,MAAM,CAAC,OAAOkB;IAC3B,2KAAK,CAACnB,MAAM,CAACC,MAAM,CAAC,OAAOgB;IAC3B,2KAAK,CAACjB,MAAM,CAACC,MAAM,CAAC,UAAUZ;IAC9B,wBAAwB;IAExB,MAAMH,IAAI,0KAAU,CAACsC,KAAK,CAAC3B,MAAMX,CAAC,EAAEiC,IAAIjC,CAAC,EAAE+B,IAAI/B,CAAC;IAChD,MAAMC,IAAI,0KAAU,CAACqC,KAAK,CAAC3B,MAAMV,CAAC,EAAEgC,IAAIhC,CAAC,EAAE8B,IAAI9B,CAAC;IAEhDE,OAAOH,CAAC,GAAGA;IACXG,OAAOF,CAAC,GAAGA;IAEX,OAAOE;AACT;AAEA;;;;;CAKC,GACDJ,WAAWwC,gBAAgB,GAAG,SAAUlC,SAAS;IAC/C,yCAAyC;IACzC,2KAAK,CAACS,MAAM,CAACC,MAAM,CAAC,aAAaV;IACjC,wBAAwB;IAExB,OAAOA,UAAUL,CAAC,GAAGK,UAAUL,CAAC,GAAGK,UAAUJ,CAAC,GAAGI,UAAUJ,CAAC;AAC9D;AAEA;;;;;CAKC,GACDF,WAAWyC,SAAS,GAAG,SAAUnC,SAAS;IACxC,OAAOyB,KAAKW,IAAI,CAAC1C,WAAWwC,gBAAgB,CAAClC;AAC/C;AAEA,MAAMqC,kBAAkB,IAAI3C;AAE5B;;;;;;;;;;CAUC,GACDA,WAAW4C,QAAQ,GAAG,SAAUC,IAAI,EAAEC,KAAK;IACzC,yCAAyC;IACzC,2KAAK,CAAC/B,MAAM,CAACC,MAAM,CAAC,QAAQ6B;IAC5B,2KAAK,CAAC9B,MAAM,CAACC,MAAM,CAAC,SAAS8B;IAC7B,wBAAwB;IAExB9C,WAAW+C,QAAQ,CAACF,MAAMC,OAAOH;IACjC,OAAO3C,WAAWyC,SAAS,CAACE;AAC9B;AAEA;;;;;;;;;;;CAWC,GACD3C,WAAWgD,eAAe,GAAG,SAAUH,IAAI,EAAEC,KAAK;IAChD,yCAAyC;IACzC,2KAAK,CAAC/B,MAAM,CAACC,MAAM,CAAC,QAAQ6B;IAC5B,2KAAK,CAAC9B,MAAM,CAACC,MAAM,CAAC,SAAS8B;IAC7B,wBAAwB;IAExB9C,WAAW+C,QAAQ,CAACF,MAAMC,OAAOH;IACjC,OAAO3C,WAAWwC,gBAAgB,CAACG;AACrC;AAEA;;;;;;CAMC,GACD3C,WAAWiD,SAAS,GAAG,SAAU3C,SAAS,EAAEF,MAAM;IAChD,yCAAyC;IACzC,2KAAK,CAACW,MAAM,CAACC,MAAM,CAAC,aAAaV;IACjC,2KAAK,CAACS,MAAM,CAACC,MAAM,CAAC,UAAUZ;IAC9B,wBAAwB;IAExB,MAAMqC,YAAYzC,WAAWyC,SAAS,CAACnC;IAEvCF,OAAOH,CAAC,GAAGK,UAAUL,CAAC,GAAGwC;IACzBrC,OAAOF,CAAC,GAAGI,UAAUJ,CAAC,GAAGuC;IAEzB,yCAAyC;IACzC,IAAIS,MAAM9C,OAAOH,CAAC,KAAKiD,MAAM9C,OAAOF,CAAC,GAAG;QACtC,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,OAAOE;AACT;AAEA;;;;;;CAMC,GACDJ,WAAWmD,GAAG,GAAG,SAAUN,IAAI,EAAEC,KAAK;IACpC,yCAAyC;IACzC,2KAAK,CAAC/B,MAAM,CAACC,MAAM,CAAC,QAAQ6B;IAC5B,2KAAK,CAAC9B,MAAM,CAACC,MAAM,CAAC,SAAS8B;IAC7B,wBAAwB;IAExB,OAAOD,KAAK5C,CAAC,GAAG6C,MAAM7C,CAAC,GAAG4C,KAAK3C,CAAC,GAAG4C,MAAM5C,CAAC;AAC5C;AAEA;;;;;;CAMC,GACDF,WAAWoD,KAAK,GAAG,SAAUP,IAAI,EAAEC,KAAK;IACtC,yCAAyC;IACzC,2KAAK,CAAC/B,MAAM,CAACC,MAAM,CAAC,QAAQ6B;IAC5B,2KAAK,CAAC9B,MAAM,CAACC,MAAM,CAAC,SAAS8B;IAC7B,wBAAwB;IAExB,OAAOD,KAAK5C,CAAC,GAAG6C,MAAM5C,CAAC,GAAG2C,KAAK3C,CAAC,GAAG4C,MAAM7C,CAAC;AAC5C;AAEA;;;;;;;CAOC,GACDD,WAAWqD,kBAAkB,GAAG,SAAUR,IAAI,EAAEC,KAAK,EAAE1C,MAAM;IAC3D,yCAAyC;IACzC,2KAAK,CAACW,MAAM,CAACC,MAAM,CAAC,QAAQ6B;IAC5B,2KAAK,CAAC9B,MAAM,CAACC,MAAM,CAAC,SAAS8B;IAC7B,2KAAK,CAAC/B,MAAM,CAACC,MAAM,CAAC,UAAUZ;IAC9B,wBAAwB;IAExBA,OAAOH,CAAC,GAAG4C,KAAK5C,CAAC,GAAG6C,MAAM7C,CAAC;IAC3BG,OAAOF,CAAC,GAAG2C,KAAK3C,CAAC,GAAG4C,MAAM5C,CAAC;IAC3B,OAAOE;AACT;AAEA;;;;;;;CAOC,GACDJ,WAAWsD,gBAAgB,GAAG,SAAUT,IAAI,EAAEC,KAAK,EAAE1C,MAAM;IACzD,yCAAyC;IACzC,2KAAK,CAACW,MAAM,CAACC,MAAM,CAAC,QAAQ6B;IAC5B,2KAAK,CAAC9B,MAAM,CAACC,MAAM,CAAC,SAAS8B;IAC7B,2KAAK,CAAC/B,MAAM,CAACC,MAAM,CAAC,UAAUZ;IAC9B,wBAAwB;IAExBA,OAAOH,CAAC,GAAG4C,KAAK5C,CAAC,GAAG6C,MAAM7C,CAAC;IAC3BG,OAAOF,CAAC,GAAG2C,KAAK3C,CAAC,GAAG4C,MAAM5C,CAAC;IAC3B,OAAOE;AACT;AAEA;;;;;;;CAOC,GACDJ,WAAWuD,GAAG,GAAG,SAAUV,IAAI,EAAEC,KAAK,EAAE1C,MAAM;IAC5C,yCAAyC;IACzC,2KAAK,CAACW,MAAM,CAACC,MAAM,CAAC,QAAQ6B;IAC5B,2KAAK,CAAC9B,MAAM,CAACC,MAAM,CAAC,SAAS8B;IAC7B,2KAAK,CAAC/B,MAAM,CAACC,MAAM,CAAC,UAAUZ;IAC9B,wBAAwB;IAExBA,OAAOH,CAAC,GAAG4C,KAAK5C,CAAC,GAAG6C,MAAM7C,CAAC;IAC3BG,OAAOF,CAAC,GAAG2C,KAAK3C,CAAC,GAAG4C,MAAM5C,CAAC;IAC3B,OAAOE;AACT;AAEA;;;;;;;CAOC,GACDJ,WAAW+C,QAAQ,GAAG,SAAUF,IAAI,EAAEC,KAAK,EAAE1C,MAAM;IACjD,yCAAyC;IACzC,2KAAK,CAACW,MAAM,CAACC,MAAM,CAAC,QAAQ6B;IAC5B,2KAAK,CAAC9B,MAAM,CAACC,MAAM,CAAC,SAAS8B;IAC7B,2KAAK,CAAC/B,MAAM,CAACC,MAAM,CAAC,UAAUZ;IAC9B,wBAAwB;IAExBA,OAAOH,CAAC,GAAG4C,KAAK5C,CAAC,GAAG6C,MAAM7C,CAAC;IAC3BG,OAAOF,CAAC,GAAG2C,KAAK3C,CAAC,GAAG4C,MAAM5C,CAAC;IAC3B,OAAOE;AACT;AAEA;;;;;;;CAOC,GACDJ,WAAWwD,gBAAgB,GAAG,SAAUlD,SAAS,EAAEmD,MAAM,EAAErD,MAAM;IAC/D,yCAAyC;IACzC,2KAAK,CAACW,MAAM,CAACC,MAAM,CAAC,aAAaV;IACjC,2KAAK,CAACS,MAAM,CAACW,MAAM,CAAC,UAAU+B;IAC9B,2KAAK,CAAC1C,MAAM,CAACC,MAAM,CAAC,UAAUZ;IAC9B,wBAAwB;IAExBA,OAAOH,CAAC,GAAGK,UAAUL,CAAC,GAAGwD;IACzBrD,OAAOF,CAAC,GAAGI,UAAUJ,CAAC,GAAGuD;IACzB,OAAOrD;AACT;AAEA;;;;;;;CAOC,GACDJ,WAAW0D,cAAc,GAAG,SAAUpD,SAAS,EAAEmD,MAAM,EAAErD,MAAM;IAC7D,yCAAyC;IACzC,2KAAK,CAACW,MAAM,CAACC,MAAM,CAAC,aAAaV;IACjC,2KAAK,CAACS,MAAM,CAACW,MAAM,CAAC,UAAU+B;IAC9B,2KAAK,CAAC1C,MAAM,CAACC,MAAM,CAAC,UAAUZ;IAC9B,wBAAwB;IAExBA,OAAOH,CAAC,GAAGK,UAAUL,CAAC,GAAGwD;IACzBrD,OAAOF,CAAC,GAAGI,UAAUJ,CAAC,GAAGuD;IACzB,OAAOrD;AACT;AAEA;;;;;;CAMC,GACDJ,WAAW2D,MAAM,GAAG,SAAUrD,SAAS,EAAEF,MAAM;IAC7C,yCAAyC;IACzC,2KAAK,CAACW,MAAM,CAACC,MAAM,CAAC,aAAaV;IACjC,2KAAK,CAACS,MAAM,CAACC,MAAM,CAAC,UAAUZ;IAC9B,wBAAwB;IAExBA,OAAOH,CAAC,GAAG,CAACK,UAAUL,CAAC;IACvBG,OAAOF,CAAC,GAAG,CAACI,UAAUJ,CAAC;IACvB,OAAOE;AACT;AAEA;;;;;;CAMC,GACDJ,WAAW4D,GAAG,GAAG,SAAUtD,SAAS,EAAEF,MAAM;IAC1C,yCAAyC;IACzC,2KAAK,CAACW,MAAM,CAACC,MAAM,CAAC,aAAaV;IACjC,2KAAK,CAACS,MAAM,CAACC,MAAM,CAAC,UAAUZ;IAC9B,wBAAwB;IAExBA,OAAOH,CAAC,GAAG8B,KAAK6B,GAAG,CAACtD,UAAUL,CAAC;IAC/BG,OAAOF,CAAC,GAAG6B,KAAK6B,GAAG,CAACtD,UAAUJ,CAAC;IAC/B,OAAOE;AACT;AAEA,MAAMyD,cAAc,IAAI7D;AACxB;;;;;;;;CAQC,GACDA,WAAW8D,IAAI,GAAG,SAAUC,KAAK,EAAEC,GAAG,EAAEC,CAAC,EAAE7D,MAAM;IAC/C,yCAAyC;IACzC,2KAAK,CAACW,MAAM,CAACC,MAAM,CAAC,SAAS+C;IAC7B,2KAAK,CAAChD,MAAM,CAACC,MAAM,CAAC,OAAOgD;IAC3B,2KAAK,CAACjD,MAAM,CAACW,MAAM,CAAC,KAAKuC;IACzB,2KAAK,CAAClD,MAAM,CAACC,MAAM,CAAC,UAAUZ;IAC9B,wBAAwB;IAExBJ,WAAWwD,gBAAgB,CAACQ,KAAKC,GAAGJ;IACpCzD,SAASJ,WAAWwD,gBAAgB,CAACO,OAAO,MAAME,GAAG7D;IACrD,OAAOJ,WAAWuD,GAAG,CAACM,aAAazD,QAAQA;AAC7C;AAEA,MAAM8D,sBAAsB,IAAIlE;AAChC,MAAMmE,uBAAuB,IAAInE;AACjC;;;;;;CAMC,GACDA,WAAWoE,YAAY,GAAG,SAAUvB,IAAI,EAAEC,KAAK;IAC7C,yCAAyC;IACzC,2KAAK,CAAC/B,MAAM,CAACC,MAAM,CAAC,QAAQ6B;IAC5B,2KAAK,CAAC9B,MAAM,CAACC,MAAM,CAAC,SAAS8B;IAC7B,wBAAwB;IAExB9C,WAAWiD,SAAS,CAACJ,MAAMqB;IAC3BlE,WAAWiD,SAAS,CAACH,OAAOqB;IAC5B,OAAO,0KAAU,CAACE,WAAW,CAC3BrE,WAAWmD,GAAG,CAACe,qBAAqBC;AAExC;AAEA,MAAMG,4BAA4B,IAAItE;AACtC;;;;;;CAMC,GACDA,WAAWuE,kBAAkB,GAAG,SAAUjE,SAAS,EAAEF,MAAM;IACzD,yCAAyC;IACzC,2KAAK,CAACW,MAAM,CAACC,MAAM,CAAC,aAAaV;IACjC,2KAAK,CAACS,MAAM,CAACC,MAAM,CAAC,UAAUZ;IAC9B,wBAAwB;IAExB,MAAMoE,IAAIxE,WAAWiD,SAAS,CAAC3C,WAAWgE;IAC1CtE,WAAW4D,GAAG,CAACY,GAAGA;IAElB,IAAIA,EAAEvE,CAAC,IAAIuE,EAAEtE,CAAC,EAAE;QACdE,SAASJ,WAAWK,KAAK,CAACL,WAAWyE,MAAM,EAAErE;IAC/C,OAAO;QACLA,SAASJ,WAAWK,KAAK,CAACL,WAAW0E,MAAM,EAAEtE;IAC/C;IAEA,OAAOA;AACT;AAEA;;;;;;;CAOC,GACDJ,WAAW2E,MAAM,GAAG,SAAU9B,IAAI,EAAEC,KAAK;IACvC,OACED,SAASC,SACR,IAAA,6KAAO,EAACD,SACP,IAAA,6KAAO,EAACC,UACRD,KAAK5C,CAAC,KAAK6C,MAAM7C,CAAC,IAClB4C,KAAK3C,CAAC,KAAK4C,MAAM5C,CAAC;AAExB;AAEA;;CAEC,GACDF,WAAW4E,WAAW,GAAG,SAAUtE,SAAS,EAAEO,KAAK,EAAEgE,MAAM;IACzD,OAAOvE,UAAUL,CAAC,KAAKY,KAAK,CAACgE,OAAO,IAAIvE,UAAUJ,CAAC,KAAKW,KAAK,CAACgE,SAAS,EAAE;AAC3E;AAEA;;;;;;;;;;CAUC,GACD7E,WAAW8E,aAAa,GAAG,SACzBjC,IAAI,EACJC,KAAK,EACLiC,eAAe,EACfC,eAAe;IAEf,OACEnC,SAASC,SACR,IAAA,6KAAO,EAACD,SACP,IAAA,6KAAO,EAACC,UACR,0KAAU,CAACgC,aAAa,CACtBjC,KAAK5C,CAAC,EACN6C,MAAM7C,CAAC,EACP8E,iBACAC,oBAEF,0KAAU,CAACF,aAAa,CACtBjC,KAAK3C,CAAC,EACN4C,MAAM5C,CAAC,EACP6E,iBACAC;AAGR;AAEA;;;;;CAKC,GACDhF,WAAWiF,IAAI,GAAGC,OAAOC,MAAM,CAAC,IAAInF,WAAW,KAAK;AAEpD;;;;;CAKC,GACDA,WAAWoF,GAAG,GAAGF,OAAOC,MAAM,CAAC,IAAInF,WAAW,KAAK;AAEnD;;;;;CAKC,GACDA,WAAWyE,MAAM,GAAGS,OAAOC,MAAM,CAAC,IAAInF,WAAW,KAAK;AAEtD;;;;;CAKC,GACDA,WAAW0E,MAAM,GAAGQ,OAAOC,MAAM,CAAC,IAAInF,WAAW,KAAK;AAEtD;;;;;CAKC,GACDA,WAAWqF,SAAS,CAAChF,KAAK,GAAG,SAAUD,MAAM;IAC3C,OAAOJ,WAAWK,KAAK,CAAC,IAAI,EAAED;AAChC;AAEA;;;;;;CAMC,GACDJ,WAAWqF,SAAS,CAACV,MAAM,GAAG,SAAU7B,KAAK;IAC3C,OAAO9C,WAAW2E,MAAM,CAAC,IAAI,EAAE7B;AACjC;AAEA;;;;;;;;;CASC,GACD9C,WAAWqF,SAAS,CAACP,aAAa,GAAG,SACnChC,KAAK,EACLiC,eAAe,EACfC,eAAe;IAEf,OAAOhF,WAAW8E,aAAa,CAC7B,IAAI,EACJhC,OACAiC,iBACAC;AAEJ;AAEA;;;;CAIC,GACDhF,WAAWqF,SAAS,CAACC,QAAQ,GAAG;IAC9B,OAAO,CAAC,CAAC,EAAE,IAAI,CAACrF,CAAC,CAAC,EAAE,EAAE,IAAI,CAACC,CAAC,CAAC,CAAC,CAAC;AACjC;uCACeF","ignoreList":[0]}},
    {"offset": {"line": 7223, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Ellipsoid.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\n\nfunction initialize(ellipsoid, x, y, z) {\n  x = x ?? 0.0;\n  y = y ?? 0.0;\n  z = z ?? 0.0;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"x\", x, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"y\", y, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"z\", z, 0.0);\n  //>>includeEnd('debug');\n\n  ellipsoid._radii = new Cartesian3(x, y, z);\n\n  ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);\n\n  ellipsoid._radiiToTheFourth = new Cartesian3(\n    x * x * x * x,\n    y * y * y * y,\n    z * z * z * z,\n  );\n\n  ellipsoid._oneOverRadii = new Cartesian3(\n    x === 0.0 ? 0.0 : 1.0 / x,\n    y === 0.0 ? 0.0 : 1.0 / y,\n    z === 0.0 ? 0.0 : 1.0 / z,\n  );\n\n  ellipsoid._oneOverRadiiSquared = new Cartesian3(\n    x === 0.0 ? 0.0 : 1.0 / (x * x),\n    y === 0.0 ? 0.0 : 1.0 / (y * y),\n    z === 0.0 ? 0.0 : 1.0 / (z * z),\n  );\n\n  ellipsoid._minimumRadius = Math.min(x, y, z);\n\n  ellipsoid._maximumRadius = Math.max(x, y, z);\n\n  ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;\n\n  if (ellipsoid._radiiSquared.z !== 0) {\n    ellipsoid._squaredXOverSquaredZ =\n      ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;\n  }\n}\n\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\n * by Cesium to represent the shape of planetary bodies.\n *\n * Rather than constructing this object directly, one of the provided\n * constants is normally used.\n * @alias Ellipsoid\n * @constructor\n *\n * @param {number} [x=0] The radius in the x direction.\n * @param {number} [y=0] The radius in the y direction.\n * @param {number} [z=0] The radius in the z direction.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.fromCartesian3\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nfunction Ellipsoid(x, y, z) {\n  this._radii = undefined;\n  this._radiiSquared = undefined;\n  this._radiiToTheFourth = undefined;\n  this._oneOverRadii = undefined;\n  this._oneOverRadiiSquared = undefined;\n  this._minimumRadius = undefined;\n  this._maximumRadius = undefined;\n  this._centerToleranceSquared = undefined;\n  this._squaredXOverSquaredZ = undefined;\n\n  initialize(this, x, y, z);\n}\n\nObject.defineProperties(Ellipsoid.prototype, {\n  /**\n   * Gets the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radii: {\n    get: function () {\n      return this._radii;\n    },\n  },\n  /**\n   * Gets the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiSquared: {\n    get: function () {\n      return this._radiiSquared;\n    },\n  },\n  /**\n   * Gets the radii of the ellipsoid raise to the fourth power.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiToTheFourth: {\n    get: function () {\n      return this._radiiToTheFourth;\n    },\n  },\n  /**\n   * Gets one over the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadii: {\n    get: function () {\n      return this._oneOverRadii;\n    },\n  },\n  /**\n   * Gets one over the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadiiSquared: {\n    get: function () {\n      return this._oneOverRadiiSquared;\n    },\n  },\n  /**\n   * Gets the minimum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {number}\n   * @readonly\n   */\n  minimumRadius: {\n    get: function () {\n      return this._minimumRadius;\n    },\n  },\n  /**\n   * Gets the maximum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {number}\n   * @readonly\n   */\n  maximumRadius: {\n    get: function () {\n      return this._maximumRadius;\n    },\n  },\n});\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\n */\nEllipsoid.clone = function (ellipsoid, result) {\n  if (!defined(ellipsoid)) {\n    return undefined;\n  }\n  const radii = ellipsoid._radii;\n\n  if (!defined(result)) {\n    return new Ellipsoid(radii.x, radii.y, radii.z);\n  }\n\n  Cartesian3.clone(radii, result._radii);\n  Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);\n  Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\n  Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\n  Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\n  result._minimumRadius = ellipsoid._minimumRadius;\n  result._maximumRadius = ellipsoid._maximumRadius;\n  result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\n\n  return result;\n};\n\n/**\n * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\n *\n * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} A new Ellipsoid instance.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nEllipsoid.fromCartesian3 = function (cartesian, result) {\n  if (!defined(result)) {\n    result = new Ellipsoid();\n  }\n\n  if (!defined(cartesian)) {\n    return result;\n  }\n\n  initialize(result, cartesian.x, cartesian.y, cartesian.z);\n  return result;\n};\n\n/**\n * An Ellipsoid instance initialized to the WGS84 standard.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.WGS84 = Object.freeze(\n  new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793),\n);\n\n/**\n * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));\n\n/**\n * An Ellipsoid instance initialized to a sphere with the lunar radius.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.MOON = Object.freeze(\n  new Ellipsoid(\n    CesiumMath.LUNAR_RADIUS,\n    CesiumMath.LUNAR_RADIUS,\n    CesiumMath.LUNAR_RADIUS,\n  ),\n);\n\n/**\n * An Ellipsoid instance initialized to a sphere with the mean radii of Mars.\n * Source: https://epsg.io/104905\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.MARS = Object.freeze(new Ellipsoid(3396190.0, 3396190.0, 3376200.0));\n\nEllipsoid._default = Ellipsoid.WGS84;\nObject.defineProperties(Ellipsoid, {\n  /**\n   * The default ellipsoid used when not otherwise specified.\n   * @memberof Ellipsoid\n   * @type {Ellipsoid}\n   * @example\n   * Cesium.Ellipsoid.default = Cesium.Ellipsoid.MOON;\n   *\n   * // Apollo 11 landing site\n   * const position = Cesium.Cartesian3.fromRadians(\n   *   0.67416,\n   *   23.47315,\n   * );\n   */\n  default: {\n    get: function () {\n      return Ellipsoid._default;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"value\", value);\n      //>>includeEnd('debug');\n\n      Ellipsoid._default = value;\n      Cartesian3._ellipsoidRadiiSquared = value.radiiSquared;\n      Cartographic._ellipsoidOneOverRadii = value.oneOverRadii;\n      Cartographic._ellipsoidOneOverRadiiSquared = value.oneOverRadiiSquared;\n      Cartographic._ellipsoidCenterToleranceSquared =\n        value._centerToleranceSquared;\n    },\n  },\n});\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid.\n */\nEllipsoid.prototype.clone = function (result) {\n  return Ellipsoid.clone(this, result);\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nEllipsoid.packedLength = Cartesian3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Ellipsoid} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nEllipsoid.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  Cartesian3.pack(value._radii, array, startingIndex);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Ellipsoid} [result] The object into which to store the result.\n * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\n */\nEllipsoid.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const radii = Cartesian3.unpack(array, startingIndex);\n  return Ellipsoid.fromCartesian3(radii, result);\n};\n\n/**\n * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geodeticSurfaceNormalCartographic = function (\n  cartographic,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  const longitude = cartographic.longitude;\n  const latitude = cartographic.latitude;\n  const cosLatitude = Math.cos(latitude);\n\n  const x = cosLatitude * Math.cos(longitude);\n  const y = cosLatitude * Math.sin(longitude);\n  const z = Math.sin(latitude);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return Cartesian3.normalize(result, result);\n};\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided, or undefined if a normal cannot be found.\n */\nEllipsoid.prototype.geodeticSurfaceNormal = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  if (isNaN(cartesian.x) || isNaN(cartesian.y) || isNaN(cartesian.z)) {\n    throw new DeveloperError(\"cartesian has a NaN component\");\n  }\n  //>>includeEnd('debug');\n  if (\n    Cartesian3.equalsEpsilon(cartesian, Cartesian3.ZERO, CesiumMath.EPSILON14)\n  ) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result = Cartesian3.multiplyComponents(\n    cartesian,\n    this._oneOverRadiiSquared,\n    result,\n  );\n  return Cartesian3.normalize(result, result);\n};\n\nconst cartographicToCartesianNormal = new Cartesian3();\nconst cartographicToCartesianK = new Cartesian3();\n\n/**\n * Converts the provided cartographic to Cartesian representation.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n *\n * @example\n * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\n * const position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\n * const cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\n */\nEllipsoid.prototype.cartographicToCartesian = function (cartographic, result) {\n  //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\n  const n = cartographicToCartesianNormal;\n  const k = cartographicToCartesianK;\n  this.geodeticSurfaceNormalCartographic(cartographic, n);\n  Cartesian3.multiplyComponents(this._radiiSquared, n, k);\n  const gamma = Math.sqrt(Cartesian3.dot(n, k));\n  Cartesian3.divideByScalar(k, gamma, k);\n  Cartesian3.multiplyByScalar(n, cartographic.height, n);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(k, n, result);\n};\n\n/**\n * Converts the provided array of cartographics to an array of Cartesians.\n *\n * @param {Cartographic[]} cartographics An array of cartographic positions.\n * @param {Cartesian3[]} [result] The object onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\n * const positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\n * const cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\n */\nEllipsoid.prototype.cartographicArrayToCartesianArray = function (\n  cartographics,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics);\n  //>>includeEnd('debug');\n\n  const length = cartographics.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (let i = 0; i < length; i++) {\n    result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\n  }\n  return result;\n};\n\nconst cartesianToCartographicN = new Cartesian3();\nconst cartesianToCartographicP = new Cartesian3();\nconst cartesianToCartographicH = new Cartesian3();\n\n/**\n * Converts the provided cartesian to cartographic representation.\n * The cartesian is undefined at the center of the ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n *\n * @example\n * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\n * const position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\n * const cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\n */\nEllipsoid.prototype.cartesianToCartographic = function (cartesian, result) {\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  const p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);\n\n  if (!defined(p)) {\n    return undefined;\n  }\n\n  const n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);\n  const h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n\n  const longitude = Math.atan2(n.y, n.x);\n  const latitude = Math.asin(n.z);\n  const height =\n    CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Converts the provided array of cartesians to an array of cartographics.\n *\n * @param {Cartesian3[]} cartesians An array of Cartesian positions.\n * @param {Cartographic[]} [result] The object onto which to store the result.\n * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\n * const positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\n *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\n *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\n * const cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\n */\nEllipsoid.prototype.cartesianArrayToCartographicArray = function (\n  cartesians,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  const length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (let i = 0; i < length; ++i) {\n    result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\n  }\n  return result;\n};\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n */\nEllipsoid.prototype.scaleToGeodeticSurface = function (cartesian, result) {\n  return scaleToGeodeticSurface(\n    cartesian,\n    this._oneOverRadii,\n    this._oneOverRadiiSquared,\n    this._centerToleranceSquared,\n    result,\n  );\n};\n\n/**\n * Scales the provided Cartesian position along the geocentric surface normal\n * so that it is on the surface of this ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.scaleToGeocentricSurface = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const positionX = cartesian.x;\n  const positionY = cartesian.y;\n  const positionZ = cartesian.z;\n  const oneOverRadiiSquared = this._oneOverRadiiSquared;\n\n  const beta =\n    1.0 /\n    Math.sqrt(\n      positionX * positionX * oneOverRadiiSquared.x +\n        positionY * positionY * oneOverRadiiSquared.y +\n        positionZ * positionZ * oneOverRadiiSquared.z,\n    );\n\n  return Cartesian3.multiplyByScalar(cartesian, beta, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#oneOverRadii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionToScaledSpace = function (\n  position,\n  result,\n) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#radii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionFromScaledSpace = function (\n  position,\n  result,\n) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._radii, result);\n};\n\n/**\n * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Ellipsoid} [right] The other Ellipsoid.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nEllipsoid.prototype.equals = function (right) {\n  return (\n    this === right ||\n    (defined(right) && Cartesian3.equals(this._radii, right._radii))\n  );\n};\n\n/**\n * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n *\n * @returns {string} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n */\nEllipsoid.prototype.toString = function () {\n  return this._radii.toString();\n};\n\n/**\n * Computes a point which is the intersection of the surface normal with the z-axis.\n *\n * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.\n * @param {number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\n *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\n *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\n *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\n * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise\n *\n * @exception {DeveloperError} position is required.\n * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).\n * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.\n */\nEllipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function (\n  position,\n  buffer,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"position\", position);\n\n  if (\n    !CesiumMath.equalsEpsilon(\n      this._radii.x,\n      this._radii.y,\n      CesiumMath.EPSILON15,\n    )\n  ) {\n    throw new DeveloperError(\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\",\n    );\n  }\n\n  Check.typeOf.number.greaterThan(\"Ellipsoid.radii.z\", this._radii.z, 0);\n  //>>includeEnd('debug');\n\n  buffer = buffer ?? 0.0;\n\n  const squaredXOverSquaredZ = this._squaredXOverSquaredZ;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result.x = 0.0;\n  result.y = 0.0;\n  result.z = position.z * (1 - squaredXOverSquaredZ);\n\n  if (Math.abs(result.z) >= this._radii.z - buffer) {\n    return undefined;\n  }\n\n  return result;\n};\n\nconst scratchEndpoint = new Cartesian3();\n\n/**\n * Computes the ellipsoid curvatures at a given position on the surface.\n *\n * @param {Cartesian3} surfacePosition The position on the ellipsoid surface where curvatures will be calculated.\n * @param {Cartesian2} [result] The cartesian to which to copy the result, or undefined to create and return a new instance.\n * @returns {Cartesian2} The local curvature of the ellipsoid surface at the provided position, in east and north directions.\n *\n * @exception {DeveloperError} position is required.\n */\nEllipsoid.prototype.getLocalCurvature = function (surfacePosition, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"surfacePosition\", surfacePosition);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  const primeVerticalEndpoint = this.getSurfaceNormalIntersectionWithZAxis(\n    surfacePosition,\n    0.0,\n    scratchEndpoint,\n  );\n  const primeVerticalRadius = Cartesian3.distance(\n    surfacePosition,\n    primeVerticalEndpoint,\n  );\n  // meridional radius = (1 - e^2) * primeVerticalRadius^3 / a^2\n  // where 1 - e^2 = b^2 / a^2,\n  // so meridional = b^2 * primeVerticalRadius^3 / a^4\n  //   = (b * primeVerticalRadius / a^2)^2 * primeVertical\n  const radiusRatio =\n    (this.minimumRadius * primeVerticalRadius) / this.maximumRadius ** 2;\n  const meridionalRadius = primeVerticalRadius * radiusRatio ** 2;\n\n  return Cartesian2.fromElements(\n    1.0 / primeVerticalRadius,\n    1.0 / meridionalRadius,\n    result,\n  );\n};\n\nconst abscissas = [\n  0.14887433898163, 0.43339539412925, 0.67940956829902, 0.86506336668898,\n  0.97390652851717, 0.0,\n];\nconst weights = [\n  0.29552422471475, 0.26926671930999, 0.21908636251598, 0.14945134915058,\n  0.066671344308684, 0.0,\n];\n\n/**\n * Compute the 10th order Gauss-Legendre Quadrature of the given definite integral.\n *\n * @param {number} a The lower bound for the integration.\n * @param {number} b The upper bound for the integration.\n * @param {Ellipsoid~RealValuedScalarFunction} func The function to integrate.\n * @returns {number} The value of the integral of the given function over the given domain.\n *\n * @private\n */\nfunction gaussLegendreQuadrature(a, b, func) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"a\", a);\n  Check.typeOf.number(\"b\", b);\n  Check.typeOf.func(\"func\", func);\n  //>>includeEnd('debug');\n\n  // The range is half of the normal range since the five weights add to one (ten weights add to two).\n  // The values of the abscissas are multiplied by two to account for this.\n  const xMean = 0.5 * (b + a);\n  const xRange = 0.5 * (b - a);\n\n  let sum = 0.0;\n  for (let i = 0; i < 5; i++) {\n    const dx = xRange * abscissas[i];\n    sum += weights[i] * (func(xMean + dx) + func(xMean - dx));\n  }\n\n  // Scale the sum to the range of x.\n  sum *= xRange;\n  return sum;\n}\n\n/**\n * A real valued scalar function.\n * @callback Ellipsoid~RealValuedScalarFunction\n *\n * @param {number} x The value used to evaluate the function.\n * @returns {number} The value of the function at x.\n *\n * @private\n */\n\n/**\n * Computes an approximation of the surface area of a rectangle on the surface of an ellipsoid using\n * Gauss-Legendre 10th order quadrature.\n *\n * @param {Rectangle} rectangle The rectangle used for computing the surface area.\n * @returns {number} The approximate area of the rectangle on the surface of this ellipsoid.\n */\nEllipsoid.prototype.surfaceArea = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  const minLongitude = rectangle.west;\n  let maxLongitude = rectangle.east;\n  const minLatitude = rectangle.south;\n  const maxLatitude = rectangle.north;\n\n  while (maxLongitude < minLongitude) {\n    maxLongitude += CesiumMath.TWO_PI;\n  }\n\n  const radiiSquared = this._radiiSquared;\n  const a2 = radiiSquared.x;\n  const b2 = radiiSquared.y;\n  const c2 = radiiSquared.z;\n  const a2b2 = a2 * b2;\n  return gaussLegendreQuadrature(minLatitude, maxLatitude, function (lat) {\n    // phi represents the angle measured from the north pole\n    // sin(phi) = sin(pi / 2 - lat) = cos(lat), cos(phi) is similar\n    const sinPhi = Math.cos(lat);\n    const cosPhi = Math.sin(lat);\n    return (\n      Math.cos(lat) *\n      gaussLegendreQuadrature(minLongitude, maxLongitude, function (lon) {\n        const cosTheta = Math.cos(lon);\n        const sinTheta = Math.sin(lon);\n        return Math.sqrt(\n          a2b2 * cosPhi * cosPhi +\n            c2 *\n              (b2 * cosTheta * cosTheta + a2 * sinTheta * sinTheta) *\n              sinPhi *\n              sinPhi,\n        );\n      })\n    );\n  });\n};\n\nexport default Ellipsoid;\n"],"names":["initialize","ellipsoid","x","y","z","typeOf","number","greaterThanOrEquals","_radii","_radiiSquared","_radiiToTheFourth","_oneOverRadii","_oneOverRadiiSquared","_minimumRadius","Math","min","_maximumRadius","max","_centerToleranceSquared","EPSILON1","_squaredXOverSquaredZ","Ellipsoid","undefined","Object","defineProperties","prototype","radii","get","radiiSquared","radiiToTheFourth","oneOverRadii","oneOverRadiiSquared","minimumRadius","maximumRadius","clone","result","fromCartesian3","cartesian","WGS84","freeze","UNIT_SPHERE","MOON","LUNAR_RADIUS","MARS","_default","default","set","value","object","_ellipsoidRadiiSquared","_ellipsoidOneOverRadii","_ellipsoidOneOverRadiiSquared","_ellipsoidCenterToleranceSquared","packedLength","pack","array","startingIndex","defined","unpack","geocentricSurfaceNormal","normalize","geodeticSurfaceNormalCartographic","cartographic","longitude","latitude","cosLatitude","cos","sin","geodeticSurfaceNormal","isNaN","equalsEpsilon","ZERO","EPSILON14","multiplyComponents","cartographicToCartesianNormal","cartographicToCartesianK","cartographicToCartesian","n","k","gamma","sqrt","dot","divideByScalar","multiplyByScalar","height","add","cartographicArrayToCartesianArray","cartographics","length","Array","i","cartesianToCartographicN","cartesianToCartographicP","cartesianToCartographicH","cartesianToCartographic","p","scaleToGeodeticSurface","h","subtract","atan2","asin","sign","magnitude","cartesianArrayToCartographicArray","cartesians","scaleToGeocentricSurface","positionX","positionY","positionZ","beta","transformPositionToScaledSpace","position","transformPositionFromScaledSpace","equals","right","toString","getSurfaceNormalIntersectionWithZAxis","buffer","EPSILON15","greaterThan","squaredXOverSquaredZ","abs","scratchEndpoint","getLocalCurvature","surfacePosition","primeVerticalEndpoint","primeVerticalRadius","distance","radiusRatio","meridionalRadius","fromElements","abscissas","weights","gaussLegendreQuadrature","a","b","func","xMean","xRange","sum","dx","surfaceArea","rectangle","minLongitude","west","maxLongitude","east","minLatitude","south","maxLatitude","north","TWO_PI","a2","b2","c2","a2b2","lat","sinPhi","cosPhi","lon","cosTheta","sinTheta"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7916, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/GeographicProjection.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\n\n/**\n * A simple map projection where longitude and latitude are linearly mapped to X and Y by multiplying\n * them by the {@link Ellipsoid#maximumRadius}.  This projection\n * is commonly known as geographic, equirectangular, equidistant cylindrical, or plate carrÃ©e. When using the WGS84 ellipsoid, it\n * is also known as EPSG:4326.\n *\n * @alias GeographicProjection\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid.\n *\n * @see WebMercatorProjection\n */\nfunction GeographicProjection(ellipsoid) {\n  this._ellipsoid = ellipsoid ?? Ellipsoid.default;\n  this._semimajorAxis = this._ellipsoid.maximumRadius;\n  this._oneOverSemimajorAxis = 1.0 / this._semimajorAxis;\n}\n\nObject.defineProperties(GeographicProjection.prototype, {\n  /**\n   * Gets the {@link Ellipsoid}.\n   *\n   * @memberof GeographicProjection.prototype\n   *\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n});\n\n/**\n * Projects a set of {@link Cartographic} coordinates, in radians, to map coordinates, in meters.\n * X and Y are the longitude and latitude, respectively, multiplied by the maximum radius of the\n * ellipsoid.  Z is the unmodified height.\n *\n * @param {Cartographic} cartographic The coordinates to project.\n * @param {Cartesian3} [result] An instance into which to copy the result.  If this parameter is\n *        undefined, a new instance is created and returned.\n * @returns {Cartesian3} The projected coordinates.  If the result parameter is not undefined, the\n *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is\n *          created and returned.\n */\nGeographicProjection.prototype.project = function (cartographic, result) {\n  // Actually this is the special case of equidistant cylindrical called the plate carree\n  const semimajorAxis = this._semimajorAxis;\n  const x = cartographic.longitude * semimajorAxis;\n  const y = cartographic.latitude * semimajorAxis;\n  const z = cartographic.height;\n\n  if (!defined(result)) {\n    return new Cartesian3(x, y, z);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Unprojects a set of projected {@link Cartesian3} coordinates, in meters, to {@link Cartographic}\n * coordinates, in radians.  Longitude and Latitude are the X and Y coordinates, respectively,\n * divided by the maximum radius of the ellipsoid.  Height is the unmodified Z coordinate.\n *\n * @param {Cartesian3} cartesian The Cartesian position to unproject with height (z) in meters.\n * @param {Cartographic} [result] An instance into which to copy the result.  If this parameter is\n *        undefined, a new instance is created and returned.\n * @returns {Cartographic} The unprojected coordinates.  If the result parameter is not undefined, the\n *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is\n *          created and returned.\n */\nGeographicProjection.prototype.unproject = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required\");\n  }\n  //>>includeEnd('debug');\n\n  const oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;\n  const longitude = cartesian.x * oneOverEarthSemimajorAxis;\n  const latitude = cartesian.y * oneOverEarthSemimajorAxis;\n  const height = cartesian.z;\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\nexport default GeographicProjection;\n"],"names":["GeographicProjection","ellipsoid","_ellipsoid","default","_semimajorAxis","maximumRadius","_oneOverSemimajorAxis","Object","defineProperties","prototype","get","project","cartographic","result","semimajorAxis","x","longitude","y","latitude","z","height","unproject","cartesian","oneOverEarthSemimajorAxis"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;;;;;CAYC,GACD,SAASA,qBAAqBC,SAAS;IACrC,IAAI,CAACC,UAAU,GAAGD,aAAa,+KAAS,CAACE,OAAO;IAChD,IAAI,CAACC,cAAc,GAAG,IAAI,CAACF,UAAU,CAACG,aAAa;IACnD,IAAI,CAACC,qBAAqB,GAAG,MAAM,IAAI,CAACF,cAAc;AACxD;AAEAG,OAAOC,gBAAgB,CAACR,qBAAqBS,SAAS,EAAE;IACtD;;;;;;;GAOC,GACDR,WAAW;QACTS,KAAK;YACH,OAAO,IAAI,CAACR,UAAU;QACxB;IACF;AACF;AAEA;;;;;;;;;;;CAWC,GACDF,qBAAqBS,SAAS,CAACE,OAAO,GAAG,SAAUC,YAAY,EAAEC,MAAM;IACrE,uFAAuF;IACvF,MAAMC,gBAAgB,IAAI,CAACV,cAAc;IACzC,MAAMW,IAAIH,aAAaI,SAAS,GAAGF;IACnC,MAAMG,IAAIL,aAAaM,QAAQ,GAAGJ;IAClC,MAAMK,IAAIP,aAAaQ,MAAM;IAE7B,IAAI,CAAC,IAAA,6KAAO,EAACP,SAAS;QACpB,OAAO,IAAI,gLAAU,CAACE,GAAGE,GAAGE;IAC9B;IAEAN,OAAOE,CAAC,GAAGA;IACXF,OAAOI,CAAC,GAAGA;IACXJ,OAAOM,CAAC,GAAGA;IACX,OAAON;AACT;AAEA;;;;;;;;;;;CAWC,GACDb,qBAAqBS,SAAS,CAACY,SAAS,GAAG,SAAUC,SAAS,EAAET,MAAM;IACpE,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACS,YAAY;QACvB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAMC,4BAA4B,IAAI,CAACjB,qBAAqB;IAC5D,MAAMU,YAAYM,UAAUP,CAAC,GAAGQ;IAChC,MAAML,WAAWI,UAAUL,CAAC,GAAGM;IAC/B,MAAMH,SAASE,UAAUH,CAAC;IAE1B,IAAI,CAAC,IAAA,6KAAO,EAACN,SAAS;QACpB,OAAO,IAAI,kLAAY,CAACG,WAAWE,UAAUE;IAC/C;IAEAP,OAAOG,SAAS,GAAGA;IACnBH,OAAOK,QAAQ,GAAGA;IAClBL,OAAOO,MAAM,GAAGA;IAChB,OAAOP;AACT;uCAEeb","ignoreList":[0]}},
    {"offset": {"line": 8020, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Intersect.js"],"sourcesContent":["/**\n * This enumerated type is used in determining where, relative to the frustum, an\n * object is located. The object can either be fully contained within the frustum (INSIDE),\n * partially inside the frustum and partially outside (INTERSECTING), or somewhere entirely\n * outside of the frustum's 6 planes (OUTSIDE).\n *\n * @enum {number}\n */\nconst Intersect = {\n  /**\n   * Represents that an object is not contained within the frustum.\n   *\n   * @type {number}\n   * @constant\n   */\n  OUTSIDE: -1,\n\n  /**\n   * Represents that an object intersects one of the frustum's planes.\n   *\n   * @type {number}\n   * @constant\n   */\n  INTERSECTING: 0,\n\n  /**\n   * Represents that an object is fully within the frustum.\n   *\n   * @type {number}\n   * @constant\n   */\n  INSIDE: 1,\n};\nexport default Object.freeze(Intersect);\n"],"names":["Intersect","OUTSIDE","INTERSECTING","INSIDE","Object","freeze"],"mappings":";;;;AAAA;;;;;;;CAOC,GACD,MAAMA,YAAY;IAChB;;;;;GAKC,GACDC,SAAS,CAAC;IAEV;;;;;GAKC,GACDC,cAAc;IAEd;;;;;GAKC,GACDC,QAAQ;AACV;uCACeC,OAAOC,MAAM,CAACL","ignoreList":[0]}},
    {"offset": {"line": 8056, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Interval.js"],"sourcesContent":["/**\n * Represents the closed interval [start, stop].\n * @alias Interval\n * @constructor\n *\n * @param {number} [start=0.0] The beginning of the interval.\n * @param {number} [stop=0.0] The end of the interval.\n */\nfunction Interval(start, stop) {\n  /**\n   * The beginning of the interval.\n   * @type {number}\n   * @default 0.0\n   */\n  this.start = start ?? 0.0;\n  /**\n   * The end of the interval.\n   * @type {number}\n   * @default 0.0\n   */\n  this.stop = stop ?? 0.0;\n}\nexport default Interval;\n"],"names":["Interval","start","stop"],"mappings":";;;;AAAA;;;;;;;CAOC,GACD,SAASA,SAASC,KAAK,EAAEC,IAAI;IAC3B;;;;GAIC,GACD,IAAI,CAACD,KAAK,GAAGA,SAAS;IACtB;;;;GAIC,GACD,IAAI,CAACC,IAAI,GAAGA,QAAQ;AACtB;uCACeF","ignoreList":[0]}},
    {"offset": {"line": 8084, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Matrix3.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 3x3 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix3\n * @constructor\n * @implements {ArrayLike<number>}\n *\n * @param {number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {number} [column2Row0=0.0] The value for column 2, row 0.\n * @param {number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {number} [column1Row1=0.0] The value for column 1, row 1.\n * @param {number} [column2Row1=0.0] The value for column 2, row 1.\n * @param {number} [column0Row2=0.0] The value for column 0, row 2.\n * @param {number} [column1Row2=0.0] The value for column 1, row 2.\n * @param {number} [column2Row2=0.0] The value for column 2, row 2.\n *\n * @see Matrix3.fromArray\n * @see Matrix3.fromColumnMajorArray\n * @see Matrix3.fromRowMajorArray\n * @see Matrix3.fromQuaternion\n * @see Matrix3.fromHeadingPitchRoll\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.fromCrossProduct\n * @see Matrix3.fromRotationX\n * @see Matrix3.fromRotationY\n * @see Matrix3.fromRotationZ\n * @see Matrix2\n * @see Matrix4\n */\nfunction Matrix3(\n  column0Row0,\n  column1Row0,\n  column2Row0,\n  column0Row1,\n  column1Row1,\n  column2Row1,\n  column0Row2,\n  column1Row2,\n  column2Row2,\n) {\n  this[0] = column0Row0 ?? 0.0;\n  this[1] = column0Row1 ?? 0.0;\n  this[2] = column0Row2 ?? 0.0;\n  this[3] = column1Row0 ?? 0.0;\n  this[4] = column1Row1 ?? 0.0;\n  this[5] = column1Row2 ?? 0.0;\n  this[6] = column2Row0 ?? 0.0;\n  this[7] = column2Row1 ?? 0.0;\n  this[8] = column2Row2 ?? 0.0;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nMatrix3.packedLength = 9;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix3} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nMatrix3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n  array[startingIndex++] = value[4];\n  array[startingIndex++] = value[5];\n  array[startingIndex++] = value[6];\n  array[startingIndex++] = value[7];\n  array[startingIndex++] = value[8];\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix3} [result] The object into which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n */\nMatrix3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  result[4] = array[startingIndex++];\n  result[5] = array[startingIndex++];\n  result[6] = array[startingIndex++];\n  result[7] = array[startingIndex++];\n  result[8] = array[startingIndex++];\n  return result;\n};\n\n/**\n * Flattens an array of Matrix3s into an array of components. The components\n * are stored in column-major order.\n *\n * @param {Matrix3[]} array The array of matrices to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 9 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 9) elements.\n * @returns {number[]} The packed array.\n */\nMatrix3.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 9;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 9 elements\",\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Matrix3.pack(array[i], result, i * 9);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of column-major matrix components into an array of Matrix3s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Matrix3[]} [result] The array onto which to store the result.\n * @returns {Matrix3[]} The unpacked array.\n */\nMatrix3.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 9);\n  if (array.length % 9 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 9.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 9);\n  } else {\n    result.length = length / 9;\n  }\n\n  for (let i = 0; i < length; i += 9) {\n    const index = i / 9;\n    result[index] = Matrix3.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Duplicates a Matrix3 instance.\n *\n * @param {Matrix3} matrix The matrix to duplicate.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix3.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Matrix3(\n      matrix[0],\n      matrix[3],\n      matrix[6],\n      matrix[1],\n      matrix[4],\n      matrix[7],\n      matrix[2],\n      matrix[5],\n      matrix[8],\n    );\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  return result;\n};\n\n/**\n * Creates a Matrix3 from 9 consecutive elements in an array.\n *\n * @function\n * @param {number[]} array The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Create the Matrix3:\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n *\n * const v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * const m = Cesium.Matrix3.fromArray(v);\n *\n * // Create same Matrix3 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * const m2 = Cesium.Matrix3.fromArray(v2, 2);\n */\nMatrix3.fromArray = Matrix3.unpack;\n\n/**\n * Creates a Matrix3 instance from a column-major order array.\n *\n * @param {number[]} values The column-major order array.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n */\nMatrix3.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix3.clone(values, result);\n};\n\n/**\n * Creates a Matrix3 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {number[]} values The row-major order array.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n */\nMatrix3.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(\n      values[0],\n      values[1],\n      values[2],\n      values[3],\n      values[4],\n      values[5],\n      values[6],\n      values[7],\n      values[8],\n    );\n  }\n  result[0] = values[0];\n  result[1] = values[3];\n  result[2] = values[6];\n  result[3] = values[1];\n  result[4] = values[4];\n  result[5] = values[7];\n  result[6] = values[2];\n  result[7] = values[5];\n  result[8] = values[8];\n  return result;\n};\n\n/**\n * Computes a 3x3 rotation matrix from the provided quaternion.\n *\n * @param {Quaternion} quaternion the quaternion to use.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The 3x3 rotation matrix from this quaternion.\n */\nMatrix3.fromQuaternion = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  const x2 = quaternion.x * quaternion.x;\n  const xy = quaternion.x * quaternion.y;\n  const xz = quaternion.x * quaternion.z;\n  const xw = quaternion.x * quaternion.w;\n  const y2 = quaternion.y * quaternion.y;\n  const yz = quaternion.y * quaternion.z;\n  const yw = quaternion.y * quaternion.w;\n  const z2 = quaternion.z * quaternion.z;\n  const zw = quaternion.z * quaternion.w;\n  const w2 = quaternion.w * quaternion.w;\n\n  const m00 = x2 - y2 - z2 + w2;\n  const m01 = 2.0 * (xy - zw);\n  const m02 = 2.0 * (xz + yw);\n\n  const m10 = 2.0 * (xy + zw);\n  const m11 = -x2 + y2 - z2 + w2;\n  const m12 = 2.0 * (yz - xw);\n\n  const m20 = 2.0 * (xz - yw);\n  const m21 = 2.0 * (yz + xw);\n  const m22 = -x2 - y2 + z2 + w2;\n\n  if (!defined(result)) {\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n  }\n  result[0] = m00;\n  result[1] = m10;\n  result[2] = m20;\n  result[3] = m01;\n  result[4] = m11;\n  result[5] = m21;\n  result[6] = m02;\n  result[7] = m12;\n  result[8] = m22;\n  return result;\n};\n\n/**\n * Computes a 3x3 rotation matrix from the provided headingPitchRoll. (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )\n *\n * @param {HeadingPitchRoll} headingPitchRoll the headingPitchRoll to use.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The 3x3 rotation matrix from this headingPitchRoll.\n */\nMatrix3.fromHeadingPitchRoll = function (headingPitchRoll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"headingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  const cosTheta = Math.cos(-headingPitchRoll.pitch);\n  const cosPsi = Math.cos(-headingPitchRoll.heading);\n  const cosPhi = Math.cos(headingPitchRoll.roll);\n  const sinTheta = Math.sin(-headingPitchRoll.pitch);\n  const sinPsi = Math.sin(-headingPitchRoll.heading);\n  const sinPhi = Math.sin(headingPitchRoll.roll);\n\n  const m00 = cosTheta * cosPsi;\n  const m01 = -cosPhi * sinPsi + sinPhi * sinTheta * cosPsi;\n  const m02 = sinPhi * sinPsi + cosPhi * sinTheta * cosPsi;\n\n  const m10 = cosTheta * sinPsi;\n  const m11 = cosPhi * cosPsi + sinPhi * sinTheta * sinPsi;\n  const m12 = -sinPhi * cosPsi + cosPhi * sinTheta * sinPsi;\n\n  const m20 = -sinTheta;\n  const m21 = sinPhi * cosTheta;\n  const m22 = cosPhi * cosTheta;\n\n  if (!defined(result)) {\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n  }\n  result[0] = m00;\n  result[1] = m10;\n  result[2] = m20;\n  result[3] = m01;\n  result[4] = m11;\n  result[5] = m21;\n  result[6] = m02;\n  result[7] = m12;\n  result[8] = m22;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing a non-uniform scale.\n *\n * @param {Cartesian3} scale The x, y, and z scale factors.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0, 0.0]\n * //   [0.0, 8.0, 0.0]\n * //   [0.0, 0.0, 9.0]\n * const m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix3.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = scale.y;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = scale.z;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing a uniform scale.\n *\n * @param {number} scale The uniform scale factor.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0, 0.0]\n * //   [0.0, 2.0, 0.0]\n * //   [0.0, 0.0, 2.0]\n * const m = Cesium.Matrix3.fromUniformScale(2.0);\n */\nMatrix3.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(scale, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, scale);\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = scale;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = scale;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.\n *\n * @param {Cartesian3} vector the vector on the left hand side of the cross product operation.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [0.0, -9.0,  8.0]\n * //   [9.0,  0.0, -7.0]\n * //   [-8.0, 7.0,  0.0]\n * const m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix3.fromCrossProduct = function (vector, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"vector\", vector);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(\n      0.0,\n      -vector.z,\n      vector.y,\n      vector.z,\n      0.0,\n      -vector.x,\n      -vector.y,\n      vector.x,\n      0.0,\n    );\n  }\n\n  result[0] = 0.0;\n  result[1] = vector.z;\n  result[2] = -vector.y;\n  result[3] = -vector.z;\n  result[4] = 0.0;\n  result[5] = vector.x;\n  result[6] = vector.y;\n  result[7] = -vector.x;\n  result[8] = 0.0;\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the x-axis.\n *\n * @param {number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the x-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationX = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      1.0,\n      0.0,\n      0.0,\n      0.0,\n      cosAngle,\n      -sinAngle,\n      0.0,\n      sinAngle,\n      cosAngle,\n    );\n  }\n\n  result[0] = 1.0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = cosAngle;\n  result[5] = sinAngle;\n  result[6] = 0.0;\n  result[7] = -sinAngle;\n  result[8] = cosAngle;\n\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the y-axis.\n *\n * @param {number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the y-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationY = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      cosAngle,\n      0.0,\n      sinAngle,\n      0.0,\n      1.0,\n      0.0,\n      -sinAngle,\n      0.0,\n      cosAngle,\n    );\n  }\n\n  result[0] = cosAngle;\n  result[1] = 0.0;\n  result[2] = -sinAngle;\n  result[3] = 0.0;\n  result[4] = 1.0;\n  result[5] = 0.0;\n  result[6] = sinAngle;\n  result[7] = 0.0;\n  result[8] = cosAngle;\n\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the z-axis.\n *\n * @param {number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the z-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationZ = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      cosAngle,\n      -sinAngle,\n      0.0,\n      sinAngle,\n      cosAngle,\n      0.0,\n      0.0,\n      0.0,\n      1.0,\n    );\n  }\n\n  result[0] = cosAngle;\n  result[1] = sinAngle;\n  result[2] = 0.0;\n  result[3] = -sinAngle;\n  result[4] = cosAngle;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 1.0;\n\n  return result;\n};\n\n/**\n * Creates an Array from the provided Matrix3 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix3} matrix The matrix to use..\n * @param {number[]} [result] The Array onto which to store the result.\n * @returns {number[]} The modified Array parameter or a new Array instance if one was not provided.\n */\nMatrix3.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [\n      matrix[0],\n      matrix[1],\n      matrix[2],\n      matrix[3],\n      matrix[4],\n      matrix[5],\n      matrix[6],\n      matrix[7],\n      matrix[8],\n    ];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {number} column The zero-based index of the column.\n * @param {number} row The zero-based index of the row.\n * @returns {number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0, 1, or 2.\n * @exception {DeveloperError} column must be 0, 1, or 2.\n *\n * @example\n * const myMatrix = new Cesium.Matrix3();\n * const column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix3.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 2);\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 2);\n  //>>includeEnd('debug');\n\n  return column * 3 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {number} index The zero-based index of the column to retrieve.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const startIndex = index * 3;\n  const x = matrix[startIndex];\n  const y = matrix[startIndex + 1];\n  const z = matrix[startIndex + 2];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {number} index The zero-based index of the column to set.\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix3.clone(matrix, result);\n  const startIndex = index * 3;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  result[startIndex + 2] = cartesian.z;\n  return result;\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {number} index The zero-based index of the row to retrieve.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = matrix[index];\n  const y = matrix[index + 3];\n  const z = matrix[index + 6];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {number} index The zero-based index of the row to set.\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix3.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 3] = cartesian.y;\n  result[index + 6] = cartesian.z;\n  return result;\n};\n\nconst scaleScratch1 = new Cartesian3();\n\n/**\n * Computes a new matrix that replaces the scale with the provided scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Cartesian3} scale The scale that replaces the scale of the provided matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.setUniformScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.multiplyByScale\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.setScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix3.getScale(matrix, scaleScratch1);\n  const scaleRatioX = scale.x / existingScale.x;\n  const scaleRatioY = scale.y / existingScale.y;\n  const scaleRatioZ = scale.z / existingScale.z;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioX;\n  result[3] = matrix[3] * scaleRatioY;\n  result[4] = matrix[4] * scaleRatioY;\n  result[5] = matrix[5] * scaleRatioY;\n  result[6] = matrix[6] * scaleRatioZ;\n  result[7] = matrix[7] * scaleRatioZ;\n  result[8] = matrix[8] * scaleRatioZ;\n\n  return result;\n};\n\nconst scaleScratch2 = new Cartesian3();\n\n/**\n * Computes a new matrix that replaces the scale with the provided uniform scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {number} scale The uniform scale that replaces the scale of the provided matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.setScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.multiplyByScale\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.setUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix3.getScale(matrix, scaleScratch2);\n  const scaleRatioX = scale / existingScale.x;\n  const scaleRatioY = scale / existingScale.y;\n  const scaleRatioZ = scale / existingScale.z;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioX;\n  result[3] = matrix[3] * scaleRatioY;\n  result[4] = matrix[4] * scaleRatioY;\n  result[5] = matrix[5] * scaleRatioY;\n  result[6] = matrix[6] * scaleRatioZ;\n  result[7] = matrix[7] * scaleRatioZ;\n  result[8] = matrix[8] * scaleRatioZ;\n\n  return result;\n};\n\nconst scratchColumn = new Cartesian3();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @see Matrix3.multiplyByScale\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.setScale\n * @see Matrix3.setUniformScale\n */\nMatrix3.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn),\n  );\n  result.y = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn),\n  );\n  result.z = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn),\n  );\n  return result;\n};\n\nconst scaleScratch3 = new Cartesian3();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors.\n *\n * @param {Matrix3} matrix The matrix.\n * @returns {number} The maximum scale.\n */\nMatrix3.getMaximumScale = function (matrix) {\n  Matrix3.getScale(matrix, scaleScratch3);\n  return Cartesian3.maximumComponent(scaleScratch3);\n};\n\nconst scaleScratch4 = new Cartesian3();\n\n/**\n * Sets the rotation assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Matrix3} rotation The rotation matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.getRotation\n */\nMatrix3.setRotation = function (matrix, rotation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix3.getScale(matrix, scaleScratch4);\n\n  result[0] = rotation[0] * scale.x;\n  result[1] = rotation[1] * scale.x;\n  result[2] = rotation[2] * scale.x;\n  result[3] = rotation[3] * scale.y;\n  result[4] = rotation[4] * scale.y;\n  result[5] = rotation[5] * scale.y;\n  result[6] = rotation[6] * scale.z;\n  result[7] = rotation[7] * scale.z;\n  result[8] = rotation[8] * scale.z;\n\n  return result;\n};\n\nconst scaleScratch5 = new Cartesian3();\n\n/**\n * Extracts the rotation matrix assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.setRotation\n */\nMatrix3.getRotation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix3.getScale(matrix, scaleScratch5);\n\n  result[0] = matrix[0] / scale.x;\n  result[1] = matrix[1] / scale.x;\n  result[2] = matrix[2] / scale.x;\n  result[3] = matrix[3] / scale.y;\n  result[4] = matrix[4] / scale.y;\n  result[5] = matrix[5] / scale.y;\n  result[6] = matrix[6] / scale.z;\n  result[7] = matrix[7] / scale.z;\n  result[8] = matrix[8] / scale.z;\n\n  return result;\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 =\n    left[0] * right[0] + left[3] * right[1] + left[6] * right[2];\n  const column0Row1 =\n    left[1] * right[0] + left[4] * right[1] + left[7] * right[2];\n  const column0Row2 =\n    left[2] * right[0] + left[5] * right[1] + left[8] * right[2];\n\n  const column1Row0 =\n    left[0] * right[3] + left[3] * right[4] + left[6] * right[5];\n  const column1Row1 =\n    left[1] * right[3] + left[4] * right[4] + left[7] * right[5];\n  const column1Row2 =\n    left[2] * right[3] + left[5] * right[4] + left[8] * right[5];\n\n  const column2Row0 =\n    left[0] * right[6] + left[3] * right[7] + left[6] * right[8];\n  const column2Row1 =\n    left[1] * right[6] + left[4] * right[7] + left[7] * right[8];\n  const column2Row2 =\n    left[2] * right[6] + left[5] * right[7] + left[8] * right[8];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column1Row0;\n  result[4] = column1Row1;\n  result[5] = column1Row2;\n  result[6] = column2Row0;\n  result[7] = column2Row1;\n  result[8] = column2Row2;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  result[4] = left[4] + right[4];\n  result[5] = left[5] + right[5];\n  result[6] = left[6] + right[6];\n  result[7] = left[7] + right[7];\n  result[8] = left[8] + right[8];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  result[4] = left[4] - right[4];\n  result[5] = left[5] - right[5];\n  result[6] = left[6] - right[6];\n  result[7] = left[7] - right[7];\n  result[8] = left[8] - right[8];\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Cartesian3} cartesian The column.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nMatrix3.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const vX = cartesian.x;\n  const vY = cartesian.y;\n  const vZ = cartesian.z;\n\n  const x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;\n  const y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;\n  const z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {number} scalar The number to multiply by.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  result[4] = matrix[4] * scalar;\n  result[5] = matrix[5] * scalar;\n  result[6] = matrix[6] * scalar;\n  result[7] = matrix[7] * scalar;\n  result[8] = matrix[8] * scalar;\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n *\n * @param {Matrix3} matrix The matrix on the left-hand side.\n * @param {Cartesian3} scale The non-uniform scale on the right-hand side.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromScale(scale), m);\n * Cesium.Matrix3.multiplyByScale(m, scale, m);\n *\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.setScale\n * @see Matrix3.setUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale.x;\n  result[1] = matrix[1] * scale.x;\n  result[2] = matrix[2] * scale.x;\n  result[3] = matrix[3] * scale.y;\n  result[4] = matrix[4] * scale.y;\n  result[5] = matrix[5] * scale.y;\n  result[6] = matrix[6] * scale.z;\n  result[7] = matrix[7] * scale.z;\n  result[8] = matrix[8] * scale.z;\n\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.\n *\n * @param {Matrix3} matrix The matrix on the left-hand side.\n * @param {number} scale The uniform scale on the right-hand side.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromUniformScale(scale), m);\n * Cesium.Matrix3.multiplyByUniformScale(m, scale, m);\n *\n * @see Matrix3.multiplyByScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.setScale\n * @see Matrix3.setUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.multiplyByUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale;\n  result[1] = matrix[1] * scale;\n  result[2] = matrix[2] * scale;\n  result[3] = matrix[3] * scale;\n  result[4] = matrix[4] * scale;\n  result[5] = matrix[5] * scale;\n  result[6] = matrix[6] * scale;\n  result[7] = matrix[7] * scale;\n  result[8] = matrix[8] * scale;\n\n  return result;\n};\n\n/**\n * Creates a negated copy of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to negate.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  result[4] = -matrix[4];\n  result[5] = -matrix[5];\n  result[6] = -matrix[6];\n  result[7] = -matrix[7];\n  result[8] = -matrix[8];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to transpose.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = matrix[0];\n  const column0Row1 = matrix[3];\n  const column0Row2 = matrix[6];\n  const column1Row0 = matrix[1];\n  const column1Row1 = matrix[4];\n  const column1Row2 = matrix[7];\n  const column2Row0 = matrix[2];\n  const column2Row1 = matrix[5];\n  const column2Row2 = matrix[8];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column1Row0;\n  result[4] = column1Row1;\n  result[5] = column1Row2;\n  result[6] = column2Row0;\n  result[7] = column2Row1;\n  result[8] = column2Row2;\n  return result;\n};\n\nfunction computeFrobeniusNorm(matrix) {\n  let norm = 0.0;\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n\nfunction offDiagonalFrobeniusNorm(matrix) {\n  // Computes the \"off-diagonal\" Frobenius norm.\n  // Assumes matrix is symmetric.\n\n  let norm = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nfunction shurDecomposition(matrix, result) {\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n  // section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n  //\n  // The routine takes a matrix, which is assumed to be symmetric, and\n  // finds the largest off-diagonal term, and then creates\n  // a matrix (result) which can be used to help reduce it\n\n  const tolerance = CesiumMath.EPSILON15;\n\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n\n  // find pivot (rotAxis) based on max diagonal of matrix\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(\n      matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])],\n    );\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  let c = 1.0;\n  let s = 0.0;\n\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n\n  if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[Matrix3.getElementIndex(q, q)];\n    const pp = matrix[Matrix3.getElementIndex(p, p)];\n    const qp = matrix[Matrix3.getElementIndex(q, p)];\n\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  result = Matrix3.clone(Matrix3.IDENTITY, result);\n\n  result[Matrix3.getElementIndex(p, p)] = result[\n    Matrix3.getElementIndex(q, q)\n  ] = c;\n  result[Matrix3.getElementIndex(q, p)] = s;\n  result[Matrix3.getElementIndex(p, q)] = -s;\n\n  return result;\n}\n\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\n\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n * <p>\n * Returns a diagonal matrix and unitary matrix such that:\n * <code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>\n * </p>\n * <p>\n * The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * </p>\n *\n * @param {Matrix3} matrix The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param {object} [result] An object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns {object} An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * const a = //... symetric matrix\n * const result = {\n *     unitary : new Cesium.Matrix3(),\n *     diagonal : new Cesium.Matrix3()\n * };\n * Cesium.Matrix3.computeEigenDecomposition(a, result);\n *\n * const unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());\n * const b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());\n * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * const lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue\n * const v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector\n * const c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)\n */\nMatrix3.computeEigenDecomposition = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n  // section 8.4.3 The Classical Jacobi Algorithm\n\n  const tolerance = CesiumMath.EPSILON20;\n  const maxSweeps = 10;\n\n  let count = 0;\n  let sweep = 0;\n\n  if (!defined(result)) {\n    result = {};\n  }\n\n  const unitaryMatrix = (result.unitary = Matrix3.clone(\n    Matrix3.IDENTITY,\n    result.unitary,\n  ));\n  const diagMatrix = (result.diagonal = Matrix3.clone(matrix, result.diagonal));\n\n  const epsilon = tolerance * computeFrobeniusNorm(diagMatrix);\n\n  while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {\n    shurDecomposition(diagMatrix, jMatrix);\n    Matrix3.transpose(jMatrix, jMatrixTranspose);\n    Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);\n    Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);\n    Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix3} matrix The matrix with signed elements.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n  result[4] = Math.abs(matrix[4]);\n  result[5] = Math.abs(matrix[5]);\n  result[6] = Math.abs(matrix[6]);\n  result[7] = Math.abs(matrix[7]);\n  result[8] = Math.abs(matrix[8]);\n\n  return result;\n};\n\n/**\n * Computes the determinant of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @returns {number} The value of the determinant of the matrix.\n */\nMatrix3.determinant = function (matrix) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  const m11 = matrix[0];\n  const m21 = matrix[3];\n  const m31 = matrix[6];\n  const m12 = matrix[1];\n  const m22 = matrix[4];\n  const m32 = matrix[7];\n  const m13 = matrix[2];\n  const m23 = matrix[5];\n  const m33 = matrix[8];\n\n  return (\n    m11 * (m22 * m33 - m23 * m32) +\n    m12 * (m23 * m31 - m21 * m33) +\n    m13 * (m21 * m32 - m22 * m31)\n  );\n};\n\n/**\n * Computes the inverse of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to invert.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} matrix is not invertible.\n */\nMatrix3.inverse = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const m11 = matrix[0];\n  const m21 = matrix[1];\n  const m31 = matrix[2];\n  const m12 = matrix[3];\n  const m22 = matrix[4];\n  const m32 = matrix[5];\n  const m13 = matrix[6];\n  const m23 = matrix[7];\n  const m33 = matrix[8];\n\n  const determinant = Matrix3.determinant(matrix);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (Math.abs(determinant) <= CesiumMath.EPSILON15) {\n    throw new DeveloperError(\"matrix is not invertible\");\n  }\n  //>>includeEnd('debug');\n\n  result[0] = m22 * m33 - m23 * m32;\n  result[1] = m23 * m31 - m21 * m33;\n  result[2] = m21 * m32 - m22 * m31;\n  result[3] = m13 * m32 - m12 * m33;\n  result[4] = m11 * m33 - m13 * m31;\n  result[5] = m12 * m31 - m11 * m32;\n  result[6] = m12 * m23 - m13 * m22;\n  result[7] = m13 * m21 - m11 * m23;\n  result[8] = m11 * m22 - m12 * m21;\n\n  const scale = 1.0 / determinant;\n  return Matrix3.multiplyByScalar(result, scale, result);\n};\n\nconst scratchTransposeMatrix = new Matrix3();\n\n/**\n * Computes the inverse transpose of a matrix.\n *\n * @param {Matrix3} matrix The matrix to transpose and invert.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.inverseTranspose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  return Matrix3.inverse(\n    Matrix3.transpose(matrix, scratchTransposeMatrix),\n    result,\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix3} [left] The first matrix.\n * @param {Matrix3} [right] The second matrix.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nMatrix3.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left[0] === right[0] &&\n      left[1] === right[1] &&\n      left[2] === right[2] &&\n      left[3] === right[3] &&\n      left[4] === right[4] &&\n      left[5] === right[5] &&\n      left[6] === right[6] &&\n      left[7] === right[7] &&\n      left[8] === right[8])\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix3} [left] The first matrix.\n * @param {Matrix3} [right] The second matrix.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix3.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = epsilon ?? 0;\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left[0] - right[0]) <= epsilon &&\n      Math.abs(left[1] - right[1]) <= epsilon &&\n      Math.abs(left[2] - right[2]) <= epsilon &&\n      Math.abs(left[3] - right[3]) <= epsilon &&\n      Math.abs(left[4] - right[4]) <= epsilon &&\n      Math.abs(left[5] - right[5]) <= epsilon &&\n      Math.abs(left[6] - right[6]) <= epsilon &&\n      Math.abs(left[7] - right[7]) <= epsilon &&\n      Math.abs(left[8] - right[8]) <= epsilon)\n  );\n};\n\n/**\n * An immutable Matrix3 instance initialized to the identity matrix.\n *\n * @type {Matrix3}\n * @constant\n */\nMatrix3.IDENTITY = Object.freeze(\n  new Matrix3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0),\n);\n\n/**\n * An immutable Matrix3 instance initialized to the zero matrix.\n *\n * @type {Matrix3}\n * @constant\n */\nMatrix3.ZERO = Object.freeze(\n  new Matrix3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0),\n);\n\n/**\n * The index into Matrix3 for column 0, row 0.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix3 for column 0, row 1.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix3 for column 0, row 2.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN0ROW2 = 2;\n\n/**\n * The index into Matrix3 for column 1, row 0.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN1ROW0 = 3;\n\n/**\n * The index into Matrix3 for column 1, row 1.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN1ROW1 = 4;\n\n/**\n * The index into Matrix3 for column 1, row 2.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN1ROW2 = 5;\n\n/**\n * The index into Matrix3 for column 2, row 0.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN2ROW0 = 6;\n\n/**\n * The index into Matrix3 for column 2, row 1.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN2ROW1 = 7;\n\n/**\n * The index into Matrix3 for column 2, row 2.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN2ROW2 = 8;\n\nObject.defineProperties(Matrix3.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix3.prototype\n   *\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      return Matrix3.packedLength;\n    },\n  },\n});\n\n/**\n * Duplicates the provided Matrix3 instance.\n *\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n */\nMatrix3.prototype.clone = function (result) {\n  return Matrix3.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix3} [right] The right hand side matrix.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix3.prototype.equals = function (right) {\n  return Matrix3.equals(this, right);\n};\n\n/**\n * @private\n */\nMatrix3.equalsArray = function (matrix, array, offset) {\n  return (\n    matrix[0] === array[offset] &&\n    matrix[1] === array[offset + 1] &&\n    matrix[2] === array[offset + 2] &&\n    matrix[3] === array[offset + 3] &&\n    matrix[4] === array[offset + 4] &&\n    matrix[5] === array[offset + 5] &&\n    matrix[6] === array[offset + 6] &&\n    matrix[7] === array[offset + 7] &&\n    matrix[8] === array[offset + 8]\n  );\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix3} [right] The right hand side matrix.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix3.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix3.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1, column2)'.\n *\n * @returns {string} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.\n */\nMatrix3.prototype.toString = function () {\n  return (\n    `(${this[0]}, ${this[3]}, ${this[6]})\\n` +\n    `(${this[1]}, ${this[4]}, ${this[7]})\\n` +\n    `(${this[2]}, ${this[5]}, ${this[8]})`\n  );\n};\nexport default Matrix3;\n"],"names":["Matrix3","column0Row0","column1Row0","column2Row0","column0Row1","column1Row1","column2Row1","column0Row2","column1Row2","column2Row2","packedLength","pack","value","array","startingIndex","typeOf","object","defined","unpack","result","packArray","length","resultLength","Array","isArray","i","unpackArray","number","greaterThanOrEquals","index","clone","matrix","undefined","fromArray","fromColumnMajorArray","values","fromRowMajorArray","fromQuaternion","quaternion","x2","x","xy","y","xz","z","xw","w","y2","yz","yw","z2","zw","w2","m00","m01","m02","m10","m11","m12","m20","m21","m22","fromHeadingPitchRoll","headingPitchRoll","cosTheta","Math","cos","pitch","cosPsi","heading","cosPhi","roll","sinTheta","sin","sinPsi","sinPhi","fromScale","scale","fromUniformScale","fromCrossProduct","vector","fromRotationX","angle","cosAngle","sinAngle","fromRotationY","fromRotationZ","toArray","getElementIndex","column","row","lessThanOrEquals","getColumn","startIndex","setColumn","cartesian","getRow","setRow","scaleScratch1","setScale","existingScale","getScale","scaleRatioX","scaleRatioY","scaleRatioZ","scaleScratch2","setUniformScale","scratchColumn","magnitude","fromElements","scaleScratch3","getMaximumScale","maximumComponent","scaleScratch4","setRotation","rotation","scaleScratch5","getRotation","multiply","left","right","add","subtract","multiplyByVector","vX","vY","vZ","multiplyByScalar","scalar","multiplyByScale","multiplyByUniformScale","negate","transpose","computeFrobeniusNorm","norm","temp","sqrt","rowVal","colVal","offDiagonalFrobeniusNorm","shurDecomposition","tolerance","EPSILON15","maxDiagonal","rotAxis","abs","c","s","p","q","qq","pp","qp","tau","t","IDENTITY","jMatrix","jMatrixTranspose","computeEigenDecomposition","EPSILON20","maxSweeps","count","sweep","unitaryMatrix","unitary","diagMatrix","diagonal","epsilon","determinant","m31","m32","m13","m23","m33","inverse","scratchTransposeMatrix","inverseTranspose","equals","equalsEpsilon","Object","freeze","ZERO","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","defineProperties","prototype","get","equalsArray","offset","toString"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9547, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Cartesian4.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 4D Cartesian point.\n * @alias Cartesian4\n * @constructor\n *\n * @param {number} [x=0.0] The X component.\n * @param {number} [y=0.0] The Y component.\n * @param {number} [z=0.0] The Z component.\n * @param {number} [w=0.0] The W component.\n *\n * @see Cartesian2\n * @see Cartesian3\n * @see Packable\n */\nfunction Cartesian4(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = x ?? 0.0;\n\n  /**\n   * The Y component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = y ?? 0.0;\n\n  /**\n   * The Z component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.z = z ?? 0.0;\n\n  /**\n   * The W component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.w = w ?? 0.0;\n}\n\n/**\n * Creates a Cartesian4 instance from x, y, z and w coordinates.\n *\n * @param {number} x The x coordinate.\n * @param {number} y The y coordinate.\n * @param {number} z The z coordinate.\n * @param {number} w The w coordinate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.fromElements = function (x, y, z, w, result) {\n  if (!defined(result)) {\n    return new Cartesian4(x, y, z, w);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,\n * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.\n *\n * @param {Color} color The source color.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.fromColor = function (color, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"color\", color);\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    return new Cartesian4(color.red, color.green, color.blue, color.alpha);\n  }\n\n  result.x = color.red;\n  result.y = color.green;\n  result.z = color.blue;\n  result.w = color.alpha;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian4 instance.\n *\n * @param {Cartesian4} cartesian The Cartesian to duplicate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian4.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  result.w = cartesian.w;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nCartesian4.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian4} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCartesian4.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian4} [result] The object into which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex++];\n  result.w = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian4s into an array of components.\n *\n * @param {Cartesian4[]} array The array of cartesians to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.\n * @returns {number[]} The packed array.\n */\nCartesian4.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 4;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 4 elements\",\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Cartesian4.pack(array[i], result, i * 4);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian4s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Cartesian4[]} [result] The array onto which to store the result.\n * @returns {Cartesian4[]} The unpacked array.\n */\nCartesian4.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 4);\n  if (array.length % 4 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 4.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 4);\n  } else {\n    result.length = length / 4;\n  }\n\n  for (let i = 0; i < length; i += 4) {\n    const index = i / 4;\n    result[index] = Cartesian4.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian4 from four consecutive elements in an array.\n * @function\n *\n * @param {number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)\n * const v = [1.0, 2.0, 3.0, 4.0];\n * const p = Cesium.Cartesian4.fromArray(v);\n *\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];\n * const p2 = Cesium.Cartesian4.fromArray(v2, 2);\n */\nCartesian4.fromArray = Cartesian4.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {number} The value of the maximum component.\n */\nCartesian4.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {number} The value of the minimum component.\n */\nCartesian4.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the minimum components.\n */\nCartesian4.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n  result.w = Math.min(first.w, second.w);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the maximum components.\n */\nCartesian4.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  result.w = Math.max(first.w, second.w);\n\n  return result;\n};\n\n/**\n * Constrain a value to lie between two values.\n *\n * @param {Cartesian4} value The value to clamp.\n * @param {Cartesian4} min The minimum bound.\n * @param {Cartesian4} max The maximum bound.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} The clamped value such that min <= result <= max.\n */\nCartesian4.clamp = function (value, min, max, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = CesiumMath.clamp(value.x, min.x, max.x);\n  const y = CesiumMath.clamp(value.y, min.y, max.y);\n  const z = CesiumMath.clamp(value.z, min.z, max.z);\n  const w = CesiumMath.clamp(value.w, min.w, max.w);\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {number} The squared magnitude.\n */\nCartesian4.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return (\n    cartesian.x * cartesian.x +\n    cartesian.y * cartesian.y +\n    cartesian.z * cartesian.z +\n    cartesian.w * cartesian.w\n  );\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {number} The magnitude.\n */\nCartesian4.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));\n};\n\nconst distanceScratch = new Cartesian4();\n\n/**\n * Computes the 4-space distance between two points.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * const d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));\n */\nCartesian4.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));\n */\nCartesian4.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be normalized.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitude = Cartesian4.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n  result.w = cartesian.w / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    isNaN(result.x) ||\n    isNaN(result.y) ||\n    isNaN(result.z) ||\n    isNaN(result.w)\n  ) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @returns {number} The dot product.\n */\nCartesian4.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w\n  );\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  result.w = left.w * right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  result.w = left.w / right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  result.w = cartesian.w * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be divided.\n * @param {number} scalar The scalar to divide by.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  result.w = cartesian.w / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be negated.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  result.w = -cartesian.w;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  result.w = Math.abs(cartesian.w);\n  return result;\n};\n\nconst lerpScratch = new Cartesian4();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian4} start The value corresponding to t at 0.0.\n * @param {Cartesian4}end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian4.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian4.add(lerpScratch, result, result);\n};\n\nconst mostOrthogonalAxisScratch = new Cartesian4();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The most orthogonal axis.\n */\nCartesian4.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian4.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      if (f.x <= f.w) {\n        result = Cartesian4.clone(Cartesian4.UNIT_X, result);\n      } else {\n        result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n      }\n    } else if (f.z <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.y <= f.z) {\n    if (f.y <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Y, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.z <= f.w) {\n    result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n  } else {\n    result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n  }\n\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian4.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z &&\n      left.w === right.w)\n  );\n};\n\n/**\n * @private\n */\nCartesian4.equalsArray = function (cartesian, array, offset) {\n  return (\n    cartesian.x === array[offset] &&\n    cartesian.y === array[offset + 1] &&\n    cartesian.z === array[offset + 2] &&\n    cartesian.w === array[offset + 3]\n  );\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian4.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.z,\n        right.z,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.w,\n        right.w,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ))\n  );\n};\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.ZERO = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (1.0, 1.0, 1.0, 1.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.ONE = Object.freeze(new Cartesian4(1.0, 1.0, 1.0, 1.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_X = Object.freeze(new Cartesian4(1.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_Y = Object.freeze(new Cartesian4(0.0, 1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_Z = Object.freeze(new Cartesian4(0.0, 0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_W = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian4 instance.\n *\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.prototype.clone = function (result) {\n  return Cartesian4.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian4.prototype.equals = function (right) {\n  return Cartesian4.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian4.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return Cartesian4.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon,\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z, w)'.\n *\n * @returns {string} A string representing the provided Cartesian in the format '(x, y, z, w)'.\n */\nCartesian4.prototype.toString = function () {\n  return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;\n};\n\n// scratchU8Array and scratchF32Array are views into the same buffer\nconst scratchF32Array = new Float32Array(1);\nconst scratchU8Array = new Uint8Array(scratchF32Array.buffer);\n\nconst testU32 = new Uint32Array([0x11223344]);\nconst testU8 = new Uint8Array(testU32.buffer);\nconst littleEndian = testU8[0] === 0x44;\n\n/**\n * Packs an arbitrary floating point value to 4 values representable using uint8.\n *\n * @param {number} value A floating point number.\n * @param {Cartesian4} [result] The Cartesian4 that will contain the packed float.\n * @returns {Cartesian4} A Cartesian4 representing the float packed to values in x, y, z, and w.\n */\nCartesian4.packFloat = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n\n  // scratchU8Array and scratchF32Array are views into the same buffer\n  scratchF32Array[0] = value;\n\n  if (littleEndian) {\n    result.x = scratchU8Array[0];\n    result.y = scratchU8Array[1];\n    result.z = scratchU8Array[2];\n    result.w = scratchU8Array[3];\n  } else {\n    // convert from big-endian to little-endian\n    result.x = scratchU8Array[3];\n    result.y = scratchU8Array[2];\n    result.z = scratchU8Array[1];\n    result.w = scratchU8Array[0];\n  }\n  return result;\n};\n\n/**\n * Unpacks a float packed using Cartesian4.packFloat.\n *\n * @param {Cartesian4} packedFloat A Cartesian4 containing a float packed to 4 values representable using uint8.\n * @returns {number} The unpacked float.\n * @private\n */\nCartesian4.unpackFloat = function (packedFloat) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"packedFloat\", packedFloat);\n  //>>includeEnd('debug');\n\n  // scratchU8Array and scratchF32Array are views into the same buffer\n  if (littleEndian) {\n    scratchU8Array[0] = packedFloat.x;\n    scratchU8Array[1] = packedFloat.y;\n    scratchU8Array[2] = packedFloat.z;\n    scratchU8Array[3] = packedFloat.w;\n  } else {\n    // convert from little-endian to big-endian\n    scratchU8Array[0] = packedFloat.w;\n    scratchU8Array[1] = packedFloat.z;\n    scratchU8Array[2] = packedFloat.y;\n    scratchU8Array[3] = packedFloat.x;\n  }\n  return scratchF32Array[0];\n};\nexport default Cartesian4;\n"],"names":["Cartesian4","x","y","z","w","fromElements","result","fromColor","color","typeOf","object","red","green","blue","alpha","clone","cartesian","undefined","packedLength","pack","value","array","startingIndex","defined","unpack","packArray","length","resultLength","Array","isArray","i","unpackArray","number","greaterThanOrEquals","index","fromArray","maximumComponent","Math","max","minimumComponent","min","minimumByComponent","first","second","maximumByComponent","clamp","magnitudeSquared","magnitude","sqrt","distanceScratch","distance","left","right","subtract","distanceSquared","normalize","isNaN","dot","multiplyComponents","divideComponents","add","multiplyByScalar","scalar","divideByScalar","negate","abs","lerpScratch","lerp","start","end","t","mostOrthogonalAxisScratch","mostOrthogonalAxis","f","UNIT_X","UNIT_W","UNIT_Z","UNIT_Y","equals","equalsArray","offset","equalsEpsilon","relativeEpsilon","absoluteEpsilon","ZERO","Object","freeze","ONE","prototype","toString","scratchF32Array","Float32Array","scratchU8Array","Uint8Array","buffer","testU32","Uint32Array","testU8","littleEndian","packFloat","unpackFloat","packedFloat"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10323, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/binarySearch.js"],"sourcesContent":["import Check from \"./Check.js\";\n\n/**\n * Finds an item in a sorted array.\n *\n * @function\n * @param {Array|Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} array The sorted array to search.\n * @param {*} itemToFind The item to find in the array.\n * @param {binarySearchComparator} comparator The function to use to compare the item to\n *        elements in the array.\n * @returns {number} The index of <code>itemToFind</code> in the array, if it exists.  If <code>itemToFind</code>\n *        does not exist, the return value is a negative number which is the bitwise complement (~)\n *        of the index before which the itemToFind should be inserted in order to maintain the\n *        sorted order of the array.\n *\n * @example\n * // Create a comparator function to search through an array of numbers.\n * function comparator(a, b) {\n *     return a - b;\n * };\n * const numbers = [0, 2, 4, 6, 8];\n * const index = Cesium.binarySearch(numbers, 6, comparator); // 3\n */\nfunction binarySearch(array, itemToFind, comparator) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.defined(\"itemToFind\", itemToFind);\n  Check.defined(\"comparator\", comparator);\n  //>>includeEnd('debug');\n\n  let low = 0;\n  let high = array.length - 1;\n  let i;\n  let comparison;\n\n  while (low <= high) {\n    i = ~~((low + high) / 2);\n    comparison = comparator(array[i], itemToFind);\n    if (comparison < 0) {\n      low = i + 1;\n      continue;\n    }\n    if (comparison > 0) {\n      high = i - 1;\n      continue;\n    }\n    return i;\n  }\n  return ~(high + 1);\n}\n\n/**\n * A function used to compare two items while performing a binary search.\n * @callback binarySearchComparator\n *\n * @param {*} a An item in the array.\n * @param {*} b The item being searched for.\n * @returns {number} Returns a negative value if <code>a</code> is less than <code>b</code>,\n *          a positive value if <code>a</code> is greater than <code>b</code>, or\n *          0 if <code>a</code> is equal to <code>b</code>.\n *\n * @example\n * function compareNumbers(a, b) {\n *     return a - b;\n * }\n */\nexport default binarySearch;\n"],"names":["binarySearch","array","itemToFind","comparator","defined","low","high","length","i","comparison"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;CAoBC,GACD,SAASA,aAAaC,KAAK,EAAEC,UAAU,EAAEC,UAAU;IACjD,yCAAyC;IACzC,2KAAK,CAACC,OAAO,CAAC,SAASH;IACvB,2KAAK,CAACG,OAAO,CAAC,cAAcF;IAC5B,2KAAK,CAACE,OAAO,CAAC,cAAcD;IAC5B,wBAAwB;IAExB,IAAIE,MAAM;IACV,IAAIC,OAAOL,MAAMM,MAAM,GAAG;IAC1B,IAAIC;IACJ,IAAIC;IAEJ,MAAOJ,OAAOC,KAAM;QAClBE,IAAI,CAAC,CAAC,CAAC,CAACH,MAAMC,IAAI,IAAI,CAAC;QACvBG,aAAaN,WAAWF,KAAK,CAACO,EAAE,EAAEN;QAClC,IAAIO,aAAa,GAAG;YAClBJ,MAAMG,IAAI;YACV;QACF;QACA,IAAIC,aAAa,GAAG;YAClBH,OAAOE,IAAI;YACX;QACF;QACA,OAAOA;IACT;IACA,OAAO,CAAC,CAACF,OAAO,CAAC;AACnB;uCAiBeN","ignoreList":[0]}},
    {"offset": {"line": 10379, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/EarthOrientationParametersSample.js"],"sourcesContent":["/**\n * A set of Earth Orientation Parameters (EOP) sampled at a time.\n *\n * @alias EarthOrientationParametersSample\n * @constructor\n *\n * @param {number} xPoleWander The pole wander about the X axis, in radians.\n * @param {number} yPoleWander The pole wander about the Y axis, in radians.\n * @param {number} xPoleOffset The offset to the Celestial Intermediate Pole (CIP) about the X axis, in radians.\n * @param {number} yPoleOffset The offset to the Celestial Intermediate Pole (CIP) about the Y axis, in radians.\n * @param {number} ut1MinusUtc The difference in time standards, UT1 - UTC, in seconds.\n *\n * @private\n */\nfunction EarthOrientationParametersSample(\n  xPoleWander,\n  yPoleWander,\n  xPoleOffset,\n  yPoleOffset,\n  ut1MinusUtc,\n) {\n  /**\n   * The pole wander about the X axis, in radians.\n   * @type {number}\n   */\n  this.xPoleWander = xPoleWander;\n\n  /**\n   * The pole wander about the Y axis, in radians.\n   * @type {number}\n   */\n  this.yPoleWander = yPoleWander;\n\n  /**\n   * The offset to the Celestial Intermediate Pole (CIP) about the X axis, in radians.\n   * @type {number}\n   */\n  this.xPoleOffset = xPoleOffset;\n\n  /**\n   * The offset to the Celestial Intermediate Pole (CIP) about the Y axis, in radians.\n   * @type {number}\n   */\n  this.yPoleOffset = yPoleOffset;\n\n  /**\n   * The difference in time standards, UT1 - UTC, in seconds.\n   * @type {number}\n   */\n  this.ut1MinusUtc = ut1MinusUtc;\n}\nexport default EarthOrientationParametersSample;\n"],"names":["EarthOrientationParametersSample","xPoleWander","yPoleWander","xPoleOffset","yPoleOffset","ut1MinusUtc"],"mappings":";;;;AAAA;;;;;;;;;;;;;CAaC,GACD,SAASA,iCACPC,WAAW,EACXC,WAAW,EACXC,WAAW,EACXC,WAAW,EACXC,WAAW;IAEX;;;GAGC,GACD,IAAI,CAACJ,WAAW,GAAGA;IAEnB;;;GAGC,GACD,IAAI,CAACC,WAAW,GAAGA;IAEnB;;;GAGC,GACD,IAAI,CAACC,WAAW,GAAGA;IAEnB;;;GAGC,GACD,IAAI,CAACC,WAAW,GAAGA;IAEnB;;;GAGC,GACD,IAAI,CAACC,WAAW,GAAGA;AACrB;uCACeL","ignoreList":[0]}},
    {"offset": {"line": 10423, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/isLeapYear.js"],"sourcesContent":["import DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Determines if a given date is a leap year.\n *\n * @function isLeapYear\n *\n * @param {number} year The year to be tested.\n * @returns {boolean} True if <code>year</code> is a leap year.\n *\n * @example\n * const leapYear = Cesium.isLeapYear(2000); // true\n */\nfunction isLeapYear(year) {\n  //>>includeStart('debug', pragmas.debug);\n  if (year === null || isNaN(year)) {\n    throw new DeveloperError(\"year is required and must be a number.\");\n  }\n  //>>includeEnd('debug');\n\n  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n}\nexport default isLeapYear;\n"],"names":["isLeapYear","year","isNaN"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;;CAUC,GACD,SAASA,WAAWC,IAAI;IACtB,yCAAyC;IACzC,IAAIA,SAAS,QAAQC,MAAMD,OAAO;QAChC,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,OAAO,AAACA,OAAO,MAAM,KAAKA,OAAO,QAAQ,KAAMA,OAAO,QAAQ;AAChE;uCACeD","ignoreList":[0]}},
    {"offset": {"line": 10452, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/GregorianDate.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport isLeapYear from \"./isLeapYear.js\";\n\nconst daysInYear = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n/**\n * Represents a Gregorian date in a more precise format than the JavaScript Date object.\n * In addition to submillisecond precision, this object can also represent leap seconds.\n * @alias GregorianDate\n * @constructor\n *\n * @param {number} [year] The year as a whole number.\n * @param {number} [month] The month as a whole number with range [1, 12].\n * @param {number} [day] The day of the month as a whole number starting at 1.\n * @param {number} [hour] The hour as a whole number with range [0, 23].\n * @param {number} [minute] The minute of the hour as a whole number with range [0, 59].\n * @param {number} [second] The second of the minute as a whole number with range [0, 60], with 60 representing a leap second.\n * @param {number} [millisecond] The millisecond of the second as a floating point number with range [0.0, 1000.0).\n * @param {boolean} [isLeapSecond] Whether this time is during a leap second.\n *\n * @see JulianDate#toGregorianDate\n */\nfunction GregorianDate(\n  year,\n  month,\n  day,\n  hour,\n  minute,\n  second,\n  millisecond,\n  isLeapSecond,\n) {\n  const minimumYear = 1;\n  const minimumMonth = 1;\n  const minimumDay = 1;\n  const minimumHour = 0;\n  const minimumMinute = 0;\n  const minimumSecond = 0;\n  const minimumMillisecond = 0;\n\n  year = year ?? minimumYear;\n  month = month ?? minimumMonth;\n  day = day ?? minimumDay;\n  hour = hour ?? minimumHour;\n  minute = minute ?? minimumMinute;\n  second = second ?? minimumSecond;\n  millisecond = millisecond ?? minimumMillisecond;\n  isLeapSecond = isLeapSecond ?? false;\n  //>>includeStart('debug', pragmas.debug);\n  validateRange();\n  validateDate();\n  //>>includeEnd('debug');\n\n  /**\n   * Gets or sets the year as a whole number.\n   * @type {number}\n   */\n  this.year = year;\n  /**\n   * Gets or sets the month as a whole number with range [1, 12].\n   * @type {number}\n   */\n  this.month = month;\n  /**\n   * Gets or sets the day of the month as a whole number starting at 1.\n   * @type {number}\n   */\n  this.day = day;\n  /**\n   * Gets or sets the hour as a whole number with range [0, 23].\n   * @type {number}\n   */\n  this.hour = hour;\n  /**\n   * Gets or sets the minute of the hour as a whole number with range [0, 59].\n   * @type {number}\n   */\n  this.minute = minute;\n  /**\n   * Gets or sets the second of the minute as a whole number with range [0, 60], with 60 representing a leap second.\n   * @type {number}\n   */\n  this.second = second;\n  /**\n   * Gets or sets the millisecond of the second as a floating point number with range [0.0, 1000.0).\n   * @type {number}\n   */\n  this.millisecond = millisecond;\n  /**\n   * Gets or sets whether this time is during a leap second.\n   * @type {boolean}\n   */\n  this.isLeapSecond = isLeapSecond;\n\n  function validateRange() {\n    const maximumYear = 9999;\n    const maximumMonth = 12;\n    const maximumDay = 31;\n    const maximumHour = 23;\n    const maximumMinute = 59;\n    const maximumSecond = 59;\n    const excludedMaximumMilisecond = 1000;\n\n    Check.typeOf.number.greaterThanOrEquals(\"Year\", year, minimumYear);\n    Check.typeOf.number.lessThanOrEquals(\"Year\", year, maximumYear);\n\n    Check.typeOf.number.greaterThanOrEquals(\"Month\", month, minimumMonth);\n    Check.typeOf.number.lessThanOrEquals(\"Month\", month, maximumMonth);\n\n    Check.typeOf.number.greaterThanOrEquals(\"Day\", day, minimumDay);\n    Check.typeOf.number.lessThanOrEquals(\"Day\", day, maximumDay);\n\n    Check.typeOf.number.greaterThanOrEquals(\"Hour\", hour, minimumHour);\n    Check.typeOf.number.lessThanOrEquals(\"Hour\", hour, maximumHour);\n\n    Check.typeOf.number.greaterThanOrEquals(\"Minute\", minute, minimumMinute);\n    Check.typeOf.number.lessThanOrEquals(\"Minute\", minute, maximumMinute);\n\n    Check.typeOf.bool(\"IsLeapSecond\", isLeapSecond);\n\n    Check.typeOf.number.greaterThanOrEquals(\"Second\", second, minimumSecond);\n    Check.typeOf.number.lessThanOrEquals(\n      \"Second\",\n      second,\n      isLeapSecond ? maximumSecond + 1 : maximumSecond,\n    );\n\n    Check.typeOf.number.greaterThanOrEquals(\n      \"Millisecond\",\n      millisecond,\n      minimumMillisecond,\n    );\n    Check.typeOf.number.lessThan(\n      \"Millisecond\",\n      millisecond,\n      excludedMaximumMilisecond,\n    );\n  }\n\n  // Javascript date object supports only dates greater than 1901. Thus validating with custom logic\n  function validateDate() {\n    const daysInMonth =\n      month === 2 && isLeapYear(year)\n        ? daysInYear[month - 1] + 1\n        : daysInYear[month - 1];\n\n    if (day > daysInMonth) {\n      throw new DeveloperError(\"Month and Day represents invalid date\");\n    }\n  }\n}\nexport default GregorianDate;\n"],"names":["daysInYear","GregorianDate","year","month","day","hour","minute","second","millisecond","isLeapSecond","minimumYear","minimumMonth","minimumDay","minimumHour","minimumMinute","minimumSecond","minimumMillisecond","validateRange","validateDate","maximumYear","maximumMonth","maximumDay","maximumHour","maximumMinute","maximumSecond","excludedMaximumMilisecond","typeOf","number","greaterThanOrEquals","lessThanOrEquals","bool","lessThan","daysInMonth"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10581, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/LeapSecond.js"],"sourcesContent":["/**\n * Describes a single leap second, which is constructed from a {@link JulianDate} and a\n * numerical offset representing the number of seconds TAI is ahead of the UTC time standard.\n * @alias LeapSecond\n * @constructor\n *\n * @param {JulianDate} [date] A Julian date representing the time of the leap second.\n * @param {number} [offset] The cumulative number of seconds that TAI is ahead of UTC at the provided date.\n */\nfunction LeapSecond(date, offset) {\n  /**\n   * Gets or sets the date at which this leap second occurs.\n   * @type {JulianDate}\n   */\n  this.julianDate = date;\n\n  /**\n   * Gets or sets the cumulative number of seconds between the UTC and TAI time standards at the time\n   * of this leap second.\n   * @type {number}\n   */\n  this.offset = offset;\n}\nexport default LeapSecond;\n"],"names":["LeapSecond","date","offset","julianDate"],"mappings":";;;;AAAA;;;;;;;;CAQC,GACD,SAASA,WAAWC,IAAI,EAAEC,MAAM;IAC9B;;;GAGC,GACD,IAAI,CAACC,UAAU,GAAGF;IAElB;;;;GAIC,GACD,IAAI,CAACC,MAAM,GAAGA;AAChB;uCACeF","ignoreList":[0]}},
    {"offset": {"line": 10609, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TimeConstants.js"],"sourcesContent":["/**\n * Constants for time conversions like those done by {@link JulianDate}.\n *\n * @namespace TimeConstants\n *\n * @see JulianDate\n *\n * @private\n */\nconst TimeConstants = {\n  /**\n   * The number of seconds in one millisecond: <code>0.001</code>\n   * @type {number}\n   * @constant\n   */\n  SECONDS_PER_MILLISECOND: 0.001,\n\n  /**\n   * The number of seconds in one minute: <code>60</code>.\n   * @type {number}\n   * @constant\n   */\n  SECONDS_PER_MINUTE: 60.0,\n\n  /**\n   * The number of minutes in one hour: <code>60</code>.\n   * @type {number}\n   * @constant\n   */\n  MINUTES_PER_HOUR: 60.0,\n\n  /**\n   * The number of hours in one day: <code>24</code>.\n   * @type {number}\n   * @constant\n   */\n  HOURS_PER_DAY: 24.0,\n\n  /**\n   * The number of seconds in one hour: <code>3600</code>.\n   * @type {number}\n   * @constant\n   */\n  SECONDS_PER_HOUR: 3600.0,\n\n  /**\n   * The number of minutes in one day: <code>1440</code>.\n   * @type {number}\n   * @constant\n   */\n  MINUTES_PER_DAY: 1440.0,\n\n  /**\n   * The number of seconds in one day, ignoring leap seconds: <code>86400</code>.\n   * @type {number}\n   * @constant\n   */\n  SECONDS_PER_DAY: 86400.0,\n\n  /**\n   * The number of days in one Julian century: <code>36525</code>.\n   * @type {number}\n   * @constant\n   */\n  DAYS_PER_JULIAN_CENTURY: 36525.0,\n\n  /**\n   * One trillionth of a second.\n   * @type {number}\n   * @constant\n   */\n  PICOSECOND: 0.000000001,\n\n  /**\n   * The number of days to subtract from a Julian date to determine the\n   * modified Julian date, which gives the number of days since midnight\n   * on November 17, 1858.\n   * @type {number}\n   * @constant\n   */\n  MODIFIED_JULIAN_DATE_DIFFERENCE: 2400000.5,\n};\nexport default Object.freeze(TimeConstants);\n"],"names":["TimeConstants","SECONDS_PER_MILLISECOND","SECONDS_PER_MINUTE","MINUTES_PER_HOUR","HOURS_PER_DAY","SECONDS_PER_HOUR","MINUTES_PER_DAY","SECONDS_PER_DAY","DAYS_PER_JULIAN_CENTURY","PICOSECOND","MODIFIED_JULIAN_DATE_DIFFERENCE","Object","freeze"],"mappings":";;;;AAAA;;;;;;;;CAQC,GACD,MAAMA,gBAAgB;IACpB;;;;GAIC,GACDC,yBAAyB;IAEzB;;;;GAIC,GACDC,oBAAoB;IAEpB;;;;GAIC,GACDC,kBAAkB;IAElB;;;;GAIC,GACDC,eAAe;IAEf;;;;GAIC,GACDC,kBAAkB;IAElB;;;;GAIC,GACDC,iBAAiB;IAEjB;;;;GAIC,GACDC,iBAAiB;IAEjB;;;;GAIC,GACDC,yBAAyB;IAEzB;;;;GAIC,GACDC,YAAY;IAEZ;;;;;;GAMC,GACDC,iCAAiC;AACnC;uCACeC,OAAOC,MAAM,CAACZ","ignoreList":[0]}},
    {"offset": {"line": 10680, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TimeStandard.js"],"sourcesContent":["/**\n * Provides the type of time standards which JulianDate can take as input.\n *\n * @enum {number}\n *\n * @see JulianDate\n */\nconst TimeStandard = {\n  /**\n   * Represents the coordinated Universal Time (UTC) time standard.\n   *\n   * UTC is related to TAI according to the relationship\n   * <code>UTC = TAI - deltaT</code> where <code>deltaT</code> is the number of leap\n   * seconds which have been introduced as of the time in TAI.\n   *\n   * @type {number}\n   * @constant\n   */\n  UTC: 0,\n\n  /**\n   * Represents the International Atomic Time (TAI) time standard.\n   * TAI is the principal time standard to which the other time standards are related.\n   *\n   * @type {number}\n   * @constant\n   */\n  TAI: 1,\n};\nexport default Object.freeze(TimeStandard);\n"],"names":["TimeStandard","UTC","TAI","Object","freeze"],"mappings":";;;;AAAA;;;;;;CAMC,GACD,MAAMA,eAAe;IACnB;;;;;;;;;GASC,GACDC,KAAK;IAEL;;;;;;GAMC,GACDC,KAAK;AACP;uCACeC,OAAOC,MAAM,CAACJ","ignoreList":[0]}},
    {"offset": {"line": 10714, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/JulianDate.js"],"sourcesContent":["import binarySearch from \"./binarySearch.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GregorianDate from \"./GregorianDate.js\";\nimport isLeapYear from \"./isLeapYear.js\";\nimport LeapSecond from \"./LeapSecond.js\";\nimport TimeConstants from \"./TimeConstants.js\";\nimport TimeStandard from \"./TimeStandard.js\";\n\nconst gregorianDateScratch = new GregorianDate();\nconst daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst daysInLeapFebruary = 29;\n\nfunction compareLeapSecondDates(leapSecond, dateToFind) {\n  return JulianDate.compare(leapSecond.julianDate, dateToFind.julianDate);\n}\n\n// we don't really need a leap second instance, anything with a julianDate property will do\nconst binarySearchScratchLeapSecond = new LeapSecond();\n\nfunction convertUtcToTai(julianDate) {\n  //Even though julianDate is in UTC, we'll treat it as TAI and\n  //search the leap second table for it.\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  const leapSeconds = JulianDate.leapSeconds;\n  let index = binarySearch(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates,\n  );\n\n  if (index < 0) {\n    index = ~index;\n  }\n\n  if (index >= leapSeconds.length) {\n    index = leapSeconds.length - 1;\n  }\n\n  let offset = leapSeconds[index].offset;\n  if (index > 0) {\n    //Now we have the index of the closest leap second that comes on or after our UTC time.\n    //However, if the difference between the UTC date being converted and the TAI\n    //defined leap second is greater than the offset, we are off by one and need to use\n    //the previous leap second.\n    const difference = JulianDate.secondsDifference(\n      leapSeconds[index].julianDate,\n      julianDate,\n    );\n    if (difference > offset) {\n      index--;\n      offset = leapSeconds[index].offset;\n    }\n  }\n\n  JulianDate.addSeconds(julianDate, offset, julianDate);\n}\n\nfunction convertTaiToUtc(julianDate, result) {\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  const leapSeconds = JulianDate.leapSeconds;\n  let index = binarySearch(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates,\n  );\n  if (index < 0) {\n    index = ~index;\n  }\n\n  //All times before our first leap second get the first offset.\n  if (index === 0) {\n    return JulianDate.addSeconds(julianDate, -leapSeconds[0].offset, result);\n  }\n\n  //All times after our leap second get the last offset.\n  if (index >= leapSeconds.length) {\n    return JulianDate.addSeconds(\n      julianDate,\n      -leapSeconds[index - 1].offset,\n      result,\n    );\n  }\n\n  //Compute the difference between the found leap second and the time we are converting.\n  const difference = JulianDate.secondsDifference(\n    leapSeconds[index].julianDate,\n    julianDate,\n  );\n\n  if (difference === 0) {\n    //The date is in our leap second table.\n    return JulianDate.addSeconds(\n      julianDate,\n      -leapSeconds[index].offset,\n      result,\n    );\n  }\n\n  if (difference <= 1.0) {\n    //The requested date is during the moment of a leap second, then we cannot convert to UTC\n    return undefined;\n  }\n\n  //The time is in between two leap seconds, index is the leap second after the date\n  //we're converting, so we subtract one to get the correct LeapSecond instance.\n  return JulianDate.addSeconds(\n    julianDate,\n    -leapSeconds[--index].offset,\n    result,\n  );\n}\n\nfunction setComponents(wholeDays, secondsOfDay, julianDate) {\n  const extraDays = (secondsOfDay / TimeConstants.SECONDS_PER_DAY) | 0;\n  wholeDays += extraDays;\n  secondsOfDay -= TimeConstants.SECONDS_PER_DAY * extraDays;\n\n  if (secondsOfDay < 0) {\n    wholeDays--;\n    secondsOfDay += TimeConstants.SECONDS_PER_DAY;\n  }\n\n  julianDate.dayNumber = wholeDays;\n  julianDate.secondsOfDay = secondsOfDay;\n  return julianDate;\n}\n\nfunction computeJulianDateComponents(\n  year,\n  month,\n  day,\n  hour,\n  minute,\n  second,\n  millisecond,\n) {\n  // Algorithm from page 604 of the Explanatory Supplement to the\n  // Astronomical Almanac (Seidelmann 1992).\n\n  const a = ((month - 14) / 12) | 0;\n  const b = year + 4800 + a;\n  let dayNumber =\n    (((1461 * b) / 4) | 0) +\n    (((367 * (month - 2 - 12 * a)) / 12) | 0) -\n    (((3 * (((b + 100) / 100) | 0)) / 4) | 0) +\n    day -\n    32075;\n\n  // JulianDates are noon-based\n  hour = hour - 12;\n  if (hour < 0) {\n    hour += 24;\n  }\n\n  const secondsOfDay =\n    second +\n    (hour * TimeConstants.SECONDS_PER_HOUR +\n      minute * TimeConstants.SECONDS_PER_MINUTE +\n      millisecond * TimeConstants.SECONDS_PER_MILLISECOND);\n\n  if (secondsOfDay >= 43200.0) {\n    dayNumber -= 1;\n  }\n\n  return [dayNumber, secondsOfDay];\n}\n\n//Regular expressions used for ISO8601 date parsing.\n//YYYY\nconst matchCalendarYear = /^(\\d{4})$/;\n//YYYY-MM (YYYYMM is invalid)\nconst matchCalendarMonth = /^(\\d{4})-(\\d{2})$/;\n//YYYY-DDD or YYYYDDD\nconst matchOrdinalDate = /^(\\d{4})-?(\\d{3})$/;\n//YYYY-Www or YYYYWww or YYYY-Www-D or YYYYWwwD\nconst matchWeekDate = /^(\\d{4})-?W(\\d{2})-?(\\d{1})?$/;\n//YYYY-MM-DD or YYYYMMDD\nconst matchCalendarDate = /^(\\d{4})-?(\\d{2})-?(\\d{2})$/;\n// Match utc offset\nconst utcOffset = /([Z+\\-])?(\\d{2})?:?(\\d{2})?$/;\n// Match hours HH or HH.xxxxx\nconst matchHours = /^(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n// Match hours/minutes HH:MM HHMM.xxxxx\nconst matchHoursMinutes = /^(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n// Match hours/minutes HH:MM:SS HHMMSS.xxxxx\nconst matchHoursMinutesSeconds =\n  /^(\\d{2}):?(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n\nconst iso8601ErrorMessage = \"Invalid ISO 8601 date.\";\n\n/**\n * Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).\n * For increased precision, this class stores the whole number part of the date and the seconds\n * part of the date in separate components.  In order to be safe for arithmetic and represent\n * leap seconds, the date is always stored in the International Atomic Time standard\n * {@link TimeStandard.TAI}.\n * @alias JulianDate\n * @constructor\n *\n * @param {number} [julianDayNumber=0.0] The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.\n * @param {number} [secondsOfDay=0.0] The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.\n * @param {TimeStandard} [timeStandard=TimeStandard.UTC] The time standard in which the first two parameters are defined.\n */\nfunction JulianDate(julianDayNumber, secondsOfDay, timeStandard) {\n  /**\n   * Gets or sets the number of whole days.\n   * @type {number}\n   */\n  this.dayNumber = undefined;\n\n  /**\n   * Gets or sets the number of seconds into the current day.\n   * @type {number}\n   */\n  this.secondsOfDay = undefined;\n\n  julianDayNumber = julianDayNumber ?? 0.0;\n  secondsOfDay = secondsOfDay ?? 0.0;\n  timeStandard = timeStandard ?? TimeStandard.UTC;\n\n  //If julianDayNumber is fractional, make it an integer and add the number of seconds the fraction represented.\n  const wholeDays = julianDayNumber | 0;\n  secondsOfDay =\n    secondsOfDay +\n    (julianDayNumber - wholeDays) * TimeConstants.SECONDS_PER_DAY;\n\n  setComponents(wholeDays, secondsOfDay, this);\n\n  if (timeStandard === TimeStandard.UTC) {\n    convertUtcToTai(this);\n  }\n}\n\n/**\n * Creates a new instance from a GregorianDate.\n *\n * @param {GregorianDate} date A GregorianDate.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} date must be a valid GregorianDate.\n */\nJulianDate.fromGregorianDate = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!(date instanceof GregorianDate)) {\n    throw new DeveloperError(\"date must be a valid GregorianDate.\");\n  }\n  //>>includeEnd('debug');\n\n  const components = computeJulianDateComponents(\n    date.year,\n    date.month,\n    date.day,\n    date.hour,\n    date.minute,\n    date.second,\n    date.millisecond,\n  );\n  if (!defined(result)) {\n    return new JulianDate(components[0], components[1], TimeStandard.UTC);\n  }\n  setComponents(components[0], components[1], result);\n  convertUtcToTai(result);\n  return result;\n};\n\n/**\n * Creates a new instance from a JavaScript Date.\n *\n * @param {Date} date A JavaScript Date.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} date must be a valid JavaScript Date.\n */\nJulianDate.fromDate = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!(date instanceof Date) || isNaN(date.getTime())) {\n    throw new DeveloperError(\"date must be a valid JavaScript Date.\");\n  }\n  //>>includeEnd('debug');\n\n  const components = computeJulianDateComponents(\n    date.getUTCFullYear(),\n    date.getUTCMonth() + 1,\n    date.getUTCDate(),\n    date.getUTCHours(),\n    date.getUTCMinutes(),\n    date.getUTCSeconds(),\n    date.getUTCMilliseconds(),\n  );\n  if (!defined(result)) {\n    return new JulianDate(components[0], components[1], TimeStandard.UTC);\n  }\n  setComponents(components[0], components[1], result);\n  convertUtcToTai(result);\n  return result;\n};\n\n/**\n * Creates a new instance from a from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date.\n * This method is superior to <code>Date.parse</code> because it will handle all valid formats defined by the ISO 8601\n * specification, including leap seconds and sub-millisecond times, which discarded by most JavaScript implementations.\n *\n * @param {string} iso8601String An ISO 8601 date.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} Invalid ISO 8601 date.\n */\nJulianDate.fromIso8601 = function (iso8601String, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof iso8601String !== \"string\") {\n    throw new DeveloperError(iso8601ErrorMessage);\n  }\n  //>>includeEnd('debug');\n\n  //Comma and decimal point both indicate a fractional number according to ISO 8601,\n  //start out by blanket replacing , with . which is the only valid such symbol in JS.\n  iso8601String = iso8601String.replace(\",\", \".\");\n\n  //Split the string into its date and time components, denoted by a mandatory T\n  let tokens = iso8601String.split(\"T\");\n  let year;\n  let month = 1;\n  let day = 1;\n  let hour = 0;\n  let minute = 0;\n  let second = 0;\n  let millisecond = 0;\n\n  //Lacking a time is okay, but a missing date is illegal.\n  const date = tokens[0];\n  const time = tokens[1];\n  let tmp;\n  let inLeapYear;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(iso8601ErrorMessage);\n  }\n\n  let dashCount;\n  //>>includeEnd('debug');\n\n  //First match the date against possible regular expressions.\n  tokens = date.match(matchCalendarDate);\n  if (tokens !== null) {\n    //>>includeStart('debug', pragmas.debug);\n    dashCount = date.split(\"-\").length - 1;\n    if (dashCount > 0 && dashCount !== 2) {\n      throw new DeveloperError(iso8601ErrorMessage);\n    }\n    //>>includeEnd('debug');\n    year = +tokens[1];\n    month = +tokens[2];\n    day = +tokens[3];\n  } else {\n    tokens = date.match(matchCalendarMonth);\n    if (tokens !== null) {\n      year = +tokens[1];\n      month = +tokens[2];\n    } else {\n      tokens = date.match(matchCalendarYear);\n      if (tokens !== null) {\n        year = +tokens[1];\n      } else {\n        //Not a year/month/day so it must be an ordinal date.\n        let dayOfYear;\n        tokens = date.match(matchOrdinalDate);\n        if (tokens !== null) {\n          year = +tokens[1];\n          dayOfYear = +tokens[2];\n          inLeapYear = isLeapYear(year);\n\n          //This validation is only applicable for this format.\n          //>>includeStart('debug', pragmas.debug);\n          if (\n            dayOfYear < 1 ||\n            (inLeapYear && dayOfYear > 366) ||\n            (!inLeapYear && dayOfYear > 365)\n          ) {\n            throw new DeveloperError(iso8601ErrorMessage);\n          }\n          //>>includeEnd('debug');\n        } else {\n          tokens = date.match(matchWeekDate);\n          if (tokens !== null) {\n            //ISO week date to ordinal date from\n            //http://en.wikipedia.org/w/index.php?title=ISO_week_date&oldid=474176775\n            year = +tokens[1];\n            const weekNumber = +tokens[2];\n            const dayOfWeek = +tokens[3] || 0;\n\n            //>>includeStart('debug', pragmas.debug);\n            dashCount = date.split(\"-\").length - 1;\n            if (\n              dashCount > 0 &&\n              ((!defined(tokens[3]) && dashCount !== 1) ||\n                (defined(tokens[3]) && dashCount !== 2))\n            ) {\n              throw new DeveloperError(iso8601ErrorMessage);\n            }\n            //>>includeEnd('debug');\n\n            const january4 = new Date(Date.UTC(year, 0, 4));\n            dayOfYear = weekNumber * 7 + dayOfWeek - january4.getUTCDay() - 3;\n          } else {\n            //None of our regular expressions succeeded in parsing the date properly.\n            //>>includeStart('debug', pragmas.debug);\n            throw new DeveloperError(iso8601ErrorMessage);\n            //>>includeEnd('debug');\n          }\n        }\n        //Split an ordinal date into month/day.\n        tmp = new Date(Date.UTC(year, 0, 1));\n        tmp.setUTCDate(dayOfYear);\n        month = tmp.getUTCMonth() + 1;\n        day = tmp.getUTCDate();\n      }\n    }\n  }\n\n  //Now that we have all of the date components, validate them to make sure nothing is out of range.\n  inLeapYear = isLeapYear(year);\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    month < 1 ||\n    month > 12 ||\n    day < 1 ||\n    ((month !== 2 || !inLeapYear) && day > daysInMonth[month - 1]) ||\n    (inLeapYear && month === 2 && day > daysInLeapFebruary)\n  ) {\n    throw new DeveloperError(iso8601ErrorMessage);\n  }\n  //>>includeEnd('debug');\n\n  //Now move onto the time string, which is much simpler.\n  //If no time is specified, it is considered the beginning of the day, UTC to match Javascript's implementation.\n  let offsetIndex;\n  if (defined(time)) {\n    tokens = time.match(matchHoursMinutesSeconds);\n    if (tokens !== null) {\n      //>>includeStart('debug', pragmas.debug);\n      dashCount = time.split(\":\").length - 1;\n      if (dashCount > 0 && dashCount !== 2 && dashCount !== 3) {\n        throw new DeveloperError(iso8601ErrorMessage);\n      }\n      //>>includeEnd('debug');\n\n      hour = +tokens[1];\n      minute = +tokens[2];\n      second = +tokens[3];\n      millisecond = +(tokens[4] || 0) * 1000.0;\n      offsetIndex = 5;\n    } else {\n      tokens = time.match(matchHoursMinutes);\n      if (tokens !== null) {\n        //>>includeStart('debug', pragmas.debug);\n        dashCount = time.split(\":\").length - 1;\n        if (dashCount > 2) {\n          throw new DeveloperError(iso8601ErrorMessage);\n        }\n        //>>includeEnd('debug');\n\n        hour = +tokens[1];\n        minute = +tokens[2];\n        second = +(tokens[3] || 0) * 60.0;\n        offsetIndex = 4;\n      } else {\n        tokens = time.match(matchHours);\n        if (tokens !== null) {\n          hour = +tokens[1];\n          minute = +(tokens[2] || 0) * 60.0;\n          offsetIndex = 3;\n        } else {\n          //>>includeStart('debug', pragmas.debug);\n          throw new DeveloperError(iso8601ErrorMessage);\n          //>>includeEnd('debug');\n        }\n      }\n    }\n\n    //Validate that all values are in proper range.  Minutes and hours have special cases at 60 and 24.\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      minute >= 60 ||\n      second >= 61 ||\n      hour > 24 ||\n      (hour === 24 && (minute > 0 || second > 0 || millisecond > 0))\n    ) {\n      throw new DeveloperError(iso8601ErrorMessage);\n    }\n    //>>includeEnd('debug');\n\n    //Check the UTC offset value, if no value exists, use local time\n    //a Z indicates UTC, + or - are offsets.\n    const offset = tokens[offsetIndex];\n    const offsetHours = +tokens[offsetIndex + 1];\n    const offsetMinutes = +(tokens[offsetIndex + 2] || 0);\n    switch (offset) {\n      case \"+\":\n        hour = hour - offsetHours;\n        minute = minute - offsetMinutes;\n        break;\n      case \"-\":\n        hour = hour + offsetHours;\n        minute = minute + offsetMinutes;\n        break;\n      case \"Z\":\n        break;\n      default:\n        minute =\n          minute +\n          new Date(\n            Date.UTC(year, month - 1, day, hour, minute),\n          ).getTimezoneOffset();\n        break;\n    }\n  }\n\n  //ISO8601 denotes a leap second by any time having a seconds component of 60 seconds.\n  //If that's the case, we need to temporarily subtract a second in order to build a UTC date.\n  //Then we add it back in after converting to TAI.\n  const isLeapSecond = second === 60;\n  if (isLeapSecond) {\n    second--;\n  }\n\n  //Even if we successfully parsed the string into its components, after applying UTC offset or\n  //special cases like 24:00:00 denoting midnight, we need to normalize the data appropriately.\n\n  //milliseconds can never be greater than 1000, and seconds can't be above 60, so we start with minutes\n  while (minute >= 60) {\n    minute -= 60;\n    hour++;\n  }\n\n  while (hour >= 24) {\n    hour -= 24;\n    day++;\n  }\n\n  tmp = inLeapYear && month === 2 ? daysInLeapFebruary : daysInMonth[month - 1];\n  while (day > tmp) {\n    day -= tmp;\n    month++;\n\n    if (month > 12) {\n      month -= 12;\n      year++;\n    }\n\n    tmp =\n      inLeapYear && month === 2 ? daysInLeapFebruary : daysInMonth[month - 1];\n  }\n\n  //If UTC offset is at the beginning/end of the day, minutes can be negative.\n  while (minute < 0) {\n    minute += 60;\n    hour--;\n  }\n\n  while (hour < 0) {\n    hour += 24;\n    day--;\n  }\n\n  while (day < 1) {\n    month--;\n    if (month < 1) {\n      month += 12;\n      year--;\n    }\n\n    tmp =\n      inLeapYear && month === 2 ? daysInLeapFebruary : daysInMonth[month - 1];\n    day += tmp;\n  }\n\n  //Now create the JulianDate components from the Gregorian date and actually create our instance.\n  const components = computeJulianDateComponents(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n  );\n\n  if (!defined(result)) {\n    result = new JulianDate(components[0], components[1], TimeStandard.UTC);\n  } else {\n    setComponents(components[0], components[1], result);\n    convertUtcToTai(result);\n  }\n\n  //If we were on a leap second, add it back.\n  if (isLeapSecond) {\n    JulianDate.addSeconds(result, 1, result);\n  }\n\n  return result;\n};\n\n/**\n * Creates a new instance that represents the current system time.\n * This is equivalent to calling <code>JulianDate.fromDate(new Date());</code>.\n *\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.now = function (result) {\n  return JulianDate.fromDate(new Date(), result);\n};\n\nconst toGregorianDateScratch = new JulianDate(0, 0, TimeStandard.TAI);\n\n/**\n * Creates a {@link GregorianDate} from the provided instance.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @param {GregorianDate} [result] An existing instance to use for the result.\n * @returns {GregorianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.toGregorianDate = function (julianDate, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let isLeapSecond = false;\n  let thisUtc = convertTaiToUtc(julianDate, toGregorianDateScratch);\n  if (!defined(thisUtc)) {\n    //Conversion to UTC will fail if we are during a leap second.\n    //If that's the case, subtract a second and convert again.\n    //JavaScript doesn't support leap seconds, so this results in second 59 being repeated twice.\n    JulianDate.addSeconds(julianDate, -1, toGregorianDateScratch);\n    thisUtc = convertTaiToUtc(toGregorianDateScratch, toGregorianDateScratch);\n    isLeapSecond = true;\n  }\n\n  let julianDayNumber = thisUtc.dayNumber;\n  const secondsOfDay = thisUtc.secondsOfDay;\n\n  if (secondsOfDay >= 43200.0) {\n    julianDayNumber += 1;\n  }\n\n  // Algorithm from page 604 of the Explanatory Supplement to the\n  // Astronomical Almanac (Seidelmann 1992).\n  let L = (julianDayNumber + 68569) | 0;\n  const N = ((4 * L) / 146097) | 0;\n  L = (L - (((146097 * N + 3) / 4) | 0)) | 0;\n  const I = ((4000 * (L + 1)) / 1461001) | 0;\n  L = (L - (((1461 * I) / 4) | 0) + 31) | 0;\n  const J = ((80 * L) / 2447) | 0;\n  const day = (L - (((2447 * J) / 80) | 0)) | 0;\n  L = (J / 11) | 0;\n  const month = (J + 2 - 12 * L) | 0;\n  const year = (100 * (N - 49) + I + L) | 0;\n\n  let hour = (secondsOfDay / TimeConstants.SECONDS_PER_HOUR) | 0;\n  let remainingSeconds = secondsOfDay - hour * TimeConstants.SECONDS_PER_HOUR;\n  const minute = (remainingSeconds / TimeConstants.SECONDS_PER_MINUTE) | 0;\n  remainingSeconds =\n    remainingSeconds - minute * TimeConstants.SECONDS_PER_MINUTE;\n  let second = remainingSeconds | 0;\n  const millisecond =\n    (remainingSeconds - second) / TimeConstants.SECONDS_PER_MILLISECOND;\n\n  // JulianDates are noon-based\n  hour += 12;\n  if (hour > 23) {\n    hour -= 24;\n  }\n\n  //If we were on a leap second, add it back.\n  if (isLeapSecond) {\n    second += 1;\n  }\n\n  if (!defined(result)) {\n    return new GregorianDate(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      isLeapSecond,\n    );\n  }\n\n  result.year = year;\n  result.month = month;\n  result.day = day;\n  result.hour = hour;\n  result.minute = minute;\n  result.second = second;\n  result.millisecond = millisecond;\n  result.isLeapSecond = isLeapSecond;\n  return result;\n};\n\n/**\n * Creates a JavaScript Date from the provided instance.\n * Since JavaScript dates are only accurate to the nearest millisecond and\n * cannot represent a leap second, consider using {@link JulianDate.toGregorianDate} instead.\n * If the provided JulianDate is during a leap second, the previous second is used.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @returns {Date} A new instance representing the provided date.\n */\nJulianDate.toDate = function (julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n  let second = gDate.second;\n  if (gDate.isLeapSecond) {\n    second -= 1;\n  }\n  return new Date(\n    Date.UTC(\n      gDate.year,\n      gDate.month - 1,\n      gDate.day,\n      gDate.hour,\n      gDate.minute,\n      second,\n      gDate.millisecond,\n    ),\n  );\n};\n\n/**\n * Creates an ISO8601 representation of the provided date.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @param {number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.\n * @returns {string} The ISO8601 representation of the provided date.\n */\nJulianDate.toIso8601 = function (julianDate, precision) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n  let year = gDate.year;\n  let month = gDate.month;\n  let day = gDate.day;\n  let hour = gDate.hour;\n  const minute = gDate.minute;\n  const second = gDate.second;\n  const millisecond = gDate.millisecond;\n\n  // special case - Iso8601.MAXIMUM_VALUE produces a string which we can't parse unless we adjust.\n  // 10000-01-01T00:00:00 is the same instant as 9999-12-31T24:00:00\n  if (\n    year === 10000 &&\n    month === 1 &&\n    day === 1 &&\n    hour === 0 &&\n    minute === 0 &&\n    second === 0 &&\n    millisecond === 0\n  ) {\n    year = 9999;\n    month = 12;\n    day = 31;\n    hour = 24;\n  }\n\n  let millisecondStr;\n\n  if (!defined(precision) && millisecond !== 0) {\n    // Forces milliseconds into a number with at least 3 digits.\n    const millisecondHundreds = millisecond * 0.01;\n    // Below 1e-6, toString returns scientific notation, so it should be replaced by toFixed with appropriate number of digits.\n    // 20 digits is a trade-off choice guided by JavaScript's Number representation accuracy (15-17 decimal digits for most numbers).\n    // Using toFixed(20) ensures capturing enough precision while avoiding inaccuracies due to floating-point limitations.\n    millisecondStr =\n      millisecondHundreds < 1e-6\n        ? millisecondHundreds.toFixed(20).replace(\".\", \"\").replace(/0+$/, \"\")\n        : millisecondHundreds.toString().replace(\".\", \"\");\n    return `${year.toString().padStart(4, \"0\")}-${month\n      .toString()\n      .padStart(2, \"0\")}-${day.toString().padStart(2, \"0\")}T${hour\n      .toString()\n      .padStart(2, \"0\")}:${minute.toString().padStart(2, \"0\")}:${second\n      .toString()\n      .padStart(2, \"0\")}.${millisecondStr}Z`;\n  }\n\n  //Precision is either 0 or milliseconds is 0 with undefined precision, in either case, leave off milliseconds entirely\n  if (!defined(precision) || precision === 0) {\n    return `${year.toString().padStart(4, \"0\")}-${month\n      .toString()\n      .padStart(2, \"0\")}-${day.toString().padStart(2, \"0\")}T${hour\n      .toString()\n      .padStart(2, \"0\")}:${minute\n      .toString()\n      .padStart(2, \"0\")}:${second.toString().padStart(2, \"0\")}Z`;\n  }\n\n  //Forces milliseconds into a number with at least 3 digits to whatever the specified precision is.\n  millisecondStr = (millisecond * 0.01)\n    .toFixed(precision)\n    .replace(\".\", \"\")\n    .slice(0, precision);\n  return `${year.toString().padStart(4, \"0\")}-${month\n    .toString()\n    .padStart(2, \"0\")}-${day.toString().padStart(2, \"0\")}T${hour\n    .toString()\n    .padStart(2, \"0\")}:${minute.toString().padStart(2, \"0\")}:${second\n    .toString()\n    .padStart(2, \"0\")}.${millisecondStr}Z`;\n};\n\n/**\n * Duplicates a JulianDate instance.\n *\n * @param {JulianDate} julianDate The date to duplicate.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided. Returns undefined if julianDate is undefined.\n */\nJulianDate.clone = function (julianDate, result) {\n  if (!defined(julianDate)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new JulianDate(\n      julianDate.dayNumber,\n      julianDate.secondsOfDay,\n      TimeStandard.TAI,\n    );\n  }\n  result.dayNumber = julianDate.dayNumber;\n  result.secondsOfDay = julianDate.secondsOfDay;\n  return result;\n};\n\n/**\n * Compares two instances.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {number} A negative value if left is less than right, a positive value if left is greater than right, or zero if left and right are equal.\n */\nJulianDate.compare = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const julianDayNumberDifference = left.dayNumber - right.dayNumber;\n  if (julianDayNumberDifference !== 0) {\n    return julianDayNumberDifference;\n  }\n  return left.secondsOfDay - right.secondsOfDay;\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {JulianDate} [left] The first instance.\n * @param {JulianDate} [right] The second instance.\n * @returns {boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nJulianDate.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.dayNumber === right.dayNumber &&\n      left.secondsOfDay === right.secondsOfDay)\n  );\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {JulianDate} [left] The first instance.\n * @param {JulianDate} [right] The second instance.\n * @param {number} [epsilon=0] The maximum number of seconds that should separate the two instances.\n * @returns {boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nJulianDate.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = epsilon ?? 0;\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(JulianDate.secondsDifference(left, right)) <= epsilon)\n  );\n};\n\n/**\n * Computes the total number of whole and fractional days represented by the provided instance.\n *\n * @param {JulianDate} julianDate The date.\n * @returns {number} The Julian date as single floating point number.\n */\nJulianDate.totalDays = function (julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n  return (\n    julianDate.dayNumber +\n    julianDate.secondsOfDay / TimeConstants.SECONDS_PER_DAY\n  );\n};\n\n/**\n * Computes the difference in seconds between the provided instance.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {number} The difference, in seconds, when subtracting <code>right</code> from <code>left</code>.\n */\nJulianDate.secondsDifference = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const dayDifference =\n    (left.dayNumber - right.dayNumber) * TimeConstants.SECONDS_PER_DAY;\n  return dayDifference + (left.secondsOfDay - right.secondsOfDay);\n};\n\n/**\n * Computes the difference in days between the provided instance.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {number} The difference, in days, when subtracting <code>right</code> from <code>left</code>.\n */\nJulianDate.daysDifference = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const dayDifference = left.dayNumber - right.dayNumber;\n  const secondDifference =\n    (left.secondsOfDay - right.secondsOfDay) / TimeConstants.SECONDS_PER_DAY;\n  return dayDifference + secondDifference;\n};\n\n/**\n * Computes the number of seconds the provided instance is ahead of UTC.\n *\n * @param {JulianDate} julianDate The date.\n * @returns {number} The number of seconds the provided instance is ahead of UTC\n */\nJulianDate.computeTaiMinusUtc = function (julianDate) {\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  const leapSeconds = JulianDate.leapSeconds;\n  let index = binarySearch(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates,\n  );\n  if (index < 0) {\n    index = ~index;\n    --index;\n    if (index < 0) {\n      index = 0;\n    }\n  }\n  return leapSeconds[index].offset;\n};\n\n/**\n * Adds the provided number of seconds to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {number} seconds The number of seconds to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addSeconds = function (julianDate, seconds, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(seconds)) {\n    throw new DeveloperError(\"seconds is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return setComponents(\n    julianDate.dayNumber,\n    julianDate.secondsOfDay + seconds,\n    result,\n  );\n};\n\n/**\n * Adds the provided number of minutes to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {number} minutes The number of minutes to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addMinutes = function (julianDate, minutes, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(minutes)) {\n    throw new DeveloperError(\"minutes is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const newSecondsOfDay =\n    julianDate.secondsOfDay + minutes * TimeConstants.SECONDS_PER_MINUTE;\n  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n};\n\n/**\n * Adds the provided number of hours to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {number} hours The number of hours to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addHours = function (julianDate, hours, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(hours)) {\n    throw new DeveloperError(\"hours is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const newSecondsOfDay =\n    julianDate.secondsOfDay + hours * TimeConstants.SECONDS_PER_HOUR;\n  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n};\n\n/**\n * Adds the provided number of days to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {number} days The number of days to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addDays = function (julianDate, days, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(days)) {\n    throw new DeveloperError(\"days is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const newJulianDayNumber = julianDate.dayNumber + days;\n  return setComponents(newJulianDayNumber, julianDate.secondsOfDay, result);\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {boolean} <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.lessThan = function (left, right) {\n  return JulianDate.compare(left, right) < 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {boolean} <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.lessThanOrEquals = function (left, right) {\n  return JulianDate.compare(left, right) <= 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {boolean} <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.greaterThan = function (left, right) {\n  return JulianDate.compare(left, right) > 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {boolean} <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.greaterThanOrEquals = function (left, right) {\n  return JulianDate.compare(left, right) >= 0;\n};\n\n/**\n * Duplicates this instance.\n *\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.prototype.clone = function (result) {\n  return JulianDate.clone(this, result);\n};\n\n/**\n * Compares this and the provided instance and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {JulianDate} [right] The second instance.\n * @returns {boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nJulianDate.prototype.equals = function (right) {\n  return JulianDate.equals(this, right);\n};\n\n/**\n * Compares this and the provided instance and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {JulianDate} [right] The second instance.\n * @param {number} [epsilon=0] The maximum number of seconds that should separate the two instances.\n * @returns {boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nJulianDate.prototype.equalsEpsilon = function (right, epsilon) {\n  return JulianDate.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this date in ISO8601 format.\n *\n * @returns {string} A string representing this date in ISO8601 format.\n */\nJulianDate.prototype.toString = function () {\n  return JulianDate.toIso8601(this);\n};\n\n/**\n * Gets or sets the list of leap seconds used throughout Cesium.\n * @memberof JulianDate\n * @type {LeapSecond[]}\n */\nJulianDate.leapSeconds = [\n  new LeapSecond(new JulianDate(2441317, 43210.0, TimeStandard.TAI), 10), // January 1, 1972 00:00:00 UTC\n  new LeapSecond(new JulianDate(2441499, 43211.0, TimeStandard.TAI), 11), // July 1, 1972 00:00:00 UTC\n  new LeapSecond(new JulianDate(2441683, 43212.0, TimeStandard.TAI), 12), // January 1, 1973 00:00:00 UTC\n  new LeapSecond(new JulianDate(2442048, 43213.0, TimeStandard.TAI), 13), // January 1, 1974 00:00:00 UTC\n  new LeapSecond(new JulianDate(2442413, 43214.0, TimeStandard.TAI), 14), // January 1, 1975 00:00:00 UTC\n  new LeapSecond(new JulianDate(2442778, 43215.0, TimeStandard.TAI), 15), // January 1, 1976 00:00:00 UTC\n  new LeapSecond(new JulianDate(2443144, 43216.0, TimeStandard.TAI), 16), // January 1, 1977 00:00:00 UTC\n  new LeapSecond(new JulianDate(2443509, 43217.0, TimeStandard.TAI), 17), // January 1, 1978 00:00:00 UTC\n  new LeapSecond(new JulianDate(2443874, 43218.0, TimeStandard.TAI), 18), // January 1, 1979 00:00:00 UTC\n  new LeapSecond(new JulianDate(2444239, 43219.0, TimeStandard.TAI), 19), // January 1, 1980 00:00:00 UTC\n  new LeapSecond(new JulianDate(2444786, 43220.0, TimeStandard.TAI), 20), // July 1, 1981 00:00:00 UTC\n  new LeapSecond(new JulianDate(2445151, 43221.0, TimeStandard.TAI), 21), // July 1, 1982 00:00:00 UTC\n  new LeapSecond(new JulianDate(2445516, 43222.0, TimeStandard.TAI), 22), // July 1, 1983 00:00:00 UTC\n  new LeapSecond(new JulianDate(2446247, 43223.0, TimeStandard.TAI), 23), // July 1, 1985 00:00:00 UTC\n  new LeapSecond(new JulianDate(2447161, 43224.0, TimeStandard.TAI), 24), // January 1, 1988 00:00:00 UTC\n  new LeapSecond(new JulianDate(2447892, 43225.0, TimeStandard.TAI), 25), // January 1, 1990 00:00:00 UTC\n  new LeapSecond(new JulianDate(2448257, 43226.0, TimeStandard.TAI), 26), // January 1, 1991 00:00:00 UTC\n  new LeapSecond(new JulianDate(2448804, 43227.0, TimeStandard.TAI), 27), // July 1, 1992 00:00:00 UTC\n  new LeapSecond(new JulianDate(2449169, 43228.0, TimeStandard.TAI), 28), // July 1, 1993 00:00:00 UTC\n  new LeapSecond(new JulianDate(2449534, 43229.0, TimeStandard.TAI), 29), // July 1, 1994 00:00:00 UTC\n  new LeapSecond(new JulianDate(2450083, 43230.0, TimeStandard.TAI), 30), // January 1, 1996 00:00:00 UTC\n  new LeapSecond(new JulianDate(2450630, 43231.0, TimeStandard.TAI), 31), // July 1, 1997 00:00:00 UTC\n  new LeapSecond(new JulianDate(2451179, 43232.0, TimeStandard.TAI), 32), // January 1, 1999 00:00:00 UTC\n  new LeapSecond(new JulianDate(2453736, 43233.0, TimeStandard.TAI), 33), // January 1, 2006 00:00:00 UTC\n  new LeapSecond(new JulianDate(2454832, 43234.0, TimeStandard.TAI), 34), // January 1, 2009 00:00:00 UTC\n  new LeapSecond(new JulianDate(2456109, 43235.0, TimeStandard.TAI), 35), // July 1, 2012 00:00:00 UTC\n  new LeapSecond(new JulianDate(2457204, 43236.0, TimeStandard.TAI), 36), // July 1, 2015 00:00:00 UTC\n  new LeapSecond(new JulianDate(2457754, 43237.0, TimeStandard.TAI), 37), // January 1, 2017 00:00:00 UTC\n];\nexport default JulianDate;\n"],"names":["gregorianDateScratch","daysInMonth","daysInLeapFebruary","compareLeapSecondDates","leapSecond","dateToFind","JulianDate","compare","julianDate","binarySearchScratchLeapSecond","convertUtcToTai","leapSeconds","index","length","offset","difference","secondsDifference","addSeconds","convertTaiToUtc","result","undefined","setComponents","wholeDays","secondsOfDay","extraDays","SECONDS_PER_DAY","dayNumber","computeJulianDateComponents","year","month","day","hour","minute","second","millisecond","a","b","SECONDS_PER_HOUR","SECONDS_PER_MINUTE","SECONDS_PER_MILLISECOND","matchCalendarYear","matchCalendarMonth","matchOrdinalDate","matchWeekDate","matchCalendarDate","utcOffset","matchHours","source","matchHoursMinutes","matchHoursMinutesSeconds","iso8601ErrorMessage","julianDayNumber","timeStandard","UTC","fromGregorianDate","date","components","fromDate","Date","isNaN","getTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","fromIso8601","iso8601String","replace","tokens","split","time","tmp","inLeapYear","dashCount","match","dayOfYear","weekNumber","dayOfWeek","january4","getUTCDay","setUTCDate","offsetIndex","offsetHours","offsetMinutes","getTimezoneOffset","isLeapSecond","now","toGregorianDateScratch","TAI","toGregorianDate","thisUtc","L","N","I","J","remainingSeconds","toDate","gDate","toIso8601","precision","millisecondStr","millisecondHundreds","toFixed","toString","padStart","slice","clone","left","right","julianDayNumberDifference","equals","equalsEpsilon","epsilon","Math","abs","totalDays","dayDifference","daysDifference","secondDifference","computeTaiMinusUtc","seconds","addMinutes","minutes","newSecondsOfDay","addHours","hours","addDays","days","newJulianDayNumber","lessThan","lessThanOrEquals","greaterThan","greaterThanOrEquals","prototype"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11650, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/EarthOrientationParameters.js"],"sourcesContent":["import binarySearch from \"./binarySearch.js\";\nimport Check from \"./Check.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport EarthOrientationParametersSample from \"./EarthOrientationParametersSample.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport LeapSecond from \"./LeapSecond.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TimeConstants from \"./TimeConstants.js\";\nimport TimeStandard from \"./TimeStandard.js\";\n\n/**\n * Specifies Earth polar motion coordinates and the difference between UT1 and UTC.\n * These Earth Orientation Parameters (EOP) are primarily used in the transformation from\n * the International Celestial Reference Frame (ICRF) to the International Terrestrial\n * Reference Frame (ITRF).\n * This object is normally not instantiated directly, use {@link EarthOrientationParameters.fromUrl}.\n *\n * @alias EarthOrientationParameters\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {object} [options.data] The actual EOP data.  If neither this\n *                 parameter nor options.data is specified, all EOP values are assumed\n *                 to be 0.0.\n * @param {boolean} [options.addNewLeapSeconds=true] True if leap seconds that\n *                  are specified in the EOP data but not in {@link JulianDate.leapSeconds}\n *                  should be added to {@link JulianDate.leapSeconds}.  False if\n *                  new leap seconds should be handled correctly in the context\n *                  of the EOP data but otherwise ignored.\n *\n * @private\n */\nfunction EarthOrientationParameters(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  this._dates = undefined;\n  this._samples = undefined;\n\n  this._dateColumn = -1;\n  this._xPoleWanderRadiansColumn = -1;\n  this._yPoleWanderRadiansColumn = -1;\n  this._ut1MinusUtcSecondsColumn = -1;\n  this._xCelestialPoleOffsetRadiansColumn = -1;\n  this._yCelestialPoleOffsetRadiansColumn = -1;\n  this._taiMinusUtcSecondsColumn = -1;\n\n  this._columnCount = 0;\n  this._lastIndex = -1;\n\n  this._addNewLeapSeconds = options.addNewLeapSeconds ?? true;\n\n  if (defined(options.data)) {\n    // Use supplied EOP data.\n    onDataReady(this, options.data);\n  } else {\n    // Use all zeros for EOP data.\n    onDataReady(this, {\n      columnNames: [\n        \"dateIso8601\",\n        \"modifiedJulianDateUtc\",\n        \"xPoleWanderRadians\",\n        \"yPoleWanderRadians\",\n        \"ut1MinusUtcSeconds\",\n        \"lengthOfDayCorrectionSeconds\",\n        \"xCelestialPoleOffsetRadians\",\n        \"yCelestialPoleOffsetRadians\",\n        \"taiMinusUtcSeconds\",\n      ],\n      samples: [],\n    });\n  }\n}\n\n/**\n *\n * @param {Resource|string} [url] The URL from which to obtain EOP data.  If neither this\n *                 parameter nor options.data is specified, all EOP values are assumed\n *                 to be 0.0.  If options.data is specified, this parameter is\n *                 ignored.\n * @param {object} [options] Object with the following properties:\n * @param {boolean} [options.addNewLeapSeconds=true] True if leap seconds that\n *                  are specified in the EOP data but not in {@link JulianDate.leapSeconds}\n *                  should be added to {@link JulianDate.leapSeconds}.  False if\n *                  new leap seconds should be handled correctly in the context\n *                  of the EOP data but otherwise ignored.\n *\n * @example\n * // An example EOP data file, EOP.json:\n * {\n *   \"columnNames\" : [\"dateIso8601\",\"modifiedJulianDateUtc\",\"xPoleWanderRadians\",\"yPoleWanderRadians\",\"ut1MinusUtcSeconds\",\"lengthOfDayCorrectionSeconds\",\"xCelestialPoleOffsetRadians\",\"yCelestialPoleOffsetRadians\",\"taiMinusUtcSeconds\"],\n *   \"samples\" : [\n *      \"2011-07-01T00:00:00Z\",55743.0,2.117957047295119e-7,2.111518721609984e-6,-0.2908948,-2.956e-4,3.393695767766752e-11,3.3452143996557983e-10,34.0,\n *      \"2011-07-02T00:00:00Z\",55744.0,2.193297093339541e-7,2.115460256837405e-6,-0.29065,-1.824e-4,-8.241832578862112e-11,5.623838700870617e-10,34.0,\n *      \"2011-07-03T00:00:00Z\",55745.0,2.262286080161428e-7,2.1191157519929706e-6,-0.2905572,1.9e-6,-3.490658503988659e-10,6.981317007977318e-10,34.0\n *   ]\n * }\n *\n * @example\n * // Loading the EOP data\n * const eop = await Cesium.EarthOrientationParameters.fromUrl('Data/EOP.json');\n * Cesium.Transforms.earthOrientationParameters = eop;\n */\nEarthOrientationParameters.fromUrl = async function (url, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const resource = Resource.createIfNeeded(url);\n\n  // Download EOP data.\n  let eopData;\n  try {\n    eopData = await resource.fetchJson();\n  } catch (e) {\n    throw new RuntimeError(\n      `An error occurred while retrieving the EOP data from the URL ${resource.url}.`,\n    );\n  }\n\n  return new EarthOrientationParameters({\n    addNewLeapSeconds: options.addNewLeapSeconds,\n    data: eopData,\n  });\n};\n\n/**\n * A default {@link EarthOrientationParameters} instance that returns zero for all EOP values.\n */\nEarthOrientationParameters.NONE = Object.freeze({\n  compute: function (date, result) {\n    if (!defined(result)) {\n      result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);\n    } else {\n      result.xPoleWander = 0.0;\n      result.yPoleWander = 0.0;\n      result.xPoleOffset = 0.0;\n      result.yPoleOffset = 0.0;\n      result.ut1MinusUtc = 0.0;\n    }\n    return result;\n  },\n});\n\n/**\n * Computes the Earth Orientation Parameters (EOP) for a given date by interpolating.\n * If the EOP data has not yet been download, this method returns undefined.\n *\n * @param {JulianDate} date The date for each to evaluate the EOP.\n * @param {EarthOrientationParametersSample} [result] The instance to which to copy the result.\n *        If this parameter is undefined, a new instance is created and returned.\n * @returns {EarthOrientationParametersSample} The EOP evaluated at the given date, or\n *          undefined if the data necessary to evaluate EOP at the date has not yet been\n *          downloaded.\n *\n * @exception {RuntimeError} The loaded EOP data has an error and cannot be used.\n *\n * @see EarthOrientationParameters#fromUrl\n */\nEarthOrientationParameters.prototype.compute = function (date, result) {\n  // We cannot compute until the samples are available.\n  if (!defined(this._samples)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);\n  }\n\n  if (this._samples.length === 0) {\n    result.xPoleWander = 0.0;\n    result.yPoleWander = 0.0;\n    result.xPoleOffset = 0.0;\n    result.yPoleOffset = 0.0;\n    result.ut1MinusUtc = 0.0;\n    return result;\n  }\n\n  const dates = this._dates;\n  const lastIndex = this._lastIndex;\n\n  let before = 0;\n  let after = 0;\n  if (defined(lastIndex)) {\n    const previousIndexDate = dates[lastIndex];\n    const nextIndexDate = dates[lastIndex + 1];\n    const isAfterPrevious = JulianDate.lessThanOrEquals(\n      previousIndexDate,\n      date,\n    );\n    const isAfterLastSample = !defined(nextIndexDate);\n    const isBeforeNext =\n      isAfterLastSample || JulianDate.greaterThanOrEquals(nextIndexDate, date);\n\n    if (isAfterPrevious && isBeforeNext) {\n      before = lastIndex;\n\n      if (!isAfterLastSample && nextIndexDate.equals(date)) {\n        ++before;\n      }\n      after = before + 1;\n\n      interpolate(this, dates, this._samples, date, before, after, result);\n      return result;\n    }\n  }\n\n  let index = binarySearch(dates, date, JulianDate.compare, this._dateColumn);\n  if (index >= 0) {\n    // If the next entry is the same date, use the later entry.  This way, if two entries\n    // describe the same moment, one before a leap second and the other after, then we will use\n    // the post-leap second data.\n    if (index < dates.length - 1 && dates[index + 1].equals(date)) {\n      ++index;\n    }\n    before = index;\n    after = index;\n  } else {\n    after = ~index;\n    before = after - 1;\n\n    // Use the first entry if the date requested is before the beginning of the data.\n    if (before < 0) {\n      before = 0;\n    }\n  }\n\n  this._lastIndex = before;\n\n  interpolate(this, dates, this._samples, date, before, after, result);\n  return result;\n};\n\nfunction compareLeapSecondDates(leapSecond, dateToFind) {\n  return JulianDate.compare(leapSecond.julianDate, dateToFind);\n}\n\nfunction onDataReady(eop, eopData) {\n  if (!defined(eopData.columnNames)) {\n    throw new RuntimeError(\n      \"Error in loaded EOP data: The columnNames property is required.\",\n    );\n  }\n\n  if (!defined(eopData.samples)) {\n    throw new RuntimeError(\n      \"Error in loaded EOP data: The samples property is required.\",\n    );\n  }\n\n  const dateColumn = eopData.columnNames.indexOf(\"modifiedJulianDateUtc\");\n  const xPoleWanderRadiansColumn =\n    eopData.columnNames.indexOf(\"xPoleWanderRadians\");\n  const yPoleWanderRadiansColumn =\n    eopData.columnNames.indexOf(\"yPoleWanderRadians\");\n  const ut1MinusUtcSecondsColumn =\n    eopData.columnNames.indexOf(\"ut1MinusUtcSeconds\");\n  const xCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(\n    \"xCelestialPoleOffsetRadians\",\n  );\n  const yCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(\n    \"yCelestialPoleOffsetRadians\",\n  );\n  const taiMinusUtcSecondsColumn =\n    eopData.columnNames.indexOf(\"taiMinusUtcSeconds\");\n\n  if (\n    dateColumn < 0 ||\n    xPoleWanderRadiansColumn < 0 ||\n    yPoleWanderRadiansColumn < 0 ||\n    ut1MinusUtcSecondsColumn < 0 ||\n    xCelestialPoleOffsetRadiansColumn < 0 ||\n    yCelestialPoleOffsetRadiansColumn < 0 ||\n    taiMinusUtcSecondsColumn < 0\n  ) {\n    throw new RuntimeError(\n      \"Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns\",\n    );\n  }\n\n  const samples = (eop._samples = eopData.samples);\n  const dates = (eop._dates = []);\n\n  eop._dateColumn = dateColumn;\n  eop._xPoleWanderRadiansColumn = xPoleWanderRadiansColumn;\n  eop._yPoleWanderRadiansColumn = yPoleWanderRadiansColumn;\n  eop._ut1MinusUtcSecondsColumn = ut1MinusUtcSecondsColumn;\n  eop._xCelestialPoleOffsetRadiansColumn = xCelestialPoleOffsetRadiansColumn;\n  eop._yCelestialPoleOffsetRadiansColumn = yCelestialPoleOffsetRadiansColumn;\n  eop._taiMinusUtcSecondsColumn = taiMinusUtcSecondsColumn;\n\n  eop._columnCount = eopData.columnNames.length;\n  eop._lastIndex = undefined;\n\n  let lastTaiMinusUtc;\n\n  const addNewLeapSeconds = eop._addNewLeapSeconds;\n\n  // Convert the ISO8601 dates to JulianDates.\n  for (let i = 0, len = samples.length; i < len; i += eop._columnCount) {\n    const mjd = samples[i + dateColumn];\n    const taiMinusUtc = samples[i + taiMinusUtcSecondsColumn];\n    const day = mjd + TimeConstants.MODIFIED_JULIAN_DATE_DIFFERENCE;\n    const date = new JulianDate(day, taiMinusUtc, TimeStandard.TAI);\n    dates.push(date);\n\n    if (addNewLeapSeconds) {\n      if (taiMinusUtc !== lastTaiMinusUtc && defined(lastTaiMinusUtc)) {\n        // We crossed a leap second boundary, so add the leap second\n        // if it does not already exist.\n        const leapSeconds = JulianDate.leapSeconds;\n        const leapSecondIndex = binarySearch(\n          leapSeconds,\n          date,\n          compareLeapSecondDates,\n        );\n        if (leapSecondIndex < 0) {\n          const leapSecond = new LeapSecond(date, taiMinusUtc);\n          leapSeconds.splice(~leapSecondIndex, 0, leapSecond);\n        }\n      }\n      lastTaiMinusUtc = taiMinusUtc;\n    }\n  }\n}\n\nfunction fillResultFromIndex(eop, samples, index, columnCount, result) {\n  const start = index * columnCount;\n  result.xPoleWander = samples[start + eop._xPoleWanderRadiansColumn];\n  result.yPoleWander = samples[start + eop._yPoleWanderRadiansColumn];\n  result.xPoleOffset = samples[start + eop._xCelestialPoleOffsetRadiansColumn];\n  result.yPoleOffset = samples[start + eop._yCelestialPoleOffsetRadiansColumn];\n  result.ut1MinusUtc = samples[start + eop._ut1MinusUtcSecondsColumn];\n}\n\nfunction linearInterp(dx, y1, y2) {\n  return y1 + dx * (y2 - y1);\n}\n\nfunction interpolate(eop, dates, samples, date, before, after, result) {\n  const columnCount = eop._columnCount;\n\n  // First check the bounds on the EOP data\n  // If we are after the bounds of the data, return zeros.\n  // The 'before' index should never be less than zero.\n  if (after > dates.length - 1) {\n    result.xPoleWander = 0;\n    result.yPoleWander = 0;\n    result.xPoleOffset = 0;\n    result.yPoleOffset = 0;\n    result.ut1MinusUtc = 0;\n    return result;\n  }\n\n  const beforeDate = dates[before];\n  const afterDate = dates[after];\n  if (beforeDate.equals(afterDate) || date.equals(beforeDate)) {\n    fillResultFromIndex(eop, samples, before, columnCount, result);\n    return result;\n  } else if (date.equals(afterDate)) {\n    fillResultFromIndex(eop, samples, after, columnCount, result);\n    return result;\n  }\n\n  const factor =\n    JulianDate.secondsDifference(date, beforeDate) /\n    JulianDate.secondsDifference(afterDate, beforeDate);\n\n  const startBefore = before * columnCount;\n  const startAfter = after * columnCount;\n\n  // Handle UT1 leap second edge case\n  let beforeUt1MinusUtc = samples[startBefore + eop._ut1MinusUtcSecondsColumn];\n  let afterUt1MinusUtc = samples[startAfter + eop._ut1MinusUtcSecondsColumn];\n\n  const offsetDifference = afterUt1MinusUtc - beforeUt1MinusUtc;\n  if (offsetDifference > 0.5 || offsetDifference < -0.5) {\n    // The absolute difference between the values is more than 0.5, so we may have\n    // crossed a leap second.  Check if this is the case and, if so, adjust the\n    // afterValue to account for the leap second.  This way, our interpolation will\n    // produce reasonable results.\n    const beforeTaiMinusUtc =\n      samples[startBefore + eop._taiMinusUtcSecondsColumn];\n    const afterTaiMinusUtc =\n      samples[startAfter + eop._taiMinusUtcSecondsColumn];\n    if (beforeTaiMinusUtc !== afterTaiMinusUtc) {\n      if (afterDate.equals(date)) {\n        // If we are at the end of the leap second interval, take the second value\n        // Otherwise, the interpolation below will yield the wrong side of the\n        // discontinuity\n        // At the end of the leap second, we need to start accounting for the jump\n        beforeUt1MinusUtc = afterUt1MinusUtc;\n      } else {\n        // Otherwise, remove the leap second so that the interpolation is correct\n        afterUt1MinusUtc -= afterTaiMinusUtc - beforeTaiMinusUtc;\n      }\n    }\n  }\n\n  result.xPoleWander = linearInterp(\n    factor,\n    samples[startBefore + eop._xPoleWanderRadiansColumn],\n    samples[startAfter + eop._xPoleWanderRadiansColumn],\n  );\n  result.yPoleWander = linearInterp(\n    factor,\n    samples[startBefore + eop._yPoleWanderRadiansColumn],\n    samples[startAfter + eop._yPoleWanderRadiansColumn],\n  );\n  result.xPoleOffset = linearInterp(\n    factor,\n    samples[startBefore + eop._xCelestialPoleOffsetRadiansColumn],\n    samples[startAfter + eop._xCelestialPoleOffsetRadiansColumn],\n  );\n  result.yPoleOffset = linearInterp(\n    factor,\n    samples[startBefore + eop._yCelestialPoleOffsetRadiansColumn],\n    samples[startAfter + eop._yCelestialPoleOffsetRadiansColumn],\n  );\n  result.ut1MinusUtc = linearInterp(\n    factor,\n    beforeUt1MinusUtc,\n    afterUt1MinusUtc,\n  );\n  return result;\n}\n\nexport default EarthOrientationParameters;\n"],"names":["EarthOrientationParameters","options","EMPTY_OBJECT","_dates","undefined","_samples","_dateColumn","_xPoleWanderRadiansColumn","_yPoleWanderRadiansColumn","_ut1MinusUtcSecondsColumn","_xCelestialPoleOffsetRadiansColumn","_yCelestialPoleOffsetRadiansColumn","_taiMinusUtcSecondsColumn","_columnCount","_lastIndex","_addNewLeapSeconds","addNewLeapSeconds","data","onDataReady","columnNames","samples","fromUrl","url","defined","resource","createIfNeeded","eopData","fetchJson","e","NONE","Object","freeze","compute","date","result","xPoleWander","yPoleWander","xPoleOffset","yPoleOffset","ut1MinusUtc","prototype","length","dates","lastIndex","before","after","previousIndexDate","nextIndexDate","isAfterPrevious","lessThanOrEquals","isAfterLastSample","isBeforeNext","greaterThanOrEquals","equals","interpolate","index","compare","compareLeapSecondDates","leapSecond","dateToFind","julianDate","eop","dateColumn","indexOf","xPoleWanderRadiansColumn","yPoleWanderRadiansColumn","ut1MinusUtcSecondsColumn","xCelestialPoleOffsetRadiansColumn","yCelestialPoleOffsetRadiansColumn","taiMinusUtcSecondsColumn","lastTaiMinusUtc","i","len","mjd","taiMinusUtc","day","MODIFIED_JULIAN_DATE_DIFFERENCE","TAI","push","leapSeconds","leapSecondIndex","splice","fillResultFromIndex","columnCount","start","linearInterp","dx","y1","y2","beforeDate","afterDate","factor","secondsDifference","startBefore","startAfter","beforeUt1MinusUtc","afterUt1MinusUtc","offsetDifference","beforeTaiMinusUtc","afterTaiMinusUtc"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11993, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/HeadingPitchRoll.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A rotation expressed as a heading, pitch, and roll. Heading is the rotation about the\n * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about\n * the positive x axis.\n * @alias HeadingPitchRoll\n * @constructor\n *\n * @param {number} [heading=0.0] The heading component in radians.\n * @param {number} [pitch=0.0] The pitch component in radians.\n * @param {number} [roll=0.0] The roll component in radians.\n */\nfunction HeadingPitchRoll(heading, pitch, roll) {\n  /**\n   * Gets or sets the heading.\n   * @type {number}\n   * @default 0.0\n   */\n  this.heading = heading ?? 0.0;\n  /**\n   * Gets or sets the pitch.\n   * @type {number}\n   * @default 0.0\n   */\n  this.pitch = pitch ?? 0.0;\n  /**\n   * Gets or sets the roll.\n   * @type {number}\n   * @default 0.0\n   */\n  this.roll = roll ?? 0.0;\n}\n\n/**\n * Computes the heading, pitch and roll from a quaternion (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )\n *\n * @param {Quaternion} quaternion The quaternion from which to retrieve heading, pitch, and roll, all expressed in radians.\n * @param {HeadingPitchRoll} [result] The object in which to store the result. If not provided, a new instance is created and returned.\n * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided.\n */\nHeadingPitchRoll.fromQuaternion = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(quaternion)) {\n    throw new DeveloperError(\"quaternion is required\");\n  }\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    result = new HeadingPitchRoll();\n  }\n  const test = 2 * (quaternion.w * quaternion.y - quaternion.z * quaternion.x);\n  const denominatorRoll =\n    1 - 2 * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);\n  const numeratorRoll =\n    2 * (quaternion.w * quaternion.x + quaternion.y * quaternion.z);\n  const denominatorHeading =\n    1 - 2 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);\n  const numeratorHeading =\n    2 * (quaternion.w * quaternion.z + quaternion.x * quaternion.y);\n  result.heading = -Math.atan2(numeratorHeading, denominatorHeading);\n  result.roll = Math.atan2(numeratorRoll, denominatorRoll);\n  result.pitch = -CesiumMath.asinClamped(test);\n  return result;\n};\n\n/**\n * Returns a new HeadingPitchRoll instance from angles given in degrees.\n *\n * @param {number} heading the heading in degrees\n * @param {number} pitch the pitch in degrees\n * @param {number} roll the heading in degrees\n * @param {HeadingPitchRoll} [result] The object in which to store the result. If not provided, a new instance is created and returned.\n * @returns {HeadingPitchRoll} A new HeadingPitchRoll instance\n */\nHeadingPitchRoll.fromDegrees = function (heading, pitch, roll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(heading)) {\n    throw new DeveloperError(\"heading is required\");\n  }\n  if (!defined(pitch)) {\n    throw new DeveloperError(\"pitch is required\");\n  }\n  if (!defined(roll)) {\n    throw new DeveloperError(\"roll is required\");\n  }\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    result = new HeadingPitchRoll();\n  }\n  result.heading = heading * CesiumMath.RADIANS_PER_DEGREE;\n  result.pitch = pitch * CesiumMath.RADIANS_PER_DEGREE;\n  result.roll = roll * CesiumMath.RADIANS_PER_DEGREE;\n  return result;\n};\n\n/**\n * Duplicates a HeadingPitchRoll instance.\n *\n * @param {HeadingPitchRoll} headingPitchRoll The HeadingPitchRoll to duplicate.\n * @param {HeadingPitchRoll} [result] The object onto which to store the result.\n * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided. (Returns undefined if headingPitchRoll is undefined)\n */\nHeadingPitchRoll.clone = function (headingPitchRoll, result) {\n  if (!defined(headingPitchRoll)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new HeadingPitchRoll(\n      headingPitchRoll.heading,\n      headingPitchRoll.pitch,\n      headingPitchRoll.roll,\n    );\n  }\n  result.heading = headingPitchRoll.heading;\n  result.pitch = headingPitchRoll.pitch;\n  result.roll = headingPitchRoll.roll;\n  return result;\n};\n\n/**\n * Compares the provided HeadingPitchRolls componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {HeadingPitchRoll} [left] The first HeadingPitchRoll.\n * @param {HeadingPitchRoll} [right] The second HeadingPitchRoll.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nHeadingPitchRoll.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.heading === right.heading &&\n      left.pitch === right.pitch &&\n      left.roll === right.roll)\n  );\n};\n\n/**\n * Compares the provided HeadingPitchRolls componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {HeadingPitchRoll} [left] The first HeadingPitchRoll.\n * @param {HeadingPitchRoll} [right] The second HeadingPitchRoll.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nHeadingPitchRoll.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.heading,\n        right.heading,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.pitch,\n        right.pitch,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.roll,\n        right.roll,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ))\n  );\n};\n\n/**\n * Duplicates this HeadingPitchRoll instance.\n *\n * @param {HeadingPitchRoll} [result] The object onto which to store the result.\n * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided.\n */\nHeadingPitchRoll.prototype.clone = function (result) {\n  return HeadingPitchRoll.clone(this, result);\n};\n\n/**\n * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {HeadingPitchRoll} [right] The right hand side HeadingPitchRoll.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nHeadingPitchRoll.prototype.equals = function (right) {\n  return HeadingPitchRoll.equals(this, right);\n};\n\n/**\n * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {HeadingPitchRoll} [right] The right hand side HeadingPitchRoll.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nHeadingPitchRoll.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return HeadingPitchRoll.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon,\n  );\n};\n\n/**\n * Creates a string representing this HeadingPitchRoll in the format '(heading, pitch, roll)' in radians.\n *\n * @returns {string} A string representing the provided HeadingPitchRoll in the format '(heading, pitch, roll)'.\n */\nHeadingPitchRoll.prototype.toString = function () {\n  return `(${this.heading}, ${this.pitch}, ${this.roll})`;\n};\nexport default HeadingPitchRoll;\n"],"names":["HeadingPitchRoll","heading","pitch","roll","fromQuaternion","quaternion","result","test","w","y","z","x","denominatorRoll","numeratorRoll","denominatorHeading","numeratorHeading","Math","atan2","asinClamped","fromDegrees","RADIANS_PER_DEGREE","clone","headingPitchRoll","undefined","equals","left","right","equalsEpsilon","relativeEpsilon","absoluteEpsilon","prototype","toString"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12165, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/buildModuleUrl.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport getAbsoluteUri from \"./getAbsoluteUri.js\";\nimport Resource from \"./Resource.js\";\n\n/*global CESIUM_BASE_URL,define,require*/\n\nconst cesiumScriptRegex = /((?:.*\\/)|^)Cesium\\.js(?:\\?|\\#|$)/;\nfunction getBaseUrlFromCesiumScript() {\n  const scripts = document.getElementsByTagName(\"script\");\n  for (let i = 0, len = scripts.length; i < len; ++i) {\n    const src = scripts[i].getAttribute(\"src\");\n    const result = cesiumScriptRegex.exec(src);\n    if (result !== null) {\n      return result[1];\n    }\n  }\n  return undefined;\n}\n\nlet a;\nfunction tryMakeAbsolute(url) {\n  if (typeof document === \"undefined\") {\n    // Node.js and Web Workers. In both cases, the URL will already be absolute.\n    return url;\n  }\n\n  if (!defined(a)) {\n    a = document.createElement(\"a\");\n  }\n  a.href = url;\n  return a.href;\n}\n\nlet baseResource;\nfunction getCesiumBaseUrl() {\n  if (defined(baseResource)) {\n    return baseResource;\n  }\n\n  let baseUrlString;\n  if (typeof CESIUM_BASE_URL !== \"undefined\") {\n    baseUrlString = CESIUM_BASE_URL;\n  } else if (defined(import.meta?.url)) {\n    // ESM\n    baseUrlString = getAbsoluteUri(\".\", import.meta.url);\n  } else if (\n    typeof define === \"object\" &&\n    defined(define.amd) &&\n    !define.amd.toUrlUndefined &&\n    defined(require.toUrl)\n  ) {\n    // RequireJS\n    baseUrlString = getAbsoluteUri(\n      \"..\",\n      buildModuleUrl(\"Core/buildModuleUrl.js\"),\n    );\n  } else {\n    // IIFE\n    baseUrlString = getBaseUrlFromCesiumScript();\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(baseUrlString)) {\n    throw new DeveloperError(\n      \"Unable to determine Cesium base URL automatically, try defining a global variable called CESIUM_BASE_URL.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  baseResource = new Resource({\n    url: tryMakeAbsolute(baseUrlString),\n  });\n  baseResource.appendForwardSlash();\n\n  return baseResource;\n}\n\nfunction buildModuleUrlFromRequireToUrl(moduleID) {\n  //moduleID will be non-relative, so require it relative to this module, in Core.\n  return tryMakeAbsolute(require.toUrl(`../${moduleID}`));\n}\n\nfunction buildModuleUrlFromBaseUrl(moduleID) {\n  const resource = getCesiumBaseUrl().getDerivedResource({\n    url: moduleID,\n  });\n  return resource.url;\n}\n\nlet implementation;\n\n/**\n * Given a relative URL under the Cesium base URL, returns an absolute URL.\n * @function\n *\n * @param {string} relativeUrl The relative path.\n * @returns {string} The absolutely URL representation of the provided path.\n *\n * @example\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   baseLayer: Cesium.ImageryLayer.fromProviderAsync(\n *     Cesium.TileMapServiceImageryProvider.fromUrl(\n *       Cesium.buildModuleUrl(\"Assets/Textures/NaturalEarthII\"),\n *     )),\n *   baseLayerPicker: false,\n * });\n */\nfunction buildModuleUrl(relativeUrl) {\n  if (!defined(implementation)) {\n    //select implementation\n    if (\n      typeof define === \"object\" &&\n      defined(define.amd) &&\n      !define.amd.toUrlUndefined &&\n      defined(require.toUrl)\n    ) {\n      implementation = buildModuleUrlFromRequireToUrl;\n    } else {\n      implementation = buildModuleUrlFromBaseUrl;\n    }\n  }\n\n  const url = implementation(relativeUrl);\n  return url;\n}\n\n// exposed for testing\nbuildModuleUrl._cesiumScriptRegex = cesiumScriptRegex;\nbuildModuleUrl._buildModuleUrlFromBaseUrl = buildModuleUrlFromBaseUrl;\nbuildModuleUrl._clearBaseResource = function () {\n  baseResource = undefined;\n};\n\n/**\n * Sets the base URL for resolving modules.\n * @param {string} value The new base URL.\n */\nbuildModuleUrl.setBaseUrl = function (value) {\n  baseResource = Resource.DEFAULT.getDerivedResource({\n    url: value,\n  });\n};\n\n/**\n * Gets the base URL for resolving modules.\n *\n * @function\n * @returns {string} The configured base URL\n */\nbuildModuleUrl.getCesiumBaseUrl = getCesiumBaseUrl;\n\nexport default buildModuleUrl;\n"],"names":["cesiumScriptRegex","getBaseUrlFromCesiumScript","scripts","document","getElementsByTagName","i","len","length","src","getAttribute","result","exec","undefined","a","tryMakeAbsolute","url","createElement","href","baseResource","getCesiumBaseUrl","baseUrlString","CESIUM_BASE_URL","define","amd","toUrlUndefined","toUrl","buildModuleUrl","appendForwardSlash","buildModuleUrlFromRequireToUrl","moduleID","buildModuleUrlFromBaseUrl","resource","getDerivedResource","implementation","relativeUrl","_cesiumScriptRegex","_buildModuleUrlFromBaseUrl","_clearBaseResource","setBaseUrl","value","DEFAULT"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12298, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Iau2006XysSample.js"],"sourcesContent":["/**\n * An IAU 2006 XYS value sampled at a particular time.\n *\n * @alias Iau2006XysSample\n * @constructor\n *\n * @param {number} x The X value.\n * @param {number} y The Y value.\n * @param {number} s The S value.\n *\n * @private\n */\nfunction Iau2006XysSample(x, y, s) {\n  /**\n   * The X value.\n   * @type {number}\n   */\n  this.x = x;\n\n  /**\n   * The Y value.\n   * @type {number}\n   */\n  this.y = y;\n\n  /**\n   * The S value.\n   * @type {number}\n   */\n  this.s = s;\n}\nexport default Iau2006XysSample;\n"],"names":["Iau2006XysSample","x","y","s"],"mappings":";;;;AAAA;;;;;;;;;;;CAWC,GACD,SAASA,iBAAiBC,CAAC,EAAEC,CAAC,EAAEC,CAAC;IAC/B;;;GAGC,GACD,IAAI,CAACF,CAAC,GAAGA;IAET;;;GAGC,GACD,IAAI,CAACC,CAAC,GAAGA;IAET;;;GAGC,GACD,IAAI,CAACC,CAAC,GAAGA;AACX;uCACeH","ignoreList":[0]}},
    {"offset": {"line": 12332, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Iau2006XysData.js"],"sourcesContent":["import buildModuleUrl from \"./buildModuleUrl.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport Iau2006XysSample from \"./Iau2006XysSample.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport Resource from \"./Resource.js\";\nimport TimeStandard from \"./TimeStandard.js\";\n\n/**\n * A set of IAU2006 XYS data that is used to evaluate the transformation between the International\n * Celestial Reference Frame (ICRF) and the International Terrestrial Reference Frame (ITRF).\n *\n * @alias Iau2006XysData\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Resource|string} [options.xysFileUrlTemplate='Assets/IAU2006_XYS/IAU2006_XYS_{0}.json'] A template URL for obtaining the XYS data.  In the template,\n *                 `{0}` will be replaced with the file index.\n * @param {number} [options.interpolationOrder=9] The order of interpolation to perform on the XYS data.\n * @param {number} [options.sampleZeroJulianEphemerisDate=2442396.5] The Julian ephemeris date (JED) of the\n *                 first XYS sample.\n * @param {number} [options.stepSizeDays=1.0] The step size, in days, between successive XYS samples.\n * @param {number} [options.samplesPerXysFile=1000] The number of samples in each XYS file.\n * @param {number} [options.totalSamples=27426] The total number of samples in all XYS files.\n *\n * @private\n */\nfunction Iau2006XysData(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  this._xysFileUrlTemplate = Resource.createIfNeeded(\n    options.xysFileUrlTemplate,\n  );\n  this._interpolationOrder = options.interpolationOrder ?? 9;\n  this._sampleZeroJulianEphemerisDate =\n    options.sampleZeroJulianEphemerisDate ?? 2442396.5;\n  this._sampleZeroDateTT = new JulianDate(\n    this._sampleZeroJulianEphemerisDate,\n    0.0,\n    TimeStandard.TAI,\n  );\n  this._stepSizeDays = options.stepSizeDays ?? 1.0;\n  this._samplesPerXysFile = options.samplesPerXysFile ?? 1000;\n  this._totalSamples = options.totalSamples ?? 27426;\n  this._samples = new Array(this._totalSamples * 3);\n  this._chunkDownloadsInProgress = [];\n\n  const order = this._interpolationOrder;\n\n  // Compute denominators and X values for interpolation.\n  const denom = (this._denominators = new Array(order + 1));\n  const xTable = (this._xTable = new Array(order + 1));\n\n  const stepN = Math.pow(this._stepSizeDays, order);\n\n  for (let i = 0; i <= order; ++i) {\n    denom[i] = stepN;\n    xTable[i] = i * this._stepSizeDays;\n\n    for (let j = 0; j <= order; ++j) {\n      if (j !== i) {\n        denom[i] *= i - j;\n      }\n    }\n\n    denom[i] = 1.0 / denom[i];\n  }\n\n  // Allocate scratch arrays for interpolation.\n  this._work = new Array(order + 1);\n  this._coef = new Array(order + 1);\n}\n\nconst julianDateScratch = new JulianDate(0, 0.0, TimeStandard.TAI);\n\nfunction getDaysSinceEpoch(xys, dayTT, secondTT) {\n  const dateTT = julianDateScratch;\n  dateTT.dayNumber = dayTT;\n  dateTT.secondsOfDay = secondTT;\n  return JulianDate.daysDifference(dateTT, xys._sampleZeroDateTT);\n}\n\n/**\n * Preloads XYS data for a specified date range.\n *\n * @param {number} startDayTT The Julian day number of the beginning of the interval to preload, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {number} startSecondTT The seconds past noon of the beginning of the interval to preload, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {number} stopDayTT The Julian day number of the end of the interval to preload, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {number} stopSecondTT The seconds past noon of the end of the interval to preload, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @returns {Promise<void>} A promise that, when resolved, indicates that the requested interval has been\n *                    preloaded.\n */\nIau2006XysData.prototype.preload = function (\n  startDayTT,\n  startSecondTT,\n  stopDayTT,\n  stopSecondTT,\n) {\n  const startDaysSinceEpoch = getDaysSinceEpoch(\n    this,\n    startDayTT,\n    startSecondTT,\n  );\n  const stopDaysSinceEpoch = getDaysSinceEpoch(this, stopDayTT, stopSecondTT);\n\n  let startIndex =\n    (startDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) |\n    0;\n  if (startIndex < 0) {\n    startIndex = 0;\n  }\n\n  let stopIndex =\n    (stopDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) |\n    (0 + this._interpolationOrder);\n  if (stopIndex >= this._totalSamples) {\n    stopIndex = this._totalSamples - 1;\n  }\n\n  const startChunk = (startIndex / this._samplesPerXysFile) | 0;\n  const stopChunk = (stopIndex / this._samplesPerXysFile) | 0;\n\n  const promises = [];\n  for (let i = startChunk; i <= stopChunk; ++i) {\n    promises.push(requestXysChunk(this, i));\n  }\n\n  return Promise.all(promises);\n};\n\n/**\n * Computes the XYS values for a given date by interpolating.  If the required data is not yet downloaded,\n * this method will return undefined.\n *\n * @param {number} dayTT The Julian day number for which to compute the XYS value, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {number} secondTT The seconds past noon of the date for which to compute the XYS value, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {Iau2006XysSample} [result] The instance to which to copy the interpolated result.  If this parameter\n *                           is undefined, a new instance is allocated and returned.\n * @returns {Iau2006XysSample} The interpolated XYS values, or undefined if the required data for this\n *                             computation has not yet been downloaded.\n *\n * @see Iau2006XysData#preload\n */\nIau2006XysData.prototype.computeXysRadians = function (\n  dayTT,\n  secondTT,\n  result,\n) {\n  const daysSinceEpoch = getDaysSinceEpoch(this, dayTT, secondTT);\n  if (daysSinceEpoch < 0.0) {\n    // Can't evaluate prior to the epoch of the data.\n    return undefined;\n  }\n\n  const centerIndex = (daysSinceEpoch / this._stepSizeDays) | 0;\n  if (centerIndex >= this._totalSamples) {\n    // Can't evaluate after the last sample in the data.\n    return undefined;\n  }\n\n  const degree = this._interpolationOrder;\n\n  let firstIndex = centerIndex - ((degree / 2) | 0);\n  if (firstIndex < 0) {\n    firstIndex = 0;\n  }\n  let lastIndex = firstIndex + degree;\n  if (lastIndex >= this._totalSamples) {\n    lastIndex = this._totalSamples - 1;\n    firstIndex = lastIndex - degree;\n    if (firstIndex < 0) {\n      firstIndex = 0;\n    }\n  }\n\n  // Are all the samples we need present?\n  // We can assume so if the first and last are present\n  let isDataMissing = false;\n  const samples = this._samples;\n  if (!defined(samples[firstIndex * 3])) {\n    requestXysChunk(this, (firstIndex / this._samplesPerXysFile) | 0);\n    isDataMissing = true;\n  }\n\n  if (!defined(samples[lastIndex * 3])) {\n    requestXysChunk(this, (lastIndex / this._samplesPerXysFile) | 0);\n    isDataMissing = true;\n  }\n\n  if (isDataMissing) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Iau2006XysSample(0.0, 0.0, 0.0);\n  } else {\n    result.x = 0.0;\n    result.y = 0.0;\n    result.s = 0.0;\n  }\n\n  const x = daysSinceEpoch - firstIndex * this._stepSizeDays;\n\n  const work = this._work;\n  const denom = this._denominators;\n  const coef = this._coef;\n  const xTable = this._xTable;\n\n  let i, j;\n  for (i = 0; i <= degree; ++i) {\n    work[i] = x - xTable[i];\n  }\n\n  for (i = 0; i <= degree; ++i) {\n    coef[i] = 1.0;\n\n    for (j = 0; j <= degree; ++j) {\n      if (j !== i) {\n        coef[i] *= work[j];\n      }\n    }\n\n    coef[i] *= denom[i];\n\n    let sampleIndex = (firstIndex + i) * 3;\n    result.x += coef[i] * samples[sampleIndex++];\n    result.y += coef[i] * samples[sampleIndex++];\n    result.s += coef[i] * samples[sampleIndex];\n  }\n\n  return result;\n};\n\nfunction requestXysChunk(xysData, chunkIndex) {\n  if (xysData._chunkDownloadsInProgress[chunkIndex]) {\n    // Chunk has already been requested.\n    return xysData._chunkDownloadsInProgress[chunkIndex];\n  }\n\n  let chunkUrl;\n  const xysFileUrlTemplate = xysData._xysFileUrlTemplate;\n  if (defined(xysFileUrlTemplate)) {\n    chunkUrl = xysFileUrlTemplate.getDerivedResource({\n      templateValues: {\n        0: chunkIndex,\n      },\n    });\n  } else {\n    chunkUrl = new Resource({\n      url: buildModuleUrl(`Assets/IAU2006_XYS/IAU2006_XYS_${chunkIndex}.json`),\n    });\n  }\n\n  const promise = chunkUrl.fetchJson().then(function (chunk) {\n    xysData._chunkDownloadsInProgress[chunkIndex] = false;\n\n    const samples = xysData._samples;\n    const newSamples = chunk.samples;\n    const startIndex = chunkIndex * xysData._samplesPerXysFile * 3;\n\n    for (let i = 0, len = newSamples.length; i < len; ++i) {\n      samples[startIndex + i] = newSamples[i];\n    }\n  });\n  xysData._chunkDownloadsInProgress[chunkIndex] = promise;\n\n  return promise;\n}\nexport default Iau2006XysData;\n"],"names":["Iau2006XysData","options","EMPTY_OBJECT","_xysFileUrlTemplate","createIfNeeded","xysFileUrlTemplate","_interpolationOrder","interpolationOrder","_sampleZeroJulianEphemerisDate","sampleZeroJulianEphemerisDate","_sampleZeroDateTT","TAI","_stepSizeDays","stepSizeDays","_samplesPerXysFile","samplesPerXysFile","_totalSamples","totalSamples","_samples","Array","_chunkDownloadsInProgress","order","denom","_denominators","xTable","_xTable","stepN","Math","pow","i","j","_work","_coef","julianDateScratch","getDaysSinceEpoch","xys","dayTT","secondTT","dateTT","dayNumber","secondsOfDay","daysDifference","prototype","preload","startDayTT","startSecondTT","stopDayTT","stopSecondTT","startDaysSinceEpoch","stopDaysSinceEpoch","startIndex","stopIndex","startChunk","stopChunk","promises","push","requestXysChunk","Promise","all","computeXysRadians","result","daysSinceEpoch","undefined","centerIndex","degree","firstIndex","lastIndex","isDataMissing","samples","x","y","s","work","coef","sampleIndex","xysData","chunkIndex","chunkUrl","getDerivedResource","templateValues","url","promise","fetchJson","then","chunk","newSamples","len","length"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12556, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Fullscreen.js"],"sourcesContent":["import defined from \"./defined.js\";\n\nlet _supportsFullscreen;\nconst _names = {\n  requestFullscreen: undefined,\n  exitFullscreen: undefined,\n  fullscreenEnabled: undefined,\n  fullscreenElement: undefined,\n  fullscreenchange: undefined,\n  fullscreenerror: undefined,\n};\n\n/**\n * Browser-independent functions for working with the standard fullscreen API.\n *\n * @namespace Fullscreen\n *\n * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}\n */\nconst Fullscreen = {};\n\nObject.defineProperties(Fullscreen, {\n  /**\n   * The element that is currently fullscreen, if any.  To simply check if the\n   * browser is in fullscreen mode or not, use {@link Fullscreen#fullscreen}.\n   * @memberof Fullscreen\n   * @type {object}\n   * @readonly\n   */\n  element: {\n    get: function () {\n      if (!Fullscreen.supportsFullscreen()) {\n        return undefined;\n      }\n\n      return document[_names.fullscreenElement];\n    },\n  },\n\n  /**\n   * The name of the event on the document that is fired when fullscreen is\n   * entered or exited.  This event name is intended for use with addEventListener.\n   * In your event handler, to determine if the browser is in fullscreen mode or not,\n   * use {@link Fullscreen#fullscreen}.\n   * @memberof Fullscreen\n   * @type {string}\n   * @readonly\n   */\n  changeEventName: {\n    get: function () {\n      if (!Fullscreen.supportsFullscreen()) {\n        return undefined;\n      }\n\n      return _names.fullscreenchange;\n    },\n  },\n\n  /**\n   * The name of the event that is fired when a fullscreen error\n   * occurs.  This event name is intended for use with addEventListener.\n   * @memberof Fullscreen\n   * @type {string}\n   * @readonly\n   */\n  errorEventName: {\n    get: function () {\n      if (!Fullscreen.supportsFullscreen()) {\n        return undefined;\n      }\n\n      return _names.fullscreenerror;\n    },\n  },\n\n  /**\n   * Determine whether the browser will allow an element to be made fullscreen, or not.\n   * For example, by default, iframes cannot go fullscreen unless the containing page\n   * adds an \"allowfullscreen\" attribute (or prefixed equivalent).\n   * @memberof Fullscreen\n   * @type {boolean}\n   * @readonly\n   */\n  enabled: {\n    get: function () {\n      if (!Fullscreen.supportsFullscreen()) {\n        return undefined;\n      }\n\n      return document[_names.fullscreenEnabled];\n    },\n  },\n\n  /**\n   * Determines if the browser is currently in fullscreen mode.\n   * @memberof Fullscreen\n   * @type {boolean}\n   * @readonly\n   */\n  fullscreen: {\n    get: function () {\n      if (!Fullscreen.supportsFullscreen()) {\n        return undefined;\n      }\n\n      return Fullscreen.element !== null;\n    },\n  },\n});\n\n/**\n * Detects whether the browser supports the standard fullscreen API.\n *\n * @returns {boolean} <code>true</code> if the browser supports the standard fullscreen API,\n * <code>false</code> otherwise.\n */\nFullscreen.supportsFullscreen = function () {\n  if (defined(_supportsFullscreen)) {\n    return _supportsFullscreen;\n  }\n\n  _supportsFullscreen = false;\n\n  const body = document.body;\n  if (typeof body.requestFullscreen === \"function\") {\n    // go with the unprefixed, standard set of names\n    _names.requestFullscreen = \"requestFullscreen\";\n    _names.exitFullscreen = \"exitFullscreen\";\n    _names.fullscreenEnabled = \"fullscreenEnabled\";\n    _names.fullscreenElement = \"fullscreenElement\";\n    _names.fullscreenchange = \"fullscreenchange\";\n    _names.fullscreenerror = \"fullscreenerror\";\n    _supportsFullscreen = true;\n    return _supportsFullscreen;\n  }\n\n  //check for the correct combination of prefix plus the various names that browsers use\n  const prefixes = [\"webkit\", \"moz\", \"o\", \"ms\", \"khtml\"];\n  let name;\n  for (let i = 0, len = prefixes.length; i < len; ++i) {\n    const prefix = prefixes[i];\n\n    // casing of Fullscreen differs across browsers\n    name = `${prefix}RequestFullscreen`;\n    if (typeof body[name] === \"function\") {\n      _names.requestFullscreen = name;\n      _supportsFullscreen = true;\n    } else {\n      name = `${prefix}RequestFullScreen`;\n      if (typeof body[name] === \"function\") {\n        _names.requestFullscreen = name;\n        _supportsFullscreen = true;\n      }\n    }\n\n    // disagreement about whether it's \"exit\" as per spec, or \"cancel\"\n    name = `${prefix}ExitFullscreen`;\n    if (typeof document[name] === \"function\") {\n      _names.exitFullscreen = name;\n    } else {\n      name = `${prefix}CancelFullScreen`;\n      if (typeof document[name] === \"function\") {\n        _names.exitFullscreen = name;\n      }\n    }\n\n    // casing of Fullscreen differs across browsers\n    name = `${prefix}FullscreenEnabled`;\n    if (document[name] !== undefined) {\n      _names.fullscreenEnabled = name;\n    } else {\n      name = `${prefix}FullScreenEnabled`;\n      if (document[name] !== undefined) {\n        _names.fullscreenEnabled = name;\n      }\n    }\n\n    // casing of Fullscreen differs across browsers\n    name = `${prefix}FullscreenElement`;\n    if (document[name] !== undefined) {\n      _names.fullscreenElement = name;\n    } else {\n      name = `${prefix}FullScreenElement`;\n      if (document[name] !== undefined) {\n        _names.fullscreenElement = name;\n      }\n    }\n\n    // thankfully, event names are all lowercase per spec\n    name = `${prefix}fullscreenchange`;\n    // event names do not have 'on' in the front, but the property on the document does\n    if (document[`on${name}`] !== undefined) {\n      //except on IE\n      if (prefix === \"ms\") {\n        name = \"MSFullscreenChange\";\n      }\n      _names.fullscreenchange = name;\n    }\n\n    name = `${prefix}fullscreenerror`;\n    if (document[`on${name}`] !== undefined) {\n      //except on IE\n      if (prefix === \"ms\") {\n        name = \"MSFullscreenError\";\n      }\n      _names.fullscreenerror = name;\n    }\n  }\n\n  return _supportsFullscreen;\n};\n\n/**\n * Asynchronously requests the browser to enter fullscreen mode on the given element.\n * If fullscreen mode is not supported by the browser, does nothing.\n *\n * @param {object} element The HTML element which will be placed into fullscreen mode.\n * @param {object} [vrDevice] The HMDVRDevice device.\n *\n * @example\n * // Put the entire page into fullscreen.\n * Cesium.Fullscreen.requestFullscreen(document.body)\n *\n * // Place only the Cesium canvas into fullscreen.\n * Cesium.Fullscreen.requestFullscreen(scene.canvas)\n */\nFullscreen.requestFullscreen = function (element, vrDevice) {\n  if (!Fullscreen.supportsFullscreen()) {\n    return;\n  }\n\n  element[_names.requestFullscreen]({ vrDisplay: vrDevice });\n};\n\n/**\n * Asynchronously exits fullscreen mode.  If the browser is not currently\n * in fullscreen, or if fullscreen mode is not supported by the browser, does nothing.\n */\nFullscreen.exitFullscreen = function () {\n  if (!Fullscreen.supportsFullscreen()) {\n    return;\n  }\n\n  document[_names.exitFullscreen]();\n};\n\n//For unit tests\nFullscreen._names = _names;\nexport default Fullscreen;\n"],"names":["_supportsFullscreen","_names","requestFullscreen","undefined","exitFullscreen","fullscreenEnabled","fullscreenElement","fullscreenchange","fullscreenerror","Fullscreen","Object","defineProperties","element","get","supportsFullscreen","document","changeEventName","errorEventName","enabled","fullscreen","body","prefixes","name","i","len","length","prefix","vrDevice","vrDisplay"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12785, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/FeatureDetection.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Fullscreen from \"./Fullscreen.js\";\n\nlet theNavigator;\nif (typeof navigator !== \"undefined\") {\n  theNavigator = navigator;\n} else {\n  theNavigator = {};\n}\n\nfunction extractVersion(versionString) {\n  const parts = versionString.split(\".\");\n  for (let i = 0, len = parts.length; i < len; ++i) {\n    parts[i] = parseInt(parts[i], 10);\n  }\n  return parts;\n}\n\nlet isChromeResult;\nlet chromeVersionResult;\nfunction isChrome() {\n  if (!defined(isChromeResult)) {\n    isChromeResult = false;\n    // Edge contains Chrome in the user agent too\n    if (!isEdge()) {\n      const fields = / Chrome\\/([\\.0-9]+)/.exec(theNavigator.userAgent);\n      if (fields !== null) {\n        isChromeResult = true;\n        chromeVersionResult = extractVersion(fields[1]);\n      }\n    }\n  }\n\n  return isChromeResult;\n}\n\nfunction chromeVersion() {\n  return isChrome() && chromeVersionResult;\n}\n\nlet isSafariResult;\nlet safariVersionResult;\nfunction isSafari() {\n  if (!defined(isSafariResult)) {\n    isSafariResult = false;\n\n    // Chrome and Edge contain Safari in the user agent too\n    if (\n      !isChrome() &&\n      !isEdge() &&\n      / Safari\\/[\\.0-9]+/.test(theNavigator.userAgent)\n    ) {\n      const fields = / Version\\/([\\.0-9]+)/.exec(theNavigator.userAgent);\n      if (fields !== null) {\n        isSafariResult = true;\n        safariVersionResult = extractVersion(fields[1]);\n      }\n    }\n  }\n\n  return isSafariResult;\n}\n\nfunction safariVersion() {\n  return isSafari() && safariVersionResult;\n}\n\nlet isWebkitResult;\nlet webkitVersionResult;\nfunction isWebkit() {\n  if (!defined(isWebkitResult)) {\n    isWebkitResult = false;\n\n    const fields = / AppleWebKit\\/([\\.0-9]+)(\\+?)/.exec(theNavigator.userAgent);\n    if (fields !== null) {\n      isWebkitResult = true;\n      webkitVersionResult = extractVersion(fields[1]);\n      webkitVersionResult.isNightly = !!fields[2];\n    }\n  }\n\n  return isWebkitResult;\n}\n\nfunction webkitVersion() {\n  return isWebkit() && webkitVersionResult;\n}\n\nlet isInternetExplorerResult;\nlet internetExplorerVersionResult;\nfunction isInternetExplorer() {\n  if (!defined(isInternetExplorerResult)) {\n    isInternetExplorerResult = false;\n\n    let fields;\n    if (theNavigator.appName === \"Microsoft Internet Explorer\") {\n      fields = /MSIE ([0-9]{1,}[\\.0-9]{0,})/.exec(theNavigator.userAgent);\n      if (fields !== null) {\n        isInternetExplorerResult = true;\n        internetExplorerVersionResult = extractVersion(fields[1]);\n      }\n    } else if (theNavigator.appName === \"Netscape\") {\n      fields = /Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(\n        theNavigator.userAgent,\n      );\n      if (fields !== null) {\n        isInternetExplorerResult = true;\n        internetExplorerVersionResult = extractVersion(fields[1]);\n      }\n    }\n  }\n  return isInternetExplorerResult;\n}\n\nfunction internetExplorerVersion() {\n  return isInternetExplorer() && internetExplorerVersionResult;\n}\n\nlet isEdgeResult;\nlet edgeVersionResult;\nfunction isEdge() {\n  if (!defined(isEdgeResult)) {\n    isEdgeResult = false;\n    const fields = / Edg\\/([\\.0-9]+)/.exec(theNavigator.userAgent);\n    if (fields !== null) {\n      isEdgeResult = true;\n      edgeVersionResult = extractVersion(fields[1]);\n    }\n  }\n  return isEdgeResult;\n}\n\nfunction edgeVersion() {\n  return isEdge() && edgeVersionResult;\n}\n\nlet isFirefoxResult;\nlet firefoxVersionResult;\nfunction isFirefox() {\n  if (!defined(isFirefoxResult)) {\n    isFirefoxResult = false;\n\n    const fields = /Firefox\\/([\\.0-9]+)/.exec(theNavigator.userAgent);\n    if (fields !== null) {\n      isFirefoxResult = true;\n      firefoxVersionResult = extractVersion(fields[1]);\n    }\n  }\n  return isFirefoxResult;\n}\n\nlet isWindowsResult;\nfunction isWindows() {\n  if (!defined(isWindowsResult)) {\n    isWindowsResult = /Windows/i.test(theNavigator.appVersion);\n  }\n  return isWindowsResult;\n}\n\nlet isIPadOrIOSResult;\nfunction isIPadOrIOS() {\n  if (!defined(isIPadOrIOSResult)) {\n    isIPadOrIOSResult =\n      navigator.platform === \"iPhone\" ||\n      navigator.platform === \"iPod\" ||\n      navigator.platform === \"iPad\";\n  }\n\n  return isIPadOrIOSResult;\n}\n\nfunction firefoxVersion() {\n  return isFirefox() && firefoxVersionResult;\n}\n\nlet hasPointerEvents;\nfunction supportsPointerEvents() {\n  if (!defined(hasPointerEvents)) {\n    //While navigator.pointerEnabled is deprecated in the W3C specification\n    //we still need to use it if it exists in order to support browsers\n    //that rely on it, such as the Windows WebBrowser control which defines\n    //PointerEvent but sets navigator.pointerEnabled to false.\n\n    //Firefox disabled because of https://github.com/CesiumGS/cesium/issues/6372\n    hasPointerEvents =\n      !isFirefox() &&\n      typeof PointerEvent !== \"undefined\" &&\n      (!defined(theNavigator.pointerEnabled) || theNavigator.pointerEnabled);\n  }\n  return hasPointerEvents;\n}\n\nlet imageRenderingValueResult;\nlet supportsImageRenderingPixelatedResult;\nfunction supportsImageRenderingPixelated() {\n  if (!defined(supportsImageRenderingPixelatedResult)) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.setAttribute(\n      \"style\",\n      \"image-rendering: -moz-crisp-edges;\" + \"image-rendering: pixelated;\",\n    );\n    //canvas.style.imageRendering will be undefined, null or an empty string on unsupported browsers.\n    const tmp = canvas.style.imageRendering;\n    supportsImageRenderingPixelatedResult = defined(tmp) && tmp !== \"\";\n    if (supportsImageRenderingPixelatedResult) {\n      imageRenderingValueResult = tmp;\n    }\n  }\n  return supportsImageRenderingPixelatedResult;\n}\n\nfunction imageRenderingValue() {\n  return supportsImageRenderingPixelated()\n    ? imageRenderingValueResult\n    : undefined;\n}\n\nfunction supportsWebP() {\n  //>>includeStart('debug', pragmas.debug);\n  if (!supportsWebP.initialized) {\n    throw new DeveloperError(\n      \"You must call FeatureDetection.supportsWebP.initialize and wait for the promise to resolve before calling FeatureDetection.supportsWebP\",\n    );\n  }\n  //>>includeEnd('debug');\n  return supportsWebP._result;\n}\nsupportsWebP._promise = undefined;\nsupportsWebP._result = undefined;\nsupportsWebP.initialize = function () {\n  // From https://developers.google.com/speed/webp/faq#how_can_i_detect_browser_support_for_webp\n  if (defined(supportsWebP._promise)) {\n    return supportsWebP._promise;\n  }\n\n  supportsWebP._promise = new Promise((resolve) => {\n    const image = new Image();\n    image.onload = function () {\n      supportsWebP._result = image.width > 0 && image.height > 0;\n      resolve(supportsWebP._result);\n    };\n\n    image.onerror = function () {\n      supportsWebP._result = false;\n      resolve(supportsWebP._result);\n    };\n    image.src =\n      \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n  });\n\n  return supportsWebP._promise;\n};\nObject.defineProperties(supportsWebP, {\n  initialized: {\n    get: function () {\n      return defined(supportsWebP._result);\n    },\n  },\n});\n\nconst typedArrayTypes = [];\nif (typeof ArrayBuffer !== \"undefined\") {\n  typedArrayTypes.push(\n    Int8Array,\n    Uint8Array,\n    Int16Array,\n    Uint16Array,\n    Int32Array,\n    Uint32Array,\n    Float32Array,\n    Float64Array,\n  );\n\n  if (typeof Uint8ClampedArray !== \"undefined\") {\n    typedArrayTypes.push(Uint8ClampedArray);\n  }\n\n  if (typeof Uint8ClampedArray !== \"undefined\") {\n    typedArrayTypes.push(Uint8ClampedArray);\n  }\n\n  if (typeof BigInt64Array !== \"undefined\") {\n    typedArrayTypes.push(BigInt64Array);\n  }\n\n  if (typeof BigUint64Array !== \"undefined\") {\n    typedArrayTypes.push(BigUint64Array);\n  }\n}\n\n/**\n * A set of functions to detect whether the current browser supports\n * various features.\n *\n * @namespace FeatureDetection\n */\nconst FeatureDetection = {\n  isChrome: isChrome,\n  chromeVersion: chromeVersion,\n  isSafari: isSafari,\n  safariVersion: safariVersion,\n  isWebkit: isWebkit,\n  webkitVersion: webkitVersion,\n  isInternetExplorer: isInternetExplorer,\n  internetExplorerVersion: internetExplorerVersion,\n  isEdge: isEdge,\n  edgeVersion: edgeVersion,\n  isFirefox: isFirefox,\n  firefoxVersion: firefoxVersion,\n  isWindows: isWindows,\n  isIPadOrIOS: isIPadOrIOS,\n  hardwareConcurrency: theNavigator.hardwareConcurrency ?? 3,\n  supportsPointerEvents: supportsPointerEvents,\n  supportsImageRenderingPixelated: supportsImageRenderingPixelated,\n  supportsWebP: supportsWebP,\n  imageRenderingValue: imageRenderingValue,\n  typedArrayTypes: typedArrayTypes,\n};\n\n/**\n * Detects whether the current browser supports Basis Universal textures and the web assembly modules needed to transcode them.\n *\n * @param {Scene} scene\n * @returns {boolean} true if the browser supports web assembly modules and the scene supports Basis Universal textures, false if not.\n */\nFeatureDetection.supportsBasis = function (scene) {\n  return FeatureDetection.supportsWebAssembly() && scene.context.supportsBasis;\n};\n\n/**\n * Detects whether the current browser supports the full screen standard.\n *\n * @returns {boolean} true if the browser supports the full screen standard, false if not.\n *\n * @see Fullscreen\n * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}\n */\nFeatureDetection.supportsFullscreen = function () {\n  return Fullscreen.supportsFullscreen();\n};\n\n/**\n * Detects whether the current browser supports typed arrays.\n *\n * @returns {boolean} true if the browser supports typed arrays, false if not.\n *\n * @see {@link https://tc39.es/ecma262/#sec-typedarray-objects|Typed Array Specification}\n */\nFeatureDetection.supportsTypedArrays = function () {\n  return typeof ArrayBuffer !== \"undefined\";\n};\n\n/**\n * Detects whether the current browser supports BigInt64Array typed arrays.\n *\n * @returns {boolean} true if the browser supports BigInt64Array typed arrays, false if not.\n *\n * @see {@link https://tc39.es/ecma262/#sec-typedarray-objects|Typed Array Specification}\n */\nFeatureDetection.supportsBigInt64Array = function () {\n  return typeof BigInt64Array !== \"undefined\";\n};\n\n/**\n * Detects whether the current browser supports BigUint64Array typed arrays.\n *\n * @returns {boolean} true if the browser supports BigUint64Array typed arrays, false if not.\n *\n * @see {@link https://tc39.es/ecma262/#sec-typedarray-objects|Typed Array Specification}\n */\nFeatureDetection.supportsBigUint64Array = function () {\n  return typeof BigUint64Array !== \"undefined\";\n};\n\n/**\n * Detects whether the current browser supports BigInt.\n *\n * @returns {boolean} true if the browser supports BigInt, false if not.\n *\n * @see {@link https://tc39.es/ecma262/#sec-bigint-objects|BigInt Specification}\n */\nFeatureDetection.supportsBigInt = function () {\n  return typeof BigInt !== \"undefined\";\n};\n\n/**\n * Detects whether the current browser supports Web Workers.\n *\n * @returns {boolean} true if the browsers supports Web Workers, false if not.\n *\n * @see {@link http://www.w3.org/TR/workers/}\n */\nFeatureDetection.supportsWebWorkers = function () {\n  return typeof Worker !== \"undefined\";\n};\n\n/**\n * Detects whether the current browser supports Web Assembly.\n *\n * @returns {boolean} true if the browsers supports Web Assembly, false if not.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/WebAssembly}\n */\nFeatureDetection.supportsWebAssembly = function () {\n  return typeof WebAssembly !== \"undefined\";\n};\n\n/**\n * Detects whether the current browser supports a WebGL2 rendering context for the specified scene.\n *\n * @param {Scene} scene the Cesium scene specifying the rendering context\n * @returns {boolean} true if the browser supports a WebGL2 rendering context, false if not.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext|WebGL2RenderingContext}\n */\nFeatureDetection.supportsWebgl2 = function (scene) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"scene\", scene);\n  //>>includeEnd('debug');\n\n  return scene.context.webgl2;\n};\n\n/**\n * Detects whether the current browser supports ECMAScript modules in web workers.\n * @returns {boolean} true if the browser supports ECMAScript modules in web workers.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Worker|Worker}\n */\nFeatureDetection.supportsEsmWebWorkers = function () {\n  return !isFirefox() || parseInt(firefoxVersionResult) >= 114;\n};\n\nexport default FeatureDetection;\n"],"names":["theNavigator","navigator","extractVersion","versionString","parts","split","i","len","length","parseInt","isChromeResult","chromeVersionResult","isChrome","isEdge","fields","exec","userAgent","chromeVersion","isSafariResult","safariVersionResult","isSafari","test","safariVersion","isWebkitResult","webkitVersionResult","isWebkit","isNightly","webkitVersion","isInternetExplorerResult","internetExplorerVersionResult","isInternetExplorer","appName","internetExplorerVersion","isEdgeResult","edgeVersionResult","edgeVersion","isFirefoxResult","firefoxVersionResult","isFirefox","isWindowsResult","isWindows","appVersion","isIPadOrIOSResult","isIPadOrIOS","platform","firefoxVersion","hasPointerEvents","supportsPointerEvents","PointerEvent","pointerEnabled","imageRenderingValueResult","supportsImageRenderingPixelatedResult","supportsImageRenderingPixelated","canvas","document","createElement","setAttribute","tmp","style","imageRendering","imageRenderingValue","undefined","supportsWebP","initialized","_result","_promise","initialize","Promise","resolve","image","Image","onload","width","height","onerror","src","Object","defineProperties","get","typedArrayTypes","ArrayBuffer","push","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Uint8ClampedArray","BigInt64Array","BigUint64Array","FeatureDetection","hardwareConcurrency","supportsBasis","scene","supportsWebAssembly","context","supportsFullscreen","supportsTypedArrays","supportsBigInt64Array","supportsBigUint64Array","supportsBigInt","BigInt","supportsWebWorkers","Worker","WebAssembly","supportsWebgl2","defined","webgl2","supportsEsmWebWorkers"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 13142, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Quaternion.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport FeatureDetection from \"./FeatureDetection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\n\n/**\n * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.\n * @alias Quaternion\n * @constructor\n *\n * @param {number} [x=0.0] The X component.\n * @param {number} [y=0.0] The Y component.\n * @param {number} [z=0.0] The Z component.\n * @param {number} [w=0.0] The W component.\n *\n * @see PackableForInterpolation\n */\nfunction Quaternion(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = x ?? 0.0;\n\n  /**\n   * The Y component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = y ?? 0.0;\n\n  /**\n   * The Z component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.z = z ?? 0.0;\n\n  /**\n   * The W component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.w = w ?? 0.0;\n}\n\nlet fromAxisAngleScratch = new Cartesian3();\n\n/**\n * Computes a quaternion representing a rotation around an axis.\n *\n * @param {Cartesian3} axis The axis of rotation.\n * @param {number} angle The angle in radians to rotate around the axis.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.fromAxisAngle = function (axis, angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"axis\", axis);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const halfAngle = angle / 2.0;\n  const s = Math.sin(halfAngle);\n  fromAxisAngleScratch = Cartesian3.normalize(axis, fromAxisAngleScratch);\n\n  const x = fromAxisAngleScratch.x * s;\n  const y = fromAxisAngleScratch.y * s;\n  const z = fromAxisAngleScratch.z * s;\n  const w = Math.cos(halfAngle);\n  if (!defined(result)) {\n    return new Quaternion(x, y, z, w);\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\nconst fromRotationMatrixNext = [1, 2, 0];\nconst fromRotationMatrixQuat = new Array(3);\n/**\n * Computes a Quaternion from the provided Matrix3 instance.\n *\n * @param {Matrix3} matrix The rotation matrix.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n *\n * @see Matrix3.fromQuaternion\n */\nQuaternion.fromRotationMatrix = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  let root;\n  let x;\n  let y;\n  let z;\n  let w;\n\n  const m00 = matrix[Matrix3.COLUMN0ROW0];\n  const m11 = matrix[Matrix3.COLUMN1ROW1];\n  const m22 = matrix[Matrix3.COLUMN2ROW2];\n  const trace = m00 + m11 + m22;\n\n  if (trace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    root = Math.sqrt(trace + 1.0); // 2w\n    w = 0.5 * root;\n    root = 0.5 / root; // 1/(4w)\n\n    x = (matrix[Matrix3.COLUMN1ROW2] - matrix[Matrix3.COLUMN2ROW1]) * root;\n    y = (matrix[Matrix3.COLUMN2ROW0] - matrix[Matrix3.COLUMN0ROW2]) * root;\n    z = (matrix[Matrix3.COLUMN0ROW1] - matrix[Matrix3.COLUMN1ROW0]) * root;\n  } else {\n    // |w| <= 1/2\n    const next = fromRotationMatrixNext;\n\n    let i = 0;\n    if (m11 > m00) {\n      i = 1;\n    }\n    if (m22 > m00 && m22 > m11) {\n      i = 2;\n    }\n    const j = next[i];\n    const k = next[j];\n\n    root = Math.sqrt(\n      matrix[Matrix3.getElementIndex(i, i)] -\n        matrix[Matrix3.getElementIndex(j, j)] -\n        matrix[Matrix3.getElementIndex(k, k)] +\n        1.0,\n    );\n\n    const quat = fromRotationMatrixQuat;\n    quat[i] = 0.5 * root;\n    root = 0.5 / root;\n    w =\n      (matrix[Matrix3.getElementIndex(k, j)] -\n        matrix[Matrix3.getElementIndex(j, k)]) *\n      root;\n    quat[j] =\n      (matrix[Matrix3.getElementIndex(j, i)] +\n        matrix[Matrix3.getElementIndex(i, j)]) *\n      root;\n    quat[k] =\n      (matrix[Matrix3.getElementIndex(k, i)] +\n        matrix[Matrix3.getElementIndex(i, k)]) *\n      root;\n\n    x = -quat[0];\n    y = -quat[1];\n    z = -quat[2];\n  }\n\n  if (!defined(result)) {\n    return new Quaternion(x, y, z, w);\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\nconst scratchHPRQuaternion = new Quaternion();\nlet scratchHeadingQuaternion = new Quaternion();\nlet scratchPitchQuaternion = new Quaternion();\nlet scratchRollQuaternion = new Quaternion();\n\n/**\n * Computes a rotation from the given heading, pitch and roll angles. Heading is the rotation about the\n * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about\n * the positive x axis.\n *\n * @param {HeadingPitchRoll} headingPitchRoll The rotation expressed as a heading, pitch and roll.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.\n */\nQuaternion.fromHeadingPitchRoll = function (headingPitchRoll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"headingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  scratchRollQuaternion = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_X,\n    headingPitchRoll.roll,\n    scratchHPRQuaternion,\n  );\n  scratchPitchQuaternion = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Y,\n    -headingPitchRoll.pitch,\n    result,\n  );\n  result = Quaternion.multiply(\n    scratchPitchQuaternion,\n    scratchRollQuaternion,\n    scratchPitchQuaternion,\n  );\n  scratchHeadingQuaternion = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Z,\n    -headingPitchRoll.heading,\n    scratchHPRQuaternion,\n  );\n  return Quaternion.multiply(scratchHeadingQuaternion, result, result);\n};\n\nconst sampledQuaternionAxis = new Cartesian3();\nconst sampledQuaternionRotation = new Cartesian3();\nconst sampledQuaternionTempQuaternion = new Quaternion();\nconst sampledQuaternionQuaternion0 = new Quaternion();\nconst sampledQuaternionQuaternion0Conjugate = new Quaternion();\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nQuaternion.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Quaternion} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nQuaternion.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Quaternion} [result] The object into which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new Quaternion();\n  }\n  result.x = array[startingIndex];\n  result.y = array[startingIndex + 1];\n  result.z = array[startingIndex + 2];\n  result.w = array[startingIndex + 3];\n  return result;\n};\n\n/**\n * The number of elements used to store the object into an array in its interpolatable form.\n * @type {number}\n */\nQuaternion.packedInterpolationLength = 3;\n\n/**\n * Converts a packed array into a form suitable for interpolation.\n *\n * @param {number[]} packedArray The packed array.\n * @param {number} [startingIndex=0] The index of the first element to be converted.\n * @param {number} [lastIndex=packedArray.length] The index of the last element to be converted.\n * @param {number[]} [result] The object into which to store the result.\n */\nQuaternion.convertPackedArrayForInterpolation = function (\n  packedArray,\n  startingIndex,\n  lastIndex,\n  result,\n) {\n  Quaternion.unpack(\n    packedArray,\n    lastIndex * 4,\n    sampledQuaternionQuaternion0Conjugate,\n  );\n  Quaternion.conjugate(\n    sampledQuaternionQuaternion0Conjugate,\n    sampledQuaternionQuaternion0Conjugate,\n  );\n\n  for (let i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {\n    const offset = i * 3;\n    Quaternion.unpack(\n      packedArray,\n      (startingIndex + i) * 4,\n      sampledQuaternionTempQuaternion,\n    );\n\n    Quaternion.multiply(\n      sampledQuaternionTempQuaternion,\n      sampledQuaternionQuaternion0Conjugate,\n      sampledQuaternionTempQuaternion,\n    );\n\n    if (sampledQuaternionTempQuaternion.w < 0) {\n      Quaternion.negate(\n        sampledQuaternionTempQuaternion,\n        sampledQuaternionTempQuaternion,\n      );\n    }\n\n    Quaternion.computeAxis(\n      sampledQuaternionTempQuaternion,\n      sampledQuaternionAxis,\n    );\n    const angle = Quaternion.computeAngle(sampledQuaternionTempQuaternion);\n    if (!defined(result)) {\n      result = [];\n    }\n    result[offset] = sampledQuaternionAxis.x * angle;\n    result[offset + 1] = sampledQuaternionAxis.y * angle;\n    result[offset + 2] = sampledQuaternionAxis.z * angle;\n  }\n};\n\n/**\n * Retrieves an instance from a packed array converted with {@link convertPackedArrayForInterpolation}.\n *\n * @param {number[]} array The array previously packed for interpolation.\n * @param {number[]} sourceArray The original packed array.\n * @param {number} [firstIndex=0] The firstIndex used to convert the array.\n * @param {number} [lastIndex=packedArray.length] The lastIndex used to convert the array.\n * @param {Quaternion} [result] The object into which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.unpackInterpolationResult = function (\n  array,\n  sourceArray,\n  firstIndex,\n  lastIndex,\n  result,\n) {\n  if (!defined(result)) {\n    result = new Quaternion();\n  }\n  Cartesian3.fromArray(array, 0, sampledQuaternionRotation);\n  const magnitude = Cartesian3.magnitude(sampledQuaternionRotation);\n\n  Quaternion.unpack(sourceArray, lastIndex * 4, sampledQuaternionQuaternion0);\n\n  if (magnitude === 0) {\n    Quaternion.clone(Quaternion.IDENTITY, sampledQuaternionTempQuaternion);\n  } else {\n    Quaternion.fromAxisAngle(\n      sampledQuaternionRotation,\n      magnitude,\n      sampledQuaternionTempQuaternion,\n    );\n  }\n\n  return Quaternion.multiply(\n    sampledQuaternionTempQuaternion,\n    sampledQuaternionQuaternion0,\n    result,\n  );\n};\n\n/**\n * Duplicates a Quaternion instance.\n *\n * @param {Quaternion} quaternion The quaternion to duplicate.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided. (Returns undefined if quaternion is undefined)\n */\nQuaternion.clone = function (quaternion, result) {\n  if (!defined(quaternion)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Quaternion(\n      quaternion.x,\n      quaternion.y,\n      quaternion.z,\n      quaternion.w,\n    );\n  }\n\n  result.x = quaternion.x;\n  result.y = quaternion.y;\n  result.z = quaternion.z;\n  result.w = quaternion.w;\n  return result;\n};\n\n/**\n * Computes the conjugate of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.conjugate = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -quaternion.x;\n  result.y = -quaternion.y;\n  result.z = -quaternion.z;\n  result.w = quaternion.w;\n  return result;\n};\n\n/**\n * Computes magnitude squared for the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @returns {number} The magnitude squared.\n */\nQuaternion.magnitudeSquared = function (quaternion) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  return (\n    quaternion.x * quaternion.x +\n    quaternion.y * quaternion.y +\n    quaternion.z * quaternion.z +\n    quaternion.w * quaternion.w\n  );\n};\n\n/**\n * Computes magnitude for the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @returns {number} The magnitude.\n */\nQuaternion.magnitude = function (quaternion) {\n  return Math.sqrt(Quaternion.magnitudeSquared(quaternion));\n};\n\n/**\n * Computes the normalized form of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to normalize.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.normalize = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const inverseMagnitude = 1.0 / Quaternion.magnitude(quaternion);\n  const x = quaternion.x * inverseMagnitude;\n  const y = quaternion.y * inverseMagnitude;\n  const z = quaternion.z * inverseMagnitude;\n  const w = quaternion.w * inverseMagnitude;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Computes the inverse of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to normalize.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.inverse = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitudeSquared = Quaternion.magnitudeSquared(quaternion);\n  result = Quaternion.conjugate(quaternion, result);\n  return Quaternion.multiplyByScalar(result, 1.0 / magnitudeSquared, result);\n};\n\n/**\n * Computes the componentwise sum of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n\n/**\n * Negates the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to be negated.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.negate = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -quaternion.x;\n  result.y = -quaternion.y;\n  result.z = -quaternion.z;\n  result.w = -quaternion.w;\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @returns {number} The dot product.\n */\nQuaternion.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w\n  );\n};\n\n/**\n * Computes the product of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const leftX = left.x;\n  const leftY = left.y;\n  const leftZ = left.z;\n  const leftW = left.w;\n\n  const rightX = right.x;\n  const rightY = right.y;\n  const rightZ = right.z;\n  const rightW = right.w;\n\n  const x = leftW * rightX + leftX * rightW + leftY * rightZ - leftZ * rightY;\n  const y = leftW * rightY - leftX * rightZ + leftY * rightW + leftZ * rightX;\n  const z = leftW * rightZ + leftX * rightY - leftY * rightX + leftZ * rightW;\n  const w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Multiplies the provided quaternion componentwise by the provided scalar.\n *\n * @param {Quaternion} quaternion The quaternion to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.multiplyByScalar = function (quaternion, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = quaternion.x * scalar;\n  result.y = quaternion.y * scalar;\n  result.z = quaternion.z * scalar;\n  result.w = quaternion.w * scalar;\n  return result;\n};\n\n/**\n * Divides the provided quaternion componentwise by the provided scalar.\n *\n * @param {Quaternion} quaternion The quaternion to be divided.\n * @param {number} scalar The scalar to divide by.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.divideByScalar = function (quaternion, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = quaternion.x / scalar;\n  result.y = quaternion.y / scalar;\n  result.z = quaternion.z / scalar;\n  result.w = quaternion.w / scalar;\n  return result;\n};\n\n/**\n * Computes the axis of rotation of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to use.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nQuaternion.computeAxis = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const w = quaternion.w;\n  if (\n    Math.abs(w - 1.0) < CesiumMath.EPSILON6 ||\n    Math.abs(w + 1.0) < CesiumMath.EPSILON6\n  ) {\n    result.x = 1;\n    result.y = result.z = 0;\n    return result;\n  }\n\n  const scalar = 1.0 / Math.sqrt(1.0 - w * w);\n\n  result.x = quaternion.x * scalar;\n  result.y = quaternion.y * scalar;\n  result.z = quaternion.z * scalar;\n  return result;\n};\n\n/**\n * Computes the angle of rotation of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to use.\n * @returns {number} The angle of rotation.\n */\nQuaternion.computeAngle = function (quaternion) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  if (Math.abs(quaternion.w - 1.0) < CesiumMath.EPSILON6) {\n    return 0.0;\n  }\n  return 2.0 * Math.acos(quaternion.w);\n};\n\nlet lerpScratch = new Quaternion();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided quaternions.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  lerpScratch = Quaternion.multiplyByScalar(end, t, lerpScratch);\n  result = Quaternion.multiplyByScalar(start, 1.0 - t, result);\n  return Quaternion.add(lerpScratch, result, result);\n};\n\nlet slerpEndNegated = new Quaternion();\nlet slerpScaledP = new Quaternion();\nlet slerpScaledR = new Quaternion();\n/**\n * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#fastSlerp\n */\nQuaternion.slerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  let dot = Quaternion.dot(start, end);\n\n  // The angle between start must be acute. Since q and -q represent\n  // the same rotation, negate q to get the acute angle.\n  let r = end;\n  if (dot < 0.0) {\n    dot = -dot;\n    r = slerpEndNegated = Quaternion.negate(end, slerpEndNegated);\n  }\n\n  // dot > 0, as the dot product approaches 1, the angle between the\n  // quaternions vanishes. use linear interpolation.\n  if (1.0 - dot < CesiumMath.EPSILON6) {\n    return Quaternion.lerp(start, r, t, result);\n  }\n\n  const theta = Math.acos(dot);\n  slerpScaledP = Quaternion.multiplyByScalar(\n    start,\n    Math.sin((1 - t) * theta),\n    slerpScaledP,\n  );\n  slerpScaledR = Quaternion.multiplyByScalar(\n    r,\n    Math.sin(t * theta),\n    slerpScaledR,\n  );\n  result = Quaternion.add(slerpScaledP, slerpScaledR, result);\n  return Quaternion.multiplyByScalar(result, 1.0 / Math.sin(theta), result);\n};\n\n/**\n * The logarithmic quaternion function.\n *\n * @param {Quaternion} quaternion The unit quaternion.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nQuaternion.log = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const theta = CesiumMath.acosClamped(quaternion.w);\n  let thetaOverSinTheta = 0.0;\n\n  if (theta !== 0.0) {\n    thetaOverSinTheta = theta / Math.sin(theta);\n  }\n\n  return Cartesian3.multiplyByScalar(quaternion, thetaOverSinTheta, result);\n};\n\n/**\n * The exponential quaternion function.\n *\n * @param {Cartesian3} cartesian The cartesian.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.exp = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const theta = Cartesian3.magnitude(cartesian);\n  let sinThetaOverTheta = 0.0;\n\n  if (theta !== 0.0) {\n    sinThetaOverTheta = Math.sin(theta) / theta;\n  }\n\n  result.x = cartesian.x * sinThetaOverTheta;\n  result.y = cartesian.y * sinThetaOverTheta;\n  result.z = cartesian.z * sinThetaOverTheta;\n  result.w = Math.cos(theta);\n\n  return result;\n};\n\nconst squadScratchCartesian0 = new Cartesian3();\nconst squadScratchCartesian1 = new Cartesian3();\nconst squadScratchQuaternion0 = new Quaternion();\nconst squadScratchQuaternion1 = new Quaternion();\n\n/**\n * Computes an inner quadrangle point.\n * <p>This will compute quaternions that ensure a squad curve is C<sup>1</sup>.</p>\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} q2 The third quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#squad\n */\nQuaternion.computeInnerQuadrangle = function (q0, q1, q2, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"q2\", q2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const qInv = Quaternion.conjugate(q1, squadScratchQuaternion0);\n  Quaternion.multiply(qInv, q2, squadScratchQuaternion1);\n  const cart0 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian0);\n\n  Quaternion.multiply(qInv, q0, squadScratchQuaternion1);\n  const cart1 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian1);\n\n  Cartesian3.add(cart0, cart1, cart0);\n  Cartesian3.multiplyByScalar(cart0, 0.25, cart0);\n  Cartesian3.negate(cart0, cart0);\n  Quaternion.exp(cart0, squadScratchQuaternion0);\n\n  return Quaternion.multiply(q1, squadScratchQuaternion0, result);\n};\n\n/**\n * Computes the spherical quadrangle interpolation between quaternions.\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} s0 The first inner quadrangle.\n * @param {Quaternion} s1 The second inner quadrangle.\n * @param {number} t The time in [0,1] used to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n *\n * @example\n * // 1. compute the squad interpolation between two quaternions on a curve\n * const s0 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i - 1], quaternions[i], quaternions[i + 1], new Cesium.Quaternion());\n * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i], quaternions[i + 1], quaternions[i + 2], new Cesium.Quaternion());\n * const q = Cesium.Quaternion.squad(quaternions[i], quaternions[i + 1], s0, s1, t, new Cesium.Quaternion());\n *\n * // 2. compute the squad interpolation as above but where the first quaternion is a end point.\n * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[0], quaternions[1], quaternions[2], new Cesium.Quaternion());\n * const q = Cesium.Quaternion.squad(quaternions[0], quaternions[1], quaternions[0], s1, t, new Cesium.Quaternion());\n *\n * @see Quaternion#computeInnerQuadrangle\n */\nQuaternion.squad = function (q0, q1, s0, s1, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"s0\", s0);\n  Check.typeOf.object(\"s1\", s1);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const slerp0 = Quaternion.slerp(q0, q1, t, squadScratchQuaternion0);\n  const slerp1 = Quaternion.slerp(s0, s1, t, squadScratchQuaternion1);\n  return Quaternion.slerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);\n};\n\nconst fastSlerpScratchQuaternion = new Quaternion();\n// eslint-disable-next-line no-loss-of-precision\nconst opmu = 1.90110745351730037;\nconst u = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nconst v = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nconst bT = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nconst bD = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\n\nfor (let i = 0; i < 7; ++i) {\n  const s = i + 1.0;\n  const t = 2.0 * s + 1.0;\n  u[i] = 1.0 / (s * t);\n  v[i] = s / t;\n}\n\nu[7] = opmu / (8.0 * 17.0);\nv[7] = (opmu * 8.0) / 17.0;\n\n/**\n * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.\n * This implementation is faster than {@link Quaternion#slerp}, but is only accurate up to 10<sup>-6</sup>.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#slerp\n */\nQuaternion.fastSlerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  let x = Quaternion.dot(start, end);\n\n  let sign;\n  if (x >= 0) {\n    sign = 1.0;\n  } else {\n    sign = -1.0;\n    x = -x;\n  }\n\n  const xm1 = x - 1.0;\n  const d = 1.0 - t;\n  const sqrT = t * t;\n  const sqrD = d * d;\n\n  for (let i = 7; i >= 0; --i) {\n    bT[i] = (u[i] * sqrT - v[i]) * xm1;\n    bD[i] = (u[i] * sqrD - v[i]) * xm1;\n  }\n\n  const cT =\n    sign *\n    t *\n    (1.0 +\n      bT[0] *\n        (1.0 +\n          bT[1] *\n            (1.0 +\n              bT[2] *\n                (1.0 +\n                  bT[3] *\n                    (1.0 +\n                      bT[4] *\n                        (1.0 + bT[5] * (1.0 + bT[6] * (1.0 + bT[7]))))))));\n  const cD =\n    d *\n    (1.0 +\n      bD[0] *\n        (1.0 +\n          bD[1] *\n            (1.0 +\n              bD[2] *\n                (1.0 +\n                  bD[3] *\n                    (1.0 +\n                      bD[4] *\n                        (1.0 + bD[5] * (1.0 + bD[6] * (1.0 + bD[7]))))))));\n\n  const temp = Quaternion.multiplyByScalar(\n    start,\n    cD,\n    fastSlerpScratchQuaternion,\n  );\n  Quaternion.multiplyByScalar(end, cT, result);\n  return Quaternion.add(temp, result, result);\n};\n\n/**\n * Computes the spherical quadrangle interpolation between quaternions.\n * An implementation that is faster than {@link Quaternion#squad}, but less accurate.\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} s0 The first inner quadrangle.\n * @param {Quaternion} s1 The second inner quadrangle.\n * @param {number} t The time in [0,1] used to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new instance if none was provided.\n *\n * @see Quaternion#squad\n */\nQuaternion.fastSquad = function (q0, q1, s0, s1, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"s0\", s0);\n  Check.typeOf.object(\"s1\", s1);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const slerp0 = Quaternion.fastSlerp(q0, q1, t, squadScratchQuaternion0);\n  const slerp1 = Quaternion.fastSlerp(s0, s1, t, squadScratchQuaternion1);\n  return Quaternion.fastSlerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);\n};\n\n/**\n * Compares the provided quaternions componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Quaternion} [left] The first quaternion.\n * @param {Quaternion} [right] The second quaternion.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nQuaternion.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z &&\n      left.w === right.w)\n  );\n};\n\n/**\n * Compares the provided quaternions componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Quaternion} [left] The first quaternion.\n * @param {Quaternion} [right] The second quaternion.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nQuaternion.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = epsilon ?? 0;\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left.x - right.x) <= epsilon &&\n      Math.abs(left.y - right.y) <= epsilon &&\n      Math.abs(left.z - right.z) <= epsilon &&\n      Math.abs(left.w - right.w) <= epsilon)\n  );\n};\n\n/**\n * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Quaternion}\n * @constant\n */\nQuaternion.ZERO = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Quaternion}\n * @constant\n */\nQuaternion.IDENTITY = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Quaternion instance.\n *\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.prototype.clone = function (result) {\n  return Quaternion.clone(this, result);\n};\n\n/**\n * Compares this and the provided quaternion componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Quaternion} [right] The right hand side quaternion.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nQuaternion.prototype.equals = function (right) {\n  return Quaternion.equals(this, right);\n};\n\n/**\n * Compares this and the provided quaternion componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Quaternion} [right] The right hand side quaternion.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nQuaternion.prototype.equalsEpsilon = function (right, epsilon) {\n  return Quaternion.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Returns a string representing this quaternion in the format (x, y, z, w).\n *\n * @returns {string} A string representing this Quaternion.\n */\nQuaternion.prototype.toString = function () {\n  return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;\n};\nexport default Quaternion;\n"],"names":["Quaternion","x","y","z","w","fromAxisAngleScratch","fromAxisAngle","axis","angle","result","typeOf","object","number","halfAngle","s","Math","sin","normalize","cos","fromRotationMatrixNext","fromRotationMatrixQuat","Array","fromRotationMatrix","matrix","root","m00","COLUMN0ROW0","m11","COLUMN1ROW1","m22","COLUMN2ROW2","trace","sqrt","COLUMN1ROW2","COLUMN2ROW1","COLUMN2ROW0","COLUMN0ROW2","COLUMN0ROW1","COLUMN1ROW0","next","i","j","k","getElementIndex","quat","scratchHPRQuaternion","scratchHeadingQuaternion","scratchPitchQuaternion","scratchRollQuaternion","fromHeadingPitchRoll","headingPitchRoll","UNIT_X","roll","UNIT_Y","pitch","multiply","UNIT_Z","heading","sampledQuaternionAxis","sampledQuaternionRotation","sampledQuaternionTempQuaternion","sampledQuaternionQuaternion0","sampledQuaternionQuaternion0Conjugate","packedLength","pack","value","array","startingIndex","defined","unpack","packedInterpolationLength","convertPackedArrayForInterpolation","packedArray","lastIndex","conjugate","len","offset","negate","computeAxis","computeAngle","unpackInterpolationResult","sourceArray","firstIndex","fromArray","magnitude","clone","IDENTITY","quaternion","undefined","magnitudeSquared","inverseMagnitude","inverse","multiplyByScalar","add","left","right","subtract","dot","leftX","leftY","leftZ","leftW","rightX","rightY","rightZ","rightW","scalar","divideByScalar","abs","EPSILON6","acos","lerpScratch","lerp","start","end","t","slerpEndNegated","slerpScaledP","slerpScaledR","slerp","r","theta","log","acosClamped","thetaOverSinTheta","exp","cartesian","sinThetaOverTheta","squadScratchCartesian0","squadScratchCartesian1","squadScratchQuaternion0","squadScratchQuaternion1","computeInnerQuadrangle","q0","q1","q2","qInv","cart0","cart1","squad","s0","s1","slerp0","slerp1","fastSlerpScratchQuaternion","opmu","u","supportsTypedArrays","Float32Array","v","bT","bD","fastSlerp","sign","xm1","d","sqrT","sqrD","cT","cD","temp","fastSquad","equals","equalsEpsilon","epsilon","ZERO","Object","freeze","prototype","toString"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 14001, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Transforms.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EarthOrientationParameters from \"./EarthOrientationParameters.js\";\nimport EarthOrientationParametersSample from \"./EarthOrientationParametersSample.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport HeadingPitchRoll from \"./HeadingPitchRoll.js\";\nimport Iau2006XysData from \"./Iau2006XysData.js\";\nimport Iau2006XysSample from \"./Iau2006XysSample.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport TimeConstants from \"./TimeConstants.js\";\n\n/**\n * Contains functions for transforming positions to various reference frames.\n *\n * @namespace Transforms\n */\nconst Transforms = {};\n\nconst vectorProductLocalFrame = {\n  up: {\n    south: \"east\",\n    north: \"west\",\n    west: \"south\",\n    east: \"north\",\n  },\n  down: {\n    south: \"west\",\n    north: \"east\",\n    west: \"north\",\n    east: \"south\",\n  },\n  south: {\n    up: \"west\",\n    down: \"east\",\n    west: \"down\",\n    east: \"up\",\n  },\n  north: {\n    up: \"east\",\n    down: \"west\",\n    west: \"up\",\n    east: \"down\",\n  },\n  west: {\n    up: \"north\",\n    down: \"south\",\n    north: \"down\",\n    south: \"up\",\n  },\n  east: {\n    up: \"south\",\n    down: \"north\",\n    north: \"up\",\n    south: \"down\",\n  },\n};\n\nconst degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1],\n};\n\nconst localFrameToFixedFrameCache = {};\n\nconst scratchCalculateCartesian = {\n  east: new Cartesian3(),\n  north: new Cartesian3(),\n  up: new Cartesian3(),\n  west: new Cartesian3(),\n  south: new Cartesian3(),\n  down: new Cartesian3(),\n};\nlet scratchFirstCartesian = new Cartesian3();\nlet scratchSecondCartesian = new Cartesian3();\nlet scratchThirdCartesian = new Cartesian3();\n/**\n * Generates a function that computes a 4x4 transformation matrix from a reference frame\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * @param  {string} firstAxis  name of the first axis of the local reference frame. Must be\n *  'east', 'north', 'up', 'west', 'south' or 'down'.\n * @param  {string} secondAxis  name of the second axis of the local reference frame. Must be\n *  'east', 'north', 'up', 'west', 'south' or 'down'.\n * @return {Transforms.LocalFrameToFixedFrame} The function that will computes a\n * 4x4 transformation matrix from a reference frame, with first axis and second axis compliant with the parameters,\n */\nTransforms.localFrameToFixedFrameGenerator = function (firstAxis, secondAxis) {\n  if (\n    !vectorProductLocalFrame.hasOwnProperty(firstAxis) ||\n    !vectorProductLocalFrame[firstAxis].hasOwnProperty(secondAxis)\n  ) {\n    throw new DeveloperError(\n      \"firstAxis and secondAxis must be east, north, up, west, south or down.\",\n    );\n  }\n  const thirdAxis = vectorProductLocalFrame[firstAxis][secondAxis];\n\n  /**\n   * Computes a 4x4 transformation matrix from a reference frame\n   * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n   * @callback Transforms.LocalFrameToFixedFrame\n   * @param {Cartesian3} origin The center point of the local reference frame.\n   * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n   * @param {Matrix4} [result] The object onto which to store the result.\n   * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n   */\n  let resultat;\n  const hashAxis = firstAxis + secondAxis;\n  if (defined(localFrameToFixedFrameCache[hashAxis])) {\n    resultat = localFrameToFixedFrameCache[hashAxis];\n  } else {\n    resultat = function (origin, ellipsoid, result) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(origin)) {\n        throw new DeveloperError(\"origin is required.\");\n      }\n      if (isNaN(origin.x) || isNaN(origin.y) || isNaN(origin.z)) {\n        throw new DeveloperError(\"origin has a NaN component\");\n      }\n      //>>includeEnd('debug');\n      if (!defined(result)) {\n        result = new Matrix4();\n      }\n      if (\n        Cartesian3.equalsEpsilon(origin, Cartesian3.ZERO, CesiumMath.EPSILON14)\n      ) {\n        // If x, y, and z are zero, use the degenerate local frame, which is a special case\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[firstAxis],\n          0,\n          scratchFirstCartesian,\n        );\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[secondAxis],\n          0,\n          scratchSecondCartesian,\n        );\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[thirdAxis],\n          0,\n          scratchThirdCartesian,\n        );\n      } else if (\n        CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) &&\n        CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)\n      ) {\n        // If x and y are zero, assume origin is at a pole, which is a special case.\n        const sign = CesiumMath.sign(origin.z);\n\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[firstAxis],\n          0,\n          scratchFirstCartesian,\n        );\n        if (firstAxis !== \"east\" && firstAxis !== \"west\") {\n          Cartesian3.multiplyByScalar(\n            scratchFirstCartesian,\n            sign,\n            scratchFirstCartesian,\n          );\n        }\n\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[secondAxis],\n          0,\n          scratchSecondCartesian,\n        );\n        if (secondAxis !== \"east\" && secondAxis !== \"west\") {\n          Cartesian3.multiplyByScalar(\n            scratchSecondCartesian,\n            sign,\n            scratchSecondCartesian,\n          );\n        }\n\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[thirdAxis],\n          0,\n          scratchThirdCartesian,\n        );\n        if (thirdAxis !== \"east\" && thirdAxis !== \"west\") {\n          Cartesian3.multiplyByScalar(\n            scratchThirdCartesian,\n            sign,\n            scratchThirdCartesian,\n          );\n        }\n      } else {\n        ellipsoid = ellipsoid ?? Ellipsoid.default;\n        ellipsoid.geodeticSurfaceNormal(origin, scratchCalculateCartesian.up);\n\n        const up = scratchCalculateCartesian.up;\n        const east = scratchCalculateCartesian.east;\n        east.x = -origin.y;\n        east.y = origin.x;\n        east.z = 0.0;\n        Cartesian3.normalize(east, scratchCalculateCartesian.east);\n        Cartesian3.cross(up, east, scratchCalculateCartesian.north);\n\n        Cartesian3.multiplyByScalar(\n          scratchCalculateCartesian.up,\n          -1,\n          scratchCalculateCartesian.down,\n        );\n        Cartesian3.multiplyByScalar(\n          scratchCalculateCartesian.east,\n          -1,\n          scratchCalculateCartesian.west,\n        );\n        Cartesian3.multiplyByScalar(\n          scratchCalculateCartesian.north,\n          -1,\n          scratchCalculateCartesian.south,\n        );\n\n        scratchFirstCartesian = scratchCalculateCartesian[firstAxis];\n        scratchSecondCartesian = scratchCalculateCartesian[secondAxis];\n        scratchThirdCartesian = scratchCalculateCartesian[thirdAxis];\n      }\n      result[0] = scratchFirstCartesian.x;\n      result[1] = scratchFirstCartesian.y;\n      result[2] = scratchFirstCartesian.z;\n      result[3] = 0.0;\n      result[4] = scratchSecondCartesian.x;\n      result[5] = scratchSecondCartesian.y;\n      result[6] = scratchSecondCartesian.z;\n      result[7] = 0.0;\n      result[8] = scratchThirdCartesian.x;\n      result[9] = scratchThirdCartesian.y;\n      result[10] = scratchThirdCartesian.z;\n      result[11] = 0.0;\n      result[12] = origin.x;\n      result[13] = origin.y;\n      result[14] = origin.z;\n      result[15] = 1.0;\n      return result;\n    };\n    localFrameToFixedFrameCache[hashAxis] = resultat;\n  }\n  return resultat;\n};\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local east direction.</li>\n * <li>The <code>y</code> axis points in the local north direction.</li>\n * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n */\nTransforms.eastNorthUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  \"east\",\n  \"north\",\n);\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the local east direction.</li>\n * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northEastDownToFixedFrame(center);\n */\nTransforms.northEastDownToFixedFrame =\n  Transforms.localFrameToFixedFrameGenerator(\"north\", \"east\");\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * <li>The <code>z</code> axis points in the local east direction.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-up-east at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northUpEastToFixedFrame(center);\n */\nTransforms.northUpEastToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  \"north\",\n  \"up\",\n);\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-west-up axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the local west direction.</li>\n * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-West-Up at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northWestUpToFixedFrame(center);\n */\nTransforms.northWestUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  \"north\",\n  \"west\",\n);\n\nconst scratchHPRQuaternion = new Quaternion();\nconst scratchScale = new Cartesian3(1.0, 1.0, 1.0);\nconst scratchHPRMatrix4 = new Matrix4();\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles\n * centered at the provided origin to the provided ellipsoid's fixed reference frame. Heading is the rotation from the local east\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const heading = -Cesium.Math.PI_OVER_TWO;\n * const pitch = Cesium.Math.PI_OVER_FOUR;\n * const roll = 0.0;\n * const hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);\n * const transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, hpr);\n */\nTransforms.headingPitchRollToFixedFrame = function (\n  origin,\n  headingPitchRoll,\n  ellipsoid,\n  fixedFrameTransform,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"HeadingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  fixedFrameTransform =\n    fixedFrameTransform ?? Transforms.eastNorthUpToFixedFrame;\n  const hprQuaternion = Quaternion.fromHeadingPitchRoll(\n    headingPitchRoll,\n    scratchHPRQuaternion,\n  );\n  const hprMatrix = Matrix4.fromTranslationQuaternionRotationScale(\n    Cartesian3.ZERO,\n    hprQuaternion,\n    scratchScale,\n    scratchHPRMatrix4,\n  );\n  result = fixedFrameTransform(origin, ellipsoid, result);\n  return Matrix4.multiply(result, hprMatrix, result);\n};\n\nconst scratchENUMatrix4 = new Matrix4();\nconst scratchHPRMatrix3 = new Matrix3();\n\n/**\n * Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles\n * centered at the provided origin. Heading is the rotation from the local east\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.\n *\n * @example\n * // Get the quaternion from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const heading = -Cesium.Math.PI_OVER_TWO;\n * const pitch = Cesium.Math.PI_OVER_FOUR;\n * const roll = 0.0;\n * const hpr = new HeadingPitchRoll(heading, pitch, roll);\n * const quaternion = Cesium.Transforms.headingPitchRollQuaternion(center, hpr);\n */\nTransforms.headingPitchRollQuaternion = function (\n  origin,\n  headingPitchRoll,\n  ellipsoid,\n  fixedFrameTransform,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"HeadingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  const transform = Transforms.headingPitchRollToFixedFrame(\n    origin,\n    headingPitchRoll,\n    ellipsoid,\n    fixedFrameTransform,\n    scratchENUMatrix4,\n  );\n  const rotation = Matrix4.getMatrix3(transform, scratchHPRMatrix3);\n  return Quaternion.fromRotationMatrix(rotation, result);\n};\n\nconst noScale = new Cartesian3(1.0, 1.0, 1.0);\nconst hprCenterScratch = new Cartesian3();\nconst ffScratch = new Matrix4();\nconst hprTransformScratch = new Matrix4();\nconst hprRotationScratch = new Matrix3();\nconst hprQuaternionScratch = new Quaternion();\n/**\n * Computes heading-pitch-roll angles from a transform in a particular reference frame. Heading is the rotation from the local east\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Matrix4} transform The transform\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {HeadingPitchRoll} [result] The object onto which to store the result.\n * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if none was provided.\n */\nTransforms.fixedFrameToHeadingPitchRoll = function (\n  transform,\n  ellipsoid,\n  fixedFrameTransform,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n  fixedFrameTransform =\n    fixedFrameTransform ?? Transforms.eastNorthUpToFixedFrame;\n  if (!defined(result)) {\n    result = new HeadingPitchRoll();\n  }\n\n  const center = Matrix4.getTranslation(transform, hprCenterScratch);\n  if (Cartesian3.equals(center, Cartesian3.ZERO)) {\n    result.heading = 0;\n    result.pitch = 0;\n    result.roll = 0;\n    return result;\n  }\n  let toFixedFrame = Matrix4.inverseTransformation(\n    fixedFrameTransform(center, ellipsoid, ffScratch),\n    ffScratch,\n  );\n  let transformCopy = Matrix4.setScale(transform, noScale, hprTransformScratch);\n  transformCopy = Matrix4.setTranslation(\n    transformCopy,\n    Cartesian3.ZERO,\n    transformCopy,\n  );\n\n  toFixedFrame = Matrix4.multiply(toFixedFrame, transformCopy, toFixedFrame);\n  let quaternionRotation = Quaternion.fromRotationMatrix(\n    Matrix4.getMatrix3(toFixedFrame, hprRotationScratch),\n    hprQuaternionScratch,\n  );\n  quaternionRotation = Quaternion.normalize(\n    quaternionRotation,\n    quaternionRotation,\n  );\n\n  return HeadingPitchRoll.fromQuaternion(quaternionRotation, result);\n};\n\nconst gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;\nconst gmstConstant1 = 8640184.812866;\nconst gmstConstant2 = 0.093104;\nconst gmstConstant3 = -6.2e-6;\nconst rateCoef = 1.1772758384668e-19;\nconst wgs84WRPrecessing = 7.2921158553e-5;\nconst twoPiOverSecondsInDay = CesiumMath.TWO_PI / 86400.0;\nlet dateInUtc = new JulianDate();\n\n/**\n * The default function to compute a rotation matrix to transform a point or vector from the International Celestial\n * Reference Frame (GCRF/ICRF) inertial frame axes to the central body, typically Earth, fixed frame axis at a given\n * time for use in lighting and transformation from inertial reference frames. This function may return undefined if\n * the data necessary to do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3|undefined} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n * @example\n * // Set the default ICRF to fixed transformation to that of the Moon.\n * Cesium.Transforms.computeIcrfToCentralBodyFixedMatrix = Cesium.Transforms.computeIcrfToMoonFixedMatrix;\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeTemeToPseudoFixedMatrix\n * @see Transforms.computeIcrfToMoonFixedMatrix\n */\nTransforms.computeIcrfToCentralBodyFixedMatrix = function (date, result) {\n  let transformMatrix = Transforms.computeIcrfToFixedMatrix(date, result);\n  if (!defined(transformMatrix)) {\n    transformMatrix = Transforms.computeTemeToPseudoFixedMatrix(date, result);\n  }\n\n  return transformMatrix;\n};\n\n/**\n * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the\n * pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.\n *\n * @example\n * //Set the view to the inertial frame.\n * scene.postUpdate.addEventListener(function(scene, time) {\n *    const now = Cesium.JulianDate.now();\n *    const offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());\n *    const transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Transforms.computeTemeToPseudoFixedMatrix(now));\n *    const inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());\n *    Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);\n *    camera.lookAtTransform(transform, offset);\n * });\n */\nTransforms.computeTemeToPseudoFixedMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // GMST is actually computed using UT1.  We're using UTC as an approximation of UT1.\n  // We do not want to use the function like convertTaiToUtc in JulianDate because\n  // we explicitly do not want to fail when inside the leap second.\n\n  dateInUtc = JulianDate.addSeconds(\n    date,\n    -JulianDate.computeTaiMinusUtc(date),\n    dateInUtc,\n  );\n  const utcDayNumber = dateInUtc.dayNumber;\n  const utcSecondsIntoDay = dateInUtc.secondsOfDay;\n\n  let t;\n  const diffDays = utcDayNumber - 2451545;\n  if (utcSecondsIntoDay >= 43200.0) {\n    t = (diffDays + 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;\n  } else {\n    t = (diffDays - 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;\n  }\n\n  const gmst0 =\n    gmstConstant0 +\n    t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));\n  const angle = (gmst0 * twoPiOverSecondsInDay) % CesiumMath.TWO_PI;\n  const ratio = wgs84WRPrecessing + rateCoef * (utcDayNumber - 2451545.5);\n  const secondsSinceMidnight =\n    (utcSecondsIntoDay + TimeConstants.SECONDS_PER_DAY * 0.5) %\n    TimeConstants.SECONDS_PER_DAY;\n  const gha = angle + ratio * secondsSinceMidnight;\n  const cosGha = Math.cos(gha);\n  const sinGha = Math.sin(gha);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      cosGha,\n      sinGha,\n      0.0,\n      -sinGha,\n      cosGha,\n      0.0,\n      0.0,\n      0.0,\n      1.0,\n    );\n  }\n  result[0] = cosGha;\n  result[1] = -sinGha;\n  result[2] = 0.0;\n  result[3] = sinGha;\n  result[4] = cosGha;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 1.0;\n  return result;\n};\n\n/**\n * The source of IAU 2006 XYS data, used for computing the transformation between the\n * Fixed and ICRF axes.\n * @type {Iau2006XysData}\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n *\n * @private\n */\nTransforms.iau2006XysData = new Iau2006XysData();\n\n/**\n * The source of Earth Orientation Parameters (EOP) data, used for computing the transformation\n * between the Fixed and ICRF axes.  By default, zero values are used for all EOP values,\n * yielding a reasonable but not completely accurate representation of the ICRF axes.\n * @type {EarthOrientationParameters}\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n *\n * @private\n */\nTransforms.earthOrientationParameters = EarthOrientationParameters.NONE;\n\nconst ttMinusTai = 32.184;\nconst j2000ttDays = 2451545.0;\n\n/**\n * Preloads the data necessary to transform between the ICRF and Fixed axes, in either\n * direction, over a given interval.  This function returns a promise that, when resolved,\n * indicates that the preload has completed.\n *\n * @param {TimeInterval} timeInterval The interval to preload.\n * @returns {Promise<void>} A promise that, when resolved, indicates that the preload has completed\n *          and evaluation of the transformation between the fixed and ICRF axes will\n *          no longer return undefined for a time inside the interval.\n *\n *\n * @example\n * const interval = new Cesium.TimeInterval(...);\n * await Cesium.Transforms.preloadIcrfFixed(interval));\n * // the data is now loaded\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n */\nTransforms.preloadIcrfFixed = function (timeInterval) {\n  const startDayTT = timeInterval.start.dayNumber;\n  const startSecondTT = timeInterval.start.secondsOfDay + ttMinusTai;\n  const stopDayTT = timeInterval.stop.dayNumber;\n  const stopSecondTT = timeInterval.stop.secondsOfDay + ttMinusTai;\n\n  return Transforms.iau2006XysData.preload(\n    startDayTT,\n    startSecondTT,\n    stopDayTT,\n    stopSecondTT,\n  );\n};\n\n/**\n * Computes a rotation matrix to transform a point or vector from the International Celestial\n * Reference Frame (GCRF/ICRF) inertial frame axes to the Earth-Fixed frame axes (ITRF)\n * at a given time.  This function may return undefined if the data necessary to\n * do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3|undefined} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n *\n * @example\n * scene.postUpdate.addEventListener(function(scene, time) {\n *   // View in ICRF.\n *   const icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);\n *   if (Cesium.defined(icrfToFixed)) {\n *     const offset = Cesium.Cartesian3.clone(camera.position);\n *     const transform = Cesium.Matrix4.fromRotationTranslation(icrfToFixed);\n *     camera.lookAtTransform(transform, offset);\n *   }\n * });\n *\n * @see Transforms.preloadIcrfFixed\n */\nTransforms.computeIcrfToFixedMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  const fixedToIcrfMtx = Transforms.computeFixedToIcrfMatrix(date, result);\n  if (!defined(fixedToIcrfMtx)) {\n    return undefined;\n  }\n\n  return Matrix3.transpose(fixedToIcrfMtx, result);\n};\n\nconst TdtMinusTai = 32.184;\nconst J2000d = 2451545;\nconst scratchHpr = new HeadingPitchRoll();\nconst scratchRotationMatrix = new Matrix3();\nconst dateScratch = new JulianDate();\n\n/**\n * Computes a rotation matrix to transform a point or vector from the Moon-Fixed frame axes\n * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes\n * at a given time.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3} The rotation matrix.\n *\n * @example\n * // Transform a point from the Fixed axes to the ICRF axes.\n * const now = Cesium.JulianDate.now();\n * const pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const fixedToIcrf = Cesium.Transforms.computeMoonFixedToIcrfMatrix(now);\n * let pointInInertial = new Cesium.Cartesian3();\n * if (Cesium.defined(fixedToIcrf)) {\n *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);\n * }\n */\nTransforms.computeMoonFixedToIcrfMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  // Converts TAI to TT\n  const secondsTT = JulianDate.addSeconds(date, TdtMinusTai, dateScratch);\n\n  // Converts TT to TDB, interval in days since the standard epoch\n  const d = JulianDate.totalDays(secondsTT) - J2000d;\n\n  // Compute the approximate rotation, using https://articles.adsabs.harvard.edu//full/1980CeMec..22..205D/0000209.000.html\n  const e1 = CesiumMath.toRadians(12.112) - CesiumMath.toRadians(0.052992) * d;\n  const e2 = CesiumMath.toRadians(24.224) - CesiumMath.toRadians(0.105984) * d;\n  const e3 = CesiumMath.toRadians(227.645) + CesiumMath.toRadians(13.012) * d;\n  const e4 =\n    CesiumMath.toRadians(261.105) + CesiumMath.toRadians(13.340716) * d;\n  const e5 = CesiumMath.toRadians(358.0) + CesiumMath.toRadians(0.9856) * d;\n\n  scratchHpr.pitch =\n    CesiumMath.toRadians(270.0 - 90) -\n    CesiumMath.toRadians(3.878) * Math.sin(e1) -\n    CesiumMath.toRadians(0.12) * Math.sin(e2) +\n    CesiumMath.toRadians(0.07) * Math.sin(e3) -\n    CesiumMath.toRadians(0.017) * Math.sin(e4);\n  scratchHpr.roll =\n    CesiumMath.toRadians(66.53 - 90) +\n    CesiumMath.toRadians(1.543) * Math.cos(e1) +\n    CesiumMath.toRadians(0.24) * Math.cos(e2) -\n    CesiumMath.toRadians(0.028) * Math.cos(e3) +\n    CesiumMath.toRadians(0.007) * Math.cos(e4);\n  scratchHpr.heading =\n    CesiumMath.toRadians(244.375 - 90) +\n    CesiumMath.toRadians(13.17635831) * d +\n    CesiumMath.toRadians(3.558) * Math.sin(e1) +\n    CesiumMath.toRadians(0.121) * Math.sin(e2) -\n    CesiumMath.toRadians(0.064) * Math.sin(e3) +\n    CesiumMath.toRadians(0.016) * Math.sin(e4) +\n    CesiumMath.toRadians(0.025) * Math.sin(e5);\n  return Matrix3.fromHeadingPitchRoll(scratchHpr, scratchRotationMatrix);\n};\n\n/**\n * Computes a rotation matrix to transform a point or vector from the International Celestial\n * Reference Frame (GCRF/ICRF) inertial frame axes to the Moon-Fixed frame axes\n * at a given time.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3} The rotation matrix.\n *\n * @example\n * // Set the default ICRF to fixed transformation to that of the Moon.\n * Cesium.Transforms.computeIcrfToCentralBodyFixedMatrix = Cesium.Transforms.computeIcrfToMoonFixedMatrix;\n */\nTransforms.computeIcrfToMoonFixedMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  const fixedToIcrfMtx = Transforms.computeMoonFixedToIcrfMatrix(date, result);\n  if (!defined(fixedToIcrfMtx)) {\n    return undefined;\n  }\n\n  return Matrix3.transpose(fixedToIcrfMtx, result);\n};\n\nconst xysScratch = new Iau2006XysSample(0.0, 0.0, 0.0);\nconst eopScratch = new EarthOrientationParametersSample(\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n);\nconst rotation1Scratch = new Matrix3();\nconst rotation2Scratch = new Matrix3();\n\n/**\n * Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)\n * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes\n * at a given time.  This function may return undefined if the data necessary to\n * do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3|undefined} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n *\n * @example\n * // Transform a point from the Fixed axes to the ICRF axes.\n * const now = Cesium.JulianDate.now();\n * const pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const fixedToIcrf = Cesium.Transforms.computeFixedToIcrfMatrix(now);\n * let pointInInertial = new Cesium.Cartesian3();\n * if (Cesium.defined(fixedToIcrf)) {\n *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);\n * }\n *\n * @see Transforms.preloadIcrfFixed\n */\nTransforms.computeFixedToIcrfMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  // Compute pole wander\n  const eop = Transforms.earthOrientationParameters.compute(date, eopScratch);\n  if (!defined(eop)) {\n    return undefined;\n  }\n\n  // There is no external conversion to Terrestrial Time (TT).\n  // So use International Atomic Time (TAI) and convert using offsets.\n  // Here we are assuming that dayTT and secondTT are positive\n  const dayTT = date.dayNumber;\n  // It's possible here that secondTT could roll over 86400\n  // This does not seem to affect the precision (unit tests check for this)\n  const secondTT = date.secondsOfDay + ttMinusTai;\n\n  const xys = Transforms.iau2006XysData.computeXysRadians(\n    dayTT,\n    secondTT,\n    xysScratch,\n  );\n  if (!defined(xys)) {\n    return undefined;\n  }\n\n  const x = xys.x + eop.xPoleOffset;\n  const y = xys.y + eop.yPoleOffset;\n\n  // Compute XYS rotation\n  const a = 1.0 / (1.0 + Math.sqrt(1.0 - x * x - y * y));\n\n  const rotation1 = rotation1Scratch;\n  rotation1[0] = 1.0 - a * x * x;\n  rotation1[3] = -a * x * y;\n  rotation1[6] = x;\n  rotation1[1] = -a * x * y;\n  rotation1[4] = 1 - a * y * y;\n  rotation1[7] = y;\n  rotation1[2] = -x;\n  rotation1[5] = -y;\n  rotation1[8] = 1 - a * (x * x + y * y);\n\n  const rotation2 = Matrix3.fromRotationZ(-xys.s, rotation2Scratch);\n  const matrixQ = Matrix3.multiply(rotation1, rotation2, rotation1Scratch);\n\n  // Similar to TT conversions above\n  // It's possible here that secondTT could roll over 86400\n  // This does not seem to affect the precision (unit tests check for this)\n  const dateUt1day = date.dayNumber;\n  const dateUt1sec =\n    date.secondsOfDay - JulianDate.computeTaiMinusUtc(date) + eop.ut1MinusUtc;\n\n  // Compute Earth rotation angle\n  // The IERS standard for era is\n  //    era = 0.7790572732640 + 1.00273781191135448 * Tu\n  // where\n  //    Tu = JulianDateInUt1 - 2451545.0\n  // However, you get much more precision if you make the following simplification\n  //    era = a + (1 + b) * (JulianDayNumber + FractionOfDay - 2451545)\n  //    era = a + (JulianDayNumber - 2451545) + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)\n  //    era = a + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)\n  // since (JulianDayNumber - 2451545) represents an integer number of revolutions which will be discarded anyway.\n  const daysSinceJ2000 = dateUt1day - 2451545;\n  const fractionOfDay = dateUt1sec / TimeConstants.SECONDS_PER_DAY;\n  let era =\n    0.779057273264 +\n    fractionOfDay +\n    0.00273781191135448 * (daysSinceJ2000 + fractionOfDay);\n  era = (era % 1.0) * CesiumMath.TWO_PI;\n\n  const earthRotation = Matrix3.fromRotationZ(era, rotation2Scratch);\n\n  // pseudoFixed to ICRF\n  const pfToIcrf = Matrix3.multiply(matrixQ, earthRotation, rotation1Scratch);\n\n  // Compute pole wander matrix\n  const cosxp = Math.cos(eop.xPoleWander);\n  const cosyp = Math.cos(eop.yPoleWander);\n  const sinxp = Math.sin(eop.xPoleWander);\n  const sinyp = Math.sin(eop.yPoleWander);\n\n  let ttt = dayTT - j2000ttDays + secondTT / TimeConstants.SECONDS_PER_DAY;\n  ttt /= 36525.0;\n\n  // approximate sp value in rad\n  const sp = (-47.0e-6 * ttt * CesiumMath.RADIANS_PER_DEGREE) / 3600.0;\n  const cossp = Math.cos(sp);\n  const sinsp = Math.sin(sp);\n\n  const fToPfMtx = rotation2Scratch;\n  fToPfMtx[0] = cosxp * cossp;\n  fToPfMtx[1] = cosxp * sinsp;\n  fToPfMtx[2] = sinxp;\n  fToPfMtx[3] = -cosyp * sinsp + sinyp * sinxp * cossp;\n  fToPfMtx[4] = cosyp * cossp + sinyp * sinxp * sinsp;\n  fToPfMtx[5] = -sinyp * cosxp;\n  fToPfMtx[6] = -sinyp * sinsp - cosyp * sinxp * cossp;\n  fToPfMtx[7] = sinyp * cossp - cosyp * sinxp * sinsp;\n  fToPfMtx[8] = cosyp * cosxp;\n\n  return Matrix3.multiply(pfToIcrf, fToPfMtx, result);\n};\n\nconst pointToWindowCoordinatesTemp = new Cartesian4();\n\n/**\n * Transform a point from model coordinates to window coordinates.\n *\n * @param {Matrix4} modelViewProjectionMatrix The 4x4 model-view-projection matrix.\n * @param {Matrix4} viewportTransformation The 4x4 viewport transformation.\n * @param {Cartesian3} point The point to transform.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n */\nTransforms.pointToWindowCoordinates = function (\n  modelViewProjectionMatrix,\n  viewportTransformation,\n  point,\n  result,\n) {\n  result = Transforms.pointToGLWindowCoordinates(\n    modelViewProjectionMatrix,\n    viewportTransformation,\n    point,\n    result,\n  );\n  result.y = 2.0 * viewportTransformation[5] - result.y;\n  return result;\n};\n\n/**\n * @private\n */\nTransforms.pointToGLWindowCoordinates = function (\n  modelViewProjectionMatrix,\n  viewportTransformation,\n  point,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(modelViewProjectionMatrix)) {\n    throw new DeveloperError(\"modelViewProjectionMatrix is required.\");\n  }\n\n  if (!defined(viewportTransformation)) {\n    throw new DeveloperError(\"viewportTransformation is required.\");\n  }\n\n  if (!defined(point)) {\n    throw new DeveloperError(\"point is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  const tmp = pointToWindowCoordinatesTemp;\n\n  Matrix4.multiplyByVector(\n    modelViewProjectionMatrix,\n    Cartesian4.fromElements(point.x, point.y, point.z, 1, tmp),\n    tmp,\n  );\n  Cartesian4.multiplyByScalar(tmp, 1.0 / tmp.w, tmp);\n  Matrix4.multiplyByVector(viewportTransformation, tmp, tmp);\n  return Cartesian2.fromCartesian4(tmp, result);\n};\n\nconst normalScratch = new Cartesian3();\nconst rightScratch = new Cartesian3();\nconst upScratch = new Cartesian3();\n\n/**\n * Transform a position and velocity to a rotation matrix.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} velocity The velocity vector to transform.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.\n */\nTransforms.rotationMatrixFromPositionVelocity = function (\n  position,\n  velocity,\n  ellipsoid,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(velocity)) {\n    throw new DeveloperError(\"velocity is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const normal = (ellipsoid ?? Ellipsoid.default).geodeticSurfaceNormal(\n    position,\n    normalScratch,\n  );\n  let right = Cartesian3.cross(velocity, normal, rightScratch);\n\n  if (Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n    right = Cartesian3.clone(Cartesian3.UNIT_X, right);\n  }\n\n  const up = Cartesian3.cross(right, velocity, upScratch);\n  Cartesian3.normalize(up, up);\n  Cartesian3.cross(velocity, up, right);\n  Cartesian3.negate(right, right);\n  Cartesian3.normalize(right, right);\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = velocity.x;\n  result[1] = velocity.y;\n  result[2] = velocity.z;\n  result[3] = right.x;\n  result[4] = right.y;\n  result[5] = right.z;\n  result[6] = up.x;\n  result[7] = up.y;\n  result[8] = up.z;\n\n  return result;\n};\n\n/**\n * An immutable matrix that swaps x, y, z for 2D.\n *\n * @type {Matrix4}\n * @constant\n * @private\n */\nTransforms.SWIZZLE_3D_TO_2D_MATRIX = Object.freeze(\n  new Matrix4(\n    0.0,\n    0.0,\n    1.0,\n    0.0,\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n  ),\n);\n\nconst scratchCartographic = new Cartographic();\nconst scratchCartesian3Projection = new Cartesian3();\nconst scratchCenter = new Cartesian3();\nconst scratchRotation = new Matrix3();\nconst scratchFromENU = new Matrix4();\nconst scratchToENU = new Matrix4();\n\n/**\n * @private\n */\nTransforms.basisTo2D = function (projection, matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(projection)) {\n    throw new DeveloperError(\"projection is required.\");\n  }\n  if (!defined(matrix)) {\n    throw new DeveloperError(\"matrix is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const rtcCenter = Matrix4.getTranslation(matrix, scratchCenter);\n  const ellipsoid = projection.ellipsoid;\n\n  let projectedPosition;\n  if (Cartesian3.equals(rtcCenter, Cartesian3.ZERO)) {\n    projectedPosition = Cartesian3.clone(\n      Cartesian3.ZERO,\n      scratchCartesian3Projection,\n    );\n  } else {\n    // Get the 2D Center\n    const cartographic = ellipsoid.cartesianToCartographic(\n      rtcCenter,\n      scratchCartographic,\n    );\n\n    projectedPosition = projection.project(\n      cartographic,\n      scratchCartesian3Projection,\n    );\n    Cartesian3.fromElements(\n      projectedPosition.z,\n      projectedPosition.x,\n      projectedPosition.y,\n      projectedPosition,\n    );\n  }\n\n  // Assuming the instance are positioned on the ellipsoid, invert the ellipsoidal transform to get the local transform and then convert to 2D\n  const fromENU = Transforms.eastNorthUpToFixedFrame(\n    rtcCenter,\n    ellipsoid,\n    scratchFromENU,\n  );\n  const toENU = Matrix4.inverseTransformation(fromENU, scratchToENU);\n  const rotation = Matrix4.getMatrix3(matrix, scratchRotation);\n  const local = Matrix4.multiplyByMatrix3(toENU, rotation, result);\n  Matrix4.multiply(Transforms.SWIZZLE_3D_TO_2D_MATRIX, local, result); // Swap x, y, z for 2D\n  Matrix4.setTranslation(result, projectedPosition, result); // Use the projected center\n\n  return result;\n};\n\n/**\n * @private\n */\nTransforms.ellipsoidTo2DModelMatrix = function (projection, center, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(projection)) {\n    throw new DeveloperError(\"projection is required.\");\n  }\n  if (!defined(center)) {\n    throw new DeveloperError(\"center is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const ellipsoid = projection.ellipsoid;\n\n  const fromENU = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    scratchFromENU,\n  );\n  const toENU = Matrix4.inverseTransformation(fromENU, scratchToENU);\n\n  const cartographic = ellipsoid.cartesianToCartographic(\n    center,\n    scratchCartographic,\n  );\n  const projectedPosition = projection.project(\n    cartographic,\n    scratchCartesian3Projection,\n  );\n  Cartesian3.fromElements(\n    projectedPosition.z,\n    projectedPosition.x,\n    projectedPosition.y,\n    projectedPosition,\n  );\n\n  const translation = Matrix4.fromTranslation(\n    projectedPosition,\n    scratchFromENU,\n  );\n  Matrix4.multiply(Transforms.SWIZZLE_3D_TO_2D_MATRIX, toENU, result);\n  Matrix4.multiply(translation, result, result);\n\n  return result;\n};\nexport default Transforms;\n"],"names":["Transforms","vectorProductLocalFrame","up","south","north","west","east","down","degeneratePositionLocalFrame","localFrameToFixedFrameCache","scratchCalculateCartesian","scratchFirstCartesian","scratchSecondCartesian","scratchThirdCartesian","localFrameToFixedFrameGenerator","firstAxis","secondAxis","hasOwnProperty","thirdAxis","resultat","hashAxis","origin","ellipsoid","result","isNaN","x","y","z","equalsEpsilon","ZERO","EPSILON14","unpack","sign","multiplyByScalar","default","geodeticSurfaceNormal","normalize","cross","eastNorthUpToFixedFrame","northEastDownToFixedFrame","northUpEastToFixedFrame","northWestUpToFixedFrame","scratchHPRQuaternion","scratchScale","scratchHPRMatrix4","headingPitchRollToFixedFrame","headingPitchRoll","fixedFrameTransform","typeOf","object","hprQuaternion","fromHeadingPitchRoll","hprMatrix","fromTranslationQuaternionRotationScale","multiply","scratchENUMatrix4","scratchHPRMatrix3","headingPitchRollQuaternion","transform","rotation","getMatrix3","fromRotationMatrix","noScale","hprCenterScratch","ffScratch","hprTransformScratch","hprRotationScratch","hprQuaternionScratch","fixedFrameToHeadingPitchRoll","defined","center","getTranslation","equals","heading","pitch","roll","toFixedFrame","inverseTransformation","transformCopy","setScale","setTranslation","quaternionRotation","fromQuaternion","gmstConstant0","gmstConstant1","gmstConstant2","gmstConstant3","rateCoef","wgs84WRPrecessing","twoPiOverSecondsInDay","TWO_PI","dateInUtc","computeIcrfToCentralBodyFixedMatrix","date","transformMatrix","computeIcrfToFixedMatrix","computeTemeToPseudoFixedMatrix","addSeconds","computeTaiMinusUtc","utcDayNumber","dayNumber","utcSecondsIntoDay","secondsOfDay","t","diffDays","DAYS_PER_JULIAN_CENTURY","gmst0","angle","ratio","secondsSinceMidnight","SECONDS_PER_DAY","gha","cosGha","Math","cos","sinGha","sin","iau2006XysData","earthOrientationParameters","NONE","ttMinusTai","j2000ttDays","preloadIcrfFixed","timeInterval","startDayTT","start","startSecondTT","stopDayTT","stop","stopSecondTT","preload","fixedToIcrfMtx","computeFixedToIcrfMatrix","undefined","transpose","TdtMinusTai","J2000d","scratchHpr","scratchRotationMatrix","dateScratch","computeMoonFixedToIcrfMatrix","secondsTT","d","totalDays","e1","toRadians","e2","e3","e4","e5","computeIcrfToMoonFixedMatrix","xysScratch","eopScratch","rotation1Scratch","rotation2Scratch","eop","compute","dayTT","secondTT","xys","computeXysRadians","xPoleOffset","yPoleOffset","a","sqrt","rotation1","rotation2","fromRotationZ","s","matrixQ","dateUt1day","dateUt1sec","ut1MinusUtc","daysSinceJ2000","fractionOfDay","era","earthRotation","pfToIcrf","cosxp","xPoleWander","cosyp","yPoleWander","sinxp","sinyp","ttt","sp","RADIANS_PER_DEGREE","cossp","sinsp","fToPfMtx","pointToWindowCoordinatesTemp","pointToWindowCoordinates","modelViewProjectionMatrix","viewportTransformation","point","pointToGLWindowCoordinates","tmp","multiplyByVector","fromElements","w","fromCartesian4","normalScratch","rightScratch","upScratch","rotationMatrixFromPositionVelocity","position","velocity","normal","right","EPSILON6","clone","UNIT_X","negate","SWIZZLE_3D_TO_2D_MATRIX","Object","freeze","scratchCartographic","scratchCartesian3Projection","scratchCenter","scratchRotation","scratchFromENU","scratchToENU","basisTo2D","projection","matrix","rtcCenter","projectedPosition","cartographic","cartesianToCartographic","project","fromENU","toENU","local","multiplyByMatrix3","ellipsoidTo2DModelMatrix","translation","fromTranslation"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 14948, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Rectangle.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\nimport Transforms from \"./Transforms.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * A two dimensional region specified as longitude and latitude coordinates.\n *\n * @alias Rectangle\n * @constructor\n *\n * @param {number} [west=0.0] The westernmost longitude, in radians, in the range [-Pi, Pi].\n * @param {number} [south=0.0] The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n * @param {number} [east=0.0] The easternmost longitude, in radians, in the range [-Pi, Pi].\n * @param {number} [north=0.0] The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n *\n * @see Packable\n */\nfunction Rectangle(west, south, east, north) {\n  /**\n   * The westernmost longitude in radians in the range [-Pi, Pi].\n   *\n   * @type {number}\n   * @default 0.0\n   */\n  this.west = west ?? 0.0;\n\n  /**\n   * The southernmost latitude in radians in the range [-Pi/2, Pi/2].\n   *\n   * @type {number}\n   * @default 0.0\n   */\n  this.south = south ?? 0.0;\n\n  /**\n   * The easternmost longitude in radians in the range [-Pi, Pi].\n   *\n   * @type {number}\n   * @default 0.0\n   */\n  this.east = east ?? 0.0;\n\n  /**\n   * The northernmost latitude in radians in the range [-Pi/2, Pi/2].\n   *\n   * @type {number}\n   * @default 0.0\n   */\n  this.north = north ?? 0.0;\n}\n\nObject.defineProperties(Rectangle.prototype, {\n  /**\n   * Gets the width of the rectangle in radians.\n   * @memberof Rectangle.prototype\n   * @type {number}\n   * @readonly\n   */\n  width: {\n    get: function () {\n      return Rectangle.computeWidth(this);\n    },\n  },\n\n  /**\n   * Gets the height of the rectangle in radians.\n   * @memberof Rectangle.prototype\n   * @type {number}\n   * @readonly\n   */\n  height: {\n    get: function () {\n      return Rectangle.computeHeight(this);\n    },\n  },\n});\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nRectangle.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Rectangle} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nRectangle.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value.west;\n  array[startingIndex++] = value.south;\n  array[startingIndex++] = value.east;\n  array[startingIndex] = value.north;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Rectangle} [result] The object into which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n */\nRectangle.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  result.west = array[startingIndex++];\n  result.south = array[startingIndex++];\n  result.east = array[startingIndex++];\n  result.north = array[startingIndex];\n  return result;\n};\n\n/**\n * Computes the width of a rectangle in radians.\n * @param {Rectangle} rectangle The rectangle to compute the width of.\n * @returns {number} The width.\n */\nRectangle.computeWidth = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  let east = rectangle.east;\n  const west = rectangle.west;\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n  }\n  return east - west;\n};\n\n/**\n * Computes the height of a rectangle in radians.\n * @param {Rectangle} rectangle The rectangle to compute the height of.\n * @returns {number} The height.\n */\nRectangle.computeHeight = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  return rectangle.north - rectangle.south;\n};\n\n/**\n * Creates a rectangle given the boundary longitude and latitude in degrees.\n *\n * @param {number} [west=0.0] The westernmost longitude in degrees in the range [-180.0, 180.0].\n * @param {number} [south=0.0] The southernmost latitude in degrees in the range [-90.0, 90.0].\n * @param {number} [east=0.0] The easternmost longitude in degrees in the range [-180.0, 180.0].\n * @param {number} [north=0.0] The northernmost latitude in degrees in the range [-90.0, 90.0].\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n *\n * @example\n * const rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);\n */\nRectangle.fromDegrees = function (west, south, east, north, result) {\n  west = CesiumMath.toRadians(west ?? 0.0);\n  south = CesiumMath.toRadians(south ?? 0.0);\n  east = CesiumMath.toRadians(east ?? 0.0);\n  north = CesiumMath.toRadians(north ?? 0.0);\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n\n  return result;\n};\n\n/**\n * Creates a rectangle given the boundary longitude and latitude in radians.\n *\n * @param {number} [west=0.0] The westernmost longitude in radians in the range [-Math.PI, Math.PI].\n * @param {number} [south=0.0] The southernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\n * @param {number} [east=0.0] The easternmost longitude in radians in the range [-Math.PI, Math.PI].\n * @param {number} [north=0.0] The northernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n *\n * @example\n * const rectangle = Cesium.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);\n */\nRectangle.fromRadians = function (west, south, east, north, result) {\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west ?? 0.0;\n  result.south = south ?? 0.0;\n  result.east = east ?? 0.0;\n  result.north = north ?? 0.0;\n\n  return result;\n};\n\n/**\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n *\n * @param {Cartographic[]} cartographics The list of Cartographic instances.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromCartographicArray = function (cartographics, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics);\n  //>>includeEnd('debug');\n\n  let west = Number.MAX_VALUE;\n  let east = -Number.MAX_VALUE;\n  let westOverIDL = Number.MAX_VALUE;\n  let eastOverIDL = -Number.MAX_VALUE;\n  let south = Number.MAX_VALUE;\n  let north = -Number.MAX_VALUE;\n\n  for (let i = 0, len = cartographics.length; i < len; i++) {\n    const position = cartographics[i];\n    west = Math.min(west, position.longitude);\n    east = Math.max(east, position.longitude);\n    south = Math.min(south, position.latitude);\n    north = Math.max(north, position.latitude);\n\n    const lonAdjusted =\n      position.longitude >= 0\n        ? position.longitude\n        : position.longitude + CesiumMath.TWO_PI;\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\n  }\n\n  if (east - west > eastOverIDL - westOverIDL) {\n    west = westOverIDL;\n    east = eastOverIDL;\n\n    if (east > CesiumMath.PI) {\n      east = east - CesiumMath.TWO_PI;\n    }\n    if (west > CesiumMath.PI) {\n      west = west - CesiumMath.TWO_PI;\n    }\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n *\n * @param {Cartesian3[]} cartesians The list of Cartesian instances.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid the cartesians are on.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromCartesianArray = function (cartesians, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n\n  let west = Number.MAX_VALUE;\n  let east = -Number.MAX_VALUE;\n  let westOverIDL = Number.MAX_VALUE;\n  let eastOverIDL = -Number.MAX_VALUE;\n  let south = Number.MAX_VALUE;\n  let north = -Number.MAX_VALUE;\n\n  for (let i = 0, len = cartesians.length; i < len; i++) {\n    const position = ellipsoid.cartesianToCartographic(cartesians[i]);\n    west = Math.min(west, position.longitude);\n    east = Math.max(east, position.longitude);\n    south = Math.min(south, position.latitude);\n    north = Math.max(north, position.latitude);\n\n    const lonAdjusted =\n      position.longitude >= 0\n        ? position.longitude\n        : position.longitude + CesiumMath.TWO_PI;\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\n  }\n\n  if (east - west > eastOverIDL - westOverIDL) {\n    west = westOverIDL;\n    east = eastOverIDL;\n\n    if (east > CesiumMath.PI) {\n      east = east - CesiumMath.TWO_PI;\n    }\n    if (west > CesiumMath.PI) {\n      west = west - CesiumMath.TWO_PI;\n    }\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\nconst fromBoundingSphereMatrixScratch = new Cartesian3();\nconst fromBoundingSphereEastScratch = new Cartesian3();\nconst fromBoundingSphereNorthScratch = new Cartesian3();\nconst fromBoundingSphereWestScratch = new Cartesian3();\nconst fromBoundingSphereSouthScratch = new Cartesian3();\nconst fromBoundingSpherePositionsScratch = new Array(5);\nfor (let n = 0; n < fromBoundingSpherePositionsScratch.length; ++n) {\n  fromBoundingSpherePositionsScratch[n] = new Cartesian3();\n}\n/**\n * Create a rectangle from a bounding sphere, ignoring height.\n *\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromBoundingSphere = function (boundingSphere, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundingSphere\", boundingSphere);\n  //>>includeEnd('debug');\n\n  const center = boundingSphere.center;\n  const radius = boundingSphere.radius;\n\n  if (!defined(ellipsoid)) {\n    ellipsoid = Ellipsoid.default;\n  }\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  if (Cartesian3.equals(center, Cartesian3.ZERO)) {\n    Rectangle.clone(Rectangle.MAX_VALUE, result);\n    return result;\n  }\n\n  const fromENU = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    fromBoundingSphereMatrixScratch,\n  );\n  const east = Matrix4.multiplyByPointAsVector(\n    fromENU,\n    Cartesian3.UNIT_X,\n    fromBoundingSphereEastScratch,\n  );\n  Cartesian3.normalize(east, east);\n  const north = Matrix4.multiplyByPointAsVector(\n    fromENU,\n    Cartesian3.UNIT_Y,\n    fromBoundingSphereNorthScratch,\n  );\n  Cartesian3.normalize(north, north);\n\n  Cartesian3.multiplyByScalar(north, radius, north);\n  Cartesian3.multiplyByScalar(east, radius, east);\n\n  const south = Cartesian3.negate(north, fromBoundingSphereSouthScratch);\n  const west = Cartesian3.negate(east, fromBoundingSphereWestScratch);\n\n  const positions = fromBoundingSpherePositionsScratch;\n\n  // North\n  let corner = positions[0];\n  Cartesian3.add(center, north, corner);\n\n  // West\n  corner = positions[1];\n  Cartesian3.add(center, west, corner);\n\n  // South\n  corner = positions[2];\n  Cartesian3.add(center, south, corner);\n\n  // East\n  corner = positions[3];\n  Cartesian3.add(center, east, corner);\n\n  positions[4] = center;\n\n  return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n};\n\n/**\n * Duplicates a Rectangle.\n *\n * @param {Rectangle} rectangle The rectangle to clone.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)\n */\nRectangle.clone = function (rectangle, result) {\n  if (!defined(rectangle)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(\n      rectangle.west,\n      rectangle.south,\n      rectangle.east,\n      rectangle.north,\n    );\n  }\n\n  result.west = rectangle.west;\n  result.south = rectangle.south;\n  result.east = rectangle.east;\n  result.north = rectangle.north;\n  return result;\n};\n\n/**\n * Compares the provided Rectangles componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [left] The first Rectangle.\n * @param {Rectangle} [right] The second Rectangle.\n * @param {number} [absoluteEpsilon=0] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nRectangle.equalsEpsilon = function (left, right, absoluteEpsilon) {\n  absoluteEpsilon = absoluteEpsilon ?? 0;\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left.west - right.west) <= absoluteEpsilon &&\n      Math.abs(left.south - right.south) <= absoluteEpsilon &&\n      Math.abs(left.east - right.east) <= absoluteEpsilon &&\n      Math.abs(left.north - right.north) <= absoluteEpsilon)\n  );\n};\n\n/**\n * Duplicates this Rectangle.\n *\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.prototype.clone = function (result) {\n  return Rectangle.clone(this, result);\n};\n\n/**\n * Compares the provided Rectangle with this Rectangle componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Rectangle} [other] The Rectangle to compare.\n * @returns {boolean} <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.\n */\nRectangle.prototype.equals = function (other) {\n  return Rectangle.equals(this, other);\n};\n\n/**\n * Compares the provided rectangles and returns <code>true</code> if they are equal,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [left] The first Rectangle.\n * @param {Rectangle} [right] The second Rectangle.\n * @returns {boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.\n */\nRectangle.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.west === right.west &&\n      left.south === right.south &&\n      left.east === right.east &&\n      left.north === right.north)\n  );\n};\n\n/**\n * Compares the provided Rectangle with this Rectangle componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [other] The Rectangle to compare.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.\n */\nRectangle.prototype.equalsEpsilon = function (other, epsilon) {\n  return Rectangle.equalsEpsilon(this, other, epsilon);\n};\n\n/**\n * Checks a Rectangle's properties and throws if they are not in valid ranges.\n *\n * @param {Rectangle} rectangle The rectangle to validate\n *\n * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @private\n */\nRectangle._validate = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n\n  const north = rectangle.north;\n  Check.typeOf.number.greaterThanOrEquals(\n    \"north\",\n    north,\n    -CesiumMath.PI_OVER_TWO,\n  );\n  Check.typeOf.number.lessThanOrEquals(\"north\", north, CesiumMath.PI_OVER_TWO);\n\n  const south = rectangle.south;\n  Check.typeOf.number.greaterThanOrEquals(\n    \"south\",\n    south,\n    -CesiumMath.PI_OVER_TWO,\n  );\n  Check.typeOf.number.lessThanOrEquals(\"south\", south, CesiumMath.PI_OVER_TWO);\n\n  const west = rectangle.west;\n  Check.typeOf.number.greaterThanOrEquals(\"west\", west, -Math.PI);\n  Check.typeOf.number.lessThanOrEquals(\"west\", west, Math.PI);\n\n  const east = rectangle.east;\n  Check.typeOf.number.greaterThanOrEquals(\"east\", east, -Math.PI);\n  Check.typeOf.number.lessThanOrEquals(\"east\", east, Math.PI);\n  //>>includeEnd('debug');\n};\n\n/**\n * Computes the southwest corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.southwest = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.west, rectangle.south);\n  }\n  result.longitude = rectangle.west;\n  result.latitude = rectangle.south;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the northwest corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.northwest = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.west, rectangle.north);\n  }\n  result.longitude = rectangle.west;\n  result.latitude = rectangle.north;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the northeast corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.northeast = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.east, rectangle.north);\n  }\n  result.longitude = rectangle.east;\n  result.latitude = rectangle.north;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the southeast corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.southeast = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.east, rectangle.south);\n  }\n  result.longitude = rectangle.east;\n  result.latitude = rectangle.south;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the center of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the center\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.center = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  let east = rectangle.east;\n  const west = rectangle.west;\n\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n  }\n\n  const longitude = CesiumMath.negativePiToPi((west + east) * 0.5);\n  const latitude = (rectangle.south + rectangle.north) * 0.5;\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the intersection of two rectangles.  This function assumes that the rectangle's coordinates are\n * latitude and longitude in radians and produces a correct intersection, taking into account the fact that\n * the same angle can be represented with multiple values as well as the wrapping of longitude at the\n * anti-meridian.  For a simple intersection that ignores these factors and can be used with projected\n * coordinates, see {@link Rectangle.simpleIntersection}.\n *\n * @param {Rectangle} rectangle On rectangle to find an intersection\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n */\nRectangle.intersection = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  let rectangleEast = rectangle.east;\n  let rectangleWest = rectangle.west;\n\n  let otherRectangleEast = otherRectangle.east;\n  let otherRectangleWest = otherRectangle.west;\n\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n    rectangleEast += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n    otherRectangleEast += CesiumMath.TWO_PI;\n  }\n\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n    otherRectangleWest += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n    rectangleWest += CesiumMath.TWO_PI;\n  }\n\n  const west = CesiumMath.negativePiToPi(\n    Math.max(rectangleWest, otherRectangleWest),\n  );\n  const east = CesiumMath.negativePiToPi(\n    Math.min(rectangleEast, otherRectangleEast),\n  );\n\n  if (\n    (rectangle.west < rectangle.east ||\n      otherRectangle.west < otherRectangle.east) &&\n    east <= west\n  ) {\n    return undefined;\n  }\n\n  const south = Math.max(rectangle.south, otherRectangle.south);\n  const north = Math.min(rectangle.north, otherRectangle.north);\n\n  if (south >= north) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Computes a simple intersection of two rectangles.  Unlike {@link Rectangle.intersection}, this function\n * does not attempt to put the angular coordinates into a consistent range or to account for crossing the\n * anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude\n * and longitude (i.e. projected coordinates).\n *\n * @param {Rectangle} rectangle On rectangle to find an intersection\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n */\nRectangle.simpleIntersection = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  const west = Math.max(rectangle.west, otherRectangle.west);\n  const south = Math.max(rectangle.south, otherRectangle.south);\n  const east = Math.min(rectangle.east, otherRectangle.east);\n  const north = Math.min(rectangle.north, otherRectangle.north);\n\n  if (south >= north || west >= east) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Computes a rectangle that is the union of two rectangles.\n *\n * @param {Rectangle} rectangle A rectangle to enclose in rectangle.\n * @param {Rectangle} otherRectangle A rectangle to enclose in a rectangle.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.union = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  let rectangleEast = rectangle.east;\n  let rectangleWest = rectangle.west;\n\n  let otherRectangleEast = otherRectangle.east;\n  let otherRectangleWest = otherRectangle.west;\n\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n    rectangleEast += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n    otherRectangleEast += CesiumMath.TWO_PI;\n  }\n\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n    otherRectangleWest += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n    rectangleWest += CesiumMath.TWO_PI;\n  }\n\n  const west = CesiumMath.negativePiToPi(\n    Math.min(rectangleWest, otherRectangleWest),\n  );\n  const east = CesiumMath.negativePiToPi(\n    Math.max(rectangleEast, otherRectangleEast),\n  );\n\n  result.west = west;\n  result.south = Math.min(rectangle.south, otherRectangle.south);\n  result.east = east;\n  result.north = Math.max(rectangle.north, otherRectangle.north);\n\n  return result;\n};\n\n/**\n * Computes a rectangle by enlarging the provided rectangle until it contains the provided cartographic.\n *\n * @param {Rectangle} rectangle A rectangle to expand.\n * @param {Cartographic} cartographic A cartographic to enclose in a rectangle.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n */\nRectangle.expand = function (rectangle, cartographic, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  result.west = Math.min(rectangle.west, cartographic.longitude);\n  result.south = Math.min(rectangle.south, cartographic.latitude);\n  result.east = Math.max(rectangle.east, cartographic.longitude);\n  result.north = Math.max(rectangle.north, cartographic.latitude);\n\n  return result;\n};\n\n/**\n * Returns true if the cartographic is on or inside the rectangle, false otherwise.\n *\n * @param {Rectangle} rectangle The rectangle\n * @param {Cartographic} cartographic The cartographic to test.\n * @returns {boolean} true if the provided cartographic is inside the rectangle, false otherwise.\n */\nRectangle.contains = function (rectangle, cartographic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  let longitude = cartographic.longitude;\n  const latitude = cartographic.latitude;\n\n  const west = rectangle.west;\n  let east = rectangle.east;\n\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n    if (longitude < 0.0) {\n      longitude += CesiumMath.TWO_PI;\n    }\n  }\n  return (\n    (longitude > west ||\n      CesiumMath.equalsEpsilon(longitude, west, CesiumMath.EPSILON14)) &&\n    (longitude < east ||\n      CesiumMath.equalsEpsilon(longitude, east, CesiumMath.EPSILON14)) &&\n    latitude >= rectangle.south &&\n    latitude <= rectangle.north\n  );\n};\n\nconst subsampleLlaScratch = new Cartographic();\n/**\n * Samples a rectangle so that it includes a list of Cartesian points suitable for passing to\n * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account\n * for rectangles that cover the poles or cross the equator.\n *\n * @param {Rectangle} rectangle The rectangle to subsample.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to use.\n * @param {number} [surfaceHeight=0.0] The height of the rectangle above the ellipsoid.\n * @param {Cartesian3[]} [result] The array of Cartesians onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array of Cartesians instances if none was provided.\n */\nRectangle.subsample = function (rectangle, ellipsoid, surfaceHeight, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n  surfaceHeight = surfaceHeight ?? 0.0;\n\n  if (!defined(result)) {\n    result = [];\n  }\n  let length = 0;\n\n  const north = rectangle.north;\n  const south = rectangle.south;\n  const east = rectangle.east;\n  const west = rectangle.west;\n\n  const lla = subsampleLlaScratch;\n  lla.height = surfaceHeight;\n\n  lla.longitude = west;\n  lla.latitude = north;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.longitude = east;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.latitude = south;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.longitude = west;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  if (north < 0.0) {\n    lla.latitude = north;\n  } else if (south > 0.0) {\n    lla.latitude = south;\n  } else {\n    lla.latitude = 0.0;\n  }\n\n  for (let i = 1; i < 8; ++i) {\n    lla.longitude = -Math.PI + i * CesiumMath.PI_OVER_TWO;\n    if (Rectangle.contains(rectangle, lla)) {\n      result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n      length++;\n    }\n  }\n\n  if (lla.latitude === 0.0) {\n    lla.longitude = west;\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n    length++;\n    lla.longitude = east;\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n    length++;\n  }\n  result.length = length;\n  return result;\n};\n\n/**\n * Computes a subsection of a rectangle from normalized coordinates in the range [0.0, 1.0].\n *\n * @param {Rectangle} rectangle The rectangle to subsection.\n * @param {number} westLerp The west interpolation factor in the range [0.0, 1.0]. Must be less than or equal to eastLerp.\n * @param {number} southLerp The south interpolation factor in the range [0.0, 1.0]. Must be less than or equal to northLerp.\n * @param {number} eastLerp The east interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to westLerp.\n * @param {number} northLerp The north interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to southLerp.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.subsection = function (\n  rectangle,\n  westLerp,\n  southLerp,\n  eastLerp,\n  northLerp,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.number.greaterThanOrEquals(\"westLerp\", westLerp, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\"westLerp\", westLerp, 1.0);\n  Check.typeOf.number.greaterThanOrEquals(\"southLerp\", southLerp, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\"southLerp\", southLerp, 1.0);\n  Check.typeOf.number.greaterThanOrEquals(\"eastLerp\", eastLerp, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\"eastLerp\", eastLerp, 1.0);\n  Check.typeOf.number.greaterThanOrEquals(\"northLerp\", northLerp, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\"northLerp\", northLerp, 1.0);\n\n  Check.typeOf.number.lessThanOrEquals(\"westLerp\", westLerp, eastLerp);\n  Check.typeOf.number.lessThanOrEquals(\"southLerp\", southLerp, northLerp);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  // This function doesn't use CesiumMath.lerp because it has floating point precision problems\n  // when the start and end values are the same but the t changes.\n\n  if (rectangle.west <= rectangle.east) {\n    const width = rectangle.east - rectangle.west;\n    result.west = rectangle.west + westLerp * width;\n    result.east = rectangle.west + eastLerp * width;\n  } else {\n    const width = CesiumMath.TWO_PI + rectangle.east - rectangle.west;\n    result.west = CesiumMath.negativePiToPi(rectangle.west + westLerp * width);\n    result.east = CesiumMath.negativePiToPi(rectangle.west + eastLerp * width);\n  }\n  const height = rectangle.north - rectangle.south;\n  result.south = rectangle.south + southLerp * height;\n  result.north = rectangle.south + northLerp * height;\n\n  // Fix floating point precision problems when t = 1\n  if (westLerp === 1.0) {\n    result.west = rectangle.east;\n  }\n  if (eastLerp === 1.0) {\n    result.east = rectangle.east;\n  }\n  if (southLerp === 1.0) {\n    result.south = rectangle.north;\n  }\n  if (northLerp === 1.0) {\n    result.north = rectangle.north;\n  }\n\n  return result;\n};\n\n/**\n * The largest possible rectangle.\n *\n * @type {Rectangle}\n * @constant\n */\nRectangle.MAX_VALUE = Object.freeze(\n  new Rectangle(\n    -Math.PI,\n    -CesiumMath.PI_OVER_TWO,\n    Math.PI,\n    CesiumMath.PI_OVER_TWO,\n  ),\n);\nexport default Rectangle;\n"],"names":["Rectangle","west","south","east","north","Object","defineProperties","prototype","width","get","computeWidth","height","computeHeight","packedLength","pack","value","array","startingIndex","typeOf","object","defined","unpack","result","rectangle","TWO_PI","fromDegrees","toRadians","fromRadians","fromCartographicArray","cartographics","Number","MAX_VALUE","westOverIDL","eastOverIDL","i","len","length","position","Math","min","longitude","max","latitude","lonAdjusted","PI","fromCartesianArray","cartesians","ellipsoid","default","cartesianToCartographic","fromBoundingSphereMatrixScratch","fromBoundingSphereEastScratch","fromBoundingSphereNorthScratch","fromBoundingSphereWestScratch","fromBoundingSphereSouthScratch","fromBoundingSpherePositionsScratch","Array","n","fromBoundingSphere","boundingSphere","center","radius","equals","ZERO","clone","fromENU","eastNorthUpToFixedFrame","multiplyByPointAsVector","UNIT_X","normalize","UNIT_Y","multiplyByScalar","negate","positions","corner","add","undefined","equalsEpsilon","left","right","absoluteEpsilon","abs","other","epsilon","_validate","number","greaterThanOrEquals","PI_OVER_TWO","lessThanOrEquals","southwest","northwest","northeast","southeast","negativePiToPi","intersection","otherRectangle","rectangleEast","rectangleWest","otherRectangleEast","otherRectangleWest","simpleIntersection","union","expand","cartographic","contains","EPSILON14","subsampleLlaScratch","subsample","surfaceHeight","lla","cartographicToCartesian","subsection","westLerp","southLerp","eastLerp","northLerp","freeze"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 15783, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/BoundingSphere.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Intersect from \"./Intersect.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * A bounding sphere with a center and a radius.\n * @alias BoundingSphere\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.\n * @param {number} [radius=0.0] The radius of the bounding sphere.\n *\n * @see AxisAlignedBoundingBox\n * @see BoundingRectangle\n * @see Packable\n */\nfunction BoundingSphere(center, radius) {\n  /**\n   * The center point of the sphere.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Cartesian3.clone(center ?? Cartesian3.ZERO);\n\n  /**\n   * The radius of the sphere.\n   * @type {number}\n   * @default 0.0\n   */\n  this.radius = radius ?? 0.0;\n}\n\nconst fromPointsXMin = new Cartesian3();\nconst fromPointsYMin = new Cartesian3();\nconst fromPointsZMin = new Cartesian3();\nconst fromPointsXMax = new Cartesian3();\nconst fromPointsYMax = new Cartesian3();\nconst fromPointsZMax = new Cartesian3();\nconst fromPointsCurrentPos = new Cartesian3();\nconst fromPointsScratch = new Cartesian3();\nconst fromPointsRitterCenter = new Cartesian3();\nconst fromPointsMinBoxPt = new Cartesian3();\nconst fromPointsMaxBoxPt = new Cartesian3();\nconst fromPointsNaiveCenterScratch = new Cartesian3();\nconst volumeConstant = (4.0 / 3.0) * CesiumMath.PI;\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\n * The bounding sphere is computed by running two algorithms, a naive algorithm and\n * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n *\n * @param {Cartesian3[]} [positions] An array of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @see {@link http://help.agi.com/AGIComponents/html/BlogBoundingSphere.htm|Bounding Sphere computation article}\n */\nBoundingSphere.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  const currentPos = Cartesian3.clone(positions[0], fromPointsCurrentPos);\n\n  const xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  const yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  const zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n  const xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  const yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  const zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n  const numPositions = positions.length;\n  let i;\n  for (i = 1; i < numPositions; i++) {\n    Cartesian3.clone(positions[i], currentPos);\n\n    const x = currentPos.x;\n    const y = currentPos.y;\n    const z = currentPos.z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(xMax, xMin, fromPointsScratch),\n  );\n  const ySpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(yMax, yMin, fromPointsScratch),\n  );\n  const zSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(zMax, zMin, fromPointsScratch),\n  );\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch),\n  );\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  const naiveCenter = Cartesian3.midpoint(\n    minBoxPt,\n    maxBoxPt,\n    fromPointsNaiveCenterScratch,\n  );\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (i = 0; i < numPositions; i++) {\n    Cartesian3.clone(positions[i], currentPos);\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = Cartesian3.magnitude(\n      Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch),\n    );\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch),\n    );\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x =\n        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /\n        oldCenterToPoint;\n      ritterCenter.y =\n        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /\n        oldCenterToPoint;\n      ritterCenter.z =\n        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /\n        oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n\nconst defaultProjection = new GeographicProjection();\nconst fromRectangle2DLowerLeft = new Cartesian3();\nconst fromRectangle2DUpperRight = new Cartesian3();\nconst fromRectangle2DSouthwest = new Cartographic();\nconst fromRectangle2DNortheast = new Cartographic();\n\n/**\n * Computes a bounding sphere from a rectangle projected in 2D.\n *\n * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n * @param {object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangle2D = function (rectangle, projection, result) {\n  return BoundingSphere.fromRectangleWithHeights2D(\n    rectangle,\n    projection,\n    0.0,\n    0.0,\n    result,\n  );\n};\n\n/**\n * Computes a bounding sphere from a rectangle projected in 2D.  The bounding sphere accounts for the\n * object's minimum and maximum heights over the rectangle.\n *\n * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n * @param {object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {number} [minimumHeight=0.0] The minimum height over the rectangle.\n * @param {number} [maximumHeight=0.0] The maximum height over the rectangle.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangleWithHeights2D = function (\n  rectangle,\n  projection,\n  minimumHeight,\n  maximumHeight,\n  result,\n) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(rectangle)) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  defaultProjection._ellipsoid = Ellipsoid.default;\n  projection = projection ?? defaultProjection;\n\n  Rectangle.southwest(rectangle, fromRectangle2DSouthwest);\n  fromRectangle2DSouthwest.height = minimumHeight;\n  Rectangle.northeast(rectangle, fromRectangle2DNortheast);\n  fromRectangle2DNortheast.height = maximumHeight;\n\n  const lowerLeft = projection.project(\n    fromRectangle2DSouthwest,\n    fromRectangle2DLowerLeft,\n  );\n  const upperRight = projection.project(\n    fromRectangle2DNortheast,\n    fromRectangle2DUpperRight,\n  );\n\n  const width = upperRight.x - lowerLeft.x;\n  const height = upperRight.y - lowerLeft.y;\n  const elevation = upperRight.z - lowerLeft.z;\n\n  result.radius =\n    Math.sqrt(width * width + height * height + elevation * elevation) * 0.5;\n  const center = result.center;\n  center.x = lowerLeft.x + width * 0.5;\n  center.y = lowerLeft.y + height * 0.5;\n  center.z = lowerLeft.z + elevation * 0.5;\n  return result;\n};\n\nconst fromRectangle3DScratch = [];\n\n/**\n * Computes a bounding sphere from a rectangle in 3D. The bounding sphere is created using a subsample of points\n * on the ellipsoid and contained in the rectangle. It may not be accurate for all rectangles on all types of ellipsoids.\n *\n * @param {Rectangle} [rectangle] The valid rectangle used to create a bounding sphere.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid used to determine positions of the rectangle.\n * @param {number} [surfaceHeight=0.0] The height above the surface of the ellipsoid.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangle3D = function (\n  rectangle,\n  ellipsoid,\n  surfaceHeight,\n  result,\n) {\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n  surfaceHeight = surfaceHeight ?? 0.0;\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(rectangle)) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  const positions = Rectangle.subsample(\n    rectangle,\n    ellipsoid,\n    surfaceHeight,\n    fromRectangle3DScratch,\n  );\n  return BoundingSphere.fromPoints(positions, result);\n};\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are\n * stored in a flat array in X, Y, Z, order.  The bounding sphere is computed by running two\n * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n * ensure a tight fit.\n *\n * @param {number[]} [positions] An array of points that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {Cartesian3} [center=Cartesian3.ZERO] The position to which the positions are relative, which need not be the\n *        origin of the coordinate system.  This is useful when the positions are to be used for\n *        relative-to-center (RTC) rendering.\n * @param {number} [stride=3] The number of array elements per vertex.  It must be at least 3, but it may\n *        be higher.  Regardless of the value of this parameter, the X coordinate of the first position\n *        is at array index 0, the Y coordinate is at array index 1, and the Z coordinate is at array index\n *        2.  When stride is 3, the X coordinate of the next position then begins at array index 3.  If\n *        the stride is 5, however, two array elements are skipped and the next position begins at array\n *        index 5.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @example\n * // Compute the bounding sphere from 3 positions, each specified relative to a center.\n * // In addition to the X, Y, and Z coordinates, the points array contains two additional\n * // elements per point which are ignored for the purpose of computing the bounding sphere.\n * const center = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const points = [1.0, 2.0, 3.0, 0.1, 0.2,\n *               4.0, 5.0, 6.0, 0.1, 0.2,\n *               7.0, 8.0, 9.0, 0.1, 0.2];\n * const sphere = Cesium.BoundingSphere.fromVertices(points, center, 5);\n *\n * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n */\nBoundingSphere.fromVertices = function (positions, center, stride, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  center = center ?? Cartesian3.ZERO;\n\n  stride = stride ?? 3;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"stride\", stride, 3);\n  //>>includeEnd('debug');\n\n  const currentPos = fromPointsCurrentPos;\n  currentPos.x = positions[0] + center.x;\n  currentPos.y = positions[1] + center.y;\n  currentPos.z = positions[2] + center.z;\n\n  const xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  const yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  const zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n  const xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  const yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  const zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n  const numElements = positions.length;\n  let i;\n  for (i = 0; i < numElements; i += stride) {\n    const x = positions[i] + center.x;\n    const y = positions[i + 1] + center.y;\n    const z = positions[i + 2] + center.z;\n\n    currentPos.x = x;\n    currentPos.y = y;\n    currentPos.z = z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(xMax, xMin, fromPointsScratch),\n  );\n  const ySpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(yMax, yMin, fromPointsScratch),\n  );\n  const zSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(zMax, zMin, fromPointsScratch),\n  );\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch),\n  );\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  const naiveCenter = Cartesian3.midpoint(\n    minBoxPt,\n    maxBoxPt,\n    fromPointsNaiveCenterScratch,\n  );\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (i = 0; i < numElements; i += stride) {\n    currentPos.x = positions[i] + center.x;\n    currentPos.y = positions[i + 1] + center.y;\n    currentPos.z = positions[i + 2] + center.z;\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = Cartesian3.magnitude(\n      Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch),\n    );\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch),\n    );\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x =\n        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /\n        oldCenterToPoint;\n      ritterCenter.y =\n        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /\n        oldCenterToPoint;\n      ritterCenter.z =\n        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /\n        oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of EncodedCartesian3s, where the points are\n * stored in parallel flat arrays in X, Y, Z, order.  The bounding sphere is computed by running two\n * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n * ensure a tight fit.\n *\n * @param {number[]} [positionsHigh] An array of high bits of the encoded cartesians that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {number[]} [positionsLow] An array of low bits of the encoded cartesians that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n */\nBoundingSphere.fromEncodedCartesianVertices = function (\n  positionsHigh,\n  positionsLow,\n  result,\n) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (\n    !defined(positionsHigh) ||\n    !defined(positionsLow) ||\n    positionsHigh.length !== positionsLow.length ||\n    positionsHigh.length === 0\n  ) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  const currentPos = fromPointsCurrentPos;\n  currentPos.x = positionsHigh[0] + positionsLow[0];\n  currentPos.y = positionsHigh[1] + positionsLow[1];\n  currentPos.z = positionsHigh[2] + positionsLow[2];\n\n  const xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  const yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  const zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n  const xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  const yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  const zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n  const numElements = positionsHigh.length;\n  let i;\n  for (i = 0; i < numElements; i += 3) {\n    const x = positionsHigh[i] + positionsLow[i];\n    const y = positionsHigh[i + 1] + positionsLow[i + 1];\n    const z = positionsHigh[i + 2] + positionsLow[i + 2];\n\n    currentPos.x = x;\n    currentPos.y = y;\n    currentPos.z = z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(xMax, xMin, fromPointsScratch),\n  );\n  const ySpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(yMax, yMin, fromPointsScratch),\n  );\n  const zSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(zMax, zMin, fromPointsScratch),\n  );\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch),\n  );\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  const naiveCenter = Cartesian3.midpoint(\n    minBoxPt,\n    maxBoxPt,\n    fromPointsNaiveCenterScratch,\n  );\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (i = 0; i < numElements; i += 3) {\n    currentPos.x = positionsHigh[i] + positionsLow[i];\n    currentPos.y = positionsHigh[i + 1] + positionsLow[i + 1];\n    currentPos.z = positionsHigh[i + 2] + positionsLow[i + 2];\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = Cartesian3.magnitude(\n      Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch),\n    );\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch),\n    );\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x =\n        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /\n        oldCenterToPoint;\n      ritterCenter.y =\n        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /\n        oldCenterToPoint;\n      ritterCenter.z =\n        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /\n        oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n\n/**\n * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n * tightly and fully encompasses the box.\n *\n * @param {Cartesian3} [corner] The minimum height over the rectangle.\n * @param {Cartesian3} [oppositeCorner] The maximum height over the rectangle.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * // Create a bounding sphere around the unit cube\n * const sphere = Cesium.BoundingSphere.fromCornerPoints(new Cesium.Cartesian3(-0.5, -0.5, -0.5), new Cesium.Cartesian3(0.5, 0.5, 0.5));\n */\nBoundingSphere.fromCornerPoints = function (corner, oppositeCorner, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"corner\", corner);\n  Check.typeOf.object(\"oppositeCorner\", oppositeCorner);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  const center = Cartesian3.midpoint(corner, oppositeCorner, result.center);\n  result.radius = Cartesian3.distance(center, oppositeCorner);\n  return result;\n};\n\n/**\n * Creates a bounding sphere encompassing an ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid around which to create a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * const boundingSphere = Cesium.BoundingSphere.fromEllipsoid(ellipsoid);\n */\nBoundingSphere.fromEllipsoid = function (ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  Cartesian3.clone(Cartesian3.ZERO, result.center);\n  result.radius = ellipsoid.maximumRadius;\n  return result;\n};\n\nconst fromBoundingSpheresScratch = new Cartesian3();\n\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided array of bounding spheres.\n *\n * @param {BoundingSphere[]} [boundingSpheres] The array of bounding spheres.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromBoundingSpheres = function (boundingSpheres, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(boundingSpheres) || boundingSpheres.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  const length = boundingSpheres.length;\n  if (length === 1) {\n    return BoundingSphere.clone(boundingSpheres[0], result);\n  }\n\n  if (length === 2) {\n    return BoundingSphere.union(boundingSpheres[0], boundingSpheres[1], result);\n  }\n\n  const positions = [];\n  let i;\n  for (i = 0; i < length; i++) {\n    positions.push(boundingSpheres[i].center);\n  }\n\n  result = BoundingSphere.fromPoints(positions, result);\n\n  const center = result.center;\n  let radius = result.radius;\n  for (i = 0; i < length; i++) {\n    const tmp = boundingSpheres[i];\n    radius = Math.max(\n      radius,\n      Cartesian3.distance(center, tmp.center, fromBoundingSpheresScratch) +\n        tmp.radius,\n    );\n  }\n  result.radius = radius;\n\n  return result;\n};\n\nconst fromOrientedBoundingBoxScratchU = new Cartesian3();\nconst fromOrientedBoundingBoxScratchV = new Cartesian3();\nconst fromOrientedBoundingBoxScratchW = new Cartesian3();\n\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box.\n *\n * @param {OrientedBoundingBox} orientedBoundingBox The oriented bounding box.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromOrientedBoundingBox = function (\n  orientedBoundingBox,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"orientedBoundingBox\", orientedBoundingBox);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  const halfAxes = orientedBoundingBox.halfAxes;\n  const u = Matrix3.getColumn(halfAxes, 0, fromOrientedBoundingBoxScratchU);\n  const v = Matrix3.getColumn(halfAxes, 1, fromOrientedBoundingBoxScratchV);\n  const w = Matrix3.getColumn(halfAxes, 2, fromOrientedBoundingBoxScratchW);\n\n  Cartesian3.add(u, v, u);\n  Cartesian3.add(u, w, u);\n\n  result.center = Cartesian3.clone(orientedBoundingBox.center, result.center);\n  result.radius = Cartesian3.magnitude(u);\n\n  return result;\n};\n\nconst scratchFromTransformationCenter = new Cartesian3();\nconst scratchFromTransformationScale = new Cartesian3();\n\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided affine transformation.\n *\n * @param {Matrix4} transformation The affine transformation.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromTransformation = function (transformation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"transformation\", transformation);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  const center = Matrix4.getTranslation(\n    transformation,\n    scratchFromTransformationCenter,\n  );\n  const scale = Matrix4.getScale(\n    transformation,\n    scratchFromTransformationScale,\n  );\n  const radius = 0.5 * Cartesian3.magnitude(scale);\n  result.center = Cartesian3.clone(center, result.center);\n  result.radius = radius;\n\n  return result;\n};\n\n/**\n * Duplicates a BoundingSphere instance.\n *\n * @param {BoundingSphere} sphere The bounding sphere to duplicate.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided. (Returns undefined if sphere is undefined)\n */\nBoundingSphere.clone = function (sphere, result) {\n  if (!defined(sphere)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new BoundingSphere(sphere.center, sphere.radius);\n  }\n\n  result.center = Cartesian3.clone(sphere.center, result.center);\n  result.radius = sphere.radius;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nBoundingSphere.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoundingSphere} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nBoundingSphere.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const center = value.center;\n  array[startingIndex++] = center.x;\n  array[startingIndex++] = center.y;\n  array[startingIndex++] = center.z;\n  array[startingIndex] = value.radius;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoundingSphere} [result] The object into which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n */\nBoundingSphere.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  const center = result.center;\n  center.x = array[startingIndex++];\n  center.y = array[startingIndex++];\n  center.z = array[startingIndex++];\n  result.radius = array[startingIndex];\n  return result;\n};\n\nconst unionScratch = new Cartesian3();\nconst unionScratchCenter = new Cartesian3();\n/**\n * Computes a bounding sphere that contains both the left and right bounding spheres.\n *\n * @param {BoundingSphere} left A sphere to enclose in a bounding sphere.\n * @param {BoundingSphere} right A sphere to enclose in a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.union = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  const leftCenter = left.center;\n  const leftRadius = left.radius;\n  const rightCenter = right.center;\n  const rightRadius = right.radius;\n\n  const toRightCenter = Cartesian3.subtract(\n    rightCenter,\n    leftCenter,\n    unionScratch,\n  );\n  const centerSeparation = Cartesian3.magnitude(toRightCenter);\n\n  if (leftRadius >= centerSeparation + rightRadius) {\n    // Left sphere wins.\n    left.clone(result);\n    return result;\n  }\n\n  if (rightRadius >= centerSeparation + leftRadius) {\n    // Right sphere wins.\n    right.clone(result);\n    return result;\n  }\n\n  // There are two tangent points, one on far side of each sphere.\n  const halfDistanceBetweenTangentPoints =\n    (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n  // Compute the center point halfway between the two tangent points.\n  const center = Cartesian3.multiplyByScalar(\n    toRightCenter,\n    (-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation,\n    unionScratchCenter,\n  );\n  Cartesian3.add(center, leftCenter, center);\n  Cartesian3.clone(center, result.center);\n  result.radius = halfDistanceBetweenTangentPoints;\n\n  return result;\n};\n\nconst expandScratch = new Cartesian3();\n/**\n * Computes a bounding sphere by enlarging the provided sphere to contain the provided point.\n *\n * @param {BoundingSphere} sphere A sphere to expand.\n * @param {Cartesian3} point A point to enclose in a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.expand = function (sphere, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  result = BoundingSphere.clone(sphere, result);\n\n  const radius = Cartesian3.magnitude(\n    Cartesian3.subtract(point, result.center, expandScratch),\n  );\n  if (radius > result.radius) {\n    result.radius = radius;\n  }\n\n  return result;\n};\n\n/**\n * Determines which side of a plane a sphere is located.\n *\n * @param {BoundingSphere} sphere The bounding sphere to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\nBoundingSphere.intersectPlane = function (sphere, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  const center = sphere.center;\n  const radius = sphere.radius;\n  const normal = plane.normal;\n  const distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n\n  if (distanceToPlane < -radius) {\n    // The center point is negative side of the plane normal\n    return Intersect.OUTSIDE;\n  } else if (distanceToPlane < radius) {\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    return Intersect.INTERSECTING;\n  }\n  return Intersect.INSIDE;\n};\n\n/**\n * Applies a 4x4 affine transformation matrix to a bounding sphere.\n *\n * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.transform = function (sphere, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  result.center = Matrix4.multiplyByPoint(\n    transform,\n    sphere.center,\n    result.center,\n  );\n  result.radius = Matrix4.getMaximumScale(transform) * sphere.radius;\n\n  return result;\n};\n\nconst distanceSquaredToScratch = new Cartesian3();\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n *\n * @param {BoundingSphere} sphere The sphere.\n * @param {Cartesian3} cartesian The point\n * @returns {number} The distance squared from the bounding sphere to the point. Returns 0 if the point is inside the sphere.\n *\n * @example\n * // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return Cesium.BoundingSphere.distanceSquaredTo(b, camera.positionWC) - Cesium.BoundingSphere.distanceSquaredTo(a, camera.positionWC);\n * });\n */\nBoundingSphere.distanceSquaredTo = function (sphere, cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  const diff = Cartesian3.subtract(\n    sphere.center,\n    cartesian,\n    distanceSquaredToScratch,\n  );\n\n  const distance = Cartesian3.magnitude(diff) - sphere.radius;\n  if (distance <= 0.0) {\n    return 0.0;\n  }\n\n  return distance * distance;\n};\n\n/**\n * Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale\n * The transformation matrix is not verified to have a uniform scale of 1.\n * This method is faster than computing the general bounding sphere transform using {@link BoundingSphere.transform}.\n *\n * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);\n * const boundingSphere = new Cesium.BoundingSphere();\n * const newBoundingSphere = Cesium.BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);\n */\nBoundingSphere.transformWithoutScale = function (sphere, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  result.center = Matrix4.multiplyByPoint(\n    transform,\n    sphere.center,\n    result.center,\n  );\n  result.radius = sphere.radius;\n\n  return result;\n};\n\nconst scratchCartesian3 = new Cartesian3();\n/**\n * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n * plus/minus the radius of the bounding sphere.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding sphere.\n *\n * @param {BoundingSphere} sphere The bounding sphere to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n */\nBoundingSphere.computePlaneDistances = function (\n  sphere,\n  position,\n  direction,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"position\", position);\n  Check.typeOf.object(\"direction\", direction);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  const toCenter = Cartesian3.subtract(\n    sphere.center,\n    position,\n    scratchCartesian3,\n  );\n  const mag = Cartesian3.dot(direction, toCenter);\n\n  result.start = mag - sphere.radius;\n  result.stop = mag + sphere.radius;\n  return result;\n};\n\nconst projectTo2DNormalScratch = new Cartesian3();\nconst projectTo2DEastScratch = new Cartesian3();\nconst projectTo2DNorthScratch = new Cartesian3();\nconst projectTo2DWestScratch = new Cartesian3();\nconst projectTo2DSouthScratch = new Cartesian3();\nconst projectTo2DCartographicScratch = new Cartographic();\nconst projectTo2DPositionsScratch = new Array(8);\nfor (let n = 0; n < 8; ++n) {\n  projectTo2DPositionsScratch[n] = new Cartesian3();\n}\n\nconst projectTo2DProjection = new GeographicProjection();\n/**\n * Creates a bounding sphere in 2D from a bounding sphere in 3D world coordinates.\n *\n * @param {BoundingSphere} sphere The bounding sphere to transform to 2D.\n * @param {object} [projection=GeographicProjection] The projection to 2D.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.projectTo2D = function (sphere, projection, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  //>>includeEnd('debug');\n\n  projectTo2DProjection._ellipsoid = Ellipsoid.default;\n  projection = projection ?? projectTo2DProjection;\n\n  const ellipsoid = projection.ellipsoid;\n  let center = sphere.center;\n  const radius = sphere.radius;\n\n  let normal;\n  if (Cartesian3.equals(center, Cartesian3.ZERO)) {\n    // Bounding sphere is at the center. The geodetic surface normal is not\n    // defined here so pick the x-axis as a fallback.\n    normal = Cartesian3.clone(Cartesian3.UNIT_X, projectTo2DNormalScratch);\n  } else {\n    normal = ellipsoid.geodeticSurfaceNormal(center, projectTo2DNormalScratch);\n  }\n  const east = Cartesian3.cross(\n    Cartesian3.UNIT_Z,\n    normal,\n    projectTo2DEastScratch,\n  );\n  Cartesian3.normalize(east, east);\n  const north = Cartesian3.cross(normal, east, projectTo2DNorthScratch);\n  Cartesian3.normalize(north, north);\n\n  Cartesian3.multiplyByScalar(normal, radius, normal);\n  Cartesian3.multiplyByScalar(north, radius, north);\n  Cartesian3.multiplyByScalar(east, radius, east);\n\n  const south = Cartesian3.negate(north, projectTo2DSouthScratch);\n  const west = Cartesian3.negate(east, projectTo2DWestScratch);\n\n  const positions = projectTo2DPositionsScratch;\n\n  // top NE corner\n  let corner = positions[0];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, east, corner);\n\n  // top NW corner\n  corner = positions[1];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // top SW corner\n  corner = positions[2];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // top SE corner\n  corner = positions[3];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, east, corner);\n\n  Cartesian3.negate(normal, normal);\n\n  // bottom NE corner\n  corner = positions[4];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, east, corner);\n\n  // bottom NW corner\n  corner = positions[5];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // bottom SW corner\n  corner = positions[6];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // bottom SE corner\n  corner = positions[7];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, east, corner);\n\n  const length = positions.length;\n  for (let i = 0; i < length; ++i) {\n    const position = positions[i];\n    Cartesian3.add(center, position, position);\n    const cartographic = ellipsoid.cartesianToCartographic(\n      position,\n      projectTo2DCartographicScratch,\n    );\n    projection.project(cartographic, position);\n  }\n\n  result = BoundingSphere.fromPoints(positions, result);\n\n  // swizzle center components\n  center = result.center;\n  const x = center.x;\n  const y = center.y;\n  const z = center.z;\n  center.x = z;\n  center.y = x;\n  center.z = y;\n\n  return result;\n};\n\n/**\n * Determines whether or not a sphere is hidden from view by the occluder.\n *\n * @param {BoundingSphere} sphere The bounding sphere surrounding the occluded object.\n * @param {Occluder} occluder The occluder.\n * @returns {boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nBoundingSphere.isOccluded = function (sphere, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"occluder\", occluder);\n  //>>includeEnd('debug');\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n\n/**\n * Compares the provided BoundingSphere componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingSphere} [left] The first BoundingSphere.\n * @param {BoundingSphere} [right] The second BoundingSphere.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nBoundingSphere.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      left.radius === right.radius)\n  );\n};\n\n/**\n * Determines which side of a plane the sphere is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\nBoundingSphere.prototype.intersectPlane = function (plane) {\n  return BoundingSphere.intersectPlane(this, plane);\n};\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\nBoundingSphere.prototype.distanceSquaredTo = function (cartesian) {\n  return BoundingSphere.distanceSquaredTo(this, cartesian);\n};\n\n/**\n * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n * plus/minus the radius of the bounding sphere.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding sphere.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n */\nBoundingSphere.prototype.computePlaneDistances = function (\n  position,\n  direction,\n  result,\n) {\n  return BoundingSphere.computePlaneDistances(\n    this,\n    position,\n    direction,\n    result,\n  );\n};\n\n/**\n * Determines whether or not a sphere is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nBoundingSphere.prototype.isOccluded = function (occluder) {\n  return BoundingSphere.isOccluded(this, occluder);\n};\n\n/**\n * Compares this BoundingSphere against the provided BoundingSphere componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingSphere} [right] The right hand side BoundingSphere.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nBoundingSphere.prototype.equals = function (right) {\n  return BoundingSphere.equals(this, right);\n};\n\n/**\n * Duplicates this BoundingSphere instance.\n *\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.prototype.clone = function (result) {\n  return BoundingSphere.clone(this, result);\n};\n\n/**\n * Computes the radius of the BoundingSphere.\n * @returns {number} The radius of the BoundingSphere.\n */\nBoundingSphere.prototype.volume = function () {\n  const radius = this.radius;\n  return volumeConstant * radius * radius * radius;\n};\nexport default BoundingSphere;\n"],"names":["BoundingSphere","center","radius","clone","ZERO","fromPointsXMin","fromPointsYMin","fromPointsZMin","fromPointsXMax","fromPointsYMax","fromPointsZMax","fromPointsCurrentPos","fromPointsScratch","fromPointsRitterCenter","fromPointsMinBoxPt","fromPointsMaxBoxPt","fromPointsNaiveCenterScratch","volumeConstant","PI","fromPoints","positions","result","length","currentPos","xMin","yMin","zMin","xMax","yMax","zMax","numPositions","i","x","y","z","xSpan","magnitudeSquared","subtract","ySpan","zSpan","diameter1","diameter2","maxSpan","ritterCenter","radiusSquared","ritterRadius","Math","sqrt","minBoxPt","maxBoxPt","naiveCenter","midpoint","naiveRadius","r","magnitude","oldCenterToPointSquared","oldCenterToPoint","oldToNew","defaultProjection","fromRectangle2DLowerLeft","fromRectangle2DUpperRight","fromRectangle2DSouthwest","fromRectangle2DNortheast","fromRectangle2D","rectangle","projection","fromRectangleWithHeights2D","minimumHeight","maximumHeight","_ellipsoid","default","southwest","height","northeast","lowerLeft","project","upperRight","width","elevation","fromRectangle3DScratch","fromRectangle3D","ellipsoid","surfaceHeight","subsample","fromVertices","stride","typeOf","number","greaterThanOrEquals","numElements","fromEncodedCartesianVertices","positionsHigh","positionsLow","fromCornerPoints","corner","oppositeCorner","object","distance","fromEllipsoid","maximumRadius","fromBoundingSpheresScratch","fromBoundingSpheres","boundingSpheres","union","push","tmp","max","fromOrientedBoundingBoxScratchU","fromOrientedBoundingBoxScratchV","fromOrientedBoundingBoxScratchW","fromOrientedBoundingBox","orientedBoundingBox","defined","halfAxes","u","getColumn","v","w","add","scratchFromTransformationCenter","scratchFromTransformationScale","fromTransformation","transformation","getTranslation","scale","getScale","sphere","undefined","packedLength","pack","value","array","startingIndex","unpack","unionScratch","unionScratchCenter","left","right","leftCenter","leftRadius","rightCenter","rightRadius","toRightCenter","centerSeparation","halfDistanceBetweenTangentPoints","multiplyByScalar","expandScratch","expand","point","intersectPlane","plane","normal","distanceToPlane","dot","OUTSIDE","INTERSECTING","INSIDE","transform","multiplyByPoint","getMaximumScale","distanceSquaredToScratch","distanceSquaredTo","cartesian","diff","transformWithoutScale","scratchCartesian3","computePlaneDistances","position","direction","toCenter","mag","start","stop","projectTo2DNormalScratch","projectTo2DEastScratch","projectTo2DNorthScratch","projectTo2DWestScratch","projectTo2DSouthScratch","projectTo2DCartographicScratch","projectTo2DPositionsScratch","Array","n","projectTo2DProjection","projectTo2D","equals","UNIT_X","geodeticSurfaceNormal","east","cross","UNIT_Z","normalize","north","south","negate","west","cartographic","cartesianToCartographic","isOccluded","occluder","isBoundingSphereVisible","prototype","volume"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 16924, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/ClockRange.js"],"sourcesContent":["/**\n * Constants used by {@link Clock#tick} to determine behavior\n * when {@link Clock#startTime} or {@link Clock#stopTime} is reached.\n *\n * @enum {number}\n *\n * @see Clock\n * @see ClockStep\n */\nconst ClockRange = {\n  /**\n   * {@link Clock#tick} will always advances the clock in its current direction.\n   *\n   * @type {number}\n   * @constant\n   */\n  UNBOUNDED: 0,\n\n  /**\n   * When {@link Clock#startTime} or {@link Clock#stopTime} is reached,\n   * {@link Clock#tick} will not advance {@link Clock#currentTime} any further.\n   *\n   * @type {number}\n   * @constant\n   */\n  CLAMPED: 1,\n\n  /**\n   * When {@link Clock#stopTime} is reached, {@link Clock#tick} will advance\n   * {@link Clock#currentTime} to the opposite end of the interval.  When\n   * time is moving backwards, {@link Clock#tick} will not advance past\n   * {@link Clock#startTime}\n   *\n   * @type {number}\n   * @constant\n   */\n  LOOP_STOP: 2,\n};\nexport default Object.freeze(ClockRange);\n"],"names":["ClockRange","UNBOUNDED","CLAMPED","LOOP_STOP","Object","freeze"],"mappings":";;;;AAAA;;;;;;;;CAQC,GACD,MAAMA,aAAa;IACjB;;;;;GAKC,GACDC,WAAW;IAEX;;;;;;GAMC,GACDC,SAAS;IAET;;;;;;;;GAQC,GACDC,WAAW;AACb;uCACeC,OAAOC,MAAM,CAACL","ignoreList":[0]}},
    {"offset": {"line": 16965, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/ClockStep.js"],"sourcesContent":["/**\n * Constants to determine how much time advances with each call\n * to {@link Clock#tick}.\n *\n * @enum {number}\n *\n * @see Clock\n * @see ClockRange\n */\nconst ClockStep = {\n  /**\n   * {@link Clock#tick} advances the current time by a fixed step,\n   * which is the number of seconds specified by {@link Clock#multiplier}.\n   *\n   * @type {number}\n   * @constant\n   */\n  TICK_DEPENDENT: 0,\n\n  /**\n   * {@link Clock#tick} advances the current time by the amount of system\n   * time elapsed since the previous call multiplied by {@link Clock#multiplier}.\n   *\n   * @type {number}\n   * @constant\n   */\n  SYSTEM_CLOCK_MULTIPLIER: 1,\n\n  /**\n   * {@link Clock#tick} sets the clock to the current system time;\n   * ignoring all other settings.\n   *\n   * @type {number}\n   * @constant\n   */\n  SYSTEM_CLOCK: 2,\n};\nexport default Object.freeze(ClockStep);\n"],"names":["ClockStep","TICK_DEPENDENT","SYSTEM_CLOCK_MULTIPLIER","SYSTEM_CLOCK","Object","freeze"],"mappings":";;;;AAAA;;;;;;;;CAQC,GACD,MAAMA,YAAY;IAChB;;;;;;GAMC,GACDC,gBAAgB;IAEhB;;;;;;GAMC,GACDC,yBAAyB;IAEzB;;;;;;GAMC,GACDC,cAAc;AAChB;uCACeC,OAAOC,MAAM,CAACL","ignoreList":[0]}},
    {"offset": {"line": 17005, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/getTimestamp.js"],"sourcesContent":["/**\n * Gets a timestamp that can be used in measuring the time between events.  Timestamps\n * are expressed in milliseconds, but it is not specified what the milliseconds are\n * measured from.  This function uses performance.now() if it is available, or Date.now()\n * otherwise.\n *\n * @function getTimestamp\n *\n * @returns {number} The timestamp in milliseconds since some unspecified reference time.\n */\nlet getTimestamp;\n\nif (\n  typeof performance !== \"undefined\" &&\n  typeof performance.now === \"function\" &&\n  isFinite(performance.now())\n) {\n  getTimestamp = function () {\n    return performance.now();\n  };\n} else {\n  getTimestamp = function () {\n    return Date.now();\n  };\n}\nexport default getTimestamp;\n"],"names":["getTimestamp","performance","now","isFinite","Date"],"mappings":";;;;AAAA;;;;;;;;;CASC,GACD,IAAIA;AAEJ,IACE,OAAOC,gBAAgB,eACvB,OAAOA,YAAYC,GAAG,KAAK,cAC3BC,SAASF,YAAYC,GAAG,KACxB;IACAF,eAAe;QACb,OAAOC,YAAYC,GAAG;IACxB;AACF,OAAO;IACLF,eAAe;QACb,OAAOI,KAAKF,GAAG;IACjB;AACF;uCACeF","ignoreList":[0]}},
    {"offset": {"line": 17033, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Clock.js"],"sourcesContent":["import ClockRange from \"./ClockRange.js\";\nimport ClockStep from \"./ClockStep.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Event from \"./Event.js\";\nimport getTimestamp from \"./getTimestamp.js\";\nimport JulianDate from \"./JulianDate.js\";\n\n/**\n * A simple clock for keeping track of simulated time.\n *\n * @alias Clock\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {JulianDate} [options.startTime] The start time of the clock.\n * @param {JulianDate} [options.stopTime] The stop time of the clock.\n * @param {JulianDate} [options.currentTime] The current time.\n * @param {number} [options.multiplier=1.0] Determines how much time advances when {@link Clock#tick} is called, negative values allow for advancing backwards.\n * @param {ClockStep} [options.clockStep=ClockStep.SYSTEM_CLOCK_MULTIPLIER] Determines if calls to {@link Clock#tick} are frame dependent or system clock dependent.\n * @param {ClockRange} [options.clockRange=ClockRange.UNBOUNDED] Determines how the clock should behave when {@link Clock#startTime} or {@link Clock#stopTime} is reached.\n * @param {boolean} [options.canAnimate=true] Indicates whether {@link Clock#tick} can advance time.  This could be false if data is being buffered, for example.  The clock will only tick when both {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.\n * @param {boolean} [options.shouldAnimate=false] Indicates whether {@link Clock#tick} should attempt to advance time.  The clock will only tick when both {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.\n *\n * @exception {DeveloperError} startTime must come before stopTime.\n *\n *\n * @example\n * // Create a clock that loops on Christmas day 2013 and runs in real-time.\n * const clock = new Cesium.Clock({\n *    startTime : Cesium.JulianDate.fromIso8601(\"2013-12-25\"),\n *    currentTime : Cesium.JulianDate.fromIso8601(\"2013-12-25\"),\n *    stopTime : Cesium.JulianDate.fromIso8601(\"2013-12-26\"),\n *    clockRange : Cesium.ClockRange.LOOP_STOP,\n *    clockStep : Cesium.ClockStep.SYSTEM_CLOCK_MULTIPLIER\n * });\n *\n * @see ClockStep\n * @see ClockRange\n * @see JulianDate\n */\nfunction Clock(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  let currentTime = options.currentTime;\n  let startTime = options.startTime;\n  let stopTime = options.stopTime;\n\n  if (!defined(currentTime)) {\n    // if not specified, current time is the start time,\n    // or if that is not specified, 1 day before the stop time,\n    // or if that is not specified, then now.\n    if (defined(startTime)) {\n      currentTime = JulianDate.clone(startTime);\n    } else if (defined(stopTime)) {\n      currentTime = JulianDate.addDays(stopTime, -1.0, new JulianDate());\n    } else {\n      currentTime = JulianDate.now();\n    }\n  } else {\n    currentTime = JulianDate.clone(currentTime);\n  }\n\n  if (!defined(startTime)) {\n    // if not specified, start time is the current time\n    // (as determined above)\n    startTime = JulianDate.clone(currentTime);\n  } else {\n    startTime = JulianDate.clone(startTime);\n  }\n\n  if (!defined(stopTime)) {\n    // if not specified, stop time is 1 day after the start time\n    // (as determined above)\n    stopTime = JulianDate.addDays(startTime, 1.0, new JulianDate());\n  } else {\n    stopTime = JulianDate.clone(stopTime);\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (JulianDate.greaterThan(startTime, stopTime)) {\n    throw new DeveloperError(\"startTime must come before stopTime.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The start time of the clock.\n   * @type {JulianDate}\n   */\n  this.startTime = startTime;\n\n  /**\n   * The stop time of the clock.\n   * @type {JulianDate}\n   */\n  this.stopTime = stopTime;\n\n  /**\n   * Determines how the clock should behave when\n   * {@link Clock#startTime} or {@link Clock#stopTime}\n   * is reached.\n   * @type {ClockRange}\n   * @default {@link ClockRange.UNBOUNDED}\n   */\n  this.clockRange = options.clockRange ?? ClockRange.UNBOUNDED;\n\n  /**\n   * Indicates whether {@link Clock#tick} can advance time.  This could be false if data is being buffered,\n   * for example.  The clock will only advance time when both\n   * {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.\n   * @type {boolean}\n   * @default true\n   */\n  this.canAnimate = options.canAnimate ?? true;\n\n  /**\n   * An {@link Event} that is fired whenever {@link Clock#tick} is called.\n   * @type {Event}\n   */\n  this.onTick = new Event();\n  /**\n   * An {@link Event} that is fired whenever {@link Clock#stopTime} is reached.\n   * @type {Event}\n   */\n  this.onStop = new Event();\n\n  this._currentTime = undefined;\n  this._multiplier = undefined;\n  this._clockStep = undefined;\n  this._shouldAnimate = undefined;\n  this._lastSystemTime = getTimestamp();\n\n  // set values using the property setters to\n  // make values consistent.\n\n  this.currentTime = currentTime;\n  this.multiplier = options.multiplier ?? 1.0;\n  this.shouldAnimate = options.shouldAnimate ?? false;\n  this.clockStep = options.clockStep ?? ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n}\n\nObject.defineProperties(Clock.prototype, {\n  /**\n   * The current time.\n   * Changing this property will change\n   * {@link Clock#clockStep} from {@link ClockStep.SYSTEM_CLOCK} to\n   * {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}.\n   * @memberof Clock.prototype\n   * @type {JulianDate}\n   */\n  currentTime: {\n    get: function () {\n      return this._currentTime;\n    },\n    set: function (value) {\n      if (JulianDate.equals(this._currentTime, value)) {\n        return;\n      }\n\n      if (this._clockStep === ClockStep.SYSTEM_CLOCK) {\n        this._clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n      }\n\n      this._currentTime = value;\n    },\n  },\n\n  /**\n   * Gets or sets how much time advances when {@link Clock#tick} is called. Negative values allow for advancing backwards.\n   * If {@link Clock#clockStep} is set to {@link ClockStep.TICK_DEPENDENT}, this is the number of seconds to advance.\n   * If {@link Clock#clockStep} is set to {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}, this value is multiplied by the\n   * elapsed system time since the last call to {@link Clock#tick}.\n   * Changing this property will change\n   * {@link Clock#clockStep} from {@link ClockStep.SYSTEM_CLOCK} to\n   * {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}.\n   * @memberof Clock.prototype\n   * @type {number}\n   * @default 1.0\n   */\n  multiplier: {\n    get: function () {\n      return this._multiplier;\n    },\n    set: function (value) {\n      if (this._multiplier === value) {\n        return;\n      }\n\n      if (this._clockStep === ClockStep.SYSTEM_CLOCK) {\n        this._clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n      }\n\n      this._multiplier = value;\n    },\n  },\n\n  /**\n   * Determines if calls to {@link Clock#tick} are frame dependent or system clock dependent.\n   * Changing this property to {@link ClockStep.SYSTEM_CLOCK} will set\n   * {@link Clock#multiplier} to 1.0, {@link Clock#shouldAnimate} to true, and\n   * {@link Clock#currentTime} to the current system clock time.\n   * @memberof Clock.prototype\n   * @type ClockStep\n   * @default {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}\n   */\n  clockStep: {\n    get: function () {\n      return this._clockStep;\n    },\n    set: function (value) {\n      if (value === ClockStep.SYSTEM_CLOCK) {\n        this._multiplier = 1.0;\n        this._shouldAnimate = true;\n        this._currentTime = JulianDate.now();\n      }\n\n      this._clockStep = value;\n    },\n  },\n\n  /**\n   * Indicates whether {@link Clock#tick} should attempt to advance time.\n   * The clock will only advance time when both\n   * {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.\n   * Changing this property will change\n   * {@link Clock#clockStep} from {@link ClockStep.SYSTEM_CLOCK} to\n   * {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}.\n   * @memberof Clock.prototype\n   * @type {boolean}\n   * @default false\n   */\n  shouldAnimate: {\n    get: function () {\n      return this._shouldAnimate;\n    },\n    set: function (value) {\n      if (this._shouldAnimate === value) {\n        return;\n      }\n\n      if (this._clockStep === ClockStep.SYSTEM_CLOCK) {\n        this._clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n      }\n\n      this._shouldAnimate = value;\n    },\n  },\n});\n\n/**\n * Advances the clock from the current time based on the current configuration options.\n * tick should be called every frame, regardless of whether animation is taking place\n * or not.  To control animation, use the {@link Clock#shouldAnimate} property.\n *\n * @returns {JulianDate} The new value of the {@link Clock#currentTime} property.\n */\nClock.prototype.tick = function () {\n  const currentSystemTime = getTimestamp();\n  let currentTime = JulianDate.clone(this._currentTime);\n\n  if (this.canAnimate && this._shouldAnimate) {\n    const clockStep = this._clockStep;\n    if (clockStep === ClockStep.SYSTEM_CLOCK) {\n      currentTime = JulianDate.now(currentTime);\n    } else {\n      const multiplier = this._multiplier;\n\n      if (clockStep === ClockStep.TICK_DEPENDENT) {\n        currentTime = JulianDate.addSeconds(\n          currentTime,\n          multiplier,\n          currentTime,\n        );\n      } else {\n        const milliseconds = currentSystemTime - this._lastSystemTime;\n        currentTime = JulianDate.addSeconds(\n          currentTime,\n          multiplier * (milliseconds / 1000.0),\n          currentTime,\n        );\n      }\n\n      const clockRange = this.clockRange;\n      const startTime = this.startTime;\n      const stopTime = this.stopTime;\n\n      if (clockRange === ClockRange.CLAMPED) {\n        if (JulianDate.lessThan(currentTime, startTime)) {\n          currentTime = JulianDate.clone(startTime, currentTime);\n        } else if (JulianDate.greaterThan(currentTime, stopTime)) {\n          currentTime = JulianDate.clone(stopTime, currentTime);\n          this.onStop.raiseEvent(this);\n        }\n      } else if (clockRange === ClockRange.LOOP_STOP) {\n        if (JulianDate.lessThan(currentTime, startTime)) {\n          currentTime = JulianDate.clone(startTime, currentTime);\n        }\n        while (JulianDate.greaterThan(currentTime, stopTime)) {\n          currentTime = JulianDate.addSeconds(\n            startTime,\n            JulianDate.secondsDifference(currentTime, stopTime),\n            currentTime,\n          );\n          this.onStop.raiseEvent(this);\n        }\n      }\n    }\n  }\n\n  this._currentTime = currentTime;\n  this._lastSystemTime = currentSystemTime;\n  this.onTick.raiseEvent(this);\n  return currentTime;\n};\nexport default Clock;\n"],"names":["Clock","options","EMPTY_OBJECT","currentTime","startTime","stopTime","clone","addDays","now","greaterThan","clockRange","UNBOUNDED","canAnimate","onTick","onStop","_currentTime","undefined","_multiplier","_clockStep","_shouldAnimate","_lastSystemTime","multiplier","shouldAnimate","clockStep","SYSTEM_CLOCK_MULTIPLIER","Object","defineProperties","prototype","get","set","value","equals","SYSTEM_CLOCK","tick","currentSystemTime","TICK_DEPENDENT","addSeconds","milliseconds","CLAMPED","lessThan","raiseEvent","LOOP_STOP","secondsDifference"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 17310, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/destroyObject.js"],"sourcesContent":["import DeveloperError from \"./DeveloperError.js\";\n\nfunction returnTrue() {\n  return true;\n}\n\n/**\n * Destroys an object.  Each of the object's functions, including functions in its prototype,\n * is replaced with a function that throws a {@link DeveloperError}, except for the object's\n * <code>isDestroyed</code> function, which is set to a function that returns <code>true</code>.\n * The object's properties are removed with <code>delete</code>.\n * <br /><br />\n * This function is used by objects that hold native resources, e.g., WebGL resources, which\n * need to be explicitly released.  Client code calls an object's <code>destroy</code> function,\n * which then releases the native resource and calls <code>destroyObject</code> to put itself\n * in a destroyed state.\n *\n * @function\n *\n * @param {object} object The object to destroy.\n * @param {string} [message] The message to include in the exception that is thrown if\n *                           a destroyed object's function is called.\n *\n *\n * @example\n * // How a texture would destroy itself.\n * this.destroy = function () {\n *     _gl.deleteTexture(_texture);\n *     return Cesium.destroyObject(this);\n * };\n *\n * @see DeveloperError\n */\nfunction destroyObject(object, message) {\n  message = message ?? \"This object was destroyed, i.e., destroy() was called.\";\n\n  function throwOnDestroyed() {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(message);\n    //>>includeEnd('debug');\n  }\n\n  for (const key in object) {\n    if (typeof object[key] === \"function\") {\n      object[key] = throwOnDestroyed;\n    }\n  }\n\n  object.isDestroyed = returnTrue;\n\n  return undefined;\n}\nexport default destroyObject;\n"],"names":["returnTrue","destroyObject","object","message","throwOnDestroyed","key","isDestroyed","undefined"],"mappings":";;;;AAAA;;AAEA,SAASA;IACP,OAAO;AACT;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;CA0BC,GACD,SAASC,cAAcC,MAAM,EAAEC,OAAO;IACpCA,UAAUA,WAAW;IAErB,SAASC;QACP,yCAAyC;QACzC,MAAM,IAAI,oLAAc,CAACD;IACzB,wBAAwB;IAC1B;IAEA,IAAK,MAAME,OAAOH,OAAQ;QACxB,IAAI,OAAOA,MAAM,CAACG,IAAI,KAAK,YAAY;YACrCH,MAAM,CAACG,IAAI,GAAGD;QAChB;IACF;IAEAF,OAAOI,WAAW,GAAGN;IAErB,OAAOO;AACT;uCACeN","ignoreList":[0]}},
    {"offset": {"line": 17365, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/EventHelper.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * A convenience object that simplifies the common pattern of attaching event listeners\n * to several events, then removing all those listeners at once later, for example, in\n * a destroy method.\n *\n * @alias EventHelper\n * @constructor\n *\n *\n * @example\n * const helper = new Cesium.EventHelper();\n *\n * helper.add(someObject.event, listener1, this);\n * helper.add(otherObject.event, listener2, this);\n *\n * // later...\n * helper.removeAll();\n *\n * @see Event\n */\nfunction EventHelper() {\n  this._removalFunctions = [];\n}\n\n/**\n * Adds a listener to an event, and records the registration to be cleaned up later.\n *\n * @param {Event} event The event to attach to.\n * @param {Function} listener The function to be executed when the event is raised.\n * @param {object} [scope] An optional object scope to serve as the <code>this</code>\n *        pointer in which the listener function will execute.\n * @returns {EventHelper.RemoveCallback} A function that will remove this event listener when invoked.\n *\n * @see Event#addEventListener\n */\nEventHelper.prototype.add = function (event, listener, scope) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(event)) {\n    throw new DeveloperError(\"event is required\");\n  }\n  //>>includeEnd('debug');\n\n  const removalFunction = event.addEventListener(listener, scope);\n  this._removalFunctions.push(removalFunction);\n\n  const that = this;\n  return function () {\n    removalFunction();\n    const removalFunctions = that._removalFunctions;\n    removalFunctions.splice(removalFunctions.indexOf(removalFunction), 1);\n  };\n};\n\n/**\n * Unregisters all previously added listeners.\n *\n * @see Event#removeEventListener\n */\nEventHelper.prototype.removeAll = function () {\n  const removalFunctions = this._removalFunctions;\n  for (let i = 0, len = removalFunctions.length; i < len; ++i) {\n    removalFunctions[i]();\n  }\n  removalFunctions.length = 0;\n};\n\n/**\n * A function that removes a listener.\n * @callback EventHelper.RemoveCallback\n */\nexport default EventHelper;\n"],"names":["EventHelper","_removalFunctions","prototype","add","event","listener","scope","removalFunction","addEventListener","push","that","removalFunctions","splice","indexOf","removeAll","i","len","length"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;;;;;;;;;;;;;CAmBC,GACD,SAASA;IACP,IAAI,CAACC,iBAAiB,GAAG,EAAE;AAC7B;AAEA;;;;;;;;;;CAUC,GACDD,YAAYE,SAAS,CAACC,GAAG,GAAG,SAAUC,KAAK,EAAEC,QAAQ,EAAEC,KAAK;IAC1D,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACF,QAAQ;QACnB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAMG,kBAAkBH,MAAMI,gBAAgB,CAACH,UAAUC;IACzD,IAAI,CAACL,iBAAiB,CAACQ,IAAI,CAACF;IAE5B,MAAMG,OAAO,IAAI;IACjB,OAAO;QACLH;QACA,MAAMI,mBAAmBD,KAAKT,iBAAiB;QAC/CU,iBAAiBC,MAAM,CAACD,iBAAiBE,OAAO,CAACN,kBAAkB;IACrE;AACF;AAEA;;;;CAIC,GACDP,YAAYE,SAAS,CAACY,SAAS,GAAG;IAChC,MAAMH,mBAAmB,IAAI,CAACV,iBAAiB;IAC/C,IAAK,IAAIc,IAAI,GAAGC,MAAML,iBAAiBM,MAAM,EAAEF,IAAIC,KAAK,EAAED,EAAG;QAC3DJ,gBAAgB,CAACI,EAAE;IACrB;IACAJ,iBAAiBM,MAAM,GAAG;AAC5B;uCAMejB","ignoreList":[0]}},
    {"offset": {"line": 17436, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/formatError.js"],"sourcesContent":["import defined from \"./defined.js\";\n\n/**\n * Formats an error object into a String.  If available, uses name, message, and stack\n * properties, otherwise, falls back on toString().\n *\n * @function\n *\n * @param {*} object The item to find in the array.\n * @returns {string} A string containing the formatted error.\n */\nfunction formatError(object) {\n  let result;\n\n  const name = object.name;\n  const message = object.message;\n  if (defined(name) && defined(message)) {\n    result = `${name}: ${message}`;\n  } else {\n    result = object.toString();\n  }\n\n  const stack = object.stack;\n  if (defined(stack)) {\n    result += `\\n${stack}`;\n  }\n\n  return result;\n}\nexport default formatError;\n"],"names":["formatError","object","result","name","message","toString","stack"],"mappings":";;;;AAAA;;AAEA;;;;;;;;CAQC,GACD,SAASA,YAAYC,MAAM;IACzB,IAAIC;IAEJ,MAAMC,OAAOF,OAAOE,IAAI;IACxB,MAAMC,UAAUH,OAAOG,OAAO;IAC9B,IAAI,IAAA,6KAAO,EAACD,SAAS,IAAA,6KAAO,EAACC,UAAU;QACrCF,SAAS,GAAGC,KAAK,EAAE,EAAEC,SAAS;IAChC,OAAO;QACLF,SAASD,OAAOI,QAAQ;IAC1B;IAEA,MAAMC,QAAQL,OAAOK,KAAK;IAC1B,IAAI,IAAA,6KAAO,EAACA,QAAQ;QAClBJ,UAAU,CAAC,EAAE,EAAEI,OAAO;IACxB;IAEA,OAAOJ;AACT;uCACeF","ignoreList":[0]}},
    {"offset": {"line": 17470, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/HeadingPitchRange.js"],"sourcesContent":["import defined from \"./defined.js\";\n\n/**\n * Defines a heading angle, pitch angle, and range in a local frame.\n * Heading is the rotation from the local east direction where a positive angle is increasing southward.\n * Pitch is the rotation from the local xy-plane. Positive pitch angles are above the plane. Negative pitch\n * angles are below the plane. Range is the distance from the center of the frame.\n * @alias HeadingPitchRange\n * @constructor\n *\n * @param {number} [heading=0.0] The heading angle in radians.\n * @param {number} [pitch=0.0] The pitch angle in radians.\n * @param {number} [range=0.0] The distance from the center in meters.\n */\nfunction HeadingPitchRange(heading, pitch, range) {\n  /**\n   * Heading is the rotation from the local east direction where a positive angle is increasing southward.\n   * @type {number}\n   * @default 0.0\n   */\n  this.heading = heading ?? 0.0;\n\n  /**\n   * Pitch is the rotation from the local xy-plane. Positive pitch angles\n   * are above the plane. Negative pitch angles are below the plane.\n   * @type {number}\n   * @default 0.0\n   */\n  this.pitch = pitch ?? 0.0;\n\n  /**\n   * Range is the distance from the center of the local frame.\n   * @type {number}\n   * @default 0.0\n   */\n  this.range = range ?? 0.0;\n}\n\n/**\n * Duplicates a HeadingPitchRange instance.\n *\n * @param {HeadingPitchRange} hpr The HeadingPitchRange to duplicate.\n * @param {HeadingPitchRange} [result] The object onto which to store the result.\n * @returns {HeadingPitchRange} The modified result parameter or a new HeadingPitchRange instance if one was not provided. (Returns undefined if hpr is undefined)\n */\nHeadingPitchRange.clone = function (hpr, result) {\n  if (!defined(hpr)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new HeadingPitchRange();\n  }\n\n  result.heading = hpr.heading;\n  result.pitch = hpr.pitch;\n  result.range = hpr.range;\n  return result;\n};\nexport default HeadingPitchRange;\n"],"names":["HeadingPitchRange","heading","pitch","range","clone","hpr","result","undefined"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;;;CAWC,GACD,SAASA,kBAAkBC,OAAO,EAAEC,KAAK,EAAEC,KAAK;IAC9C;;;;GAIC,GACD,IAAI,CAACF,OAAO,GAAGA,WAAW;IAE1B;;;;;GAKC,GACD,IAAI,CAACC,KAAK,GAAGA,SAAS;IAEtB;;;;GAIC,GACD,IAAI,CAACC,KAAK,GAAGA,SAAS;AACxB;AAEA;;;;;;CAMC,GACDH,kBAAkBI,KAAK,GAAG,SAAUC,GAAG,EAAEC,MAAM;IAC7C,IAAI,CAAC,IAAA,6KAAO,EAACD,MAAM;QACjB,OAAOE;IACT;IACA,IAAI,CAAC,IAAA,6KAAO,EAACD,SAAS;QACpBA,SAAS,IAAIN;IACf;IAEAM,OAAOL,OAAO,GAAGI,IAAIJ,OAAO;IAC5BK,OAAOJ,KAAK,GAAGG,IAAIH,KAAK;IACxBI,OAAOH,KAAK,GAAGE,IAAIF,KAAK;IACxB,OAAOG;AACT;uCACeN","ignoreList":[0]}},
    {"offset": {"line": 17528, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/GeographicTilingScheme.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where\n * longitude and latitude are directly mapped to X and Y.  This projection is commonly\n * known as geographic, equirectangular, equidistant cylindrical, or plate carrÃ©e.\n *\n * @alias GeographicTilingScheme\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid whose surface is being tiled. Defaults to\n * the default ellipsoid.\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the tiling scheme.\n * @param {number} [options.numberOfLevelZeroTilesX=2] The number of tiles in the X direction at level zero of\n * the tile tree.\n * @param {number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of\n * the tile tree.\n */\nfunction GeographicTilingScheme(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  this._ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  this._rectangle = options.rectangle ?? Rectangle.MAX_VALUE;\n  this._projection = new GeographicProjection(this._ellipsoid);\n  this._numberOfLevelZeroTilesX = options.numberOfLevelZeroTilesX ?? 2;\n  this._numberOfLevelZeroTilesY = options.numberOfLevelZeroTilesY ?? 1;\n}\n\nObject.defineProperties(GeographicTilingScheme.prototype, {\n  /**\n   * Gets the ellipsoid that is tiled by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, covered by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {Rectangle}\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    },\n  },\n\n  /**\n   * Gets the map projection used by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {MapProjection}\n   */\n  projection: {\n    get: function () {\n      return this._projection;\n    },\n  },\n});\n\n/**\n * Gets the total number of tiles in the X direction at a specified level-of-detail.\n *\n * @param {number} level The level-of-detail.\n * @returns {number} The number of tiles in the X direction at the given level.\n */\nGeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesX << level;\n};\n\n/**\n * Gets the total number of tiles in the Y direction at a specified level-of-detail.\n *\n * @param {number} level The level-of-detail.\n * @returns {number} The number of tiles in the Y direction at the given level.\n */\nGeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesY << level;\n};\n\n/**\n * Transforms a rectangle specified in geodetic radians to the native coordinate system\n * of this tiling scheme.\n *\n * @param {Rectangle} rectangle The rectangle to transform.\n * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'\n *          is undefined.\n */\nGeographicTilingScheme.prototype.rectangleToNativeRectangle = function (\n  rectangle,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  const west = CesiumMath.toDegrees(rectangle.west);\n  const south = CesiumMath.toDegrees(rectangle.south);\n  const east = CesiumMath.toDegrees(rectangle.east);\n  const north = CesiumMath.toDegrees(rectangle.north);\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates\n * of the tiling scheme.\n *\n * @param {number} x The integer x coordinate of the tile.\n * @param {number} y The integer y coordinate of the tile.\n * @param {number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.tileXYToNativeRectangle = function (\n  x,\n  y,\n  level,\n  result,\n) {\n  const rectangleRadians = this.tileXYToRectangle(x, y, level, result);\n  rectangleRadians.west = CesiumMath.toDegrees(rectangleRadians.west);\n  rectangleRadians.south = CesiumMath.toDegrees(rectangleRadians.south);\n  rectangleRadians.east = CesiumMath.toDegrees(rectangleRadians.east);\n  rectangleRadians.north = CesiumMath.toDegrees(rectangleRadians.north);\n  return rectangleRadians;\n};\n\n/**\n * Converts tile x, y coordinates and level to a cartographic rectangle in radians.\n *\n * @param {number} x The integer x coordinate of the tile.\n * @param {number} y The integer y coordinate of the tile.\n * @param {number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.tileXYToRectangle = function (\n  x,\n  y,\n  level,\n  result,\n) {\n  const rectangle = this._rectangle;\n\n  const xTiles = this.getNumberOfXTilesAtLevel(level);\n  const yTiles = this.getNumberOfYTilesAtLevel(level);\n\n  const xTileWidth = rectangle.width / xTiles;\n  const west = x * xTileWidth + rectangle.west;\n  const east = (x + 1) * xTileWidth + rectangle.west;\n\n  const yTileHeight = rectangle.height / yTiles;\n  const north = rectangle.north - y * yTileHeight;\n  const south = rectangle.north - (y + 1) * yTileHeight;\n\n  if (!defined(result)) {\n    result = new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Calculates the tile x, y coordinates of the tile containing\n * a given cartographic position.\n *\n * @param {Cartographic} position The position.\n * @param {number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.positionToTileXY = function (\n  position,\n  level,\n  result,\n) {\n  const rectangle = this._rectangle;\n  if (!Rectangle.contains(rectangle, position)) {\n    // outside the bounds of the tiling scheme\n    return undefined;\n  }\n\n  const xTiles = this.getNumberOfXTilesAtLevel(level);\n  const yTiles = this.getNumberOfYTilesAtLevel(level);\n\n  const xTileWidth = rectangle.width / xTiles;\n  const yTileHeight = rectangle.height / yTiles;\n\n  let longitude = position.longitude;\n  if (rectangle.east < rectangle.west) {\n    longitude += CesiumMath.TWO_PI;\n  }\n\n  let xTileCoordinate = ((longitude - rectangle.west) / xTileWidth) | 0;\n  if (xTileCoordinate >= xTiles) {\n    xTileCoordinate = xTiles - 1;\n  }\n\n  let yTileCoordinate =\n    ((rectangle.north - position.latitude) / yTileHeight) | 0;\n  if (yTileCoordinate >= yTiles) {\n    yTileCoordinate = yTiles - 1;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian2(xTileCoordinate, yTileCoordinate);\n  }\n\n  result.x = xTileCoordinate;\n  result.y = yTileCoordinate;\n  return result;\n};\nexport default GeographicTilingScheme;\n"],"names":["GeographicTilingScheme","options","EMPTY_OBJECT","_ellipsoid","ellipsoid","default","_rectangle","rectangle","MAX_VALUE","_projection","_numberOfLevelZeroTilesX","numberOfLevelZeroTilesX","_numberOfLevelZeroTilesY","numberOfLevelZeroTilesY","Object","defineProperties","prototype","get","projection","getNumberOfXTilesAtLevel","level","getNumberOfYTilesAtLevel","rectangleToNativeRectangle","result","defined","west","toDegrees","south","east","north","tileXYToNativeRectangle","x","y","rectangleRadians","tileXYToRectangle","xTiles","yTiles","xTileWidth","width","yTileHeight","height","positionToTileXY","position","contains","undefined","longitude","TWO_PI","xTileCoordinate","yTileCoordinate","latitude"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 17735, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/ApproximateTerrainHeights.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport buildModuleUrl from \"./buildModuleUrl.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Resource from \"./Resource.js\";\n\nconst scratchDiagonalCartesianNE = new Cartesian3();\nconst scratchDiagonalCartesianSW = new Cartesian3();\nconst scratchDiagonalCartographic = new Cartographic();\nconst scratchCenterCartesian = new Cartesian3();\nconst scratchSurfaceCartesian = new Cartesian3();\n\nconst scratchBoundingSphere = new BoundingSphere();\nconst tilingScheme = new GeographicTilingScheme();\nconst scratchCorners = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\nconst scratchTileXY = new Cartesian2();\n\n/**\n * A collection of functions for approximating terrain height\n * @private\n */\nconst ApproximateTerrainHeights = {};\n\n/**\n * Initializes the minimum and maximum terrain heights\n * @return {Promise<void>}\n */\nApproximateTerrainHeights.initialize = function () {\n  let initPromise = ApproximateTerrainHeights._initPromise;\n  if (defined(initPromise)) {\n    return initPromise;\n  }\n  initPromise = Resource.fetchJson(\n    buildModuleUrl(\"Assets/approximateTerrainHeights.json\"),\n  ).then(function (json) {\n    ApproximateTerrainHeights._terrainHeights = json;\n  });\n  ApproximateTerrainHeights._initPromise = initPromise;\n\n  return initPromise;\n};\n\n/**\n * Computes the minimum and maximum terrain heights for a given rectangle\n * @param {Rectangle} rectangle The bounding rectangle\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid\n * @return {{minimumTerrainHeight: number, maximumTerrainHeight: number}}\n */\nApproximateTerrainHeights.getMinimumMaximumHeights = function (\n  rectangle,\n  ellipsoid,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\n    throw new DeveloperError(\n      \"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\",\n    );\n  }\n  //>>includeEnd('debug');\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n\n  const xyLevel = getTileXYLevel(rectangle);\n\n  // Get the terrain min/max for that tile\n  let minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n  let maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  if (defined(xyLevel)) {\n    const key = `${xyLevel.level}-${xyLevel.x}-${xyLevel.y}`;\n    const heights = ApproximateTerrainHeights._terrainHeights[key];\n    if (defined(heights)) {\n      minTerrainHeight = heights[0];\n      maxTerrainHeight = heights[1];\n    }\n\n    // Compute min by taking the center of the NE->SW diagonal and finding distance to the surface\n    ellipsoid.cartographicToCartesian(\n      Rectangle.northeast(rectangle, scratchDiagonalCartographic),\n      scratchDiagonalCartesianNE,\n    );\n    ellipsoid.cartographicToCartesian(\n      Rectangle.southwest(rectangle, scratchDiagonalCartographic),\n      scratchDiagonalCartesianSW,\n    );\n\n    Cartesian3.midpoint(\n      scratchDiagonalCartesianSW,\n      scratchDiagonalCartesianNE,\n      scratchCenterCartesian,\n    );\n    const surfacePosition = ellipsoid.scaleToGeodeticSurface(\n      scratchCenterCartesian,\n      scratchSurfaceCartesian,\n    );\n    if (defined(surfacePosition)) {\n      const distance = Cartesian3.distance(\n        scratchCenterCartesian,\n        surfacePosition,\n      );\n      minTerrainHeight = Math.min(minTerrainHeight, -distance);\n    } else {\n      minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n    }\n  }\n\n  minTerrainHeight = Math.max(\n    ApproximateTerrainHeights._defaultMinTerrainHeight,\n    minTerrainHeight,\n  );\n\n  return {\n    minimumTerrainHeight: minTerrainHeight,\n    maximumTerrainHeight: maxTerrainHeight,\n  };\n};\n\n/**\n * Computes the bounding sphere based on the tile heights in the rectangle\n * @param {Rectangle} rectangle The bounding rectangle\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid\n * @return {BoundingSphere} The result bounding sphere\n */\nApproximateTerrainHeights.getBoundingSphere = function (rectangle, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\n    throw new DeveloperError(\n      \"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\",\n    );\n  }\n  //>>includeEnd('debug');\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n\n  const xyLevel = getTileXYLevel(rectangle);\n\n  // Get the terrain max for that tile\n  let maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  if (defined(xyLevel)) {\n    const key = `${xyLevel.level}-${xyLevel.x}-${xyLevel.y}`;\n    const heights = ApproximateTerrainHeights._terrainHeights[key];\n    if (defined(heights)) {\n      maxTerrainHeight = heights[1];\n    }\n  }\n\n  const result = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, 0.0);\n  BoundingSphere.fromRectangle3D(\n    rectangle,\n    ellipsoid,\n    maxTerrainHeight,\n    scratchBoundingSphere,\n  );\n\n  return BoundingSphere.union(result, scratchBoundingSphere, result);\n};\n\nfunction getTileXYLevel(rectangle) {\n  Cartographic.fromRadians(\n    rectangle.east,\n    rectangle.north,\n    0.0,\n    scratchCorners[0],\n  );\n  Cartographic.fromRadians(\n    rectangle.west,\n    rectangle.north,\n    0.0,\n    scratchCorners[1],\n  );\n  Cartographic.fromRadians(\n    rectangle.east,\n    rectangle.south,\n    0.0,\n    scratchCorners[2],\n  );\n  Cartographic.fromRadians(\n    rectangle.west,\n    rectangle.south,\n    0.0,\n    scratchCorners[3],\n  );\n\n  // Determine which tile the bounding rectangle is in\n  let lastLevelX = 0,\n    lastLevelY = 0;\n  let currentX = 0,\n    currentY = 0;\n  const maxLevel = ApproximateTerrainHeights._terrainHeightsMaxLevel;\n  let i;\n  for (i = 0; i <= maxLevel; ++i) {\n    let failed = false;\n    for (let j = 0; j < 4; ++j) {\n      const corner = scratchCorners[j];\n      tilingScheme.positionToTileXY(corner, i, scratchTileXY);\n      if (j === 0) {\n        currentX = scratchTileXY.x;\n        currentY = scratchTileXY.y;\n      } else if (currentX !== scratchTileXY.x || currentY !== scratchTileXY.y) {\n        failed = true;\n        break;\n      }\n    }\n\n    if (failed) {\n      break;\n    }\n\n    lastLevelX = currentX;\n    lastLevelY = currentY;\n  }\n\n  if (i === 0) {\n    return undefined;\n  }\n\n  return {\n    x: lastLevelX,\n    y: lastLevelY,\n    level: i > maxLevel ? maxLevel : i - 1,\n  };\n}\n\nApproximateTerrainHeights._terrainHeightsMaxLevel = 6;\nApproximateTerrainHeights._defaultMaxTerrainHeight = 9000.0;\nApproximateTerrainHeights._defaultMinTerrainHeight = -100000.0;\nApproximateTerrainHeights._terrainHeights = undefined;\nApproximateTerrainHeights._initPromise = undefined;\n\nObject.defineProperties(ApproximateTerrainHeights, {\n  /**\n   * Determines if the terrain heights are initialized and ready to use. To initialize the terrain heights,\n   * call {@link ApproximateTerrainHeights#initialize} and wait for the returned promise to resolve.\n   * @type {boolean}\n   * @readonly\n   * @memberof ApproximateTerrainHeights\n   */\n  initialized: {\n    get: function () {\n      return defined(ApproximateTerrainHeights._terrainHeights);\n    },\n  },\n});\nexport default ApproximateTerrainHeights;\n"],"names":["scratchDiagonalCartesianNE","scratchDiagonalCartesianSW","scratchDiagonalCartographic","scratchCenterCartesian","scratchSurfaceCartesian","scratchBoundingSphere","tilingScheme","scratchCorners","scratchTileXY","ApproximateTerrainHeights","initialize","initPromise","_initPromise","fetchJson","then","json","_terrainHeights","getMinimumMaximumHeights","rectangle","ellipsoid","defined","default","xyLevel","getTileXYLevel","minTerrainHeight","_defaultMinTerrainHeight","maxTerrainHeight","_defaultMaxTerrainHeight","key","level","x","y","heights","cartographicToCartesian","northeast","southwest","midpoint","surfacePosition","scaleToGeodeticSurface","distance","Math","min","max","minimumTerrainHeight","maximumTerrainHeight","getBoundingSphere","result","fromRectangle3D","union","fromRadians","east","north","west","south","lastLevelX","lastLevelY","currentX","currentY","maxLevel","_terrainHeightsMaxLevel","i","failed","j","corner","positionToTileXY","undefined","Object","defineProperties","initialized","get"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 17925, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/WebGLConstants.js"],"sourcesContent":["/**\n * Enum containing WebGL Constant values by name.\n * for use without an active WebGL context, or in cases where certain constants are unavailable using the WebGL context\n * (For example, in [Safari 9]{@link https://github.com/CesiumGS/cesium/issues/2989}).\n *\n * These match the constants from the [WebGL 1.0]{@link https://www.khronos.org/registry/webgl/specs/latest/1.0/}\n * and [WebGL 2.0]{@link https://www.khronos.org/registry/webgl/specs/latest/2.0/}\n * specifications.\n *\n * @enum {number}\n */\nconst WebGLConstants = {\n  DEPTH_BUFFER_BIT: 0x00000100,\n  STENCIL_BUFFER_BIT: 0x00000400,\n  COLOR_BUFFER_BIT: 0x00004000,\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n  ZERO: 0,\n  ONE: 1,\n  SRC_COLOR: 0x0300,\n  ONE_MINUS_SRC_COLOR: 0x0301,\n  SRC_ALPHA: 0x0302,\n  ONE_MINUS_SRC_ALPHA: 0x0303,\n  DST_ALPHA: 0x0304,\n  ONE_MINUS_DST_ALPHA: 0x0305,\n  DST_COLOR: 0x0306,\n  ONE_MINUS_DST_COLOR: 0x0307,\n  SRC_ALPHA_SATURATE: 0x0308,\n  FUNC_ADD: 0x8006,\n  BLEND_EQUATION: 0x8009,\n  BLEND_EQUATION_RGB: 0x8009, // same as BLEND_EQUATION\n  BLEND_EQUATION_ALPHA: 0x883d,\n  FUNC_SUBTRACT: 0x800a,\n  FUNC_REVERSE_SUBTRACT: 0x800b,\n  BLEND_DST_RGB: 0x80c8,\n  BLEND_SRC_RGB: 0x80c9,\n  BLEND_DST_ALPHA: 0x80ca,\n  BLEND_SRC_ALPHA: 0x80cb,\n  CONSTANT_COLOR: 0x8001,\n  ONE_MINUS_CONSTANT_COLOR: 0x8002,\n  CONSTANT_ALPHA: 0x8003,\n  ONE_MINUS_CONSTANT_ALPHA: 0x8004,\n  BLEND_COLOR: 0x8005,\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n  ARRAY_BUFFER_BINDING: 0x8894,\n  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895,\n  STREAM_DRAW: 0x88e0,\n  STATIC_DRAW: 0x88e4,\n  DYNAMIC_DRAW: 0x88e8,\n  BUFFER_SIZE: 0x8764,\n  BUFFER_USAGE: 0x8765,\n  CURRENT_VERTEX_ATTRIB: 0x8626,\n  FRONT: 0x0404,\n  BACK: 0x0405,\n  FRONT_AND_BACK: 0x0408,\n  CULL_FACE: 0x0b44,\n  BLEND: 0x0be2,\n  DITHER: 0x0bd0,\n  STENCIL_TEST: 0x0b90,\n  DEPTH_TEST: 0x0b71,\n  SCISSOR_TEST: 0x0c11,\n  POLYGON_OFFSET_FILL: 0x8037,\n  SAMPLE_ALPHA_TO_COVERAGE: 0x809e,\n  SAMPLE_COVERAGE: 0x80a0,\n  NO_ERROR: 0,\n  INVALID_ENUM: 0x0500,\n  INVALID_VALUE: 0x0501,\n  INVALID_OPERATION: 0x0502,\n  OUT_OF_MEMORY: 0x0505,\n  CW: 0x0900,\n  CCW: 0x0901,\n  LINE_WIDTH: 0x0b21,\n  ALIASED_POINT_SIZE_RANGE: 0x846d,\n  ALIASED_LINE_WIDTH_RANGE: 0x846e,\n  CULL_FACE_MODE: 0x0b45,\n  FRONT_FACE: 0x0b46,\n  DEPTH_RANGE: 0x0b70,\n  DEPTH_WRITEMASK: 0x0b72,\n  DEPTH_CLEAR_VALUE: 0x0b73,\n  DEPTH_FUNC: 0x0b74,\n  STENCIL_CLEAR_VALUE: 0x0b91,\n  STENCIL_FUNC: 0x0b92,\n  STENCIL_FAIL: 0x0b94,\n  STENCIL_PASS_DEPTH_FAIL: 0x0b95,\n  STENCIL_PASS_DEPTH_PASS: 0x0b96,\n  STENCIL_REF: 0x0b97,\n  STENCIL_VALUE_MASK: 0x0b93,\n  STENCIL_WRITEMASK: 0x0b98,\n  STENCIL_BACK_FUNC: 0x8800,\n  STENCIL_BACK_FAIL: 0x8801,\n  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802,\n  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803,\n  STENCIL_BACK_REF: 0x8ca3,\n  STENCIL_BACK_VALUE_MASK: 0x8ca4,\n  STENCIL_BACK_WRITEMASK: 0x8ca5,\n  VIEWPORT: 0x0ba2,\n  SCISSOR_BOX: 0x0c10,\n  COLOR_CLEAR_VALUE: 0x0c22,\n  COLOR_WRITEMASK: 0x0c23,\n  UNPACK_ALIGNMENT: 0x0cf5,\n  PACK_ALIGNMENT: 0x0d05,\n  MAX_TEXTURE_SIZE: 0x0d33,\n  MAX_VIEWPORT_DIMS: 0x0d3a,\n  SUBPIXEL_BITS: 0x0d50,\n  RED_BITS: 0x0d52,\n  GREEN_BITS: 0x0d53,\n  BLUE_BITS: 0x0d54,\n  ALPHA_BITS: 0x0d55,\n  DEPTH_BITS: 0x0d56,\n  STENCIL_BITS: 0x0d57,\n  POLYGON_OFFSET_UNITS: 0x2a00,\n  POLYGON_OFFSET_FACTOR: 0x8038,\n  TEXTURE_BINDING_2D: 0x8069,\n  SAMPLE_BUFFERS: 0x80a8,\n  SAMPLES: 0x80a9,\n  SAMPLE_COVERAGE_VALUE: 0x80aa,\n  SAMPLE_COVERAGE_INVERT: 0x80ab,\n  COMPRESSED_TEXTURE_FORMATS: 0x86a3,\n  DONT_CARE: 0x1100,\n  FASTEST: 0x1101,\n  NICEST: 0x1102,\n  GENERATE_MIPMAP_HINT: 0x8192,\n  BYTE: 0x1400,\n  UNSIGNED_BYTE: 0x1401,\n  SHORT: 0x1402,\n  UNSIGNED_SHORT: 0x1403,\n  INT: 0x1404,\n  UNSIGNED_INT: 0x1405,\n  FLOAT: 0x1406,\n  DEPTH_COMPONENT: 0x1902,\n  ALPHA: 0x1906,\n  RGB: 0x1907,\n  RGBA: 0x1908,\n  LUMINANCE: 0x1909,\n  LUMINANCE_ALPHA: 0x190a,\n  UNSIGNED_SHORT_4_4_4_4: 0x8033,\n  UNSIGNED_SHORT_5_5_5_1: 0x8034,\n  UNSIGNED_SHORT_5_6_5: 0x8363,\n  FRAGMENT_SHADER: 0x8b30,\n  VERTEX_SHADER: 0x8b31,\n  MAX_VERTEX_ATTRIBS: 0x8869,\n  MAX_VERTEX_UNIFORM_VECTORS: 0x8dfb,\n  MAX_VARYING_VECTORS: 0x8dfc,\n  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8b4d,\n  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8b4c,\n  MAX_TEXTURE_IMAGE_UNITS: 0x8872,\n  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8dfd,\n  SHADER_TYPE: 0x8b4f,\n  DELETE_STATUS: 0x8b80,\n  LINK_STATUS: 0x8b82,\n  VALIDATE_STATUS: 0x8b83,\n  ATTACHED_SHADERS: 0x8b85,\n  ACTIVE_UNIFORMS: 0x8b86,\n  ACTIVE_ATTRIBUTES: 0x8b89,\n  SHADING_LANGUAGE_VERSION: 0x8b8c,\n  CURRENT_PROGRAM: 0x8b8d,\n  NEVER: 0x0200,\n  LESS: 0x0201,\n  EQUAL: 0x0202,\n  LEQUAL: 0x0203,\n  GREATER: 0x0204,\n  NOTEQUAL: 0x0205,\n  GEQUAL: 0x0206,\n  ALWAYS: 0x0207,\n  KEEP: 0x1e00,\n  REPLACE: 0x1e01,\n  INCR: 0x1e02,\n  DECR: 0x1e03,\n  INVERT: 0x150a,\n  INCR_WRAP: 0x8507,\n  DECR_WRAP: 0x8508,\n  VENDOR: 0x1f00,\n  RENDERER: 0x1f01,\n  VERSION: 0x1f02,\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n  TEXTURE_2D: 0x0de1,\n  TEXTURE: 0x1702,\n  TEXTURE_CUBE_MAP: 0x8513,\n  TEXTURE_BINDING_CUBE_MAP: 0x8514,\n  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515,\n  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516,\n  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517,\n  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518,\n  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519,\n  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851a,\n  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851c,\n  TEXTURE0: 0x84c0,\n  TEXTURE1: 0x84c1,\n  TEXTURE2: 0x84c2,\n  TEXTURE3: 0x84c3,\n  TEXTURE4: 0x84c4,\n  TEXTURE5: 0x84c5,\n  TEXTURE6: 0x84c6,\n  TEXTURE7: 0x84c7,\n  TEXTURE8: 0x84c8,\n  TEXTURE9: 0x84c9,\n  TEXTURE10: 0x84ca,\n  TEXTURE11: 0x84cb,\n  TEXTURE12: 0x84cc,\n  TEXTURE13: 0x84cd,\n  TEXTURE14: 0x84ce,\n  TEXTURE15: 0x84cf,\n  TEXTURE16: 0x84d0,\n  TEXTURE17: 0x84d1,\n  TEXTURE18: 0x84d2,\n  TEXTURE19: 0x84d3,\n  TEXTURE20: 0x84d4,\n  TEXTURE21: 0x84d5,\n  TEXTURE22: 0x84d6,\n  TEXTURE23: 0x84d7,\n  TEXTURE24: 0x84d8,\n  TEXTURE25: 0x84d9,\n  TEXTURE26: 0x84da,\n  TEXTURE27: 0x84db,\n  TEXTURE28: 0x84dc,\n  TEXTURE29: 0x84dd,\n  TEXTURE30: 0x84de,\n  TEXTURE31: 0x84df,\n  ACTIVE_TEXTURE: 0x84e0,\n  REPEAT: 0x2901,\n  CLAMP_TO_EDGE: 0x812f,\n  MIRRORED_REPEAT: 0x8370,\n  FLOAT_VEC2: 0x8b50,\n  FLOAT_VEC3: 0x8b51,\n  FLOAT_VEC4: 0x8b52,\n  INT_VEC2: 0x8b53,\n  INT_VEC3: 0x8b54,\n  INT_VEC4: 0x8b55,\n  BOOL: 0x8b56,\n  BOOL_VEC2: 0x8b57,\n  BOOL_VEC3: 0x8b58,\n  BOOL_VEC4: 0x8b59,\n  FLOAT_MAT2: 0x8b5a,\n  FLOAT_MAT3: 0x8b5b,\n  FLOAT_MAT4: 0x8b5c,\n  SAMPLER_2D: 0x8b5e,\n  SAMPLER_CUBE: 0x8b60,\n  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622,\n  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623,\n  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624,\n  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625,\n  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886a,\n  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645,\n  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889f,\n  IMPLEMENTATION_COLOR_READ_TYPE: 0x8b9a,\n  IMPLEMENTATION_COLOR_READ_FORMAT: 0x8b9b,\n  COMPILE_STATUS: 0x8b81,\n  LOW_FLOAT: 0x8df0,\n  MEDIUM_FLOAT: 0x8df1,\n  HIGH_FLOAT: 0x8df2,\n  LOW_INT: 0x8df3,\n  MEDIUM_INT: 0x8df4,\n  HIGH_INT: 0x8df5,\n  FRAMEBUFFER: 0x8d40,\n  RENDERBUFFER: 0x8d41,\n  RGBA4: 0x8056,\n  RGB5_A1: 0x8057,\n  RGB565: 0x8d62,\n  DEPTH_COMPONENT16: 0x81a5,\n  STENCIL_INDEX: 0x1901,\n  STENCIL_INDEX8: 0x8d48,\n  DEPTH_STENCIL: 0x84f9,\n  RENDERBUFFER_WIDTH: 0x8d42,\n  RENDERBUFFER_HEIGHT: 0x8d43,\n  RENDERBUFFER_INTERNAL_FORMAT: 0x8d44,\n  RENDERBUFFER_RED_SIZE: 0x8d50,\n  RENDERBUFFER_GREEN_SIZE: 0x8d51,\n  RENDERBUFFER_BLUE_SIZE: 0x8d52,\n  RENDERBUFFER_ALPHA_SIZE: 0x8d53,\n  RENDERBUFFER_DEPTH_SIZE: 0x8d54,\n  RENDERBUFFER_STENCIL_SIZE: 0x8d55,\n  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8cd0,\n  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8cd1,\n  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8cd2,\n  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8cd3,\n  COLOR_ATTACHMENT0: 0x8ce0,\n  DEPTH_ATTACHMENT: 0x8d00,\n  STENCIL_ATTACHMENT: 0x8d20,\n  DEPTH_STENCIL_ATTACHMENT: 0x821a,\n  NONE: 0,\n  FRAMEBUFFER_COMPLETE: 0x8cd5,\n  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8cd6,\n  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8cd7,\n  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8cd9,\n  FRAMEBUFFER_UNSUPPORTED: 0x8cdd,\n  FRAMEBUFFER_BINDING: 0x8ca6,\n  RENDERBUFFER_BINDING: 0x8ca7,\n  MAX_RENDERBUFFER_SIZE: 0x84e8,\n  INVALID_FRAMEBUFFER_OPERATION: 0x0506,\n  UNPACK_FLIP_Y_WEBGL: 0x9240,\n  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241,\n  CONTEXT_LOST_WEBGL: 0x9242,\n  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243,\n  BROWSER_DEFAULT_WEBGL: 0x9244,\n\n  // WEBGL_compressed_texture_s3tc\n  COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83f0,\n  COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83f1,\n  COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83f2,\n  COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83f3,\n\n  // WEBGL_compressed_texture_pvrtc\n  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8c00,\n  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8c01,\n  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8c02,\n  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8c03,\n\n  // WEBGL_compressed_texture_astc\n  COMPRESSED_RGBA_ASTC_4x4_WEBGL: 0x93b0,\n\n  // WEBGL_compressed_texture_etc1\n  COMPRESSED_RGB_ETC1_WEBGL: 0x8d64,\n\n  // EXT_texture_compression_bptc\n  COMPRESSED_RGBA_BPTC_UNORM: 0x8e8c,\n\n  // EXT_color_buffer_half_float\n  HALF_FLOAT_OES: 0x8d61,\n\n  // Desktop OpenGL\n  DOUBLE: 0x140a,\n\n  // WebGL 2\n  READ_BUFFER: 0x0c02,\n  UNPACK_ROW_LENGTH: 0x0cf2,\n  UNPACK_SKIP_ROWS: 0x0cf3,\n  UNPACK_SKIP_PIXELS: 0x0cf4,\n  PACK_ROW_LENGTH: 0x0d02,\n  PACK_SKIP_ROWS: 0x0d03,\n  PACK_SKIP_PIXELS: 0x0d04,\n  COLOR: 0x1800,\n  DEPTH: 0x1801,\n  STENCIL: 0x1802,\n  RED: 0x1903,\n  RGB8: 0x8051,\n  RGBA8: 0x8058,\n  RGB10_A2: 0x8059,\n  TEXTURE_BINDING_3D: 0x806a,\n  UNPACK_SKIP_IMAGES: 0x806d,\n  UNPACK_IMAGE_HEIGHT: 0x806e,\n  TEXTURE_3D: 0x806f,\n  TEXTURE_WRAP_R: 0x8072,\n  MAX_3D_TEXTURE_SIZE: 0x8073,\n  UNSIGNED_INT_2_10_10_10_REV: 0x8368,\n  MAX_ELEMENTS_VERTICES: 0x80e8,\n  MAX_ELEMENTS_INDICES: 0x80e9,\n  TEXTURE_MIN_LOD: 0x813a,\n  TEXTURE_MAX_LOD: 0x813b,\n  TEXTURE_BASE_LEVEL: 0x813c,\n  TEXTURE_MAX_LEVEL: 0x813d,\n  MIN: 0x8007,\n  MAX: 0x8008,\n  DEPTH_COMPONENT24: 0x81a6,\n  MAX_TEXTURE_LOD_BIAS: 0x84fd,\n  TEXTURE_COMPARE_MODE: 0x884c,\n  TEXTURE_COMPARE_FUNC: 0x884d,\n  CURRENT_QUERY: 0x8865,\n  QUERY_RESULT: 0x8866,\n  QUERY_RESULT_AVAILABLE: 0x8867,\n  STREAM_READ: 0x88e1,\n  STREAM_COPY: 0x88e2,\n  STATIC_READ: 0x88e5,\n  STATIC_COPY: 0x88e6,\n  DYNAMIC_READ: 0x88e9,\n  DYNAMIC_COPY: 0x88ea,\n  MAX_DRAW_BUFFERS: 0x8824,\n  DRAW_BUFFER0: 0x8825,\n  DRAW_BUFFER1: 0x8826,\n  DRAW_BUFFER2: 0x8827,\n  DRAW_BUFFER3: 0x8828,\n  DRAW_BUFFER4: 0x8829,\n  DRAW_BUFFER5: 0x882a,\n  DRAW_BUFFER6: 0x882b,\n  DRAW_BUFFER7: 0x882c,\n  DRAW_BUFFER8: 0x882d,\n  DRAW_BUFFER9: 0x882e,\n  DRAW_BUFFER10: 0x882f,\n  DRAW_BUFFER11: 0x8830,\n  DRAW_BUFFER12: 0x8831,\n  DRAW_BUFFER13: 0x8832,\n  DRAW_BUFFER14: 0x8833,\n  DRAW_BUFFER15: 0x8834,\n  MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8b49,\n  MAX_VERTEX_UNIFORM_COMPONENTS: 0x8b4a,\n  SAMPLER_3D: 0x8b5f,\n  SAMPLER_2D_SHADOW: 0x8b62,\n  FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8b8b,\n  PIXEL_PACK_BUFFER: 0x88eb,\n  PIXEL_UNPACK_BUFFER: 0x88ec,\n  PIXEL_PACK_BUFFER_BINDING: 0x88ed,\n  PIXEL_UNPACK_BUFFER_BINDING: 0x88ef,\n  FLOAT_MAT2x3: 0x8b65,\n  FLOAT_MAT2x4: 0x8b66,\n  FLOAT_MAT3x2: 0x8b67,\n  FLOAT_MAT3x4: 0x8b68,\n  FLOAT_MAT4x2: 0x8b69,\n  FLOAT_MAT4x3: 0x8b6a,\n  SRGB: 0x8c40,\n  SRGB8: 0x8c41,\n  SRGB8_ALPHA8: 0x8c43,\n  COMPARE_REF_TO_TEXTURE: 0x884e,\n  RGBA32F: 0x8814,\n  RGB32F: 0x8815,\n  RGBA16F: 0x881a,\n  RGB16F: 0x881b,\n  VERTEX_ATTRIB_ARRAY_INTEGER: 0x88fd,\n  MAX_ARRAY_TEXTURE_LAYERS: 0x88ff,\n  MIN_PROGRAM_TEXEL_OFFSET: 0x8904,\n  MAX_PROGRAM_TEXEL_OFFSET: 0x8905,\n  MAX_VARYING_COMPONENTS: 0x8b4b,\n  TEXTURE_2D_ARRAY: 0x8c1a,\n  TEXTURE_BINDING_2D_ARRAY: 0x8c1d,\n  R11F_G11F_B10F: 0x8c3a,\n  UNSIGNED_INT_10F_11F_11F_REV: 0x8c3b,\n  RGB9_E5: 0x8c3d,\n  UNSIGNED_INT_5_9_9_9_REV: 0x8c3e,\n  TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8c7f,\n  MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8c80,\n  TRANSFORM_FEEDBACK_VARYINGS: 0x8c83,\n  TRANSFORM_FEEDBACK_BUFFER_START: 0x8c84,\n  TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8c85,\n  TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8c88,\n  RASTERIZER_DISCARD: 0x8c89,\n  MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8c8a,\n  MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8c8b,\n  INTERLEAVED_ATTRIBS: 0x8c8c,\n  SEPARATE_ATTRIBS: 0x8c8d,\n  TRANSFORM_FEEDBACK_BUFFER: 0x8c8e,\n  TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8c8f,\n  RGBA32UI: 0x8d70,\n  RGB32UI: 0x8d71,\n  RGBA16UI: 0x8d76,\n  RGB16UI: 0x8d77,\n  RGBA8UI: 0x8d7c,\n  RGB8UI: 0x8d7d,\n  RGBA32I: 0x8d82,\n  RGB32I: 0x8d83,\n  RGBA16I: 0x8d88,\n  RGB16I: 0x8d89,\n  RGBA8I: 0x8d8e,\n  RGB8I: 0x8d8f,\n  RED_INTEGER: 0x8d94,\n  RGB_INTEGER: 0x8d98,\n  RGBA_INTEGER: 0x8d99,\n  SAMPLER_2D_ARRAY: 0x8dc1,\n  SAMPLER_2D_ARRAY_SHADOW: 0x8dc4,\n  SAMPLER_CUBE_SHADOW: 0x8dc5,\n  UNSIGNED_INT_VEC2: 0x8dc6,\n  UNSIGNED_INT_VEC3: 0x8dc7,\n  UNSIGNED_INT_VEC4: 0x8dc8,\n  INT_SAMPLER_2D: 0x8dca,\n  INT_SAMPLER_3D: 0x8dcb,\n  INT_SAMPLER_CUBE: 0x8dcc,\n  INT_SAMPLER_2D_ARRAY: 0x8dcf,\n  UNSIGNED_INT_SAMPLER_2D: 0x8dd2,\n  UNSIGNED_INT_SAMPLER_3D: 0x8dd3,\n  UNSIGNED_INT_SAMPLER_CUBE: 0x8dd4,\n  UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8dd7,\n  DEPTH_COMPONENT32F: 0x8cac,\n  DEPTH32F_STENCIL8: 0x8cad,\n  FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8dad,\n  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210,\n  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211,\n  FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212,\n  FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213,\n  FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214,\n  FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215,\n  FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216,\n  FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217,\n  FRAMEBUFFER_DEFAULT: 0x8218,\n  UNSIGNED_INT_24_8: 0x84fa,\n  DEPTH24_STENCIL8: 0x88f0,\n  UNSIGNED_NORMALIZED: 0x8c17,\n  DRAW_FRAMEBUFFER_BINDING: 0x8ca6, // Same as FRAMEBUFFER_BINDING\n  READ_FRAMEBUFFER: 0x8ca8,\n  DRAW_FRAMEBUFFER: 0x8ca9,\n  READ_FRAMEBUFFER_BINDING: 0x8caa,\n  RENDERBUFFER_SAMPLES: 0x8cab,\n  FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8cd4,\n  MAX_COLOR_ATTACHMENTS: 0x8cdf,\n  COLOR_ATTACHMENT1: 0x8ce1,\n  COLOR_ATTACHMENT2: 0x8ce2,\n  COLOR_ATTACHMENT3: 0x8ce3,\n  COLOR_ATTACHMENT4: 0x8ce4,\n  COLOR_ATTACHMENT5: 0x8ce5,\n  COLOR_ATTACHMENT6: 0x8ce6,\n  COLOR_ATTACHMENT7: 0x8ce7,\n  COLOR_ATTACHMENT8: 0x8ce8,\n  COLOR_ATTACHMENT9: 0x8ce9,\n  COLOR_ATTACHMENT10: 0x8cea,\n  COLOR_ATTACHMENT11: 0x8ceb,\n  COLOR_ATTACHMENT12: 0x8cec,\n  COLOR_ATTACHMENT13: 0x8ced,\n  COLOR_ATTACHMENT14: 0x8cee,\n  COLOR_ATTACHMENT15: 0x8cef,\n  FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8d56,\n  MAX_SAMPLES: 0x8d57,\n  HALF_FLOAT: 0x140b,\n  RG: 0x8227,\n  RG_INTEGER: 0x8228,\n  R8: 0x8229,\n  RG8: 0x822b,\n  R16F: 0x822d,\n  R32F: 0x822e,\n  RG16F: 0x822f,\n  RG32F: 0x8230,\n  R8I: 0x8231,\n  R8UI: 0x8232,\n  R16I: 0x8233,\n  R16UI: 0x8234,\n  R32I: 0x8235,\n  R32UI: 0x8236,\n  RG8I: 0x8237,\n  RG8UI: 0x8238,\n  RG16I: 0x8239,\n  RG16UI: 0x823a,\n  RG32I: 0x823b,\n  RG32UI: 0x823c,\n  VERTEX_ARRAY_BINDING: 0x85b5,\n  R8_SNORM: 0x8f94,\n  RG8_SNORM: 0x8f95,\n  RGB8_SNORM: 0x8f96,\n  RGBA8_SNORM: 0x8f97,\n  SIGNED_NORMALIZED: 0x8f9c,\n  COPY_READ_BUFFER: 0x8f36,\n  COPY_WRITE_BUFFER: 0x8f37,\n  COPY_READ_BUFFER_BINDING: 0x8f36, // Same as COPY_READ_BUFFER\n  COPY_WRITE_BUFFER_BINDING: 0x8f37, // Same as COPY_WRITE_BUFFER\n  UNIFORM_BUFFER: 0x8a11,\n  UNIFORM_BUFFER_BINDING: 0x8a28,\n  UNIFORM_BUFFER_START: 0x8a29,\n  UNIFORM_BUFFER_SIZE: 0x8a2a,\n  MAX_VERTEX_UNIFORM_BLOCKS: 0x8a2b,\n  MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8a2d,\n  MAX_COMBINED_UNIFORM_BLOCKS: 0x8a2e,\n  MAX_UNIFORM_BUFFER_BINDINGS: 0x8a2f,\n  MAX_UNIFORM_BLOCK_SIZE: 0x8a30,\n  MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8a31,\n  MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8a33,\n  UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8a34,\n  ACTIVE_UNIFORM_BLOCKS: 0x8a36,\n  UNIFORM_TYPE: 0x8a37,\n  UNIFORM_SIZE: 0x8a38,\n  UNIFORM_BLOCK_INDEX: 0x8a3a,\n  UNIFORM_OFFSET: 0x8a3b,\n  UNIFORM_ARRAY_STRIDE: 0x8a3c,\n  UNIFORM_MATRIX_STRIDE: 0x8a3d,\n  UNIFORM_IS_ROW_MAJOR: 0x8a3e,\n  UNIFORM_BLOCK_BINDING: 0x8a3f,\n  UNIFORM_BLOCK_DATA_SIZE: 0x8a40,\n  UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8a42,\n  UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8a43,\n  UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8a44,\n  UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8a46,\n  INVALID_INDEX: 0xffffffff,\n  MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122,\n  MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125,\n  MAX_SERVER_WAIT_TIMEOUT: 0x9111,\n  OBJECT_TYPE: 0x9112,\n  SYNC_CONDITION: 0x9113,\n  SYNC_STATUS: 0x9114,\n  SYNC_FLAGS: 0x9115,\n  SYNC_FENCE: 0x9116,\n  SYNC_GPU_COMMANDS_COMPLETE: 0x9117,\n  UNSIGNALED: 0x9118,\n  SIGNALED: 0x9119,\n  ALREADY_SIGNALED: 0x911a,\n  TIMEOUT_EXPIRED: 0x911b,\n  CONDITION_SATISFIED: 0x911c,\n  WAIT_FAILED: 0x911d,\n  SYNC_FLUSH_COMMANDS_BIT: 0x00000001,\n  VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88fe,\n  ANY_SAMPLES_PASSED: 0x8c2f,\n  ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8d6a,\n  SAMPLER_BINDING: 0x8919,\n  RGB10_A2UI: 0x906f,\n  INT_2_10_10_10_REV: 0x8d9f,\n  TRANSFORM_FEEDBACK: 0x8e22,\n  TRANSFORM_FEEDBACK_PAUSED: 0x8e23,\n  TRANSFORM_FEEDBACK_ACTIVE: 0x8e24,\n  TRANSFORM_FEEDBACK_BINDING: 0x8e25,\n  COMPRESSED_R11_EAC: 0x9270,\n  COMPRESSED_SIGNED_R11_EAC: 0x9271,\n  COMPRESSED_RG11_EAC: 0x9272,\n  COMPRESSED_SIGNED_RG11_EAC: 0x9273,\n  COMPRESSED_RGB8_ETC2: 0x9274,\n  COMPRESSED_SRGB8_ETC2: 0x9275,\n  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9276,\n  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9277,\n  COMPRESSED_RGBA8_ETC2_EAC: 0x9278,\n  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9279,\n  TEXTURE_IMMUTABLE_FORMAT: 0x912f,\n  MAX_ELEMENT_INDEX: 0x8d6b,\n  TEXTURE_IMMUTABLE_LEVELS: 0x82df,\n\n  // Extensions\n  MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84ff,\n};\nexport default Object.freeze(WebGLConstants);\n"],"names":["WebGLConstants","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","COLOR_BUFFER_BIT","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","ZERO","ONE","SRC_COLOR","ONE_MINUS_SRC_COLOR","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","DST_ALPHA","ONE_MINUS_DST_ALPHA","DST_COLOR","ONE_MINUS_DST_COLOR","SRC_ALPHA_SATURATE","FUNC_ADD","BLEND_EQUATION","BLEND_EQUATION_RGB","BLEND_EQUATION_ALPHA","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","BLEND_DST_RGB","BLEND_SRC_RGB","BLEND_DST_ALPHA","BLEND_SRC_ALPHA","CONSTANT_COLOR","ONE_MINUS_CONSTANT_COLOR","CONSTANT_ALPHA","ONE_MINUS_CONSTANT_ALPHA","BLEND_COLOR","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","ARRAY_BUFFER_BINDING","ELEMENT_ARRAY_BUFFER_BINDING","STREAM_DRAW","STATIC_DRAW","DYNAMIC_DRAW","BUFFER_SIZE","BUFFER_USAGE","CURRENT_VERTEX_ATTRIB","FRONT","BACK","FRONT_AND_BACK","CULL_FACE","BLEND","DITHER","STENCIL_TEST","DEPTH_TEST","SCISSOR_TEST","POLYGON_OFFSET_FILL","SAMPLE_ALPHA_TO_COVERAGE","SAMPLE_COVERAGE","NO_ERROR","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","OUT_OF_MEMORY","CW","CCW","LINE_WIDTH","ALIASED_POINT_SIZE_RANGE","ALIASED_LINE_WIDTH_RANGE","CULL_FACE_MODE","FRONT_FACE","DEPTH_RANGE","DEPTH_WRITEMASK","DEPTH_CLEAR_VALUE","DEPTH_FUNC","STENCIL_CLEAR_VALUE","STENCIL_FUNC","STENCIL_FAIL","STENCIL_PASS_DEPTH_FAIL","STENCIL_PASS_DEPTH_PASS","STENCIL_REF","STENCIL_VALUE_MASK","STENCIL_WRITEMASK","STENCIL_BACK_FUNC","STENCIL_BACK_FAIL","STENCIL_BACK_PASS_DEPTH_FAIL","STENCIL_BACK_PASS_DEPTH_PASS","STENCIL_BACK_REF","STENCIL_BACK_VALUE_MASK","STENCIL_BACK_WRITEMASK","VIEWPORT","SCISSOR_BOX","COLOR_CLEAR_VALUE","COLOR_WRITEMASK","UNPACK_ALIGNMENT","PACK_ALIGNMENT","MAX_TEXTURE_SIZE","MAX_VIEWPORT_DIMS","SUBPIXEL_BITS","RED_BITS","GREEN_BITS","BLUE_BITS","ALPHA_BITS","DEPTH_BITS","STENCIL_BITS","POLYGON_OFFSET_UNITS","POLYGON_OFFSET_FACTOR","TEXTURE_BINDING_2D","SAMPLE_BUFFERS","SAMPLES","SAMPLE_COVERAGE_VALUE","SAMPLE_COVERAGE_INVERT","COMPRESSED_TEXTURE_FORMATS","DONT_CARE","FASTEST","NICEST","GENERATE_MIPMAP_HINT","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","FLOAT","DEPTH_COMPONENT","ALPHA","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","FRAGMENT_SHADER","VERTEX_SHADER","MAX_VERTEX_ATTRIBS","MAX_VERTEX_UNIFORM_VECTORS","MAX_VARYING_VECTORS","MAX_COMBINED_TEXTURE_IMAGE_UNITS","MAX_VERTEX_TEXTURE_IMAGE_UNITS","MAX_TEXTURE_IMAGE_UNITS","MAX_FRAGMENT_UNIFORM_VECTORS","SHADER_TYPE","DELETE_STATUS","LINK_STATUS","VALIDATE_STATUS","ATTACHED_SHADERS","ACTIVE_UNIFORMS","ACTIVE_ATTRIBUTES","SHADING_LANGUAGE_VERSION","CURRENT_PROGRAM","NEVER","LESS","EQUAL","LEQUAL","GREATER","NOTEQUAL","GEQUAL","ALWAYS","KEEP","REPLACE","INCR","DECR","INVERT","INCR_WRAP","DECR_WRAP","VENDOR","RENDERER","VERSION","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXTURE_2D","TEXTURE","TEXTURE_CUBE_MAP","TEXTURE_BINDING_CUBE_MAP","TEXTURE_CUBE_MAP_POSITIVE_X","TEXTURE_CUBE_MAP_NEGATIVE_X","TEXTURE_CUBE_MAP_POSITIVE_Y","TEXTURE_CUBE_MAP_NEGATIVE_Y","TEXTURE_CUBE_MAP_POSITIVE_Z","TEXTURE_CUBE_MAP_NEGATIVE_Z","MAX_CUBE_MAP_TEXTURE_SIZE","TEXTURE0","TEXTURE1","TEXTURE2","TEXTURE3","TEXTURE4","TEXTURE5","TEXTURE6","TEXTURE7","TEXTURE8","TEXTURE9","TEXTURE10","TEXTURE11","TEXTURE12","TEXTURE13","TEXTURE14","TEXTURE15","TEXTURE16","TEXTURE17","TEXTURE18","TEXTURE19","TEXTURE20","TEXTURE21","TEXTURE22","TEXTURE23","TEXTURE24","TEXTURE25","TEXTURE26","TEXTURE27","TEXTURE28","TEXTURE29","TEXTURE30","TEXTURE31","ACTIVE_TEXTURE","REPEAT","CLAMP_TO_EDGE","MIRRORED_REPEAT","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","INT_VEC2","INT_VEC3","INT_VEC4","BOOL","BOOL_VEC2","BOOL_VEC3","BOOL_VEC4","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","SAMPLER_2D","SAMPLER_CUBE","VERTEX_ATTRIB_ARRAY_ENABLED","VERTEX_ATTRIB_ARRAY_SIZE","VERTEX_ATTRIB_ARRAY_STRIDE","VERTEX_ATTRIB_ARRAY_TYPE","VERTEX_ATTRIB_ARRAY_NORMALIZED","VERTEX_ATTRIB_ARRAY_POINTER","VERTEX_ATTRIB_ARRAY_BUFFER_BINDING","IMPLEMENTATION_COLOR_READ_TYPE","IMPLEMENTATION_COLOR_READ_FORMAT","COMPILE_STATUS","LOW_FLOAT","MEDIUM_FLOAT","HIGH_FLOAT","LOW_INT","MEDIUM_INT","HIGH_INT","FRAMEBUFFER","RENDERBUFFER","RGBA4","RGB5_A1","RGB565","DEPTH_COMPONENT16","STENCIL_INDEX","STENCIL_INDEX8","DEPTH_STENCIL","RENDERBUFFER_WIDTH","RENDERBUFFER_HEIGHT","RENDERBUFFER_INTERNAL_FORMAT","RENDERBUFFER_RED_SIZE","RENDERBUFFER_GREEN_SIZE","RENDERBUFFER_BLUE_SIZE","RENDERBUFFER_ALPHA_SIZE","RENDERBUFFER_DEPTH_SIZE","RENDERBUFFER_STENCIL_SIZE","FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE","FRAMEBUFFER_ATTACHMENT_OBJECT_NAME","FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL","FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE","COLOR_ATTACHMENT0","DEPTH_ATTACHMENT","STENCIL_ATTACHMENT","DEPTH_STENCIL_ATTACHMENT","NONE","FRAMEBUFFER_COMPLETE","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_UNSUPPORTED","FRAMEBUFFER_BINDING","RENDERBUFFER_BINDING","MAX_RENDERBUFFER_SIZE","INVALID_FRAMEBUFFER_OPERATION","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","CONTEXT_LOST_WEBGL","UNPACK_COLORSPACE_CONVERSION_WEBGL","BROWSER_DEFAULT_WEBGL","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_ASTC_4x4_WEBGL","COMPRESSED_RGB_ETC1_WEBGL","COMPRESSED_RGBA_BPTC_UNORM","HALF_FLOAT_OES","DOUBLE","READ_BUFFER","UNPACK_ROW_LENGTH","UNPACK_SKIP_ROWS","UNPACK_SKIP_PIXELS","PACK_ROW_LENGTH","PACK_SKIP_ROWS","PACK_SKIP_PIXELS","COLOR","DEPTH","STENCIL","RED","RGB8","RGBA8","RGB10_A2","TEXTURE_BINDING_3D","UNPACK_SKIP_IMAGES","UNPACK_IMAGE_HEIGHT","TEXTURE_3D","TEXTURE_WRAP_R","MAX_3D_TEXTURE_SIZE","UNSIGNED_INT_2_10_10_10_REV","MAX_ELEMENTS_VERTICES","MAX_ELEMENTS_INDICES","TEXTURE_MIN_LOD","TEXTURE_MAX_LOD","TEXTURE_BASE_LEVEL","TEXTURE_MAX_LEVEL","MIN","MAX","DEPTH_COMPONENT24","MAX_TEXTURE_LOD_BIAS","TEXTURE_COMPARE_MODE","TEXTURE_COMPARE_FUNC","CURRENT_QUERY","QUERY_RESULT","QUERY_RESULT_AVAILABLE","STREAM_READ","STREAM_COPY","STATIC_READ","STATIC_COPY","DYNAMIC_READ","DYNAMIC_COPY","MAX_DRAW_BUFFERS","DRAW_BUFFER0","DRAW_BUFFER1","DRAW_BUFFER2","DRAW_BUFFER3","DRAW_BUFFER4","DRAW_BUFFER5","DRAW_BUFFER6","DRAW_BUFFER7","DRAW_BUFFER8","DRAW_BUFFER9","DRAW_BUFFER10","DRAW_BUFFER11","DRAW_BUFFER12","DRAW_BUFFER13","DRAW_BUFFER14","DRAW_BUFFER15","MAX_FRAGMENT_UNIFORM_COMPONENTS","MAX_VERTEX_UNIFORM_COMPONENTS","SAMPLER_3D","SAMPLER_2D_SHADOW","FRAGMENT_SHADER_DERIVATIVE_HINT","PIXEL_PACK_BUFFER","PIXEL_UNPACK_BUFFER","PIXEL_PACK_BUFFER_BINDING","PIXEL_UNPACK_BUFFER_BINDING","FLOAT_MAT2x3","FLOAT_MAT2x4","FLOAT_MAT3x2","FLOAT_MAT3x4","FLOAT_MAT4x2","FLOAT_MAT4x3","SRGB","SRGB8","SRGB8_ALPHA8","COMPARE_REF_TO_TEXTURE","RGBA32F","RGB32F","RGBA16F","RGB16F","VERTEX_ATTRIB_ARRAY_INTEGER","MAX_ARRAY_TEXTURE_LAYERS","MIN_PROGRAM_TEXEL_OFFSET","MAX_PROGRAM_TEXEL_OFFSET","MAX_VARYING_COMPONENTS","TEXTURE_2D_ARRAY","TEXTURE_BINDING_2D_ARRAY","R11F_G11F_B10F","UNSIGNED_INT_10F_11F_11F_REV","RGB9_E5","UNSIGNED_INT_5_9_9_9_REV","TRANSFORM_FEEDBACK_BUFFER_MODE","MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS","TRANSFORM_FEEDBACK_VARYINGS","TRANSFORM_FEEDBACK_BUFFER_START","TRANSFORM_FEEDBACK_BUFFER_SIZE","TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN","RASTERIZER_DISCARD","MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS","MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS","INTERLEAVED_ATTRIBS","SEPARATE_ATTRIBS","TRANSFORM_FEEDBACK_BUFFER","TRANSFORM_FEEDBACK_BUFFER_BINDING","RGBA32UI","RGB32UI","RGBA16UI","RGB16UI","RGBA8UI","RGB8UI","RGBA32I","RGB32I","RGBA16I","RGB16I","RGBA8I","RGB8I","RED_INTEGER","RGB_INTEGER","RGBA_INTEGER","SAMPLER_2D_ARRAY","SAMPLER_2D_ARRAY_SHADOW","SAMPLER_CUBE_SHADOW","UNSIGNED_INT_VEC2","UNSIGNED_INT_VEC3","UNSIGNED_INT_VEC4","INT_SAMPLER_2D","INT_SAMPLER_3D","INT_SAMPLER_CUBE","INT_SAMPLER_2D_ARRAY","UNSIGNED_INT_SAMPLER_2D","UNSIGNED_INT_SAMPLER_3D","UNSIGNED_INT_SAMPLER_CUBE","UNSIGNED_INT_SAMPLER_2D_ARRAY","DEPTH_COMPONENT32F","DEPTH32F_STENCIL8","FLOAT_32_UNSIGNED_INT_24_8_REV","FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING","FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE","FRAMEBUFFER_ATTACHMENT_RED_SIZE","FRAMEBUFFER_ATTACHMENT_GREEN_SIZE","FRAMEBUFFER_ATTACHMENT_BLUE_SIZE","FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE","FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE","FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE","FRAMEBUFFER_DEFAULT","UNSIGNED_INT_24_8","DEPTH24_STENCIL8","UNSIGNED_NORMALIZED","DRAW_FRAMEBUFFER_BINDING","READ_FRAMEBUFFER","DRAW_FRAMEBUFFER","READ_FRAMEBUFFER_BINDING","RENDERBUFFER_SAMPLES","FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER","MAX_COLOR_ATTACHMENTS","COLOR_ATTACHMENT1","COLOR_ATTACHMENT2","COLOR_ATTACHMENT3","COLOR_ATTACHMENT4","COLOR_ATTACHMENT5","COLOR_ATTACHMENT6","COLOR_ATTACHMENT7","COLOR_ATTACHMENT8","COLOR_ATTACHMENT9","COLOR_ATTACHMENT10","COLOR_ATTACHMENT11","COLOR_ATTACHMENT12","COLOR_ATTACHMENT13","COLOR_ATTACHMENT14","COLOR_ATTACHMENT15","FRAMEBUFFER_INCOMPLETE_MULTISAMPLE","MAX_SAMPLES","HALF_FLOAT","RG","RG_INTEGER","R8","RG8","R16F","R32F","RG16F","RG32F","R8I","R8UI","R16I","R16UI","R32I","R32UI","RG8I","RG8UI","RG16I","RG16UI","RG32I","RG32UI","VERTEX_ARRAY_BINDING","R8_SNORM","RG8_SNORM","RGB8_SNORM","RGBA8_SNORM","SIGNED_NORMALIZED","COPY_READ_BUFFER","COPY_WRITE_BUFFER","COPY_READ_BUFFER_BINDING","COPY_WRITE_BUFFER_BINDING","UNIFORM_BUFFER","UNIFORM_BUFFER_BINDING","UNIFORM_BUFFER_START","UNIFORM_BUFFER_SIZE","MAX_VERTEX_UNIFORM_BLOCKS","MAX_FRAGMENT_UNIFORM_BLOCKS","MAX_COMBINED_UNIFORM_BLOCKS","MAX_UNIFORM_BUFFER_BINDINGS","MAX_UNIFORM_BLOCK_SIZE","MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS","MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS","UNIFORM_BUFFER_OFFSET_ALIGNMENT","ACTIVE_UNIFORM_BLOCKS","UNIFORM_TYPE","UNIFORM_SIZE","UNIFORM_BLOCK_INDEX","UNIFORM_OFFSET","UNIFORM_ARRAY_STRIDE","UNIFORM_MATRIX_STRIDE","UNIFORM_IS_ROW_MAJOR","UNIFORM_BLOCK_BINDING","UNIFORM_BLOCK_DATA_SIZE","UNIFORM_BLOCK_ACTIVE_UNIFORMS","UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES","UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER","UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER","INVALID_INDEX","MAX_VERTEX_OUTPUT_COMPONENTS","MAX_FRAGMENT_INPUT_COMPONENTS","MAX_SERVER_WAIT_TIMEOUT","OBJECT_TYPE","SYNC_CONDITION","SYNC_STATUS","SYNC_FLAGS","SYNC_FENCE","SYNC_GPU_COMMANDS_COMPLETE","UNSIGNALED","SIGNALED","ALREADY_SIGNALED","TIMEOUT_EXPIRED","CONDITION_SATISFIED","WAIT_FAILED","SYNC_FLUSH_COMMANDS_BIT","VERTEX_ATTRIB_ARRAY_DIVISOR","ANY_SAMPLES_PASSED","ANY_SAMPLES_PASSED_CONSERVATIVE","SAMPLER_BINDING","RGB10_A2UI","INT_2_10_10_10_REV","TRANSFORM_FEEDBACK","TRANSFORM_FEEDBACK_PAUSED","TRANSFORM_FEEDBACK_ACTIVE","TRANSFORM_FEEDBACK_BINDING","COMPRESSED_R11_EAC","COMPRESSED_SIGNED_R11_EAC","COMPRESSED_RG11_EAC","COMPRESSED_SIGNED_RG11_EAC","COMPRESSED_RGB8_ETC2","COMPRESSED_SRGB8_ETC2","COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2","COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2","COMPRESSED_RGBA8_ETC2_EAC","COMPRESSED_SRGB8_ALPHA8_ETC2_EAC","TEXTURE_IMMUTABLE_FORMAT","MAX_ELEMENT_INDEX","TEXTURE_IMMUTABLE_LEVELS","MAX_TEXTURE_MAX_ANISOTROPY_EXT","Object","freeze"],"mappings":";;;;AAAA;;;;;;;;;;CAUC,GACD,MAAMA,iBAAiB;IACrBC,kBAAkB;IAClBC,oBAAoB;IACpBC,kBAAkB;IAClBC,QAAQ;IACRC,OAAO;IACPC,WAAW;IACXC,YAAY;IACZC,WAAW;IACXC,gBAAgB;IAChBC,cAAc;IACdC,MAAM;IACNC,KAAK;IACLC,WAAW;IACXC,qBAAqB;IACrBC,WAAW;IACXC,qBAAqB;IACrBC,WAAW;IACXC,qBAAqB;IACrBC,WAAW;IACXC,qBAAqB;IACrBC,oBAAoB;IACpBC,UAAU;IACVC,gBAAgB;IAChBC,oBAAoB;IACpBC,sBAAsB;IACtBC,eAAe;IACfC,uBAAuB;IACvBC,eAAe;IACfC,eAAe;IACfC,iBAAiB;IACjBC,iBAAiB;IACjBC,gBAAgB;IAChBC,0BAA0B;IAC1BC,gBAAgB;IAChBC,0BAA0B;IAC1BC,aAAa;IACbC,cAAc;IACdC,sBAAsB;IACtBC,sBAAsB;IACtBC,8BAA8B;IAC9BC,aAAa;IACbC,aAAa;IACbC,cAAc;IACdC,aAAa;IACbC,cAAc;IACdC,uBAAuB;IACvBC,OAAO;IACPC,MAAM;IACNC,gBAAgB;IAChBC,WAAW;IACXC,OAAO;IACPC,QAAQ;IACRC,cAAc;IACdC,YAAY;IACZC,cAAc;IACdC,qBAAqB;IACrBC,0BAA0B;IAC1BC,iBAAiB;IACjBC,UAAU;IACVC,cAAc;IACdC,eAAe;IACfC,mBAAmB;IACnBC,eAAe;IACfC,IAAI;IACJC,KAAK;IACLC,YAAY;IACZC,0BAA0B;IAC1BC,0BAA0B;IAC1BC,gBAAgB;IAChBC,YAAY;IACZC,aAAa;IACbC,iBAAiB;IACjBC,mBAAmB;IACnBC,YAAY;IACZC,qBAAqB;IACrBC,cAAc;IACdC,cAAc;IACdC,yBAAyB;IACzBC,yBAAyB;IACzBC,aAAa;IACbC,oBAAoB;IACpBC,mBAAmB;IACnBC,mBAAmB;IACnBC,mBAAmB;IACnBC,8BAA8B;IAC9BC,8BAA8B;IAC9BC,kBAAkB;IAClBC,yBAAyB;IACzBC,wBAAwB;IACxBC,UAAU;IACVC,aAAa;IACbC,mBAAmB;IACnBC,iBAAiB;IACjBC,kBAAkB;IAClBC,gBAAgB;IAChBC,kBAAkB;IAClBC,mBAAmB;IACnBC,eAAe;IACfC,UAAU;IACVC,YAAY;IACZC,WAAW;IACXC,YAAY;IACZC,YAAY;IACZC,cAAc;IACdC,sBAAsB;IACtBC,uBAAuB;IACvBC,oBAAoB;IACpBC,gBAAgB;IAChBC,SAAS;IACTC,uBAAuB;IACvBC,wBAAwB;IACxBC,4BAA4B;IAC5BC,WAAW;IACXC,SAAS;IACTC,QAAQ;IACRC,sBAAsB;IACtBC,MAAM;IACNC,eAAe;IACfC,OAAO;IACPC,gBAAgB;IAChBC,KAAK;IACLC,cAAc;IACdC,OAAO;IACPC,iBAAiB;IACjBC,OAAO;IACPC,KAAK;IACLC,MAAM;IACNC,WAAW;IACXC,iBAAiB;IACjBC,wBAAwB;IACxBC,wBAAwB;IACxBC,sBAAsB;IACtBC,iBAAiB;IACjBC,eAAe;IACfC,oBAAoB;IACpBC,4BAA4B;IAC5BC,qBAAqB;IACrBC,kCAAkC;IAClCC,gCAAgC;IAChCC,yBAAyB;IACzBC,8BAA8B;IAC9BC,aAAa;IACbC,eAAe;IACfC,aAAa;IACbC,iBAAiB;IACjBC,kBAAkB;IAClBC,iBAAiB;IACjBC,mBAAmB;IACnBC,0BAA0B;IAC1BC,iBAAiB;IACjBC,OAAO;IACPC,MAAM;IACNC,OAAO;IACPC,QAAQ;IACRC,SAAS;IACTC,UAAU;IACVC,QAAQ;IACRC,QAAQ;IACRC,MAAM;IACNC,SAAS;IACTC,MAAM;IACNC,MAAM;IACNC,QAAQ;IACRC,WAAW;IACXC,WAAW;IACXC,QAAQ;IACRC,UAAU;IACVC,SAAS;IACTC,SAAS;IACTC,QAAQ;IACRC,wBAAwB;IACxBC,uBAAuB;IACvBC,uBAAuB;IACvBC,sBAAsB;IACtBC,oBAAoB;IACpBC,oBAAoB;IACpBC,gBAAgB;IAChBC,gBAAgB;IAChBC,YAAY;IACZC,SAAS;IACTC,kBAAkB;IAClBC,0BAA0B;IAC1BC,6BAA6B;IAC7BC,6BAA6B;IAC7BC,6BAA6B;IAC7BC,6BAA6B;IAC7BC,6BAA6B;IAC7BC,6BAA6B;IAC7BC,2BAA2B;IAC3BC,UAAU;IACVC,UAAU;IACVC,UAAU;IACVC,UAAU;IACVC,UAAU;IACVC,UAAU;IACVC,UAAU;IACVC,UAAU;IACVC,UAAU;IACVC,UAAU;IACVC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,gBAAgB;IAChBC,QAAQ;IACRC,eAAe;IACfC,iBAAiB;IACjBC,YAAY;IACZC,YAAY;IACZC,YAAY;IACZC,UAAU;IACVC,UAAU;IACVC,UAAU;IACVC,MAAM;IACNC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,YAAY;IACZC,YAAY;IACZC,YAAY;IACZC,YAAY;IACZC,cAAc;IACdC,6BAA6B;IAC7BC,0BAA0B;IAC1BC,4BAA4B;IAC5BC,0BAA0B;IAC1BC,gCAAgC;IAChCC,6BAA6B;IAC7BC,oCAAoC;IACpCC,gCAAgC;IAChCC,kCAAkC;IAClCC,gBAAgB;IAChBC,WAAW;IACXC,cAAc;IACdC,YAAY;IACZC,SAAS;IACTC,YAAY;IACZC,UAAU;IACVC,aAAa;IACbC,cAAc;IACdC,OAAO;IACPC,SAAS;IACTC,QAAQ;IACRC,mBAAmB;IACnBC,eAAe;IACfC,gBAAgB;IAChBC,eAAe;IACfC,oBAAoB;IACpBC,qBAAqB;IACrBC,8BAA8B;IAC9BC,uBAAuB;IACvBC,yBAAyB;IACzBC,wBAAwB;IACxBC,yBAAyB;IACzBC,yBAAyB;IACzBC,2BAA2B;IAC3BC,oCAAoC;IACpCC,oCAAoC;IACpCC,sCAAsC;IACtCC,8CAA8C;IAC9CC,mBAAmB;IACnBC,kBAAkB;IAClBC,oBAAoB;IACpBC,0BAA0B;IAC1BC,MAAM;IACNC,sBAAsB;IACtBC,mCAAmC;IACnCC,2CAA2C;IAC3CC,mCAAmC;IACnCC,yBAAyB;IACzBC,qBAAqB;IACrBC,sBAAsB;IACtBC,uBAAuB;IACvBC,+BAA+B;IAC/BC,qBAAqB;IACrBC,gCAAgC;IAChCC,oBAAoB;IACpBC,oCAAoC;IACpCC,uBAAuB;IAEvB,gCAAgC;IAChCC,8BAA8B;IAC9BC,+BAA+B;IAC/BC,+BAA+B;IAC/BC,+BAA+B;IAE/B,iCAAiC;IACjCC,iCAAiC;IACjCC,iCAAiC;IACjCC,kCAAkC;IAClCC,kCAAkC;IAElC,gCAAgC;IAChCC,gCAAgC;IAEhC,gCAAgC;IAChCC,2BAA2B;IAE3B,+BAA+B;IAC/BC,4BAA4B;IAE5B,8BAA8B;IAC9BC,gBAAgB;IAEhB,iBAAiB;IACjBC,QAAQ;IAER,UAAU;IACVC,aAAa;IACbC,mBAAmB;IACnBC,kBAAkB;IAClBC,oBAAoB;IACpBC,iBAAiB;IACjBC,gBAAgB;IAChBC,kBAAkB;IAClBC,OAAO;IACPC,OAAO;IACPC,SAAS;IACTC,KAAK;IACLC,MAAM;IACNC,OAAO;IACPC,UAAU;IACVC,oBAAoB;IACpBC,oBAAoB;IACpBC,qBAAqB;IACrBC,YAAY;IACZC,gBAAgB;IAChBC,qBAAqB;IACrBC,6BAA6B;IAC7BC,uBAAuB;IACvBC,sBAAsB;IACtBC,iBAAiB;IACjBC,iBAAiB;IACjBC,oBAAoB;IACpBC,mBAAmB;IACnBC,KAAK;IACLC,KAAK;IACLC,mBAAmB;IACnBC,sBAAsB;IACtBC,sBAAsB;IACtBC,sBAAsB;IACtBC,eAAe;IACfC,cAAc;IACdC,wBAAwB;IACxBC,aAAa;IACbC,aAAa;IACbC,aAAa;IACbC,aAAa;IACbC,cAAc;IACdC,cAAc;IACdC,kBAAkB;IAClBC,cAAc;IACdC,cAAc;IACdC,cAAc;IACdC,cAAc;IACdC,cAAc;IACdC,cAAc;IACdC,cAAc;IACdC,cAAc;IACdC,cAAc;IACdC,cAAc;IACdC,eAAe;IACfC,eAAe;IACfC,eAAe;IACfC,eAAe;IACfC,eAAe;IACfC,eAAe;IACfC,iCAAiC;IACjCC,+BAA+B;IAC/BC,YAAY;IACZC,mBAAmB;IACnBC,iCAAiC;IACjCC,mBAAmB;IACnBC,qBAAqB;IACrBC,2BAA2B;IAC3BC,6BAA6B;IAC7BC,cAAc;IACdC,cAAc;IACdC,cAAc;IACdC,cAAc;IACdC,cAAc;IACdC,cAAc;IACdC,MAAM;IACNC,OAAO;IACPC,cAAc;IACdC,wBAAwB;IACxBC,SAAS;IACTC,QAAQ;IACRC,SAAS;IACTC,QAAQ;IACRC,6BAA6B;IAC7BC,0BAA0B;IAC1BC,0BAA0B;IAC1BC,0BAA0B;IAC1BC,wBAAwB;IACxBC,kBAAkB;IAClBC,0BAA0B;IAC1BC,gBAAgB;IAChBC,8BAA8B;IAC9BC,SAAS;IACTC,0BAA0B;IAC1BC,gCAAgC;IAChCC,4CAA4C;IAC5CC,6BAA6B;IAC7BC,iCAAiC;IACjCC,gCAAgC;IAChCC,uCAAuC;IACvCC,oBAAoB;IACpBC,+CAA+C;IAC/CC,yCAAyC;IACzCC,qBAAqB;IACrBC,kBAAkB;IAClBC,2BAA2B;IAC3BC,mCAAmC;IACnCC,UAAU;IACVC,SAAS;IACTC,UAAU;IACVC,SAAS;IACTC,SAAS;IACTC,QAAQ;IACRC,SAAS;IACTC,QAAQ;IACRC,SAAS;IACTC,QAAQ;IACRC,QAAQ;IACRC,OAAO;IACPC,aAAa;IACbC,aAAa;IACbC,cAAc;IACdC,kBAAkB;IAClBC,yBAAyB;IACzBC,qBAAqB;IACrBC,mBAAmB;IACnBC,mBAAmB;IACnBC,mBAAmB;IACnBC,gBAAgB;IAChBC,gBAAgB;IAChBC,kBAAkB;IAClBC,sBAAsB;IACtBC,yBAAyB;IACzBC,yBAAyB;IACzBC,2BAA2B;IAC3BC,+BAA+B;IAC/BC,oBAAoB;IACpBC,mBAAmB;IACnBC,gCAAgC;IAChCC,uCAAuC;IACvCC,uCAAuC;IACvCC,iCAAiC;IACjCC,mCAAmC;IACnCC,kCAAkC;IAClCC,mCAAmC;IACnCC,mCAAmC;IACnCC,qCAAqC;IACrCC,qBAAqB;IACrBC,mBAAmB;IACnBC,kBAAkB;IAClBC,qBAAqB;IACrBC,0BAA0B;IAC1BC,kBAAkB;IAClBC,kBAAkB;IAClBC,0BAA0B;IAC1BC,sBAAsB;IACtBC,sCAAsC;IACtCC,uBAAuB;IACvBC,mBAAmB;IACnBC,mBAAmB;IACnBC,mBAAmB;IACnBC,mBAAmB;IACnBC,mBAAmB;IACnBC,mBAAmB;IACnBC,mBAAmB;IACnBC,mBAAmB;IACnBC,mBAAmB;IACnBC,oBAAoB;IACpBC,oBAAoB;IACpBC,oBAAoB;IACpBC,oBAAoB;IACpBC,oBAAoB;IACpBC,oBAAoB;IACpBC,oCAAoC;IACpCC,aAAa;IACbC,YAAY;IACZC,IAAI;IACJC,YAAY;IACZC,IAAI;IACJC,KAAK;IACLC,MAAM;IACNC,MAAM;IACNC,OAAO;IACPC,OAAO;IACPC,KAAK;IACLC,MAAM;IACNC,MAAM;IACNC,OAAO;IACPC,MAAM;IACNC,OAAO;IACPC,MAAM;IACNC,OAAO;IACPC,OAAO;IACPC,QAAQ;IACRC,OAAO;IACPC,QAAQ;IACRC,sBAAsB;IACtBC,UAAU;IACVC,WAAW;IACXC,YAAY;IACZC,aAAa;IACbC,mBAAmB;IACnBC,kBAAkB;IAClBC,mBAAmB;IACnBC,0BAA0B;IAC1BC,2BAA2B;IAC3BC,gBAAgB;IAChBC,wBAAwB;IACxBC,sBAAsB;IACtBC,qBAAqB;IACrBC,2BAA2B;IAC3BC,6BAA6B;IAC7BC,6BAA6B;IAC7BC,6BAA6B;IAC7BC,wBAAwB;IACxBC,wCAAwC;IACxCC,0CAA0C;IAC1CC,iCAAiC;IACjCC,uBAAuB;IACvBC,cAAc;IACdC,cAAc;IACdC,qBAAqB;IACrBC,gBAAgB;IAChBC,sBAAsB;IACtBC,uBAAuB;IACvBC,sBAAsB;IACtBC,uBAAuB;IACvBC,yBAAyB;IACzBC,+BAA+B;IAC/BC,sCAAsC;IACtCC,2CAA2C;IAC3CC,6CAA6C;IAC7CC,eAAe;IACfC,8BAA8B;IAC9BC,+BAA+B;IAC/BC,yBAAyB;IACzBC,aAAa;IACbC,gBAAgB;IAChBC,aAAa;IACbC,YAAY;IACZC,YAAY;IACZC,4BAA4B;IAC5BC,YAAY;IACZC,UAAU;IACVC,kBAAkB;IAClBC,iBAAiB;IACjBC,qBAAqB;IACrBC,aAAa;IACbC,yBAAyB;IACzBC,6BAA6B;IAC7BC,oBAAoB;IACpBC,iCAAiC;IACjCC,iBAAiB;IACjBC,YAAY;IACZC,oBAAoB;IACpBC,oBAAoB;IACpBC,2BAA2B;IAC3BC,2BAA2B;IAC3BC,4BAA4B;IAC5BC,oBAAoB;IACpBC,2BAA2B;IAC3BC,qBAAqB;IACrBC,4BAA4B;IAC5BC,sBAAsB;IACtBC,uBAAuB;IACvBC,0CAA0C;IAC1CC,2CAA2C;IAC3CC,2BAA2B;IAC3BC,kCAAkC;IAClCC,0BAA0B;IAC1BC,mBAAmB;IACnBC,0BAA0B;IAE1B,aAAa;IACbC,gCAAgC;AAClC;uCACeC,OAAOC,MAAM,CAACxkB","ignoreList":[0]}},
    {"offset": {"line": 18537, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/ComponentDatatype.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport WebGLConstants from \"./WebGLConstants.js\";\n\n/**\n * WebGL component datatypes.  Components are intrinsics,\n * which form attributes, which form vertices.\n *\n * @enum {number}\n */\nconst ComponentDatatype = {\n  /**\n   * 8-bit signed byte corresponding to <code>gl.BYTE</code> and the type\n   * of an element in <code>Int8Array</code>.\n   *\n   * @type {number}\n   * @constant\n   */\n  BYTE: WebGLConstants.BYTE,\n\n  /**\n   * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type\n   * of an element in <code>Uint8Array</code>.\n   *\n   * @type {number}\n   * @constant\n   */\n  UNSIGNED_BYTE: WebGLConstants.UNSIGNED_BYTE,\n\n  /**\n   * 16-bit signed short corresponding to <code>SHORT</code> and the type\n   * of an element in <code>Int16Array</code>.\n   *\n   * @type {number}\n   * @constant\n   */\n  SHORT: WebGLConstants.SHORT,\n\n  /**\n   * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type\n   * of an element in <code>Uint16Array</code>.\n   *\n   * @type {number}\n   * @constant\n   */\n  UNSIGNED_SHORT: WebGLConstants.UNSIGNED_SHORT,\n\n  /**\n   * 32-bit signed int corresponding to <code>INT</code> and the type\n   * of an element in <code>Int32Array</code>.\n   *\n   * @memberOf ComponentDatatype\n   *\n   * @type {number}\n   * @constant\n   */\n  INT: WebGLConstants.INT,\n\n  /**\n   * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type\n   * of an element in <code>Uint32Array</code>.\n   *\n   * @memberOf ComponentDatatype\n   *\n   * @type {number}\n   * @constant\n   */\n  UNSIGNED_INT: WebGLConstants.UNSIGNED_INT,\n\n  /**\n   * 32-bit floating-point corresponding to <code>FLOAT</code> and the type\n   * of an element in <code>Float32Array</code>.\n   *\n   * @type {number}\n   * @constant\n   */\n  FLOAT: WebGLConstants.FLOAT,\n\n  /**\n   * 64-bit floating-point corresponding to <code>gl.DOUBLE</code> (in Desktop OpenGL;\n   * this is not supported in WebGL, and is emulated in Cesium via {@link GeometryPipeline.encodeAttribute})\n   * and the type of an element in <code>Float64Array</code>.\n   *\n   * @memberOf ComponentDatatype\n   *\n   * @type {number}\n   * @constant\n   * @default 0x140A\n   */\n  DOUBLE: WebGLConstants.DOUBLE,\n};\n\n/**\n * Returns the size, in bytes, of the corresponding datatype.\n *\n * @param {ComponentDatatype} componentDatatype The component datatype to get the size of.\n * @returns {number} The size in bytes.\n *\n * @exception {DeveloperError} componentDatatype is not a valid value.\n *\n * @example\n * // Returns Int8Array.BYTES_PER_ELEMENT\n * const size = Cesium.ComponentDatatype.getSizeInBytes(Cesium.ComponentDatatype.BYTE);\n */\nComponentDatatype.getSizeInBytes = function (componentDatatype) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(componentDatatype)) {\n    throw new DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n\n  switch (componentDatatype) {\n    case ComponentDatatype.BYTE:\n      return Int8Array.BYTES_PER_ELEMENT;\n    case ComponentDatatype.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case ComponentDatatype.SHORT:\n      return Int16Array.BYTES_PER_ELEMENT;\n    case ComponentDatatype.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case ComponentDatatype.INT:\n      return Int32Array.BYTES_PER_ELEMENT;\n    case ComponentDatatype.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n    case ComponentDatatype.FLOAT:\n      return Float32Array.BYTES_PER_ELEMENT;\n    case ComponentDatatype.DOUBLE:\n      return Float64Array.BYTES_PER_ELEMENT;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"componentDatatype is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Gets the {@link ComponentDatatype} for the provided TypedArray instance.\n *\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} array The typed array.\n * @returns {ComponentDatatype} The ComponentDatatype for the provided array, or undefined if the array is not a TypedArray.\n */\nComponentDatatype.fromTypedArray = function (array) {\n  if (array instanceof Int8Array) {\n    return ComponentDatatype.BYTE;\n  }\n  if (array instanceof Uint8Array) {\n    return ComponentDatatype.UNSIGNED_BYTE;\n  }\n  if (array instanceof Int16Array) {\n    return ComponentDatatype.SHORT;\n  }\n  if (array instanceof Uint16Array) {\n    return ComponentDatatype.UNSIGNED_SHORT;\n  }\n  if (array instanceof Int32Array) {\n    return ComponentDatatype.INT;\n  }\n  if (array instanceof Uint32Array) {\n    return ComponentDatatype.UNSIGNED_INT;\n  }\n  if (array instanceof Float32Array) {\n    return ComponentDatatype.FLOAT;\n  }\n  if (array instanceof Float64Array) {\n    return ComponentDatatype.DOUBLE;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    \"array must be an Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, or Float64Array.\",\n  );\n  //>>includeEnd('debug');\n};\n\n/**\n * Validates that the provided component datatype is a valid {@link ComponentDatatype}\n *\n * @param {ComponentDatatype} componentDatatype The component datatype to validate.\n * @returns {boolean} <code>true</code> if the provided component datatype is a valid value; otherwise, <code>false</code>.\n *\n * @example\n * if (!Cesium.ComponentDatatype.validate(componentDatatype)) {\n *   throw new Cesium.DeveloperError('componentDatatype must be a valid value.');\n * }\n */\nComponentDatatype.validate = function (componentDatatype) {\n  return (\n    defined(componentDatatype) &&\n    (componentDatatype === ComponentDatatype.BYTE ||\n      componentDatatype === ComponentDatatype.UNSIGNED_BYTE ||\n      componentDatatype === ComponentDatatype.SHORT ||\n      componentDatatype === ComponentDatatype.UNSIGNED_SHORT ||\n      componentDatatype === ComponentDatatype.INT ||\n      componentDatatype === ComponentDatatype.UNSIGNED_INT ||\n      componentDatatype === ComponentDatatype.FLOAT ||\n      componentDatatype === ComponentDatatype.DOUBLE)\n  );\n};\n\n/**\n * Creates a typed array corresponding to component data type.\n *\n * @param {ComponentDatatype} componentDatatype The component data type.\n * @param {number|Array} valuesOrLength The length of the array to create or an array.\n * @returns {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} A typed array.\n *\n * @exception {DeveloperError} componentDatatype is not a valid value.\n *\n * @example\n * // creates a Float32Array with length of 100\n * const typedArray = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 100);\n */\nComponentDatatype.createTypedArray = function (\n  componentDatatype,\n  valuesOrLength,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(componentDatatype)) {\n    throw new DeveloperError(\"componentDatatype is required.\");\n  }\n  if (!defined(valuesOrLength)) {\n    throw new DeveloperError(\"valuesOrLength is required.\");\n  }\n  //>>includeEnd('debug');\n\n  switch (componentDatatype) {\n    case ComponentDatatype.BYTE:\n      return new Int8Array(valuesOrLength);\n    case ComponentDatatype.UNSIGNED_BYTE:\n      return new Uint8Array(valuesOrLength);\n    case ComponentDatatype.SHORT:\n      return new Int16Array(valuesOrLength);\n    case ComponentDatatype.UNSIGNED_SHORT:\n      return new Uint16Array(valuesOrLength);\n    case ComponentDatatype.INT:\n      return new Int32Array(valuesOrLength);\n    case ComponentDatatype.UNSIGNED_INT:\n      return new Uint32Array(valuesOrLength);\n    case ComponentDatatype.FLOAT:\n      return new Float32Array(valuesOrLength);\n    case ComponentDatatype.DOUBLE:\n      return new Float64Array(valuesOrLength);\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"componentDatatype is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Creates a typed view of an array of bytes.\n *\n * @param {ComponentDatatype} componentDatatype The type of the view to create.\n * @param {ArrayBuffer} buffer The buffer storage to use for the view.\n * @param {number} [byteOffset] The offset, in bytes, to the first element in the view.\n * @param {number} [length] The number of elements in the view.\n * @returns {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} A typed array view of the buffer.\n *\n * @exception {DeveloperError} componentDatatype is not a valid value.\n */\nComponentDatatype.createArrayBufferView = function (\n  componentDatatype,\n  buffer,\n  byteOffset,\n  length,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(componentDatatype)) {\n    throw new DeveloperError(\"componentDatatype is required.\");\n  }\n  if (!defined(buffer)) {\n    throw new DeveloperError(\"buffer is required.\");\n  }\n  //>>includeEnd('debug');\n\n  byteOffset = byteOffset ?? 0;\n  length =\n    length ??\n    (buffer.byteLength - byteOffset) /\n      ComponentDatatype.getSizeInBytes(componentDatatype);\n\n  switch (componentDatatype) {\n    case ComponentDatatype.BYTE:\n      return new Int8Array(buffer, byteOffset, length);\n    case ComponentDatatype.UNSIGNED_BYTE:\n      return new Uint8Array(buffer, byteOffset, length);\n    case ComponentDatatype.SHORT:\n      return new Int16Array(buffer, byteOffset, length);\n    case ComponentDatatype.UNSIGNED_SHORT:\n      return new Uint16Array(buffer, byteOffset, length);\n    case ComponentDatatype.INT:\n      return new Int32Array(buffer, byteOffset, length);\n    case ComponentDatatype.UNSIGNED_INT:\n      return new Uint32Array(buffer, byteOffset, length);\n    case ComponentDatatype.FLOAT:\n      return new Float32Array(buffer, byteOffset, length);\n    case ComponentDatatype.DOUBLE:\n      return new Float64Array(buffer, byteOffset, length);\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"componentDatatype is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Get the ComponentDatatype from its name.\n *\n * @param {string} name The name of the ComponentDatatype.\n * @returns {ComponentDatatype} The ComponentDatatype.\n *\n * @exception {DeveloperError} name is not a valid value.\n */\nComponentDatatype.fromName = function (name) {\n  switch (name) {\n    case \"BYTE\":\n      return ComponentDatatype.BYTE;\n    case \"UNSIGNED_BYTE\":\n      return ComponentDatatype.UNSIGNED_BYTE;\n    case \"SHORT\":\n      return ComponentDatatype.SHORT;\n    case \"UNSIGNED_SHORT\":\n      return ComponentDatatype.UNSIGNED_SHORT;\n    case \"INT\":\n      return ComponentDatatype.INT;\n    case \"UNSIGNED_INT\":\n      return ComponentDatatype.UNSIGNED_INT;\n    case \"FLOAT\":\n      return ComponentDatatype.FLOAT;\n    case \"DOUBLE\":\n      return ComponentDatatype.DOUBLE;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"name is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\nexport default Object.freeze(ComponentDatatype);\n"],"names":["ComponentDatatype","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","FLOAT","DOUBLE","getSizeInBytes","componentDatatype","Int8Array","BYTES_PER_ELEMENT","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","fromTypedArray","array","validate","createTypedArray","valuesOrLength","createArrayBufferView","buffer","byteOffset","length","byteLength","fromName","name","Object","freeze"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 18825, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/GeometryInstance.js"],"sourcesContent":["import Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * Geometry instancing allows one {@link Geometry} object to be positions in several\n * different locations and colored uniquely.  For example, one {@link BoxGeometry} can\n * be instanced several times, each with a different <code>modelMatrix</code> to change\n * its position, rotation, and scale.\n *\n * @alias GeometryInstance\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Geometry|GeometryFactory} options.geometry The geometry to instance.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The model matrix that transforms to transform the geometry from model to world coordinates.\n * @param {object} [options.id] A user-defined object to return when the instance is picked with {@link Scene#pick} or get/set per-instance attributes with {@link Primitive#getGeometryInstanceAttributes}.\n * @param {object} [options.attributes] Per-instance attributes like a show or color attribute shown in the example below.\n *\n *\n * @example\n * // Create geometry for a box, and two instances that refer to it.\n * // One instance positions the box on the bottom and colored aqua.\n * // The other instance positions the box on the top and color white.\n * const geometry = Cesium.BoxGeometry.fromDimensions({\n *   vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n *   dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)\n * });\n * const instanceBottom = new Cesium.GeometryInstance({\n *   geometry : geometry,\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *   },\n *   id : 'bottom'\n * });\n * const instanceTop = new Cesium.GeometryInstance({\n *   geometry : geometry,\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 3000000.0), new Cesium.Matrix4()),\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *   },\n *   id : 'top'\n * });\n *\n * @see Geometry\n */\nfunction GeometryInstance(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.geometry)) {\n    throw new DeveloperError(\"options.geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The geometry being instanced.\n   *\n   * @type Geometry\n   *\n   */\n  this.geometry = options.geometry;\n\n  /**\n   * The 4x4 transformation matrix that transforms the geometry from model to world coordinates.\n   * When this is the identity matrix, the geometry is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type Matrix4\n   *\n   * @default Matrix4.IDENTITY\n   */\n  this.modelMatrix = Matrix4.clone(options.modelMatrix ?? Matrix4.IDENTITY);\n\n  /**\n   * User-defined object returned when the instance is picked or used to get/set per-instance attributes.\n   *\n   * @type {object|undefined}\n   *\n   * @default undefined\n   *\n   * @see Scene#pick\n   * @see Primitive#getGeometryInstanceAttributes\n   */\n  this.id = options.id;\n\n  /**\n   * Used for picking primitives that wrap geometry instances.\n   *\n   * @private\n   */\n  this.pickPrimitive = options.pickPrimitive;\n\n  /**\n   * Per-instance attributes like {@link ColorGeometryInstanceAttribute} or {@link ShowGeometryInstanceAttribute}.\n   * {@link Geometry} attributes varying per vertex; these attributes are constant for the entire instance.\n   *\n   * @type {object}\n   *\n   * @default {}\n   */\n  this.attributes = options.attributes ?? {};\n\n  /**\n   * @private\n   */\n  this.westHemisphereGeometry = undefined;\n  /**\n   * @private\n   */\n  this.eastHemisphereGeometry = undefined;\n}\nexport default GeometryInstance;\n"],"names":["GeometryInstance","options","EMPTY_OBJECT","geometry","modelMatrix","clone","IDENTITY","id","pickPrimitive","attributes","westHemisphereGeometry","undefined","eastHemisphereGeometry"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4CC,GACD,SAASA,iBAAiBC,OAAO;IAC/BA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACD,QAAQE,QAAQ,GAAG;QAC9B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB;;;;;GAKC,GACD,IAAI,CAACA,QAAQ,GAAGF,QAAQE,QAAQ;IAEhC;;;;;;;;;GASC,GACD,IAAI,CAACC,WAAW,GAAG,6KAAO,CAACC,KAAK,CAACJ,QAAQG,WAAW,IAAI,6KAAO,CAACE,QAAQ;IAExE;;;;;;;;;GASC,GACD,IAAI,CAACC,EAAE,GAAGN,QAAQM,EAAE;IAEpB;;;;GAIC,GACD,IAAI,CAACC,aAAa,GAAGP,QAAQO,aAAa;IAE1C;;;;;;;GAOC,GACD,IAAI,CAACC,UAAU,GAAGR,QAAQQ,UAAU,IAAI,CAAC;IAEzC;;GAEC,GACD,IAAI,CAACC,sBAAsB,GAAGC;IAC9B;;GAEC,GACD,IAAI,CAACC,sBAAsB,GAAGD;AAChC;uCACeX","ignoreList":[0]}},
    {"offset": {"line": 18939, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/GeometryInstanceAttribute.js"],"sourcesContent":["import Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Values and type information for per-instance geometry attributes.\n *\n * @alias GeometryInstanceAttribute\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {ComponentDatatype} options.componentDatatype The datatype of each component in the attribute, e.g., individual elements in values.\n * @param {number} options.componentsPerAttribute A number between 1 and 4 that defines the number of components in an attributes.\n * @param {boolean} [options.normalize=false] When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n * @param {number[]} options.value The value for the attribute.\n *\n * @exception {DeveloperError} options.componentsPerAttribute must be between 1 and 4.\n *\n *\n * @example\n * const instance = new Cesium.GeometryInstance({\n *   geometry : Cesium.BoxGeometry.fromDimensions({\n *     dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(0.0, 0.0)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   id : 'box',\n *   attributes : {\n *     color : new Cesium.GeometryInstanceAttribute({\n *       componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,\n *       componentsPerAttribute : 4,\n *       normalize : true,\n *       value : [255, 255, 0, 255]\n *     })\n *   }\n * });\n *\n * @see ColorGeometryInstanceAttribute\n * @see ShowGeometryInstanceAttribute\n * @see DistanceDisplayConditionGeometryInstanceAttribute\n */\nfunction GeometryInstanceAttribute(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.componentDatatype)) {\n    throw new DeveloperError(\"options.componentDatatype is required.\");\n  }\n  if (!defined(options.componentsPerAttribute)) {\n    throw new DeveloperError(\"options.componentsPerAttribute is required.\");\n  }\n  if (\n    options.componentsPerAttribute < 1 ||\n    options.componentsPerAttribute > 4\n  ) {\n    throw new DeveloperError(\n      \"options.componentsPerAttribute must be between 1 and 4.\",\n    );\n  }\n  if (!defined(options.value)) {\n    throw new DeveloperError(\"options.value is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The datatype of each component in the attribute, e.g., individual elements in\n   * {@link GeometryInstanceAttribute#value}.\n   *\n   * @type ComponentDatatype\n   *\n   */\n  this.componentDatatype = options.componentDatatype;\n\n  /**\n   * A number between 1 and 4 that defines the number of components in an attributes.\n   * For example, a position attribute with x, y, and z components would have 3 as\n   * shown in the code example.\n   *\n   * @type {number}\n   *\n   * @example\n   * show : new Cesium.GeometryInstanceAttribute({\n   *   componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,\n   *   componentsPerAttribute : 1,\n   *   normalize : true,\n   *   value : [1.0]\n   * })\n   */\n  this.componentsPerAttribute = options.componentsPerAttribute;\n\n  /**\n   * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n   * indicate that the components should be mapped to the range [0, 1] (unsigned)\n   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n   * <p>\n   * This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   *\n   * @example\n   * attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;\n   * attribute.componentsPerAttribute = 4;\n   * attribute.normalize = true;\n   * attribute.value = [\n   *   Cesium.Color.floatToByte(color.red),\n   *   Cesium.Color.floatToByte(color.green),\n   *   Cesium.Color.floatToByte(color.blue),\n   *   Cesium.Color.floatToByte(color.alpha)\n   * ];\n   */\n  this.normalize = options.normalize ?? false;\n\n  /**\n   * The values for the attributes stored in a typed array.  In the code example,\n   * every three elements in <code>values</code> defines one attributes since\n   * <code>componentsPerAttribute</code> is 3.\n   *\n   * @type {number[]}\n   *\n   * @example\n   * show : new Cesium.GeometryInstanceAttribute({\n   *   componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,\n   *   componentsPerAttribute : 1,\n   *   normalize : true,\n   *   value : [1.0]\n   * })\n   */\n  this.value = options.value;\n}\nexport default GeometryInstanceAttribute;\n"],"names":["GeometryInstanceAttribute","options","EMPTY_OBJECT","componentDatatype","componentsPerAttribute","value","normalize"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoCC,GACD,SAASA,0BAA0BC,OAAO;IACxCA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACD,QAAQE,iBAAiB,GAAG;QACvC,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACF,QAAQG,sBAAsB,GAAG;QAC5C,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IACEH,QAAQG,sBAAsB,GAAG,KACjCH,QAAQG,sBAAsB,GAAG,GACjC;QACA,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,IAAI,CAAC,IAAA,6KAAO,EAACH,QAAQI,KAAK,GAAG;QAC3B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB;;;;;;GAMC,GACD,IAAI,CAACF,iBAAiB,GAAGF,QAAQE,iBAAiB;IAElD;;;;;;;;;;;;;;GAcC,GACD,IAAI,CAACC,sBAAsB,GAAGH,QAAQG,sBAAsB;IAE5D;;;;;;;;;;;;;;;;;;;;;;GAsBC,GACD,IAAI,CAACE,SAAS,GAAGL,QAAQK,SAAS,IAAI;IAEtC;;;;;;;;;;;;;;GAcC,GACD,IAAI,CAACD,KAAK,GAAGJ,QAAQI,KAAK;AAC5B;uCACeL","ignoreList":[0]}},
    {"offset": {"line": 19067, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/ArcType.js"],"sourcesContent":["/**\n * ArcType defines the path that should be taken connecting vertices.\n *\n * @enum {number}\n */\nconst ArcType = {\n  /**\n   * Straight line that does not conform to the surface of the ellipsoid.\n   *\n   * @type {number}\n   * @constant\n   */\n  NONE: 0,\n\n  /**\n   * Follow geodesic path.\n   *\n   * @type {number}\n   * @constant\n   */\n  GEODESIC: 1,\n\n  /**\n   * Follow rhumb or loxodrome path.\n   *\n   * @type {number}\n   * @constant\n   */\n  RHUMB: 2,\n};\nexport default Object.freeze(ArcType);\n"],"names":["ArcType","NONE","GEODESIC","RHUMB","Object","freeze"],"mappings":";;;;AAAA;;;;CAIC,GACD,MAAMA,UAAU;IACd;;;;;GAKC,GACDC,MAAM;IAEN;;;;;GAKC,GACDC,UAAU;IAEV;;;;;GAKC,GACDC,OAAO;AACT;uCACeC,OAAOC,MAAM,CAACL","ignoreList":[0]}},
    {"offset": {"line": 19100, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/arrayRemoveDuplicates.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\n\nconst removeDuplicatesEpsilon = CesiumMath.EPSILON10;\n\n/**\n * Removes adjacent duplicate values in an array of values.\n *\n * @param {any[]} [values] The array of values.\n * @param {Function} equalsEpsilon Function to compare values with an epsilon. Boolean equalsEpsilon(left, right, epsilon).\n * @param {boolean} [wrapAround=false] Compare the last value in the array against the first value. If they are equal, the last value is removed.\n * @param {number[]} [removedIndices=undefined] Store the indices that correspond to the duplicate items removed from the array, if there were any.\n * @returns {any[]|undefined} A new array of values with no adjacent duplicate values or the input array if no duplicates were found.\n *\n * @example\n * // Returns [(1.0, 1.0, 1.0), (2.0, 2.0, 2.0), (3.0, 3.0, 3.0), (1.0, 1.0, 1.0)]\n * const values = [\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(3.0, 3.0, 3.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0)];\n * const nonDuplicatevalues = Cesium.PolylinePipeline.removeDuplicates(values, Cartesian3.equalsEpsilon);\n *\n * @example\n * // Returns [(1.0, 1.0, 1.0), (2.0, 2.0, 2.0), (3.0, 3.0, 3.0)]\n * const values = [\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(3.0, 3.0, 3.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0)];\n * const nonDuplicatevalues = Cesium.PolylinePipeline.removeDuplicates(values, Cartesian3.equalsEpsilon, true);\n *\n * @example\n * // Returns [(1.0, 1.0, 1.0), (2.0, 2.0, 2.0), (3.0, 3.0, 3.0)]\n * // removedIndices will be equal to [1, 3, 5]\n * const values = [\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(3.0, 3.0, 3.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0)];\n * const nonDuplicatevalues = Cesium.PolylinePipeline.removeDuplicates(values, Cartesian3.equalsEpsilon, true);\n * @private\n */\nfunction arrayRemoveDuplicates(\n  values,\n  equalsEpsilon,\n  wrapAround,\n  removedIndices,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"equalsEpsilon\", equalsEpsilon);\n  //>>includeEnd('debug');\n\n  if (!defined(values)) {\n    return undefined;\n  }\n\n  wrapAround = wrapAround ?? false;\n  const storeRemovedIndices = defined(removedIndices);\n\n  const length = values.length;\n  if (length < 2) {\n    return values;\n  }\n\n  let i;\n  let v0 = values[0];\n  let v1;\n\n  // We only want to create a new array if there are duplicates in the array.\n  // As such, cleanedValues is undefined until it encounters the first duplicate, if it exists.\n  let cleanedValues;\n  let lastCleanIndex = 0;\n\n  // removedIndexLCI keeps track of where lastCleanIndex would be if it were sorted into the removedIndices array.\n  // In case of arrays such as [A, B, C, ..., A, A, A], removedIndices will not be sorted properly without this.\n  let removedIndexLCI = -1;\n\n  for (i = 1; i < length; ++i) {\n    v1 = values[i];\n    if (equalsEpsilon(v0, v1, removeDuplicatesEpsilon)) {\n      if (!defined(cleanedValues)) {\n        cleanedValues = values.slice(0, i);\n        lastCleanIndex = i - 1;\n        removedIndexLCI = 0;\n      }\n      if (storeRemovedIndices) {\n        removedIndices.push(i);\n      }\n    } else {\n      if (defined(cleanedValues)) {\n        cleanedValues.push(v1);\n        lastCleanIndex = i;\n        if (storeRemovedIndices) {\n          removedIndexLCI = removedIndices.length;\n        }\n      }\n      v0 = v1;\n    }\n  }\n\n  if (\n    wrapAround &&\n    equalsEpsilon(values[0], values[length - 1], removeDuplicatesEpsilon)\n  ) {\n    if (storeRemovedIndices) {\n      if (defined(cleanedValues)) {\n        removedIndices.splice(removedIndexLCI, 0, lastCleanIndex);\n      } else {\n        removedIndices.push(length - 1);\n      }\n    }\n\n    if (defined(cleanedValues)) {\n      cleanedValues.length -= 1;\n    } else {\n      cleanedValues = values.slice(0, -1);\n    }\n  }\n\n  return defined(cleanedValues) ? cleanedValues : values;\n}\n\nexport default arrayRemoveDuplicates;\n"],"names":["removeDuplicatesEpsilon","EPSILON10","arrayRemoveDuplicates","values","equalsEpsilon","wrapAround","removedIndices","defined","undefined","storeRemovedIndices","length","i","v0","v1","cleanedValues","lastCleanIndex","removedIndexLCI","slice","push","splice"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,MAAMA,0BAA0B,0KAAU,CAACC,SAAS;AAEpD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyCC,GACD,SAASC,sBACPC,MAAM,EACNC,aAAa,EACbC,UAAU,EACVC,cAAc;IAEd,yCAAyC;IACzC,2KAAK,CAACC,OAAO,CAAC,iBAAiBH;IAC/B,wBAAwB;IAExB,IAAI,CAAC,IAAA,6KAAO,EAACD,SAAS;QACpB,OAAOK;IACT;IAEAH,aAAaA,cAAc;IAC3B,MAAMI,sBAAsB,IAAA,6KAAO,EAACH;IAEpC,MAAMI,SAASP,OAAOO,MAAM;IAC5B,IAAIA,SAAS,GAAG;QACd,OAAOP;IACT;IAEA,IAAIQ;IACJ,IAAIC,KAAKT,MAAM,CAAC,EAAE;IAClB,IAAIU;IAEJ,2EAA2E;IAC3E,6FAA6F;IAC7F,IAAIC;IACJ,IAAIC,iBAAiB;IAErB,gHAAgH;IAChH,8GAA8G;IAC9G,IAAIC,kBAAkB,CAAC;IAEvB,IAAKL,IAAI,GAAGA,IAAID,QAAQ,EAAEC,EAAG;QAC3BE,KAAKV,MAAM,CAACQ,EAAE;QACd,IAAIP,cAAcQ,IAAIC,IAAIb,0BAA0B;YAClD,IAAI,CAAC,IAAA,6KAAO,EAACc,gBAAgB;gBAC3BA,gBAAgBX,OAAOc,KAAK,CAAC,GAAGN;gBAChCI,iBAAiBJ,IAAI;gBACrBK,kBAAkB;YACpB;YACA,IAAIP,qBAAqB;gBACvBH,eAAeY,IAAI,CAACP;YACtB;QACF,OAAO;YACL,IAAI,IAAA,6KAAO,EAACG,gBAAgB;gBAC1BA,cAAcI,IAAI,CAACL;gBACnBE,iBAAiBJ;gBACjB,IAAIF,qBAAqB;oBACvBO,kBAAkBV,eAAeI,MAAM;gBACzC;YACF;YACAE,KAAKC;QACP;IACF;IAEA,IACER,cACAD,cAAcD,MAAM,CAAC,EAAE,EAAEA,MAAM,CAACO,SAAS,EAAE,EAAEV,0BAC7C;QACA,IAAIS,qBAAqB;YACvB,IAAI,IAAA,6KAAO,EAACK,gBAAgB;gBAC1BR,eAAea,MAAM,CAACH,iBAAiB,GAAGD;YAC5C,OAAO;gBACLT,eAAeY,IAAI,CAACR,SAAS;YAC/B;QACF;QAEA,IAAI,IAAA,6KAAO,EAACI,gBAAgB;YAC1BA,cAAcJ,MAAM,IAAI;QAC1B,OAAO;YACLI,gBAAgBX,OAAOc,KAAK,CAAC,GAAG,CAAC;QACnC;IACF;IAEA,OAAO,IAAA,6KAAO,EAACH,iBAAiBA,gBAAgBX;AAClD;uCAEeD","ignoreList":[0]}},
    {"offset": {"line": 19218, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/EllipsoidGeodesic.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\n\nfunction setConstants(ellipsoidGeodesic) {\n  const uSquared = ellipsoidGeodesic._uSquared;\n  const a = ellipsoidGeodesic._ellipsoid.maximumRadius;\n  const b = ellipsoidGeodesic._ellipsoid.minimumRadius;\n  const f = (a - b) / a;\n\n  const cosineHeading = Math.cos(ellipsoidGeodesic._startHeading);\n  const sineHeading = Math.sin(ellipsoidGeodesic._startHeading);\n\n  const tanU = (1 - f) * Math.tan(ellipsoidGeodesic._start.latitude);\n\n  const cosineU = 1.0 / Math.sqrt(1.0 + tanU * tanU);\n  const sineU = cosineU * tanU;\n\n  const sigma = Math.atan2(tanU, cosineHeading);\n\n  const sineAlpha = cosineU * sineHeading;\n  const sineSquaredAlpha = sineAlpha * sineAlpha;\n\n  const cosineSquaredAlpha = 1.0 - sineSquaredAlpha;\n  const cosineAlpha = Math.sqrt(cosineSquaredAlpha);\n\n  const u2Over4 = uSquared / 4.0;\n  const u4Over16 = u2Over4 * u2Over4;\n  const u6Over64 = u4Over16 * u2Over4;\n  const u8Over256 = u4Over16 * u4Over16;\n\n  const a0 =\n    1.0 +\n    u2Over4 -\n    (3.0 * u4Over16) / 4.0 +\n    (5.0 * u6Over64) / 4.0 -\n    (175.0 * u8Over256) / 64.0;\n  const a1 = 1.0 - u2Over4 + (15.0 * u4Over16) / 8.0 - (35.0 * u6Over64) / 8.0;\n  const a2 = 1.0 - 3.0 * u2Over4 + (35.0 * u4Over16) / 4.0;\n  const a3 = 1.0 - 5.0 * u2Over4;\n\n  const distanceRatio =\n    a0 * sigma -\n    (a1 * Math.sin(2.0 * sigma) * u2Over4) / 2.0 -\n    (a2 * Math.sin(4.0 * sigma) * u4Over16) / 16.0 -\n    (a3 * Math.sin(6.0 * sigma) * u6Over64) / 48.0 -\n    (Math.sin(8.0 * sigma) * 5.0 * u8Over256) / 512;\n\n  const constants = ellipsoidGeodesic._constants;\n\n  constants.a = a;\n  constants.b = b;\n  constants.f = f;\n  constants.cosineHeading = cosineHeading;\n  constants.sineHeading = sineHeading;\n  constants.tanU = tanU;\n  constants.cosineU = cosineU;\n  constants.sineU = sineU;\n  constants.sigma = sigma;\n  constants.sineAlpha = sineAlpha;\n  constants.sineSquaredAlpha = sineSquaredAlpha;\n  constants.cosineSquaredAlpha = cosineSquaredAlpha;\n  constants.cosineAlpha = cosineAlpha;\n  constants.u2Over4 = u2Over4;\n  constants.u4Over16 = u4Over16;\n  constants.u6Over64 = u6Over64;\n  constants.u8Over256 = u8Over256;\n  constants.a0 = a0;\n  constants.a1 = a1;\n  constants.a2 = a2;\n  constants.a3 = a3;\n  constants.distanceRatio = distanceRatio;\n}\n\nfunction computeC(f, cosineSquaredAlpha) {\n  return (\n    (f * cosineSquaredAlpha * (4.0 + f * (4.0 - 3.0 * cosineSquaredAlpha))) /\n    16.0\n  );\n}\n\nfunction computeDeltaLambda(\n  f,\n  sineAlpha,\n  cosineSquaredAlpha,\n  sigma,\n  sineSigma,\n  cosineSigma,\n  cosineTwiceSigmaMidpoint,\n) {\n  const C = computeC(f, cosineSquaredAlpha);\n\n  return (\n    (1.0 - C) *\n    f *\n    sineAlpha *\n    (sigma +\n      C *\n        sineSigma *\n        (cosineTwiceSigmaMidpoint +\n          C *\n            cosineSigma *\n            (2.0 * cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint - 1.0)))\n  );\n}\n\nfunction vincentyInverseFormula(\n  ellipsoidGeodesic,\n  major,\n  minor,\n  firstLongitude,\n  firstLatitude,\n  secondLongitude,\n  secondLatitude,\n) {\n  const eff = (major - minor) / major;\n  const l = secondLongitude - firstLongitude;\n\n  const u1 = Math.atan((1 - eff) * Math.tan(firstLatitude));\n  const u2 = Math.atan((1 - eff) * Math.tan(secondLatitude));\n\n  const cosineU1 = Math.cos(u1);\n  const sineU1 = Math.sin(u1);\n  const cosineU2 = Math.cos(u2);\n  const sineU2 = Math.sin(u2);\n\n  const cc = cosineU1 * cosineU2;\n  const cs = cosineU1 * sineU2;\n  const ss = sineU1 * sineU2;\n  const sc = sineU1 * cosineU2;\n\n  let lambda = l;\n  let lambdaDot = CesiumMath.TWO_PI;\n\n  let cosineLambda = Math.cos(lambda);\n  let sineLambda = Math.sin(lambda);\n\n  let sigma;\n  let cosineSigma;\n  let sineSigma;\n  let cosineSquaredAlpha;\n  let cosineTwiceSigmaMidpoint;\n\n  do {\n    cosineLambda = Math.cos(lambda);\n    sineLambda = Math.sin(lambda);\n\n    const temp = cs - sc * cosineLambda;\n    sineSigma = Math.sqrt(\n      cosineU2 * cosineU2 * sineLambda * sineLambda + temp * temp,\n    );\n    cosineSigma = ss + cc * cosineLambda;\n\n    sigma = Math.atan2(sineSigma, cosineSigma);\n\n    let sineAlpha;\n\n    if (sineSigma === 0.0) {\n      sineAlpha = 0.0;\n      cosineSquaredAlpha = 1.0;\n    } else {\n      sineAlpha = (cc * sineLambda) / sineSigma;\n      cosineSquaredAlpha = 1.0 - sineAlpha * sineAlpha;\n    }\n\n    lambdaDot = lambda;\n\n    cosineTwiceSigmaMidpoint = cosineSigma - (2.0 * ss) / cosineSquaredAlpha;\n\n    if (!isFinite(cosineTwiceSigmaMidpoint)) {\n      cosineTwiceSigmaMidpoint = 0.0;\n    }\n\n    lambda =\n      l +\n      computeDeltaLambda(\n        eff,\n        sineAlpha,\n        cosineSquaredAlpha,\n        sigma,\n        sineSigma,\n        cosineSigma,\n        cosineTwiceSigmaMidpoint,\n      );\n  } while (Math.abs(lambda - lambdaDot) > CesiumMath.EPSILON12);\n\n  const uSquared =\n    (cosineSquaredAlpha * (major * major - minor * minor)) / (minor * minor);\n  const A =\n    1.0 +\n    (uSquared *\n      (4096.0 + uSquared * (uSquared * (320.0 - 175.0 * uSquared) - 768.0))) /\n      16384.0;\n  const B =\n    (uSquared *\n      (256.0 + uSquared * (uSquared * (74.0 - 47.0 * uSquared) - 128.0))) /\n    1024.0;\n\n  const cosineSquaredTwiceSigmaMidpoint =\n    cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint;\n  const deltaSigma =\n    B *\n    sineSigma *\n    (cosineTwiceSigmaMidpoint +\n      (B *\n        (cosineSigma * (2.0 * cosineSquaredTwiceSigmaMidpoint - 1.0) -\n          (B *\n            cosineTwiceSigmaMidpoint *\n            (4.0 * sineSigma * sineSigma - 3.0) *\n            (4.0 * cosineSquaredTwiceSigmaMidpoint - 3.0)) /\n            6.0)) /\n        4.0);\n\n  const distance = minor * A * (sigma - deltaSigma);\n\n  const startHeading = Math.atan2(\n    cosineU2 * sineLambda,\n    cs - sc * cosineLambda,\n  );\n  const endHeading = Math.atan2(cosineU1 * sineLambda, cs * cosineLambda - sc);\n\n  ellipsoidGeodesic._distance = distance;\n  ellipsoidGeodesic._startHeading = startHeading;\n  ellipsoidGeodesic._endHeading = endHeading;\n  ellipsoidGeodesic._uSquared = uSquared;\n}\n\nconst scratchCart1 = new Cartesian3();\nconst scratchCart2 = new Cartesian3();\nfunction computeProperties(ellipsoidGeodesic, start, end, ellipsoid) {\n  const firstCartesian = Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(start, scratchCart2),\n    scratchCart1,\n  );\n  const lastCartesian = Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(end, scratchCart2),\n    scratchCart2,\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"value\",\n    Math.abs(\n      Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) -\n        Math.PI,\n    ),\n    0.0125,\n  );\n  //>>includeEnd('debug');\n\n  vincentyInverseFormula(\n    ellipsoidGeodesic,\n    ellipsoid.maximumRadius,\n    ellipsoid.minimumRadius,\n    start.longitude,\n    start.latitude,\n    end.longitude,\n    end.latitude,\n  );\n\n  ellipsoidGeodesic._start = Cartographic.clone(\n    start,\n    ellipsoidGeodesic._start,\n  );\n  ellipsoidGeodesic._end = Cartographic.clone(end, ellipsoidGeodesic._end);\n  ellipsoidGeodesic._start.height = 0;\n  ellipsoidGeodesic._end.height = 0;\n\n  setConstants(ellipsoidGeodesic);\n}\n\n/**\n * Initializes a geodesic on the ellipsoid connecting the two provided planetodetic points.\n *\n * @alias EllipsoidGeodesic\n * @constructor\n *\n * @param {Cartographic} [start] The initial planetodetic point on the path.\n * @param {Cartographic} [end] The final planetodetic point on the path.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the geodesic lies.\n */\nfunction EllipsoidGeodesic(start, end, ellipsoid) {\n  const e = ellipsoid ?? Ellipsoid.default;\n  this._ellipsoid = e;\n  this._start = new Cartographic();\n  this._end = new Cartographic();\n\n  this._constants = {};\n  this._startHeading = undefined;\n  this._endHeading = undefined;\n  this._distance = undefined;\n  this._uSquared = undefined;\n\n  if (defined(start) && defined(end)) {\n    computeProperties(this, start, end, e);\n  }\n}\n\nObject.defineProperties(EllipsoidGeodesic.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the surface distance between the start and end point\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {number}\n   * @readonly\n   */\n  surfaceDistance: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._distance;\n    },\n  },\n\n  /**\n   * Gets the initial planetodetic point on the path.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  start: {\n    get: function () {\n      return this._start;\n    },\n  },\n\n  /**\n   * Gets the final planetodetic point on the path.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  end: {\n    get: function () {\n      return this._end;\n    },\n  },\n\n  /**\n   * Gets the heading at the initial point.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {number}\n   * @readonly\n   */\n  startHeading: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._startHeading;\n    },\n  },\n\n  /**\n   * Gets the heading at the final point.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {number}\n   * @readonly\n   */\n  endHeading: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._endHeading;\n    },\n  },\n});\n\n/**\n * Sets the start and end points of the geodesic\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Cartographic} end The final planetodetic point on the path.\n */\nEllipsoidGeodesic.prototype.setEndPoints = function (start, end) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"start\", start);\n  Check.defined(\"end\", end);\n  //>>includeEnd('debug');\n\n  computeProperties(this, start, end, this._ellipsoid);\n};\n\n/**\n * Provides the location of a point at the indicated portion along the geodesic.\n *\n * @param {number} fraction The portion of the distance between the initial and final points.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the geodesic.\n */\nEllipsoidGeodesic.prototype.interpolateUsingFraction = function (\n  fraction,\n  result,\n) {\n  return this.interpolateUsingSurfaceDistance(\n    this._distance * fraction,\n    result,\n  );\n};\n\n/**\n * Provides the location of a point at the indicated distance along the geodesic.\n *\n * @param {number} distance The distance from the initial point to the point of interest along the geodesic\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the geodesic.\n *\n * @exception {DeveloperError} start and end must be set before calling function interpolateUsingSurfaceDistance\n */\nEllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance = function (\n  distance,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"distance\", this._distance);\n  //>>includeEnd('debug');\n\n  const constants = this._constants;\n\n  const s = constants.distanceRatio + distance / constants.b;\n\n  const cosine2S = Math.cos(2.0 * s);\n  const cosine4S = Math.cos(4.0 * s);\n  const cosine6S = Math.cos(6.0 * s);\n  const sine2S = Math.sin(2.0 * s);\n  const sine4S = Math.sin(4.0 * s);\n  const sine6S = Math.sin(6.0 * s);\n  const sine8S = Math.sin(8.0 * s);\n\n  const s2 = s * s;\n  const s3 = s * s2;\n\n  const u8Over256 = constants.u8Over256;\n  const u2Over4 = constants.u2Over4;\n  const u6Over64 = constants.u6Over64;\n  const u4Over16 = constants.u4Over16;\n  let sigma =\n    (2.0 * s3 * u8Over256 * cosine2S) / 3.0 +\n    s *\n      (1.0 -\n        u2Over4 +\n        (7.0 * u4Over16) / 4.0 -\n        (15.0 * u6Over64) / 4.0 +\n        (579.0 * u8Over256) / 64.0 -\n        (u4Over16 - (15.0 * u6Over64) / 4.0 + (187.0 * u8Over256) / 16.0) *\n          cosine2S -\n        ((5.0 * u6Over64) / 4.0 - (115.0 * u8Over256) / 16.0) * cosine4S -\n        (29.0 * u8Over256 * cosine6S) / 16.0) +\n    (u2Over4 / 2.0 -\n      u4Over16 +\n      (71.0 * u6Over64) / 32.0 -\n      (85.0 * u8Over256) / 16.0) *\n      sine2S +\n    ((5.0 * u4Over16) / 16.0 -\n      (5.0 * u6Over64) / 4.0 +\n      (383.0 * u8Over256) / 96.0) *\n      sine4S -\n    s2 *\n      ((u6Over64 - (11.0 * u8Over256) / 2.0) * sine2S +\n        (5.0 * u8Over256 * sine4S) / 2.0) +\n    ((29.0 * u6Over64) / 96.0 - (29.0 * u8Over256) / 16.0) * sine6S +\n    (539.0 * u8Over256 * sine8S) / 1536.0;\n\n  const theta = Math.asin(Math.sin(sigma) * constants.cosineAlpha);\n  const latitude = Math.atan((constants.a / constants.b) * Math.tan(theta));\n\n  // Redefine in terms of relative argument of latitude.\n  sigma = sigma - constants.sigma;\n\n  const cosineTwiceSigmaMidpoint = Math.cos(2.0 * constants.sigma + sigma);\n\n  const sineSigma = Math.sin(sigma);\n  const cosineSigma = Math.cos(sigma);\n\n  const cc = constants.cosineU * cosineSigma;\n  const ss = constants.sineU * sineSigma;\n\n  const lambda = Math.atan2(\n    sineSigma * constants.sineHeading,\n    cc - ss * constants.cosineHeading,\n  );\n\n  const l =\n    lambda -\n    computeDeltaLambda(\n      constants.f,\n      constants.sineAlpha,\n      constants.cosineSquaredAlpha,\n      sigma,\n      sineSigma,\n      cosineSigma,\n      cosineTwiceSigmaMidpoint,\n    );\n\n  if (defined(result)) {\n    result.longitude = this._start.longitude + l;\n    result.latitude = latitude;\n    result.height = 0.0;\n    return result;\n  }\n\n  return new Cartographic(this._start.longitude + l, latitude, 0.0);\n};\nexport default EllipsoidGeodesic;\n"],"names":["setConstants","ellipsoidGeodesic","uSquared","_uSquared","a","_ellipsoid","maximumRadius","b","minimumRadius","f","cosineHeading","Math","cos","_startHeading","sineHeading","sin","tanU","tan","_start","latitude","cosineU","sqrt","sineU","sigma","atan2","sineAlpha","sineSquaredAlpha","cosineSquaredAlpha","cosineAlpha","u2Over4","u4Over16","u6Over64","u8Over256","a0","a1","a2","a3","distanceRatio","constants","_constants","computeC","computeDeltaLambda","sineSigma","cosineSigma","cosineTwiceSigmaMidpoint","C","vincentyInverseFormula","major","minor","firstLongitude","firstLatitude","secondLongitude","secondLatitude","eff","l","u1","atan","u2","cosineU1","sineU1","cosineU2","sineU2","cc","cs","ss","sc","lambda","lambdaDot","TWO_PI","cosineLambda","sineLambda","temp","isFinite","abs","EPSILON12","A","B","cosineSquaredTwiceSigmaMidpoint","deltaSigma","distance","startHeading","endHeading","_distance","_endHeading","scratchCart1","scratchCart2","computeProperties","start","end","ellipsoid","firstCartesian","normalize","cartographicToCartesian","lastCartesian","typeOf","number","greaterThanOrEquals","angleBetween","PI","longitude","clone","_end","height","EllipsoidGeodesic","e","default","undefined","Object","defineProperties","prototype","get","surfaceDistance","defined","setEndPoints","interpolateUsingFraction","fraction","result","interpolateUsingSurfaceDistance","s","cosine2S","cosine4S","cosine6S","sine2S","sine4S","sine6S","sine8S","s2","s3","theta","asin"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 19528, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/EllipsoidRhumbLine.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\n\nfunction calculateM(ellipticity, major, latitude) {\n  if (ellipticity === 0.0) {\n    // sphere\n    return major * latitude;\n  }\n\n  const e2 = ellipticity * ellipticity;\n  const e4 = e2 * e2;\n  const e6 = e4 * e2;\n  const e8 = e6 * e2;\n  const e10 = e8 * e2;\n  const e12 = e10 * e2;\n  const phi = latitude;\n  const sin2Phi = Math.sin(2 * phi);\n  const sin4Phi = Math.sin(4 * phi);\n  const sin6Phi = Math.sin(6 * phi);\n  const sin8Phi = Math.sin(8 * phi);\n  const sin10Phi = Math.sin(10 * phi);\n  const sin12Phi = Math.sin(12 * phi);\n\n  return (\n    major *\n    ((1 -\n      e2 / 4 -\n      (3 * e4) / 64 -\n      (5 * e6) / 256 -\n      (175 * e8) / 16384 -\n      (441 * e10) / 65536 -\n      (4851 * e12) / 1048576) *\n      phi -\n      ((3 * e2) / 8 +\n        (3 * e4) / 32 +\n        (45 * e6) / 1024 +\n        (105 * e8) / 4096 +\n        (2205 * e10) / 131072 +\n        (6237 * e12) / 524288) *\n        sin2Phi +\n      ((15 * e4) / 256 +\n        (45 * e6) / 1024 +\n        (525 * e8) / 16384 +\n        (1575 * e10) / 65536 +\n        (155925 * e12) / 8388608) *\n        sin4Phi -\n      ((35 * e6) / 3072 +\n        (175 * e8) / 12288 +\n        (3675 * e10) / 262144 +\n        (13475 * e12) / 1048576) *\n        sin6Phi +\n      ((315 * e8) / 131072 + (2205 * e10) / 524288 + (43659 * e12) / 8388608) *\n        sin8Phi -\n      ((693 * e10) / 1310720 + (6237 * e12) / 5242880) * sin10Phi +\n      ((1001 * e12) / 8388608) * sin12Phi)\n  );\n}\n\nfunction calculateInverseM(M, ellipticity, major) {\n  const d = M / major;\n\n  if (ellipticity === 0.0) {\n    // sphere\n    return d;\n  }\n\n  const d2 = d * d;\n  const d3 = d2 * d;\n  const d4 = d3 * d;\n  const e = ellipticity;\n  const e2 = e * e;\n  const e4 = e2 * e2;\n  const e6 = e4 * e2;\n  const e8 = e6 * e2;\n  const e10 = e8 * e2;\n  const e12 = e10 * e2;\n  const sin2D = Math.sin(2 * d);\n  const cos2D = Math.cos(2 * d);\n  const sin4D = Math.sin(4 * d);\n  const cos4D = Math.cos(4 * d);\n  const sin6D = Math.sin(6 * d);\n  const cos6D = Math.cos(6 * d);\n  const sin8D = Math.sin(8 * d);\n  const cos8D = Math.cos(8 * d);\n  const sin10D = Math.sin(10 * d);\n  const cos10D = Math.cos(10 * d);\n  const sin12D = Math.sin(12 * d);\n\n  return (\n    d +\n    (d * e2) / 4 +\n    (7 * d * e4) / 64 +\n    (15 * d * e6) / 256 +\n    (579 * d * e8) / 16384 +\n    (1515 * d * e10) / 65536 +\n    (16837 * d * e12) / 1048576 +\n    ((3 * d * e4) / 16 +\n      (45 * d * e6) / 256 -\n      (d * (32 * d2 - 561) * e8) / 4096 -\n      (d * (232 * d2 - 1677) * e10) / 16384 +\n      (d * (399985 - 90560 * d2 + 512 * d4) * e12) / 5242880) *\n      cos2D +\n    ((21 * d * e6) / 256 +\n      (483 * d * e8) / 4096 -\n      (d * (224 * d2 - 1969) * e10) / 16384 -\n      (d * (33152 * d2 - 112599) * e12) / 1048576) *\n      cos4D +\n    ((151 * d * e8) / 4096 +\n      (4681 * d * e10) / 65536 +\n      (1479 * d * e12) / 16384 -\n      (453 * d3 * e12) / 32768) *\n      cos6D +\n    ((1097 * d * e10) / 65536 + (42783 * d * e12) / 1048576) * cos8D +\n    ((8011 * d * e12) / 1048576) * cos10D +\n    ((3 * e2) / 8 +\n      (3 * e4) / 16 +\n      (213 * e6) / 2048 -\n      (3 * d2 * e6) / 64 +\n      (255 * e8) / 4096 -\n      (33 * d2 * e8) / 512 +\n      (20861 * e10) / 524288 -\n      (33 * d2 * e10) / 512 +\n      (d4 * e10) / 1024 +\n      (28273 * e12) / 1048576 -\n      (471 * d2 * e12) / 8192 +\n      (9 * d4 * e12) / 4096) *\n      sin2D +\n    ((21 * e4) / 256 +\n      (21 * e6) / 256 +\n      (533 * e8) / 8192 -\n      (21 * d2 * e8) / 512 +\n      (197 * e10) / 4096 -\n      (315 * d2 * e10) / 4096 +\n      (584039 * e12) / 16777216 -\n      (12517 * d2 * e12) / 131072 +\n      (7 * d4 * e12) / 2048) *\n      sin4D +\n    ((151 * e6) / 6144 +\n      (151 * e8) / 4096 +\n      (5019 * e10) / 131072 -\n      (453 * d2 * e10) / 16384 +\n      (26965 * e12) / 786432 -\n      (8607 * d2 * e12) / 131072) *\n      sin6D +\n    ((1097 * e8) / 131072 +\n      (1097 * e10) / 65536 +\n      (225797 * e12) / 10485760 -\n      (1097 * d2 * e12) / 65536) *\n      sin8D +\n    ((8011 * e10) / 2621440 + (8011 * e12) / 1048576) * sin10D +\n    ((293393 * e12) / 251658240) * sin12D\n  );\n}\n\nfunction calculateSigma(ellipticity, latitude) {\n  if (ellipticity === 0.0) {\n    // sphere\n    return Math.log(Math.tan(0.5 * (CesiumMath.PI_OVER_TWO + latitude)));\n  }\n\n  const eSinL = ellipticity * Math.sin(latitude);\n  return (\n    Math.log(Math.tan(0.5 * (CesiumMath.PI_OVER_TWO + latitude))) -\n    (ellipticity / 2.0) * Math.log((1 + eSinL) / (1 - eSinL))\n  );\n}\n\nfunction calculateHeading(\n  ellipsoidRhumbLine,\n  firstLongitude,\n  firstLatitude,\n  secondLongitude,\n  secondLatitude,\n) {\n  const sigma1 = calculateSigma(ellipsoidRhumbLine._ellipticity, firstLatitude);\n  const sigma2 = calculateSigma(\n    ellipsoidRhumbLine._ellipticity,\n    secondLatitude,\n  );\n  return Math.atan2(\n    CesiumMath.negativePiToPi(secondLongitude - firstLongitude),\n    sigma2 - sigma1,\n  );\n}\n\nfunction calculateArcLength(\n  ellipsoidRhumbLine,\n  major,\n  minor,\n  firstLongitude,\n  firstLatitude,\n  secondLongitude,\n  secondLatitude,\n) {\n  const heading = ellipsoidRhumbLine._heading;\n  const deltaLongitude = secondLongitude - firstLongitude;\n\n  let distance = 0.0;\n\n  //Check to see if the rhumb line has constant latitude\n  //This equation will diverge if heading gets close to 90 degrees\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(heading),\n      CesiumMath.PI_OVER_TWO,\n      CesiumMath.EPSILON8,\n    )\n  ) {\n    //If heading is close to 90 degrees\n    if (major === minor) {\n      distance =\n        major *\n        Math.cos(firstLatitude) *\n        CesiumMath.negativePiToPi(deltaLongitude);\n    } else {\n      const sinPhi = Math.sin(firstLatitude);\n      distance =\n        (major *\n          Math.cos(firstLatitude) *\n          CesiumMath.negativePiToPi(deltaLongitude)) /\n        Math.sqrt(1 - ellipsoidRhumbLine._ellipticitySquared * sinPhi * sinPhi);\n    }\n  } else {\n    const M1 = calculateM(\n      ellipsoidRhumbLine._ellipticity,\n      major,\n      firstLatitude,\n    );\n    const M2 = calculateM(\n      ellipsoidRhumbLine._ellipticity,\n      major,\n      secondLatitude,\n    );\n\n    distance = (M2 - M1) / Math.cos(heading);\n  }\n  return Math.abs(distance);\n}\n\nconst scratchCart1 = new Cartesian3();\nconst scratchCart2 = new Cartesian3();\n\nfunction computeProperties(ellipsoidRhumbLine, start, end, ellipsoid) {\n  const firstCartesian = Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(start, scratchCart2),\n    scratchCart1,\n  );\n  const lastCartesian = Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(end, scratchCart2),\n    scratchCart2,\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"value\",\n    Math.abs(\n      Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) -\n        Math.PI,\n    ),\n    0.0125,\n  );\n  //>>includeEnd('debug');\n\n  const major = ellipsoid.maximumRadius;\n  const minor = ellipsoid.minimumRadius;\n  const majorSquared = major * major;\n  const minorSquared = minor * minor;\n  ellipsoidRhumbLine._ellipticitySquared =\n    (majorSquared - minorSquared) / majorSquared;\n  ellipsoidRhumbLine._ellipticity = Math.sqrt(\n    ellipsoidRhumbLine._ellipticitySquared,\n  );\n\n  ellipsoidRhumbLine._start = Cartographic.clone(\n    start,\n    ellipsoidRhumbLine._start,\n  );\n  ellipsoidRhumbLine._start.height = 0;\n\n  ellipsoidRhumbLine._end = Cartographic.clone(end, ellipsoidRhumbLine._end);\n  ellipsoidRhumbLine._end.height = 0;\n\n  ellipsoidRhumbLine._heading = calculateHeading(\n    ellipsoidRhumbLine,\n    start.longitude,\n    start.latitude,\n    end.longitude,\n    end.latitude,\n  );\n  ellipsoidRhumbLine._distance = calculateArcLength(\n    ellipsoidRhumbLine,\n    ellipsoid.maximumRadius,\n    ellipsoid.minimumRadius,\n    start.longitude,\n    start.latitude,\n    end.longitude,\n    end.latitude,\n  );\n}\n\nfunction interpolateUsingSurfaceDistance(\n  start,\n  heading,\n  distance,\n  major,\n  ellipticity,\n  result,\n) {\n  if (distance === 0.0) {\n    return Cartographic.clone(start, result);\n  }\n\n  const ellipticitySquared = ellipticity * ellipticity;\n\n  let longitude;\n  let latitude;\n  let deltaLongitude;\n\n  //Check to see if the rhumb line has constant latitude\n  //This won't converge if heading is close to 90 degrees\n  if (\n    Math.abs(CesiumMath.PI_OVER_TWO - Math.abs(heading)) > CesiumMath.EPSILON8\n  ) {\n    //Calculate latitude of the second point\n    const M1 = calculateM(ellipticity, major, start.latitude);\n    const deltaM = distance * Math.cos(heading);\n    const M2 = M1 + deltaM;\n    latitude = calculateInverseM(M2, ellipticity, major);\n\n    //Now find the longitude of the second point\n\n    // Check to see if the rhumb line has constant longitude\n    if (Math.abs(heading) < CesiumMath.EPSILON10) {\n      longitude = CesiumMath.negativePiToPi(start.longitude);\n    } else {\n      const sigma1 = calculateSigma(ellipticity, start.latitude);\n      const sigma2 = calculateSigma(ellipticity, latitude);\n      deltaLongitude = Math.tan(heading) * (sigma2 - sigma1);\n      longitude = CesiumMath.negativePiToPi(start.longitude + deltaLongitude);\n    }\n  } else {\n    //If heading is close to 90 degrees\n    latitude = start.latitude;\n    let localRad;\n\n    if (ellipticity === 0.0) {\n      // sphere\n      localRad = major * Math.cos(start.latitude);\n    } else {\n      const sinPhi = Math.sin(start.latitude);\n      localRad =\n        (major * Math.cos(start.latitude)) /\n        Math.sqrt(1 - ellipticitySquared * sinPhi * sinPhi);\n    }\n\n    deltaLongitude = distance / localRad;\n    if (heading > 0.0) {\n      longitude = CesiumMath.negativePiToPi(start.longitude + deltaLongitude);\n    } else {\n      longitude = CesiumMath.negativePiToPi(start.longitude - deltaLongitude);\n    }\n  }\n\n  if (defined(result)) {\n    result.longitude = longitude;\n    result.latitude = latitude;\n    result.height = 0;\n\n    return result;\n  }\n\n  return new Cartographic(longitude, latitude, 0);\n}\n\n/**\n * Initializes a rhumb line on the ellipsoid connecting the two provided planetodetic points.\n *\n * @alias EllipsoidRhumbLine\n * @constructor\n *\n * @param {Cartographic} [start] The initial planetodetic point on the path.\n * @param {Cartographic} [end] The final planetodetic point on the path.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the rhumb line lies.\n *\n * @exception {DeveloperError} angle between start and end must be at least 0.0125 radians.\n */\nfunction EllipsoidRhumbLine(start, end, ellipsoid) {\n  const e = ellipsoid ?? Ellipsoid.default;\n  this._ellipsoid = e;\n  this._start = new Cartographic();\n  this._end = new Cartographic();\n\n  this._heading = undefined;\n  this._distance = undefined;\n  this._ellipticity = undefined;\n  this._ellipticitySquared = undefined;\n\n  if (defined(start) && defined(end)) {\n    computeProperties(this, start, end, e);\n  }\n}\n\nObject.defineProperties(EllipsoidRhumbLine.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the surface distance between the start and end point\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {number}\n   * @readonly\n   */\n  surfaceDistance: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._distance;\n    },\n  },\n\n  /**\n   * Gets the initial planetodetic point on the path.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  start: {\n    get: function () {\n      return this._start;\n    },\n  },\n\n  /**\n   * Gets the final planetodetic point on the path.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  end: {\n    get: function () {\n      return this._end;\n    },\n  },\n\n  /**\n   * Gets the heading from the start point to the end point.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {number}\n   * @readonly\n   */\n  heading: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._heading;\n    },\n  },\n});\n\n/**\n * Create a rhumb line using an initial position with a heading and distance.\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {number} heading The heading in radians.\n * @param {number} distance The rhumb line distance between the start and end point.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the rhumb line lies.\n * @param {EllipsoidRhumbLine} [result] The object in which to store the result.\n * @returns {EllipsoidRhumbLine} The EllipsoidRhumbLine object.\n */\nEllipsoidRhumbLine.fromStartHeadingDistance = function (\n  start,\n  heading,\n  distance,\n  ellipsoid,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"start\", start);\n  Check.defined(\"heading\", heading);\n  Check.defined(\"distance\", distance);\n  Check.typeOf.number.greaterThan(\"distance\", distance, 0.0);\n  //>>includeEnd('debug');\n\n  const e = ellipsoid ?? Ellipsoid.default;\n  const major = e.maximumRadius;\n  const minor = e.minimumRadius;\n  const majorSquared = major * major;\n  const minorSquared = minor * minor;\n  const ellipticity = Math.sqrt((majorSquared - minorSquared) / majorSquared);\n\n  heading = CesiumMath.negativePiToPi(heading);\n  const end = interpolateUsingSurfaceDistance(\n    start,\n    heading,\n    distance,\n    e.maximumRadius,\n    ellipticity,\n  );\n\n  if (\n    !defined(result) ||\n    (defined(ellipsoid) && !ellipsoid.equals(result.ellipsoid))\n  ) {\n    return new EllipsoidRhumbLine(start, end, e);\n  }\n\n  result.setEndPoints(start, end);\n  return result;\n};\n\n/**\n * Sets the start and end points of the rhumb line.\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Cartographic} end The final planetodetic point on the path.\n */\nEllipsoidRhumbLine.prototype.setEndPoints = function (start, end) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"start\", start);\n  Check.defined(\"end\", end);\n  //>>includeEnd('debug');\n\n  computeProperties(this, start, end, this._ellipsoid);\n};\n\n/**\n * Provides the location of a point at the indicated portion along the rhumb line.\n *\n * @param {number} fraction The portion of the distance between the initial and final points.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the rhumb line.\n */\nEllipsoidRhumbLine.prototype.interpolateUsingFraction = function (\n  fraction,\n  result,\n) {\n  return this.interpolateUsingSurfaceDistance(\n    fraction * this._distance,\n    result,\n  );\n};\n\n/**\n * Provides the location of a point at the indicated distance along the rhumb line.\n *\n * @param {number} distance The distance from the initial point to the point of interest along the rhumbLine.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the rhumb line.\n *\n * @exception {DeveloperError} start and end must be set before calling function interpolateUsingSurfaceDistance\n */\nEllipsoidRhumbLine.prototype.interpolateUsingSurfaceDistance = function (\n  distance,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"distance\", distance);\n  if (!defined(this._distance) || this._distance === 0.0) {\n    throw new DeveloperError(\n      \"EllipsoidRhumbLine must have distinct start and end set.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  return interpolateUsingSurfaceDistance(\n    this._start,\n    this._heading,\n    distance,\n    this._ellipsoid.maximumRadius,\n    this._ellipticity,\n    result,\n  );\n};\n\n/**\n * Provides the location of a point at the indicated longitude along the rhumb line.\n * If the longitude is outside the range of start and end points, the first intersection with the longitude from the start point in the direction of the heading is returned. This follows the spiral property of a rhumb line.\n *\n * @param {number} intersectionLongitude The longitude, in radians, at which to find the intersection point from the starting point using the heading.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the intersection point along the rhumb line, undefined if there is no intersection or infinite intersections.\n *\n * @exception {DeveloperError} start and end must be set before calling function findIntersectionWithLongitude.\n */\nEllipsoidRhumbLine.prototype.findIntersectionWithLongitude = function (\n  intersectionLongitude,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"intersectionLongitude\", intersectionLongitude);\n  if (!defined(this._distance) || this._distance === 0.0) {\n    throw new DeveloperError(\n      \"EllipsoidRhumbLine must have distinct start and end set.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const ellipticity = this._ellipticity;\n  const heading = this._heading;\n  const absHeading = Math.abs(heading);\n  const start = this._start;\n\n  intersectionLongitude = CesiumMath.negativePiToPi(intersectionLongitude);\n\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(intersectionLongitude),\n      Math.PI,\n      CesiumMath.EPSILON14,\n    )\n  ) {\n    intersectionLongitude = CesiumMath.sign(start.longitude) * Math.PI;\n  }\n\n  if (!defined(result)) {\n    result = new Cartographic();\n  }\n\n  // If heading is -PI/2 or PI/2, this is an E-W rhumb line\n  // If heading is 0 or PI, this is an N-S rhumb line\n  if (Math.abs(CesiumMath.PI_OVER_TWO - absHeading) <= CesiumMath.EPSILON8) {\n    result.longitude = intersectionLongitude;\n    result.latitude = start.latitude;\n    result.height = 0;\n    return result;\n  } else if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(CesiumMath.PI_OVER_TWO - absHeading),\n      CesiumMath.PI_OVER_TWO,\n      CesiumMath.EPSILON8,\n    )\n  ) {\n    if (\n      CesiumMath.equalsEpsilon(\n        intersectionLongitude,\n        start.longitude,\n        CesiumMath.EPSILON12,\n      )\n    ) {\n      return undefined;\n    }\n\n    result.longitude = intersectionLongitude;\n    result.latitude =\n      CesiumMath.PI_OVER_TWO *\n      CesiumMath.sign(CesiumMath.PI_OVER_TWO - heading);\n    result.height = 0;\n    return result;\n  }\n\n  // Use iterative solver from Equation 9 from http://edwilliams.org/ellipsoid/ellipsoid.pdf\n  const phi1 = start.latitude;\n  const eSinPhi1 = ellipticity * Math.sin(phi1);\n  const leftComponent =\n    Math.tan(0.5 * (CesiumMath.PI_OVER_TWO + phi1)) *\n    Math.exp((intersectionLongitude - start.longitude) / Math.tan(heading));\n  const denominator = (1 + eSinPhi1) / (1 - eSinPhi1);\n\n  let newPhi = start.latitude;\n  let phi;\n  do {\n    phi = newPhi;\n    const eSinPhi = ellipticity * Math.sin(phi);\n    const numerator = (1 + eSinPhi) / (1 - eSinPhi);\n    newPhi =\n      2 *\n        Math.atan(\n          leftComponent * Math.pow(numerator / denominator, ellipticity / 2),\n        ) -\n      CesiumMath.PI_OVER_TWO;\n  } while (!CesiumMath.equalsEpsilon(newPhi, phi, CesiumMath.EPSILON12));\n\n  result.longitude = intersectionLongitude;\n  result.latitude = newPhi;\n  result.height = 0;\n  return result;\n};\n\n/**\n * Provides the location of a point at the indicated latitude along the rhumb line.\n * If the latitude is outside the range of start and end points, the first intersection with the latitude from that start point in the direction of the heading is returned. This follows the spiral property of a rhumb line.\n *\n * @param {number} intersectionLatitude The latitude, in radians, at which to find the intersection point from the starting point using the heading.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the intersection point along the rhumb line, undefined if there is no intersection or infinite intersections.\n *\n * @exception {DeveloperError} start and end must be set before calling function findIntersectionWithLongitude.\n */\nEllipsoidRhumbLine.prototype.findIntersectionWithLatitude = function (\n  intersectionLatitude,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"intersectionLatitude\", intersectionLatitude);\n  if (!defined(this._distance) || this._distance === 0.0) {\n    throw new DeveloperError(\n      \"EllipsoidRhumbLine must have distinct start and end set.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const ellipticity = this._ellipticity;\n  const heading = this._heading;\n  const start = this._start;\n\n  // If start and end have same latitude, return undefined since it's either no intersection or infinite intersections\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(heading),\n      CesiumMath.PI_OVER_TWO,\n      CesiumMath.EPSILON8,\n    )\n  ) {\n    return;\n  }\n\n  // Can be solved using the same equations from interpolateUsingSurfaceDistance\n  const sigma1 = calculateSigma(ellipticity, start.latitude);\n  const sigma2 = calculateSigma(ellipticity, intersectionLatitude);\n  const deltaLongitude = Math.tan(heading) * (sigma2 - sigma1);\n  const longitude = CesiumMath.negativePiToPi(start.longitude + deltaLongitude);\n\n  if (defined(result)) {\n    result.longitude = longitude;\n    result.latitude = intersectionLatitude;\n    result.height = 0;\n\n    return result;\n  }\n\n  return new Cartographic(longitude, intersectionLatitude, 0);\n};\nexport default EllipsoidRhumbLine;\n"],"names":["calculateM","ellipticity","major","latitude","e2","e4","e6","e8","e10","e12","phi","sin2Phi","Math","sin","sin4Phi","sin6Phi","sin8Phi","sin10Phi","sin12Phi","calculateInverseM","M","d","d2","d3","d4","e","sin2D","cos2D","cos","sin4D","cos4D","sin6D","cos6D","sin8D","cos8D","sin10D","cos10D","sin12D","calculateSigma","log","tan","PI_OVER_TWO","eSinL","calculateHeading","ellipsoidRhumbLine","firstLongitude","firstLatitude","secondLongitude","secondLatitude","sigma1","_ellipticity","sigma2","atan2","negativePiToPi","calculateArcLength","minor","heading","_heading","deltaLongitude","distance","equalsEpsilon","abs","EPSILON8","sinPhi","sqrt","_ellipticitySquared","M1","M2","scratchCart1","scratchCart2","computeProperties","start","end","ellipsoid","firstCartesian","normalize","cartographicToCartesian","lastCartesian","typeOf","number","greaterThanOrEquals","angleBetween","PI","maximumRadius","minimumRadius","majorSquared","minorSquared","_start","clone","height","_end","longitude","_distance","interpolateUsingSurfaceDistance","result","ellipticitySquared","deltaM","EPSILON10","localRad","EllipsoidRhumbLine","default","_ellipsoid","undefined","Object","defineProperties","prototype","get","surfaceDistance","defined","fromStartHeadingDistance","greaterThan","equals","setEndPoints","interpolateUsingFraction","fraction","findIntersectionWithLongitude","intersectionLongitude","absHeading","EPSILON14","sign","EPSILON12","phi1","eSinPhi1","leftComponent","exp","denominator","newPhi","eSinPhi","numerator","atan","pow","findIntersectionWithLatitude","intersectionLatitude"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 19954, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/EncodedCartesian3.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\n\n/**\n * A fixed-point encoding of a {@link Cartesian3} with 64-bit floating-point components, as two {@link Cartesian3}\n * values that, when converted to 32-bit floating-point and added, approximate the original input.\n * <p>\n * This is used to encode positions in vertex buffers for rendering without jittering artifacts\n * as described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n * </p>\n *\n * @alias EncodedCartesian3\n * @constructor\n *\n * @private\n */\nfunction EncodedCartesian3() {\n  /**\n   * The high bits for each component.  Bits 0 to 22 store the whole value.  Bits 23 to 31 are not used.\n   *\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.high = Cartesian3.clone(Cartesian3.ZERO);\n\n  /**\n   * The low bits for each component.  Bits 7 to 22 store the whole value, and bits 0 to 6 store the fraction.  Bits 23 to 31 are not used.\n   *\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.low = Cartesian3.clone(Cartesian3.ZERO);\n}\n\n/**\n * Encodes a 64-bit floating-point value as two floating-point values that, when converted to\n * 32-bit floating-point and added, approximate the original input.  The returned object\n * has <code>high</code> and <code>low</code> properties for the high and low bits, respectively.\n * <p>\n * The fixed-point encoding follows {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n * </p>\n *\n * @param {number} value The floating-point value to encode.\n * @param {object} [result] The object onto which to store the result.\n * @returns {object} The modified result parameter or a new instance if one was not provided.\n *\n * @example\n * const value = 1234567.1234567;\n * const splitValue = Cesium.EncodedCartesian3.encode(value);\n */\nEncodedCartesian3.encode = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = {\n      high: 0.0,\n      low: 0.0,\n    };\n  }\n\n  let doubleHigh;\n  if (value >= 0.0) {\n    doubleHigh = Math.floor(value / 65536.0) * 65536.0;\n    result.high = doubleHigh;\n    result.low = value - doubleHigh;\n  } else {\n    doubleHigh = Math.floor(-value / 65536.0) * 65536.0;\n    result.high = -doubleHigh;\n    result.low = value + doubleHigh;\n  }\n\n  return result;\n};\n\nconst scratchEncode = {\n  high: 0.0,\n  low: 0.0,\n};\n\n/**\n * Encodes a {@link Cartesian3} with 64-bit floating-point components as two {@link Cartesian3}\n * values that, when converted to 32-bit floating-point and added, approximate the original input.\n * <p>\n * The fixed-point encoding follows {@link https://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n * </p>\n *\n * @param {Cartesian3} cartesian The cartesian to encode.\n * @param {EncodedCartesian3} [result] The object onto which to store the result.\n * @returns {EncodedCartesian3} The modified result parameter or a new EncodedCartesian3 instance if one was not provided.\n *\n * @example\n * const cart = new Cesium.Cartesian3(-10000000.0, 0.0, 10000000.0);\n * const encoded = Cesium.EncodedCartesian3.fromCartesian(cart);\n */\nEncodedCartesian3.fromCartesian = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new EncodedCartesian3();\n  }\n\n  const high = result.high;\n  const low = result.low;\n\n  EncodedCartesian3.encode(cartesian.x, scratchEncode);\n  high.x = scratchEncode.high;\n  low.x = scratchEncode.low;\n\n  EncodedCartesian3.encode(cartesian.y, scratchEncode);\n  high.y = scratchEncode.high;\n  low.y = scratchEncode.low;\n\n  EncodedCartesian3.encode(cartesian.z, scratchEncode);\n  high.z = scratchEncode.high;\n  low.z = scratchEncode.low;\n\n  return result;\n};\n\nconst encodedP = new EncodedCartesian3();\n\n/**\n * Encodes the provided <code>cartesian</code>, and writes it to an array with <code>high</code>\n * components followed by <code>low</code> components, i.e. <code>[high.x, high.y, high.z, low.x, low.y, low.z]</code>.\n * <p>\n * This is used to create interleaved high-precision position vertex attributes.\n * </p>\n *\n * @param {Cartesian3} cartesian The cartesian to encode.\n * @param {number[]} cartesianArray The array to write to.\n * @param {number} index The index into the array to start writing.  Six elements will be written.\n *\n * @exception {DeveloperError} index must be a number greater than or equal to 0.\n *\n * @example\n * const positions = [\n *    new Cesium.Cartesian3(),\n *    // ...\n * ];\n * const encodedPositions = new Float32Array(2 * 3 * positions.length);\n * let j = 0;\n * for (let i = 0; i < positions.length; ++i) {\n *   Cesium.EncodedCartesian3.writeElement(positions[i], encodedPositions, j);\n *   j += 6;\n * }\n */\nEncodedCartesian3.writeElements = function (cartesian, cartesianArray, index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesianArray\", cartesianArray);\n  Check.typeOf.number(\"index\", index);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  //>>includeEnd('debug');\n\n  EncodedCartesian3.fromCartesian(cartesian, encodedP);\n  const high = encodedP.high;\n  const low = encodedP.low;\n\n  cartesianArray[index] = high.x;\n  cartesianArray[index + 1] = high.y;\n  cartesianArray[index + 2] = high.z;\n  cartesianArray[index + 3] = low.x;\n  cartesianArray[index + 4] = low.y;\n  cartesianArray[index + 5] = low.z;\n};\nexport default EncodedCartesian3;\n"],"names":["EncodedCartesian3","high","clone","ZERO","low","encode","value","result","typeOf","number","doubleHigh","Math","floor","scratchEncode","fromCartesian","cartesian","object","x","y","z","encodedP","writeElements","cartesianArray","index","defined","greaterThanOrEquals"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 20111, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/GeometryType.js"],"sourcesContent":["/**\n * @private\n */\nconst GeometryType = {\n  NONE: 0,\n  TRIANGLES: 1,\n  LINES: 2,\n  POLYLINES: 3,\n};\nexport default Object.freeze(GeometryType);\n"],"names":["GeometryType","NONE","TRIANGLES","LINES","POLYLINES","Object","freeze"],"mappings":";;;;AAAA;;CAEC,GACD,MAAMA,eAAe;IACnBC,MAAM;IACNC,WAAW;IACXC,OAAO;IACPC,WAAW;AACb;uCACeC,OAAOC,MAAM,CAACN","ignoreList":[0]}},
    {"offset": {"line": 20128, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Matrix2.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * A 2x2 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix2\n * @constructor\n * @implements {ArrayLike<number>}\n *\n * @param {number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {number} [column1Row1=0.0] The value for column 1, row 1.\n *\n * @see Matrix2.fromArray\n * @see Matrix2.fromColumnMajorArray\n * @see Matrix2.fromRowMajorArray\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.fromRotation\n * @see Matrix3\n * @see Matrix4\n */\nfunction Matrix2(column0Row0, column1Row0, column0Row1, column1Row1) {\n  this[0] = column0Row0 ?? 0.0;\n  this[1] = column0Row1 ?? 0.0;\n  this[2] = column1Row0 ?? 0.0;\n  this[3] = column1Row1 ?? 0.0;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nMatrix2.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix2} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nMatrix2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix2} [result] The object into which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n */\nMatrix2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new Matrix2();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  return result;\n};\n\n/**\n * Flattens an array of Matrix2s into an array of components. The components\n * are stored in column-major order.\n *\n * @param {Matrix2[]} array The array of matrices to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.\n * @returns {number[]} The packed array.\n */\nMatrix2.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 4;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 4 elements\",\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Matrix2.pack(array[i], result, i * 4);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of column-major matrix components into an array of Matrix2s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Matrix2[]} [result] The array onto which to store the result.\n * @returns {Matrix2[]} The unpacked array.\n */\nMatrix2.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 4);\n  if (array.length % 4 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 4.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 4);\n  } else {\n    result.length = length / 4;\n  }\n\n  for (let i = 0; i < length; i += 4) {\n    const index = i / 4;\n    result[index] = Matrix2.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Duplicates a Matrix2 instance.\n *\n * @param {Matrix2} matrix The matrix to duplicate.\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix2.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Matrix2(matrix[0], matrix[2], matrix[1], matrix[3]);\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  return result;\n};\n\n/**\n * Creates a Matrix2 from 4 consecutive elements in an array.\n *\n * @function\n * @param {number[]} array The array whose 4 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Create the Matrix2:\n * // [1.0, 2.0]\n * // [1.0, 2.0]\n *\n * const v = [1.0, 1.0, 2.0, 2.0];\n * const m = Cesium.Matrix2.fromArray(v);\n *\n * // Create same Matrix2 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];\n * const m2 = Cesium.Matrix2.fromArray(v2, 2);\n */\nMatrix2.fromArray = Matrix2.unpack;\n/**\n * Creates a Matrix2 instance from a column-major order array.\n *\n * @param {number[]} values The column-major order array.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n */\nMatrix2.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix2.clone(values, result);\n};\n\n/**\n * Creates a Matrix2 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {number[]} values The row-major order array.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n */\nMatrix2.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(values[0], values[1], values[2], values[3]);\n  }\n  result[0] = values[0];\n  result[1] = values[2];\n  result[2] = values[1];\n  result[3] = values[3];\n  return result;\n};\n\n/**\n * Computes a Matrix2 instance representing a non-uniform scale.\n *\n * @param {Cartesian2} scale The x and y scale factors.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0]\n * //   [0.0, 8.0]\n * const m = Cesium.Matrix2.fromScale(new Cesium.Cartesian2(7.0, 8.0));\n */\nMatrix2.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(scale.x, 0.0, 0.0, scale.y);\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = scale.y;\n  return result;\n};\n\n/**\n * Computes a Matrix2 instance representing a uniform scale.\n *\n * @param {number} scale The uniform scale factor.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0]\n * //   [0.0, 2.0]\n * const m = Cesium.Matrix2.fromUniformScale(2.0);\n */\nMatrix2.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(scale, 0.0, 0.0, scale);\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = scale;\n  return result;\n};\n\n/**\n * Creates a rotation matrix.\n *\n * @param {number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise.\n * const p = new Cesium.Cartesian2(5, 6);\n * const m = Cesium.Matrix2.fromRotation(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix2.multiplyByVector(m, p, new Cesium.Cartesian2());\n */\nMatrix2.fromRotation = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix2(cosAngle, -sinAngle, sinAngle, cosAngle);\n  }\n  result[0] = cosAngle;\n  result[1] = sinAngle;\n  result[2] = -sinAngle;\n  result[3] = cosAngle;\n  return result;\n};\n\n/**\n * Creates an Array from the provided Matrix2 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix2} matrix The matrix to use..\n * @param {number[]} [result] The Array onto which to store the result.\n * @returns {number[]} The modified Array parameter or a new Array instance if one was not provided.\n */\nMatrix2.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [matrix[0], matrix[1], matrix[2], matrix[3]];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {number} row The zero-based index of the row.\n * @param {number} column The zero-based index of the column.\n * @returns {number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0 or 1.\n * @exception {DeveloperError} column must be 0 or 1.\n *\n * @example\n * const myMatrix = new Cesium.Matrix2();\n * const column1Row0Index = Cesium.Matrix2.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix2.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 1);\n\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 1);\n  //>>includeEnd('debug');\n\n  return column * 2 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {number} index The zero-based index of the column to retrieve.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const startIndex = index * 2;\n  const x = matrix[startIndex];\n  const y = matrix[startIndex + 1];\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {number} index The zero-based index of the column to set.\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix2.clone(matrix, result);\n  const startIndex = index * 2;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  return result;\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {number} index The zero-based index of the row to retrieve.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = matrix[index];\n  const y = matrix[index + 2];\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {number} index The zero-based index of the row to set.\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix2.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 2] = cartesian.y;\n  return result;\n};\n\nconst scaleScratch1 = new Cartesian2();\n\n/**\n * Computes a new matrix that replaces the scale with the provided scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Cartesian2} scale The scale that replaces the scale of the provided matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @see Matrix2.setUniformScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.multiplyByScale\n * @see Matrix2.multiplyByUniformScale\n * @see Matrix2.getScale\n */\nMatrix2.setScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix2.getScale(matrix, scaleScratch1);\n  const scaleRatioX = scale.x / existingScale.x;\n  const scaleRatioY = scale.y / existingScale.y;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioY;\n  result[3] = matrix[3] * scaleRatioY;\n\n  return result;\n};\n\nconst scaleScratch2 = new Cartesian2();\n\n/**\n * Computes a new matrix that replaces the scale with the provided uniform scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {number} scale The uniform scale that replaces the scale of the provided matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @see Matrix2.setScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.multiplyByScale\n * @see Matrix2.multiplyByUniformScale\n * @see Matrix2.getScale\n */\nMatrix2.setUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix2.getScale(matrix, scaleScratch2);\n  const scaleRatioX = scale / existingScale.x;\n  const scaleRatioY = scale / existingScale.y;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioY;\n  result[3] = matrix[3] * scaleRatioY;\n\n  return result;\n};\n\nconst scratchColumn = new Cartesian2();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @see Matrix2.multiplyByScale\n * @see Matrix2.multiplyByUniformScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.setScale\n * @see Matrix2.setUniformScale\n */\nMatrix2.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Cartesian2.magnitude(\n    Cartesian2.fromElements(matrix[0], matrix[1], scratchColumn),\n  );\n  result.y = Cartesian2.magnitude(\n    Cartesian2.fromElements(matrix[2], matrix[3], scratchColumn),\n  );\n  return result;\n};\n\nconst scaleScratch3 = new Cartesian2();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors.\n *\n * @param {Matrix2} matrix The matrix.\n * @returns {number} The maximum scale.\n */\nMatrix2.getMaximumScale = function (matrix) {\n  Matrix2.getScale(matrix, scaleScratch3);\n  return Cartesian2.maximumComponent(scaleScratch3);\n};\n\nconst scaleScratch4 = new Cartesian2();\n\n/**\n * Sets the rotation assuming the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Matrix2} rotation The rotation matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @see Matrix2.fromRotation\n * @see Matrix2.getRotation\n */\nMatrix2.setRotation = function (matrix, rotation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix2.getScale(matrix, scaleScratch4);\n\n  result[0] = rotation[0] * scale.x;\n  result[1] = rotation[1] * scale.x;\n  result[2] = rotation[2] * scale.y;\n  result[3] = rotation[3] * scale.y;\n\n  return result;\n};\n\nconst scaleScratch5 = new Cartesian2();\n\n/**\n * Extracts the rotation matrix assuming the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @see Matrix2.setRotation\n * @see Matrix2.fromRotation\n */\nMatrix2.getRotation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix2.getScale(matrix, scaleScratch5);\n\n  result[0] = matrix[0] / scale.x;\n  result[1] = matrix[1] / scale.x;\n  result[2] = matrix[2] / scale.y;\n  result[3] = matrix[3] / scale.y;\n\n  return result;\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = left[0] * right[0] + left[2] * right[1];\n  const column1Row0 = left[0] * right[2] + left[2] * right[3];\n  const column0Row1 = left[1] * right[0] + left[3] * right[1];\n  const column1Row1 = left[1] * right[2] + left[3] * right[3];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column1Row0;\n  result[3] = column1Row1;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Cartesian2} cartesian The column.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nMatrix2.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = matrix[0] * cartesian.x + matrix[2] * cartesian.y;\n  const y = matrix[1] * cartesian.x + matrix[3] * cartesian.y;\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {number} scalar The number to multiply by.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n *\n * @param {Matrix2} matrix The matrix on the left-hand side.\n * @param {Cartesian2} scale The non-uniform scale on the right-hand side.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromScale(scale), m);\n * Cesium.Matrix2.multiplyByScale(m, scale, m);\n *\n * @see Matrix2.multiplyByUniformScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.setScale\n * @see Matrix2.setUniformScale\n * @see Matrix2.getScale\n */\nMatrix2.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale.x;\n  result[1] = matrix[1] * scale.x;\n  result[2] = matrix[2] * scale.y;\n  result[3] = matrix[3] * scale.y;\n\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.\n *\n * @param {Matrix2} matrix The matrix on the left-hand side.\n * @param {number} scale The uniform scale on the right-hand side.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromUniformScale(scale), m);\n * Cesium.Matrix2.multiplyByUniformScale(m, scale, m);\n *\n * @see Matrix2.multiplyByScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.setScale\n * @see Matrix2.setUniformScale\n * @see Matrix2.getScale\n */\nMatrix2.multiplyByUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale;\n  result[1] = matrix[1] * scale;\n  result[2] = matrix[2] * scale;\n  result[3] = matrix[3] * scale;\n\n  return result;\n};\n\n/**\n * Creates a negated copy of the provided matrix.\n *\n * @param {Matrix2} matrix The matrix to negate.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix2} matrix The matrix to transpose.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = matrix[0];\n  const column0Row1 = matrix[2];\n  const column1Row0 = matrix[1];\n  const column1Row1 = matrix[3];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column1Row0;\n  result[3] = column1Row1;\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix2} matrix The matrix with signed elements.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n\n  return result;\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix2} [left] The first matrix.\n * @param {Matrix2} [right] The second matrix.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nMatrix2.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left[0] === right[0] &&\n      left[1] === right[1] &&\n      left[2] === right[2] &&\n      left[3] === right[3])\n  );\n};\n\n/**\n * @private\n */\nMatrix2.equalsArray = function (matrix, array, offset) {\n  return (\n    matrix[0] === array[offset] &&\n    matrix[1] === array[offset + 1] &&\n    matrix[2] === array[offset + 2] &&\n    matrix[3] === array[offset + 3]\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix2} [left] The first matrix.\n * @param {Matrix2} [right] The second matrix.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix2.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = epsilon ?? 0;\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left[0] - right[0]) <= epsilon &&\n      Math.abs(left[1] - right[1]) <= epsilon &&\n      Math.abs(left[2] - right[2]) <= epsilon &&\n      Math.abs(left[3] - right[3]) <= epsilon)\n  );\n};\n\n/**\n * An immutable Matrix2 instance initialized to the identity matrix.\n *\n * @type {Matrix2}\n * @constant\n */\nMatrix2.IDENTITY = Object.freeze(new Matrix2(1.0, 0.0, 0.0, 1.0));\n\n/**\n * An immutable Matrix2 instance initialized to the zero matrix.\n *\n * @type {Matrix2}\n * @constant\n */\nMatrix2.ZERO = Object.freeze(new Matrix2(0.0, 0.0, 0.0, 0.0));\n\n/**\n * The index into Matrix2 for column 0, row 0.\n *\n * @type {number}\n * @constant\n *\n * @example\n * const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0\n */\nMatrix2.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix2 for column 0, row 1.\n *\n * @type {number}\n * @constant\n *\n * @example\n * const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0\n */\nMatrix2.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix2 for column 1, row 0.\n *\n * @type {number}\n * @constant\n *\n * @example\n * const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0\n */\nMatrix2.COLUMN1ROW0 = 2;\n\n/**\n * The index into Matrix2 for column 1, row 1.\n *\n * @type {number}\n * @constant\n *\n * @example\n * const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0\n */\nMatrix2.COLUMN1ROW1 = 3;\n\nObject.defineProperties(Matrix2.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix2.prototype\n   *\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      return Matrix2.packedLength;\n    },\n  },\n});\n\n/**\n * Duplicates the provided Matrix2 instance.\n *\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n */\nMatrix2.prototype.clone = function (result) {\n  return Matrix2.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix2} [right] The right hand side matrix.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix2.prototype.equals = function (right) {\n  return Matrix2.equals(this, right);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix2} [right] The right hand side matrix.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix2.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix2.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1)'.\n *\n * @returns {string} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.\n */\nMatrix2.prototype.toString = function () {\n  return `(${this[0]}, ${this[2]})\\n` + `(${this[1]}, ${this[3]})`;\n};\nexport default Matrix2;\n"],"names":["Matrix2","column0Row0","column1Row0","column0Row1","column1Row1","packedLength","pack","value","array","startingIndex","typeOf","object","defined","unpack","result","packArray","length","resultLength","Array","isArray","i","unpackArray","number","greaterThanOrEquals","index","clone","matrix","undefined","fromArray","fromColumnMajorArray","values","fromRowMajorArray","fromScale","scale","x","y","fromUniformScale","fromRotation","angle","cosAngle","Math","cos","sinAngle","sin","toArray","getElementIndex","column","row","lessThanOrEquals","getColumn","startIndex","setColumn","cartesian","getRow","setRow","scaleScratch1","setScale","existingScale","getScale","scaleRatioX","scaleRatioY","scaleScratch2","setUniformScale","scratchColumn","magnitude","fromElements","scaleScratch3","getMaximumScale","maximumComponent","scaleScratch4","setRotation","rotation","scaleScratch5","getRotation","multiply","left","right","add","subtract","multiplyByVector","multiplyByScalar","scalar","multiplyByScale","multiplyByUniformScale","negate","transpose","abs","equals","equalsArray","offset","equalsEpsilon","epsilon","IDENTITY","Object","freeze","ZERO","COLUMN0ROW0","COLUMN0ROW1","COLUMN1ROW0","COLUMN1ROW1","defineProperties","prototype","get","toString"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 21043, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PrimitiveType.js"],"sourcesContent":["import WebGLConstants from \"./WebGLConstants.js\";\n\n/**\n * The type of a geometric primitive, i.e., points, lines, and triangles.\n *\n * @enum {number}\n */\nconst PrimitiveType = {\n  /**\n   * Points primitive where each vertex (or index) is a separate point.\n   *\n   * @type {number}\n   * @constant\n   */\n  POINTS: WebGLConstants.POINTS,\n\n  /**\n   * Lines primitive where each two vertices (or indices) is a line segment.  Line segments are not necessarily connected.\n   *\n   * @type {number}\n   * @constant\n   */\n  LINES: WebGLConstants.LINES,\n\n  /**\n   * Line loop primitive where each vertex (or index) after the first connects a line to\n   * the previous vertex, and the last vertex implicitly connects to the first.\n   *\n   * @type {number}\n   * @constant\n   */\n  LINE_LOOP: WebGLConstants.LINE_LOOP,\n\n  /**\n   * Line strip primitive where each vertex (or index) after the first connects a line to the previous vertex.\n   *\n   * @type {number}\n   * @constant\n   */\n  LINE_STRIP: WebGLConstants.LINE_STRIP,\n\n  /**\n   * Triangles primitive where each three vertices (or indices) is a triangle.  Triangles do not necessarily share edges.\n   *\n   * @type {number}\n   * @constant\n   */\n  TRIANGLES: WebGLConstants.TRIANGLES,\n\n  /**\n   * Triangle strip primitive where each vertex (or index) after the first two connect to\n   * the previous two vertices forming a triangle.  For example, this can be used to model a wall.\n   *\n   * @type {number}\n   * @constant\n   */\n  TRIANGLE_STRIP: WebGLConstants.TRIANGLE_STRIP,\n\n  /**\n   * Triangle fan primitive where each vertex (or index) after the first two connect to\n   * the previous vertex and the first vertex forming a triangle.  For example, this can be used\n   * to model a cone or circle.\n   *\n   * @type {number}\n   * @constant\n   */\n  TRIANGLE_FAN: WebGLConstants.TRIANGLE_FAN,\n};\n\n/**\n * @private\n */\nPrimitiveType.isLines = function (primitiveType) {\n  return (\n    primitiveType === PrimitiveType.LINES ||\n    primitiveType === PrimitiveType.LINE_LOOP ||\n    primitiveType === PrimitiveType.LINE_STRIP\n  );\n};\n\n/**\n * @private\n */\nPrimitiveType.isTriangles = function (primitiveType) {\n  return (\n    primitiveType === PrimitiveType.TRIANGLES ||\n    primitiveType === PrimitiveType.TRIANGLE_STRIP ||\n    primitiveType === PrimitiveType.TRIANGLE_FAN\n  );\n};\n\n/**\n * @private\n */\nPrimitiveType.validate = function (primitiveType) {\n  return (\n    primitiveType === PrimitiveType.POINTS ||\n    primitiveType === PrimitiveType.LINES ||\n    primitiveType === PrimitiveType.LINE_LOOP ||\n    primitiveType === PrimitiveType.LINE_STRIP ||\n    primitiveType === PrimitiveType.TRIANGLES ||\n    primitiveType === PrimitiveType.TRIANGLE_STRIP ||\n    primitiveType === PrimitiveType.TRIANGLE_FAN\n  );\n};\n\nexport default Object.freeze(PrimitiveType);\n"],"names":["PrimitiveType","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","isLines","primitiveType","isTriangles","validate","Object","freeze"],"mappings":";;;;AAAA;;AAEA;;;;CAIC,GACD,MAAMA,gBAAgB;IACpB;;;;;GAKC,GACDC,QAAQ,oLAAc,CAACA,MAAM;IAE7B;;;;;GAKC,GACDC,OAAO,oLAAc,CAACA,KAAK;IAE3B;;;;;;GAMC,GACDC,WAAW,oLAAc,CAACA,SAAS;IAEnC;;;;;GAKC,GACDC,YAAY,oLAAc,CAACA,UAAU;IAErC;;;;;GAKC,GACDC,WAAW,oLAAc,CAACA,SAAS;IAEnC;;;;;;GAMC,GACDC,gBAAgB,oLAAc,CAACA,cAAc;IAE7C;;;;;;;GAOC,GACDC,cAAc,oLAAc,CAACA,YAAY;AAC3C;AAEA;;CAEC,GACDP,cAAcQ,OAAO,GAAG,SAAUC,aAAa;IAC7C,OACEA,kBAAkBT,cAAcE,KAAK,IACrCO,kBAAkBT,cAAcG,SAAS,IACzCM,kBAAkBT,cAAcI,UAAU;AAE9C;AAEA;;CAEC,GACDJ,cAAcU,WAAW,GAAG,SAAUD,aAAa;IACjD,OACEA,kBAAkBT,cAAcK,SAAS,IACzCI,kBAAkBT,cAAcM,cAAc,IAC9CG,kBAAkBT,cAAcO,YAAY;AAEhD;AAEA;;CAEC,GACDP,cAAcW,QAAQ,GAAG,SAAUF,aAAa;IAC9C,OACEA,kBAAkBT,cAAcC,MAAM,IACtCQ,kBAAkBT,cAAcE,KAAK,IACrCO,kBAAkBT,cAAcG,SAAS,IACzCM,kBAAkBT,cAAcI,UAAU,IAC1CK,kBAAkBT,cAAcK,SAAS,IACzCI,kBAAkBT,cAAcM,cAAc,IAC9CG,kBAAkBT,cAAcO,YAAY;AAEhD;uCAEeK,OAAOC,MAAM,CAACb","ignoreList":[0]}},
    {"offset": {"line": 21121, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Geometry.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport Matrix2 from \"./Matrix2.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Transforms from \"./Transforms.js\";\n\n/**\n * A geometry representation with attributes forming vertices and optional index data\n * defining primitives.  Geometries and an {@link Appearance}, which describes the shading,\n * can be assigned to a {@link Primitive} for visualization.  A <code>Primitive</code> can\n * be created from many heterogeneous - in many cases - geometries for performance.\n * <p>\n * Geometries can be transformed and optimized using functions in {@link GeometryPipeline}.\n * </p>\n *\n * @alias Geometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {GeometryAttributes} options.attributes Attributes, which make up the geometry's vertices.\n * @param {PrimitiveType} [options.primitiveType=PrimitiveType.TRIANGLES] The type of primitives in the geometry.\n * @param {Uint16Array|Uint32Array} [options.indices] Optional index data that determines the primitives in the geometry.\n * @param {BoundingSphere} [options.boundingSphere] An optional bounding sphere that fully enclosed the geometry.\n *\n * @see PolygonGeometry\n * @see RectangleGeometry\n * @see EllipseGeometry\n * @see CircleGeometry\n * @see WallGeometry\n * @see SimplePolylineGeometry\n * @see BoxGeometry\n * @see EllipsoidGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Geometry%20and%20Appearances.html|Geometry and Appearances Demo}\n *\n * @example\n * // Create geometry with a position attribute and indexed lines.\n * const positions = new Float64Array([\n *   0.0, 0.0, 0.0,\n *   7500000.0, 0.0, 0.0,\n *   0.0, 7500000.0, 0.0\n * ]);\n *\n * const geometry = new Cesium.Geometry({\n *   attributes : {\n *     position : new Cesium.GeometryAttribute({\n *       componentDatatype : Cesium.ComponentDatatype.DOUBLE,\n *       componentsPerAttribute : 3,\n *       values : positions\n *     })\n *   },\n *   indices : new Uint16Array([0, 1, 1, 2, 2, 0]),\n *   primitiveType : Cesium.PrimitiveType.LINES,\n *   boundingSphere : Cesium.BoundingSphere.fromVertices(positions)\n * });\n */\nfunction Geometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.attributes\", options.attributes);\n  //>>includeEnd('debug');\n\n  /**\n   * Attributes, which make up the geometry's vertices.  Each property in this object corresponds to a\n   * {@link GeometryAttribute} containing the attribute's data.\n   * <p>\n   * Attributes are always stored non-interleaved in a Geometry.\n   * </p>\n   * <p>\n   * There are reserved attribute names with well-known semantics.  The following attributes\n   * are created by a Geometry (depending on the provided {@link VertexFormat}.\n   * <ul>\n   *    <li><code>position</code> - 3D vertex position.  64-bit floating-point (for precision).  3 components per attribute.  See {@link VertexFormat#position}.</li>\n   *    <li><code>normal</code> - Normal (normalized), commonly used for lighting.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#normal}.</li>\n   *    <li><code>st</code> - 2D texture coordinate.  32-bit floating-point.  2 components per attribute.  See {@link VertexFormat#st}.</li>\n   *    <li><code>bitangent</code> - Bitangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#bitangent}.</li>\n   *    <li><code>tangent</code> - Tangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#tangent}.</li>\n   * </ul>\n   * </p>\n   * <p>\n   * The following attribute names are generally not created by a Geometry, but are added\n   * to a Geometry by a {@link Primitive} or {@link GeometryPipeline} functions to prepare\n   * the geometry for rendering.\n   * <ul>\n   *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>position3DLow</code> - Low 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>position2DHigh</code> - High 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>position2DLow</code> - Low 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>color</code> - RGBA color (normalized) usually from {@link GeometryInstance#color}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>pickColor</code> - RGBA color used for picking.  32-bit floating-point.  4 components per attribute.</li>\n   * </ul>\n   * </p>\n   *\n   * @type GeometryAttributes\n   *\n   *\n   * @example\n   * geometry.attributes.position = new Cesium.GeometryAttribute({\n   *   componentDatatype : Cesium.ComponentDatatype.FLOAT,\n   *   componentsPerAttribute : 3,\n   *   values : new Float32Array(0)\n   * });\n   *\n   * @see GeometryAttribute\n   * @see VertexFormat\n   */\n  this.attributes = options.attributes;\n\n  /**\n   * Optional index data that - along with {@link Geometry#primitiveType} -\n   * determines the primitives in the geometry.\n   *\n   * @type {Array|undefined}\n   *\n   * @default undefined\n   */\n  this.indices = options.indices;\n\n  /**\n   * The type of primitives in the geometry.  This is most often {@link PrimitiveType.TRIANGLES},\n   * but can varying based on the specific geometry.\n   *\n   * @type {PrimitiveType|undefined}\n   *\n   * @default PrimitiveType.TRIANGLES\n   */\n  this.primitiveType = options.primitiveType ?? PrimitiveType.TRIANGLES;\n\n  /**\n   * An optional bounding sphere that fully encloses the geometry.  This is\n   * commonly used for culling.\n   *\n   * @type {BoundingSphere|undefined}\n   *\n   * @default undefined\n   */\n  this.boundingSphere = options.boundingSphere;\n\n  /**\n   * @private\n   */\n  this.geometryType = options.geometryType ?? GeometryType.NONE;\n\n  /**\n   * @private\n   */\n  this.boundingSphereCV = options.boundingSphereCV;\n\n  /**\n   * Used for computing the bounding sphere for geometry using the applyOffset vertex attribute\n   * @private\n   */\n  this.offsetAttribute = options.offsetAttribute;\n}\n\n/**\n * Computes the number of vertices in a geometry.  The runtime is linear with\n * respect to the number of attributes in a vertex, not the number of vertices.\n *\n * @param {Geometry} geometry The geometry.\n * @returns {number} The number of vertices in the geometry.\n *\n * @example\n * const numVertices = Cesium.Geometry.computeNumberOfVertices(geometry);\n */\nGeometry.computeNumberOfVertices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"geometry\", geometry);\n  //>>includeEnd('debug');\n\n  let numberOfVertices = -1;\n  for (const property in geometry.attributes) {\n    if (\n      geometry.attributes.hasOwnProperty(property) &&\n      defined(geometry.attributes[property]) &&\n      defined(geometry.attributes[property].values)\n    ) {\n      const attribute = geometry.attributes[property];\n      const num = attribute.values.length / attribute.componentsPerAttribute;\n      //>>includeStart('debug', pragmas.debug);\n      if (numberOfVertices !== num && numberOfVertices !== -1) {\n        throw new DeveloperError(\n          \"All attribute lists must have the same number of attributes.\",\n        );\n      }\n      //>>includeEnd('debug');\n      numberOfVertices = num;\n    }\n  }\n\n  return numberOfVertices;\n};\n\nconst rectangleCenterScratch = new Cartographic();\nconst enuCenterScratch = new Cartesian3();\nconst fixedFrameToEnuScratch = new Matrix4();\nconst boundingRectanglePointsCartographicScratch = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\nconst boundingRectanglePointsEnuScratch = [\n  new Cartesian2(),\n  new Cartesian2(),\n  new Cartesian2(),\n];\nconst points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\nconst pointEnuScratch = new Cartesian3();\nconst enuRotationScratch = new Quaternion();\nconst enuRotationMatrixScratch = new Matrix4();\nconst rotation2DScratch = new Matrix2();\n\n/**\n * For remapping texture coordinates when rendering GroundPrimitives with materials.\n * GroundPrimitive texture coordinates are computed to align with the cartographic coordinate system on the globe.\n * However, EllipseGeometry, RectangleGeometry, and PolygonGeometry all bake rotations to per-vertex texture coordinates\n * using different strategies.\n *\n * This method is used by EllipseGeometry and PolygonGeometry to approximate the same visual effect.\n * We encapsulate rotation and scale by computing a \"transformed\" texture coordinate system and computing\n * a set of reference points from which \"cartographic\" texture coordinates can be remapped to the \"transformed\"\n * system using distances to lines in 2D.\n *\n * This approximation becomes less accurate as the covered area increases, especially for GroundPrimitives near the poles,\n * but is generally reasonable for polygons and ellipses around the size of USA states.\n *\n * RectangleGeometry has its own version of this method that computes remapping coordinates using cartographic space\n * as an intermediary instead of local ENU, which is more accurate for large-area rectangles.\n *\n * @param {Cartesian3[]} positions Array of positions outlining the geometry\n * @param {number} stRotation Texture coordinate rotation.\n * @param {Ellipsoid} ellipsoid Ellipsoid for projecting and generating local vectors.\n * @param {Rectangle} boundingRectangle Bounding rectangle around the positions.\n * @returns {number[]} An array of 6 numbers specifying [minimum point, u extent, v extent] as points in the \"cartographic\" system.\n * @private\n */\nGeometry._textureCoordinateRotationPoints = function (\n  positions,\n  stRotation,\n  ellipsoid,\n  boundingRectangle,\n) {\n  let i;\n\n  // Create a local east-north-up coordinate system centered on the polygon's bounding rectangle.\n  // Project the southwest, northwest, and southeast corners of the bounding rectangle into the plane of ENU as 2D points.\n  // These are the equivalents of (0,0), (0,1), and (1,0) in the texture coordinate system computed in ShadowVolumeAppearanceFS,\n  // aka \"ENU texture space.\"\n  const rectangleCenter = Rectangle.center(\n    boundingRectangle,\n    rectangleCenterScratch,\n  );\n  const enuCenter = Cartographic.toCartesian(\n    rectangleCenter,\n    ellipsoid,\n    enuCenterScratch,\n  );\n  const enuToFixedFrame = Transforms.eastNorthUpToFixedFrame(\n    enuCenter,\n    ellipsoid,\n    fixedFrameToEnuScratch,\n  );\n  const fixedFrameToEnu = Matrix4.inverse(\n    enuToFixedFrame,\n    fixedFrameToEnuScratch,\n  );\n\n  const boundingPointsEnu = boundingRectanglePointsEnuScratch;\n  const boundingPointsCarto = boundingRectanglePointsCartographicScratch;\n\n  boundingPointsCarto[0].longitude = boundingRectangle.west;\n  boundingPointsCarto[0].latitude = boundingRectangle.south;\n\n  boundingPointsCarto[1].longitude = boundingRectangle.west;\n  boundingPointsCarto[1].latitude = boundingRectangle.north;\n\n  boundingPointsCarto[2].longitude = boundingRectangle.east;\n  boundingPointsCarto[2].latitude = boundingRectangle.south;\n\n  let posEnu = pointEnuScratch;\n\n  for (i = 0; i < 3; i++) {\n    Cartographic.toCartesian(boundingPointsCarto[i], ellipsoid, posEnu);\n    posEnu = Matrix4.multiplyByPointAsVector(fixedFrameToEnu, posEnu, posEnu);\n    boundingPointsEnu[i].x = posEnu.x;\n    boundingPointsEnu[i].y = posEnu.y;\n  }\n\n  // Rotate each point in the polygon around the up vector in the ENU by -stRotation and project into ENU as 2D.\n  // Compute the bounding box of these rotated points in the 2D ENU plane.\n  // Rotate the corners back by stRotation, then compute their equivalents in the ENU texture space using the corners computed earlier.\n  const rotation = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Z,\n    -stRotation,\n    enuRotationScratch,\n  );\n  const textureMatrix = Matrix3.fromQuaternion(\n    rotation,\n    enuRotationMatrixScratch,\n  );\n\n  const positionsLength = positions.length;\n  let enuMinX = Number.POSITIVE_INFINITY;\n  let enuMinY = Number.POSITIVE_INFINITY;\n  let enuMaxX = Number.NEGATIVE_INFINITY;\n  let enuMaxY = Number.NEGATIVE_INFINITY;\n  for (i = 0; i < positionsLength; i++) {\n    posEnu = Matrix4.multiplyByPointAsVector(\n      fixedFrameToEnu,\n      positions[i],\n      posEnu,\n    );\n    posEnu = Matrix3.multiplyByVector(textureMatrix, posEnu, posEnu);\n\n    enuMinX = Math.min(enuMinX, posEnu.x);\n    enuMinY = Math.min(enuMinY, posEnu.y);\n    enuMaxX = Math.max(enuMaxX, posEnu.x);\n    enuMaxY = Math.max(enuMaxY, posEnu.y);\n  }\n\n  const toDesiredInComputed = Matrix2.fromRotation(\n    stRotation,\n    rotation2DScratch,\n  );\n\n  const points2D = points2DScratch;\n  points2D[0].x = enuMinX;\n  points2D[0].y = enuMinY;\n\n  points2D[1].x = enuMinX;\n  points2D[1].y = enuMaxY;\n\n  points2D[2].x = enuMaxX;\n  points2D[2].y = enuMinY;\n\n  const boundingEnuMin = boundingPointsEnu[0];\n  const boundingPointsWidth = boundingPointsEnu[2].x - boundingEnuMin.x;\n  const boundingPointsHeight = boundingPointsEnu[1].y - boundingEnuMin.y;\n\n  for (i = 0; i < 3; i++) {\n    const point2D = points2D[i];\n    // rotate back\n    Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\n\n    // Convert point into east-north texture coordinate space\n    point2D.x = (point2D.x - boundingEnuMin.x) / boundingPointsWidth;\n    point2D.y = (point2D.y - boundingEnuMin.y) / boundingPointsHeight;\n  }\n\n  const minXYCorner = points2D[0];\n  const maxYCorner = points2D[1];\n  const maxXCorner = points2D[2];\n  const result = new Array(6);\n  Cartesian2.pack(minXYCorner, result);\n  Cartesian2.pack(maxYCorner, result, 2);\n  Cartesian2.pack(maxXCorner, result, 4);\n\n  return result;\n};\nexport default Geometry;\n"],"names":["Geometry","options","EMPTY_OBJECT","typeOf","object","attributes","indices","primitiveType","TRIANGLES","boundingSphere","geometryType","NONE","boundingSphereCV","offsetAttribute","computeNumberOfVertices","geometry","numberOfVertices","property","hasOwnProperty","values","attribute","num","length","componentsPerAttribute","rectangleCenterScratch","enuCenterScratch","fixedFrameToEnuScratch","boundingRectanglePointsCartographicScratch","boundingRectanglePointsEnuScratch","points2DScratch","pointEnuScratch","enuRotationScratch","enuRotationMatrixScratch","rotation2DScratch","_textureCoordinateRotationPoints","positions","stRotation","ellipsoid","boundingRectangle","i","rectangleCenter","center","enuCenter","toCartesian","enuToFixedFrame","eastNorthUpToFixedFrame","fixedFrameToEnu","inverse","boundingPointsEnu","boundingPointsCarto","longitude","west","latitude","south","north","east","posEnu","multiplyByPointAsVector","x","y","rotation","fromAxisAngle","UNIT_Z","textureMatrix","fromQuaternion","positionsLength","enuMinX","Number","POSITIVE_INFINITY","enuMinY","enuMaxX","NEGATIVE_INFINITY","enuMaxY","multiplyByVector","Math","min","max","toDesiredInComputed","fromRotation","points2D","boundingEnuMin","boundingPointsWidth","boundingPointsHeight","point2D","minXYCorner","maxYCorner","maxXCorner","result","Array","pack"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 21437, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/GeometryAttribute.js"],"sourcesContent":["import Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Values and type information for geometry attributes.  A {@link Geometry}\n * generally contains one or more attributes.  All attributes together form\n * the geometry's vertices.\n *\n * @alias GeometryAttribute\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {ComponentDatatype} options.componentDatatype The datatype of each component in the attribute, e.g., individual elements in values.\n * @param {number} options.componentsPerAttribute A number between 1 and 4 that defines the number of components in an attributes.\n * @param {boolean} [options.normalize=false] When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n * @param {number[]|Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} options.values The values for the attributes stored in a typed array.\n *\n * @exception {DeveloperError} options.componentsPerAttribute must be between 1 and 4.\n *\n *\n * @example\n * const geometry = new Cesium.Geometry({\n *   attributes : {\n *     position : new Cesium.GeometryAttribute({\n *       componentDatatype : Cesium.ComponentDatatype.FLOAT,\n *       componentsPerAttribute : 3,\n *       values : new Float32Array([\n *         0.0, 0.0, 0.0,\n *         7500000.0, 0.0, 0.0,\n *         0.0, 7500000.0, 0.0\n *       ])\n *     })\n *   },\n *   primitiveType : Cesium.PrimitiveType.LINE_LOOP\n * });\n *\n * @see Geometry\n */\nfunction GeometryAttribute(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.componentDatatype)) {\n    throw new DeveloperError(\"options.componentDatatype is required.\");\n  }\n  if (!defined(options.componentsPerAttribute)) {\n    throw new DeveloperError(\"options.componentsPerAttribute is required.\");\n  }\n  if (\n    options.componentsPerAttribute < 1 ||\n    options.componentsPerAttribute > 4\n  ) {\n    throw new DeveloperError(\n      \"options.componentsPerAttribute must be between 1 and 4.\",\n    );\n  }\n  if (!defined(options.values)) {\n    throw new DeveloperError(\"options.values is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The datatype of each component in the attribute, e.g., individual elements in\n   * {@link GeometryAttribute#values}.\n   *\n   * @type {ComponentDatatype}\n   *\n   */\n  this.componentDatatype = options.componentDatatype;\n\n  /**\n   * A number between 1 and 4 that defines the number of components in an attributes.\n   * For example, a position attribute with x, y, and z components would have 3 as\n   * shown in the code example.\n   *\n   * @type {number}\n   *\n   * @example\n   * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;\n   * attribute.componentsPerAttribute = 3;\n   * attribute.values = new Float32Array([\n   *   0.0, 0.0, 0.0,\n   *   7500000.0, 0.0, 0.0,\n   *   0.0, 7500000.0, 0.0\n   * ]);\n   */\n  this.componentsPerAttribute = options.componentsPerAttribute;\n\n  /**\n   * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n   * indicate that the components should be mapped to the range [0, 1] (unsigned)\n   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n   * <p>\n   * This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   *\n   * @example\n   * attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;\n   * attribute.componentsPerAttribute = 4;\n   * attribute.normalize = true;\n   * attribute.values = new Uint8Array([\n   *   Cesium.Color.floatToByte(color.red),\n   *   Cesium.Color.floatToByte(color.green),\n   *   Cesium.Color.floatToByte(color.blue),\n   *   Cesium.Color.floatToByte(color.alpha)\n   * ]);\n   */\n  this.normalize = options.normalize ?? false;\n\n  /**\n   * The values for the attributes stored in a typed array.  In the code example,\n   * every three elements in <code>values</code> defines one attributes since\n   * <code>componentsPerAttribute</code> is 3.\n   *\n   * @type {number[]|Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array}\n   *\n   * @example\n   * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;\n   * attribute.componentsPerAttribute = 3;\n   * attribute.values = new Float32Array([\n   *   0.0, 0.0, 0.0,\n   *   7500000.0, 0.0, 0.0,\n   *   0.0, 7500000.0, 0.0\n   * ]);\n   */\n  this.values = options.values;\n}\nexport default GeometryAttribute;\n"],"names":["GeometryAttribute","options","EMPTY_OBJECT","componentDatatype","componentsPerAttribute","values","normalize"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCC,GACD,SAASA,kBAAkBC,OAAO;IAChCA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACD,QAAQE,iBAAiB,GAAG;QACvC,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACF,QAAQG,sBAAsB,GAAG;QAC5C,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IACEH,QAAQG,sBAAsB,GAAG,KACjCH,QAAQG,sBAAsB,GAAG,GACjC;QACA,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,IAAI,CAAC,IAAA,6KAAO,EAACH,QAAQI,MAAM,GAAG;QAC5B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB;;;;;;GAMC,GACD,IAAI,CAACF,iBAAiB,GAAGF,QAAQE,iBAAiB;IAElD;;;;;;;;;;;;;;;GAeC,GACD,IAAI,CAACC,sBAAsB,GAAGH,QAAQG,sBAAsB;IAE5D;;;;;;;;;;;;;;;;;;;;;;GAsBC,GACD,IAAI,CAACE,SAAS,GAAGL,QAAQK,SAAS,IAAI;IAEtC;;;;;;;;;;;;;;;GAeC,GACD,IAAI,CAACD,MAAM,GAAGJ,QAAQI,MAAM;AAC9B;uCACeL","ignoreList":[0]}},
    {"offset": {"line": 21565, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/QuadraticRealPolynomial.js"],"sourcesContent":["import DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * Defines functions for 2nd order polynomial functions of one variable with only real coefficients.\n *\n * @namespace QuadraticRealPolynomial\n */\nconst QuadraticRealPolynomial = {};\n\n/**\n * Provides the discriminant of the quadratic equation from the supplied coefficients.\n *\n * @param {number} a The coefficient of the 2nd order monomial.\n * @param {number} b The coefficient of the 1st order monomial.\n * @param {number} c The coefficient of the 0th order monomial.\n * @returns {number} The value of the discriminant.\n */\nQuadraticRealPolynomial.computeDiscriminant = function (a, b, c) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  const discriminant = b * b - 4.0 * a * c;\n  return discriminant;\n};\n\nfunction addWithCancellationCheck(left, right, tolerance) {\n  const difference = left + right;\n  if (\n    CesiumMath.sign(left) !== CesiumMath.sign(right) &&\n    Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance\n  ) {\n    return 0.0;\n  }\n\n  return difference;\n}\n\n/**\n * Provides the real valued roots of the quadratic polynomial with the provided coefficients.\n *\n * @param {number} a The coefficient of the 2nd order monomial.\n * @param {number} b The coefficient of the 1st order monomial.\n * @param {number} c The coefficient of the 0th order monomial.\n * @returns {number[]} The real valued roots.\n */\nQuadraticRealPolynomial.computeRealRoots = function (a, b, c) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  let ratio;\n  if (a === 0.0) {\n    if (b === 0.0) {\n      // Constant function: c = 0.\n      return [];\n    }\n\n    // Linear function: b * x + c = 0.\n    return [-c / b];\n  } else if (b === 0.0) {\n    if (c === 0.0) {\n      // 2nd order monomial: a * x^2 = 0.\n      return [0.0, 0.0];\n    }\n\n    const cMagnitude = Math.abs(c);\n    const aMagnitude = Math.abs(a);\n\n    if (\n      cMagnitude < aMagnitude &&\n      cMagnitude / aMagnitude < CesiumMath.EPSILON14\n    ) {\n      // c ~= 0.0.\n      // 2nd order monomial: a * x^2 = 0.\n      return [0.0, 0.0];\n    } else if (\n      cMagnitude > aMagnitude &&\n      aMagnitude / cMagnitude < CesiumMath.EPSILON14\n    ) {\n      // a ~= 0.0.\n      // Constant function: c = 0.\n      return [];\n    }\n\n    // a * x^2 + c = 0\n    ratio = -c / a;\n\n    if (ratio < 0.0) {\n      // Both roots are complex.\n      return [];\n    }\n\n    // Both roots are real.\n    const root = Math.sqrt(ratio);\n    return [-root, root];\n  } else if (c === 0.0) {\n    // a * x^2 + b * x = 0\n    ratio = -b / a;\n    if (ratio < 0.0) {\n      return [ratio, 0.0];\n    }\n\n    return [0.0, ratio];\n  }\n\n  // a * x^2 + b * x + c = 0\n  const b2 = b * b;\n  const four_ac = 4.0 * a * c;\n  const radicand = addWithCancellationCheck(b2, -four_ac, CesiumMath.EPSILON14);\n\n  if (radicand < 0.0) {\n    // Both roots are complex.\n    return [];\n  }\n\n  const q =\n    -0.5 *\n    addWithCancellationCheck(\n      b,\n      CesiumMath.sign(b) * Math.sqrt(radicand),\n      CesiumMath.EPSILON14,\n    );\n  if (b > 0.0) {\n    return [q / a, c / q];\n  }\n\n  return [c / q, q / a];\n};\nexport default QuadraticRealPolynomial;\n"],"names":["QuadraticRealPolynomial","computeDiscriminant","a","b","c","discriminant","addWithCancellationCheck","left","right","tolerance","difference","sign","Math","abs","max","computeRealRoots","ratio","cMagnitude","aMagnitude","EPSILON14","root","sqrt","b2","four_ac","radicand","q"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 21709, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/CubicRealPolynomial.js"],"sourcesContent":["import DeveloperError from \"./DeveloperError.js\";\nimport QuadraticRealPolynomial from \"./QuadraticRealPolynomial.js\";\n\n/**\n * Defines functions for 3rd order polynomial functions of one variable with only real coefficients.\n *\n * @namespace CubicRealPolynomial\n */\nconst CubicRealPolynomial = {};\n\n/**\n * Provides the discriminant of the cubic equation from the supplied coefficients.\n *\n * @param {number} a The coefficient of the 3rd order monomial.\n * @param {number} b The coefficient of the 2nd order monomial.\n * @param {number} c The coefficient of the 1st order monomial.\n * @param {number} d The coefficient of the 0th order monomial.\n * @returns {number} The value of the discriminant.\n */\nCubicRealPolynomial.computeDiscriminant = function (a, b, c, d) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  if (typeof d !== \"number\") {\n    throw new DeveloperError(\"d is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  const a2 = a * a;\n  const b2 = b * b;\n  const c2 = c * c;\n  const d2 = d * d;\n\n  const discriminant =\n    18.0 * a * b * c * d +\n    b2 * c2 -\n    27.0 * a2 * d2 -\n    4.0 * (a * c2 * c + b2 * b * d);\n  return discriminant;\n};\n\nfunction computeRealRoots(a, b, c, d) {\n  const A = a;\n  const B = b / 3.0;\n  const C = c / 3.0;\n  const D = d;\n\n  const AC = A * C;\n  const BD = B * D;\n  const B2 = B * B;\n  const C2 = C * C;\n  const delta1 = A * C - B2;\n  const delta2 = A * D - B * C;\n  const delta3 = B * D - C2;\n\n  const discriminant = 4.0 * delta1 * delta3 - delta2 * delta2;\n  let temp;\n  let temp1;\n\n  if (discriminant < 0.0) {\n    let ABar;\n    let CBar;\n    let DBar;\n\n    if (B2 * BD >= AC * C2) {\n      ABar = A;\n      CBar = delta1;\n      DBar = -2.0 * B * delta1 + A * delta2;\n    } else {\n      ABar = D;\n      CBar = delta3;\n      DBar = -D * delta2 + 2.0 * C * delta3;\n    }\n\n    const s = DBar < 0.0 ? -1.0 : 1.0; // This is not Math.Sign()!\n    const temp0 = -s * Math.abs(ABar) * Math.sqrt(-discriminant);\n    temp1 = -DBar + temp0;\n\n    const x = temp1 / 2.0;\n    const p = x < 0.0 ? -Math.pow(-x, 1.0 / 3.0) : Math.pow(x, 1.0 / 3.0);\n    const q = temp1 === temp0 ? -p : -CBar / p;\n\n    temp = CBar <= 0.0 ? p + q : -DBar / (p * p + q * q + CBar);\n\n    if (B2 * BD >= AC * C2) {\n      return [(temp - B) / A];\n    }\n\n    return [-D / (temp + C)];\n  }\n\n  const CBarA = delta1;\n  const DBarA = -2.0 * B * delta1 + A * delta2;\n\n  const CBarD = delta3;\n  const DBarD = -D * delta2 + 2.0 * C * delta3;\n\n  const squareRootOfDiscriminant = Math.sqrt(discriminant);\n  const halfSquareRootOf3 = Math.sqrt(3.0) / 2.0;\n\n  let theta = Math.abs(Math.atan2(A * squareRootOfDiscriminant, -DBarA) / 3.0);\n  temp = 2.0 * Math.sqrt(-CBarA);\n  let cosine = Math.cos(theta);\n  temp1 = temp * cosine;\n  let temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));\n\n  const numeratorLarge = temp1 + temp3 > 2.0 * B ? temp1 - B : temp3 - B;\n  const denominatorLarge = A;\n\n  const root1 = numeratorLarge / denominatorLarge;\n\n  theta = Math.abs(Math.atan2(D * squareRootOfDiscriminant, -DBarD) / 3.0);\n  temp = 2.0 * Math.sqrt(-CBarD);\n  cosine = Math.cos(theta);\n  temp1 = temp * cosine;\n  temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));\n\n  const numeratorSmall = -D;\n  const denominatorSmall = temp1 + temp3 < 2.0 * C ? temp1 + C : temp3 + C;\n\n  const root3 = numeratorSmall / denominatorSmall;\n\n  const E = denominatorLarge * denominatorSmall;\n  const F =\n    -numeratorLarge * denominatorSmall - denominatorLarge * numeratorSmall;\n  const G = numeratorLarge * numeratorSmall;\n\n  const root2 = (C * F - B * G) / (-B * F + C * E);\n\n  if (root1 <= root2) {\n    if (root1 <= root3) {\n      if (root2 <= root3) {\n        return [root1, root2, root3];\n      }\n      return [root1, root3, root2];\n    }\n    return [root3, root1, root2];\n  }\n  if (root1 <= root3) {\n    return [root2, root1, root3];\n  }\n  if (root2 <= root3) {\n    return [root2, root3, root1];\n  }\n  return [root3, root2, root1];\n}\n\n/**\n * Provides the real valued roots of the cubic polynomial with the provided coefficients.\n *\n * @param {number} a The coefficient of the 3rd order monomial.\n * @param {number} b The coefficient of the 2nd order monomial.\n * @param {number} c The coefficient of the 1st order monomial.\n * @param {number} d The coefficient of the 0th order monomial.\n * @returns {number[]} The real valued roots.\n */\nCubicRealPolynomial.computeRealRoots = function (a, b, c, d) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  if (typeof d !== \"number\") {\n    throw new DeveloperError(\"d is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  let roots;\n  let ratio;\n  if (a === 0.0) {\n    // Quadratic function: b * x^2 + c * x + d = 0.\n    return QuadraticRealPolynomial.computeRealRoots(b, c, d);\n  } else if (b === 0.0) {\n    if (c === 0.0) {\n      if (d === 0.0) {\n        // 3rd order monomial: a * x^3 = 0.\n        return [0.0, 0.0, 0.0];\n      }\n\n      // a * x^3 + d = 0\n      ratio = -d / a;\n      const root =\n        ratio < 0.0 ? -Math.pow(-ratio, 1.0 / 3.0) : Math.pow(ratio, 1.0 / 3.0);\n      return [root, root, root];\n    } else if (d === 0.0) {\n      // x * (a * x^2 + c) = 0.\n      roots = QuadraticRealPolynomial.computeRealRoots(a, 0, c);\n\n      // Return the roots in ascending order.\n      if (roots.Length === 0) {\n        return [0.0];\n      }\n      return [roots[0], 0.0, roots[1]];\n    }\n\n    // Deflated cubic polynomial: a * x^3 + c * x + d= 0.\n    return computeRealRoots(a, 0, c, d);\n  } else if (c === 0.0) {\n    if (d === 0.0) {\n      // x^2 * (a * x + b) = 0.\n      ratio = -b / a;\n      if (ratio < 0.0) {\n        return [ratio, 0.0, 0.0];\n      }\n      return [0.0, 0.0, ratio];\n    }\n    // a * x^3 + b * x^2 + d = 0.\n    return computeRealRoots(a, b, 0, d);\n  } else if (d === 0.0) {\n    // x * (a * x^2 + b * x + c) = 0\n    roots = QuadraticRealPolynomial.computeRealRoots(a, b, c);\n\n    // Return the roots in ascending order.\n    if (roots.length === 0) {\n      return [0.0];\n    } else if (roots[1] <= 0.0) {\n      return [roots[0], roots[1], 0.0];\n    } else if (roots[0] >= 0.0) {\n      return [0.0, roots[0], roots[1]];\n    }\n    return [roots[0], 0.0, roots[1]];\n  }\n\n  return computeRealRoots(a, b, c, d);\n};\nexport default CubicRealPolynomial;\n"],"names":["CubicRealPolynomial","computeDiscriminant","a","b","c","d","a2","b2","c2","d2","discriminant","computeRealRoots","A","B","C","D","AC","BD","B2","C2","delta1","delta2","delta3","temp","temp1","ABar","CBar","DBar","s","temp0","Math","abs","sqrt","x","p","pow","q","CBarA","DBarA","CBarD","DBarD","squareRootOfDiscriminant","halfSquareRootOf3","theta","atan2","cosine","cos","temp3","sin","numeratorLarge","denominatorLarge","root1","numeratorSmall","denominatorSmall","root3","E","F","G","root2","roots","ratio","root","Length","length"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 21979, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/QuarticRealPolynomial.js"],"sourcesContent":["import CubicRealPolynomial from \"./CubicRealPolynomial.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport QuadraticRealPolynomial from \"./QuadraticRealPolynomial.js\";\n\n/**\n * Defines functions for 4th order polynomial functions of one variable with only real coefficients.\n *\n * @namespace QuarticRealPolynomial\n */\nconst QuarticRealPolynomial = {};\n\n/**\n * Provides the discriminant of the quartic equation from the supplied coefficients.\n *\n * @param {number} a The coefficient of the 4th order monomial.\n * @param {number} b The coefficient of the 3rd order monomial.\n * @param {number} c The coefficient of the 2nd order monomial.\n * @param {number} d The coefficient of the 1st order monomial.\n * @param {number} e The coefficient of the 0th order monomial.\n * @returns {number} The value of the discriminant.\n */\nQuarticRealPolynomial.computeDiscriminant = function (a, b, c, d, e) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  if (typeof d !== \"number\") {\n    throw new DeveloperError(\"d is a required number.\");\n  }\n  if (typeof e !== \"number\") {\n    throw new DeveloperError(\"e is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  const a2 = a * a;\n  const a3 = a2 * a;\n  const b2 = b * b;\n  const b3 = b2 * b;\n  const c2 = c * c;\n  const c3 = c2 * c;\n  const d2 = d * d;\n  const d3 = d2 * d;\n  const e2 = e * e;\n  const e3 = e2 * e;\n\n  const discriminant =\n    b2 * c2 * d2 -\n    4.0 * b3 * d3 -\n    4.0 * a * c3 * d2 +\n    18 * a * b * c * d3 -\n    27.0 * a2 * d2 * d2 +\n    256.0 * a3 * e3 +\n    e *\n      (18.0 * b3 * c * d -\n        4.0 * b2 * c3 +\n        16.0 * a * c2 * c2 -\n        80.0 * a * b * c2 * d -\n        6.0 * a * b2 * d2 +\n        144.0 * a2 * c * d2) +\n    e2 *\n      (144.0 * a * b2 * c -\n        27.0 * b2 * b2 -\n        128.0 * a2 * c2 -\n        192.0 * a2 * b * d);\n  return discriminant;\n};\n\nfunction original(a3, a2, a1, a0) {\n  const a3Squared = a3 * a3;\n\n  const p = a2 - (3.0 * a3Squared) / 8.0;\n  const q = a1 - (a2 * a3) / 2.0 + (a3Squared * a3) / 8.0;\n  const r =\n    a0 -\n    (a1 * a3) / 4.0 +\n    (a2 * a3Squared) / 16.0 -\n    (3.0 * a3Squared * a3Squared) / 256.0;\n\n  // Find the roots of the cubic equations:  h^6 + 2 p h^4 + (p^2 - 4 r) h^2 - q^2 = 0.\n  const cubicRoots = CubicRealPolynomial.computeRealRoots(\n    1.0,\n    2.0 * p,\n    p * p - 4.0 * r,\n    -q * q,\n  );\n\n  if (cubicRoots.length > 0) {\n    const temp = -a3 / 4.0;\n\n    // Use the largest positive root.\n    const hSquared = cubicRoots[cubicRoots.length - 1];\n\n    if (Math.abs(hSquared) < CesiumMath.EPSILON14) {\n      // y^4 + p y^2 + r = 0.\n      const roots = QuadraticRealPolynomial.computeRealRoots(1.0, p, r);\n\n      if (roots.length === 2) {\n        const root0 = roots[0];\n        const root1 = roots[1];\n\n        let y;\n        if (root0 >= 0.0 && root1 >= 0.0) {\n          const y0 = Math.sqrt(root0);\n          const y1 = Math.sqrt(root1);\n\n          return [temp - y1, temp - y0, temp + y0, temp + y1];\n        } else if (root0 >= 0.0 && root1 < 0.0) {\n          y = Math.sqrt(root0);\n          return [temp - y, temp + y];\n        } else if (root0 < 0.0 && root1 >= 0.0) {\n          y = Math.sqrt(root1);\n          return [temp - y, temp + y];\n        }\n      }\n      return [];\n    } else if (hSquared > 0.0) {\n      const h = Math.sqrt(hSquared);\n\n      const m = (p + hSquared - q / h) / 2.0;\n      const n = (p + hSquared + q / h) / 2.0;\n\n      // Now solve the two quadratic factors:  (y^2 + h y + m)(y^2 - h y + n);\n      const roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, h, m);\n      const roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, -h, n);\n\n      if (roots1.length !== 0) {\n        roots1[0] += temp;\n        roots1[1] += temp;\n\n        if (roots2.length !== 0) {\n          roots2[0] += temp;\n          roots2[1] += temp;\n\n          if (roots1[1] <= roots2[0]) {\n            return [roots1[0], roots1[1], roots2[0], roots2[1]];\n          } else if (roots2[1] <= roots1[0]) {\n            return [roots2[0], roots2[1], roots1[0], roots1[1]];\n          } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {\n            return [roots2[0], roots1[0], roots1[1], roots2[1]];\n          } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {\n            return [roots1[0], roots2[0], roots2[1], roots1[1]];\n          } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {\n            return [roots2[0], roots1[0], roots2[1], roots1[1]];\n          }\n          return [roots1[0], roots2[0], roots1[1], roots2[1]];\n        }\n        return roots1;\n      }\n\n      if (roots2.length !== 0) {\n        roots2[0] += temp;\n        roots2[1] += temp;\n\n        return roots2;\n      }\n      return [];\n    }\n  }\n  return [];\n}\n\nfunction neumark(a3, a2, a1, a0) {\n  const a1Squared = a1 * a1;\n  const a2Squared = a2 * a2;\n  const a3Squared = a3 * a3;\n\n  const p = -2.0 * a2;\n  const q = a1 * a3 + a2Squared - 4.0 * a0;\n  const r = a3Squared * a0 - a1 * a2 * a3 + a1Squared;\n\n  const cubicRoots = CubicRealPolynomial.computeRealRoots(1.0, p, q, r);\n\n  if (cubicRoots.length > 0) {\n    // Use the most positive root\n    const y = cubicRoots[0];\n\n    const temp = a2 - y;\n    const tempSquared = temp * temp;\n\n    const g1 = a3 / 2.0;\n    const h1 = temp / 2.0;\n\n    const m = tempSquared - 4.0 * a0;\n    const mError = tempSquared + 4.0 * Math.abs(a0);\n\n    const n = a3Squared - 4.0 * y;\n    const nError = a3Squared + 4.0 * Math.abs(y);\n\n    let g2;\n    let h2;\n\n    if (y < 0.0 || m * nError < n * mError) {\n      const squareRootOfN = Math.sqrt(n);\n      g2 = squareRootOfN / 2.0;\n      h2 = squareRootOfN === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfN;\n    } else {\n      const squareRootOfM = Math.sqrt(m);\n      g2 = squareRootOfM === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfM;\n      h2 = squareRootOfM / 2.0;\n    }\n\n    let G;\n    let g;\n    if (g1 === 0.0 && g2 === 0.0) {\n      G = 0.0;\n      g = 0.0;\n    } else if (CesiumMath.sign(g1) === CesiumMath.sign(g2)) {\n      G = g1 + g2;\n      g = y / G;\n    } else {\n      g = g1 - g2;\n      G = y / g;\n    }\n\n    let H;\n    let h;\n    if (h1 === 0.0 && h2 === 0.0) {\n      H = 0.0;\n      h = 0.0;\n    } else if (CesiumMath.sign(h1) === CesiumMath.sign(h2)) {\n      H = h1 + h2;\n      h = a0 / H;\n    } else {\n      h = h1 - h2;\n      H = a0 / h;\n    }\n\n    // Now solve the two quadratic factors:  (y^2 + G y + H)(y^2 + g y + h);\n    const roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, G, H);\n    const roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, g, h);\n\n    if (roots1.length !== 0) {\n      if (roots2.length !== 0) {\n        if (roots1[1] <= roots2[0]) {\n          return [roots1[0], roots1[1], roots2[0], roots2[1]];\n        } else if (roots2[1] <= roots1[0]) {\n          return [roots2[0], roots2[1], roots1[0], roots1[1]];\n        } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {\n          return [roots2[0], roots1[0], roots1[1], roots2[1]];\n        } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {\n          return [roots1[0], roots2[0], roots2[1], roots1[1]];\n        } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {\n          return [roots2[0], roots1[0], roots2[1], roots1[1]];\n        }\n        return [roots1[0], roots2[0], roots1[1], roots2[1]];\n      }\n      return roots1;\n    }\n    if (roots2.length !== 0) {\n      return roots2;\n    }\n  }\n  return [];\n}\n\n/**\n * Provides the real valued roots of the quartic polynomial with the provided coefficients.\n *\n * @param {number} a The coefficient of the 4th order monomial.\n * @param {number} b The coefficient of the 3rd order monomial.\n * @param {number} c The coefficient of the 2nd order monomial.\n * @param {number} d The coefficient of the 1st order monomial.\n * @param {number} e The coefficient of the 0th order monomial.\n * @returns {number[]} The real valued roots.\n */\nQuarticRealPolynomial.computeRealRoots = function (a, b, c, d, e) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  if (typeof d !== \"number\") {\n    throw new DeveloperError(\"d is a required number.\");\n  }\n  if (typeof e !== \"number\") {\n    throw new DeveloperError(\"e is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  if (Math.abs(a) < CesiumMath.EPSILON15) {\n    return CubicRealPolynomial.computeRealRoots(b, c, d, e);\n  }\n  const a3 = b / a;\n  const a2 = c / a;\n  const a1 = d / a;\n  const a0 = e / a;\n\n  let k = a3 < 0.0 ? 1 : 0;\n  k += a2 < 0.0 ? k + 1 : k;\n  k += a1 < 0.0 ? k + 1 : k;\n  k += a0 < 0.0 ? k + 1 : k;\n\n  switch (k) {\n    case 0:\n      return original(a3, a2, a1, a0);\n    case 1:\n      return neumark(a3, a2, a1, a0);\n    case 2:\n      return neumark(a3, a2, a1, a0);\n    case 3:\n      return original(a3, a2, a1, a0);\n    case 4:\n      return original(a3, a2, a1, a0);\n    case 5:\n      return neumark(a3, a2, a1, a0);\n    case 6:\n      return original(a3, a2, a1, a0);\n    case 7:\n      return original(a3, a2, a1, a0);\n    case 8:\n      return neumark(a3, a2, a1, a0);\n    case 9:\n      return original(a3, a2, a1, a0);\n    case 10:\n      return original(a3, a2, a1, a0);\n    case 11:\n      return neumark(a3, a2, a1, a0);\n    case 12:\n      return original(a3, a2, a1, a0);\n    case 13:\n      return original(a3, a2, a1, a0);\n    case 14:\n      return original(a3, a2, a1, a0);\n    case 15:\n      return original(a3, a2, a1, a0);\n    default:\n      return undefined;\n  }\n};\nexport default QuarticRealPolynomial;\n"],"names":["QuarticRealPolynomial","computeDiscriminant","a","b","c","d","e","a2","a3","b2","b3","c2","c3","d2","d3","e2","e3","discriminant","original","a1","a0","a3Squared","p","q","r","cubicRoots","computeRealRoots","length","temp","hSquared","Math","abs","EPSILON14","roots","root0","root1","y","y0","sqrt","y1","h","m","n","roots1","roots2","neumark","a1Squared","a2Squared","tempSquared","g1","h1","mError","nError","g2","h2","squareRootOfN","squareRootOfM","G","g","sign","H","EPSILON15","k","undefined"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;;CAIC,GACD,MAAMA,wBAAwB,CAAC;AAE/B;;;;;;;;;CASC,GACDA,sBAAsBC,mBAAmB,GAAG,SAAUC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC;IACjE,yCAAyC;IACzC,IAAI,OAAOJ,MAAM,UAAU;QACzB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,OAAOC,MAAM,UAAU;QACzB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,OAAOC,MAAM,UAAU;QACzB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,OAAOC,MAAM,UAAU;QACzB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,OAAOC,MAAM,UAAU;QACzB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAMC,KAAKL,IAAIA;IACf,MAAMM,KAAKD,KAAKL;IAChB,MAAMO,KAAKN,IAAIA;IACf,MAAMO,KAAKD,KAAKN;IAChB,MAAMQ,KAAKP,IAAIA;IACf,MAAMQ,KAAKD,KAAKP;IAChB,MAAMS,KAAKR,IAAIA;IACf,MAAMS,KAAKD,KAAKR;IAChB,MAAMU,KAAKT,IAAIA;IACf,MAAMU,KAAKD,KAAKT;IAEhB,MAAMW,eACJR,KAAKE,KAAKE,KACV,MAAMH,KAAKI,KACX,MAAMZ,IAAIU,KAAKC,KACf,KAAKX,IAAIC,IAAIC,IAAIU,KACjB,OAAOP,KAAKM,KAAKA,KACjB,QAAQL,KAAKQ,KACbV,IACE,CAAC,OAAOI,KAAKN,IAAIC,IACf,MAAMI,KAAKG,KACX,OAAOV,IAAIS,KAAKA,KAChB,OAAOT,IAAIC,IAAIQ,KAAKN,IACpB,MAAMH,IAAIO,KAAKI,KACf,QAAQN,KAAKH,IAAIS,EAAE,IACvBE,KACE,CAAC,QAAQb,IAAIO,KAAKL,IAChB,OAAOK,KAAKA,KACZ,QAAQF,KAAKI,KACb,QAAQJ,KAAKJ,IAAIE,CAAC;IACxB,OAAOY;AACT;AAEA,SAASC,SAASV,EAAE,EAAED,EAAE,EAAEY,EAAE,EAAEC,EAAE;IAC9B,MAAMC,YAAYb,KAAKA;IAEvB,MAAMc,IAAIf,KAAK,AAAC,MAAMc,YAAa;IACnC,MAAME,IAAIJ,KAAK,AAACZ,KAAKC,KAAM,MAAM,AAACa,YAAYb,KAAM;IACpD,MAAMgB,IACJJ,KACA,AAACD,KAAKX,KAAM,MACZ,AAACD,KAAKc,YAAa,OACnB,AAAC,MAAMA,YAAYA,YAAa;IAElC,qFAAqF;IACrF,MAAMI,aAAa,yLAAmB,CAACC,gBAAgB,CACrD,KACA,MAAMJ,GACNA,IAAIA,IAAI,MAAME,GACd,CAACD,IAAIA;IAGP,IAAIE,WAAWE,MAAM,GAAG,GAAG;QACzB,MAAMC,OAAO,CAACpB,KAAK;QAEnB,iCAAiC;QACjC,MAAMqB,WAAWJ,UAAU,CAACA,WAAWE,MAAM,GAAG,EAAE;QAElD,IAAIG,KAAKC,GAAG,CAACF,YAAY,0KAAU,CAACG,SAAS,EAAE;YAC7C,uBAAuB;YACvB,MAAMC,QAAQ,6LAAuB,CAACP,gBAAgB,CAAC,KAAKJ,GAAGE;YAE/D,IAAIS,MAAMN,MAAM,KAAK,GAAG;gBACtB,MAAMO,QAAQD,KAAK,CAAC,EAAE;gBACtB,MAAME,QAAQF,KAAK,CAAC,EAAE;gBAEtB,IAAIG;gBACJ,IAAIF,SAAS,OAAOC,SAAS,KAAK;oBAChC,MAAME,KAAKP,KAAKQ,IAAI,CAACJ;oBACrB,MAAMK,KAAKT,KAAKQ,IAAI,CAACH;oBAErB,OAAO;wBAACP,OAAOW;wBAAIX,OAAOS;wBAAIT,OAAOS;wBAAIT,OAAOW;qBAAG;gBACrD,OAAO,IAAIL,SAAS,OAAOC,QAAQ,KAAK;oBACtCC,IAAIN,KAAKQ,IAAI,CAACJ;oBACd,OAAO;wBAACN,OAAOQ;wBAAGR,OAAOQ;qBAAE;gBAC7B,OAAO,IAAIF,QAAQ,OAAOC,SAAS,KAAK;oBACtCC,IAAIN,KAAKQ,IAAI,CAACH;oBACd,OAAO;wBAACP,OAAOQ;wBAAGR,OAAOQ;qBAAE;gBAC7B;YACF;YACA,OAAO,EAAE;QACX,OAAO,IAAIP,WAAW,KAAK;YACzB,MAAMW,IAAIV,KAAKQ,IAAI,CAACT;YAEpB,MAAMY,IAAI,CAACnB,IAAIO,WAAWN,IAAIiB,CAAC,IAAI;YACnC,MAAME,IAAI,CAACpB,IAAIO,WAAWN,IAAIiB,CAAC,IAAI;YAEnC,wEAAwE;YACxE,MAAMG,SAAS,6LAAuB,CAACjB,gBAAgB,CAAC,KAAKc,GAAGC;YAChE,MAAMG,SAAS,6LAAuB,CAAClB,gBAAgB,CAAC,KAAK,CAACc,GAAGE;YAEjE,IAAIC,OAAOhB,MAAM,KAAK,GAAG;gBACvBgB,MAAM,CAAC,EAAE,IAAIf;gBACbe,MAAM,CAAC,EAAE,IAAIf;gBAEb,IAAIgB,OAAOjB,MAAM,KAAK,GAAG;oBACvBiB,MAAM,CAAC,EAAE,IAAIhB;oBACbgB,MAAM,CAAC,EAAE,IAAIhB;oBAEb,IAAIe,MAAM,CAAC,EAAE,IAAIC,MAAM,CAAC,EAAE,EAAE;wBAC1B,OAAO;4BAACD,MAAM,CAAC,EAAE;4BAAEA,MAAM,CAAC,EAAE;4BAAEC,MAAM,CAAC,EAAE;4BAAEA,MAAM,CAAC,EAAE;yBAAC;oBACrD,OAAO,IAAIA,MAAM,CAAC,EAAE,IAAID,MAAM,CAAC,EAAE,EAAE;wBACjC,OAAO;4BAACC,MAAM,CAAC,EAAE;4BAAEA,MAAM,CAAC,EAAE;4BAAED,MAAM,CAAC,EAAE;4BAAEA,MAAM,CAAC,EAAE;yBAAC;oBACrD,OAAO,IAAIA,MAAM,CAAC,EAAE,IAAIC,MAAM,CAAC,EAAE,IAAID,MAAM,CAAC,EAAE,IAAIC,MAAM,CAAC,EAAE,EAAE;wBAC3D,OAAO;4BAACA,MAAM,CAAC,EAAE;4BAAED,MAAM,CAAC,EAAE;4BAAEA,MAAM,CAAC,EAAE;4BAAEC,MAAM,CAAC,EAAE;yBAAC;oBACrD,OAAO,IAAIA,MAAM,CAAC,EAAE,IAAID,MAAM,CAAC,EAAE,IAAIC,MAAM,CAAC,EAAE,IAAID,MAAM,CAAC,EAAE,EAAE;wBAC3D,OAAO;4BAACA,MAAM,CAAC,EAAE;4BAAEC,MAAM,CAAC,EAAE;4BAAEA,MAAM,CAAC,EAAE;4BAAED,MAAM,CAAC,EAAE;yBAAC;oBACrD,OAAO,IAAIA,MAAM,CAAC,EAAE,GAAGC,MAAM,CAAC,EAAE,IAAID,MAAM,CAAC,EAAE,GAAGC,MAAM,CAAC,EAAE,EAAE;wBACzD,OAAO;4BAACA,MAAM,CAAC,EAAE;4BAAED,MAAM,CAAC,EAAE;4BAAEC,MAAM,CAAC,EAAE;4BAAED,MAAM,CAAC,EAAE;yBAAC;oBACrD;oBACA,OAAO;wBAACA,MAAM,CAAC,EAAE;wBAAEC,MAAM,CAAC,EAAE;wBAAED,MAAM,CAAC,EAAE;wBAAEC,MAAM,CAAC,EAAE;qBAAC;gBACrD;gBACA,OAAOD;YACT;YAEA,IAAIC,OAAOjB,MAAM,KAAK,GAAG;gBACvBiB,MAAM,CAAC,EAAE,IAAIhB;gBACbgB,MAAM,CAAC,EAAE,IAAIhB;gBAEb,OAAOgB;YACT;YACA,OAAO,EAAE;QACX;IACF;IACA,OAAO,EAAE;AACX;AAEA,SAASC,QAAQrC,EAAE,EAAED,EAAE,EAAEY,EAAE,EAAEC,EAAE;IAC7B,MAAM0B,YAAY3B,KAAKA;IACvB,MAAM4B,YAAYxC,KAAKA;IACvB,MAAMc,YAAYb,KAAKA;IAEvB,MAAMc,IAAI,CAAC,MAAMf;IACjB,MAAMgB,IAAIJ,KAAKX,KAAKuC,YAAY,MAAM3B;IACtC,MAAMI,IAAIH,YAAYD,KAAKD,KAAKZ,KAAKC,KAAKsC;IAE1C,MAAMrB,aAAa,yLAAmB,CAACC,gBAAgB,CAAC,KAAKJ,GAAGC,GAAGC;IAEnE,IAAIC,WAAWE,MAAM,GAAG,GAAG;QACzB,6BAA6B;QAC7B,MAAMS,IAAIX,UAAU,CAAC,EAAE;QAEvB,MAAMG,OAAOrB,KAAK6B;QAClB,MAAMY,cAAcpB,OAAOA;QAE3B,MAAMqB,KAAKzC,KAAK;QAChB,MAAM0C,KAAKtB,OAAO;QAElB,MAAMa,IAAIO,cAAc,MAAM5B;QAC9B,MAAM+B,SAASH,cAAc,MAAMlB,KAAKC,GAAG,CAACX;QAE5C,MAAMsB,IAAIrB,YAAY,MAAMe;QAC5B,MAAMgB,SAAS/B,YAAY,MAAMS,KAAKC,GAAG,CAACK;QAE1C,IAAIiB;QACJ,IAAIC;QAEJ,IAAIlB,IAAI,OAAOK,IAAIW,SAASV,IAAIS,QAAQ;YACtC,MAAMI,gBAAgBzB,KAAKQ,IAAI,CAACI;YAChCW,KAAKE,gBAAgB;YACrBD,KAAKC,kBAAkB,MAAM,MAAM,CAAC/C,KAAK0C,KAAK/B,EAAE,IAAIoC;QACtD,OAAO;YACL,MAAMC,gBAAgB1B,KAAKQ,IAAI,CAACG;YAChCY,KAAKG,kBAAkB,MAAM,MAAM,CAAChD,KAAK0C,KAAK/B,EAAE,IAAIqC;YACpDF,KAAKE,gBAAgB;QACvB;QAEA,IAAIC;QACJ,IAAIC;QACJ,IAAIT,OAAO,OAAOI,OAAO,KAAK;YAC5BI,IAAI;YACJC,IAAI;QACN,OAAO,IAAI,0KAAU,CAACC,IAAI,CAACV,QAAQ,0KAAU,CAACU,IAAI,CAACN,KAAK;YACtDI,IAAIR,KAAKI;YACTK,IAAItB,IAAIqB;QACV,OAAO;YACLC,IAAIT,KAAKI;YACTI,IAAIrB,IAAIsB;QACV;QAEA,IAAIE;QACJ,IAAIpB;QACJ,IAAIU,OAAO,OAAOI,OAAO,KAAK;YAC5BM,IAAI;YACJpB,IAAI;QACN,OAAO,IAAI,0KAAU,CAACmB,IAAI,CAACT,QAAQ,0KAAU,CAACS,IAAI,CAACL,KAAK;YACtDM,IAAIV,KAAKI;YACTd,IAAIpB,KAAKwC;QACX,OAAO;YACLpB,IAAIU,KAAKI;YACTM,IAAIxC,KAAKoB;QACX;QAEA,wEAAwE;QACxE,MAAMG,SAAS,6LAAuB,CAACjB,gBAAgB,CAAC,KAAK+B,GAAGG;QAChE,MAAMhB,SAAS,6LAAuB,CAAClB,gBAAgB,CAAC,KAAKgC,GAAGlB;QAEhE,IAAIG,OAAOhB,MAAM,KAAK,GAAG;YACvB,IAAIiB,OAAOjB,MAAM,KAAK,GAAG;gBACvB,IAAIgB,MAAM,CAAC,EAAE,IAAIC,MAAM,CAAC,EAAE,EAAE;oBAC1B,OAAO;wBAACD,MAAM,CAAC,EAAE;wBAAEA,MAAM,CAAC,EAAE;wBAAEC,MAAM,CAAC,EAAE;wBAAEA,MAAM,CAAC,EAAE;qBAAC;gBACrD,OAAO,IAAIA,MAAM,CAAC,EAAE,IAAID,MAAM,CAAC,EAAE,EAAE;oBACjC,OAAO;wBAACC,MAAM,CAAC,EAAE;wBAAEA,MAAM,CAAC,EAAE;wBAAED,MAAM,CAAC,EAAE;wBAAEA,MAAM,CAAC,EAAE;qBAAC;gBACrD,OAAO,IAAIA,MAAM,CAAC,EAAE,IAAIC,MAAM,CAAC,EAAE,IAAID,MAAM,CAAC,EAAE,IAAIC,MAAM,CAAC,EAAE,EAAE;oBAC3D,OAAO;wBAACA,MAAM,CAAC,EAAE;wBAAED,MAAM,CAAC,EAAE;wBAAEA,MAAM,CAAC,EAAE;wBAAEC,MAAM,CAAC,EAAE;qBAAC;gBACrD,OAAO,IAAIA,MAAM,CAAC,EAAE,IAAID,MAAM,CAAC,EAAE,IAAIC,MAAM,CAAC,EAAE,IAAID,MAAM,CAAC,EAAE,EAAE;oBAC3D,OAAO;wBAACA,MAAM,CAAC,EAAE;wBAAEC,MAAM,CAAC,EAAE;wBAAEA,MAAM,CAAC,EAAE;wBAAED,MAAM,CAAC,EAAE;qBAAC;gBACrD,OAAO,IAAIA,MAAM,CAAC,EAAE,GAAGC,MAAM,CAAC,EAAE,IAAID,MAAM,CAAC,EAAE,GAAGC,MAAM,CAAC,EAAE,EAAE;oBACzD,OAAO;wBAACA,MAAM,CAAC,EAAE;wBAAED,MAAM,CAAC,EAAE;wBAAEC,MAAM,CAAC,EAAE;wBAAED,MAAM,CAAC,EAAE;qBAAC;gBACrD;gBACA,OAAO;oBAACA,MAAM,CAAC,EAAE;oBAAEC,MAAM,CAAC,EAAE;oBAAED,MAAM,CAAC,EAAE;oBAAEC,MAAM,CAAC,EAAE;iBAAC;YACrD;YACA,OAAOD;QACT;QACA,IAAIC,OAAOjB,MAAM,KAAK,GAAG;YACvB,OAAOiB;QACT;IACF;IACA,OAAO,EAAE;AACX;AAEA;;;;;;;;;CASC,GACD5C,sBAAsB0B,gBAAgB,GAAG,SAAUxB,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC;IAC9D,yCAAyC;IACzC,IAAI,OAAOJ,MAAM,UAAU;QACzB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,OAAOC,MAAM,UAAU;QACzB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,OAAOC,MAAM,UAAU;QACzB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,OAAOC,MAAM,UAAU;QACzB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,OAAOC,MAAM,UAAU;QACzB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,IAAIwB,KAAKC,GAAG,CAAC7B,KAAK,0KAAU,CAAC2D,SAAS,EAAE;QACtC,OAAO,yLAAmB,CAACnC,gBAAgB,CAACvB,GAAGC,GAAGC,GAAGC;IACvD;IACA,MAAME,KAAKL,IAAID;IACf,MAAMK,KAAKH,IAAIF;IACf,MAAMiB,KAAKd,IAAIH;IACf,MAAMkB,KAAKd,IAAIJ;IAEf,IAAI4D,IAAItD,KAAK,MAAM,IAAI;IACvBsD,KAAKvD,KAAK,MAAMuD,IAAI,IAAIA;IACxBA,KAAK3C,KAAK,MAAM2C,IAAI,IAAIA;IACxBA,KAAK1C,KAAK,MAAM0C,IAAI,IAAIA;IAExB,OAAQA;QACN,KAAK;YACH,OAAO5C,SAASV,IAAID,IAAIY,IAAIC;QAC9B,KAAK;YACH,OAAOyB,QAAQrC,IAAID,IAAIY,IAAIC;QAC7B,KAAK;YACH,OAAOyB,QAAQrC,IAAID,IAAIY,IAAIC;QAC7B,KAAK;YACH,OAAOF,SAASV,IAAID,IAAIY,IAAIC;QAC9B,KAAK;YACH,OAAOF,SAASV,IAAID,IAAIY,IAAIC;QAC9B,KAAK;YACH,OAAOyB,QAAQrC,IAAID,IAAIY,IAAIC;QAC7B,KAAK;YACH,OAAOF,SAASV,IAAID,IAAIY,IAAIC;QAC9B,KAAK;YACH,OAAOF,SAASV,IAAID,IAAIY,IAAIC;QAC9B,KAAK;YACH,OAAOyB,QAAQrC,IAAID,IAAIY,IAAIC;QAC7B,KAAK;YACH,OAAOF,SAASV,IAAID,IAAIY,IAAIC;QAC9B,KAAK;YACH,OAAOF,SAASV,IAAID,IAAIY,IAAIC;QAC9B,KAAK;YACH,OAAOyB,QAAQrC,IAAID,IAAIY,IAAIC;QAC7B,KAAK;YACH,OAAOF,SAASV,IAAID,IAAIY,IAAIC;QAC9B,KAAK;YACH,OAAOF,SAASV,IAAID,IAAIY,IAAIC;QAC9B,KAAK;YACH,OAAOF,SAASV,IAAID,IAAIY,IAAIC;QAC9B,KAAK;YACH,OAAOF,SAASV,IAAID,IAAIY,IAAIC;QAC9B;YACE,OAAO2C;IACX;AACF;uCACe/D","ignoreList":[0]}},
    {"offset": {"line": 22336, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Ray.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Represents a ray that extends infinitely from the provided origin in the provided direction.\n * @alias Ray\n * @constructor\n *\n * @param {Cartesian3} [origin=Cartesian3.ZERO] The origin of the ray.\n * @param {Cartesian3} [direction=Cartesian3.ZERO] The direction of the ray.\n */\nfunction Ray(origin, direction) {\n  direction = Cartesian3.clone(direction ?? Cartesian3.ZERO);\n  if (!Cartesian3.equals(direction, Cartesian3.ZERO)) {\n    Cartesian3.normalize(direction, direction);\n  }\n\n  /**\n   * The origin of the ray.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.origin = Cartesian3.clone(origin ?? Cartesian3.ZERO);\n\n  /**\n   * The direction of the ray.\n   * @type {Cartesian3}\n   */\n  this.direction = direction;\n}\n\n/**\n * Duplicates a Ray instance.\n *\n * @param {Ray} ray The ray to duplicate.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray} The modified result parameter or a new Ray instance if one was not provided. (Returns undefined if ray is undefined)\n */\nRay.clone = function (ray, result) {\n  if (!defined(ray)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Ray(ray.origin, ray.direction);\n  }\n  result.origin = Cartesian3.clone(ray.origin);\n  result.direction = Cartesian3.clone(ray.direction);\n  return result;\n};\n\n/**\n * Computes the point along the ray given by r(t) = o + t*d,\n * where o is the origin of the ray and d is the direction.\n *\n * @param {Ray} ray The ray.\n * @param {number} t A scalar value.\n * @param {Cartesian3} [result] The object in which the result will be stored.\n * @returns {Cartesian3} The modified result parameter, or a new instance if none was provided.\n *\n * @example\n * //Get the first intersection point of a ray and an ellipsoid.\n * const intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);\n * const point = Cesium.Ray.getPoint(ray, intersection.start);\n */\nRay.getPoint = function (ray, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ray\", ray);\n  Check.typeOf.number(\"t\", t);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result = Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\nexport default Ray;\n"],"names":["Ray","origin","direction","clone","ZERO","equals","normalize","ray","result","undefined","getPoint","t","typeOf","object","number","multiplyByScalar","add"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;CAOC,GACD,SAASA,IAAIC,MAAM,EAAEC,SAAS;IAC5BA,YAAY,gLAAU,CAACC,KAAK,CAACD,aAAa,gLAAU,CAACE,IAAI;IACzD,IAAI,CAAC,gLAAU,CAACC,MAAM,CAACH,WAAW,gLAAU,CAACE,IAAI,GAAG;QAClD,gLAAU,CAACE,SAAS,CAACJ,WAAWA;IAClC;IAEA;;;;GAIC,GACD,IAAI,CAACD,MAAM,GAAG,gLAAU,CAACE,KAAK,CAACF,UAAU,gLAAU,CAACG,IAAI;IAExD;;;GAGC,GACD,IAAI,CAACF,SAAS,GAAGA;AACnB;AAEA;;;;;;CAMC,GACDF,IAAIG,KAAK,GAAG,SAAUI,GAAG,EAAEC,MAAM;IAC/B,IAAI,CAAC,IAAA,6KAAO,EAACD,MAAM;QACjB,OAAOE;IACT;IACA,IAAI,CAAC,IAAA,6KAAO,EAACD,SAAS;QACpB,OAAO,IAAIR,IAAIO,IAAIN,MAAM,EAAEM,IAAIL,SAAS;IAC1C;IACAM,OAAOP,MAAM,GAAG,gLAAU,CAACE,KAAK,CAACI,IAAIN,MAAM;IAC3CO,OAAON,SAAS,GAAG,gLAAU,CAACC,KAAK,CAACI,IAAIL,SAAS;IACjD,OAAOM;AACT;AAEA;;;;;;;;;;;;;CAaC,GACDR,IAAIU,QAAQ,GAAG,SAAUH,GAAG,EAAEI,CAAC,EAAEH,MAAM;IACrC,yCAAyC;IACzC,2KAAK,CAACI,MAAM,CAACC,MAAM,CAAC,OAAON;IAC3B,2KAAK,CAACK,MAAM,CAACE,MAAM,CAAC,KAAKH;IACzB,wBAAwB;IAExB,IAAI,CAAC,IAAA,6KAAO,EAACH,SAAS;QACpBA,SAAS,IAAI,gLAAU;IACzB;IAEAA,SAAS,gLAAU,CAACO,gBAAgB,CAACR,IAAIL,SAAS,EAAES,GAAGH;IACvD,OAAO,gLAAU,CAACQ,GAAG,CAACT,IAAIN,MAAM,EAAEO,QAAQA;AAC5C;uCACeR","ignoreList":[0]}},
    {"offset": {"line": 22414, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/IntersectionTests.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport QuadraticRealPolynomial from \"./QuadraticRealPolynomial.js\";\nimport QuarticRealPolynomial from \"./QuarticRealPolynomial.js\";\nimport Ray from \"./Ray.js\";\n\n/**\n * Functions for computing the intersection between geometries such as rays, planes, triangles, and ellipsoids.\n *\n * @namespace IntersectionTests\n */\nconst IntersectionTests = {};\n\n/**\n * Computes the intersection of a ray and a plane.\n *\n * @param {Ray} ray The ray.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.rayPlane = function (ray, plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const origin = ray.origin;\n  const direction = ray.direction;\n  const normal = plane.normal;\n  const denominator = Cartesian3.dot(normal, direction);\n\n  if (Math.abs(denominator) < CesiumMath.EPSILON15) {\n    // Ray is parallel to plane.  The ray may be in the polygon's plane.\n    return undefined;\n  }\n\n  const t = (-plane.distance - Cartesian3.dot(normal, origin)) / denominator;\n\n  if (t < 0) {\n    return undefined;\n  }\n\n  result = Cartesian3.multiplyByScalar(direction, t, result);\n  return Cartesian3.add(origin, result, result);\n};\n\nconst scratchEdge0 = new Cartesian3();\nconst scratchEdge1 = new Cartesian3();\nconst scratchPVec = new Cartesian3();\nconst scratchTVec = new Cartesian3();\nconst scratchQVec = new Cartesian3();\n\n/**\n * Computes the intersection of a ray and a triangle as a parametric distance along the input ray. The result is negative when the triangle is behind the ray.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @returns {number} The intersection as a parametric distance along the ray, or undefined if there is no intersection.\n */\nIntersectionTests.rayTriangleParametric = function (\n  ray,\n  p0,\n  p1,\n  p2,\n  cullBackFaces,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(p2)) {\n    throw new DeveloperError(\"p2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  cullBackFaces = cullBackFaces ?? false;\n\n  const origin = ray.origin;\n  const direction = ray.direction;\n\n  const edge0 = Cartesian3.subtract(p1, p0, scratchEdge0);\n  const edge1 = Cartesian3.subtract(p2, p0, scratchEdge1);\n\n  const p = Cartesian3.cross(direction, edge1, scratchPVec);\n  const det = Cartesian3.dot(edge0, p);\n\n  let tvec;\n  let q;\n\n  let u;\n  let v;\n  let t;\n\n  if (cullBackFaces) {\n    if (det < CesiumMath.EPSILON6) {\n      return undefined;\n    }\n\n    tvec = Cartesian3.subtract(origin, p0, scratchTVec);\n    u = Cartesian3.dot(tvec, p);\n    if (u < 0.0 || u > det) {\n      return undefined;\n    }\n\n    q = Cartesian3.cross(tvec, edge0, scratchQVec);\n\n    v = Cartesian3.dot(direction, q);\n    if (v < 0.0 || u + v > det) {\n      return undefined;\n    }\n\n    t = Cartesian3.dot(edge1, q) / det;\n  } else {\n    if (Math.abs(det) < CesiumMath.EPSILON6) {\n      return undefined;\n    }\n    const invDet = 1.0 / det;\n\n    tvec = Cartesian3.subtract(origin, p0, scratchTVec);\n    u = Cartesian3.dot(tvec, p) * invDet;\n    if (u < 0.0 || u > 1.0) {\n      return undefined;\n    }\n\n    q = Cartesian3.cross(tvec, edge0, scratchQVec);\n\n    v = Cartesian3.dot(direction, q) * invDet;\n    if (v < 0.0 || u + v > 1.0) {\n      return undefined;\n    }\n\n    t = Cartesian3.dot(edge1, q) * invDet;\n  }\n\n  return t;\n};\n\n/**\n * Computes the intersection of a ray and a triangle as a Cartesian3 coordinate.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.rayTriangle = function (\n  ray,\n  p0,\n  p1,\n  p2,\n  cullBackFaces,\n  result,\n) {\n  const t = IntersectionTests.rayTriangleParametric(\n    ray,\n    p0,\n    p1,\n    p2,\n    cullBackFaces,\n  );\n  if (!defined(t) || t < 0.0) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\n\nconst scratchLineSegmentTriangleRay = new Ray();\n\n/**\n * Computes the intersection of a line segment and a triangle.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} v0 The an end point of the line segment.\n * @param {Cartesian3} v1 The other end point of the line segment.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.lineSegmentTriangle = function (\n  v0,\n  v1,\n  p0,\n  p1,\n  p2,\n  cullBackFaces,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(v0)) {\n    throw new DeveloperError(\"v0 is required.\");\n  }\n  if (!defined(v1)) {\n    throw new DeveloperError(\"v1 is required.\");\n  }\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(p2)) {\n    throw new DeveloperError(\"p2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const ray = scratchLineSegmentTriangleRay;\n  Cartesian3.clone(v0, ray.origin);\n  Cartesian3.subtract(v1, v0, ray.direction);\n  Cartesian3.normalize(ray.direction, ray.direction);\n\n  const t = IntersectionTests.rayTriangleParametric(\n    ray,\n    p0,\n    p1,\n    p2,\n    cullBackFaces,\n  );\n  if (!defined(t) || t < 0.0 || t > Cartesian3.distance(v0, v1)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\n\nfunction solveQuadratic(a, b, c, result) {\n  const det = b * b - 4.0 * a * c;\n  if (det < 0.0) {\n    return undefined;\n  } else if (det > 0.0) {\n    const denom = 1.0 / (2.0 * a);\n    const disc = Math.sqrt(det);\n    const root0 = (-b + disc) * denom;\n    const root1 = (-b - disc) * denom;\n\n    if (root0 < root1) {\n      result.root0 = root0;\n      result.root1 = root1;\n    } else {\n      result.root0 = root1;\n      result.root1 = root0;\n    }\n\n    return result;\n  }\n\n  const root = -b / (2.0 * a);\n  if (root === 0.0) {\n    return undefined;\n  }\n\n  result.root0 = result.root1 = root;\n  return result;\n}\n\nconst raySphereRoots = {\n  root0: 0.0,\n  root1: 0.0,\n};\n\nfunction raySphere(ray, sphere, result) {\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  const origin = ray.origin;\n  const direction = ray.direction;\n\n  const center = sphere.center;\n  const radiusSquared = sphere.radius * sphere.radius;\n\n  const diff = Cartesian3.subtract(origin, center, scratchPVec);\n\n  const a = Cartesian3.dot(direction, direction);\n  const b = 2.0 * Cartesian3.dot(direction, diff);\n  const c = Cartesian3.magnitudeSquared(diff) - radiusSquared;\n\n  const roots = solveQuadratic(a, b, c, raySphereRoots);\n  if (!defined(roots)) {\n    return undefined;\n  }\n\n  result.start = roots.root0;\n  result.stop = roots.root1;\n  return result;\n}\n\n/**\n * Computes the intersection points of a ray with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.raySphere = function (ray, sphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(sphere)) {\n    throw new DeveloperError(\"sphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  result = raySphere(ray, sphere, result);\n  if (!defined(result) || result.stop < 0.0) {\n    return undefined;\n  }\n\n  result.start = Math.max(result.start, 0.0);\n  return result;\n};\n\nconst scratchLineSegmentRay = new Ray();\n\n/**\n * Computes the intersection points of a line segment with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} p0 An end point of the line segment.\n * @param {Cartesian3} p1 The other end point of the line segment.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.lineSegmentSphere = function (p0, p1, sphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(sphere)) {\n    throw new DeveloperError(\"sphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const ray = scratchLineSegmentRay;\n  Cartesian3.clone(p0, ray.origin);\n  const direction = Cartesian3.subtract(p1, p0, ray.direction);\n\n  const maxT = Cartesian3.magnitude(direction);\n  Cartesian3.normalize(direction, direction);\n\n  result = raySphere(ray, sphere, result);\n  if (!defined(result) || result.stop < 0.0 || result.start > maxT) {\n    return undefined;\n  }\n\n  result.start = Math.max(result.start, 0.0);\n  result.stop = Math.min(result.stop, maxT);\n  return result;\n};\n\nconst scratchQ = new Cartesian3();\nconst scratchW = new Cartesian3();\n\n/**\n * Computes the intersection points of a ray with an ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.rayEllipsoid = function (ray, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(ellipsoid)) {\n    throw new DeveloperError(\"ellipsoid is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const inverseRadii = ellipsoid.oneOverRadii;\n  const q = Cartesian3.multiplyComponents(inverseRadii, ray.origin, scratchQ);\n  const w = Cartesian3.multiplyComponents(\n    inverseRadii,\n    ray.direction,\n    scratchW,\n  );\n\n  const q2 = Cartesian3.magnitudeSquared(q);\n  const qw = Cartesian3.dot(q, w);\n\n  let difference, w2, product, discriminant, temp;\n\n  if (q2 > 1.0) {\n    // Outside ellipsoid.\n    if (qw >= 0.0) {\n      // Looking outward or tangent (0 intersections).\n      return undefined;\n    }\n\n    // qw < 0.0.\n    const qw2 = qw * qw;\n    difference = q2 - 1.0; // Positively valued.\n    w2 = Cartesian3.magnitudeSquared(w);\n    product = w2 * difference;\n\n    if (qw2 < product) {\n      // Imaginary roots (0 intersections).\n      return undefined;\n    } else if (qw2 > product) {\n      // Distinct roots (2 intersections).\n      discriminant = qw * qw - product;\n      temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.\n      const root0 = temp / w2;\n      const root1 = difference / temp;\n      if (root0 < root1) {\n        return new Interval(root0, root1);\n      }\n\n      return {\n        start: root1,\n        stop: root0,\n      };\n    }\n    // qw2 == product.  Repeated roots (2 intersections).\n    const root = Math.sqrt(difference / w2);\n    return new Interval(root, root);\n  } else if (q2 < 1.0) {\n    // Inside ellipsoid (2 intersections).\n    difference = q2 - 1.0; // Negatively valued.\n    w2 = Cartesian3.magnitudeSquared(w);\n    product = w2 * difference; // Negatively valued.\n\n    discriminant = qw * qw - product;\n    temp = -qw + Math.sqrt(discriminant); // Positively valued.\n    return new Interval(0.0, temp / w2);\n  }\n  // q2 == 1.0. On ellipsoid.\n  if (qw < 0.0) {\n    // Looking inward.\n    w2 = Cartesian3.magnitudeSquared(w);\n    return new Interval(0.0, -qw / w2);\n  }\n\n  // qw >= 0.0.  Looking outward or tangent.\n  return undefined;\n};\n\nconst scratchRayIntervalX = new Interval();\nconst scratchRayIntervalY = new Interval();\nconst scratchRayIntervalZ = new Interval();\n\n/**\n * Computes the intersection points of a ray with an axis-aligned bounding box. (axis-aligned in the same space as the ray)\n *\n * @param {Ray} ray The ray.\n * @param {AxisAlignedBoundingBox} box The axis-aligned bounding box.\n * @param {Interval | undefined} result The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.rayAxisAlignedBoundingBox = function (ray, box, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  const tx = rayIntervalAlongAABBAxis(\n    ray.origin.x,\n    ray.direction.x,\n    box.minimum.x,\n    box.maximum.x,\n    scratchRayIntervalX,\n  );\n  const ty = rayIntervalAlongAABBAxis(\n    ray.origin.y,\n    ray.direction.y,\n    box.minimum.y,\n    box.maximum.y,\n    scratchRayIntervalY,\n  );\n  const tz = rayIntervalAlongAABBAxis(\n    ray.origin.z,\n    ray.direction.z,\n    box.minimum.z,\n    box.maximum.z,\n    scratchRayIntervalZ,\n  );\n\n  result.start = tx.start > ty.start ? tx.start : ty.start; //Get Greatest Min\n  result.stop = tx.stop < ty.stop ? tx.stop : ty.stop; //Get Smallest Max\n\n  if (tx.start > ty.stop || ty.start > tx.stop) {\n    return undefined;\n  }\n\n  if (result.start > tz.stop || tz.start > result.stop) {\n    return undefined;\n  }\n\n  if (tz.start > result.start) {\n    result.start = tz.start;\n  }\n  if (tz.stop < result.stop) {\n    result.stop = tz.stop;\n  }\n\n  return result;\n};\n\nfunction rayIntervalAlongAABBAxis(origin, direction, min, max, result) {\n  result.start = (min - origin) / direction;\n  result.stop = (max - origin) / direction;\n  if (result.stop < result.start) {\n    const tmp = result.stop;\n    result.stop = result.start;\n    result.start = tmp;\n  }\n\n  return result;\n}\n\nfunction addWithCancellationCheck(left, right, tolerance) {\n  const difference = left + right;\n  if (\n    CesiumMath.sign(left) !== CesiumMath.sign(right) &&\n    Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance\n  ) {\n    return 0.0;\n  }\n\n  return difference;\n}\n\n/**\n * @private\n */\nIntersectionTests.quadraticVectorExpression = function (A, b, c, x, w) {\n  const xSquared = x * x;\n  const wSquared = w * w;\n\n  const l2 = (A[Matrix3.COLUMN1ROW1] - A[Matrix3.COLUMN2ROW2]) * wSquared;\n  const l1 =\n    w *\n    (x *\n      addWithCancellationCheck(\n        A[Matrix3.COLUMN1ROW0],\n        A[Matrix3.COLUMN0ROW1],\n        CesiumMath.EPSILON15,\n      ) +\n      b.y);\n  const l0 =\n    A[Matrix3.COLUMN0ROW0] * xSquared +\n    A[Matrix3.COLUMN2ROW2] * wSquared +\n    x * b.x +\n    c;\n\n  const r1 =\n    wSquared *\n    addWithCancellationCheck(\n      A[Matrix3.COLUMN2ROW1],\n      A[Matrix3.COLUMN1ROW2],\n      CesiumMath.EPSILON15,\n    );\n  const r0 =\n    w *\n    (x *\n      addWithCancellationCheck(A[Matrix3.COLUMN2ROW0], A[Matrix3.COLUMN0ROW2]) +\n      b.z);\n\n  let cosines;\n  const solutions = [];\n  if (r0 === 0.0 && r1 === 0.0) {\n    cosines = QuadraticRealPolynomial.computeRealRoots(l2, l1, l0);\n    if (cosines.length === 0) {\n      return solutions;\n    }\n\n    const cosine0 = cosines[0];\n    const sine0 = Math.sqrt(Math.max(1.0 - cosine0 * cosine0, 0.0));\n    solutions.push(new Cartesian3(x, w * cosine0, w * -sine0));\n    solutions.push(new Cartesian3(x, w * cosine0, w * sine0));\n\n    if (cosines.length === 2) {\n      const cosine1 = cosines[1];\n      const sine1 = Math.sqrt(Math.max(1.0 - cosine1 * cosine1, 0.0));\n      solutions.push(new Cartesian3(x, w * cosine1, w * -sine1));\n      solutions.push(new Cartesian3(x, w * cosine1, w * sine1));\n    }\n\n    return solutions;\n  }\n\n  const r0Squared = r0 * r0;\n  const r1Squared = r1 * r1;\n  const l2Squared = l2 * l2;\n  const r0r1 = r0 * r1;\n\n  const c4 = l2Squared + r1Squared;\n  const c3 = 2.0 * (l1 * l2 + r0r1);\n  const c2 = 2.0 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;\n  const c1 = 2.0 * (l0 * l1 - r0r1);\n  const c0 = l0 * l0 - r0Squared;\n\n  if (c4 === 0.0 && c3 === 0.0 && c2 === 0.0 && c1 === 0.0) {\n    return solutions;\n  }\n\n  cosines = QuarticRealPolynomial.computeRealRoots(c4, c3, c2, c1, c0);\n  const length = cosines.length;\n  if (length === 0) {\n    return solutions;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    const cosine = cosines[i];\n    const cosineSquared = cosine * cosine;\n    const sineSquared = Math.max(1.0 - cosineSquared, 0.0);\n    const sine = Math.sqrt(sineSquared);\n\n    //const left = l2 * cosineSquared + l1 * cosine + l0;\n    let left;\n    if (CesiumMath.sign(l2) === CesiumMath.sign(l0)) {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared + l0,\n        l1 * cosine,\n        CesiumMath.EPSILON12,\n      );\n    } else if (CesiumMath.sign(l0) === CesiumMath.sign(l1 * cosine)) {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared,\n        l1 * cosine + l0,\n        CesiumMath.EPSILON12,\n      );\n    } else {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared + l1 * cosine,\n        l0,\n        CesiumMath.EPSILON12,\n      );\n    }\n\n    const right = addWithCancellationCheck(\n      r1 * cosine,\n      r0,\n      CesiumMath.EPSILON15,\n    );\n    const product = left * right;\n\n    if (product < 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n    } else if (product > 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * -sine));\n    } else if (sine !== 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * -sine));\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n      ++i;\n    } else {\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n    }\n  }\n\n  return solutions;\n};\n\nconst firstAxisScratch = new Cartesian3();\nconst secondAxisScratch = new Cartesian3();\nconst thirdAxisScratch = new Cartesian3();\nconst referenceScratch = new Cartesian3();\nconst bCart = new Cartesian3();\nconst bScratch = new Matrix3();\nconst btScratch = new Matrix3();\nconst diScratch = new Matrix3();\nconst dScratch = new Matrix3();\nconst cScratch = new Matrix3();\nconst tempMatrix = new Matrix3();\nconst aScratch = new Matrix3();\nconst sScratch = new Cartesian3();\nconst closestScratch = new Cartesian3();\nconst surfPointScratch = new Cartographic();\n\n/**\n * Provides the point along the ray which is nearest to the ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Cartesian3} The nearest planetodetic point on the ray.\n */\nIntersectionTests.grazingAltitudeLocation = function (ray, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(ellipsoid)) {\n    throw new DeveloperError(\"ellipsoid is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const position = ray.origin;\n  const direction = ray.direction;\n\n  if (!Cartesian3.equals(position, Cartesian3.ZERO)) {\n    const normal = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);\n    if (Cartesian3.dot(direction, normal) >= 0.0) {\n      // The location provided is the closest point in altitude\n      return position;\n    }\n  }\n\n  const intersects = defined(this.rayEllipsoid(ray, ellipsoid));\n\n  // Compute the scaled direction vector.\n  const f = ellipsoid.transformPositionToScaledSpace(\n    direction,\n    firstAxisScratch,\n  );\n\n  // Constructs a basis from the unit scaled direction vector. Construct its rotation and transpose.\n  const firstAxis = Cartesian3.normalize(f, f);\n  const reference = Cartesian3.mostOrthogonalAxis(f, referenceScratch);\n  const secondAxis = Cartesian3.normalize(\n    Cartesian3.cross(reference, firstAxis, secondAxisScratch),\n    secondAxisScratch,\n  );\n  const thirdAxis = Cartesian3.normalize(\n    Cartesian3.cross(firstAxis, secondAxis, thirdAxisScratch),\n    thirdAxisScratch,\n  );\n  const B = bScratch;\n  B[0] = firstAxis.x;\n  B[1] = firstAxis.y;\n  B[2] = firstAxis.z;\n  B[3] = secondAxis.x;\n  B[4] = secondAxis.y;\n  B[5] = secondAxis.z;\n  B[6] = thirdAxis.x;\n  B[7] = thirdAxis.y;\n  B[8] = thirdAxis.z;\n\n  const B_T = Matrix3.transpose(B, btScratch);\n\n  // Get the scaling matrix and its inverse.\n  const D_I = Matrix3.fromScale(ellipsoid.radii, diScratch);\n  const D = Matrix3.fromScale(ellipsoid.oneOverRadii, dScratch);\n\n  const C = cScratch;\n  C[0] = 0.0;\n  C[1] = -direction.z;\n  C[2] = direction.y;\n  C[3] = direction.z;\n  C[4] = 0.0;\n  C[5] = -direction.x;\n  C[6] = -direction.y;\n  C[7] = direction.x;\n  C[8] = 0.0;\n\n  const temp = Matrix3.multiply(\n    Matrix3.multiply(B_T, D, tempMatrix),\n    C,\n    tempMatrix,\n  );\n  const A = Matrix3.multiply(\n    Matrix3.multiply(temp, D_I, aScratch),\n    B,\n    aScratch,\n  );\n  const b = Matrix3.multiplyByVector(temp, position, bCart);\n\n  // Solve for the solutions to the expression in standard form:\n  const solutions = IntersectionTests.quadraticVectorExpression(\n    A,\n    Cartesian3.negate(b, firstAxisScratch),\n    0.0,\n    0.0,\n    1.0,\n  );\n\n  let s;\n  let altitude;\n  const length = solutions.length;\n  if (length > 0) {\n    let closest = Cartesian3.clone(Cartesian3.ZERO, closestScratch);\n    let maximumValue = Number.NEGATIVE_INFINITY;\n\n    for (let i = 0; i < length; ++i) {\n      s = Matrix3.multiplyByVector(\n        D_I,\n        Matrix3.multiplyByVector(B, solutions[i], sScratch),\n        sScratch,\n      );\n      const v = Cartesian3.normalize(\n        Cartesian3.subtract(s, position, referenceScratch),\n        referenceScratch,\n      );\n      const dotProduct = Cartesian3.dot(v, direction);\n\n      if (dotProduct > maximumValue) {\n        maximumValue = dotProduct;\n        closest = Cartesian3.clone(s, closest);\n      }\n    }\n\n    const surfacePoint = ellipsoid.cartesianToCartographic(\n      closest,\n      surfPointScratch,\n    );\n    maximumValue = CesiumMath.clamp(maximumValue, 0.0, 1.0);\n    altitude =\n      Cartesian3.magnitude(\n        Cartesian3.subtract(closest, position, referenceScratch),\n      ) * Math.sqrt(1.0 - maximumValue * maximumValue);\n    altitude = intersects ? -altitude : altitude;\n    surfacePoint.height = altitude;\n    return ellipsoid.cartographicToCartesian(surfacePoint, new Cartesian3());\n  }\n\n  return undefined;\n};\n\nconst lineSegmentPlaneDifference = new Cartesian3();\n\n/**\n * Computes the intersection of a line segment and a plane.\n *\n * @param {Cartesian3} endPoint0 An end point of the line segment.\n * @param {Cartesian3} endPoint1 The other end point of the line segment.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersection.\n *\n * @example\n * const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * const normal = ellipsoid.geodeticSurfaceNormal(origin);\n * const plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * const p0 = new Cesium.Cartesian3(...);\n * const p1 = new Cesium.Cartesian3(...);\n *\n * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.\n * const intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);\n */\nIntersectionTests.lineSegmentPlane = function (\n  endPoint0,\n  endPoint1,\n  plane,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(endPoint0)) {\n    throw new DeveloperError(\"endPoint0 is required.\");\n  }\n  if (!defined(endPoint1)) {\n    throw new DeveloperError(\"endPoint1 is required.\");\n  }\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const difference = Cartesian3.subtract(\n    endPoint1,\n    endPoint0,\n    lineSegmentPlaneDifference,\n  );\n  const normal = plane.normal;\n  const nDotDiff = Cartesian3.dot(normal, difference);\n\n  // check if the segment and plane are parallel\n  if (Math.abs(nDotDiff) < CesiumMath.EPSILON6) {\n    return undefined;\n  }\n\n  const nDotP0 = Cartesian3.dot(normal, endPoint0);\n  const t = -(plane.distance + nDotP0) / nDotDiff;\n\n  // intersection only if t is in [0, 1]\n  if (t < 0.0 || t > 1.0) {\n    return undefined;\n  }\n\n  // intersection is endPoint0 + t * (endPoint1 - endPoint0)\n  Cartesian3.multiplyByScalar(difference, t, result);\n  Cartesian3.add(endPoint0, result, result);\n  return result;\n};\n\n/**\n * Computes the intersection of a triangle and a plane\n *\n * @param {Cartesian3} p0 First point of the triangle\n * @param {Cartesian3} p1 Second point of the triangle\n * @param {Cartesian3} p2 Third point of the triangle\n * @param {Plane} plane Intersection plane\n * @returns {object} An object with properties <code>positions</code> and <code>indices</code>, which are arrays that represent three triangles that do not cross the plane. (Undefined if no intersection exists)\n *\n * @example\n * const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * const normal = ellipsoid.geodeticSurfaceNormal(origin);\n * const plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * const p0 = new Cesium.Cartesian3(...);\n * const p1 = new Cesium.Cartesian3(...);\n * const p2 = new Cesium.Cartesian3(...);\n *\n * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane\n * const triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);\n */\nIntersectionTests.trianglePlaneIntersection = function (p0, p1, p2, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(p0) || !defined(p1) || !defined(p2) || !defined(plane)) {\n    throw new DeveloperError(\"p0, p1, p2, and plane are required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planeNormal = plane.normal;\n  const planeD = plane.distance;\n  const p0Behind = Cartesian3.dot(planeNormal, p0) + planeD < 0.0;\n  const p1Behind = Cartesian3.dot(planeNormal, p1) + planeD < 0.0;\n  const p2Behind = Cartesian3.dot(planeNormal, p2) + planeD < 0.0;\n  // Given these dots products, the calls to lineSegmentPlaneIntersection\n  // always have defined results.\n\n  let numBehind = 0;\n  numBehind += p0Behind ? 1 : 0;\n  numBehind += p1Behind ? 1 : 0;\n  numBehind += p2Behind ? 1 : 0;\n\n  let u1, u2;\n  if (numBehind === 1 || numBehind === 2) {\n    u1 = new Cartesian3();\n    u2 = new Cartesian3();\n  }\n\n  if (numBehind === 1) {\n    if (p0Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          0, 3, 4,\n\n          // In front\n          1, 2, 4, 1, 4, 3,\n        ],\n      };\n    } else if (p1Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          1, 3, 4,\n\n          // In front\n          2, 0, 4, 2, 4, 3,\n        ],\n      };\n    } else if (p2Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          2, 3, 4,\n\n          // In front\n          0, 1, 4, 0, 4, 3,\n        ],\n      };\n    }\n  } else if (numBehind === 2) {\n    if (!p0Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          1, 2, 4, 1, 4, 3,\n\n          // In front\n          0, 3, 4,\n        ],\n      };\n    } else if (!p1Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          2, 0, 4, 2, 4, 3,\n\n          // In front\n          1, 3, 4,\n        ],\n      };\n    } else if (!p2Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          0, 1, 4, 0, 4, 3,\n\n          // In front\n          2, 3, 4,\n        ],\n      };\n    }\n  }\n\n  // if numBehind is 3, the triangle is completely behind the plane;\n  // otherwise, it is completely in front (numBehind is 0).\n  return undefined;\n};\nexport default IntersectionTests;\n"],"names":["IntersectionTests","rayPlane","ray","plane","result","origin","direction","normal","denominator","dot","Math","abs","EPSILON15","undefined","t","distance","multiplyByScalar","add","scratchEdge0","scratchEdge1","scratchPVec","scratchTVec","scratchQVec","rayTriangleParametric","p0","p1","p2","cullBackFaces","edge0","subtract","edge1","p","cross","det","tvec","q","u","v","EPSILON6","invDet","rayTriangle","scratchLineSegmentTriangleRay","lineSegmentTriangle","v0","v1","clone","normalize","solveQuadratic","a","b","c","denom","disc","sqrt","root0","root1","root","raySphereRoots","raySphere","sphere","center","radiusSquared","radius","diff","magnitudeSquared","roots","start","stop","max","scratchLineSegmentRay","lineSegmentSphere","maxT","magnitude","min","scratchQ","scratchW","rayEllipsoid","ellipsoid","inverseRadii","oneOverRadii","multiplyComponents","w","q2","qw","difference","w2","product","discriminant","temp","qw2","scratchRayIntervalX","scratchRayIntervalY","scratchRayIntervalZ","rayAxisAlignedBoundingBox","box","tx","rayIntervalAlongAABBAxis","x","minimum","maximum","ty","y","tz","z","tmp","addWithCancellationCheck","left","right","tolerance","sign","quadraticVectorExpression","A","xSquared","wSquared","l2","COLUMN1ROW1","COLUMN2ROW2","l1","COLUMN1ROW0","COLUMN0ROW1","l0","COLUMN0ROW0","r1","COLUMN2ROW1","COLUMN1ROW2","r0","COLUMN2ROW0","COLUMN0ROW2","cosines","solutions","computeRealRoots","length","cosine0","sine0","push","cosine1","sine1","r0Squared","r1Squared","l2Squared","r0r1","c4","c3","c2","c1","c0","i","cosine","cosineSquared","sineSquared","sine","EPSILON12","firstAxisScratch","secondAxisScratch","thirdAxisScratch","referenceScratch","bCart","bScratch","btScratch","diScratch","dScratch","cScratch","tempMatrix","aScratch","sScratch","closestScratch","surfPointScratch","grazingAltitudeLocation","position","equals","ZERO","geodeticSurfaceNormal","intersects","f","transformPositionToScaledSpace","firstAxis","reference","mostOrthogonalAxis","secondAxis","thirdAxis","B","B_T","transpose","D_I","fromScale","radii","D","C","multiply","multiplyByVector","negate","s","altitude","closest","maximumValue","Number","NEGATIVE_INFINITY","dotProduct","surfacePoint","cartesianToCartographic","clamp","height","cartographicToCartesian","lineSegmentPlaneDifference","lineSegmentPlane","endPoint0","endPoint1","nDotDiff","nDotP0","trianglePlaneIntersection","planeNormal","planeD","p0Behind","p1Behind","p2Behind","numBehind","u1","u2","positions","indices"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 23303, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Plane.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * A plane in Hessian Normal Form defined by\n * <pre>\n * ax + by + cz + d = 0\n * </pre>\n * where (a, b, c) is the plane's <code>normal</code>, d is the signed\n * <code>distance</code> to the plane, and (x, y, z) is any point on\n * the plane.\n *\n * @alias Plane\n * @constructor\n *\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {number} distance The shortest distance from the origin to the plane.  The sign of\n * <code>distance</code> determines which side of the plane the origin\n * is on.  If <code>distance</code> is positive, the origin is in the half-space\n * in the direction of the normal; if negative, the origin is in the half-space\n * opposite to the normal; if zero, the plane passes through the origin.\n *\n * @example\n * // The plane x=0\n * const plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nfunction Plane(normal, distance) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"normal\", normal);\n  if (\n    !CesiumMath.equalsEpsilon(\n      Cartesian3.magnitude(normal),\n      1.0,\n      CesiumMath.EPSILON6,\n    )\n  ) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  Check.typeOf.number(\"distance\", distance);\n  //>>includeEnd('debug');\n\n  /**\n   * The plane's normal.\n   *\n   * @type {Cartesian3}\n   */\n  this.normal = Cartesian3.clone(normal);\n\n  /**\n   * The shortest distance from the origin to the plane.  The sign of\n   * <code>distance</code> determines which side of the plane the origin\n   * is on.  If <code>distance</code> is positive, the origin is in the half-space\n   * in the direction of the normal; if negative, the origin is in the half-space\n   * opposite to the normal; if zero, the plane passes through the origin.\n   *\n   * @type {number}\n   */\n  this.distance = distance;\n}\n\n/**\n * Creates a plane from a normal and a point on the plane.\n *\n * @param {Cartesian3} point The point on the plane.\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} A new plane instance or the modified result parameter.\n *\n * @example\n * const point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * const normal = ellipsoid.geodeticSurfaceNormal(point);\n * const tangentPlane = Cesium.Plane.fromPointNormal(point, normal);\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nPlane.fromPointNormal = function (point, normal, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"point\", point);\n  Check.typeOf.object(\"normal\", normal);\n  if (\n    !CesiumMath.equalsEpsilon(\n      Cartesian3.magnitude(normal),\n      1.0,\n      CesiumMath.EPSILON6,\n    )\n  ) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  const distance = -Cartesian3.dot(normal, point);\n\n  if (!defined(result)) {\n    return new Plane(normal, distance);\n  }\n\n  Cartesian3.clone(normal, result.normal);\n  result.distance = distance;\n  return result;\n};\n\nconst scratchNormal = new Cartesian3();\n/**\n * Creates a plane from the general equation\n *\n * @param {Cartesian4} coefficients The plane's normal (normalized).\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} A new plane instance or the modified result parameter.\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nPlane.fromCartesian4 = function (coefficients, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"coefficients\", coefficients);\n  //>>includeEnd('debug');\n\n  const normal = Cartesian3.fromCartesian4(coefficients, scratchNormal);\n  const distance = coefficients.w;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !CesiumMath.equalsEpsilon(\n      Cartesian3.magnitude(normal),\n      1.0,\n      CesiumMath.EPSILON6,\n    )\n  ) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Plane(normal, distance);\n  }\n  Cartesian3.clone(normal, result.normal);\n  result.distance = distance;\n  return result;\n};\n\n/**\n * Computes the signed shortest distance of a point to a plane.\n * The sign of the distance determines which side of the plane the point\n * is on.  If the distance is positive, the point is in the half-space\n * in the direction of the normal; if negative, the point is in the half-space\n * opposite to the normal; if zero, the plane passes through the point.\n *\n * @param {Plane} plane The plane.\n * @param {Cartesian3} point The point.\n * @returns {number} The signed shortest distance of the point to the plane.\n */\nPlane.getPointDistance = function (plane, point) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  return Cartesian3.dot(plane.normal, point) + plane.distance;\n};\n\nconst scratchCartesian = new Cartesian3();\n/**\n * Projects a point onto the plane.\n * @param {Plane} plane The plane to project the point onto\n * @param {Cartesian3} point The point to project onto the plane\n * @param {Cartesian3} [result] The result point.  If undefined, a new Cartesian3 will be created.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nPlane.projectPointOntoPlane = function (plane, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  // projectedPoint = point - (normal.point + scale) * normal\n  const pointDistance = Plane.getPointDistance(plane, point);\n  const scaledNormal = Cartesian3.multiplyByScalar(\n    plane.normal,\n    pointDistance,\n    scratchCartesian,\n  );\n\n  return Cartesian3.subtract(point, scaledNormal, result);\n};\n\nconst scratchInverseTranspose = new Matrix4();\nconst scratchPlaneCartesian4 = new Cartesian4();\nconst scratchTransformNormal = new Cartesian3();\n/**\n * Transforms the plane by the given transformation matrix.\n *\n * @param {Plane} plane The plane.\n * @param {Matrix4} transform The transformation matrix.\n * @param {Plane} [result] The object into which to store the result.\n * @returns {Plane} The plane transformed by the given transformation matrix.\n */\nPlane.transform = function (plane, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  const normal = plane.normal;\n  const distance = plane.distance;\n  const inverseTranspose = Matrix4.inverseTranspose(\n    transform,\n    scratchInverseTranspose,\n  );\n  let planeAsCartesian4 = Cartesian4.fromElements(\n    normal.x,\n    normal.y,\n    normal.z,\n    distance,\n    scratchPlaneCartesian4,\n  );\n  planeAsCartesian4 = Matrix4.multiplyByVector(\n    inverseTranspose,\n    planeAsCartesian4,\n    planeAsCartesian4,\n  );\n\n  // Convert the transformed plane to Hessian Normal Form\n  const transformedNormal = Cartesian3.fromCartesian4(\n    planeAsCartesian4,\n    scratchTransformNormal,\n  );\n\n  planeAsCartesian4 = Cartesian4.divideByScalar(\n    planeAsCartesian4,\n    Cartesian3.magnitude(transformedNormal),\n    planeAsCartesian4,\n  );\n\n  return Plane.fromCartesian4(planeAsCartesian4, result);\n};\n\n/**\n * Duplicates a Plane instance.\n *\n * @param {Plane} plane The plane to duplicate.\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} The modified result parameter or a new Plane instance if one was not provided.\n */\nPlane.clone = function (plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Plane(plane.normal, plane.distance);\n  }\n\n  Cartesian3.clone(plane.normal, result.normal);\n  result.distance = plane.distance;\n\n  return result;\n};\n\n/**\n * Compares the provided Planes by normal and distance and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Plane} left The first plane.\n * @param {Plane} right The second plane.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nPlane.equals = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.distance === right.distance &&\n    Cartesian3.equals(left.normal, right.normal)\n  );\n};\n\n/**\n * A constant initialized to the XY plane passing through the origin, with normal in positive Z.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_XY_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Z, 0.0));\n\n/**\n * A constant initialized to the YZ plane passing through the origin, with normal in positive X.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_YZ_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_X, 0.0));\n\n/**\n * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_ZX_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Y, 0.0));\nexport default Plane;\n"],"names":["Plane","normal","distance","typeOf","object","equalsEpsilon","magnitude","EPSILON6","number","clone","fromPointNormal","point","result","dot","scratchNormal","fromCartesian4","coefficients","w","getPointDistance","plane","scratchCartesian","projectPointOntoPlane","pointDistance","scaledNormal","multiplyByScalar","subtract","scratchInverseTranspose","scratchPlaneCartesian4","scratchTransformNormal","transform","inverseTranspose","planeAsCartesian4","fromElements","x","y","z","multiplyByVector","transformedNormal","divideByScalar","equals","left","right","ORIGIN_XY_PLANE","Object","freeze","UNIT_Z","ORIGIN_YZ_PLANE","UNIT_X","ORIGIN_ZX_PLANE","UNIT_Y"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 23541, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/WebMercatorProjection.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * The map projection used by Google Maps, Bing Maps, and most of ArcGIS Online, EPSG:3857.  This\n * projection use longitude and latitude expressed with the WGS84 and transforms them to Mercator using\n * the spherical (rather than ellipsoidal) equations.\n *\n * @alias WebMercatorProjection\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n *\n * @see GeographicProjection\n */\nfunction WebMercatorProjection(ellipsoid) {\n  this._ellipsoid = ellipsoid ?? Ellipsoid.WGS84;\n  this._semimajorAxis = this._ellipsoid.maximumRadius;\n  this._oneOverSemimajorAxis = 1.0 / this._semimajorAxis;\n}\n\nObject.defineProperties(WebMercatorProjection.prototype, {\n  /**\n   * Gets the {@link Ellipsoid}.\n   *\n   * @memberof WebMercatorProjection.prototype\n   *\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n});\n\n/**\n * Converts a Mercator angle, in the range -PI to PI, to a geodetic latitude\n * in the range -PI/2 to PI/2.\n *\n * @param {number} mercatorAngle The angle to convert.\n * @returns {number} The geodetic latitude in radians.\n */\nWebMercatorProjection.mercatorAngleToGeodeticLatitude = function (\n  mercatorAngle,\n) {\n  return CesiumMath.PI_OVER_TWO - 2.0 * Math.atan(Math.exp(-mercatorAngle));\n};\n\n/**\n * Converts a geodetic latitude in radians, in the range -PI/2 to PI/2, to a Mercator\n * angle in the range -PI to PI.\n *\n * @param {number} latitude The geodetic latitude in radians.\n * @returns {number} The Mercator angle.\n */\nWebMercatorProjection.geodeticLatitudeToMercatorAngle = function (latitude) {\n  // Clamp the latitude coordinate to the valid Mercator bounds.\n  if (latitude > WebMercatorProjection.MaximumLatitude) {\n    latitude = WebMercatorProjection.MaximumLatitude;\n  } else if (latitude < -WebMercatorProjection.MaximumLatitude) {\n    latitude = -WebMercatorProjection.MaximumLatitude;\n  }\n  const sinLatitude = Math.sin(latitude);\n  return 0.5 * Math.log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n};\n\n/**\n * The maximum latitude (both North and South) supported by a Web Mercator\n * (EPSG:3857) projection.  Technically, the Mercator projection is defined\n * for any latitude up to (but not including) 90 degrees, but it makes sense\n * to cut it off sooner because it grows exponentially with increasing latitude.\n * The logic behind this particular cutoff value, which is the one used by\n * Google Maps, Bing Maps, and Esri, is that it makes the projection\n * square.  That is, the rectangle is equal in the X and Y directions.\n *\n * The constant value is computed by calling:\n *    WebMercatorProjection.mercatorAngleToGeodeticLatitude(Math.PI)\n *\n * @type {number}\n */\nWebMercatorProjection.MaximumLatitude =\n  WebMercatorProjection.mercatorAngleToGeodeticLatitude(Math.PI);\n\n/**\n * Converts geodetic ellipsoid coordinates, in radians, to the equivalent Web Mercator\n * X, Y, Z coordinates expressed in meters and returned in a {@link Cartesian3}.  The height\n * is copied unmodified to the Z coordinate.\n *\n * @param {Cartographic} cartographic The cartographic coordinates in radians.\n * @param {Cartesian3} [result] The instance to which to copy the result, or undefined if a\n *        new instance should be created.\n * @returns {Cartesian3} The equivalent web mercator X, Y, Z coordinates, in meters.\n */\nWebMercatorProjection.prototype.project = function (cartographic, result) {\n  const semimajorAxis = this._semimajorAxis;\n  const x = cartographic.longitude * semimajorAxis;\n  const y =\n    WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n      cartographic.latitude,\n    ) * semimajorAxis;\n  const z = cartographic.height;\n\n  if (!defined(result)) {\n    return new Cartesian3(x, y, z);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Converts Web Mercator X, Y coordinates, expressed in meters, to a {@link Cartographic}\n * containing geodetic ellipsoid coordinates.  The Z coordinate is copied unmodified to the\n * height.\n *\n * @param {Cartesian3} cartesian The web mercator Cartesian position to unrproject with height (z) in meters.\n * @param {Cartographic} [result] The instance to which to copy the result, or undefined if a\n *        new instance should be created.\n * @returns {Cartographic} The equivalent cartographic coordinates.\n */\nWebMercatorProjection.prototype.unproject = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required\");\n  }\n  //>>includeEnd('debug');\n\n  const oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;\n  const longitude = cartesian.x * oneOverEarthSemimajorAxis;\n  const latitude = WebMercatorProjection.mercatorAngleToGeodeticLatitude(\n    cartesian.y * oneOverEarthSemimajorAxis,\n  );\n  const height = cartesian.z;\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\nexport default WebMercatorProjection;\n"],"names":["WebMercatorProjection","ellipsoid","_ellipsoid","WGS84","_semimajorAxis","maximumRadius","_oneOverSemimajorAxis","Object","defineProperties","prototype","get","mercatorAngleToGeodeticLatitude","mercatorAngle","PI_OVER_TWO","Math","atan","exp","geodeticLatitudeToMercatorAngle","latitude","MaximumLatitude","sinLatitude","sin","log","PI","project","cartographic","result","semimajorAxis","x","longitude","y","z","height","unproject","cartesian","oneOverEarthSemimajorAxis"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEA;;;;;;;;;;;CAWC,GACD,SAASA,sBAAsBC,SAAS;IACtC,IAAI,CAACC,UAAU,GAAGD,aAAa,+KAAS,CAACE,KAAK;IAC9C,IAAI,CAACC,cAAc,GAAG,IAAI,CAACF,UAAU,CAACG,aAAa;IACnD,IAAI,CAACC,qBAAqB,GAAG,MAAM,IAAI,CAACF,cAAc;AACxD;AAEAG,OAAOC,gBAAgB,CAACR,sBAAsBS,SAAS,EAAE;IACvD;;;;;;;GAOC,GACDR,WAAW;QACTS,KAAK;YACH,OAAO,IAAI,CAACR,UAAU;QACxB;IACF;AACF;AAEA;;;;;;CAMC,GACDF,sBAAsBW,+BAA+B,GAAG,SACtDC,aAAa;IAEb,OAAO,0KAAU,CAACC,WAAW,GAAG,MAAMC,KAAKC,IAAI,CAACD,KAAKE,GAAG,CAAC,CAACJ;AAC5D;AAEA;;;;;;CAMC,GACDZ,sBAAsBiB,+BAA+B,GAAG,SAAUC,QAAQ;IACxE,8DAA8D;IAC9D,IAAIA,WAAWlB,sBAAsBmB,eAAe,EAAE;QACpDD,WAAWlB,sBAAsBmB,eAAe;IAClD,OAAO,IAAID,WAAW,CAAClB,sBAAsBmB,eAAe,EAAE;QAC5DD,WAAW,CAAClB,sBAAsBmB,eAAe;IACnD;IACA,MAAMC,cAAcN,KAAKO,GAAG,CAACH;IAC7B,OAAO,MAAMJ,KAAKQ,GAAG,CAAC,CAAC,MAAMF,WAAW,IAAI,CAAC,MAAMA,WAAW;AAChE;AAEA;;;;;;;;;;;;;CAaC,GACDpB,sBAAsBmB,eAAe,GACnCnB,sBAAsBW,+BAA+B,CAACG,KAAKS,EAAE;AAE/D;;;;;;;;;CASC,GACDvB,sBAAsBS,SAAS,CAACe,OAAO,GAAG,SAAUC,YAAY,EAAEC,MAAM;IACtE,MAAMC,gBAAgB,IAAI,CAACvB,cAAc;IACzC,MAAMwB,IAAIH,aAAaI,SAAS,GAAGF;IACnC,MAAMG,IACJ9B,sBAAsBiB,+BAA+B,CACnDQ,aAAaP,QAAQ,IACnBS;IACN,MAAMI,IAAIN,aAAaO,MAAM;IAE7B,IAAI,CAAC,IAAA,6KAAO,EAACN,SAAS;QACpB,OAAO,IAAI,gLAAU,CAACE,GAAGE,GAAGC;IAC9B;IAEAL,OAAOE,CAAC,GAAGA;IACXF,OAAOI,CAAC,GAAGA;IACXJ,OAAOK,CAAC,GAAGA;IACX,OAAOL;AACT;AAEA;;;;;;;;;CASC,GACD1B,sBAAsBS,SAAS,CAACwB,SAAS,GAAG,SAAUC,SAAS,EAAER,MAAM;IACrE,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACQ,YAAY;QACvB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAMC,4BAA4B,IAAI,CAAC7B,qBAAqB;IAC5D,MAAMuB,YAAYK,UAAUN,CAAC,GAAGO;IAChC,MAAMjB,WAAWlB,sBAAsBW,+BAA+B,CACpEuB,UAAUJ,CAAC,GAAGK;IAEhB,MAAMH,SAASE,UAAUH,CAAC;IAE1B,IAAI,CAAC,IAAA,6KAAO,EAACL,SAAS;QACpB,OAAO,IAAI,kLAAY,CAACG,WAAWX,UAAUc;IAC/C;IAEAN,OAAOG,SAAS,GAAGA;IACnBH,OAAOR,QAAQ,GAAGA;IAClBQ,OAAOM,MAAM,GAAGA;IAChB,OAAON;AACT;uCACe1B","ignoreList":[0]}},
    {"offset": {"line": 23680, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/GroundPolylineGeometry.js"],"sourcesContent":["import ApproximateTerrainHeights from \"./ApproximateTerrainHeights.js\";\nimport ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Plane from \"./Plane.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\n\nconst PROJECTIONS = [GeographicProjection, WebMercatorProjection];\nconst PROJECTION_COUNT = PROJECTIONS.length;\n\nconst MITER_BREAK_SMALL = Math.cos(CesiumMath.toRadians(30.0));\nconst MITER_BREAK_LARGE = Math.cos(CesiumMath.toRadians(150.0));\n\n// Initial heights for constructing the wall.\n// Keeping WALL_INITIAL_MIN_HEIGHT near the ellipsoid surface helps\n// prevent precision problems with planes in the shader.\n// Putting the start point of a plane at ApproximateTerrainHeights._defaultMinTerrainHeight,\n// which is a highly conservative bound, usually puts the plane origin several thousands\n// of meters away from the actual terrain, causing floating point problems when checking\n// fragments on terrain against the plane.\n// Ellipsoid height is generally much closer.\n// The initial max height is arbitrary.\n// Both heights are corrected using ApproximateTerrainHeights for computing the actual volume geometry.\nconst WALL_INITIAL_MIN_HEIGHT = 0.0;\nconst WALL_INITIAL_MAX_HEIGHT = 1000.0;\n\n/**\n * A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.\n *\n * @alias GroundPolylineGeometry\n * @constructor\n *\n * @param {object} options Options with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.\n * @param {number} [options.width=1.0] The screen space width in pixels.\n * @param {number} [options.granularity=9999.0] The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.\n * @param {boolean} [options.loop=false] Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @exception {DeveloperError} At least two positions are required.\n *\n * @see GroundPolylinePrimitive\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -112.1340164450331, 36.05494287836128,\n *   -112.08821010582645, 36.097804071380715,\n *   -112.13296079730024, 36.168769146801104\n * ]);\n *\n * const geometry = new Cesium.GroundPolylineGeometry({\n *   positions : positions\n * });\n */\nfunction GroundPolylineGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const positions = options.positions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (\n    defined(options.arcType) &&\n    options.arcType !== ArcType.GEODESIC &&\n    options.arcType !== ArcType.RHUMB\n  ) {\n    throw new DeveloperError(\n      \"Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The screen space width in pixels.\n   * @type {number}\n   */\n  this.width = options.width ?? 1.0; // Doesn't get packed, not necessary for computing geometry.\n\n  this._positions = positions;\n\n  /**\n   * The distance interval used for interpolating options.points. Zero indicates no interpolation.\n   * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.\n   * @type {boolean}\n   * @default 9999.0\n   */\n  this.granularity = options.granularity ?? 9999.0;\n\n  /**\n   * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n   * If the geometry has two positions this parameter will be ignored.\n   * @type {boolean}\n   * @default false\n   */\n  this.loop = options.loop ?? false;\n\n  /**\n   * The type of path the polyline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n   * @type {ArcType}\n   * @default ArcType.GEODESIC\n   */\n  this.arcType = options.arcType ?? ArcType.GEODESIC;\n\n  this._ellipsoid = Ellipsoid.default;\n\n  // MapProjections can't be packed, so store the index to a known MapProjection.\n  this._projectionIndex = 0;\n  this._workerName = \"createGroundPolylineGeometry\";\n\n  // Used by GroundPolylinePrimitive to signal worker that scenemode is 3D only.\n  this._scene3DOnly = false;\n}\n\nObject.defineProperties(GroundPolylineGeometry.prototype, {\n  /**\n   * The number of elements used to pack the object into an array.\n   * @memberof GroundPolylineGeometry.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  packedLength: {\n    get: function () {\n      return (\n        1.0 +\n        this._positions.length * 3 +\n        1.0 +\n        1.0 +\n        1.0 +\n        Ellipsoid.packedLength +\n        1.0 +\n        1.0\n      );\n    },\n  },\n});\n\n/**\n * Set the GroundPolylineGeometry's projection and ellipsoid.\n * Used by GroundPolylinePrimitive to signal scene information to the geometry for generating 2D attributes.\n *\n * @param {GroundPolylineGeometry} groundPolylineGeometry GroundPolylinGeometry describing a polyline on terrain or 3D Tiles.\n * @param {Projection} mapProjection A MapProjection used for projecting cartographic coordinates to 2D.\n * @private\n */\nGroundPolylineGeometry.setProjectionAndEllipsoid = function (\n  groundPolylineGeometry,\n  mapProjection,\n) {\n  let projectionIndex = 0;\n  for (let i = 0; i < PROJECTION_COUNT; i++) {\n    if (mapProjection instanceof PROJECTIONS[i]) {\n      projectionIndex = i;\n      break;\n    }\n  }\n\n  groundPolylineGeometry._projectionIndex = projectionIndex;\n  groundPolylineGeometry._ellipsoid = mapProjection.ellipsoid;\n};\n\nconst cart3Scratch1 = new Cartesian3();\nconst cart3Scratch2 = new Cartesian3();\nconst cart3Scratch3 = new Cartesian3();\nfunction computeRightNormal(start, end, maxHeight, ellipsoid, result) {\n  const startBottom = getPosition(ellipsoid, start, 0.0, cart3Scratch1);\n  const startTop = getPosition(ellipsoid, start, maxHeight, cart3Scratch2);\n  const endBottom = getPosition(ellipsoid, end, 0.0, cart3Scratch3);\n\n  const up = direction(startTop, startBottom, cart3Scratch2);\n  const forward = direction(endBottom, startBottom, cart3Scratch3);\n\n  Cartesian3.cross(forward, up, result);\n  return Cartesian3.normalize(result, result);\n}\n\nconst interpolatedCartographicScratch = new Cartographic();\nconst interpolatedBottomScratch = new Cartesian3();\nconst interpolatedTopScratch = new Cartesian3();\nconst interpolatedNormalScratch = new Cartesian3();\nfunction interpolateSegment(\n  start,\n  end,\n  minHeight,\n  maxHeight,\n  granularity,\n  arcType,\n  ellipsoid,\n  normalsArray,\n  bottomPositionsArray,\n  topPositionsArray,\n  cartographicsArray,\n) {\n  if (granularity === 0.0) {\n    return;\n  }\n\n  let ellipsoidLine;\n  if (arcType === ArcType.GEODESIC) {\n    ellipsoidLine = new EllipsoidGeodesic(start, end, ellipsoid);\n  } else if (arcType === ArcType.RHUMB) {\n    ellipsoidLine = new EllipsoidRhumbLine(start, end, ellipsoid);\n  }\n\n  const surfaceDistance = ellipsoidLine.surfaceDistance;\n  if (surfaceDistance < granularity) {\n    return;\n  }\n\n  // Compute rightwards normal applicable at all interpolated points\n  const interpolatedNormal = computeRightNormal(\n    start,\n    end,\n    maxHeight,\n    ellipsoid,\n    interpolatedNormalScratch,\n  );\n\n  const segments = Math.ceil(surfaceDistance / granularity);\n  const interpointDistance = surfaceDistance / segments;\n  let distanceFromStart = interpointDistance;\n  const pointsToAdd = segments - 1;\n  let packIndex = normalsArray.length;\n  for (let i = 0; i < pointsToAdd; i++) {\n    const interpolatedCartographic =\n      ellipsoidLine.interpolateUsingSurfaceDistance(\n        distanceFromStart,\n        interpolatedCartographicScratch,\n      );\n    const interpolatedBottom = getPosition(\n      ellipsoid,\n      interpolatedCartographic,\n      minHeight,\n      interpolatedBottomScratch,\n    );\n    const interpolatedTop = getPosition(\n      ellipsoid,\n      interpolatedCartographic,\n      maxHeight,\n      interpolatedTopScratch,\n    );\n\n    Cartesian3.pack(interpolatedNormal, normalsArray, packIndex);\n    Cartesian3.pack(interpolatedBottom, bottomPositionsArray, packIndex);\n    Cartesian3.pack(interpolatedTop, topPositionsArray, packIndex);\n    cartographicsArray.push(interpolatedCartographic.latitude);\n    cartographicsArray.push(interpolatedCartographic.longitude);\n\n    packIndex += 3;\n    distanceFromStart += interpointDistance;\n  }\n}\n\nconst heightlessCartographicScratch = new Cartographic();\nfunction getPosition(ellipsoid, cartographic, height, result) {\n  Cartographic.clone(cartographic, heightlessCartographicScratch);\n  heightlessCartographicScratch.height = height;\n  return Cartographic.toCartesian(\n    heightlessCartographicScratch,\n    ellipsoid,\n    result,\n  );\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nGroundPolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  let index = startingIndex ?? 0;\n\n  const positions = value._positions;\n  const positionsLength = positions.length;\n\n  array[index++] = positionsLength;\n\n  for (let i = 0; i < positionsLength; ++i) {\n    const cartesian = positions[i];\n    Cartesian3.pack(cartesian, array, index);\n    index += 3;\n  }\n\n  array[index++] = value.granularity;\n  array[index++] = value.loop ? 1.0 : 0.0;\n  array[index++] = value.arcType;\n\n  Ellipsoid.pack(value._ellipsoid, array, index);\n  index += Ellipsoid.packedLength;\n\n  array[index++] = value._projectionIndex;\n  array[index++] = value._scene3DOnly ? 1.0 : 0.0;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonGeometry} [result] The object into which to store the result.\n */\nGroundPolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  let index = startingIndex ?? 0;\n  const positionsLength = array[index++];\n  const positions = new Array(positionsLength);\n\n  for (let i = 0; i < positionsLength; i++) {\n    positions[i] = Cartesian3.unpack(array, index);\n    index += 3;\n  }\n\n  const granularity = array[index++];\n  const loop = array[index++] === 1.0;\n  const arcType = array[index++];\n\n  const ellipsoid = Ellipsoid.unpack(array, index);\n  index += Ellipsoid.packedLength;\n\n  const projectionIndex = array[index++];\n  const scene3DOnly = array[index++] === 1.0;\n\n  if (!defined(result)) {\n    result = new GroundPolylineGeometry({\n      positions: positions,\n    });\n  }\n\n  result._positions = positions;\n  result.granularity = granularity;\n  result.loop = loop;\n  result.arcType = arcType;\n  result._ellipsoid = ellipsoid;\n  result._projectionIndex = projectionIndex;\n  result._scene3DOnly = scene3DOnly;\n\n  return result;\n};\n\nfunction direction(target, origin, result) {\n  Cartesian3.subtract(target, origin, result);\n  Cartesian3.normalize(result, result);\n  return result;\n}\n\nfunction tangentDirection(target, origin, up, result) {\n  result = direction(target, origin, result);\n\n  // orthogonalize\n  result = Cartesian3.cross(result, up, result);\n  result = Cartesian3.normalize(result, result);\n  result = Cartesian3.cross(up, result, result);\n  return result;\n}\n\nconst toPreviousScratch = new Cartesian3();\nconst toNextScratch = new Cartesian3();\nconst forwardScratch = new Cartesian3();\nconst vertexUpScratch = new Cartesian3();\nconst cosine90 = 0.0;\nconst cosine180 = -1.0;\nfunction computeVertexMiterNormal(\n  previousBottom,\n  vertexBottom,\n  vertexTop,\n  nextBottom,\n  result,\n) {\n  const up = direction(vertexTop, vertexBottom, vertexUpScratch);\n\n  // Compute vectors pointing towards neighboring points but tangent to this point on the ellipsoid\n  const toPrevious = tangentDirection(\n    previousBottom,\n    vertexBottom,\n    up,\n    toPreviousScratch,\n  );\n  const toNext = tangentDirection(nextBottom, vertexBottom, up, toNextScratch);\n\n  // Check if tangents are almost opposite - if so, no need to miter.\n  if (\n    CesiumMath.equalsEpsilon(\n      Cartesian3.dot(toPrevious, toNext),\n      cosine180,\n      CesiumMath.EPSILON5,\n    )\n  ) {\n    result = Cartesian3.cross(up, toPrevious, result);\n    result = Cartesian3.normalize(result, result);\n    return result;\n  }\n\n  // Average directions to previous and to next in the plane of Up\n  result = Cartesian3.add(toNext, toPrevious, result);\n  result = Cartesian3.normalize(result, result);\n\n  // Flip the normal if it isn't pointing roughly bound right (aka if forward is pointing more \"backwards\")\n  const forward = Cartesian3.cross(up, result, forwardScratch);\n  if (Cartesian3.dot(toNext, forward) < cosine90) {\n    result = Cartesian3.negate(result, result);\n  }\n\n  return result;\n}\n\nconst XZ_PLANE = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\n\nconst previousBottomScratch = new Cartesian3();\nconst vertexBottomScratch = new Cartesian3();\nconst vertexTopScratch = new Cartesian3();\nconst nextBottomScratch = new Cartesian3();\nconst vertexNormalScratch = new Cartesian3();\nconst intersectionScratch = new Cartesian3();\nconst cartographicScratch0 = new Cartographic();\nconst cartographicScratch1 = new Cartographic();\nconst cartographicIntersectionScratch = new Cartographic();\n/**\n * Computes shadow volumes for the ground polyline, consisting of its vertices, indices, and a bounding sphere.\n * Vertices are \"fat,\" packing all the data needed in each volume to describe a line on terrain or 3D Tiles.\n * Should not be called independent of {@link GroundPolylinePrimitive}.\n *\n * @param {GroundPolylineGeometry} groundPolylineGeometry\n * @private\n */\nGroundPolylineGeometry.createGeometry = function (groundPolylineGeometry) {\n  const compute2dAttributes = !groundPolylineGeometry._scene3DOnly;\n  let loop = groundPolylineGeometry.loop;\n  const ellipsoid = groundPolylineGeometry._ellipsoid;\n  const granularity = groundPolylineGeometry.granularity;\n  const arcType = groundPolylineGeometry.arcType;\n  const projection = new PROJECTIONS[groundPolylineGeometry._projectionIndex](\n    ellipsoid,\n  );\n\n  const minHeight = WALL_INITIAL_MIN_HEIGHT;\n  const maxHeight = WALL_INITIAL_MAX_HEIGHT;\n\n  let index;\n  let i;\n\n  const positions = groundPolylineGeometry._positions;\n  const positionsLength = positions.length;\n\n  if (positionsLength === 2) {\n    loop = false;\n  }\n\n  // Split positions across the IDL and the Prime Meridian as well.\n  // Split across prime meridian because very large geometries crossing the Prime Meridian but not the IDL\n  // may get split by the plane of IDL + Prime Meridian.\n  let p0;\n  let p1;\n  let c0;\n  let c1;\n  const rhumbLine = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  let intersection;\n  let intersectionCartographic;\n  let intersectionLongitude;\n  const splitPositions = [positions[0]];\n  for (i = 0; i < positionsLength - 1; i++) {\n    p0 = positions[i];\n    p1 = positions[i + 1];\n    intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      XZ_PLANE,\n      intersectionScratch,\n    );\n    if (\n      defined(intersection) &&\n      !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n      !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n    ) {\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n        splitPositions.push(Cartesian3.clone(intersection));\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n        intersectionLongitude = ellipsoid.cartesianToCartographic(\n          intersection,\n          cartographicScratch0,\n        ).longitude;\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n        rhumbLine.setEndPoints(c0, c1);\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(\n          intersectionLongitude,\n          cartographicIntersectionScratch,\n        );\n        intersection = ellipsoid.cartographicToCartesian(\n          intersectionCartographic,\n          intersectionScratch,\n        );\n        if (\n          defined(intersection) &&\n          !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n          !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n        ) {\n          splitPositions.push(Cartesian3.clone(intersection));\n        }\n      }\n    }\n    splitPositions.push(p1);\n  }\n\n  if (loop) {\n    p0 = positions[positionsLength - 1];\n    p1 = positions[0];\n    intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      XZ_PLANE,\n      intersectionScratch,\n    );\n    if (\n      defined(intersection) &&\n      !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n      !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n    ) {\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n        splitPositions.push(Cartesian3.clone(intersection));\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n        intersectionLongitude = ellipsoid.cartesianToCartographic(\n          intersection,\n          cartographicScratch0,\n        ).longitude;\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n        rhumbLine.setEndPoints(c0, c1);\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(\n          intersectionLongitude,\n          cartographicIntersectionScratch,\n        );\n        intersection = ellipsoid.cartographicToCartesian(\n          intersectionCartographic,\n          intersectionScratch,\n        );\n        if (\n          defined(intersection) &&\n          !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n          !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n        ) {\n          splitPositions.push(Cartesian3.clone(intersection));\n        }\n      }\n    }\n  }\n  let cartographicsLength = splitPositions.length;\n\n  let cartographics = new Array(cartographicsLength);\n  for (i = 0; i < cartographicsLength; i++) {\n    const cartographic = Cartographic.fromCartesian(\n      splitPositions[i],\n      ellipsoid,\n    );\n    cartographic.height = 0.0;\n    cartographics[i] = cartographic;\n  }\n\n  cartographics = arrayRemoveDuplicates(\n    cartographics,\n    Cartographic.equalsEpsilon,\n  );\n  cartographicsLength = cartographics.length;\n\n  if (cartographicsLength < 2) {\n    return undefined;\n  }\n\n  /**** Build heap-side arrays for positions, interpolated cartographics, and normals from which to compute vertices ****/\n  // We build a \"wall\" and then decompose it into separately connected component \"volumes\" because we need a lot\n  // of information about the wall. Also, this simplifies interpolation.\n  // Convention: \"next\" and \"end\" are locally forward to each segment of the wall,\n  // and we are computing normals pointing towards the local right side of the vertices in each segment.\n  const cartographicsArray = [];\n  const normalsArray = [];\n  const bottomPositionsArray = [];\n  const topPositionsArray = [];\n\n  let previousBottom = previousBottomScratch;\n  let vertexBottom = vertexBottomScratch;\n  let vertexTop = vertexTopScratch;\n  let nextBottom = nextBottomScratch;\n  let vertexNormal = vertexNormalScratch;\n\n  // First point - either loop or attach a \"perpendicular\" normal\n  const startCartographic = cartographics[0];\n  const nextCartographic = cartographics[1];\n\n  const prestartCartographic = cartographics[cartographicsLength - 1];\n  previousBottom = getPosition(\n    ellipsoid,\n    prestartCartographic,\n    minHeight,\n    previousBottom,\n  );\n  nextBottom = getPosition(ellipsoid, nextCartographic, minHeight, nextBottom);\n  vertexBottom = getPosition(\n    ellipsoid,\n    startCartographic,\n    minHeight,\n    vertexBottom,\n  );\n  vertexTop = getPosition(ellipsoid, startCartographic, maxHeight, vertexTop);\n\n  if (loop) {\n    vertexNormal = computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal,\n    );\n  } else {\n    vertexNormal = computeRightNormal(\n      startCartographic,\n      nextCartographic,\n      maxHeight,\n      ellipsoid,\n      vertexNormal,\n    );\n  }\n\n  Cartesian3.pack(vertexNormal, normalsArray, 0);\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, 0);\n  Cartesian3.pack(vertexTop, topPositionsArray, 0);\n  cartographicsArray.push(startCartographic.latitude);\n  cartographicsArray.push(startCartographic.longitude);\n\n  interpolateSegment(\n    startCartographic,\n    nextCartographic,\n    minHeight,\n    maxHeight,\n    granularity,\n    arcType,\n    ellipsoid,\n    normalsArray,\n    bottomPositionsArray,\n    topPositionsArray,\n    cartographicsArray,\n  );\n\n  // All inbetween points\n  for (i = 1; i < cartographicsLength - 1; ++i) {\n    previousBottom = Cartesian3.clone(vertexBottom, previousBottom);\n    vertexBottom = Cartesian3.clone(nextBottom, vertexBottom);\n    const vertexCartographic = cartographics[i];\n    getPosition(ellipsoid, vertexCartographic, maxHeight, vertexTop);\n    getPosition(ellipsoid, cartographics[i + 1], minHeight, nextBottom);\n\n    computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal,\n    );\n\n    index = normalsArray.length;\n    Cartesian3.pack(vertexNormal, normalsArray, index);\n    Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n    Cartesian3.pack(vertexTop, topPositionsArray, index);\n    cartographicsArray.push(vertexCartographic.latitude);\n    cartographicsArray.push(vertexCartographic.longitude);\n\n    interpolateSegment(\n      cartographics[i],\n      cartographics[i + 1],\n      minHeight,\n      maxHeight,\n      granularity,\n      arcType,\n      ellipsoid,\n      normalsArray,\n      bottomPositionsArray,\n      topPositionsArray,\n      cartographicsArray,\n    );\n  }\n\n  // Last point - either loop or attach a normal \"perpendicular\" to the wall.\n  const endCartographic = cartographics[cartographicsLength - 1];\n  const preEndCartographic = cartographics[cartographicsLength - 2];\n\n  vertexBottom = getPosition(\n    ellipsoid,\n    endCartographic,\n    minHeight,\n    vertexBottom,\n  );\n  vertexTop = getPosition(ellipsoid, endCartographic, maxHeight, vertexTop);\n\n  if (loop) {\n    const postEndCartographic = cartographics[0];\n    previousBottom = getPosition(\n      ellipsoid,\n      preEndCartographic,\n      minHeight,\n      previousBottom,\n    );\n    nextBottom = getPosition(\n      ellipsoid,\n      postEndCartographic,\n      minHeight,\n      nextBottom,\n    );\n\n    vertexNormal = computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal,\n    );\n  } else {\n    vertexNormal = computeRightNormal(\n      preEndCartographic,\n      endCartographic,\n      maxHeight,\n      ellipsoid,\n      vertexNormal,\n    );\n  }\n\n  index = normalsArray.length;\n  Cartesian3.pack(vertexNormal, normalsArray, index);\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n  Cartesian3.pack(vertexTop, topPositionsArray, index);\n  cartographicsArray.push(endCartographic.latitude);\n  cartographicsArray.push(endCartographic.longitude);\n\n  if (loop) {\n    interpolateSegment(\n      endCartographic,\n      startCartographic,\n      minHeight,\n      maxHeight,\n      granularity,\n      arcType,\n      ellipsoid,\n      normalsArray,\n      bottomPositionsArray,\n      topPositionsArray,\n      cartographicsArray,\n    );\n    index = normalsArray.length;\n    for (i = 0; i < 3; ++i) {\n      normalsArray[index + i] = normalsArray[i];\n      bottomPositionsArray[index + i] = bottomPositionsArray[i];\n      topPositionsArray[index + i] = topPositionsArray[i];\n    }\n    cartographicsArray.push(startCartographic.latitude);\n    cartographicsArray.push(startCartographic.longitude);\n  }\n\n  return generateGeometryAttributes(\n    loop,\n    projection,\n    bottomPositionsArray,\n    topPositionsArray,\n    normalsArray,\n    cartographicsArray,\n    compute2dAttributes,\n  );\n};\n\n// If the end normal angle is too steep compared to the direction of the line segment,\n// \"break\" the miter by rotating the normal 90 degrees around the \"up\" direction at the point\n// For ultra precision we would want to project into a plane, but in practice this is sufficient.\nconst lineDirectionScratch = new Cartesian3();\nconst matrix3Scratch = new Matrix3();\nconst quaternionScratch = new Quaternion();\nfunction breakMiter(endGeometryNormal, startBottom, endBottom, endTop) {\n  const lineDirection = direction(endBottom, startBottom, lineDirectionScratch);\n\n  const dot = Cartesian3.dot(lineDirection, endGeometryNormal);\n  if (dot > MITER_BREAK_SMALL || dot < MITER_BREAK_LARGE) {\n    const vertexUp = direction(endTop, endBottom, vertexUpScratch);\n    const angle =\n      dot < MITER_BREAK_LARGE\n        ? CesiumMath.PI_OVER_TWO\n        : -CesiumMath.PI_OVER_TWO;\n    const quaternion = Quaternion.fromAxisAngle(\n      vertexUp,\n      angle,\n      quaternionScratch,\n    );\n    const rotationMatrix = Matrix3.fromQuaternion(quaternion, matrix3Scratch);\n    Matrix3.multiplyByVector(\n      rotationMatrix,\n      endGeometryNormal,\n      endGeometryNormal,\n    );\n    return true;\n  }\n  return false;\n}\n\nconst endPosCartographicScratch = new Cartographic();\nconst normalStartpointScratch = new Cartesian3();\nconst normalEndpointScratch = new Cartesian3();\nfunction projectNormal(\n  projection,\n  cartographic,\n  normal,\n  projectedPosition,\n  result,\n) {\n  const position = Cartographic.toCartesian(\n    cartographic,\n    projection._ellipsoid,\n    normalStartpointScratch,\n  );\n  let normalEndpoint = Cartesian3.add(position, normal, normalEndpointScratch);\n  let flipNormal = false;\n\n  const ellipsoid = projection._ellipsoid;\n  let normalEndpointCartographic = ellipsoid.cartesianToCartographic(\n    normalEndpoint,\n    endPosCartographicScratch,\n  );\n  // If normal crosses the IDL, go the other way and flip the result.\n  // In practice this almost never happens because the cartographic start\n  // and end points of each segment are \"nudged\" to be on the same side\n  // of the IDL and slightly away from the IDL.\n  if (\n    Math.abs(cartographic.longitude - normalEndpointCartographic.longitude) >\n    CesiumMath.PI_OVER_TWO\n  ) {\n    flipNormal = true;\n    normalEndpoint = Cartesian3.subtract(\n      position,\n      normal,\n      normalEndpointScratch,\n    );\n    normalEndpointCartographic = ellipsoid.cartesianToCartographic(\n      normalEndpoint,\n      endPosCartographicScratch,\n    );\n  }\n\n  normalEndpointCartographic.height = 0.0;\n  const normalEndpointProjected = projection.project(\n    normalEndpointCartographic,\n    result,\n  );\n  result = Cartesian3.subtract(\n    normalEndpointProjected,\n    projectedPosition,\n    result,\n  );\n  result.z = 0.0;\n  result = Cartesian3.normalize(result, result);\n  if (flipNormal) {\n    Cartesian3.negate(result, result);\n  }\n  return result;\n}\n\nconst adjustHeightNormalScratch = new Cartesian3();\nconst adjustHeightOffsetScratch = new Cartesian3();\nfunction adjustHeights(\n  bottom,\n  top,\n  minHeight,\n  maxHeight,\n  adjustHeightBottom,\n  adjustHeightTop,\n) {\n  // bottom and top should be at WALL_INITIAL_MIN_HEIGHT and WALL_INITIAL_MAX_HEIGHT, respectively\n  const adjustHeightNormal = Cartesian3.subtract(\n    top,\n    bottom,\n    adjustHeightNormalScratch,\n  );\n  Cartesian3.normalize(adjustHeightNormal, adjustHeightNormal);\n\n  const distanceForBottom = minHeight - WALL_INITIAL_MIN_HEIGHT;\n  let adjustHeightOffset = Cartesian3.multiplyByScalar(\n    adjustHeightNormal,\n    distanceForBottom,\n    adjustHeightOffsetScratch,\n  );\n  Cartesian3.add(bottom, adjustHeightOffset, adjustHeightBottom);\n\n  const distanceForTop = maxHeight - WALL_INITIAL_MAX_HEIGHT;\n  adjustHeightOffset = Cartesian3.multiplyByScalar(\n    adjustHeightNormal,\n    distanceForTop,\n    adjustHeightOffsetScratch,\n  );\n  Cartesian3.add(top, adjustHeightOffset, adjustHeightTop);\n}\n\nconst nudgeDirectionScratch = new Cartesian3();\nfunction nudgeXZ(start, end) {\n  const startToXZdistance = Plane.getPointDistance(XZ_PLANE, start);\n  const endToXZdistance = Plane.getPointDistance(XZ_PLANE, end);\n  let offset = nudgeDirectionScratch;\n  // Larger epsilon than what's used in GeometryPipeline, a centimeter in world space\n  if (CesiumMath.equalsEpsilon(startToXZdistance, 0.0, CesiumMath.EPSILON2)) {\n    offset = direction(end, start, offset);\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n    Cartesian3.add(start, offset, start);\n  } else if (\n    CesiumMath.equalsEpsilon(endToXZdistance, 0.0, CesiumMath.EPSILON2)\n  ) {\n    offset = direction(start, end, offset);\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n    Cartesian3.add(end, offset, end);\n  }\n}\n\n// \"Nudge\" cartographic coordinates so start and end are on the same side of the IDL.\n// Nudge amounts are tiny, basically just an IDL flip.\n// Only used for 2D/CV.\nfunction nudgeCartographic(start, end) {\n  const absStartLon = Math.abs(start.longitude);\n  const absEndLon = Math.abs(end.longitude);\n  if (\n    CesiumMath.equalsEpsilon(absStartLon, CesiumMath.PI, CesiumMath.EPSILON11)\n  ) {\n    const endSign = CesiumMath.sign(end.longitude);\n    start.longitude = endSign * (absStartLon - CesiumMath.EPSILON11);\n    return 1;\n  } else if (\n    CesiumMath.equalsEpsilon(absEndLon, CesiumMath.PI, CesiumMath.EPSILON11)\n  ) {\n    const startSign = CesiumMath.sign(start.longitude);\n    end.longitude = startSign * (absEndLon - CesiumMath.EPSILON11);\n    return 2;\n  }\n  return 0;\n}\n\nconst startCartographicScratch = new Cartographic();\nconst endCartographicScratch = new Cartographic();\n\nconst segmentStartTopScratch = new Cartesian3();\nconst segmentEndTopScratch = new Cartesian3();\nconst segmentStartBottomScratch = new Cartesian3();\nconst segmentEndBottomScratch = new Cartesian3();\nconst segmentStartNormalScratch = new Cartesian3();\nconst segmentEndNormalScratch = new Cartesian3();\n\nconst getHeightCartographics = [\n  startCartographicScratch,\n  endCartographicScratch,\n];\nconst getHeightRectangleScratch = new Rectangle();\n\nconst adjustHeightStartTopScratch = new Cartesian3();\nconst adjustHeightEndTopScratch = new Cartesian3();\nconst adjustHeightStartBottomScratch = new Cartesian3();\nconst adjustHeightEndBottomScratch = new Cartesian3();\n\nconst segmentStart2DScratch = new Cartesian3();\nconst segmentEnd2DScratch = new Cartesian3();\nconst segmentStartNormal2DScratch = new Cartesian3();\nconst segmentEndNormal2DScratch = new Cartesian3();\n\nconst offsetScratch = new Cartesian3();\nconst startUpScratch = new Cartesian3();\nconst endUpScratch = new Cartesian3();\nconst rightScratch = new Cartesian3();\nconst startPlaneNormalScratch = new Cartesian3();\nconst endPlaneNormalScratch = new Cartesian3();\nconst encodeScratch = new EncodedCartesian3();\n\nconst encodeScratch2D = new EncodedCartesian3();\nconst forwardOffset2DScratch = new Cartesian3();\nconst right2DScratch = new Cartesian3();\n\nconst normalNudgeScratch = new Cartesian3();\n\nconst scratchBoundingSpheres = [new BoundingSphere(), new BoundingSphere()];\n\n// Winding order is reversed so each segment's volume is inside-out\nconst REFERENCE_INDICES = [\n  0,\n  2,\n  1,\n  0,\n  3,\n  2, // right\n  0,\n  7,\n  3,\n  0,\n  4,\n  7, // start\n  0,\n  5,\n  4,\n  0,\n  1,\n  5, // bottom\n  5,\n  7,\n  4,\n  5,\n  6,\n  7, // left\n  5,\n  2,\n  6,\n  5,\n  1,\n  2, // end\n  3,\n  6,\n  2,\n  3,\n  7,\n  6, // top\n];\nconst REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\n\n// Decompose the \"wall\" into a series of shadow volumes.\n// Each shadow volume's vertices encode a description of the line it contains,\n// including mitering planes at the end points, a plane along the line itself,\n// and attributes for computing length-wise texture coordinates.\nfunction generateGeometryAttributes(\n  loop,\n  projection,\n  bottomPositionsArray,\n  topPositionsArray,\n  normalsArray,\n  cartographicsArray,\n  compute2dAttributes,\n) {\n  let i;\n  let index;\n  const ellipsoid = projection._ellipsoid;\n\n  // Each segment will have 8 vertices\n  const segmentCount = bottomPositionsArray.length / 3 - 1;\n  const vertexCount = segmentCount * 8;\n  const arraySizeVec4 = vertexCount * 4;\n  const indexCount = segmentCount * 36;\n\n  const indices =\n    vertexCount > 65535\n      ? new Uint32Array(indexCount)\n      : new Uint16Array(indexCount);\n  const positionsArray = new Float64Array(vertexCount * 3);\n\n  const startHiAndForwardOffsetX = new Float32Array(arraySizeVec4);\n  const startLoAndForwardOffsetY = new Float32Array(arraySizeVec4);\n  const startNormalAndForwardOffsetZ = new Float32Array(arraySizeVec4);\n  const endNormalAndTextureCoordinateNormalizationX = new Float32Array(\n    arraySizeVec4,\n  );\n  const rightNormalAndTextureCoordinateNormalizationY = new Float32Array(\n    arraySizeVec4,\n  );\n\n  let startHiLo2D;\n  let offsetAndRight2D;\n  let startEndNormals2D;\n  let texcoordNormalization2D;\n\n  if (compute2dAttributes) {\n    startHiLo2D = new Float32Array(arraySizeVec4);\n    offsetAndRight2D = new Float32Array(arraySizeVec4);\n    startEndNormals2D = new Float32Array(arraySizeVec4);\n    texcoordNormalization2D = new Float32Array(vertexCount * 2);\n  }\n\n  /*** Compute total lengths for texture coordinate normalization ***/\n  // 2D\n  const cartographicsLength = cartographicsArray.length / 2;\n  let length2D = 0.0;\n\n  const startCartographic = startCartographicScratch;\n  startCartographic.height = 0.0;\n  const endCartographic = endCartographicScratch;\n  endCartographic.height = 0.0;\n\n  let segmentStartCartesian = segmentStartTopScratch;\n  let segmentEndCartesian = segmentEndTopScratch;\n\n  if (compute2dAttributes) {\n    index = 0;\n    for (i = 1; i < cartographicsLength; i++) {\n      // Don't clone anything from previous segment b/c possible IDL touch\n      startCartographic.latitude = cartographicsArray[index];\n      startCartographic.longitude = cartographicsArray[index + 1];\n      endCartographic.latitude = cartographicsArray[index + 2];\n      endCartographic.longitude = cartographicsArray[index + 3];\n\n      segmentStartCartesian = projection.project(\n        startCartographic,\n        segmentStartCartesian,\n      );\n      segmentEndCartesian = projection.project(\n        endCartographic,\n        segmentEndCartesian,\n      );\n      length2D += Cartesian3.distance(\n        segmentStartCartesian,\n        segmentEndCartesian,\n      );\n      index += 2;\n    }\n  }\n\n  // 3D\n  const positionsLength = topPositionsArray.length / 3;\n  segmentEndCartesian = Cartesian3.unpack(\n    topPositionsArray,\n    0,\n    segmentEndCartesian,\n  );\n  let length3D = 0.0;\n\n  index = 3;\n  for (i = 1; i < positionsLength; i++) {\n    segmentStartCartesian = Cartesian3.clone(\n      segmentEndCartesian,\n      segmentStartCartesian,\n    );\n    segmentEndCartesian = Cartesian3.unpack(\n      topPositionsArray,\n      index,\n      segmentEndCartesian,\n    );\n    length3D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\n    index += 3;\n  }\n\n  /*** Generate segments ***/\n  let j;\n  index = 3;\n  let cartographicsIndex = 0;\n  let vec2sWriteIndex = 0;\n  let vec3sWriteIndex = 0;\n  let vec4sWriteIndex = 0;\n  let miterBroken = false;\n\n  let endBottom = Cartesian3.unpack(\n    bottomPositionsArray,\n    0,\n    segmentEndBottomScratch,\n  );\n  let endTop = Cartesian3.unpack(topPositionsArray, 0, segmentEndTopScratch);\n  let endGeometryNormal = Cartesian3.unpack(\n    normalsArray,\n    0,\n    segmentEndNormalScratch,\n  );\n\n  if (loop) {\n    const preEndBottom = Cartesian3.unpack(\n      bottomPositionsArray,\n      bottomPositionsArray.length - 6,\n      segmentStartBottomScratch,\n    );\n    if (breakMiter(endGeometryNormal, preEndBottom, endBottom, endTop)) {\n      // Miter broken as if for the last point in the loop, needs to be inverted for first point (clone of endBottom)\n      endGeometryNormal = Cartesian3.negate(\n        endGeometryNormal,\n        endGeometryNormal,\n      );\n    }\n  }\n\n  let lengthSoFar3D = 0.0;\n  let lengthSoFar2D = 0.0;\n\n  // For translating bounding volume\n  let sumHeights = 0.0;\n\n  for (i = 0; i < segmentCount; i++) {\n    const startBottom = Cartesian3.clone(endBottom, segmentStartBottomScratch);\n    const startTop = Cartesian3.clone(endTop, segmentStartTopScratch);\n    let startGeometryNormal = Cartesian3.clone(\n      endGeometryNormal,\n      segmentStartNormalScratch,\n    );\n\n    if (miterBroken) {\n      startGeometryNormal = Cartesian3.negate(\n        startGeometryNormal,\n        startGeometryNormal,\n      );\n    }\n\n    endBottom = Cartesian3.unpack(\n      bottomPositionsArray,\n      index,\n      segmentEndBottomScratch,\n    );\n    endTop = Cartesian3.unpack(topPositionsArray, index, segmentEndTopScratch);\n    endGeometryNormal = Cartesian3.unpack(\n      normalsArray,\n      index,\n      segmentEndNormalScratch,\n    );\n\n    miterBroken = breakMiter(endGeometryNormal, startBottom, endBottom, endTop);\n\n    // 2D - don't clone anything from previous segment b/c possible IDL touch\n    startCartographic.latitude = cartographicsArray[cartographicsIndex];\n    startCartographic.longitude = cartographicsArray[cartographicsIndex + 1];\n    endCartographic.latitude = cartographicsArray[cartographicsIndex + 2];\n    endCartographic.longitude = cartographicsArray[cartographicsIndex + 3];\n    let start2D;\n    let end2D;\n    let startGeometryNormal2D;\n    let endGeometryNormal2D;\n\n    if (compute2dAttributes) {\n      const nudgeResult = nudgeCartographic(startCartographic, endCartographic);\n      start2D = projection.project(startCartographic, segmentStart2DScratch);\n      end2D = projection.project(endCartographic, segmentEnd2DScratch);\n      const direction2D = direction(end2D, start2D, forwardOffset2DScratch);\n      direction2D.y = Math.abs(direction2D.y);\n\n      startGeometryNormal2D = segmentStartNormal2DScratch;\n      endGeometryNormal2D = segmentEndNormal2DScratch;\n      if (\n        nudgeResult === 0 ||\n        Cartesian3.dot(direction2D, Cartesian3.UNIT_Y) > MITER_BREAK_SMALL\n      ) {\n        // No nudge - project the original normal\n        // Or, if the line's angle relative to the IDL is very acute,\n        // in which case snapping will produce oddly shaped volumes.\n        startGeometryNormal2D = projectNormal(\n          projection,\n          startCartographic,\n          startGeometryNormal,\n          start2D,\n          segmentStartNormal2DScratch,\n        );\n        endGeometryNormal2D = projectNormal(\n          projection,\n          endCartographic,\n          endGeometryNormal,\n          end2D,\n          segmentEndNormal2DScratch,\n        );\n      } else if (nudgeResult === 1) {\n        // Start is close to IDL - snap start normal to align with IDL\n        endGeometryNormal2D = projectNormal(\n          projection,\n          endCartographic,\n          endGeometryNormal,\n          end2D,\n          segmentEndNormal2DScratch,\n        );\n        startGeometryNormal2D.x = 0.0;\n        // If start longitude is negative and end longitude is less negative, relative right is unit -Y\n        // If start longitude is positive and end longitude is less positive, relative right is unit +Y\n        startGeometryNormal2D.y = CesiumMath.sign(\n          startCartographic.longitude - Math.abs(endCartographic.longitude),\n        );\n        startGeometryNormal2D.z = 0.0;\n      } else {\n        // End is close to IDL - snap end normal to align with IDL\n        startGeometryNormal2D = projectNormal(\n          projection,\n          startCartographic,\n          startGeometryNormal,\n          start2D,\n          segmentStartNormal2DScratch,\n        );\n        endGeometryNormal2D.x = 0.0;\n        // If end longitude is negative and start longitude is less negative, relative right is unit Y\n        // If end longitude is positive and start longitude is less positive, relative right is unit -Y\n        endGeometryNormal2D.y = CesiumMath.sign(\n          startCartographic.longitude - endCartographic.longitude,\n        );\n        endGeometryNormal2D.z = 0.0;\n      }\n    }\n\n    /****************************************\n     * Geometry descriptors of a \"line on terrain,\"\n     * as opposed to the \"shadow volume used to draw\n     * the line on terrain\":\n     * - position of start + offset to end\n     * - start, end, and right-facing planes\n     * - encoded texture coordinate offsets\n     ****************************************/\n\n    /* 3D */\n    const segmentLength3D = Cartesian3.distance(startTop, endTop);\n\n    const encodedStart = EncodedCartesian3.fromCartesian(\n      startBottom,\n      encodeScratch,\n    );\n    const forwardOffset = Cartesian3.subtract(\n      endBottom,\n      startBottom,\n      offsetScratch,\n    );\n    const forward = Cartesian3.normalize(forwardOffset, rightScratch);\n\n    let startUp = Cartesian3.subtract(startTop, startBottom, startUpScratch);\n    startUp = Cartesian3.normalize(startUp, startUp);\n    let rightNormal = Cartesian3.cross(forward, startUp, rightScratch);\n    rightNormal = Cartesian3.normalize(rightNormal, rightNormal);\n\n    let startPlaneNormal = Cartesian3.cross(\n      startUp,\n      startGeometryNormal,\n      startPlaneNormalScratch,\n    );\n    startPlaneNormal = Cartesian3.normalize(startPlaneNormal, startPlaneNormal);\n\n    let endUp = Cartesian3.subtract(endTop, endBottom, endUpScratch);\n    endUp = Cartesian3.normalize(endUp, endUp);\n    let endPlaneNormal = Cartesian3.cross(\n      endGeometryNormal,\n      endUp,\n      endPlaneNormalScratch,\n    );\n    endPlaneNormal = Cartesian3.normalize(endPlaneNormal, endPlaneNormal);\n\n    const texcoordNormalization3DX = segmentLength3D / length3D;\n    const texcoordNormalization3DY = lengthSoFar3D / length3D;\n\n    /* 2D */\n    let segmentLength2D = 0.0;\n    let encodedStart2D;\n    let forwardOffset2D;\n    let right2D;\n    let texcoordNormalization2DX = 0.0;\n    let texcoordNormalization2DY = 0.0;\n    if (compute2dAttributes) {\n      segmentLength2D = Cartesian3.distance(start2D, end2D);\n\n      encodedStart2D = EncodedCartesian3.fromCartesian(\n        start2D,\n        encodeScratch2D,\n      );\n      forwardOffset2D = Cartesian3.subtract(\n        end2D,\n        start2D,\n        forwardOffset2DScratch,\n      );\n\n      // Right direction is just forward direction rotated by -90 degrees around Z\n      // Similarly with plane normals\n      right2D = Cartesian3.normalize(forwardOffset2D, right2DScratch);\n      const swap = right2D.x;\n      right2D.x = right2D.y;\n      right2D.y = -swap;\n\n      texcoordNormalization2DX = segmentLength2D / length2D;\n      texcoordNormalization2DY = lengthSoFar2D / length2D;\n    }\n    /** Pack **/\n    for (j = 0; j < 8; j++) {\n      const vec4Index = vec4sWriteIndex + j * 4;\n      const vec2Index = vec2sWriteIndex + j * 2;\n      const wIndex = vec4Index + 3;\n\n      // Encode sidedness of vertex relative to right plane in texture coordinate normalization X,\n      // whether vertex is top or bottom of volume in sign/magnitude of normalization Y.\n      const rightPlaneSide = j < 4 ? 1.0 : -1.0;\n      const topBottomSide =\n        j === 2 || j === 3 || j === 6 || j === 7 ? 1.0 : -1.0;\n\n      // 3D\n      Cartesian3.pack(encodedStart.high, startHiAndForwardOffsetX, vec4Index);\n      startHiAndForwardOffsetX[wIndex] = forwardOffset.x;\n\n      Cartesian3.pack(encodedStart.low, startLoAndForwardOffsetY, vec4Index);\n      startLoAndForwardOffsetY[wIndex] = forwardOffset.y;\n\n      Cartesian3.pack(\n        startPlaneNormal,\n        startNormalAndForwardOffsetZ,\n        vec4Index,\n      );\n      startNormalAndForwardOffsetZ[wIndex] = forwardOffset.z;\n\n      Cartesian3.pack(\n        endPlaneNormal,\n        endNormalAndTextureCoordinateNormalizationX,\n        vec4Index,\n      );\n      endNormalAndTextureCoordinateNormalizationX[wIndex] =\n        texcoordNormalization3DX * rightPlaneSide;\n\n      Cartesian3.pack(\n        rightNormal,\n        rightNormalAndTextureCoordinateNormalizationY,\n        vec4Index,\n      );\n\n      let texcoordNormalization = texcoordNormalization3DY * topBottomSide;\n      if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n        texcoordNormalization = 9.0; // some value greater than 1.0\n      }\n      rightNormalAndTextureCoordinateNormalizationY[wIndex] =\n        texcoordNormalization;\n\n      // 2D\n      if (compute2dAttributes) {\n        startHiLo2D[vec4Index] = encodedStart2D.high.x;\n        startHiLo2D[vec4Index + 1] = encodedStart2D.high.y;\n        startHiLo2D[vec4Index + 2] = encodedStart2D.low.x;\n        startHiLo2D[vec4Index + 3] = encodedStart2D.low.y;\n\n        startEndNormals2D[vec4Index] = -startGeometryNormal2D.y;\n        startEndNormals2D[vec4Index + 1] = startGeometryNormal2D.x;\n        startEndNormals2D[vec4Index + 2] = endGeometryNormal2D.y;\n        startEndNormals2D[vec4Index + 3] = -endGeometryNormal2D.x;\n\n        offsetAndRight2D[vec4Index] = forwardOffset2D.x;\n        offsetAndRight2D[vec4Index + 1] = forwardOffset2D.y;\n        offsetAndRight2D[vec4Index + 2] = right2D.x;\n        offsetAndRight2D[vec4Index + 3] = right2D.y;\n\n        texcoordNormalization2D[vec2Index] =\n          texcoordNormalization2DX * rightPlaneSide;\n\n        texcoordNormalization = texcoordNormalization2DY * topBottomSide;\n        if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n          texcoordNormalization = 9.0; // some value greater than 1.0\n        }\n        texcoordNormalization2D[vec2Index + 1] = texcoordNormalization;\n      }\n    }\n\n    // Adjust height of volume in 3D\n    const adjustHeightStartBottom = adjustHeightStartBottomScratch;\n    const adjustHeightEndBottom = adjustHeightEndBottomScratch;\n    const adjustHeightStartTop = adjustHeightStartTopScratch;\n    const adjustHeightEndTop = adjustHeightEndTopScratch;\n\n    const getHeightsRectangle = Rectangle.fromCartographicArray(\n      getHeightCartographics,\n      getHeightRectangleScratch,\n    );\n    const minMaxHeights = ApproximateTerrainHeights.getMinimumMaximumHeights(\n      getHeightsRectangle,\n      ellipsoid,\n    );\n    const minHeight = minMaxHeights.minimumTerrainHeight;\n    const maxHeight = minMaxHeights.maximumTerrainHeight;\n\n    // Sum using abs() to properly account for negative eleavtions in calculating bounding sphere radius\n    sumHeights += Math.abs(minHeight);\n    sumHeights += Math.abs(maxHeight);\n\n    adjustHeights(\n      startBottom,\n      startTop,\n      minHeight,\n      maxHeight,\n      adjustHeightStartBottom,\n      adjustHeightStartTop,\n    );\n    adjustHeights(\n      endBottom,\n      endTop,\n      minHeight,\n      maxHeight,\n      adjustHeightEndBottom,\n      adjustHeightEndTop,\n    );\n\n    // Nudge the positions away from the \"polyline\" a little bit to prevent errors in GeometryPipeline\n    let normalNudge = Cartesian3.multiplyByScalar(\n      rightNormal,\n      CesiumMath.EPSILON5,\n      normalNudgeScratch,\n    );\n    Cartesian3.add(\n      adjustHeightStartBottom,\n      normalNudge,\n      adjustHeightStartBottom,\n    );\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n\n    // If the segment is very close to the XZ plane, nudge the vertices slightly to avoid touching it.\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n\n    Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex);\n    Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 3);\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 6);\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 9);\n\n    normalNudge = Cartesian3.multiplyByScalar(\n      rightNormal,\n      -2.0 * CesiumMath.EPSILON5,\n      normalNudgeScratch,\n    );\n    Cartesian3.add(\n      adjustHeightStartBottom,\n      normalNudge,\n      adjustHeightStartBottom,\n    );\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n\n    Cartesian3.pack(\n      adjustHeightStartBottom,\n      positionsArray,\n      vec3sWriteIndex + 12,\n    );\n    Cartesian3.pack(\n      adjustHeightEndBottom,\n      positionsArray,\n      vec3sWriteIndex + 15,\n    );\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 18);\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 21);\n\n    cartographicsIndex += 2;\n    index += 3;\n\n    vec2sWriteIndex += 16;\n    vec3sWriteIndex += 24;\n    vec4sWriteIndex += 32;\n\n    lengthSoFar3D += segmentLength3D;\n    lengthSoFar2D += segmentLength2D;\n  }\n\n  index = 0;\n  let indexOffset = 0;\n  for (i = 0; i < segmentCount; i++) {\n    for (j = 0; j < REFERENCE_INDICES_LENGTH; j++) {\n      indices[index + j] = REFERENCE_INDICES[j] + indexOffset;\n    }\n    indexOffset += 8;\n    index += REFERENCE_INDICES_LENGTH;\n  }\n\n  const boundingSpheres = scratchBoundingSpheres;\n  BoundingSphere.fromVertices(\n    bottomPositionsArray,\n    Cartesian3.ZERO,\n    3,\n    boundingSpheres[0],\n  );\n  BoundingSphere.fromVertices(\n    topPositionsArray,\n    Cartesian3.ZERO,\n    3,\n    boundingSpheres[1],\n  );\n  const boundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres);\n\n  // Adjust bounding sphere height and radius to cover more of the volume\n  boundingSphere.radius += sumHeights / (segmentCount * 2.0);\n\n  const attributes = {\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      normalize: false,\n      values: positionsArray,\n    }),\n    startHiAndForwardOffsetX: getVec4GeometryAttribute(\n      startHiAndForwardOffsetX,\n    ),\n    startLoAndForwardOffsetY: getVec4GeometryAttribute(\n      startLoAndForwardOffsetY,\n    ),\n    startNormalAndForwardOffsetZ: getVec4GeometryAttribute(\n      startNormalAndForwardOffsetZ,\n    ),\n    endNormalAndTextureCoordinateNormalizationX: getVec4GeometryAttribute(\n      endNormalAndTextureCoordinateNormalizationX,\n    ),\n    rightNormalAndTextureCoordinateNormalizationY: getVec4GeometryAttribute(\n      rightNormalAndTextureCoordinateNormalizationY,\n    ),\n  };\n\n  if (compute2dAttributes) {\n    attributes.startHiLo2D = getVec4GeometryAttribute(startHiLo2D);\n    attributes.offsetAndRight2D = getVec4GeometryAttribute(offsetAndRight2D);\n    attributes.startEndNormals2D = getVec4GeometryAttribute(startEndNormals2D);\n    attributes.texcoordNormalization2D = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      normalize: false,\n      values: texcoordNormalization2D,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    boundingSphere: boundingSphere,\n  });\n}\n\nfunction getVec4GeometryAttribute(typedArray) {\n  return new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    values: typedArray,\n  });\n}\n\n/**\n * Approximates an ellipsoid-tangent vector in 2D by projecting the end point into 2D.\n * Exposed for testing.\n *\n * @param {MapProjection} projection Map Projection for projecting coordinates to 2D.\n * @param {Cartographic} cartographic The cartographic origin point of the normal.\n *   Used to check if the normal crosses the IDL during projection.\n * @param {Cartesian3} normal The normal in 3D.\n * @param {Cartesian3} projectedPosition The projected origin point of the normal in 2D.\n * @param {Cartesian3} result Result parameter on which to store the projected normal.\n * @private\n */\nGroundPolylineGeometry._projectNormal = projectNormal;\nexport default GroundPolylineGeometry;\n"],"names":["PROJECTIONS","PROJECTION_COUNT","length","MITER_BREAK_SMALL","Math","cos","toRadians","MITER_BREAK_LARGE","WALL_INITIAL_MIN_HEIGHT","WALL_INITIAL_MAX_HEIGHT","GroundPolylineGeometry","options","EMPTY_OBJECT","positions","arcType","GEODESIC","RHUMB","width","_positions","granularity","loop","_ellipsoid","default","_projectionIndex","_workerName","_scene3DOnly","Object","defineProperties","prototype","packedLength","get","setProjectionAndEllipsoid","groundPolylineGeometry","mapProjection","projectionIndex","i","ellipsoid","cart3Scratch1","cart3Scratch2","cart3Scratch3","computeRightNormal","start","end","maxHeight","result","startBottom","getPosition","startTop","endBottom","up","direction","forward","cross","normalize","interpolatedCartographicScratch","interpolatedBottomScratch","interpolatedTopScratch","interpolatedNormalScratch","interpolateSegment","minHeight","normalsArray","bottomPositionsArray","topPositionsArray","cartographicsArray","ellipsoidLine","surfaceDistance","interpolatedNormal","segments","ceil","interpointDistance","distanceFromStart","pointsToAdd","packIndex","interpolatedCartographic","interpolateUsingSurfaceDistance","interpolatedBottom","interpolatedTop","pack","push","latitude","longitude","heightlessCartographicScratch","cartographic","height","clone","toCartesian","value","array","startingIndex","typeOf","object","defined","index","positionsLength","cartesian","unpack","Array","scene3DOnly","target","origin","subtract","tangentDirection","toPreviousScratch","toNextScratch","forwardScratch","vertexUpScratch","cosine90","cosine180","computeVertexMiterNormal","previousBottom","vertexBottom","vertexTop","nextBottom","toPrevious","toNext","equalsEpsilon","dot","EPSILON5","add","negate","XZ_PLANE","fromPointNormal","ZERO","UNIT_Y","previousBottomScratch","vertexBottomScratch","vertexTopScratch","nextBottomScratch","vertexNormalScratch","intersectionScratch","cartographicScratch0","cartographicScratch1","cartographicIntersectionScratch","createGeometry","compute2dAttributes","projection","p0","p1","c0","c1","rhumbLine","undefined","intersection","intersectionCartographic","intersectionLongitude","splitPositions","lineSegmentPlane","EPSILON7","cartesianToCartographic","setEndPoints","findIntersectionWithLongitude","cartographicToCartesian","cartographicsLength","cartographics","fromCartesian","vertexNormal","startCartographic","nextCartographic","prestartCartographic","vertexCartographic","endCartographic","preEndCartographic","postEndCartographic","generateGeometryAttributes","lineDirectionScratch","matrix3Scratch","quaternionScratch","breakMiter","endGeometryNormal","endTop","lineDirection","vertexUp","angle","PI_OVER_TWO","quaternion","fromAxisAngle","rotationMatrix","fromQuaternion","multiplyByVector","endPosCartographicScratch","normalStartpointScratch","normalEndpointScratch","projectNormal","normal","projectedPosition","position","normalEndpoint","flipNormal","normalEndpointCartographic","abs","normalEndpointProjected","project","z","adjustHeightNormalScratch","adjustHeightOffsetScratch","adjustHeights","bottom","top","adjustHeightBottom","adjustHeightTop","adjustHeightNormal","distanceForBottom","adjustHeightOffset","multiplyByScalar","distanceForTop","nudgeDirectionScratch","nudgeXZ","startToXZdistance","getPointDistance","endToXZdistance","offset","EPSILON2","nudgeCartographic","absStartLon","absEndLon","PI","EPSILON11","endSign","sign","startSign","startCartographicScratch","endCartographicScratch","segmentStartTopScratch","segmentEndTopScratch","segmentStartBottomScratch","segmentEndBottomScratch","segmentStartNormalScratch","segmentEndNormalScratch","getHeightCartographics","getHeightRectangleScratch","adjustHeightStartTopScratch","adjustHeightEndTopScratch","adjustHeightStartBottomScratch","adjustHeightEndBottomScratch","segmentStart2DScratch","segmentEnd2DScratch","segmentStartNormal2DScratch","segmentEndNormal2DScratch","offsetScratch","startUpScratch","endUpScratch","rightScratch","startPlaneNormalScratch","endPlaneNormalScratch","encodeScratch","encodeScratch2D","forwardOffset2DScratch","right2DScratch","normalNudgeScratch","scratchBoundingSpheres","REFERENCE_INDICES","REFERENCE_INDICES_LENGTH","segmentCount","vertexCount","arraySizeVec4","indexCount","indices","Uint32Array","Uint16Array","positionsArray","Float64Array","startHiAndForwardOffsetX","Float32Array","startLoAndForwardOffsetY","startNormalAndForwardOffsetZ","endNormalAndTextureCoordinateNormalizationX","rightNormalAndTextureCoordinateNormalizationY","startHiLo2D","offsetAndRight2D","startEndNormals2D","texcoordNormalization2D","length2D","segmentStartCartesian","segmentEndCartesian","distance","length3D","j","cartographicsIndex","vec2sWriteIndex","vec3sWriteIndex","vec4sWriteIndex","miterBroken","preEndBottom","lengthSoFar3D","lengthSoFar2D","sumHeights","startGeometryNormal","start2D","end2D","startGeometryNormal2D","endGeometryNormal2D","nudgeResult","direction2D","y","x","segmentLength3D","encodedStart","forwardOffset","startUp","rightNormal","startPlaneNormal","endUp","endPlaneNormal","texcoordNormalization3DX","texcoordNormalization3DY","segmentLength2D","encodedStart2D","forwardOffset2D","right2D","texcoordNormalization2DX","texcoordNormalization2DY","swap","vec4Index","vec2Index","wIndex","rightPlaneSide","topBottomSide","high","low","texcoordNormalization","adjustHeightStartBottom","adjustHeightEndBottom","adjustHeightStartTop","adjustHeightEndTop","getHeightsRectangle","fromCartographicArray","minMaxHeights","getMinimumMaximumHeights","minimumTerrainHeight","maximumTerrainHeight","normalNudge","indexOffset","boundingSpheres","fromVertices","boundingSphere","fromBoundingSpheres","radius","attributes","componentDatatype","DOUBLE","componentsPerAttribute","values","getVec4GeometryAttribute","FLOAT","typedArray","_projectNormal"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 24705, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/BoundingRectangle.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Intersect from \"./Intersect.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * A bounding rectangle given by a corner, width and height.\n * @alias BoundingRectangle\n * @constructor\n *\n * @param {number} [x=0.0] The x coordinate of the rectangle.\n * @param {number} [y=0.0] The y coordinate of the rectangle.\n * @param {number} [width=0.0] The width of the rectangle.\n * @param {number} [height=0.0] The height of the rectangle.\n *\n * @see BoundingSphere\n * @see Packable\n */\nfunction BoundingRectangle(x, y, width, height) {\n  /**\n   * The x coordinate of the rectangle.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = x ?? 0.0;\n\n  /**\n   * The y coordinate of the rectangle.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = y ?? 0.0;\n\n  /**\n   * The width of the rectangle.\n   * @type {number}\n   * @default 0.0\n   */\n  this.width = width ?? 0.0;\n\n  /**\n   * The height of the rectangle.\n   * @type {number}\n   * @default 0.0\n   */\n  this.height = height ?? 0.0;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nBoundingRectangle.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoundingRectangle} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nBoundingRectangle.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.width;\n  array[startingIndex] = value.height;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoundingRectangle} [result] The object into which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.width = array[startingIndex++];\n  result.height = array[startingIndex];\n  return result;\n};\n\n/**\n * Computes a bounding rectangle enclosing the list of 2D points.\n * The rectangle is oriented with the corner at the bottom left.\n *\n * @param {Cartesian2[]} positions List of points that the bounding rectangle will enclose.  Each point must have <code>x</code> and <code>y</code> properties.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.x = 0;\n    result.y = 0;\n    result.width = 0;\n    result.height = 0;\n    return result;\n  }\n\n  const length = positions.length;\n\n  let minimumX = positions[0].x;\n  let minimumY = positions[0].y;\n\n  let maximumX = positions[0].x;\n  let maximumY = positions[0].y;\n\n  for (let i = 1; i < length; i++) {\n    const p = positions[i];\n    const x = p.x;\n    const y = p.y;\n\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n  }\n\n  result.x = minimumX;\n  result.y = minimumY;\n  result.width = maximumX - minimumX;\n  result.height = maximumY - minimumY;\n  return result;\n};\n\nconst defaultProjection = new GeographicProjection();\nconst fromRectangleLowerLeft = new Cartographic();\nconst fromRectangleUpperRight = new Cartographic();\n/**\n * Computes a bounding rectangle from a rectangle.\n *\n * @param {Rectangle} rectangle The valid rectangle used to create a bounding rectangle.\n * @param {object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.fromRectangle = function (rectangle, projection, result) {\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  if (!defined(rectangle)) {\n    result.x = 0;\n    result.y = 0;\n    result.width = 0;\n    result.height = 0;\n    return result;\n  }\n\n  defaultProjection._ellipsoid = Ellipsoid.default;\n  projection = projection ?? defaultProjection;\n\n  const lowerLeft = projection.project(\n    Rectangle.southwest(rectangle, fromRectangleLowerLeft),\n  );\n  const upperRight = projection.project(\n    Rectangle.northeast(rectangle, fromRectangleUpperRight),\n  );\n\n  Cartesian2.subtract(upperRight, lowerLeft, upperRight);\n\n  result.x = lowerLeft.x;\n  result.y = lowerLeft.y;\n  result.width = upperRight.x;\n  result.height = upperRight.y;\n  return result;\n};\n\n/**\n * Duplicates a BoundingRectangle instance.\n *\n * @param {BoundingRectangle} rectangle The bounding rectangle to duplicate.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided. (Returns undefined if rectangle is undefined)\n */\nBoundingRectangle.clone = function (rectangle, result) {\n  if (!defined(rectangle)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new BoundingRectangle(\n      rectangle.x,\n      rectangle.y,\n      rectangle.width,\n      rectangle.height,\n    );\n  }\n\n  result.x = rectangle.x;\n  result.y = rectangle.y;\n  result.width = rectangle.width;\n  result.height = rectangle.height;\n  return result;\n};\n\n/**\n * Computes a bounding rectangle that is the union of the left and right bounding rectangles.\n *\n * @param {BoundingRectangle} left A rectangle to enclose in bounding rectangle.\n * @param {BoundingRectangle} right A rectangle to enclose in a bounding rectangle.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.union = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  const lowerLeftX = Math.min(left.x, right.x);\n  const lowerLeftY = Math.min(left.y, right.y);\n  const upperRightX = Math.max(left.x + left.width, right.x + right.width);\n  const upperRightY = Math.max(left.y + left.height, right.y + right.height);\n\n  result.x = lowerLeftX;\n  result.y = lowerLeftY;\n  result.width = upperRightX - lowerLeftX;\n  result.height = upperRightY - lowerLeftY;\n  return result;\n};\n\n/**\n * Computes a bounding rectangle by enlarging the provided rectangle until it contains the provided point.\n *\n * @param {BoundingRectangle} rectangle A rectangle to expand.\n * @param {Cartesian2} point A point to enclose in a bounding rectangle.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.expand = function (rectangle, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  result = BoundingRectangle.clone(rectangle, result);\n\n  const width = point.x - result.x;\n  const height = point.y - result.y;\n\n  if (width > result.width) {\n    result.width = width;\n  } else if (width < 0) {\n    result.width -= width;\n    result.x = point.x;\n  }\n\n  if (height > result.height) {\n    result.height = height;\n  } else if (height < 0) {\n    result.height -= height;\n    result.y = point.y;\n  }\n\n  return result;\n};\n\n/**\n * Determines if two rectangles intersect.\n *\n * @param {BoundingRectangle} left A rectangle to check for intersection.\n * @param {BoundingRectangle} right The other rectangle to check for intersection.\n * @returns {Intersect} <code>Intersect.INTERSECTING</code> if the rectangles intersect, <code>Intersect.OUTSIDE</code> otherwise.\n */\nBoundingRectangle.intersect = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  const leftX = left.x;\n  const leftY = left.y;\n  const rightX = right.x;\n  const rightY = right.y;\n  if (\n    !(\n      leftX > rightX + right.width ||\n      leftX + left.width < rightX ||\n      leftY + left.height < rightY ||\n      leftY > rightY + right.height\n    )\n  ) {\n    return Intersect.INTERSECTING;\n  }\n\n  return Intersect.OUTSIDE;\n};\n\n/**\n * Compares the provided BoundingRectangles componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingRectangle} [left] The first BoundingRectangle.\n * @param {BoundingRectangle} [right] The second BoundingRectangle.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nBoundingRectangle.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.width === right.width &&\n      left.height === right.height)\n  );\n};\n\n/**\n * Duplicates this BoundingRectangle instance.\n *\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.prototype.clone = function (result) {\n  return BoundingRectangle.clone(this, result);\n};\n\n/**\n * Determines if this rectangle intersects with another.\n *\n * @param {BoundingRectangle} right A rectangle to check for intersection.\n * @returns {Intersect} <code>Intersect.INTERSECTING</code> if the rectangles intersect, <code>Intersect.OUTSIDE</code> otherwise.\n */\nBoundingRectangle.prototype.intersect = function (right) {\n  return BoundingRectangle.intersect(this, right);\n};\n\n/**\n * Compares this BoundingRectangle against the provided BoundingRectangle componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingRectangle} [right] The right hand side BoundingRectangle.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nBoundingRectangle.prototype.equals = function (right) {\n  return BoundingRectangle.equals(this, right);\n};\nexport default BoundingRectangle;\n"],"names":["BoundingRectangle","x","y","width","height","packedLength","pack","value","array","startingIndex","typeOf","object","defined","unpack","result","fromPoints","positions","length","minimumX","minimumY","maximumX","maximumY","i","p","Math","min","max","defaultProjection","fromRectangleLowerLeft","fromRectangleUpperRight","fromRectangle","rectangle","projection","_ellipsoid","default","lowerLeft","project","southwest","upperRight","northeast","subtract","clone","undefined","union","left","right","lowerLeftX","lowerLeftY","upperRightX","upperRightY","expand","point","intersect","leftX","leftY","rightX","rightY","INTERSECTING","OUTSIDE","equals","prototype"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 25007, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Color.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport FeatureDetection from \"./FeatureDetection.js\";\nimport CesiumMath from \"./Math.js\";\n\nfunction hue2rgb(m1, m2, h) {\n  if (h < 0) {\n    h += 1;\n  }\n  if (h > 1) {\n    h -= 1;\n  }\n  if (h * 6 < 1) {\n    return m1 + (m2 - m1) * 6 * h;\n  }\n  if (h * 2 < 1) {\n    return m2;\n  }\n  if (h * 3 < 2) {\n    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n  }\n  return m1;\n}\n\n/**\n * A color, specified using red, green, blue, and alpha values,\n * which range from <code>0</code> (no intensity) to <code>1.0</code> (full intensity).\n * @param {number} [red=1.0] The red component.\n * @param {number} [green=1.0] The green component.\n * @param {number} [blue=1.0] The blue component.\n * @param {number} [alpha=1.0] The alpha component.\n *\n * @constructor\n * @alias Color\n *\n * @see Packable\n */\nfunction Color(red, green, blue, alpha) {\n  /**\n   * The red component.\n   * @type {number}\n   * @default 1.0\n   */\n  this.red = red ?? 1.0;\n  /**\n   * The green component.\n   * @type {number}\n   * @default 1.0\n   */\n  this.green = green ?? 1.0;\n  /**\n   * The blue component.\n   * @type {number}\n   * @default 1.0\n   */\n  this.blue = blue ?? 1.0;\n  /**\n   * The alpha component.\n   * @type {number}\n   * @default 1.0\n   */\n  this.alpha = alpha ?? 1.0;\n}\n\n/**\n * Creates a Color instance from a {@link Cartesian4}. <code>x</code>, <code>y</code>, <code>z</code>,\n * and <code>w</code> map to <code>red</code>, <code>green</code>, <code>blue</code>, and <code>alpha</code>, respectively.\n *\n * @param {Cartesian4} cartesian The source cartesian.\n * @param {Color} [result] The object onto which to store the result.\n * @returns {Color} The modified result parameter or a new Color instance if one was not provided.\n */\nColor.fromCartesian4 = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Color(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n  }\n\n  result.red = cartesian.x;\n  result.green = cartesian.y;\n  result.blue = cartesian.z;\n  result.alpha = cartesian.w;\n  return result;\n};\n\n/**\n * Creates a new Color specified using red, green, blue, and alpha values\n * that are in the range of 0 to 255, converting them internally to a range of 0.0 to 1.0.\n *\n * @param {number} [red=255] The red component.\n * @param {number} [green=255] The green component.\n * @param {number} [blue=255] The blue component.\n * @param {number} [alpha=255] The alpha component.\n * @param {Color} [result] The object onto which to store the result.\n * @returns {Color} The modified result parameter or a new Color instance if one was not provided.\n */\nColor.fromBytes = function (red, green, blue, alpha, result) {\n  red = Color.byteToFloat(red ?? 255.0);\n  green = Color.byteToFloat(green ?? 255.0);\n  blue = Color.byteToFloat(blue ?? 255.0);\n  alpha = Color.byteToFloat(alpha ?? 255.0);\n\n  if (!defined(result)) {\n    return new Color(red, green, blue, alpha);\n  }\n\n  result.red = red;\n  result.green = green;\n  result.blue = blue;\n  result.alpha = alpha;\n  return result;\n};\n\n/**\n * Creates a new Color that has the same red, green, and blue components\n * of the specified color, but with the specified alpha value.\n *\n * @param {Color} color The base color\n * @param {number} alpha The new alpha component.\n * @param {Color} [result] The object onto which to store the result.\n * @returns {Color} The modified result parameter or a new Color instance if one was not provided.\n *\n * @example const translucentRed = Cesium.Color.fromAlpha(Cesium.Color.RED, 0.9);\n */\nColor.fromAlpha = function (color, alpha, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"color\", color);\n  Check.typeOf.number(\"alpha\", alpha);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Color(color.red, color.green, color.blue, alpha);\n  }\n\n  result.red = color.red;\n  result.green = color.green;\n  result.blue = color.blue;\n  result.alpha = alpha;\n  return result;\n};\n\nlet scratchArrayBuffer;\nlet scratchUint32Array;\nlet scratchUint8Array;\nif (FeatureDetection.supportsTypedArrays()) {\n  scratchArrayBuffer = new ArrayBuffer(4);\n  scratchUint32Array = new Uint32Array(scratchArrayBuffer);\n  scratchUint8Array = new Uint8Array(scratchArrayBuffer);\n}\n\n/**\n * Creates a new Color from a single numeric unsigned 32-bit RGBA value, using the endianness\n * of the system.\n *\n * @param {number} rgba A single numeric unsigned 32-bit RGBA value.\n * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.\n * @returns {Color} The color object.\n *\n * @example\n * const color = Cesium.Color.fromRgba(0x67ADDFFF);\n *\n * @see Color#toRgba\n */\nColor.fromRgba = function (rgba, result) {\n  // scratchUint32Array and scratchUint8Array share an underlying array buffer\n  scratchUint32Array[0] = rgba;\n  return Color.fromBytes(\n    scratchUint8Array[0],\n    scratchUint8Array[1],\n    scratchUint8Array[2],\n    scratchUint8Array[3],\n    result,\n  );\n};\n\n/**\n * Creates a Color instance from hue, saturation, and lightness.\n *\n * @param {number} [hue=0] The hue angle 0...1\n * @param {number} [saturation=0] The saturation value 0...1\n * @param {number} [lightness=0] The lightness value 0...1\n * @param {number} [alpha=1.0] The alpha component 0...1\n * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.\n * @returns {Color} The color object.\n *\n * @see {@link http://www.w3.org/TR/css3-color/#hsl-color|CSS color values}\n */\nColor.fromHsl = function (hue, saturation, lightness, alpha, result) {\n  hue = (hue ?? 0.0) % 1.0;\n  saturation = saturation ?? 0.0;\n  lightness = lightness ?? 0.0;\n  alpha = alpha ?? 1.0;\n\n  let red = lightness;\n  let green = lightness;\n  let blue = lightness;\n\n  if (saturation !== 0) {\n    let m2;\n    if (lightness < 0.5) {\n      m2 = lightness * (1 + saturation);\n    } else {\n      m2 = lightness + saturation - lightness * saturation;\n    }\n\n    const m1 = 2.0 * lightness - m2;\n    red = hue2rgb(m1, m2, hue + 1 / 3);\n    green = hue2rgb(m1, m2, hue);\n    blue = hue2rgb(m1, m2, hue - 1 / 3);\n  }\n\n  if (!defined(result)) {\n    return new Color(red, green, blue, alpha);\n  }\n\n  result.red = red;\n  result.green = green;\n  result.blue = blue;\n  result.alpha = alpha;\n  return result;\n};\n\n/**\n * Creates a random color using the provided options. For reproducible random colors, you should\n * call {@link CesiumMath#setRandomNumberSeed} once at the beginning of your application.\n *\n * @param {object} [options] Object with the following properties:\n * @param {number} [options.red] If specified, the red component to use instead of a randomized value.\n * @param {number} [options.minimumRed=0.0] The maximum red value to generate if none was specified.\n * @param {number} [options.maximumRed=1.0] The minimum red value to generate if none was specified.\n * @param {number} [options.green] If specified, the green component to use instead of a randomized value.\n * @param {number} [options.minimumGreen=0.0] The maximum green value to generate if none was specified.\n * @param {number} [options.maximumGreen=1.0] The minimum green value to generate if none was specified.\n * @param {number} [options.blue] If specified, the blue component to use instead of a randomized value.\n * @param {number} [options.minimumBlue=0.0] The maximum blue value to generate if none was specified.\n * @param {number} [options.maximumBlue=1.0] The minimum blue value to generate if none was specified.\n * @param {number} [options.alpha] If specified, the alpha component to use instead of a randomized value.\n * @param {number} [options.minimumAlpha=0.0] The maximum alpha value to generate if none was specified.\n * @param {number} [options.maximumAlpha=1.0] The minimum alpha value to generate if none was specified.\n * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.\n * @returns {Color} The modified result parameter or a new instance if result was undefined.\n *\n * @exception {DeveloperError} minimumRed must be less than or equal to maximumRed.\n * @exception {DeveloperError} minimumGreen must be less than or equal to maximumGreen.\n * @exception {DeveloperError} minimumBlue must be less than or equal to maximumBlue.\n * @exception {DeveloperError} minimumAlpha must be less than or equal to maximumAlpha.\n *\n * @example\n * //Create a completely random color\n * const color = Cesium.Color.fromRandom();\n *\n * //Create a random shade of yellow.\n * const color1 = Cesium.Color.fromRandom({\n *     red : 1.0,\n *     green : 1.0,\n *     alpha : 1.0\n * });\n *\n * //Create a random bright color.\n * const color2 = Cesium.Color.fromRandom({\n *     minimumRed : 0.75,\n *     minimumGreen : 0.75,\n *     minimumBlue : 0.75,\n *     alpha : 1.0\n * });\n */\nColor.fromRandom = function (options, result) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  let red = options.red;\n  if (!defined(red)) {\n    const minimumRed = options.minimumRed ?? 0;\n    const maximumRed = options.maximumRed ?? 1.0;\n\n    //>>includeStart('debug', pragmas.debug);\n    Check.typeOf.number.lessThanOrEquals(\"minimumRed\", minimumRed, maximumRed);\n    //>>includeEnd('debug');\n\n    red =\n      minimumRed + CesiumMath.nextRandomNumber() * (maximumRed - minimumRed);\n  }\n\n  let green = options.green;\n  if (!defined(green)) {\n    const minimumGreen = options.minimumGreen ?? 0;\n    const maximumGreen = options.maximumGreen ?? 1.0;\n\n    //>>includeStart('debug', pragmas.debug);\n    Check.typeOf.number.lessThanOrEquals(\n      \"minimumGreen\",\n      minimumGreen,\n      maximumGreen,\n    );\n    //>>includeEnd('debug');\n    green =\n      minimumGreen +\n      CesiumMath.nextRandomNumber() * (maximumGreen - minimumGreen);\n  }\n\n  let blue = options.blue;\n  if (!defined(blue)) {\n    const minimumBlue = options.minimumBlue ?? 0;\n    const maximumBlue = options.maximumBlue ?? 1.0;\n\n    //>>includeStart('debug', pragmas.debug);\n    Check.typeOf.number.lessThanOrEquals(\n      \"minimumBlue\",\n      minimumBlue,\n      maximumBlue,\n    );\n    //>>includeEnd('debug');\n\n    blue =\n      minimumBlue + CesiumMath.nextRandomNumber() * (maximumBlue - minimumBlue);\n  }\n\n  let alpha = options.alpha;\n  if (!defined(alpha)) {\n    const minimumAlpha = options.minimumAlpha ?? 0;\n    const maximumAlpha = options.maximumAlpha ?? 1.0;\n\n    //>>includeStart('debug', pragmas.debug);\n    Check.typeOf.number.lessThanOrEquals(\n      \"minimumAlpha\",\n      minimumAlpha,\n      maximumAlpha,\n    );\n    //>>includeEnd('debug');\n\n    alpha =\n      minimumAlpha +\n      CesiumMath.nextRandomNumber() * (maximumAlpha - minimumAlpha);\n  }\n\n  if (!defined(result)) {\n    return new Color(red, green, blue, alpha);\n  }\n\n  result.red = red;\n  result.green = green;\n  result.blue = blue;\n  result.alpha = alpha;\n  return result;\n};\n\n//#rgba\nconst rgbaMatcher = /^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i;\n//#rrggbbaa\nconst rrggbbaaMatcher =\n  /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;\n//rgb(), rgba(), or rgb%()\nconst rgbParenthesesMatcher =\n  /^rgba?\\s*\\(\\s*([0-9.]+%?)\\s*[,\\s]+\\s*([0-9.]+%?)\\s*[,\\s]+\\s*([0-9.]+%?)(?:\\s*[,\\s/]+\\s*([0-9.]+))?\\s*\\)$/i;\n//hsl() or hsla()\nconst hslParenthesesMatcher =\n  /^hsla?\\s*\\(\\s*([0-9.]+)\\s*[,\\s]+\\s*([0-9.]+%)\\s*[,\\s]+\\s*([0-9.]+%)(?:\\s*[,\\s/]+\\s*([0-9.]+))?\\s*\\)$/i;\n\n/**\n * Creates a Color instance from a CSS color value.\n *\n * @param {string} color The CSS color value in #rgb, #rgba, #rrggbb, #rrggbbaa, rgb(), rgba(), hsl(), or hsla() format.\n * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.\n * @returns {Color} The color object, or undefined if the string was not a valid CSS color.\n *\n *\n * @example\n * const cesiumBlue = Cesium.Color.fromCssColorString('#67ADDF');\n * const green = Cesium.Color.fromCssColorString('green');\n *\n * @see {@link http://www.w3.org/TR/css3-color|CSS color values}\n */\nColor.fromCssColorString = function (color, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"color\", color);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Color();\n  }\n\n  // Remove all surrounding whitespaces from the color string\n  color = color.trim();\n\n  const namedColor = Color[color.toUpperCase()];\n  if (defined(namedColor)) {\n    Color.clone(namedColor, result);\n    return result;\n  }\n\n  let matches = rgbaMatcher.exec(color);\n  if (matches !== null) {\n    result.red = parseInt(matches[1], 16) / 15;\n    result.green = parseInt(matches[2], 16) / 15.0;\n    result.blue = parseInt(matches[3], 16) / 15.0;\n    result.alpha = parseInt(matches[4] ?? \"f\", 16) / 15.0;\n    return result;\n  }\n\n  matches = rrggbbaaMatcher.exec(color);\n  if (matches !== null) {\n    result.red = parseInt(matches[1], 16) / 255.0;\n    result.green = parseInt(matches[2], 16) / 255.0;\n    result.blue = parseInt(matches[3], 16) / 255.0;\n    result.alpha = parseInt(matches[4] ?? \"ff\", 16) / 255.0;\n    return result;\n  }\n\n  matches = rgbParenthesesMatcher.exec(color);\n  if (matches !== null) {\n    result.red =\n      parseFloat(matches[1]) / (\"%\" === matches[1].substr(-1) ? 100.0 : 255.0);\n    result.green =\n      parseFloat(matches[2]) / (\"%\" === matches[2].substr(-1) ? 100.0 : 255.0);\n    result.blue =\n      parseFloat(matches[3]) / (\"%\" === matches[3].substr(-1) ? 100.0 : 255.0);\n    result.alpha = parseFloat(matches[4] ?? \"1.0\");\n    return result;\n  }\n\n  matches = hslParenthesesMatcher.exec(color);\n  if (matches !== null) {\n    return Color.fromHsl(\n      parseFloat(matches[1]) / 360.0,\n      parseFloat(matches[2]) / 100.0,\n      parseFloat(matches[3]) / 100.0,\n      parseFloat(matches[4] ?? \"1.0\"),\n      result,\n    );\n  }\n\n  result = undefined;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nColor.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Color} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nColor.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n  array[startingIndex++] = value.red;\n  array[startingIndex++] = value.green;\n  array[startingIndex++] = value.blue;\n  array[startingIndex] = value.alpha;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Color} [result] The object into which to store the result.\n * @returns {Color} The modified result parameter or a new Color instance if one was not provided.\n */\nColor.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n  if (!defined(result)) {\n    result = new Color();\n  }\n  result.red = array[startingIndex++];\n  result.green = array[startingIndex++];\n  result.blue = array[startingIndex++];\n  result.alpha = array[startingIndex];\n  return result;\n};\n\n/**\n * Converts a 'byte' color component in the range of 0 to 255 into\n * a 'float' color component in the range of 0 to 1.0.\n *\n * @param {number} number The number to be converted.\n * @returns {number} The converted number.\n */\nColor.byteToFloat = function (number) {\n  return number / 255.0;\n};\n\n/**\n * Converts a 'float' color component in the range of 0 to 1.0 into\n * a 'byte' color component in the range of 0 to 255.\n *\n * @param {number} number The number to be converted.\n * @returns {number} The converted number.\n */\nColor.floatToByte = function (number) {\n  return number === 1.0 ? 255.0 : (number * 256.0) | 0;\n};\n\n/**\n * Duplicates a Color.\n *\n * @param {Color} color The Color to duplicate.\n * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.\n * @returns {Color} The modified result parameter or a new instance if result was undefined. (Returns undefined if color is undefined)\n */\nColor.clone = function (color, result) {\n  if (!defined(color)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Color(color.red, color.green, color.blue, color.alpha);\n  }\n  result.red = color.red;\n  result.green = color.green;\n  result.blue = color.blue;\n  result.alpha = color.alpha;\n  return result;\n};\n\n/**\n * Returns true if the first Color equals the second color.\n *\n * @param {Color} [left] The first Color to compare for equality.\n * @param {Color} [right] The second Color to compare for equality.\n * @returns {boolean} <code>true</code> if the Colors are equal; otherwise, <code>false</code>.\n */\nColor.equals = function (left, right) {\n  return (\n    left === right || //\n    (defined(left) && //\n      defined(right) && //\n      left.red === right.red && //\n      left.green === right.green && //\n      left.blue === right.blue && //\n      left.alpha === right.alpha)\n  );\n};\n\n/**\n * @private\n */\nColor.equalsArray = function (color, array, offset) {\n  return (\n    color.red === array[offset] &&\n    color.green === array[offset + 1] &&\n    color.blue === array[offset + 2] &&\n    color.alpha === array[offset + 3]\n  );\n};\n\n/**\n * Returns a duplicate of a Color instance.\n *\n * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.\n * @returns {Color} The modified result parameter or a new instance if result was undefined.\n */\nColor.prototype.clone = function (result) {\n  return Color.clone(this, result);\n};\n\n/**\n * Returns true if this Color equals other.\n *\n * @param {Color} [other] The Color to compare for equality.\n * @returns {boolean} <code>true</code> if the Colors are equal; otherwise, <code>false</code>.\n */\nColor.prototype.equals = function (other) {\n  return Color.equals(this, other);\n};\n\n/**\n * Returns <code>true</code> if this Color equals other componentwise within the specified epsilon.\n *\n * @param {Color} other The Color to compare for equality.\n * @param {number} [epsilon=0.0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if the Colors are equal within the specified epsilon; otherwise, <code>false</code>.\n */\nColor.prototype.equalsEpsilon = function (other, epsilon) {\n  return (\n    this === other || //\n    (defined(other) && //\n      Math.abs(this.red - other.red) <= epsilon && //\n      Math.abs(this.green - other.green) <= epsilon && //\n      Math.abs(this.blue - other.blue) <= epsilon && //\n      Math.abs(this.alpha - other.alpha) <= epsilon)\n  );\n};\n\n/**\n * Creates a string representing this Color in the format '(red, green, blue, alpha)'.\n *\n * @returns {string} A string representing this Color in the format '(red, green, blue, alpha)'.\n */\nColor.prototype.toString = function () {\n  return `(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;\n};\n\n/**\n * Creates a string containing the CSS color value for this color.\n *\n * @returns {string} The CSS equivalent of this color.\n *\n * @see {@link http://www.w3.org/TR/css3-color/#rgba-color|CSS RGB or RGBA color values}\n */\nColor.prototype.toCssColorString = function () {\n  const red = Color.floatToByte(this.red);\n  const green = Color.floatToByte(this.green);\n  const blue = Color.floatToByte(this.blue);\n  if (this.alpha === 1) {\n    return `rgb(${red},${green},${blue})`;\n  }\n  return `rgba(${red},${green},${blue},${this.alpha})`;\n};\n\n/**\n * Creates a string containing CSS hex string color value for this color.\n *\n * @returns {string} The CSS hex string equivalent of this color.\n */\nColor.prototype.toCssHexString = function () {\n  let r = Color.floatToByte(this.red).toString(16);\n  if (r.length < 2) {\n    r = `0${r}`;\n  }\n  let g = Color.floatToByte(this.green).toString(16);\n  if (g.length < 2) {\n    g = `0${g}`;\n  }\n  let b = Color.floatToByte(this.blue).toString(16);\n  if (b.length < 2) {\n    b = `0${b}`;\n  }\n  if (this.alpha < 1) {\n    let hexAlpha = Color.floatToByte(this.alpha).toString(16);\n    if (hexAlpha.length < 2) {\n      hexAlpha = `0${hexAlpha}`;\n    }\n    return `#${r}${g}${b}${hexAlpha}`;\n  }\n  return `#${r}${g}${b}`;\n};\n\n/**\n * Converts this color to an array of red, green, blue, and alpha values\n * that are in the range of 0 to 255.\n *\n * @param {number[]} [result] The array to store the result in, if undefined a new instance will be created.\n * @returns {number[]} The modified result parameter or a new instance if result was undefined.\n */\nColor.prototype.toBytes = function (result) {\n  const red = Color.floatToByte(this.red);\n  const green = Color.floatToByte(this.green);\n  const blue = Color.floatToByte(this.blue);\n  const alpha = Color.floatToByte(this.alpha);\n\n  if (!defined(result)) {\n    return [red, green, blue, alpha];\n  }\n  result[0] = red;\n  result[1] = green;\n  result[2] = blue;\n  result[3] = alpha;\n  return result;\n};\n\n/**\n * Converts RGBA values in bytes to a single numeric unsigned 32-bit RGBA value, using the endianness\n * of the system.\n *\n * @returns {number} A single numeric unsigned 32-bit RGBA value.\n *\n * @see Color.toRgba\n */\nColor.bytesToRgba = function (red, green, blue, alpha) {\n  // scratchUint32Array and scratchUint8Array share an underlying array buffer\n  scratchUint8Array[0] = red;\n  scratchUint8Array[1] = green;\n  scratchUint8Array[2] = blue;\n  scratchUint8Array[3] = alpha;\n  return scratchUint32Array[0];\n};\n\n/**\n * Converts this color to a single numeric unsigned 32-bit RGBA value, using the endianness\n * of the system.\n *\n * @returns {number} A single numeric unsigned 32-bit RGBA value.\n *\n *\n * @example\n * const rgba = Cesium.Color.BLUE.toRgba();\n *\n * @see Color.fromRgba\n */\nColor.prototype.toRgba = function () {\n  return Color.bytesToRgba(\n    Color.floatToByte(this.red),\n    Color.floatToByte(this.green),\n    Color.floatToByte(this.blue),\n    Color.floatToByte(this.alpha),\n  );\n};\n\n/**\n * Brightens this color by the provided magnitude.\n *\n * @param {number} magnitude A positive number indicating the amount to brighten.\n * @param {Color} result The object onto which to store the result.\n * @returns {Color} The modified result parameter.\n *\n * @example\n * const brightBlue = Cesium.Color.BLUE.brighten(0.5, new Cesium.Color());\n */\nColor.prototype.brighten = function (magnitude, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"magnitude\", magnitude);\n  Check.typeOf.number.greaterThanOrEquals(\"magnitude\", magnitude, 0.0);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  magnitude = 1.0 - magnitude;\n  result.red = 1.0 - (1.0 - this.red) * magnitude;\n  result.green = 1.0 - (1.0 - this.green) * magnitude;\n  result.blue = 1.0 - (1.0 - this.blue) * magnitude;\n  result.alpha = this.alpha;\n  return result;\n};\n\n/**\n * Darkens this color by the provided magnitude.\n *\n * @param {number} magnitude A positive number indicating the amount to darken.\n * @param {Color} result The object onto which to store the result.\n * @returns {Color} The modified result parameter.\n *\n * @example\n * const darkBlue = Cesium.Color.BLUE.darken(0.5, new Cesium.Color());\n */\nColor.prototype.darken = function (magnitude, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"magnitude\", magnitude);\n  Check.typeOf.number.greaterThanOrEquals(\"magnitude\", magnitude, 0.0);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  magnitude = 1.0 - magnitude;\n  result.red = this.red * magnitude;\n  result.green = this.green * magnitude;\n  result.blue = this.blue * magnitude;\n  result.alpha = this.alpha;\n  return result;\n};\n\n/**\n * Creates a new Color that has the same red, green, and blue components\n * as this Color, but with the specified alpha value.\n *\n * @param {number} alpha The new alpha component.\n * @param {Color} [result] The object onto which to store the result.\n * @returns {Color} The modified result parameter or a new Color instance if one was not provided.\n *\n * @example const translucentRed = Cesium.Color.RED.withAlpha(0.9);\n */\nColor.prototype.withAlpha = function (alpha, result) {\n  return Color.fromAlpha(this, alpha, result);\n};\n\n/**\n * Computes the componentwise sum of two Colors.\n *\n * @param {Color} left The first Color.\n * @param {Color} right The second Color.\n * @param {Color} result The object onto which to store the result.\n * @returns {Color} The modified result parameter.\n */\nColor.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.red = left.red + right.red;\n  result.green = left.green + right.green;\n  result.blue = left.blue + right.blue;\n  result.alpha = left.alpha + right.alpha;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Colors.\n *\n * @param {Color} left The first Color.\n * @param {Color} right The second Color.\n * @param {Color} result The object onto which to store the result.\n * @returns {Color} The modified result parameter.\n */\nColor.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.red = left.red - right.red;\n  result.green = left.green - right.green;\n  result.blue = left.blue - right.blue;\n  result.alpha = left.alpha - right.alpha;\n  return result;\n};\n\n/**\n * Computes the componentwise product of two Colors.\n *\n * @param {Color} left The first Color.\n * @param {Color} right The second Color.\n * @param {Color} result The object onto which to store the result.\n * @returns {Color} The modified result parameter.\n */\nColor.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.red = left.red * right.red;\n  result.green = left.green * right.green;\n  result.blue = left.blue * right.blue;\n  result.alpha = left.alpha * right.alpha;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Colors.\n *\n * @param {Color} left The first Color.\n * @param {Color} right The second Color.\n * @param {Color} result The object onto which to store the result.\n * @returns {Color} The modified result parameter.\n */\nColor.divide = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.red = left.red / right.red;\n  result.green = left.green / right.green;\n  result.blue = left.blue / right.blue;\n  result.alpha = left.alpha / right.alpha;\n  return result;\n};\n\n/**\n * Computes the componentwise modulus of two Colors.\n *\n * @param {Color} left The first Color.\n * @param {Color} right The second Color.\n * @param {Color} result The object onto which to store the result.\n * @returns {Color} The modified result parameter.\n */\nColor.mod = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.red = left.red % right.red;\n  result.green = left.green % right.green;\n  result.blue = left.blue % right.blue;\n  result.alpha = left.alpha % right.alpha;\n  return result;\n};\n\n/**\n * Computes the linear interpolation or extrapolation at t between the provided colors.\n *\n * @param {Color} start The color corresponding to t at 0.0.\n * @param {Color} end The color corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Color} result The object onto which to store the result.\n * @returns {Color} The modified result parameter.\n */\nColor.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.red = CesiumMath.lerp(start.red, end.red, t);\n  result.green = CesiumMath.lerp(start.green, end.green, t);\n  result.blue = CesiumMath.lerp(start.blue, end.blue, t);\n  result.alpha = CesiumMath.lerp(start.alpha, end.alpha, t);\n  return result;\n};\n\n/**\n * Multiplies the provided Color componentwise by the provided scalar.\n *\n * @param {Color} color The Color to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Color} result The object onto which to store the result.\n * @returns {Color} The modified result parameter.\n */\nColor.multiplyByScalar = function (color, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"color\", color);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.red = color.red * scalar;\n  result.green = color.green * scalar;\n  result.blue = color.blue * scalar;\n  result.alpha = color.alpha * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Color componentwise by the provided scalar.\n *\n * @param {Color} color The Color to be divided.\n * @param {number} scalar The scalar to divide with.\n * @param {Color} result The object onto which to store the result.\n * @returns {Color} The modified result parameter.\n */\nColor.divideByScalar = function (color, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"color\", color);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.red = color.red / scalar;\n  result.green = color.green / scalar;\n  result.blue = color.blue / scalar;\n  result.alpha = color.alpha / scalar;\n  return result;\n};\n\n/**\n * An immutable Color instance initialized to CSS color #F0F8FF\n * <span class=\"colorSwath\" style=\"background: #F0F8FF;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.ALICEBLUE = Object.freeze(Color.fromCssColorString(\"#F0F8FF\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FAEBD7\n * <span class=\"colorSwath\" style=\"background: #FAEBD7;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.ANTIQUEWHITE = Object.freeze(Color.fromCssColorString(\"#FAEBD7\"));\n\n/**\n * An immutable Color instance initialized to CSS color #00FFFF\n * <span class=\"colorSwath\" style=\"background: #00FFFF;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.AQUA = Object.freeze(Color.fromCssColorString(\"#00FFFF\"));\n\n/**\n * An immutable Color instance initialized to CSS color #7FFFD4\n * <span class=\"colorSwath\" style=\"background: #7FFFD4;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.AQUAMARINE = Object.freeze(Color.fromCssColorString(\"#7FFFD4\"));\n\n/**\n * An immutable Color instance initialized to CSS color #F0FFFF\n * <span class=\"colorSwath\" style=\"background: #F0FFFF;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.AZURE = Object.freeze(Color.fromCssColorString(\"#F0FFFF\"));\n\n/**\n * An immutable Color instance initialized to CSS color #F5F5DC\n * <span class=\"colorSwath\" style=\"background: #F5F5DC;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.BEIGE = Object.freeze(Color.fromCssColorString(\"#F5F5DC\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFE4C4\n * <span class=\"colorSwath\" style=\"background: #FFE4C4;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.BISQUE = Object.freeze(Color.fromCssColorString(\"#FFE4C4\"));\n\n/**\n * An immutable Color instance initialized to CSS color #000000\n * <span class=\"colorSwath\" style=\"background: #000000;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.BLACK = Object.freeze(Color.fromCssColorString(\"#000000\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFEBCD\n * <span class=\"colorSwath\" style=\"background: #FFEBCD;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.BLANCHEDALMOND = Object.freeze(Color.fromCssColorString(\"#FFEBCD\"));\n\n/**\n * An immutable Color instance initialized to CSS color #0000FF\n * <span class=\"colorSwath\" style=\"background: #0000FF;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.BLUE = Object.freeze(Color.fromCssColorString(\"#0000FF\"));\n\n/**\n * An immutable Color instance initialized to CSS color #8A2BE2\n * <span class=\"colorSwath\" style=\"background: #8A2BE2;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.BLUEVIOLET = Object.freeze(Color.fromCssColorString(\"#8A2BE2\"));\n\n/**\n * An immutable Color instance initialized to CSS color #A52A2A\n * <span class=\"colorSwath\" style=\"background: #A52A2A;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.BROWN = Object.freeze(Color.fromCssColorString(\"#A52A2A\"));\n\n/**\n * An immutable Color instance initialized to CSS color #DEB887\n * <span class=\"colorSwath\" style=\"background: #DEB887;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.BURLYWOOD = Object.freeze(Color.fromCssColorString(\"#DEB887\"));\n\n/**\n * An immutable Color instance initialized to CSS color #5F9EA0\n * <span class=\"colorSwath\" style=\"background: #5F9EA0;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.CADETBLUE = Object.freeze(Color.fromCssColorString(\"#5F9EA0\"));\n/**\n * An immutable Color instance initialized to CSS color #7FFF00\n * <span class=\"colorSwath\" style=\"background: #7FFF00;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.CHARTREUSE = Object.freeze(Color.fromCssColorString(\"#7FFF00\"));\n\n/**\n * An immutable Color instance initialized to CSS color #D2691E\n * <span class=\"colorSwath\" style=\"background: #D2691E;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.CHOCOLATE = Object.freeze(Color.fromCssColorString(\"#D2691E\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FF7F50\n * <span class=\"colorSwath\" style=\"background: #FF7F50;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.CORAL = Object.freeze(Color.fromCssColorString(\"#FF7F50\"));\n\n/**\n * An immutable Color instance initialized to CSS color #6495ED\n * <span class=\"colorSwath\" style=\"background: #6495ED;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.CORNFLOWERBLUE = Object.freeze(Color.fromCssColorString(\"#6495ED\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFF8DC\n * <span class=\"colorSwath\" style=\"background: #FFF8DC;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.CORNSILK = Object.freeze(Color.fromCssColorString(\"#FFF8DC\"));\n\n/**\n * An immutable Color instance initialized to CSS color #DC143C\n * <span class=\"colorSwath\" style=\"background: #DC143C;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.CRIMSON = Object.freeze(Color.fromCssColorString(\"#DC143C\"));\n\n/**\n * An immutable Color instance initialized to CSS color #00FFFF\n * <span class=\"colorSwath\" style=\"background: #00FFFF;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.CYAN = Object.freeze(Color.fromCssColorString(\"#00FFFF\"));\n\n/**\n * An immutable Color instance initialized to CSS color #00008B\n * <span class=\"colorSwath\" style=\"background: #00008B;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKBLUE = Object.freeze(Color.fromCssColorString(\"#00008B\"));\n\n/**\n * An immutable Color instance initialized to CSS color #008B8B\n * <span class=\"colorSwath\" style=\"background: #008B8B;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKCYAN = Object.freeze(Color.fromCssColorString(\"#008B8B\"));\n\n/**\n * An immutable Color instance initialized to CSS color #B8860B\n * <span class=\"colorSwath\" style=\"background: #B8860B;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKGOLDENROD = Object.freeze(Color.fromCssColorString(\"#B8860B\"));\n\n/**\n * An immutable Color instance initialized to CSS color #A9A9A9\n * <span class=\"colorSwath\" style=\"background: #A9A9A9;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKGRAY = Object.freeze(Color.fromCssColorString(\"#A9A9A9\"));\n\n/**\n * An immutable Color instance initialized to CSS color #006400\n * <span class=\"colorSwath\" style=\"background: #006400;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKGREEN = Object.freeze(Color.fromCssColorString(\"#006400\"));\n\n/**\n * An immutable Color instance initialized to CSS color #A9A9A9\n * <span class=\"colorSwath\" style=\"background: #A9A9A9;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKGREY = Color.DARKGRAY;\n\n/**\n * An immutable Color instance initialized to CSS color #BDB76B\n * <span class=\"colorSwath\" style=\"background: #BDB76B;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKKHAKI = Object.freeze(Color.fromCssColorString(\"#BDB76B\"));\n\n/**\n * An immutable Color instance initialized to CSS color #8B008B\n * <span class=\"colorSwath\" style=\"background: #8B008B;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKMAGENTA = Object.freeze(Color.fromCssColorString(\"#8B008B\"));\n\n/**\n * An immutable Color instance initialized to CSS color #556B2F\n * <span class=\"colorSwath\" style=\"background: #556B2F;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKOLIVEGREEN = Object.freeze(Color.fromCssColorString(\"#556B2F\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FF8C00\n * <span class=\"colorSwath\" style=\"background: #FF8C00;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKORANGE = Object.freeze(Color.fromCssColorString(\"#FF8C00\"));\n\n/**\n * An immutable Color instance initialized to CSS color #9932CC\n * <span class=\"colorSwath\" style=\"background: #9932CC;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKORCHID = Object.freeze(Color.fromCssColorString(\"#9932CC\"));\n\n/**\n * An immutable Color instance initialized to CSS color #8B0000\n * <span class=\"colorSwath\" style=\"background: #8B0000;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKRED = Object.freeze(Color.fromCssColorString(\"#8B0000\"));\n\n/**\n * An immutable Color instance initialized to CSS color #E9967A\n * <span class=\"colorSwath\" style=\"background: #E9967A;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKSALMON = Object.freeze(Color.fromCssColorString(\"#E9967A\"));\n\n/**\n * An immutable Color instance initialized to CSS color #8FBC8F\n * <span class=\"colorSwath\" style=\"background: #8FBC8F;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKSEAGREEN = Object.freeze(Color.fromCssColorString(\"#8FBC8F\"));\n\n/**\n * An immutable Color instance initialized to CSS color #483D8B\n * <span class=\"colorSwath\" style=\"background: #483D8B;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKSLATEBLUE = Object.freeze(Color.fromCssColorString(\"#483D8B\"));\n\n/**\n * An immutable Color instance initialized to CSS color #2F4F4F\n * <span class=\"colorSwath\" style=\"background: #2F4F4F;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKSLATEGRAY = Object.freeze(Color.fromCssColorString(\"#2F4F4F\"));\n\n/**\n * An immutable Color instance initialized to CSS color #2F4F4F\n * <span class=\"colorSwath\" style=\"background: #2F4F4F;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKSLATEGREY = Color.DARKSLATEGRAY;\n\n/**\n * An immutable Color instance initialized to CSS color #00CED1\n * <span class=\"colorSwath\" style=\"background: #00CED1;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKTURQUOISE = Object.freeze(Color.fromCssColorString(\"#00CED1\"));\n\n/**\n * An immutable Color instance initialized to CSS color #9400D3\n * <span class=\"colorSwath\" style=\"background: #9400D3;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DARKVIOLET = Object.freeze(Color.fromCssColorString(\"#9400D3\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FF1493\n * <span class=\"colorSwath\" style=\"background: #FF1493;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DEEPPINK = Object.freeze(Color.fromCssColorString(\"#FF1493\"));\n\n/**\n * An immutable Color instance initialized to CSS color #00BFFF\n * <span class=\"colorSwath\" style=\"background: #00BFFF;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DEEPSKYBLUE = Object.freeze(Color.fromCssColorString(\"#00BFFF\"));\n\n/**\n * An immutable Color instance initialized to CSS color #696969\n * <span class=\"colorSwath\" style=\"background: #696969;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DIMGRAY = Object.freeze(Color.fromCssColorString(\"#696969\"));\n\n/**\n * An immutable Color instance initialized to CSS color #696969\n * <span class=\"colorSwath\" style=\"background: #696969;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DIMGREY = Color.DIMGRAY;\n\n/**\n * An immutable Color instance initialized to CSS color #1E90FF\n * <span class=\"colorSwath\" style=\"background: #1E90FF;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.DODGERBLUE = Object.freeze(Color.fromCssColorString(\"#1E90FF\"));\n\n/**\n * An immutable Color instance initialized to CSS color #B22222\n * <span class=\"colorSwath\" style=\"background: #B22222;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.FIREBRICK = Object.freeze(Color.fromCssColorString(\"#B22222\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFFAF0\n * <span class=\"colorSwath\" style=\"background: #FFFAF0;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.FLORALWHITE = Object.freeze(Color.fromCssColorString(\"#FFFAF0\"));\n\n/**\n * An immutable Color instance initialized to CSS color #228B22\n * <span class=\"colorSwath\" style=\"background: #228B22;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.FORESTGREEN = Object.freeze(Color.fromCssColorString(\"#228B22\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FF00FF\n * <span class=\"colorSwath\" style=\"background: #FF00FF;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.FUCHSIA = Object.freeze(Color.fromCssColorString(\"#FF00FF\"));\n\n/**\n * An immutable Color instance initialized to CSS color #DCDCDC\n * <span class=\"colorSwath\" style=\"background: #DCDCDC;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.GAINSBORO = Object.freeze(Color.fromCssColorString(\"#DCDCDC\"));\n\n/**\n * An immutable Color instance initialized to CSS color #F8F8FF\n * <span class=\"colorSwath\" style=\"background: #F8F8FF;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.GHOSTWHITE = Object.freeze(Color.fromCssColorString(\"#F8F8FF\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFD700\n * <span class=\"colorSwath\" style=\"background: #FFD700;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.GOLD = Object.freeze(Color.fromCssColorString(\"#FFD700\"));\n\n/**\n * An immutable Color instance initialized to CSS color #DAA520\n * <span class=\"colorSwath\" style=\"background: #DAA520;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.GOLDENROD = Object.freeze(Color.fromCssColorString(\"#DAA520\"));\n\n/**\n * An immutable Color instance initialized to CSS color #808080\n * <span class=\"colorSwath\" style=\"background: #808080;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.GRAY = Object.freeze(Color.fromCssColorString(\"#808080\"));\n\n/**\n * An immutable Color instance initialized to CSS color #008000\n * <span class=\"colorSwath\" style=\"background: #008000;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.GREEN = Object.freeze(Color.fromCssColorString(\"#008000\"));\n\n/**\n * An immutable Color instance initialized to CSS color #ADFF2F\n * <span class=\"colorSwath\" style=\"background: #ADFF2F;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.GREENYELLOW = Object.freeze(Color.fromCssColorString(\"#ADFF2F\"));\n\n/**\n * An immutable Color instance initialized to CSS color #808080\n * <span class=\"colorSwath\" style=\"background: #808080;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.GREY = Color.GRAY;\n\n/**\n * An immutable Color instance initialized to CSS color #F0FFF0\n * <span class=\"colorSwath\" style=\"background: #F0FFF0;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.HONEYDEW = Object.freeze(Color.fromCssColorString(\"#F0FFF0\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FF69B4\n * <span class=\"colorSwath\" style=\"background: #FF69B4;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.HOTPINK = Object.freeze(Color.fromCssColorString(\"#FF69B4\"));\n\n/**\n * An immutable Color instance initialized to CSS color #CD5C5C\n * <span class=\"colorSwath\" style=\"background: #CD5C5C;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.INDIANRED = Object.freeze(Color.fromCssColorString(\"#CD5C5C\"));\n\n/**\n * An immutable Color instance initialized to CSS color #4B0082\n * <span class=\"colorSwath\" style=\"background: #4B0082;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.INDIGO = Object.freeze(Color.fromCssColorString(\"#4B0082\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFFFF0\n * <span class=\"colorSwath\" style=\"background: #FFFFF0;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.IVORY = Object.freeze(Color.fromCssColorString(\"#FFFFF0\"));\n\n/**\n * An immutable Color instance initialized to CSS color #F0E68C\n * <span class=\"colorSwath\" style=\"background: #F0E68C;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.KHAKI = Object.freeze(Color.fromCssColorString(\"#F0E68C\"));\n\n/**\n * An immutable Color instance initialized to CSS color #E6E6FA\n * <span class=\"colorSwath\" style=\"background: #E6E6FA;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LAVENDER = Object.freeze(Color.fromCssColorString(\"#E6E6FA\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFF0F5\n * <span class=\"colorSwath\" style=\"background: #FFF0F5;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LAVENDAR_BLUSH = Object.freeze(Color.fromCssColorString(\"#FFF0F5\"));\n\n/**\n * An immutable Color instance initialized to CSS color #7CFC00\n * <span class=\"colorSwath\" style=\"background: #7CFC00;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LAWNGREEN = Object.freeze(Color.fromCssColorString(\"#7CFC00\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFFACD\n * <span class=\"colorSwath\" style=\"background: #FFFACD;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LEMONCHIFFON = Object.freeze(Color.fromCssColorString(\"#FFFACD\"));\n\n/**\n * An immutable Color instance initialized to CSS color #ADD8E6\n * <span class=\"colorSwath\" style=\"background: #ADD8E6;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LIGHTBLUE = Object.freeze(Color.fromCssColorString(\"#ADD8E6\"));\n\n/**\n * An immutable Color instance initialized to CSS color #F08080\n * <span class=\"colorSwath\" style=\"background: #F08080;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LIGHTCORAL = Object.freeze(Color.fromCssColorString(\"#F08080\"));\n\n/**\n * An immutable Color instance initialized to CSS color #E0FFFF\n * <span class=\"colorSwath\" style=\"background: #E0FFFF;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LIGHTCYAN = Object.freeze(Color.fromCssColorString(\"#E0FFFF\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FAFAD2\n * <span class=\"colorSwath\" style=\"background: #FAFAD2;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LIGHTGOLDENRODYELLOW = Object.freeze(Color.fromCssColorString(\"#FAFAD2\"));\n\n/**\n * An immutable Color instance initialized to CSS color #D3D3D3\n * <span class=\"colorSwath\" style=\"background: #D3D3D3;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LIGHTGRAY = Object.freeze(Color.fromCssColorString(\"#D3D3D3\"));\n\n/**\n * An immutable Color instance initialized to CSS color #90EE90\n * <span class=\"colorSwath\" style=\"background: #90EE90;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LIGHTGREEN = Object.freeze(Color.fromCssColorString(\"#90EE90\"));\n\n/**\n * An immutable Color instance initialized to CSS color #D3D3D3\n * <span class=\"colorSwath\" style=\"background: #D3D3D3;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LIGHTGREY = Color.LIGHTGRAY;\n\n/**\n * An immutable Color instance initialized to CSS color #FFB6C1\n * <span class=\"colorSwath\" style=\"background: #FFB6C1;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LIGHTPINK = Object.freeze(Color.fromCssColorString(\"#FFB6C1\"));\n\n/**\n * An immutable Color instance initialized to CSS color #20B2AA\n * <span class=\"colorSwath\" style=\"background: #20B2AA;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LIGHTSEAGREEN = Object.freeze(Color.fromCssColorString(\"#20B2AA\"));\n\n/**\n * An immutable Color instance initialized to CSS color #87CEFA\n * <span class=\"colorSwath\" style=\"background: #87CEFA;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LIGHTSKYBLUE = Object.freeze(Color.fromCssColorString(\"#87CEFA\"));\n\n/**\n * An immutable Color instance initialized to CSS color #778899\n * <span class=\"colorSwath\" style=\"background: #778899;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LIGHTSLATEGRAY = Object.freeze(Color.fromCssColorString(\"#778899\"));\n\n/**\n * An immutable Color instance initialized to CSS color #778899\n * <span class=\"colorSwath\" style=\"background: #778899;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LIGHTSLATEGREY = Color.LIGHTSLATEGRAY;\n\n/**\n * An immutable Color instance initialized to CSS color #B0C4DE\n * <span class=\"colorSwath\" style=\"background: #B0C4DE;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LIGHTSTEELBLUE = Object.freeze(Color.fromCssColorString(\"#B0C4DE\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFFFE0\n * <span class=\"colorSwath\" style=\"background: #FFFFE0;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LIGHTYELLOW = Object.freeze(Color.fromCssColorString(\"#FFFFE0\"));\n\n/**\n * An immutable Color instance initialized to CSS color #00FF00\n * <span class=\"colorSwath\" style=\"background: #00FF00;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LIME = Object.freeze(Color.fromCssColorString(\"#00FF00\"));\n\n/**\n * An immutable Color instance initialized to CSS color #32CD32\n * <span class=\"colorSwath\" style=\"background: #32CD32;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LIMEGREEN = Object.freeze(Color.fromCssColorString(\"#32CD32\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FAF0E6\n * <span class=\"colorSwath\" style=\"background: #FAF0E6;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.LINEN = Object.freeze(Color.fromCssColorString(\"#FAF0E6\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FF00FF\n * <span class=\"colorSwath\" style=\"background: #FF00FF;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.MAGENTA = Object.freeze(Color.fromCssColorString(\"#FF00FF\"));\n\n/**\n * An immutable Color instance initialized to CSS color #800000\n * <span class=\"colorSwath\" style=\"background: #800000;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.MAROON = Object.freeze(Color.fromCssColorString(\"#800000\"));\n\n/**\n * An immutable Color instance initialized to CSS color #66CDAA\n * <span class=\"colorSwath\" style=\"background: #66CDAA;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.MEDIUMAQUAMARINE = Object.freeze(Color.fromCssColorString(\"#66CDAA\"));\n\n/**\n * An immutable Color instance initialized to CSS color #0000CD\n * <span class=\"colorSwath\" style=\"background: #0000CD;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.MEDIUMBLUE = Object.freeze(Color.fromCssColorString(\"#0000CD\"));\n\n/**\n * An immutable Color instance initialized to CSS color #BA55D3\n * <span class=\"colorSwath\" style=\"background: #BA55D3;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.MEDIUMORCHID = Object.freeze(Color.fromCssColorString(\"#BA55D3\"));\n\n/**\n * An immutable Color instance initialized to CSS color #9370DB\n * <span class=\"colorSwath\" style=\"background: #9370DB;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.MEDIUMPURPLE = Object.freeze(Color.fromCssColorString(\"#9370DB\"));\n\n/**\n * An immutable Color instance initialized to CSS color #3CB371\n * <span class=\"colorSwath\" style=\"background: #3CB371;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.MEDIUMSEAGREEN = Object.freeze(Color.fromCssColorString(\"#3CB371\"));\n\n/**\n * An immutable Color instance initialized to CSS color #7B68EE\n * <span class=\"colorSwath\" style=\"background: #7B68EE;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.MEDIUMSLATEBLUE = Object.freeze(Color.fromCssColorString(\"#7B68EE\"));\n\n/**\n * An immutable Color instance initialized to CSS color #00FA9A\n * <span class=\"colorSwath\" style=\"background: #00FA9A;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.MEDIUMSPRINGGREEN = Object.freeze(Color.fromCssColorString(\"#00FA9A\"));\n\n/**\n * An immutable Color instance initialized to CSS color #48D1CC\n * <span class=\"colorSwath\" style=\"background: #48D1CC;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.MEDIUMTURQUOISE = Object.freeze(Color.fromCssColorString(\"#48D1CC\"));\n\n/**\n * An immutable Color instance initialized to CSS color #C71585\n * <span class=\"colorSwath\" style=\"background: #C71585;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.MEDIUMVIOLETRED = Object.freeze(Color.fromCssColorString(\"#C71585\"));\n\n/**\n * An immutable Color instance initialized to CSS color #191970\n * <span class=\"colorSwath\" style=\"background: #191970;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.MIDNIGHTBLUE = Object.freeze(Color.fromCssColorString(\"#191970\"));\n\n/**\n * An immutable Color instance initialized to CSS color #F5FFFA\n * <span class=\"colorSwath\" style=\"background: #F5FFFA;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.MINTCREAM = Object.freeze(Color.fromCssColorString(\"#F5FFFA\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFE4E1\n * <span class=\"colorSwath\" style=\"background: #FFE4E1;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.MISTYROSE = Object.freeze(Color.fromCssColorString(\"#FFE4E1\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFE4B5\n * <span class=\"colorSwath\" style=\"background: #FFE4B5;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.MOCCASIN = Object.freeze(Color.fromCssColorString(\"#FFE4B5\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFDEAD\n * <span class=\"colorSwath\" style=\"background: #FFDEAD;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.NAVAJOWHITE = Object.freeze(Color.fromCssColorString(\"#FFDEAD\"));\n\n/**\n * An immutable Color instance initialized to CSS color #000080\n * <span class=\"colorSwath\" style=\"background: #000080;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.NAVY = Object.freeze(Color.fromCssColorString(\"#000080\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FDF5E6\n * <span class=\"colorSwath\" style=\"background: #FDF5E6;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.OLDLACE = Object.freeze(Color.fromCssColorString(\"#FDF5E6\"));\n\n/**\n * An immutable Color instance initialized to CSS color #808000\n * <span class=\"colorSwath\" style=\"background: #808000;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.OLIVE = Object.freeze(Color.fromCssColorString(\"#808000\"));\n\n/**\n * An immutable Color instance initialized to CSS color #6B8E23\n * <span class=\"colorSwath\" style=\"background: #6B8E23;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.OLIVEDRAB = Object.freeze(Color.fromCssColorString(\"#6B8E23\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFA500\n * <span class=\"colorSwath\" style=\"background: #FFA500;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.ORANGE = Object.freeze(Color.fromCssColorString(\"#FFA500\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FF4500\n * <span class=\"colorSwath\" style=\"background: #FF4500;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.ORANGERED = Object.freeze(Color.fromCssColorString(\"#FF4500\"));\n\n/**\n * An immutable Color instance initialized to CSS color #DA70D6\n * <span class=\"colorSwath\" style=\"background: #DA70D6;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.ORCHID = Object.freeze(Color.fromCssColorString(\"#DA70D6\"));\n\n/**\n * An immutable Color instance initialized to CSS color #EEE8AA\n * <span class=\"colorSwath\" style=\"background: #EEE8AA;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.PALEGOLDENROD = Object.freeze(Color.fromCssColorString(\"#EEE8AA\"));\n\n/**\n * An immutable Color instance initialized to CSS color #98FB98\n * <span class=\"colorSwath\" style=\"background: #98FB98;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.PALEGREEN = Object.freeze(Color.fromCssColorString(\"#98FB98\"));\n\n/**\n * An immutable Color instance initialized to CSS color #AFEEEE\n * <span class=\"colorSwath\" style=\"background: #AFEEEE;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.PALETURQUOISE = Object.freeze(Color.fromCssColorString(\"#AFEEEE\"));\n\n/**\n * An immutable Color instance initialized to CSS color #DB7093\n * <span class=\"colorSwath\" style=\"background: #DB7093;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.PALEVIOLETRED = Object.freeze(Color.fromCssColorString(\"#DB7093\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFEFD5\n * <span class=\"colorSwath\" style=\"background: #FFEFD5;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.PAPAYAWHIP = Object.freeze(Color.fromCssColorString(\"#FFEFD5\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFDAB9\n * <span class=\"colorSwath\" style=\"background: #FFDAB9;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.PEACHPUFF = Object.freeze(Color.fromCssColorString(\"#FFDAB9\"));\n\n/**\n * An immutable Color instance initialized to CSS color #CD853F\n * <span class=\"colorSwath\" style=\"background: #CD853F;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.PERU = Object.freeze(Color.fromCssColorString(\"#CD853F\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFC0CB\n * <span class=\"colorSwath\" style=\"background: #FFC0CB;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.PINK = Object.freeze(Color.fromCssColorString(\"#FFC0CB\"));\n\n/**\n * An immutable Color instance initialized to CSS color #DDA0DD\n * <span class=\"colorSwath\" style=\"background: #DDA0DD;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.PLUM = Object.freeze(Color.fromCssColorString(\"#DDA0DD\"));\n\n/**\n * An immutable Color instance initialized to CSS color #B0E0E6\n * <span class=\"colorSwath\" style=\"background: #B0E0E6;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.POWDERBLUE = Object.freeze(Color.fromCssColorString(\"#B0E0E6\"));\n\n/**\n * An immutable Color instance initialized to CSS color #800080\n * <span class=\"colorSwath\" style=\"background: #800080;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.PURPLE = Object.freeze(Color.fromCssColorString(\"#800080\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FF0000\n * <span class=\"colorSwath\" style=\"background: #FF0000;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.RED = Object.freeze(Color.fromCssColorString(\"#FF0000\"));\n\n/**\n * An immutable Color instance initialized to CSS color #BC8F8F\n * <span class=\"colorSwath\" style=\"background: #BC8F8F;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.ROSYBROWN = Object.freeze(Color.fromCssColorString(\"#BC8F8F\"));\n\n/**\n * An immutable Color instance initialized to CSS color #4169E1\n * <span class=\"colorSwath\" style=\"background: #4169E1;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.ROYALBLUE = Object.freeze(Color.fromCssColorString(\"#4169E1\"));\n\n/**\n * An immutable Color instance initialized to CSS color #8B4513\n * <span class=\"colorSwath\" style=\"background: #8B4513;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.SADDLEBROWN = Object.freeze(Color.fromCssColorString(\"#8B4513\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FA8072\n * <span class=\"colorSwath\" style=\"background: #FA8072;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.SALMON = Object.freeze(Color.fromCssColorString(\"#FA8072\"));\n\n/**\n * An immutable Color instance initialized to CSS color #F4A460\n * <span class=\"colorSwath\" style=\"background: #F4A460;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.SANDYBROWN = Object.freeze(Color.fromCssColorString(\"#F4A460\"));\n\n/**\n * An immutable Color instance initialized to CSS color #2E8B57\n * <span class=\"colorSwath\" style=\"background: #2E8B57;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.SEAGREEN = Object.freeze(Color.fromCssColorString(\"#2E8B57\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFF5EE\n * <span class=\"colorSwath\" style=\"background: #FFF5EE;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.SEASHELL = Object.freeze(Color.fromCssColorString(\"#FFF5EE\"));\n\n/**\n * An immutable Color instance initialized to CSS color #A0522D\n * <span class=\"colorSwath\" style=\"background: #A0522D;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.SIENNA = Object.freeze(Color.fromCssColorString(\"#A0522D\"));\n\n/**\n * An immutable Color instance initialized to CSS color #C0C0C0\n * <span class=\"colorSwath\" style=\"background: #C0C0C0;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.SILVER = Object.freeze(Color.fromCssColorString(\"#C0C0C0\"));\n\n/**\n * An immutable Color instance initialized to CSS color #87CEEB\n * <span class=\"colorSwath\" style=\"background: #87CEEB;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.SKYBLUE = Object.freeze(Color.fromCssColorString(\"#87CEEB\"));\n\n/**\n * An immutable Color instance initialized to CSS color #6A5ACD\n * <span class=\"colorSwath\" style=\"background: #6A5ACD;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.SLATEBLUE = Object.freeze(Color.fromCssColorString(\"#6A5ACD\"));\n\n/**\n * An immutable Color instance initialized to CSS color #708090\n * <span class=\"colorSwath\" style=\"background: #708090;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.SLATEGRAY = Object.freeze(Color.fromCssColorString(\"#708090\"));\n\n/**\n * An immutable Color instance initialized to CSS color #708090\n * <span class=\"colorSwath\" style=\"background: #708090;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.SLATEGREY = Color.SLATEGRAY;\n\n/**\n * An immutable Color instance initialized to CSS color #FFFAFA\n * <span class=\"colorSwath\" style=\"background: #FFFAFA;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.SNOW = Object.freeze(Color.fromCssColorString(\"#FFFAFA\"));\n\n/**\n * An immutable Color instance initialized to CSS color #00FF7F\n * <span class=\"colorSwath\" style=\"background: #00FF7F;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.SPRINGGREEN = Object.freeze(Color.fromCssColorString(\"#00FF7F\"));\n\n/**\n * An immutable Color instance initialized to CSS color #4682B4\n * <span class=\"colorSwath\" style=\"background: #4682B4;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.STEELBLUE = Object.freeze(Color.fromCssColorString(\"#4682B4\"));\n\n/**\n * An immutable Color instance initialized to CSS color #D2B48C\n * <span class=\"colorSwath\" style=\"background: #D2B48C;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.TAN = Object.freeze(Color.fromCssColorString(\"#D2B48C\"));\n\n/**\n * An immutable Color instance initialized to CSS color #008080\n * <span class=\"colorSwath\" style=\"background: #008080;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.TEAL = Object.freeze(Color.fromCssColorString(\"#008080\"));\n\n/**\n * An immutable Color instance initialized to CSS color #D8BFD8\n * <span class=\"colorSwath\" style=\"background: #D8BFD8;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.THISTLE = Object.freeze(Color.fromCssColorString(\"#D8BFD8\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FF6347\n * <span class=\"colorSwath\" style=\"background: #FF6347;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.TOMATO = Object.freeze(Color.fromCssColorString(\"#FF6347\"));\n\n/**\n * An immutable Color instance initialized to CSS color #40E0D0\n * <span class=\"colorSwath\" style=\"background: #40E0D0;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.TURQUOISE = Object.freeze(Color.fromCssColorString(\"#40E0D0\"));\n\n/**\n * An immutable Color instance initialized to CSS color #EE82EE\n * <span class=\"colorSwath\" style=\"background: #EE82EE;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.VIOLET = Object.freeze(Color.fromCssColorString(\"#EE82EE\"));\n\n/**\n * An immutable Color instance initialized to CSS color #F5DEB3\n * <span class=\"colorSwath\" style=\"background: #F5DEB3;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.WHEAT = Object.freeze(Color.fromCssColorString(\"#F5DEB3\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFFFFF\n * <span class=\"colorSwath\" style=\"background: #FFFFFF;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.WHITE = Object.freeze(Color.fromCssColorString(\"#FFFFFF\"));\n\n/**\n * An immutable Color instance initialized to CSS color #F5F5F5\n * <span class=\"colorSwath\" style=\"background: #F5F5F5;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.WHITESMOKE = Object.freeze(Color.fromCssColorString(\"#F5F5F5\"));\n\n/**\n * An immutable Color instance initialized to CSS color #FFFF00\n * <span class=\"colorSwath\" style=\"background: #FFFF00;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.YELLOW = Object.freeze(Color.fromCssColorString(\"#FFFF00\"));\n\n/**\n * An immutable Color instance initialized to CSS color #9ACD32\n * <span class=\"colorSwath\" style=\"background: #9ACD32;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.YELLOWGREEN = Object.freeze(Color.fromCssColorString(\"#9ACD32\"));\n\n/**\n * An immutable Color instance initialized to CSS transparent.\n * <span class=\"colorSwath\" style=\"background: transparent;\"></span>\n *\n * @constant\n * @type {Color}\n */\nColor.TRANSPARENT = Object.freeze(new Color(0, 0, 0, 0));\nexport default Color;\n"],"names":["hue2rgb","m1","m2","h","Color","red","green","blue","alpha","fromCartesian4","cartesian","result","typeOf","object","x","y","z","w","fromBytes","byteToFloat","fromAlpha","color","number","scratchArrayBuffer","scratchUint32Array","scratchUint8Array","supportsTypedArrays","ArrayBuffer","Uint32Array","Uint8Array","fromRgba","rgba","fromHsl","hue","saturation","lightness","fromRandom","options","EMPTY_OBJECT","minimumRed","maximumRed","lessThanOrEquals","nextRandomNumber","minimumGreen","maximumGreen","minimumBlue","maximumBlue","minimumAlpha","maximumAlpha","rgbaMatcher","rrggbbaaMatcher","rgbParenthesesMatcher","hslParenthesesMatcher","fromCssColorString","string","trim","namedColor","toUpperCase","clone","matches","exec","parseInt","parseFloat","substr","undefined","packedLength","pack","value","array","startingIndex","defined","unpack","floatToByte","equals","left","right","equalsArray","offset","prototype","other","equalsEpsilon","epsilon","Math","abs","toString","toCssColorString","toCssHexString","r","length","g","b","hexAlpha","toBytes","bytesToRgba","toRgba","brighten","magnitude","greaterThanOrEquals","darken","withAlpha","add","subtract","multiply","divide","mod","lerp","start","end","t","multiplyByScalar","scalar","divideByScalar","ALICEBLUE","Object","freeze","ANTIQUEWHITE","AQUA","AQUAMARINE","AZURE","BEIGE","BISQUE","BLACK","BLANCHEDALMOND","BLUE","BLUEVIOLET","BROWN","BURLYWOOD","CADETBLUE","CHARTREUSE","CHOCOLATE","CORAL","CORNFLOWERBLUE","CORNSILK","CRIMSON","CYAN","DARKBLUE","DARKCYAN","DARKGOLDENROD","DARKGRAY","DARKGREEN","DARKGREY","DARKKHAKI","DARKMAGENTA","DARKOLIVEGREEN","DARKORANGE","DARKORCHID","DARKRED","DARKSALMON","DARKSEAGREEN","DARKSLATEBLUE","DARKSLATEGRAY","DARKSLATEGREY","DARKTURQUOISE","DARKVIOLET","DEEPPINK","DEEPSKYBLUE","DIMGRAY","DIMGREY","DODGERBLUE","FIREBRICK","FLORALWHITE","FORESTGREEN","FUCHSIA","GAINSBORO","GHOSTWHITE","GOLD","GOLDENROD","GRAY","GREEN","GREENYELLOW","GREY","HONEYDEW","HOTPINK","INDIANRED","INDIGO","IVORY","KHAKI","LAVENDER","LAVENDAR_BLUSH","LAWNGREEN","LEMONCHIFFON","LIGHTBLUE","LIGHTCORAL","LIGHTCYAN","LIGHTGOLDENRODYELLOW","LIGHTGRAY","LIGHTGREEN","LIGHTGREY","LIGHTPINK","LIGHTSEAGREEN","LIGHTSKYBLUE","LIGHTSLATEGRAY","LIGHTSLATEGREY","LIGHTSTEELBLUE","LIGHTYELLOW","LIME","LIMEGREEN","LINEN","MAGENTA","MAROON","MEDIUMAQUAMARINE","MEDIUMBLUE","MEDIUMORCHID","MEDIUMPURPLE","MEDIUMSEAGREEN","MEDIUMSLATEBLUE","MEDIUMSPRINGGREEN","MEDIUMTURQUOISE","MEDIUMVIOLETRED","MIDNIGHTBLUE","MINTCREAM","MISTYROSE","MOCCASIN","NAVAJOWHITE","NAVY","OLDLACE","OLIVE","OLIVEDRAB","ORANGE","ORANGERED","ORCHID","PALEGOLDENROD","PALEGREEN","PALETURQUOISE","PALEVIOLETRED","PAPAYAWHIP","PEACHPUFF","PERU","PINK","PLUM","POWDERBLUE","PURPLE","RED","ROSYBROWN","ROYALBLUE","SADDLEBROWN","SALMON","SANDYBROWN","SEAGREEN","SEASHELL","SIENNA","SILVER","SKYBLUE","SLATEBLUE","SLATEGRAY","SLATEGREY","SNOW","SPRINGGREEN","STEELBLUE","TAN","TEAL","THISTLE","TOMATO","TURQUOISE","VIOLET","WHEAT","WHITE","WHITESMOKE","YELLOW","YELLOWGREEN","TRANSPARENT"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 26838, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/WindingOrder.js"],"sourcesContent":["import WebGLConstants from \"./WebGLConstants.js\";\n\n/**\n * Winding order defines the order of vertices for a triangle to be considered front-facing.\n *\n * @enum {number}\n */\nconst WindingOrder = {\n  /**\n   * Vertices are in clockwise order.\n   *\n   * @type {number}\n   * @constant\n   */\n  CLOCKWISE: WebGLConstants.CW,\n\n  /**\n   * Vertices are in counter-clockwise order.\n   *\n   * @type {number}\n   * @constant\n   */\n  COUNTER_CLOCKWISE: WebGLConstants.CCW,\n};\n\n/**\n * @private\n */\nWindingOrder.validate = function (windingOrder) {\n  return (\n    windingOrder === WindingOrder.CLOCKWISE ||\n    windingOrder === WindingOrder.COUNTER_CLOCKWISE\n  );\n};\n\nexport default Object.freeze(WindingOrder);\n"],"names":["WindingOrder","CLOCKWISE","CW","COUNTER_CLOCKWISE","CCW","validate","windingOrder","Object","freeze"],"mappings":";;;;AAAA;;AAEA;;;;CAIC,GACD,MAAMA,eAAe;IACnB;;;;;GAKC,GACDC,WAAW,oLAAc,CAACC,EAAE;IAE5B;;;;;GAKC,GACDC,mBAAmB,oLAAc,CAACC,GAAG;AACvC;AAEA;;CAEC,GACDJ,aAAaK,QAAQ,GAAG,SAAUC,YAAY;IAC5C,OACEA,iBAAiBN,aAAaC,SAAS,IACvCK,iBAAiBN,aAAaG,iBAAiB;AAEnD;uCAEeI,OAAOC,MAAM,CAACR","ignoreList":[0]}},
    {"offset": {"line": 26872, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/VertexFormat.js"],"sourcesContent":["import Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * A vertex format defines what attributes make up a vertex.  A VertexFormat can be provided\n * to a {@link Geometry} to request that certain properties be computed, e.g., just position,\n * position and normal, etc.\n *\n * @param {object} [options] An object with boolean properties corresponding to VertexFormat properties as shown in the code example.\n *\n * @alias VertexFormat\n * @constructor\n *\n * @example\n * // Create a vertex format with position and 2D texture coordinate attributes.\n * const format = new Cesium.VertexFormat({\n *   position : true,\n *   st : true\n * });\n *\n * @see Geometry#attributes\n * @see Packable\n */\nfunction VertexFormat(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  /**\n   * When <code>true</code>, the vertex has a 3D position attribute.\n   * <p>\n   * 64-bit floating-point (for precision).  3 components per attribute.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.position = options.position ?? false;\n\n  /**\n   * When <code>true</code>, the vertex has a normal attribute (normalized), which is commonly used for lighting.\n   * <p>\n   * 32-bit floating-point.  3 components per attribute.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.normal = options.normal ?? false;\n\n  /**\n   * When <code>true</code>, the vertex has a 2D texture coordinate attribute.\n   * <p>\n   * 32-bit floating-point.  2 components per attribute\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.st = options.st ?? false;\n\n  /**\n   * When <code>true</code>, the vertex has a bitangent attribute (normalized), which is used for tangent-space effects like bump mapping.\n   * <p>\n   * 32-bit floating-point.  3 components per attribute.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.bitangent = options.bitangent ?? false;\n\n  /**\n   * When <code>true</code>, the vertex has a tangent attribute (normalized), which is used for tangent-space effects like bump mapping.\n   * <p>\n   * 32-bit floating-point.  3 components per attribute.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.tangent = options.tangent ?? false;\n\n  /**\n   * When <code>true</code>, the vertex has an RGB color attribute.\n   * <p>\n   * 8-bit unsigned byte.  3 components per attribute.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.color = options.color ?? false;\n}\n\n/**\n * An immutable vertex format with only a position attribute.\n *\n * @type {VertexFormat}\n * @constant\n *\n * @see VertexFormat#position\n */\nVertexFormat.POSITION_ONLY = Object.freeze(\n  new VertexFormat({\n    position: true,\n  }),\n);\n\n/**\n * An immutable vertex format with position and normal attributes.\n * This is compatible with per-instance color appearances like {@link PerInstanceColorAppearance}.\n *\n * @type {VertexFormat}\n * @constant\n *\n * @see VertexFormat#position\n * @see VertexFormat#normal\n */\nVertexFormat.POSITION_AND_NORMAL = Object.freeze(\n  new VertexFormat({\n    position: true,\n    normal: true,\n  }),\n);\n\n/**\n * An immutable vertex format with position, normal, and st attributes.\n * This is compatible with {@link MaterialAppearance} when {@link MaterialAppearance#materialSupport}\n * is <code>TEXTURED/code>.\n *\n * @type {VertexFormat}\n * @constant\n *\n * @see VertexFormat#position\n * @see VertexFormat#normal\n * @see VertexFormat#st\n */\nVertexFormat.POSITION_NORMAL_AND_ST = Object.freeze(\n  new VertexFormat({\n    position: true,\n    normal: true,\n    st: true,\n  }),\n);\n\n/**\n * An immutable vertex format with position and st attributes.\n * This is compatible with {@link EllipsoidSurfaceAppearance}.\n *\n * @type {VertexFormat}\n * @constant\n *\n * @see VertexFormat#position\n * @see VertexFormat#st\n */\nVertexFormat.POSITION_AND_ST = Object.freeze(\n  new VertexFormat({\n    position: true,\n    st: true,\n  }),\n);\n\n/**\n * An immutable vertex format with position and color attributes.\n *\n * @type {VertexFormat}\n * @constant\n *\n * @see VertexFormat#position\n * @see VertexFormat#color\n */\nVertexFormat.POSITION_AND_COLOR = Object.freeze(\n  new VertexFormat({\n    position: true,\n    color: true,\n  }),\n);\n\n/**\n * An immutable vertex format with well-known attributes: position, normal, st, tangent, and bitangent.\n *\n * @type {VertexFormat}\n * @constant\n *\n * @see VertexFormat#position\n * @see VertexFormat#normal\n * @see VertexFormat#st\n * @see VertexFormat#tangent\n * @see VertexFormat#bitangent\n */\nVertexFormat.ALL = Object.freeze(\n  new VertexFormat({\n    position: true,\n    normal: true,\n    st: true,\n    tangent: true,\n    bitangent: true,\n  }),\n);\n\n/**\n * An immutable vertex format with position, normal, and st attributes.\n * This is compatible with most appearances and materials; however\n * normal and st attributes are not always required.  When this is\n * known in advance, another <code>VertexFormat</code> should be used.\n *\n * @type {VertexFormat}\n * @constant\n *\n * @see VertexFormat#position\n * @see VertexFormat#normal\n */\nVertexFormat.DEFAULT = VertexFormat.POSITION_NORMAL_AND_ST;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nVertexFormat.packedLength = 6;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {VertexFormat} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nVertexFormat.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value.position ? 1.0 : 0.0;\n  array[startingIndex++] = value.normal ? 1.0 : 0.0;\n  array[startingIndex++] = value.st ? 1.0 : 0.0;\n  array[startingIndex++] = value.tangent ? 1.0 : 0.0;\n  array[startingIndex++] = value.bitangent ? 1.0 : 0.0;\n  array[startingIndex] = value.color ? 1.0 : 0.0;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {VertexFormat} [result] The object into which to store the result.\n * @returns {VertexFormat} The modified result parameter or a new VertexFormat instance if one was not provided.\n */\nVertexFormat.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new VertexFormat();\n  }\n\n  result.position = array[startingIndex++] === 1.0;\n  result.normal = array[startingIndex++] === 1.0;\n  result.st = array[startingIndex++] === 1.0;\n  result.tangent = array[startingIndex++] === 1.0;\n  result.bitangent = array[startingIndex++] === 1.0;\n  result.color = array[startingIndex] === 1.0;\n  return result;\n};\n\n/**\n * Duplicates a VertexFormat instance.\n *\n * @param {VertexFormat} vertexFormat The vertex format to duplicate.\n * @param {VertexFormat} [result] The object onto which to store the result.\n * @returns {VertexFormat} The modified result parameter or a new VertexFormat instance if one was not provided. (Returns undefined if vertexFormat is undefined)\n */\nVertexFormat.clone = function (vertexFormat, result) {\n  if (!defined(vertexFormat)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new VertexFormat();\n  }\n\n  result.position = vertexFormat.position;\n  result.normal = vertexFormat.normal;\n  result.st = vertexFormat.st;\n  result.tangent = vertexFormat.tangent;\n  result.bitangent = vertexFormat.bitangent;\n  result.color = vertexFormat.color;\n  return result;\n};\nexport default VertexFormat;\n"],"names":["VertexFormat","options","EMPTY_OBJECT","position","normal","st","bitangent","tangent","color","POSITION_ONLY","Object","freeze","POSITION_AND_NORMAL","POSITION_NORMAL_AND_ST","POSITION_AND_ST","POSITION_AND_COLOR","ALL","DEFAULT","packedLength","pack","value","array","startingIndex","unpack","result","clone","vertexFormat","undefined"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 27139, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/createGuid.js"],"sourcesContent":["/**\n * Creates a Globally unique identifier (GUID) string.  A GUID is 128 bits long, and can guarantee uniqueness across space and time.\n *\n * @function\n *\n * @returns {string}\n *\n *\n * @example\n * this.guid = Cesium.createGuid();\n *\n * @see {@link http://www.ietf.org/rfc/rfc4122.txt|RFC 4122 A Universally Unique IDentifier (UUID) URN Namespace}\n */\nfunction createGuid() {\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\nexport default createGuid;\n"],"names":["createGuid","replace","c","r","Math","random","v","toString"],"mappings":";;;;AAAA;;;;;;;;;;;;CAYC,GACD,SAASA;IACP,oFAAoF;IACpF,OAAO,uCAAuCC,OAAO,CAAC,SAAS,SAAUC,CAAC;QACxE,MAAMC,IAAI,AAACC,KAAKC,MAAM,KAAK,KAAM;QACjC,MAAMC,IAAIJ,MAAM,MAAMC,IAAI,AAACA,IAAI,MAAO;QACtC,OAAOG,EAAEC,QAAQ,CAAC;IACpB;AACF;uCACeP","ignoreList":[0]}},
    {"offset": {"line": 27168, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/CompressedTextureBuffer.js"],"sourcesContent":["import defined from \"./defined.js\";\n\n/**\n * Describes a compressed texture and contains a compressed texture buffer.\n * @alias CompressedTextureBuffer\n * @constructor\n *\n * @param {PixelFormat} internalFormat The pixel format of the compressed texture.\n * @param {PixelDatatype} pixelDatatype The pixel datatype of the compressed texture.\n * @param {number} width The width of the texture.\n * @param {number} height The height of the texture.\n * @param {Uint8Array} buffer The compressed texture buffer.\n */\nfunction CompressedTextureBuffer(\n  internalFormat,\n  pixelDatatype,\n  width,\n  height,\n  buffer,\n) {\n  this._format = internalFormat;\n  this._datatype = pixelDatatype;\n  this._width = width;\n  this._height = height;\n  this._buffer = buffer;\n}\n\nObject.defineProperties(CompressedTextureBuffer.prototype, {\n  /**\n   * The format of the compressed texture.\n   * @type {PixelFormat}\n   * @readonly\n   * @memberof CompressedTextureBuffer.prototype\n   */\n  internalFormat: {\n    get: function () {\n      return this._format;\n    },\n  },\n  /**\n   * The datatype of the compressed texture.\n   * @type {PixelDatatype}\n   * @readonly\n   * @memberof CompressedTextureBuffer.prototype\n   */\n  pixelDatatype: {\n    get: function () {\n      return this._datatype;\n    },\n  },\n  /**\n   * The width of the texture.\n   * @type {number}\n   * @readonly\n   * @memberof CompressedTextureBuffer.prototype\n   */\n  width: {\n    get: function () {\n      return this._width;\n    },\n  },\n  /**\n   * The height of the texture.\n   * @type {number}\n   * @readonly\n   * @memberof CompressedTextureBuffer.prototype\n   */\n  height: {\n    get: function () {\n      return this._height;\n    },\n  },\n  /**\n   * The compressed texture buffer.\n   * @type {Uint8Array}\n   * @readonly\n   * @memberof CompressedTextureBuffer.prototype\n   */\n  bufferView: {\n    get: function () {\n      return this._buffer;\n    },\n  },\n  /**\n   * The compressed texture buffer. Alias for bufferView.\n   * @type {Uint8Array}\n   * @readonly\n   * @memberof CompressedTextureBuffer.prototype\n   */\n  arrayBufferView: {\n    get: function () {\n      return this._buffer;\n    },\n  },\n});\n\n/**\n * Creates a shallow clone of a compressed texture buffer.\n *\n * @param {CompressedTextureBuffer} object The compressed texture buffer to be cloned.\n * @return {CompressedTextureBuffer} A shallow clone of the compressed texture buffer.\n */\nCompressedTextureBuffer.clone = function (object) {\n  if (!defined(object)) {\n    return undefined;\n  }\n\n  return new CompressedTextureBuffer(\n    object._format,\n    object._datatype,\n    object._width,\n    object._height,\n    object._buffer,\n  );\n};\n\n/**\n * Creates a shallow clone of this compressed texture buffer.\n *\n * @return {CompressedTextureBuffer} A shallow clone of the compressed texture buffer.\n */\nCompressedTextureBuffer.prototype.clone = function () {\n  return CompressedTextureBuffer.clone(this);\n};\nexport default CompressedTextureBuffer;\n"],"names":["CompressedTextureBuffer","internalFormat","pixelDatatype","width","height","buffer","_format","_datatype","_width","_height","_buffer","Object","defineProperties","prototype","get","bufferView","arrayBufferView","clone","object","undefined"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;;CAUC,GACD,SAASA,wBACPC,cAAc,EACdC,aAAa,EACbC,KAAK,EACLC,MAAM,EACNC,MAAM;IAEN,IAAI,CAACC,OAAO,GAAGL;IACf,IAAI,CAACM,SAAS,GAAGL;IACjB,IAAI,CAACM,MAAM,GAAGL;IACd,IAAI,CAACM,OAAO,GAAGL;IACf,IAAI,CAACM,OAAO,GAAGL;AACjB;AAEAM,OAAOC,gBAAgB,CAACZ,wBAAwBa,SAAS,EAAE;IACzD;;;;;GAKC,GACDZ,gBAAgB;QACda,KAAK;YACH,OAAO,IAAI,CAACR,OAAO;QACrB;IACF;IACA;;;;;GAKC,GACDJ,eAAe;QACbY,KAAK;YACH,OAAO,IAAI,CAACP,SAAS;QACvB;IACF;IACA;;;;;GAKC,GACDJ,OAAO;QACLW,KAAK;YACH,OAAO,IAAI,CAACN,MAAM;QACpB;IACF;IACA;;;;;GAKC,GACDJ,QAAQ;QACNU,KAAK;YACH,OAAO,IAAI,CAACL,OAAO;QACrB;IACF;IACA;;;;;GAKC,GACDM,YAAY;QACVD,KAAK;YACH,OAAO,IAAI,CAACJ,OAAO;QACrB;IACF;IACA;;;;;GAKC,GACDM,iBAAiB;QACfF,KAAK;YACH,OAAO,IAAI,CAACJ,OAAO;QACrB;IACF;AACF;AAEA;;;;;CAKC,GACDV,wBAAwBiB,KAAK,GAAG,SAAUC,MAAM;IAC9C,IAAI,CAAC,IAAA,6KAAO,EAACA,SAAS;QACpB,OAAOC;IACT;IAEA,OAAO,IAAInB,wBACTkB,OAAOZ,OAAO,EACdY,OAAOX,SAAS,EAChBW,OAAOV,MAAM,EACbU,OAAOT,OAAO,EACdS,OAAOR,OAAO;AAElB;AAEA;;;;CAIC,GACDV,wBAAwBa,SAAS,CAACI,KAAK,GAAG;IACxC,OAAOjB,wBAAwBiB,KAAK,CAAC,IAAI;AAC3C;uCACejB","ignoreList":[0]}},
    {"offset": {"line": 27276, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TaskProcessor.js"],"sourcesContent":["import Uri from \"urijs\";\nimport buildModuleUrl from \"./buildModuleUrl.js\";\nimport defined from \"./defined.js\";\nimport destroyObject from \"./destroyObject.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Event from \"./Event.js\";\nimport FeatureDetection from \"./FeatureDetection.js\";\nimport isCrossOriginUrl from \"./isCrossOriginUrl.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\n\nfunction canTransferArrayBuffer() {\n  if (!defined(TaskProcessor._canTransferArrayBuffer)) {\n    const worker = createWorker(\"transferTypedArrayTest\");\n    worker.postMessage = worker.webkitPostMessage ?? worker.postMessage;\n\n    const value = 99;\n    const array = new Int8Array([value]);\n\n    try {\n      // postMessage might fail with a DataCloneError\n      // if transferring array buffers is not supported.\n      worker.postMessage(\n        {\n          array: array,\n        },\n        [array.buffer],\n      );\n    } catch (e) {\n      TaskProcessor._canTransferArrayBuffer = false;\n      return TaskProcessor._canTransferArrayBuffer;\n    }\n\n    TaskProcessor._canTransferArrayBuffer = new Promise((resolve) => {\n      worker.onmessage = function (event) {\n        const array = event.data.array;\n\n        // some versions of Firefox silently fail to transfer typed arrays.\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=841904\n        // Check to make sure the value round-trips successfully.\n        const result = defined(array) && array[0] === value;\n        resolve(result);\n\n        worker.terminate();\n\n        TaskProcessor._canTransferArrayBuffer = result;\n      };\n    });\n  }\n\n  return TaskProcessor._canTransferArrayBuffer;\n}\n\nconst taskCompletedEvent = new Event();\n\nfunction urlFromScript(script) {\n  let blob;\n  try {\n    blob = new Blob([script], {\n      type: \"application/javascript\",\n    });\n  } catch (e) {\n    const BlobBuilder =\n      window.BlobBuilder ||\n      window.WebKitBlobBuilder ||\n      window.MozBlobBuilder ||\n      window.MSBlobBuilder;\n    const blobBuilder = new BlobBuilder();\n    blobBuilder.append(script);\n    blob = blobBuilder.getBlob(\"application/javascript\");\n  }\n\n  const URL = window.URL || window.webkitURL;\n  return URL.createObjectURL(blob);\n}\n\nfunction createWorker(url) {\n  const uri = new Uri(url);\n  const isUri = uri.scheme().length !== 0 && uri.fragment().length === 0;\n  const moduleID = url.replace(/\\.js$/, \"\");\n\n  const options = {};\n  let workerPath;\n  let crossOriginUrl;\n\n  // If we are provided a fully resolved URL, check it is cross-origin\n  // Or if provided a module ID, check the full absolute URL instead.\n  if (isCrossOriginUrl(url)) {\n    crossOriginUrl = url;\n  } else if (!isUri) {\n    const moduleAbsoluteUrl = buildModuleUrl(\n      `${TaskProcessor._workerModulePrefix}/${moduleID}.js`,\n    );\n\n    if (isCrossOriginUrl(moduleAbsoluteUrl)) {\n      crossOriginUrl = moduleAbsoluteUrl;\n    }\n  }\n\n  if (crossOriginUrl) {\n    // To load cross-origin, create a shim worker from a blob URL\n    const script = `import \"${crossOriginUrl}\";`;\n    workerPath = urlFromScript(script);\n    options.type = \"module\";\n    return new Worker(workerPath, options);\n  }\n\n  /* global CESIUM_WORKERS */\n  if (!isUri && typeof CESIUM_WORKERS !== \"undefined\") {\n    // If the workers are embedded, create a shim worker from the embedded script data\n    const script = `\n      importScripts(\"${urlFromScript(CESIUM_WORKERS)}\");\n      CesiumWorkers[\"${moduleID}\"]();\n    `;\n    workerPath = urlFromScript(script);\n    return new Worker(workerPath, options);\n  }\n\n  workerPath = url;\n\n  if (!isUri) {\n    workerPath = buildModuleUrl(\n      `${TaskProcessor._workerModulePrefix + moduleID}.js`,\n    );\n  }\n\n  if (!FeatureDetection.supportsEsmWebWorkers()) {\n    throw new RuntimeError(\n      \"This browser is not supported. Please update your browser to continue.\",\n    );\n  }\n\n  options.type = \"module\";\n\n  return new Worker(workerPath, options);\n}\n\nasync function getWebAssemblyLoaderConfig(processor, wasmOptions) {\n  const config = {\n    modulePath: undefined,\n    wasmBinaryFile: undefined,\n    wasmBinary: undefined,\n  };\n\n  // Web assembly not supported, use fallback js module if provided\n  if (!FeatureDetection.supportsWebAssembly()) {\n    if (!defined(wasmOptions.fallbackModulePath)) {\n      throw new RuntimeError(\n        `This browser does not support Web Assembly, and no backup module was provided for ${processor._workerPath}`,\n      );\n    }\n\n    config.modulePath = buildModuleUrl(wasmOptions.fallbackModulePath);\n    return config;\n  }\n\n  config.wasmBinaryFile = buildModuleUrl(wasmOptions.wasmBinaryFile);\n\n  const arrayBuffer = await Resource.fetchArrayBuffer({\n    url: config.wasmBinaryFile,\n  });\n\n  config.wasmBinary = arrayBuffer;\n  return config;\n}\n\n/**\n * A wrapper around a web worker that allows scheduling tasks for a given worker,\n * returning results asynchronously via a promise.\n *\n * The Worker is not constructed until a task is scheduled.\n *\n * @alias TaskProcessor\n * @constructor\n *\n * @param {string} workerPath The Url to the worker. This can either be an absolute path or relative to the Cesium Workers folder.\n * @param {number} [maximumActiveTasks=Number.POSITIVE_INFINITY] The maximum number of active tasks.  Once exceeded,\n *                                        scheduleTask will not queue any more tasks, allowing\n *                                        work to be rescheduled in future frames.\n */\nfunction TaskProcessor(workerPath, maximumActiveTasks) {\n  this._workerPath = workerPath;\n  this._maximumActiveTasks = maximumActiveTasks ?? Number.POSITIVE_INFINITY;\n  this._activeTasks = 0;\n  this._nextID = 0;\n  this._webAssemblyPromise = undefined;\n}\n\nconst createOnmessageHandler = (worker, id, resolve, reject) => {\n  const listener = ({ data }) => {\n    if (data.id !== id) {\n      return;\n    }\n\n    if (defined(data.error)) {\n      let error = data.error;\n      if (error.name === \"RuntimeError\") {\n        error = new RuntimeError(data.error.message);\n        error.stack = data.error.stack;\n      } else if (error.name === \"DeveloperError\") {\n        error = new DeveloperError(data.error.message);\n        error.stack = data.error.stack;\n      } else if (error.name === \"Error\") {\n        error = new Error(data.error.message);\n        error.stack = data.error.stack;\n      }\n      taskCompletedEvent.raiseEvent(error);\n      reject(error);\n    } else {\n      taskCompletedEvent.raiseEvent();\n      resolve(data.result);\n    }\n\n    worker.removeEventListener(\"message\", listener);\n  };\n\n  return listener;\n};\n\nconst emptyTransferableObjectArray = [];\nasync function runTask(processor, parameters, transferableObjects) {\n  const canTransfer = await Promise.resolve(canTransferArrayBuffer());\n  if (!defined(transferableObjects)) {\n    transferableObjects = emptyTransferableObjectArray;\n  } else if (!canTransfer) {\n    transferableObjects.length = 0;\n  }\n\n  const id = processor._nextID++;\n  const promise = new Promise((resolve, reject) => {\n    processor._worker.addEventListener(\n      \"message\",\n      createOnmessageHandler(processor._worker, id, resolve, reject),\n    );\n  });\n\n  processor._worker.postMessage(\n    {\n      id: id,\n      baseUrl: buildModuleUrl.getCesiumBaseUrl().url,\n      parameters: parameters,\n      canTransferArrayBuffer: canTransfer,\n    },\n    transferableObjects,\n  );\n\n  return promise;\n}\n\nasync function scheduleTask(processor, parameters, transferableObjects) {\n  ++processor._activeTasks;\n\n  try {\n    const result = await runTask(processor, parameters, transferableObjects);\n    --processor._activeTasks;\n    return result;\n  } catch (error) {\n    --processor._activeTasks;\n    throw error;\n  }\n}\n\n/**\n * Schedule a task to be processed by the web worker asynchronously.  If there are currently more\n * tasks active than the maximum set by the constructor, will immediately return undefined.\n * Otherwise, returns a promise that will resolve to the result posted back by the worker when\n * finished.\n *\n * @param {object} parameters Any input data that will be posted to the worker.\n * @param {object[]} [transferableObjects] An array of objects contained in parameters that should be\n *                                      transferred to the worker instead of copied.\n * @returns {Promise<object>|undefined} Either a promise that will resolve to the result when available, or undefined\n *                    if there are too many active tasks,\n *\n * @example\n * const taskProcessor = new Cesium.TaskProcessor('myWorkerPath');\n * const promise = taskProcessor.scheduleTask({\n *     someParameter : true,\n *     another : 'hello'\n * });\n * if (!Cesium.defined(promise)) {\n *     // too many active tasks - try again later\n * } else {\n *     promise.then(function(result) {\n *         // use the result of the task\n *     });\n * }\n */\nTaskProcessor.prototype.scheduleTask = function (\n  parameters,\n  transferableObjects,\n) {\n  if (!defined(this._worker)) {\n    this._worker = createWorker(this._workerPath);\n  }\n\n  if (this._activeTasks >= this._maximumActiveTasks) {\n    return undefined;\n  }\n\n  return scheduleTask(this, parameters, transferableObjects);\n};\n\n/**\n * Posts a message to a web worker with configuration to initialize loading\n * and compiling a web assembly module asynchronously, as well as an optional\n * fallback JavaScript module to use if Web Assembly is not supported.\n *\n * @param {object} [webAssemblyOptions] An object with the following properties:\n * @param {string} [webAssemblyOptions.modulePath] The path of the web assembly JavaScript wrapper module.\n * @param {string} [webAssemblyOptions.wasmBinaryFile] The path of the web assembly binary file.\n * @param {string} [webAssemblyOptions.fallbackModulePath] The path of the fallback JavaScript module to use if web assembly is not supported.\n * @returns {Promise<*>} A promise that resolves to the result when the web worker has loaded and compiled the web assembly module and is ready to process tasks.\n *\n * @exception {RuntimeError} This browser does not support Web Assembly, and no backup module was provided\n */\nTaskProcessor.prototype.initWebAssemblyModule = async function (\n  webAssemblyOptions,\n) {\n  if (defined(this._webAssemblyPromise)) {\n    return this._webAssemblyPromise;\n  }\n\n  const init = async () => {\n    const worker = (this._worker = createWorker(this._workerPath));\n    const wasmConfig = await getWebAssemblyLoaderConfig(\n      this,\n      webAssemblyOptions,\n    );\n    const canTransfer = await Promise.resolve(canTransferArrayBuffer());\n    let transferableObjects;\n    const binary = wasmConfig.wasmBinary;\n    if (defined(binary) && canTransfer) {\n      transferableObjects = [binary];\n    }\n\n    const promise = new Promise((resolve, reject) => {\n      worker.onmessage = function ({ data }) {\n        if (defined(data)) {\n          resolve(data.result);\n        } else {\n          reject(new RuntimeError(\"Could not configure wasm module\"));\n        }\n      };\n    });\n\n    worker.postMessage(\n      {\n        canTransferArrayBuffer: canTransfer,\n        parameters: { webAssemblyConfig: wasmConfig },\n      },\n      transferableObjects,\n    );\n\n    return promise;\n  };\n\n  this._webAssemblyPromise = init();\n  return this._webAssemblyPromise;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see TaskProcessor#destroy\n */\nTaskProcessor.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys this object.  This will immediately terminate the Worker.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n */\nTaskProcessor.prototype.destroy = function () {\n  if (defined(this._worker)) {\n    this._worker.terminate();\n  }\n  return destroyObject(this);\n};\n\n/**\n * An event that's raised when a task is completed successfully.  Event handlers are passed\n * the error object is a task fails.\n *\n * @type {Event}\n *\n * @private\n */\nTaskProcessor.taskCompletedEvent = taskCompletedEvent;\n\n// exposed for testing purposes\nTaskProcessor._defaultWorkerModulePrefix = \"Workers/\";\nTaskProcessor._workerModulePrefix = TaskProcessor._defaultWorkerModulePrefix;\nTaskProcessor._canTransferArrayBuffer = undefined;\nexport default TaskProcessor;\n"],"names":["canTransferArrayBuffer","TaskProcessor","_canTransferArrayBuffer","worker","createWorker","postMessage","webkitPostMessage","value","array","Int8Array","buffer","e","Promise","resolve","onmessage","event","data","result","terminate","taskCompletedEvent","urlFromScript","script","blob","Blob","type","BlobBuilder","window","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","blobBuilder","append","getBlob","URL","webkitURL","createObjectURL","url","uri","isUri","scheme","length","fragment","moduleID","replace","options","workerPath","crossOriginUrl","moduleAbsoluteUrl","_workerModulePrefix","Worker","CESIUM_WORKERS","supportsEsmWebWorkers","getWebAssemblyLoaderConfig","processor","wasmOptions","config","modulePath","undefined","wasmBinaryFile","wasmBinary","supportsWebAssembly","fallbackModulePath","_workerPath","arrayBuffer","fetchArrayBuffer","maximumActiveTasks","_maximumActiveTasks","Number","POSITIVE_INFINITY","_activeTasks","_nextID","_webAssemblyPromise","createOnmessageHandler","id","reject","listener","error","name","message","stack","Error","raiseEvent","removeEventListener","emptyTransferableObjectArray","runTask","parameters","transferableObjects","canTransfer","promise","_worker","addEventListener","baseUrl","getCesiumBaseUrl","scheduleTask","prototype","initWebAssemblyModule","webAssemblyOptions","init","wasmConfig","binary","webAssemblyConfig","isDestroyed","destroy","_defaultWorkerModulePrefix"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 27616, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/KTX2Transcoder.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport CompressedTextureBuffer from \"./CompressedTextureBuffer.js\";\nimport defined from \"./defined.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\n\n/**\n * Transcodes KTX2 textures using web workers.\n *\n * @private\n */\nfunction KTX2Transcoder() {}\n\nKTX2Transcoder._transcodeTaskProcessor = new TaskProcessor(\n  \"transcodeKTX2\",\n  Number.POSITIVE_INFINITY, // KTX2 transcoding is used in place of Resource.fetchImage, so it can't reject as \"just soooo busy right now\"\n);\n\nKTX2Transcoder._readyPromise = undefined;\n\nfunction makeReadyPromise() {\n  const readyPromise = KTX2Transcoder._transcodeTaskProcessor\n    .initWebAssemblyModule({\n      wasmBinaryFile: \"ThirdParty/basis_transcoder.wasm\",\n    })\n    .then(function (result) {\n      if (result) {\n        return KTX2Transcoder._transcodeTaskProcessor;\n      }\n\n      throw new RuntimeError(\"KTX2 transcoder could not be initialized.\");\n    });\n  KTX2Transcoder._readyPromise = readyPromise;\n}\n\nKTX2Transcoder.transcode = function (ktx2Buffer, supportedTargetFormats) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"supportedTargetFormats\", supportedTargetFormats);\n  //>>includeEnd('debug');\n\n  if (!defined(KTX2Transcoder._readyPromise)) {\n    makeReadyPromise();\n  }\n\n  return KTX2Transcoder._readyPromise\n    .then(function (taskProcessor) {\n      let bufferView = ktx2Buffer;\n      if (ktx2Buffer instanceof ArrayBuffer) {\n        bufferView = new Uint8Array(ktx2Buffer);\n      }\n      const parameters = {\n        supportedTargetFormats: supportedTargetFormats,\n        ktx2Buffer: bufferView,\n      };\n      return taskProcessor.scheduleTask(parameters, [bufferView.buffer]);\n    })\n    .then(function (result) {\n      const levelsLength = result.length;\n      const faceKeys = Object.keys(result[0]);\n\n      for (let i = 0; i < levelsLength; i++) {\n        const faces = result[i];\n        for (let j = 0; j < faceKeys.length; j++) {\n          const face = faces[faceKeys[j]];\n          faces[faceKeys[j]] = new CompressedTextureBuffer(\n            face.internalFormat,\n            face.datatype,\n            face.width,\n            face.height,\n            face.levelBuffer,\n          );\n        }\n      }\n\n      // Cleaning up parsed result if it's a single image\n      if (faceKeys.length === 1) {\n        for (let i = 0; i < levelsLength; ++i) {\n          result[i] = result[i][faceKeys[0]];\n        }\n\n        if (levelsLength === 1) {\n          result = result[0];\n        }\n      }\n      return result;\n    })\n    .catch(function (error) {\n      throw error;\n    });\n};\n\nexport default KTX2Transcoder;\n"],"names":["KTX2Transcoder","_transcodeTaskProcessor","Number","POSITIVE_INFINITY","_readyPromise","undefined","makeReadyPromise","readyPromise","initWebAssemblyModule","wasmBinaryFile","then","result","transcode","ktx2Buffer","supportedTargetFormats","defined","taskProcessor","bufferView","ArrayBuffer","Uint8Array","parameters","scheduleTask","buffer","levelsLength","length","faceKeys","Object","keys","i","faces","j","face","internalFormat","datatype","width","height","levelBuffer","catch","error"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;CAIC,GACD,SAASA,kBAAkB;AAE3BA,eAAeC,uBAAuB,GAAG,IAAI,mLAAa,CACxD,iBACAC,OAAOC,iBAAiB;AAG1BH,eAAeI,aAAa,GAAGC;AAE/B,SAASC;IACP,MAAMC,eAAeP,eAAeC,uBAAuB,CACxDO,qBAAqB,CAAC;QACrBC,gBAAgB;IAClB,GACCC,IAAI,CAAC,SAAUC,MAAM;QACpB,IAAIA,QAAQ;YACV,OAAOX,eAAeC,uBAAuB;QAC/C;QAEA,MAAM,IAAI,kLAAY,CAAC;IACzB;IACFD,eAAeI,aAAa,GAAGG;AACjC;AAEAP,eAAeY,SAAS,GAAG,SAAUC,UAAU,EAAEC,sBAAsB;IACrE,yCAAyC;IACzC,2KAAK,CAACC,OAAO,CAAC,0BAA0BD;IACxC,wBAAwB;IAExB,IAAI,CAAC,IAAA,6KAAO,EAACd,eAAeI,aAAa,GAAG;QAC1CE;IACF;IAEA,OAAON,eAAeI,aAAa,CAChCM,IAAI,CAAC,SAAUM,aAAa;QAC3B,IAAIC,aAAaJ;QACjB,IAAIA,sBAAsBK,aAAa;YACrCD,aAAa,IAAIE,WAAWN;QAC9B;QACA,MAAMO,aAAa;YACjBN,wBAAwBA;YACxBD,YAAYI;QACd;QACA,OAAOD,cAAcK,YAAY,CAACD,YAAY;YAACH,WAAWK,MAAM;SAAC;IACnE,GACCZ,IAAI,CAAC,SAAUC,MAAM;QACpB,MAAMY,eAAeZ,OAAOa,MAAM;QAClC,MAAMC,WAAWC,OAAOC,IAAI,CAAChB,MAAM,CAAC,EAAE;QAEtC,IAAK,IAAIiB,IAAI,GAAGA,IAAIL,cAAcK,IAAK;YACrC,MAAMC,QAAQlB,MAAM,CAACiB,EAAE;YACvB,IAAK,IAAIE,IAAI,GAAGA,IAAIL,SAASD,MAAM,EAAEM,IAAK;gBACxC,MAAMC,OAAOF,KAAK,CAACJ,QAAQ,CAACK,EAAE,CAAC;gBAC/BD,KAAK,CAACJ,QAAQ,CAACK,EAAE,CAAC,GAAG,IAAI,6LAAuB,CAC9CC,KAAKC,cAAc,EACnBD,KAAKE,QAAQ,EACbF,KAAKG,KAAK,EACVH,KAAKI,MAAM,EACXJ,KAAKK,WAAW;YAEpB;QACF;QAEA,mDAAmD;QACnD,IAAIX,SAASD,MAAM,KAAK,GAAG;YACzB,IAAK,IAAII,IAAI,GAAGA,IAAIL,cAAc,EAAEK,EAAG;gBACrCjB,MAAM,CAACiB,EAAE,GAAGjB,MAAM,CAACiB,EAAE,CAACH,QAAQ,CAAC,EAAE,CAAC;YACpC;YAEA,IAAIF,iBAAiB,GAAG;gBACtBZ,SAASA,MAAM,CAAC,EAAE;YACpB;QACF;QACA,OAAOA;IACT,GACC0B,KAAK,CAAC,SAAUC,KAAK;QACpB,MAAMA;IACR;AACJ;uCAEetC","ignoreList":[0]}},
    {"offset": {"line": 27696, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/loadKTX2.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport Resource from \"./Resource.js\";\nimport KTX2Transcoder from \"./KTX2Transcoder.js\";\n\n/**\n * Stores the supported formats that KTX2 can transcode to. Called during context creation.\n *\n * @param {boolean} s3tc Whether or not S3TC is supported\n * @param {boolean} pvrtc Whether or not PVRTC is supported\n * @param {boolean} astc Whether or not ASTC is supported\n * @param {boolean} etc Whether or not ETC is supported\n * @param {boolean} etc1 Whether or not ETC1 is supported\n * @param {boolean} bc7 Whether or not BC7 is supported\n * @private\n */\nlet supportedTranscoderFormats;\n\nloadKTX2.setKTX2SupportedFormats = function (\n  s3tc,\n  pvrtc,\n  astc,\n  etc,\n  etc1,\n  bc7,\n) {\n  supportedTranscoderFormats = {\n    s3tc: s3tc,\n    pvrtc: pvrtc,\n    astc: astc,\n    etc: etc,\n    etc1: etc1,\n    bc7: bc7,\n  };\n};\n\n/**\n * Asynchronously loads and parses the given URL to a KTX2 file or parses the raw binary data of a KTX2 file.\n * Returns a promise that will resolve to an object containing the image buffer, width, height, and format once loaded,\n * or reject if the URL failed to load or failed to parse the data. The data is loaded\n * using XMLHttpRequest, which means that in order to make requests to another origin,\n * the server must have Cross-Origin Resource sharing (CORS) headers enabled.\n * <p>\n * The following are part of the KTX2 format specification but are not supported:\n * <ul>\n *     <li>Metadata</li>\n *     <li>3D textures</li>\n *     <li>Texture Arrays</li>\n *     <li>Video</li>\n * </ul>\n * </p>\n *\n * @function loadKTX2\n *\n * @param {Resource|string|ArrayBuffer} resourceOrUrlOrBuffer The URL of the binary data or an ArrayBuffer.\n * @returns {Promise<CompressedTextureBuffer>|undefined} A promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n *\n * @exception {RuntimeError} Invalid KTX2 file.\n * @exception {RuntimeError} KTX2 texture arrays are not supported.\n * @exception {RuntimeError} KTX2 3D textures are unsupported.\n * @exception {RuntimeError} No transcoding format target available for ETC1S compressed ktx2s.\n * @exception {RuntimeError} No transcoding format target available for UASTC compressed ktx2s.\n * @exception {RuntimeError} startTranscoding() failed.\n * @exception {RuntimeError} transcodeImage() failed.\n *\n * @example\n * // load a single URL asynchronously\n * Cesium.loadKTX2('some/url').then(function (ktx2Data) {\n *     const width = ktx2Data.width;\n *     const height = ktx2Data.height;\n *     const format = ktx2Data.internalFormat;\n *     const arrayBufferView = ktx2Data.bufferView;\n *     // use the data to create a texture\n * }).catch(function (error) {\n *     // an error occurred.\n * });\n *\n * @see {@link https://github.com/KhronosGroup/KTX-Specification|KTX file format}\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n * @private\n */\nfunction loadKTX2(resourceOrUrlOrBuffer) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"resourceOrUrlOrBuffer\", resourceOrUrlOrBuffer);\n  //>>includeEnd('debug');\n\n  let loadPromise;\n  if (\n    resourceOrUrlOrBuffer instanceof ArrayBuffer ||\n    ArrayBuffer.isView(resourceOrUrlOrBuffer)\n  ) {\n    loadPromise = Promise.resolve(resourceOrUrlOrBuffer);\n  } else {\n    const resource = Resource.createIfNeeded(resourceOrUrlOrBuffer);\n    loadPromise = resource.fetchArrayBuffer();\n  }\n\n  // load module then return\n  return loadPromise.then(function (data) {\n    return KTX2Transcoder.transcode(data, supportedTranscoderFormats);\n  });\n}\n\nexport default loadKTX2;\n"],"names":["supportedTranscoderFormats","loadKTX2","setKTX2SupportedFormats","s3tc","pvrtc","astc","etc","etc1","bc7","resourceOrUrlOrBuffer","defined","loadPromise","ArrayBuffer","isView","Promise","resolve","resource","createIfNeeded","fetchArrayBuffer","then","data","transcode"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;;;CAUC,GACD,IAAIA;AAEJC,SAASC,uBAAuB,GAAG,SACjCC,IAAI,EACJC,KAAK,EACLC,IAAI,EACJC,GAAG,EACHC,IAAI,EACJC,GAAG;IAEHR,6BAA6B;QAC3BG,MAAMA;QACNC,OAAOA;QACPC,MAAMA;QACNC,KAAKA;QACLC,MAAMA;QACNC,KAAKA;IACP;AACF;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6CC,GACD,SAASP,SAASQ,qBAAqB;IACrC,yCAAyC;IACzC,2KAAK,CAACC,OAAO,CAAC,yBAAyBD;IACvC,wBAAwB;IAExB,IAAIE;IACJ,IACEF,iCAAiCG,eACjCA,YAAYC,MAAM,CAACJ,wBACnB;QACAE,cAAcG,QAAQC,OAAO,CAACN;IAChC,OAAO;QACL,MAAMO,WAAW,8KAAQ,CAACC,cAAc,CAACR;QACzCE,cAAcK,SAASE,gBAAgB;IACzC;IAEA,0BAA0B;IAC1B,OAAOP,YAAYQ,IAAI,CAAC,SAAUC,IAAI;QACpC,OAAO,oLAAc,CAACC,SAAS,CAACD,MAAMpB;IACxC;AACF;uCAEeC","ignoreList":[0]}},
    {"offset": {"line": 27793, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/GeometryAttributes.js"],"sourcesContent":["import Frozen from \"./Frozen.js\";\n\n/**\n * Attributes, which make up a geometry's vertices.  Each property in this object corresponds to a\n * {@link GeometryAttribute} containing the attribute's data.\n * <p>\n * Attributes are always stored non-interleaved in a Geometry.\n * </p>\n *\n * @alias GeometryAttributes\n * @constructor\n */\nfunction GeometryAttributes(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  /**\n   * The 3D position attribute.\n   * <p>\n   * 64-bit floating-point (for precision).  3 components per attribute.\n   * </p>\n   *\n   * @type {GeometryAttribute|undefined}\n   *\n   * @default undefined\n   */\n  this.position = options.position;\n\n  /**\n   * The normal attribute (normalized), which is commonly used for lighting.\n   * <p>\n   * 32-bit floating-point.  3 components per attribute.\n   * </p>\n   *\n   * @type {GeometryAttribute|undefined}\n   *\n   * @default undefined\n   */\n  this.normal = options.normal;\n\n  /**\n   * The 2D texture coordinate attribute.\n   * <p>\n   * 32-bit floating-point.  2 components per attribute\n   * </p>\n   *\n   * @type {GeometryAttribute|undefined}\n   *\n   * @default undefined\n   */\n  this.st = options.st;\n\n  /**\n   * The bitangent attribute (normalized), which is used for tangent-space effects like bump mapping.\n   * <p>\n   * 32-bit floating-point.  3 components per attribute.\n   * </p>\n   *\n   * @type {GeometryAttribute|undefined}\n   *\n   * @default undefined\n   */\n  this.bitangent = options.bitangent;\n\n  /**\n   * The tangent attribute (normalized), which is used for tangent-space effects like bump mapping.\n   * <p>\n   * 32-bit floating-point.  3 components per attribute.\n   * </p>\n   *\n   * @type {GeometryAttribute|undefined}\n   *\n   * @default undefined\n   */\n  this.tangent = options.tangent;\n\n  /**\n   * The color attribute.\n   * <p>\n   * 8-bit unsigned integer. 4 components per attribute.\n   * </p>\n   *\n   * @type {GeometryAttribute|undefined}\n   *\n   * @default undefined\n   */\n  this.color = options.color;\n}\nexport default GeometryAttributes;\n"],"names":["GeometryAttributes","options","EMPTY_OBJECT","position","normal","st","bitangent","tangent","color"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;CASC,GACD,SAASA,mBAAmBC,OAAO;IACjCA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC;;;;;;;;;GASC,GACD,IAAI,CAACC,QAAQ,GAAGF,QAAQE,QAAQ;IAEhC;;;;;;;;;GASC,GACD,IAAI,CAACC,MAAM,GAAGH,QAAQG,MAAM;IAE5B;;;;;;;;;GASC,GACD,IAAI,CAACC,EAAE,GAAGJ,QAAQI,EAAE;IAEpB;;;;;;;;;GASC,GACD,IAAI,CAACC,SAAS,GAAGL,QAAQK,SAAS;IAElC;;;;;;;;;GASC,GACD,IAAI,CAACC,OAAO,GAAGN,QAAQM,OAAO;IAE9B;;;;;;;;;GASC,GACD,IAAI,CAACC,KAAK,GAAGP,QAAQO,KAAK;AAC5B;uCACeR","ignoreList":[0]}},
    {"offset": {"line": 27876, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/GeometryOffsetAttribute.js"],"sourcesContent":["/**\n * Represents which vertices should have a value of `true` for the `applyOffset` attribute\n * @private\n */\nconst GeometryOffsetAttribute = {\n  NONE: 0,\n  TOP: 1,\n  ALL: 2,\n};\nexport default Object.freeze(GeometryOffsetAttribute);\n"],"names":["GeometryOffsetAttribute","NONE","TOP","ALL","Object","freeze"],"mappings":";;;;AAAA;;;CAGC,GACD,MAAMA,0BAA0B;IAC9BC,MAAM;IACNC,KAAK;IACLC,KAAK;AACP;uCACeC,OAAOC,MAAM,CAACL","ignoreList":[0]}},
    {"offset": {"line": 27893, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/BoxGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst diffScratch = new Cartesian3();\n\n/**\n * Describes a cube centered at the origin.\n *\n * @alias BoxGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.minimum The minimum x, y, and z coordinates of the box.\n * @param {Cartesian3} options.maximum The maximum x, y, and z coordinates of the box.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @see BoxGeometry.fromDimensions\n * @see BoxGeometry.createGeometry\n * @see Packable\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Box.html|Cesium Sandcastle Box Demo}\n *\n * @example\n * const box = new Cesium.BoxGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0),\n *   minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0)\n * });\n * const geometry = Cesium.BoxGeometry.createGeometry(box);\n */\nfunction BoxGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const min = options.minimum;\n  const max = options.maximum;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const vertexFormat = options.vertexFormat ?? VertexFormat.DEFAULT;\n\n  this._minimum = Cartesian3.clone(min);\n  this._maximum = Cartesian3.clone(max);\n  this._vertexFormat = vertexFormat;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createBoxGeometry\";\n}\n\n/**\n * Creates a cube centered at the origin given its dimensions.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.dimensions The width, depth, and height of the box stored in the x, y, and z coordinates of the <code>Cartesian3</code>, respectively.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @returns {BoxGeometry}\n *\n * @exception {DeveloperError} All dimensions components must be greater than or equal to zero.\n *\n *\n * @example\n * const box = Cesium.BoxGeometry.fromDimensions({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   dimensions : new Cesium.Cartesian3(500000.0, 500000.0, 500000.0)\n * });\n * const geometry = Cesium.BoxGeometry.createGeometry(box);\n *\n * @see BoxGeometry.createGeometry\n */\nBoxGeometry.fromDimensions = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const dimensions = options.dimensions;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"dimensions\", dimensions);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.x\", dimensions.x, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.y\", dimensions.y, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.z\", dimensions.z, 0);\n  //>>includeEnd('debug');\n\n  const corner = Cartesian3.multiplyByScalar(dimensions, 0.5, new Cartesian3());\n\n  return new BoxGeometry({\n    minimum: Cartesian3.negate(corner, new Cartesian3()),\n    maximum: corner,\n    vertexFormat: options.vertexFormat,\n    offsetAttribute: options.offsetAttribute,\n  });\n};\n\n/**\n * Creates a cube from the dimensions of an AxisAlignedBoundingBox.\n *\n * @param {AxisAlignedBoundingBox} boundingBox A description of the AxisAlignedBoundingBox.\n * @returns {BoxGeometry}\n *\n *\n *\n * @example\n * const aabb = Cesium.AxisAlignedBoundingBox.fromPoints(Cesium.Cartesian3.fromDegreesArray([\n *      -72.0, 40.0,\n *      -70.0, 35.0,\n *      -75.0, 30.0,\n *      -70.0, 30.0,\n *      -68.0, 40.0\n * ]));\n * const box = Cesium.BoxGeometry.fromAxisAlignedBoundingBox(aabb);\n *\n * @see BoxGeometry.createGeometry\n */\nBoxGeometry.fromAxisAlignedBoundingBox = function (boundingBox) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundingBox\", boundingBox);\n  //>>includeEnd('debug');\n\n  return new BoxGeometry({\n    minimum: boundingBox.minimum,\n    maximum: boundingBox.maximum,\n  });\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nBoxGeometry.packedLength =\n  2 * Cartesian3.packedLength + VertexFormat.packedLength + 1;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoxGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nBoxGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  Cartesian3.pack(value._minimum, array, startingIndex);\n  Cartesian3.pack(\n    value._maximum,\n    array,\n    startingIndex + Cartesian3.packedLength,\n  );\n  VertexFormat.pack(\n    value._vertexFormat,\n    array,\n    startingIndex + 2 * Cartesian3.packedLength,\n  );\n  array[\n    startingIndex + 2 * Cartesian3.packedLength + VertexFormat.packedLength\n  ] = value._offsetAttribute ?? -1;\n\n  return array;\n};\n\nconst scratchMin = new Cartesian3();\nconst scratchMax = new Cartesian3();\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  minimum: scratchMin,\n  maximum: scratchMax,\n  vertexFormat: scratchVertexFormat,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoxGeometry} [result] The object into which to store the result.\n * @returns {BoxGeometry} The modified result parameter or a new BoxGeometry instance if one was not provided.\n */\nBoxGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const min = Cartesian3.unpack(array, startingIndex, scratchMin);\n  const max = Cartesian3.unpack(\n    array,\n    startingIndex + Cartesian3.packedLength,\n    scratchMax,\n  );\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex + 2 * Cartesian3.packedLength,\n    scratchVertexFormat,\n  );\n  const offsetAttribute =\n    array[\n      startingIndex + 2 * Cartesian3.packedLength + VertexFormat.packedLength\n    ];\n\n  if (!defined(result)) {\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new BoxGeometry(scratchOptions);\n  }\n\n  result._minimum = Cartesian3.clone(min, result._minimum);\n  result._maximum = Cartesian3.clone(max, result._maximum);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of a box, including its vertices, indices, and a bounding sphere.\n *\n * @param {BoxGeometry} boxGeometry A description of the box.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nBoxGeometry.createGeometry = function (boxGeometry) {\n  const min = boxGeometry._minimum;\n  const max = boxGeometry._maximum;\n  const vertexFormat = boxGeometry._vertexFormat;\n\n  if (Cartesian3.equals(min, max)) {\n    return;\n  }\n\n  const attributes = new GeometryAttributes();\n  let indices;\n  let positions;\n\n  if (\n    vertexFormat.position &&\n    (vertexFormat.st ||\n      vertexFormat.normal ||\n      vertexFormat.tangent ||\n      vertexFormat.bitangent)\n  ) {\n    if (vertexFormat.position) {\n      // 8 corner points.  Duplicated 3 times each for each incident edge/face.\n      positions = new Float64Array(6 * 4 * 3);\n\n      // +z face\n      positions[0] = min.x;\n      positions[1] = min.y;\n      positions[2] = max.z;\n      positions[3] = max.x;\n      positions[4] = min.y;\n      positions[5] = max.z;\n      positions[6] = max.x;\n      positions[7] = max.y;\n      positions[8] = max.z;\n      positions[9] = min.x;\n      positions[10] = max.y;\n      positions[11] = max.z;\n\n      // -z face\n      positions[12] = min.x;\n      positions[13] = min.y;\n      positions[14] = min.z;\n      positions[15] = max.x;\n      positions[16] = min.y;\n      positions[17] = min.z;\n      positions[18] = max.x;\n      positions[19] = max.y;\n      positions[20] = min.z;\n      positions[21] = min.x;\n      positions[22] = max.y;\n      positions[23] = min.z;\n\n      // +x face\n      positions[24] = max.x;\n      positions[25] = min.y;\n      positions[26] = min.z;\n      positions[27] = max.x;\n      positions[28] = max.y;\n      positions[29] = min.z;\n      positions[30] = max.x;\n      positions[31] = max.y;\n      positions[32] = max.z;\n      positions[33] = max.x;\n      positions[34] = min.y;\n      positions[35] = max.z;\n\n      // -x face\n      positions[36] = min.x;\n      positions[37] = min.y;\n      positions[38] = min.z;\n      positions[39] = min.x;\n      positions[40] = max.y;\n      positions[41] = min.z;\n      positions[42] = min.x;\n      positions[43] = max.y;\n      positions[44] = max.z;\n      positions[45] = min.x;\n      positions[46] = min.y;\n      positions[47] = max.z;\n\n      // +y face\n      positions[48] = min.x;\n      positions[49] = max.y;\n      positions[50] = min.z;\n      positions[51] = max.x;\n      positions[52] = max.y;\n      positions[53] = min.z;\n      positions[54] = max.x;\n      positions[55] = max.y;\n      positions[56] = max.z;\n      positions[57] = min.x;\n      positions[58] = max.y;\n      positions[59] = max.z;\n\n      // -y face\n      positions[60] = min.x;\n      positions[61] = min.y;\n      positions[62] = min.z;\n      positions[63] = max.x;\n      positions[64] = min.y;\n      positions[65] = min.z;\n      positions[66] = max.x;\n      positions[67] = min.y;\n      positions[68] = max.z;\n      positions[69] = min.x;\n      positions[70] = min.y;\n      positions[71] = max.z;\n\n      attributes.position = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: positions,\n      });\n    }\n\n    if (vertexFormat.normal) {\n      const normals = new Float32Array(6 * 4 * 3);\n\n      // +z face\n      normals[0] = 0.0;\n      normals[1] = 0.0;\n      normals[2] = 1.0;\n      normals[3] = 0.0;\n      normals[4] = 0.0;\n      normals[5] = 1.0;\n      normals[6] = 0.0;\n      normals[7] = 0.0;\n      normals[8] = 1.0;\n      normals[9] = 0.0;\n      normals[10] = 0.0;\n      normals[11] = 1.0;\n\n      // -z face\n      normals[12] = 0.0;\n      normals[13] = 0.0;\n      normals[14] = -1.0;\n      normals[15] = 0.0;\n      normals[16] = 0.0;\n      normals[17] = -1.0;\n      normals[18] = 0.0;\n      normals[19] = 0.0;\n      normals[20] = -1.0;\n      normals[21] = 0.0;\n      normals[22] = 0.0;\n      normals[23] = -1.0;\n\n      // +x face\n      normals[24] = 1.0;\n      normals[25] = 0.0;\n      normals[26] = 0.0;\n      normals[27] = 1.0;\n      normals[28] = 0.0;\n      normals[29] = 0.0;\n      normals[30] = 1.0;\n      normals[31] = 0.0;\n      normals[32] = 0.0;\n      normals[33] = 1.0;\n      normals[34] = 0.0;\n      normals[35] = 0.0;\n\n      // -x face\n      normals[36] = -1.0;\n      normals[37] = 0.0;\n      normals[38] = 0.0;\n      normals[39] = -1.0;\n      normals[40] = 0.0;\n      normals[41] = 0.0;\n      normals[42] = -1.0;\n      normals[43] = 0.0;\n      normals[44] = 0.0;\n      normals[45] = -1.0;\n      normals[46] = 0.0;\n      normals[47] = 0.0;\n\n      // +y face\n      normals[48] = 0.0;\n      normals[49] = 1.0;\n      normals[50] = 0.0;\n      normals[51] = 0.0;\n      normals[52] = 1.0;\n      normals[53] = 0.0;\n      normals[54] = 0.0;\n      normals[55] = 1.0;\n      normals[56] = 0.0;\n      normals[57] = 0.0;\n      normals[58] = 1.0;\n      normals[59] = 0.0;\n\n      // -y face\n      normals[60] = 0.0;\n      normals[61] = -1.0;\n      normals[62] = 0.0;\n      normals[63] = 0.0;\n      normals[64] = -1.0;\n      normals[65] = 0.0;\n      normals[66] = 0.0;\n      normals[67] = -1.0;\n      normals[68] = 0.0;\n      normals[69] = 0.0;\n      normals[70] = -1.0;\n      normals[71] = 0.0;\n\n      attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n\n    if (vertexFormat.st) {\n      const texCoords = new Float32Array(6 * 4 * 2);\n\n      // +z face\n      texCoords[0] = 0.0;\n      texCoords[1] = 0.0;\n      texCoords[2] = 1.0;\n      texCoords[3] = 0.0;\n      texCoords[4] = 1.0;\n      texCoords[5] = 1.0;\n      texCoords[6] = 0.0;\n      texCoords[7] = 1.0;\n\n      // -z face\n      texCoords[8] = 1.0;\n      texCoords[9] = 0.0;\n      texCoords[10] = 0.0;\n      texCoords[11] = 0.0;\n      texCoords[12] = 0.0;\n      texCoords[13] = 1.0;\n      texCoords[14] = 1.0;\n      texCoords[15] = 1.0;\n\n      //+x face\n      texCoords[16] = 0.0;\n      texCoords[17] = 0.0;\n      texCoords[18] = 1.0;\n      texCoords[19] = 0.0;\n      texCoords[20] = 1.0;\n      texCoords[21] = 1.0;\n      texCoords[22] = 0.0;\n      texCoords[23] = 1.0;\n\n      // -x face\n      texCoords[24] = 1.0;\n      texCoords[25] = 0.0;\n      texCoords[26] = 0.0;\n      texCoords[27] = 0.0;\n      texCoords[28] = 0.0;\n      texCoords[29] = 1.0;\n      texCoords[30] = 1.0;\n      texCoords[31] = 1.0;\n\n      // +y face\n      texCoords[32] = 1.0;\n      texCoords[33] = 0.0;\n      texCoords[34] = 0.0;\n      texCoords[35] = 0.0;\n      texCoords[36] = 0.0;\n      texCoords[37] = 1.0;\n      texCoords[38] = 1.0;\n      texCoords[39] = 1.0;\n\n      // -y face\n      texCoords[40] = 0.0;\n      texCoords[41] = 0.0;\n      texCoords[42] = 1.0;\n      texCoords[43] = 0.0;\n      texCoords[44] = 1.0;\n      texCoords[45] = 1.0;\n      texCoords[46] = 0.0;\n      texCoords[47] = 1.0;\n\n      attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: texCoords,\n      });\n    }\n\n    if (vertexFormat.tangent) {\n      const tangents = new Float32Array(6 * 4 * 3);\n\n      // +z face\n      tangents[0] = 1.0;\n      tangents[1] = 0.0;\n      tangents[2] = 0.0;\n      tangents[3] = 1.0;\n      tangents[4] = 0.0;\n      tangents[5] = 0.0;\n      tangents[6] = 1.0;\n      tangents[7] = 0.0;\n      tangents[8] = 0.0;\n      tangents[9] = 1.0;\n      tangents[10] = 0.0;\n      tangents[11] = 0.0;\n\n      // -z face\n      tangents[12] = -1.0;\n      tangents[13] = 0.0;\n      tangents[14] = 0.0;\n      tangents[15] = -1.0;\n      tangents[16] = 0.0;\n      tangents[17] = 0.0;\n      tangents[18] = -1.0;\n      tangents[19] = 0.0;\n      tangents[20] = 0.0;\n      tangents[21] = -1.0;\n      tangents[22] = 0.0;\n      tangents[23] = 0.0;\n\n      // +x face\n      tangents[24] = 0.0;\n      tangents[25] = 1.0;\n      tangents[26] = 0.0;\n      tangents[27] = 0.0;\n      tangents[28] = 1.0;\n      tangents[29] = 0.0;\n      tangents[30] = 0.0;\n      tangents[31] = 1.0;\n      tangents[32] = 0.0;\n      tangents[33] = 0.0;\n      tangents[34] = 1.0;\n      tangents[35] = 0.0;\n\n      // -x face\n      tangents[36] = 0.0;\n      tangents[37] = -1.0;\n      tangents[38] = 0.0;\n      tangents[39] = 0.0;\n      tangents[40] = -1.0;\n      tangents[41] = 0.0;\n      tangents[42] = 0.0;\n      tangents[43] = -1.0;\n      tangents[44] = 0.0;\n      tangents[45] = 0.0;\n      tangents[46] = -1.0;\n      tangents[47] = 0.0;\n\n      // +y face\n      tangents[48] = -1.0;\n      tangents[49] = 0.0;\n      tangents[50] = 0.0;\n      tangents[51] = -1.0;\n      tangents[52] = 0.0;\n      tangents[53] = 0.0;\n      tangents[54] = -1.0;\n      tangents[55] = 0.0;\n      tangents[56] = 0.0;\n      tangents[57] = -1.0;\n      tangents[58] = 0.0;\n      tangents[59] = 0.0;\n\n      // -y face\n      tangents[60] = 1.0;\n      tangents[61] = 0.0;\n      tangents[62] = 0.0;\n      tangents[63] = 1.0;\n      tangents[64] = 0.0;\n      tangents[65] = 0.0;\n      tangents[66] = 1.0;\n      tangents[67] = 0.0;\n      tangents[68] = 0.0;\n      tangents[69] = 1.0;\n      tangents[70] = 0.0;\n      tangents[71] = 0.0;\n\n      attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n\n    if (vertexFormat.bitangent) {\n      const bitangents = new Float32Array(6 * 4 * 3);\n\n      // +z face\n      bitangents[0] = 0.0;\n      bitangents[1] = 1.0;\n      bitangents[2] = 0.0;\n      bitangents[3] = 0.0;\n      bitangents[4] = 1.0;\n      bitangents[5] = 0.0;\n      bitangents[6] = 0.0;\n      bitangents[7] = 1.0;\n      bitangents[8] = 0.0;\n      bitangents[9] = 0.0;\n      bitangents[10] = 1.0;\n      bitangents[11] = 0.0;\n\n      // -z face\n      bitangents[12] = 0.0;\n      bitangents[13] = 1.0;\n      bitangents[14] = 0.0;\n      bitangents[15] = 0.0;\n      bitangents[16] = 1.0;\n      bitangents[17] = 0.0;\n      bitangents[18] = 0.0;\n      bitangents[19] = 1.0;\n      bitangents[20] = 0.0;\n      bitangents[21] = 0.0;\n      bitangents[22] = 1.0;\n      bitangents[23] = 0.0;\n\n      // +x face\n      bitangents[24] = 0.0;\n      bitangents[25] = 0.0;\n      bitangents[26] = 1.0;\n      bitangents[27] = 0.0;\n      bitangents[28] = 0.0;\n      bitangents[29] = 1.0;\n      bitangents[30] = 0.0;\n      bitangents[31] = 0.0;\n      bitangents[32] = 1.0;\n      bitangents[33] = 0.0;\n      bitangents[34] = 0.0;\n      bitangents[35] = 1.0;\n\n      // -x face\n      bitangents[36] = 0.0;\n      bitangents[37] = 0.0;\n      bitangents[38] = 1.0;\n      bitangents[39] = 0.0;\n      bitangents[40] = 0.0;\n      bitangents[41] = 1.0;\n      bitangents[42] = 0.0;\n      bitangents[43] = 0.0;\n      bitangents[44] = 1.0;\n      bitangents[45] = 0.0;\n      bitangents[46] = 0.0;\n      bitangents[47] = 1.0;\n\n      // +y face\n      bitangents[48] = 0.0;\n      bitangents[49] = 0.0;\n      bitangents[50] = 1.0;\n      bitangents[51] = 0.0;\n      bitangents[52] = 0.0;\n      bitangents[53] = 1.0;\n      bitangents[54] = 0.0;\n      bitangents[55] = 0.0;\n      bitangents[56] = 1.0;\n      bitangents[57] = 0.0;\n      bitangents[58] = 0.0;\n      bitangents[59] = 1.0;\n\n      // -y face\n      bitangents[60] = 0.0;\n      bitangents[61] = 0.0;\n      bitangents[62] = 1.0;\n      bitangents[63] = 0.0;\n      bitangents[64] = 0.0;\n      bitangents[65] = 1.0;\n      bitangents[66] = 0.0;\n      bitangents[67] = 0.0;\n      bitangents[68] = 1.0;\n      bitangents[69] = 0.0;\n      bitangents[70] = 0.0;\n      bitangents[71] = 1.0;\n\n      attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n\n    // 12 triangles:  6 faces, 2 triangles each.\n    indices = new Uint16Array(6 * 2 * 3);\n\n    // +z face\n    indices[0] = 0;\n    indices[1] = 1;\n    indices[2] = 2;\n    indices[3] = 0;\n    indices[4] = 2;\n    indices[5] = 3;\n\n    // -z face\n    indices[6] = 4 + 2;\n    indices[7] = 4 + 1;\n    indices[8] = 4 + 0;\n    indices[9] = 4 + 3;\n    indices[10] = 4 + 2;\n    indices[11] = 4 + 0;\n\n    // +x face\n    indices[12] = 8 + 0;\n    indices[13] = 8 + 1;\n    indices[14] = 8 + 2;\n    indices[15] = 8 + 0;\n    indices[16] = 8 + 2;\n    indices[17] = 8 + 3;\n\n    // -x face\n    indices[18] = 12 + 2;\n    indices[19] = 12 + 1;\n    indices[20] = 12 + 0;\n    indices[21] = 12 + 3;\n    indices[22] = 12 + 2;\n    indices[23] = 12 + 0;\n\n    // +y face\n    indices[24] = 16 + 2;\n    indices[25] = 16 + 1;\n    indices[26] = 16 + 0;\n    indices[27] = 16 + 3;\n    indices[28] = 16 + 2;\n    indices[29] = 16 + 0;\n\n    // -y face\n    indices[30] = 20 + 0;\n    indices[31] = 20 + 1;\n    indices[32] = 20 + 2;\n    indices[33] = 20 + 0;\n    indices[34] = 20 + 2;\n    indices[35] = 20 + 3;\n  } else {\n    // Positions only - no need to duplicate corner points\n    positions = new Float64Array(8 * 3);\n\n    positions[0] = min.x;\n    positions[1] = min.y;\n    positions[2] = min.z;\n    positions[3] = max.x;\n    positions[4] = min.y;\n    positions[5] = min.z;\n    positions[6] = max.x;\n    positions[7] = max.y;\n    positions[8] = min.z;\n    positions[9] = min.x;\n    positions[10] = max.y;\n    positions[11] = min.z;\n    positions[12] = min.x;\n    positions[13] = min.y;\n    positions[14] = max.z;\n    positions[15] = max.x;\n    positions[16] = min.y;\n    positions[17] = max.z;\n    positions[18] = max.x;\n    positions[19] = max.y;\n    positions[20] = max.z;\n    positions[21] = min.x;\n    positions[22] = max.y;\n    positions[23] = max.z;\n\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    });\n\n    // 12 triangles:  6 faces, 2 triangles each.\n    indices = new Uint16Array(6 * 2 * 3);\n\n    // plane z = corner.Z\n    indices[0] = 4;\n    indices[1] = 5;\n    indices[2] = 6;\n    indices[3] = 4;\n    indices[4] = 6;\n    indices[5] = 7;\n\n    // plane z = -corner.Z\n    indices[6] = 1;\n    indices[7] = 0;\n    indices[8] = 3;\n    indices[9] = 1;\n    indices[10] = 3;\n    indices[11] = 2;\n\n    // plane x = corner.X\n    indices[12] = 1;\n    indices[13] = 6;\n    indices[14] = 5;\n    indices[15] = 1;\n    indices[16] = 2;\n    indices[17] = 6;\n\n    // plane y = corner.Y\n    indices[18] = 2;\n    indices[19] = 3;\n    indices[20] = 7;\n    indices[21] = 2;\n    indices[22] = 7;\n    indices[23] = 6;\n\n    // plane x = -corner.X\n    indices[24] = 3;\n    indices[25] = 0;\n    indices[26] = 4;\n    indices[27] = 3;\n    indices[28] = 4;\n    indices[29] = 7;\n\n    // plane y = -corner.Y\n    indices[30] = 0;\n    indices[31] = 1;\n    indices[32] = 5;\n    indices[33] = 0;\n    indices[34] = 5;\n    indices[35] = 4;\n  }\n\n  const diff = Cartesian3.subtract(max, min, diffScratch);\n  const radius = Cartesian3.magnitude(diff) * 0.5;\n\n  if (defined(boxGeometry._offsetAttribute)) {\n    const length = positions.length;\n    const offsetValue =\n      boxGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n    const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: new BoundingSphere(Cartesian3.ZERO, radius),\n    offsetAttribute: boxGeometry._offsetAttribute,\n  });\n};\n\nlet unitBoxGeometry;\n\n/**\n * Returns the geometric representation of a unit box, including its vertices, indices, and a bounding sphere.\n * @returns {Geometry} The computed vertices and indices.\n *\n * @private\n */\nBoxGeometry.getUnitBox = function () {\n  if (!defined(unitBoxGeometry)) {\n    unitBoxGeometry = BoxGeometry.createGeometry(\n      BoxGeometry.fromDimensions({\n        dimensions: new Cartesian3(1.0, 1.0, 1.0),\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      }),\n    );\n  }\n  return unitBoxGeometry;\n};\nexport default BoxGeometry;\n"],"names":["diffScratch","BoxGeometry","options","EMPTY_OBJECT","min","minimum","max","maximum","typeOf","object","offsetAttribute","TOP","vertexFormat","DEFAULT","_minimum","clone","_maximum","_vertexFormat","_offsetAttribute","_workerName","fromDimensions","dimensions","number","greaterThanOrEquals","x","y","z","corner","multiplyByScalar","negate","fromAxisAlignedBoundingBox","boundingBox","packedLength","pack","value","array","startingIndex","defined","scratchMin","scratchMax","scratchVertexFormat","scratchOptions","undefined","unpack","result","createGeometry","boxGeometry","equals","attributes","indices","positions","position","st","normal","tangent","bitangent","Float64Array","componentDatatype","DOUBLE","componentsPerAttribute","values","normals","Float32Array","FLOAT","texCoords","tangents","bitangents","Uint16Array","diff","subtract","radius","magnitude","length","offsetValue","NONE","applyOffset","Uint8Array","fill","UNSIGNED_BYTE","primitiveType","TRIANGLES","boundingSphere","ZERO","unitBoxGeometry","getUnitBox","POSITION_ONLY"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAEA,MAAMA,cAAc,IAAI,gLAAU;AAElC;;;;;;;;;;;;;;;;;;;;;;;;CAwBC,GACD,SAASC,YAAYC,OAAO;IAC1BA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC,MAAMC,MAAMF,QAAQG,OAAO;IAC3B,MAAMC,MAAMJ,QAAQK,OAAO;IAE3B,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,OAAOL;IAC3B,2KAAK,CAACI,MAAM,CAACC,MAAM,CAAC,OAAOH;IAC3B,IACE,IAAA,6KAAO,EAACJ,QAAQQ,eAAe,KAC/BR,QAAQQ,eAAe,KAAK,6LAAuB,CAACC,GAAG,EACvD;QACA,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,wBAAwB;IAExB,MAAMC,eAAeV,QAAQU,YAAY,IAAI,kLAAY,CAACC,OAAO;IAEjE,IAAI,CAACC,QAAQ,GAAG,gLAAU,CAACC,KAAK,CAACX;IACjC,IAAI,CAACY,QAAQ,GAAG,gLAAU,CAACD,KAAK,CAACT;IACjC,IAAI,CAACW,aAAa,GAAGL;IACrB,IAAI,CAACM,gBAAgB,GAAGhB,QAAQQ,eAAe;IAC/C,IAAI,CAACS,WAAW,GAAG;AACrB;AAEA;;;;;;;;;;;;;;;;;;;CAmBC,GACDlB,YAAYmB,cAAc,GAAG,SAAUlB,OAAO;IAC5CA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IACxC,MAAMkB,aAAanB,QAAQmB,UAAU;IAErC,yCAAyC;IACzC,2KAAK,CAACb,MAAM,CAACC,MAAM,CAAC,cAAcY;IAClC,2KAAK,CAACb,MAAM,CAACc,MAAM,CAACC,mBAAmB,CAAC,gBAAgBF,WAAWG,CAAC,EAAE;IACtE,2KAAK,CAAChB,MAAM,CAACc,MAAM,CAACC,mBAAmB,CAAC,gBAAgBF,WAAWI,CAAC,EAAE;IACtE,2KAAK,CAACjB,MAAM,CAACc,MAAM,CAACC,mBAAmB,CAAC,gBAAgBF,WAAWK,CAAC,EAAE;IACtE,wBAAwB;IAExB,MAAMC,SAAS,gLAAU,CAACC,gBAAgB,CAACP,YAAY,KAAK,IAAI,gLAAU;IAE1E,OAAO,IAAIpB,YAAY;QACrBI,SAAS,gLAAU,CAACwB,MAAM,CAACF,QAAQ,IAAI,gLAAU;QACjDpB,SAASoB;QACTf,cAAcV,QAAQU,YAAY;QAClCF,iBAAiBR,QAAQQ,eAAe;IAC1C;AACF;AAEA;;;;;;;;;;;;;;;;;;;CAmBC,GACDT,YAAY6B,0BAA0B,GAAG,SAAUC,WAAW;IAC5D,yCAAyC;IACzC,2KAAK,CAACvB,MAAM,CAACC,MAAM,CAAC,eAAesB;IACnC,wBAAwB;IAExB,OAAO,IAAI9B,YAAY;QACrBI,SAAS0B,YAAY1B,OAAO;QAC5BE,SAASwB,YAAYxB,OAAO;IAC9B;AACF;AAEA;;;CAGC,GACDN,YAAY+B,YAAY,GACtB,IAAI,gLAAU,CAACA,YAAY,GAAG,kLAAY,CAACA,YAAY,GAAG;AAE5D;;;;;;;;CAQC,GACD/B,YAAYgC,IAAI,GAAG,SAAUC,KAAK,EAAEC,KAAK,EAAEC,aAAa;IACtD,yCAAyC;IACzC,2KAAK,CAAC5B,MAAM,CAACC,MAAM,CAAC,SAASyB;IAC7B,2KAAK,CAACG,OAAO,CAAC,SAASF;IACvB,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjC,gLAAU,CAACH,IAAI,CAACC,MAAMpB,QAAQ,EAAEqB,OAAOC;IACvC,gLAAU,CAACH,IAAI,CACbC,MAAMlB,QAAQ,EACdmB,OACAC,gBAAgB,gLAAU,CAACJ,YAAY;IAEzC,kLAAY,CAACC,IAAI,CACfC,MAAMjB,aAAa,EACnBkB,OACAC,gBAAgB,IAAI,gLAAU,CAACJ,YAAY;IAE7CG,KAAK,CACHC,gBAAgB,IAAI,gLAAU,CAACJ,YAAY,GAAG,kLAAY,CAACA,YAAY,CACxE,GAAGE,MAAMhB,gBAAgB,IAAI,CAAC;IAE/B,OAAOiB;AACT;AAEA,MAAMG,aAAa,IAAI,gLAAU;AACjC,MAAMC,aAAa,IAAI,gLAAU;AACjC,MAAMC,sBAAsB,IAAI,kLAAY;AAC5C,MAAMC,iBAAiB;IACrBpC,SAASiC;IACT/B,SAASgC;IACT3B,cAAc4B;IACd9B,iBAAiBgC;AACnB;AAEA;;;;;;;CAOC,GACDzC,YAAY0C,MAAM,GAAG,SAAUR,KAAK,EAAEC,aAAa,EAAEQ,MAAM;IACzD,yCAAyC;IACzC,2KAAK,CAACP,OAAO,CAAC,SAASF;IACvB,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjC,MAAMhC,MAAM,gLAAU,CAACuC,MAAM,CAACR,OAAOC,eAAeE;IACpD,MAAMhC,MAAM,gLAAU,CAACqC,MAAM,CAC3BR,OACAC,gBAAgB,gLAAU,CAACJ,YAAY,EACvCO;IAEF,MAAM3B,eAAe,kLAAY,CAAC+B,MAAM,CACtCR,OACAC,gBAAgB,IAAI,gLAAU,CAACJ,YAAY,EAC3CQ;IAEF,MAAM9B,kBACJyB,KAAK,CACHC,gBAAgB,IAAI,gLAAU,CAACJ,YAAY,GAAG,kLAAY,CAACA,YAAY,CACxE;IAEH,IAAI,CAAC,IAAA,6KAAO,EAACY,SAAS;QACpBH,eAAe/B,eAAe,GAC5BA,oBAAoB,CAAC,IAAIgC,YAAYhC;QACvC,OAAO,IAAIT,YAAYwC;IACzB;IAEAG,OAAO9B,QAAQ,GAAG,gLAAU,CAACC,KAAK,CAACX,KAAKwC,OAAO9B,QAAQ;IACvD8B,OAAO5B,QAAQ,GAAG,gLAAU,CAACD,KAAK,CAACT,KAAKsC,OAAO5B,QAAQ;IACvD4B,OAAO3B,aAAa,GAAG,kLAAY,CAACF,KAAK,CAACH,cAAcgC,OAAO3B,aAAa;IAC5E2B,OAAO1B,gBAAgB,GACrBR,oBAAoB,CAAC,IAAIgC,YAAYhC;IAEvC,OAAOkC;AACT;AAEA;;;;;CAKC,GACD3C,YAAY4C,cAAc,GAAG,SAAUC,WAAW;IAChD,MAAM1C,MAAM0C,YAAYhC,QAAQ;IAChC,MAAMR,MAAMwC,YAAY9B,QAAQ;IAChC,MAAMJ,eAAekC,YAAY7B,aAAa;IAE9C,IAAI,gLAAU,CAAC8B,MAAM,CAAC3C,KAAKE,MAAM;QAC/B;IACF;IAEA,MAAM0C,aAAa,IAAI,wLAAkB;IACzC,IAAIC;IACJ,IAAIC;IAEJ,IACEtC,aAAauC,QAAQ,IACrB,CAACvC,aAAawC,EAAE,IACdxC,aAAayC,MAAM,IACnBzC,aAAa0C,OAAO,IACpB1C,aAAa2C,SAAS,GACxB;QACA,IAAI3C,aAAauC,QAAQ,EAAE;YACzB,yEAAyE;YACzED,YAAY,IAAIM,aAAa,IAAI,IAAI;YAErC,UAAU;YACVN,SAAS,CAAC,EAAE,GAAG9C,IAAIoB,CAAC;YACpB0B,SAAS,CAAC,EAAE,GAAG9C,IAAIqB,CAAC;YACpByB,SAAS,CAAC,EAAE,GAAG5C,IAAIoB,CAAC;YACpBwB,SAAS,CAAC,EAAE,GAAG5C,IAAIkB,CAAC;YACpB0B,SAAS,CAAC,EAAE,GAAG9C,IAAIqB,CAAC;YACpByB,SAAS,CAAC,EAAE,GAAG5C,IAAIoB,CAAC;YACpBwB,SAAS,CAAC,EAAE,GAAG5C,IAAIkB,CAAC;YACpB0B,SAAS,CAAC,EAAE,GAAG5C,IAAImB,CAAC;YACpByB,SAAS,CAAC,EAAE,GAAG5C,IAAIoB,CAAC;YACpBwB,SAAS,CAAC,EAAE,GAAG9C,IAAIoB,CAAC;YACpB0B,SAAS,CAAC,GAAG,GAAG5C,IAAImB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG5C,IAAIoB,CAAC;YAErB,UAAU;YACVwB,SAAS,CAAC,GAAG,GAAG9C,IAAIoB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG9C,IAAIqB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG9C,IAAIsB,CAAC;YACrBwB,SAAS,CAAC,GAAG,GAAG5C,IAAIkB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG9C,IAAIqB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG9C,IAAIsB,CAAC;YACrBwB,SAAS,CAAC,GAAG,GAAG5C,IAAIkB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG5C,IAAImB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG9C,IAAIsB,CAAC;YACrBwB,SAAS,CAAC,GAAG,GAAG9C,IAAIoB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG5C,IAAImB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG9C,IAAIsB,CAAC;YAErB,UAAU;YACVwB,SAAS,CAAC,GAAG,GAAG5C,IAAIkB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG9C,IAAIqB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG9C,IAAIsB,CAAC;YACrBwB,SAAS,CAAC,GAAG,GAAG5C,IAAIkB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG5C,IAAImB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG9C,IAAIsB,CAAC;YACrBwB,SAAS,CAAC,GAAG,GAAG5C,IAAIkB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG5C,IAAImB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG5C,IAAIoB,CAAC;YACrBwB,SAAS,CAAC,GAAG,GAAG5C,IAAIkB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG9C,IAAIqB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG5C,IAAIoB,CAAC;YAErB,UAAU;YACVwB,SAAS,CAAC,GAAG,GAAG9C,IAAIoB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG9C,IAAIqB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG9C,IAAIsB,CAAC;YACrBwB,SAAS,CAAC,GAAG,GAAG9C,IAAIoB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG5C,IAAImB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG9C,IAAIsB,CAAC;YACrBwB,SAAS,CAAC,GAAG,GAAG9C,IAAIoB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG5C,IAAImB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG5C,IAAIoB,CAAC;YACrBwB,SAAS,CAAC,GAAG,GAAG9C,IAAIoB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG9C,IAAIqB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG5C,IAAIoB,CAAC;YAErB,UAAU;YACVwB,SAAS,CAAC,GAAG,GAAG9C,IAAIoB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG5C,IAAImB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG9C,IAAIsB,CAAC;YACrBwB,SAAS,CAAC,GAAG,GAAG5C,IAAIkB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG5C,IAAImB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG9C,IAAIsB,CAAC;YACrBwB,SAAS,CAAC,GAAG,GAAG5C,IAAIkB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG5C,IAAImB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG5C,IAAIoB,CAAC;YACrBwB,SAAS,CAAC,GAAG,GAAG9C,IAAIoB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG5C,IAAImB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG5C,IAAIoB,CAAC;YAErB,UAAU;YACVwB,SAAS,CAAC,GAAG,GAAG9C,IAAIoB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG9C,IAAIqB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG9C,IAAIsB,CAAC;YACrBwB,SAAS,CAAC,GAAG,GAAG5C,IAAIkB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG9C,IAAIqB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG9C,IAAIsB,CAAC;YACrBwB,SAAS,CAAC,GAAG,GAAG5C,IAAIkB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG9C,IAAIqB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG5C,IAAIoB,CAAC;YACrBwB,SAAS,CAAC,GAAG,GAAG9C,IAAIoB,CAAC;YACrB0B,SAAS,CAAC,GAAG,GAAG9C,IAAIqB,CAAC;YACrByB,SAAS,CAAC,GAAG,GAAG5C,IAAIoB,CAAC;YAErBsB,WAAWG,QAAQ,GAAG,IAAI,uLAAiB,CAAC;gBAC1CM,mBAAmB,uLAAiB,CAACC,MAAM;gBAC3CC,wBAAwB;gBACxBC,QAAQV;YACV;QACF;QAEA,IAAItC,aAAayC,MAAM,EAAE;YACvB,MAAMQ,UAAU,IAAIC,aAAa,IAAI,IAAI;YAEzC,UAAU;YACVD,OAAO,CAAC,EAAE,GAAG;YACbA,OAAO,CAAC,EAAE,GAAG;YACbA,OAAO,CAAC,EAAE,GAAG;YACbA,OAAO,CAAC,EAAE,GAAG;YACbA,OAAO,CAAC,EAAE,GAAG;YACbA,OAAO,CAAC,EAAE,GAAG;YACbA,OAAO,CAAC,EAAE,GAAG;YACbA,OAAO,CAAC,EAAE,GAAG;YACbA,OAAO,CAAC,EAAE,GAAG;YACbA,OAAO,CAAC,EAAE,GAAG;YACbA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YAEd,UAAU;YACVA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG,CAAC;YACfA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG,CAAC;YACfA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG,CAAC;YACfA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG,CAAC;YAEf,UAAU;YACVA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YAEd,UAAU;YACVA,OAAO,CAAC,GAAG,GAAG,CAAC;YACfA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG,CAAC;YACfA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG,CAAC;YACfA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG,CAAC;YACfA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YAEd,UAAU;YACVA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YAEd,UAAU;YACVA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG,CAAC;YACfA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG,CAAC;YACfA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG,CAAC;YACfA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG;YACdA,OAAO,CAAC,GAAG,GAAG,CAAC;YACfA,OAAO,CAAC,GAAG,GAAG;YAEdb,WAAWK,MAAM,GAAG,IAAI,uLAAiB,CAAC;gBACxCI,mBAAmB,uLAAiB,CAACM,KAAK;gBAC1CJ,wBAAwB;gBACxBC,QAAQC;YACV;QACF;QAEA,IAAIjD,aAAawC,EAAE,EAAE;YACnB,MAAMY,YAAY,IAAIF,aAAa,IAAI,IAAI;YAE3C,UAAU;YACVE,SAAS,CAAC,EAAE,GAAG;YACfA,SAAS,CAAC,EAAE,GAAG;YACfA,SAAS,CAAC,EAAE,GAAG;YACfA,SAAS,CAAC,EAAE,GAAG;YACfA,SAAS,CAAC,EAAE,GAAG;YACfA,SAAS,CAAC,EAAE,GAAG;YACfA,SAAS,CAAC,EAAE,GAAG;YACfA,SAAS,CAAC,EAAE,GAAG;YAEf,UAAU;YACVA,SAAS,CAAC,EAAE,GAAG;YACfA,SAAS,CAAC,EAAE,GAAG;YACfA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAEhB,SAAS;YACTA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAEhB,UAAU;YACVA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAEhB,UAAU;YACVA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAEhB,UAAU;YACVA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAChBA,SAAS,CAAC,GAAG,GAAG;YAEhBhB,WAAWI,EAAE,GAAG,IAAI,uLAAiB,CAAC;gBACpCK,mBAAmB,uLAAiB,CAACM,KAAK;gBAC1CJ,wBAAwB;gBACxBC,QAAQI;YACV;QACF;QAEA,IAAIpD,aAAa0C,OAAO,EAAE;YACxB,MAAMW,WAAW,IAAIH,aAAa,IAAI,IAAI;YAE1C,UAAU;YACVG,QAAQ,CAAC,EAAE,GAAG;YACdA,QAAQ,CAAC,EAAE,GAAG;YACdA,QAAQ,CAAC,EAAE,GAAG;YACdA,QAAQ,CAAC,EAAE,GAAG;YACdA,QAAQ,CAAC,EAAE,GAAG;YACdA,QAAQ,CAAC,EAAE,GAAG;YACdA,QAAQ,CAAC,EAAE,GAAG;YACdA,QAAQ,CAAC,EAAE,GAAG;YACdA,QAAQ,CAAC,EAAE,GAAG;YACdA,QAAQ,CAAC,EAAE,GAAG;YACdA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YAEf,UAAU;YACVA,QAAQ,CAAC,GAAG,GAAG,CAAC;YAChBA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG,CAAC;YAChBA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG,CAAC;YAChBA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG,CAAC;YAChBA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YAEf,UAAU;YACVA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YAEf,UAAU;YACVA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG,CAAC;YAChBA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG,CAAC;YAChBA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG,CAAC;YAChBA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG,CAAC;YAChBA,QAAQ,CAAC,GAAG,GAAG;YAEf,UAAU;YACVA,QAAQ,CAAC,GAAG,GAAG,CAAC;YAChBA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG,CAAC;YAChBA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG,CAAC;YAChBA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG,CAAC;YAChBA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YAEf,UAAU;YACVA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YACfA,QAAQ,CAAC,GAAG,GAAG;YAEfjB,WAAWM,OAAO,GAAG,IAAI,uLAAiB,CAAC;gBACzCG,mBAAmB,uLAAiB,CAACM,KAAK;gBAC1CJ,wBAAwB;gBACxBC,QAAQK;YACV;QACF;QAEA,IAAIrD,aAAa2C,SAAS,EAAE;YAC1B,MAAMW,aAAa,IAAIJ,aAAa,IAAI,IAAI;YAE5C,UAAU;YACVI,UAAU,CAAC,EAAE,GAAG;YAChBA,UAAU,CAAC,EAAE,GAAG;YAChBA,UAAU,CAAC,EAAE,GAAG;YAChBA,UAAU,CAAC,EAAE,GAAG;YAChBA,UAAU,CAAC,EAAE,GAAG;YAChBA,UAAU,CAAC,EAAE,GAAG;YAChBA,UAAU,CAAC,EAAE,GAAG;YAChBA,UAAU,CAAC,EAAE,GAAG;YAChBA,UAAU,CAAC,EAAE,GAAG;YAChBA,UAAU,CAAC,EAAE,GAAG;YAChBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YAEjB,UAAU;YACVA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YAEjB,UAAU;YACVA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YAEjB,UAAU;YACVA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YAEjB,UAAU;YACVA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CAAC,GAAG,GAAG;YACjBA,UAAU,CA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","ignoreList":[0]}},
    {"offset": {"line": 28673, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/AttributeCompression.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport AttributeType from \"../Scene/AttributeType.js\";\n\nconst RIGHT_SHIFT = 1.0 / 256.0;\nconst LEFT_SHIFT = 256.0;\n\n/**\n * Attribute compression and decompression functions.\n *\n * @namespace AttributeCompression\n *\n * @private\n */\nconst AttributeCompression = {};\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-rangeMax] following the 'oct' encoding.\n *\n * Oct encoding is a compact representation of unit length vectors.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: {@link http://jcgt.org/published/0003/02/01/}\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 component 'oct' encoding.\n * @param {Cartesian2} result The 2 component oct-encoded unit length vector.\n * @param {number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @returns {Cartesian2} The 2 component oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octDecodeInRange\n */\nAttributeCompression.octEncodeInRange = function (vector, rangeMax, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"vector\", vector);\n  Check.defined(\"result\", result);\n  const magSquared = Cartesian3.magnitudeSquared(vector);\n  if (Math.abs(magSquared - 1.0) > CesiumMath.EPSILON6) {\n    throw new DeveloperError(\"vector must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  result.x =\n    vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  result.y =\n    vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  if (vector.z < 0) {\n    const x = result.x;\n    const y = result.y;\n    result.x = (1.0 - Math.abs(y)) * CesiumMath.signNotZero(x);\n    result.y = (1.0 - Math.abs(x)) * CesiumMath.signNotZero(y);\n  }\n\n  result.x = CesiumMath.toSNorm(result.x, rangeMax);\n  result.y = CesiumMath.toSNorm(result.y, rangeMax);\n\n  return result;\n};\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding.\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @param {Cartesian2} result The 2 byte oct-encoded unit length vector.\n * @returns {Cartesian2} The 2 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octEncodeInRange\n * @see AttributeCompression.octDecode\n */\nAttributeCompression.octEncode = function (vector, result) {\n  return AttributeCompression.octEncodeInRange(vector, 255, result);\n};\n\nconst octEncodeScratch = new Cartesian2();\nconst uint8ForceArray = new Uint8Array(1);\nfunction forceUint8(value) {\n  uint8ForceArray[0] = value;\n  return uint8ForceArray[0];\n}\n/**\n * @param {Cartesian3} vector The normalized vector to be compressed into 4 byte 'oct' encoding.\n * @param {Cartesian4} result The 4 byte oct-encoded unit length vector.\n * @returns {Cartesian4} The 4 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octEncodeInRange\n * @see AttributeCompression.octDecodeFromCartesian4\n */\nAttributeCompression.octEncodeToCartesian4 = function (vector, result) {\n  AttributeCompression.octEncodeInRange(vector, 65535, octEncodeScratch);\n  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\n  result.y = forceUint8(octEncodeScratch.x);\n  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\n  result.w = forceUint8(octEncodeScratch.y);\n  return result;\n};\n\n/**\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component vector.\n *\n * @param {number} x The x component of the oct-encoded unit length vector.\n * @param {number} y The y component of the oct-encoded unit length vector.\n * @param {number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @param {Cartesian3} result The decoded and normalized vector\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x and y must be unsigned normalized integers between 0 and rangeMax.\n *\n * @see AttributeCompression.octEncodeInRange\n */\nAttributeCompression.octDecodeInRange = function (x, y, rangeMax, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"result\", result);\n  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\n    throw new DeveloperError(\n      `x and y must be unsigned normalized integers between 0 and ${rangeMax}`,\n    );\n  }\n  //>>includeEnd('debug');\n\n  result.x = CesiumMath.fromSNorm(x, rangeMax);\n  result.y = CesiumMath.fromSNorm(y, rangeMax);\n  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n\n  if (result.z < 0.0) {\n    const oldVX = result.x;\n    result.x = (1.0 - Math.abs(result.y)) * CesiumMath.signNotZero(oldVX);\n    result.y = (1.0 - Math.abs(oldVX)) * CesiumMath.signNotZero(result.y);\n  }\n\n  return Cartesian3.normalize(result, result);\n};\n\n/**\n * Decodes a unit-length vector in 2 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {number} x The x component of the oct-encoded unit length vector.\n * @param {number} y The y component of the oct-encoded unit length vector.\n * @param {Cartesian3} result The decoded and normalized vector.\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x and y must be an unsigned normalized integer between 0 and 255.\n *\n * @see AttributeCompression.octDecodeInRange\n */\nAttributeCompression.octDecode = function (x, y, result) {\n  return AttributeCompression.octDecodeInRange(x, y, 255, result);\n};\n\n/**\n * Decodes a unit-length vector in 4 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Cartesian4} encoded The oct-encoded unit length vector.\n * @param {Cartesian3} result The decoded and normalized vector.\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x, y, z, and w must be unsigned normalized integers between 0 and 255.\n *\n * @see AttributeCompression.octDecodeInRange\n * @see AttributeCompression.octEncodeToCartesian4\n */\nAttributeCompression.octDecodeFromCartesian4 = function (encoded, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"encoded\", encoded);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n  const x = encoded.x;\n  const y = encoded.y;\n  const z = encoded.z;\n  const w = encoded.w;\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    x < 0 ||\n    x > 255 ||\n    y < 0 ||\n    y > 255 ||\n    z < 0 ||\n    z > 255 ||\n    w < 0 ||\n    w > 255\n  ) {\n    throw new DeveloperError(\n      \"x, y, z, and w must be unsigned normalized integers between 0 and 255\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const xOct16 = x * LEFT_SHIFT + y;\n  const yOct16 = z * LEFT_SHIFT + w;\n  return AttributeCompression.octDecodeInRange(xOct16, yOct16, 65535, result);\n};\n\n/**\n * Packs an oct encoded vector into a single floating-point number.\n *\n * @param {Cartesian2} encoded The oct encoded vector.\n * @returns {number} The oct encoded vector packed into a single float.\n *\n */\nAttributeCompression.octPackFloat = function (encoded) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"encoded\", encoded);\n  //>>includeEnd('debug');\n  return 256.0 * encoded.x + encoded.y;\n};\n\nconst scratchEncodeCart2 = new Cartesian2();\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding and\n * stores those values in a single float-point number.\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @returns {number} The 2 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n */\nAttributeCompression.octEncodeFloat = function (vector) {\n  AttributeCompression.octEncode(vector, scratchEncodeCart2);\n  return AttributeCompression.octPackFloat(scratchEncodeCart2);\n};\n\n/**\n * Decodes a unit-length vector in 'oct' encoding packed in a floating-point number to a normalized 3-component vector.\n *\n * @param {number} value The oct-encoded unit length vector stored as a single floating-point number.\n * @param {Cartesian3} result The decoded and normalized vector\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n */\nAttributeCompression.octDecodeFloat = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  //>>includeEnd('debug');\n\n  const temp = value / 256.0;\n  const x = Math.floor(temp);\n  const y = (temp - x) * 256.0;\n\n  return AttributeCompression.octDecode(x, y, result);\n};\n\n/**\n * Encodes three normalized vectors into 6 SNORM values in the range of [0-255] following the 'oct' encoding and\n * packs those into two floating-point numbers.\n *\n * @param {Cartesian3} v1 A normalized vector to be compressed.\n * @param {Cartesian3} v2 A normalized vector to be compressed.\n * @param {Cartesian3} v3 A normalized vector to be compressed.\n * @param {Cartesian2} result The 'oct' encoded vectors packed into two floating-point numbers.\n * @returns {Cartesian2} The 'oct' encoded vectors packed into two floating-point numbers.\n *\n */\nAttributeCompression.octPack = function (v1, v2, v3, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"v1\", v1);\n  Check.defined(\"v2\", v2);\n  Check.defined(\"v3\", v3);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const encoded1 = AttributeCompression.octEncodeFloat(v1);\n  const encoded2 = AttributeCompression.octEncodeFloat(v2);\n\n  const encoded3 = AttributeCompression.octEncode(v3, scratchEncodeCart2);\n  result.x = 65536.0 * encoded3.x + encoded1;\n  result.y = 65536.0 * encoded3.y + encoded2;\n  return result;\n};\n\n/**\n * Decodes three unit-length vectors in 'oct' encoding packed into a floating-point number to a normalized 3-component vector.\n *\n * @param {Cartesian2} packed The three oct-encoded unit length vectors stored as two floating-point number.\n * @param {Cartesian3} v1 One decoded and normalized vector.\n * @param {Cartesian3} v2 One decoded and normalized vector.\n * @param {Cartesian3} v3 One decoded and normalized vector.\n */\nAttributeCompression.octUnpack = function (packed, v1, v2, v3) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"packed\", packed);\n  Check.defined(\"v1\", v1);\n  Check.defined(\"v2\", v2);\n  Check.defined(\"v3\", v3);\n  //>>includeEnd('debug');\n\n  let temp = packed.x / 65536.0;\n  const x = Math.floor(temp);\n  const encodedFloat1 = (temp - x) * 65536.0;\n\n  temp = packed.y / 65536.0;\n  const y = Math.floor(temp);\n  const encodedFloat2 = (temp - y) * 65536.0;\n\n  AttributeCompression.octDecodeFloat(encodedFloat1, v1);\n  AttributeCompression.octDecodeFloat(encodedFloat2, v2);\n  AttributeCompression.octDecode(x, y, v3);\n};\n\n/**\n * Pack texture coordinates into a single float. The texture coordinates will only preserve 12 bits of precision.\n *\n * @param {Cartesian2} textureCoordinates The texture coordinates to compress.  Both coordinates must be in the range 0.0-1.0.\n * @returns {number} The packed texture coordinates.\n *\n */\nAttributeCompression.compressTextureCoordinates = function (\n  textureCoordinates,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"textureCoordinates\", textureCoordinates);\n  //>>includeEnd('debug');\n\n  // Move x and y to the range 0-4095;\n  const x = (textureCoordinates.x * 4095.0) | 0;\n  const y = (textureCoordinates.y * 4095.0) | 0;\n  return 4096.0 * x + y;\n};\n\n/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @param {number} compressed The compressed texture coordinates.\n * @param {Cartesian2} result The decompressed texture coordinates.\n * @returns {Cartesian2} The modified result parameter.\n *\n */\nAttributeCompression.decompressTextureCoordinates = function (\n  compressed,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"compressed\", compressed);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const temp = compressed / 4096.0;\n  const xZeroTo4095 = Math.floor(temp);\n  result.x = xZeroTo4095 / 4095.0;\n  result.y = (compressed - xZeroTo4095 * 4096) / 4095;\n  return result;\n};\n\nfunction zigZagDecode(value) {\n  return (value >> 1) ^ -(value & 1);\n}\n\n/**\n * Decodes delta and ZigZag encoded vertices. This modifies the buffers in place.\n *\n * @param {Uint16Array} uBuffer The buffer view of u values.\n * @param {Uint16Array} vBuffer The buffer view of v values.\n * @param {Uint16Array} [heightBuffer] The buffer view of height values.\n *\n * @see {@link https://github.com/CesiumGS/quantized-mesh|quantized-mesh-1.0 terrain format}\n */\nAttributeCompression.zigZagDeltaDecode = function (\n  uBuffer,\n  vBuffer,\n  heightBuffer,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"uBuffer\", uBuffer);\n  Check.defined(\"vBuffer\", vBuffer);\n  Check.typeOf.number.equals(\n    \"uBuffer.length\",\n    \"vBuffer.length\",\n    uBuffer.length,\n    vBuffer.length,\n  );\n  if (defined(heightBuffer)) {\n    Check.typeOf.number.equals(\n      \"uBuffer.length\",\n      \"heightBuffer.length\",\n      uBuffer.length,\n      heightBuffer.length,\n    );\n  }\n  //>>includeEnd('debug');\n\n  const count = uBuffer.length;\n\n  let u = 0;\n  let v = 0;\n  let height = 0;\n\n  for (let i = 0; i < count; ++i) {\n    u += zigZagDecode(uBuffer[i]);\n    v += zigZagDecode(vBuffer[i]);\n\n    uBuffer[i] = u;\n    vBuffer[i] = v;\n\n    if (defined(heightBuffer)) {\n      height += zigZagDecode(heightBuffer[i]);\n      heightBuffer[i] = height;\n    }\n  }\n};\n\n/**\n * Dequantizes a quantized typed array into a floating point typed array.\n *\n * @see {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data}\n *\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array} typedArray The typed array for the quantized data.\n * @param {ComponentDatatype} componentDatatype The component datatype of the quantized data.\n * @param {AttributeType} type The attribute type of the quantized data.\n * @param {number} count The number of attributes referenced in the dequantized array.\n *\n * @returns {Float32Array} The dequantized array.\n */\nAttributeCompression.dequantize = function (\n  typedArray,\n  componentDatatype,\n  type,\n  count,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"typedArray\", typedArray);\n  Check.defined(\"componentDatatype\", componentDatatype);\n  Check.defined(\"type\", type);\n  Check.defined(\"count\", count);\n  //>>includeEnd('debug');\n\n  const componentsPerAttribute = AttributeType.getNumberOfComponents(type);\n\n  let divisor;\n  switch (componentDatatype) {\n    case ComponentDatatype.BYTE:\n      divisor = 127.0;\n      break;\n    case ComponentDatatype.UNSIGNED_BYTE:\n      divisor = 255.0;\n      break;\n    case ComponentDatatype.SHORT:\n      divisor = 32767.0;\n      break;\n    case ComponentDatatype.UNSIGNED_SHORT:\n      divisor = 65535.0;\n      break;\n    case ComponentDatatype.INT:\n      divisor = 2147483647.0;\n      break;\n    case ComponentDatatype.UNSIGNED_INT:\n      divisor = 4294967295.0;\n      break;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\n        `Cannot dequantize component datatype: ${componentDatatype}`,\n      );\n    //>>includeEnd('debug');\n  }\n\n  const dequantizedTypedArray = new Float32Array(\n    count * componentsPerAttribute,\n  );\n\n  for (let i = 0; i < count; i++) {\n    for (let j = 0; j < componentsPerAttribute; j++) {\n      const index = i * componentsPerAttribute + j;\n      dequantizedTypedArray[index] = Math.max(\n        typedArray[index] / divisor,\n        -1.0,\n      );\n    }\n  }\n\n  return dequantizedTypedArray;\n};\n\n/**\n * Decode RGB565-encoded colors into a floating point typed array containing\n * normalized RGB values.\n *\n * @param {Uint16Array} typedArray Array of RGB565 values\n * @param {Float32Array} [result] Array to store the normalized VEC3 result\n */\nAttributeCompression.decodeRGB565 = function (typedArray, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"typedArray\", typedArray);\n\n  const expectedLength = typedArray.length * 3;\n  if (defined(result)) {\n    Check.typeOf.number.equals(\n      \"result.length\",\n      \"typedArray.length * 3\",\n      result.length,\n      expectedLength,\n    );\n  }\n  //>>includeEnd('debug');\n\n  const count = typedArray.length;\n  if (!defined(result)) {\n    result = new Float32Array(count * 3);\n  }\n\n  const mask5 = (1 << 5) - 1;\n  const mask6 = (1 << 6) - 1;\n  const normalize5 = 1.0 / 31.0;\n  const normalize6 = 1.0 / 63.0;\n  for (let i = 0; i < count; i++) {\n    const value = typedArray[i];\n    const red = value >> 11;\n    const green = (value >> 5) & mask6;\n    const blue = value & mask5;\n\n    const offset = 3 * i;\n    result[offset] = red * normalize5;\n    result[offset + 1] = green * normalize6;\n    result[offset + 2] = blue * normalize5;\n  }\n\n  return result;\n};\n\nexport default AttributeCompression;\n"],"names":["RIGHT_SHIFT","LEFT_SHIFT","AttributeCompression","octEncodeInRange","vector","rangeMax","result","defined","magSquared","magnitudeSquared","Math","abs","EPSILON6","x","y","z","signNotZero","toSNorm","octEncode","octEncodeScratch","uint8ForceArray","Uint8Array","forceUint8","value","octEncodeToCartesian4","w","octDecodeInRange","fromSNorm","oldVX","normalize","octDecode","octDecodeFromCartesian4","encoded","typeOf","object","xOct16","yOct16","octPackFloat","scratchEncodeCart2","octEncodeFloat","octDecodeFloat","temp","floor","octPack","v1","v2","v3","encoded1","encoded2","encoded3","octUnpack","packed","encodedFloat1","encodedFloat2","compressTextureCoordinates","textureCoordinates","decompressTextureCoordinates","compressed","xZeroTo4095","zigZagDecode","zigZagDeltaDecode","uBuffer","vBuffer","heightBuffer","number","equals","length","count","u","v","height","i","dequantize","typedArray","componentDatatype","type","componentsPerAttribute","getNumberOfComponents","divisor","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","dequantizedTypedArray","Float32Array","j","index","max","decodeRGB565","expectedLength","mask5","mask6","normalize5","normalize6","red","green","blue","offset"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 29095, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/barycentricCoordinates.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\n\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\n\n/**\n * Computes the barycentric coordinates for a point with respect to a triangle.\n *\n * @function\n *\n * @param {Cartesian2|Cartesian3} point The point to test.\n * @param {Cartesian2|Cartesian3} p0 The first point of the triangle, corresponding to the barycentric x-axis.\n * @param {Cartesian2|Cartesian3} p1 The second point of the triangle, corresponding to the barycentric y-axis.\n * @param {Cartesian2|Cartesian3} p2 The third point of the triangle, corresponding to the barycentric z-axis.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3|undefined} The modified result parameter or a new Cartesian3 instance if one was not provided. If the triangle is degenerate the function will return undefined.\n *\n * @example\n * // Returns Cartesian3.UNIT_X\n * const p = new Cesium.Cartesian3(-1.0, 0.0, 0.0);\n * const b = Cesium.barycentricCoordinates(p,\n *   new Cesium.Cartesian3(-1.0, 0.0, 0.0),\n *   new Cesium.Cartesian3( 1.0, 0.0, 0.0),\n *   new Cesium.Cartesian3( 0.0, 1.0, 1.0));\n */\nfunction barycentricCoordinates(point, p0, p1, p2, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"point\", point);\n  Check.defined(\"p0\", p0);\n  Check.defined(\"p1\", p1);\n  Check.defined(\"p2\", p2);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  // Implementation based on http://www.blackpawn.com/texts/pointinpoly/default.html.\n  let v0;\n  let v1;\n  let v2;\n  let dot00;\n  let dot01;\n  let dot02;\n  let dot11;\n  let dot12;\n\n  if (!defined(p0.z)) {\n    if (Cartesian2.equalsEpsilon(point, p0, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_X, result);\n    }\n    if (Cartesian2.equalsEpsilon(point, p1, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_Y, result);\n    }\n    if (Cartesian2.equalsEpsilon(point, p2, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n\n    v0 = Cartesian2.subtract(p1, p0, scratchCartesian1);\n    v1 = Cartesian2.subtract(p2, p0, scratchCartesian2);\n    v2 = Cartesian2.subtract(point, p0, scratchCartesian3);\n\n    dot00 = Cartesian2.dot(v0, v0);\n    dot01 = Cartesian2.dot(v0, v1);\n    dot02 = Cartesian2.dot(v0, v2);\n    dot11 = Cartesian2.dot(v1, v1);\n    dot12 = Cartesian2.dot(v1, v2);\n  } else {\n    if (Cartesian3.equalsEpsilon(point, p0, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_X, result);\n    }\n    if (Cartesian3.equalsEpsilon(point, p1, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_Y, result);\n    }\n    if (Cartesian3.equalsEpsilon(point, p2, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n\n    v0 = Cartesian3.subtract(p1, p0, scratchCartesian1);\n    v1 = Cartesian3.subtract(p2, p0, scratchCartesian2);\n    v2 = Cartesian3.subtract(point, p0, scratchCartesian3);\n\n    dot00 = Cartesian3.dot(v0, v0);\n    dot01 = Cartesian3.dot(v0, v1);\n    dot02 = Cartesian3.dot(v0, v2);\n    dot11 = Cartesian3.dot(v1, v1);\n    dot12 = Cartesian3.dot(v1, v2);\n  }\n\n  result.y = dot11 * dot02 - dot01 * dot12;\n  result.z = dot00 * dot12 - dot01 * dot02;\n  const q = dot00 * dot11 - dot01 * dot01;\n\n  // Triangle is degenerate\n  if (q === 0) {\n    return undefined;\n  }\n\n  result.y /= q;\n  result.z /= q;\n  result.x = 1.0 - result.y - result.z;\n  return result;\n}\nexport default barycentricCoordinates;\n"],"names":["scratchCartesian1","scratchCartesian2","scratchCartesian3","barycentricCoordinates","point","p0","p1","p2","result","defined","v0","v1","v2","dot00","dot01","dot02","dot11","dot12","z","equalsEpsilon","EPSILON14","clone","UNIT_X","UNIT_Y","UNIT_Z","subtract","dot","y","q","undefined","x"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 29204, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/IndexDatatype.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport WebGLConstants from \"./WebGLConstants.js\";\n\n/**\n * Constants for WebGL index datatypes.  These corresponds to the\n * <code>type</code> parameter of {@link http://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml|drawElements}.\n *\n * @enum {number}\n */\nconst IndexDatatype = {\n  /**\n   * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type\n   * of an element in <code>Uint8Array</code>.\n   *\n   * @type {number}\n   * @constant\n   */\n  UNSIGNED_BYTE: WebGLConstants.UNSIGNED_BYTE,\n\n  /**\n   * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type\n   * of an element in <code>Uint16Array</code>.\n   *\n   * @type {number}\n   * @constant\n   */\n  UNSIGNED_SHORT: WebGLConstants.UNSIGNED_SHORT,\n\n  /**\n   * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type\n   * of an element in <code>Uint32Array</code>.\n   *\n   * @type {number}\n   * @constant\n   */\n  UNSIGNED_INT: WebGLConstants.UNSIGNED_INT,\n};\n\n/**\n * Returns the size, in bytes, of the corresponding datatype.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to get the size of.\n * @returns {number} The size in bytes.\n *\n * @example\n * // Returns 2\n * const size = Cesium.IndexDatatype.getSizeInBytes(Cesium.IndexDatatype.UNSIGNED_SHORT);\n */\nIndexDatatype.getSizeInBytes = function (indexDatatype) {\n  switch (indexDatatype) {\n    case IndexDatatype.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case IndexDatatype.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case IndexDatatype.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    \"indexDatatype is required and must be a valid IndexDatatype constant.\",\n  );\n  //>>includeEnd('debug');\n};\n\n/**\n * Gets the datatype with a given size in bytes.\n *\n * @param {number} sizeInBytes The size of a single index in bytes.\n * @returns {IndexDatatype} The index datatype with the given size.\n */\nIndexDatatype.fromSizeInBytes = function (sizeInBytes) {\n  switch (sizeInBytes) {\n    case 2:\n      return IndexDatatype.UNSIGNED_SHORT;\n    case 4:\n      return IndexDatatype.UNSIGNED_INT;\n    case 1:\n      return IndexDatatype.UNSIGNED_BYTE;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\n        \"Size in bytes cannot be mapped to an IndexDatatype\",\n      );\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Validates that the provided index datatype is a valid {@link IndexDatatype}.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to validate.\n * @returns {boolean} <code>true</code> if the provided index datatype is a valid value; otherwise, <code>false</code>.\n *\n * @example\n * if (!Cesium.IndexDatatype.validate(indexDatatype)) {\n *   throw new Cesium.DeveloperError('indexDatatype must be a valid value.');\n * }\n */\nIndexDatatype.validate = function (indexDatatype) {\n  return (\n    defined(indexDatatype) &&\n    (indexDatatype === IndexDatatype.UNSIGNED_BYTE ||\n      indexDatatype === IndexDatatype.UNSIGNED_SHORT ||\n      indexDatatype === IndexDatatype.UNSIGNED_INT)\n  );\n};\n\n/**\n * Creates a typed array that will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {number} numberOfVertices Number of vertices that the indices will reference.\n * @param {number|Array} indicesLengthOrArray Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>indicesLengthOrArray</code>.\n *\n * @example\n * this.indices = Cesium.IndexDatatype.createTypedArray(positions.length / 3, numberOfIndices);\n */\nIndexDatatype.createTypedArray = function (\n  numberOfVertices,\n  indicesLengthOrArray,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(numberOfVertices)) {\n    throw new DeveloperError(\"numberOfVertices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(indicesLengthOrArray);\n  }\n\n  return new Uint16Array(indicesLengthOrArray);\n};\n\n/**\n * Creates a typed array from a source array buffer.  The resulting typed array will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {number} numberOfVertices Number of vertices that the indices will reference.\n * @param {ArrayBuffer} sourceArray Passed through to the typed array constructor.\n * @param {number} byteOffset Passed through to the typed array constructor.\n * @param {number} length Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>sourceArray</code>, <code>byteOffset</code>, and <code>length</code>.\n *\n */\nIndexDatatype.createTypedArrayFromArrayBuffer = function (\n  numberOfVertices,\n  sourceArray,\n  byteOffset,\n  length,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(numberOfVertices)) {\n    throw new DeveloperError(\"numberOfVertices is required.\");\n  }\n  if (!defined(sourceArray)) {\n    throw new DeveloperError(\"sourceArray is required.\");\n  }\n  if (!defined(byteOffset)) {\n    throw new DeveloperError(\"byteOffset is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(sourceArray, byteOffset, length);\n  }\n\n  return new Uint16Array(sourceArray, byteOffset, length);\n};\n\n/**\n * Gets the {@link IndexDatatype} for the provided TypedArray instance.\n *\n * @param {Uint8Array|Uint16Array|Uint32Array} array The typed array.\n * @returns {IndexDatatype} The IndexDatatype for the provided array, or undefined if the array is not a Uint8Array, Uint16Array, or Uint32Array.\n */\nIndexDatatype.fromTypedArray = function (array) {\n  if (array instanceof Uint8Array) {\n    return IndexDatatype.UNSIGNED_BYTE;\n  }\n  if (array instanceof Uint16Array) {\n    return IndexDatatype.UNSIGNED_SHORT;\n  }\n  if (array instanceof Uint32Array) {\n    return IndexDatatype.UNSIGNED_INT;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    \"array must be a Uint8Array, Uint16Array, or Uint32Array.\",\n  );\n  //>>includeEnd('debug');\n};\n\nexport default Object.freeze(IndexDatatype);\n"],"names":["IndexDatatype","UNSIGNED_BYTE","UNSIGNED_SHORT","UNSIGNED_INT","getSizeInBytes","indexDatatype","Uint8Array","BYTES_PER_ELEMENT","Uint16Array","Uint32Array","fromSizeInBytes","sizeInBytes","validate","createTypedArray","numberOfVertices","indicesLengthOrArray","SIXTY_FOUR_KILOBYTES","createTypedArrayFromArrayBuffer","sourceArray","byteOffset","length","fromTypedArray","array","Object","freeze"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;;;CAKC,GACD,MAAMA,gBAAgB;IACpB;;;;;;GAMC,GACDC,eAAe,oLAAc,CAACA,aAAa;IAE3C;;;;;;GAMC,GACDC,gBAAgB,oLAAc,CAACA,cAAc;IAE7C;;;;;;GAMC,GACDC,cAAc,oLAAc,CAACA,YAAY;AAC3C;AAEA;;;;;;;;;CASC,GACDH,cAAcI,cAAc,GAAG,SAAUC,aAAa;IACpD,OAAQA;QACN,KAAKL,cAAcC,aAAa;YAC9B,OAAOK,WAAWC,iBAAiB;QACrC,KAAKP,cAAcE,cAAc;YAC/B,OAAOM,YAAYD,iBAAiB;QACtC,KAAKP,cAAcG,YAAY;YAC7B,OAAOM,YAAYF,iBAAiB;IACxC;IAEA,yCAAyC;IACzC,MAAM,IAAI,oLAAc,CACtB;AAEF,wBAAwB;AAC1B;AAEA;;;;;CAKC,GACDP,cAAcU,eAAe,GAAG,SAAUC,WAAW;IACnD,OAAQA;QACN,KAAK;YACH,OAAOX,cAAcE,cAAc;QACrC,KAAK;YACH,OAAOF,cAAcG,YAAY;QACnC,KAAK;YACH,OAAOH,cAAcC,aAAa;QACpC,yCAAyC;QACzC;YACE,MAAM,IAAI,oLAAc,CACtB;IAGN;AACF;AAEA;;;;;;;;;;CAUC,GACDD,cAAcY,QAAQ,GAAG,SAAUP,aAAa;IAC9C,OACE,IAAA,6KAAO,EAACA,kBACR,CAACA,kBAAkBL,cAAcC,aAAa,IAC5CI,kBAAkBL,cAAcE,cAAc,IAC9CG,kBAAkBL,cAAcG,YAAY;AAElD;AAEA;;;;;;;;;;CAUC,GACDH,cAAca,gBAAgB,GAAG,SAC/BC,gBAAgB,EAChBC,oBAAoB;IAEpB,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACD,mBAAmB;QAC9B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,IAAIA,oBAAoB,0KAAU,CAACE,oBAAoB,EAAE;QACvD,OAAO,IAAIP,YAAYM;IACzB;IAEA,OAAO,IAAIP,YAAYO;AACzB;AAEA;;;;;;;;;;CAUC,GACDf,cAAciB,+BAA+B,GAAG,SAC9CH,gBAAgB,EAChBI,WAAW,EACXC,UAAU,EACVC,MAAM;IAEN,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACN,mBAAmB;QAC9B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACI,cAAc;QACzB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACC,aAAa;QACxB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,IAAIL,oBAAoB,0KAAU,CAACE,oBAAoB,EAAE;QACvD,OAAO,IAAIP,YAAYS,aAAaC,YAAYC;IAClD;IAEA,OAAO,IAAIZ,YAAYU,aAAaC,YAAYC;AAClD;AAEA;;;;;CAKC,GACDpB,cAAcqB,cAAc,GAAG,SAAUC,KAAK;IAC5C,IAAIA,iBAAiBhB,YAAY;QAC/B,OAAON,cAAcC,aAAa;IACpC;IACA,IAAIqB,iBAAiBd,aAAa;QAChC,OAAOR,cAAcE,cAAc;IACrC;IACA,IAAIoB,iBAAiBb,aAAa;QAChC,OAAOT,cAAcG,YAAY;IACnC;IAEA,yCAAyC;IACzC,MAAM,IAAI,oLAAc,CACtB;AAEF,wBAAwB;AAC1B;uCAEeoB,OAAOC,MAAM,CAACxB","ignoreList":[0]}},
    {"offset": {"line": 29369, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Tipsify.js"],"sourcesContent":["import Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Encapsulates an algorithm to optimize triangles for the post\n * vertex-shader cache.  This is based on the 2007 SIGGRAPH paper\n * 'Fast Triangle Reordering for Vertex Locality and Reduced Overdraw.'\n * The runtime is linear but several passes are made.\n *\n * @namespace Tipsify\n *\n * @see <a href='http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf'>\n * Fast Triangle Reordering for Vertex Locality and Reduced Overdraw</a>\n * by Sander, Nehab, and Barczak\n *\n * @private\n */\nconst Tipsify = {};\n\n/**\n * Calculates the average cache miss ratio (ACMR) for a given set of indices.\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\n *                        in the vertex buffer that define the geometry's triangles.\n * @param {number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\n *                                     If not supplied, this value will be computed.\n * @param {number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\n * @returns {number} The average cache miss ratio (ACMR).\n *\n * @exception {DeveloperError} indices length must be a multiple of three.\n * @exception {DeveloperError} cacheSize must be greater than two.\n *\n * @example\n * const indices = [0, 1, 2, 3, 4, 5];\n * const maxIndex = 5;\n * const cacheSize = 3;\n * const acmr = Cesium.Tipsify.calculateACMR({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\n */\nTipsify.calculateACMR = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const indices = options.indices;\n  let maximumIndex = options.maximumIndex;\n  const cacheSize = options.cacheSize ?? 24;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(indices)) {\n    throw new DeveloperError(\"indices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const numIndices = indices.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numIndices < 3 || numIndices % 3 !== 0) {\n    throw new DeveloperError(\"indices length must be a multiple of three.\");\n  }\n  if (maximumIndex <= 0) {\n    throw new DeveloperError(\"maximumIndex must be greater than zero.\");\n  }\n  if (cacheSize < 3) {\n    throw new DeveloperError(\"cacheSize must be greater than two.\");\n  }\n  //>>includeEnd('debug');\n\n  // Compute the maximumIndex if not given\n  if (!defined(maximumIndex)) {\n    maximumIndex = 0;\n    let currentIndex = 0;\n    let intoIndices = indices[currentIndex];\n    while (currentIndex < numIndices) {\n      if (intoIndices > maximumIndex) {\n        maximumIndex = intoIndices;\n      }\n      ++currentIndex;\n      intoIndices = indices[currentIndex];\n    }\n  }\n\n  // Vertex time stamps\n  const vertexTimeStamps = [];\n  for (let i = 0; i < maximumIndex + 1; i++) {\n    vertexTimeStamps[i] = 0;\n  }\n\n  // Cache processing\n  let s = cacheSize + 1;\n  for (let j = 0; j < numIndices; ++j) {\n    if (s - vertexTimeStamps[indices[j]] > cacheSize) {\n      vertexTimeStamps[indices[j]] = s;\n      ++s;\n    }\n  }\n\n  return (s - cacheSize + 1) / (numIndices / 3);\n};\n\n/**\n * Optimizes triangles for the post-vertex shader cache.\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\n *                        in the vertex buffer that define the geometry's triangles.\n * @param {number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\n *                                     If not supplied, this value will be computed.\n * @param {number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\n * @returns {number[]} A list of the input indices in an optimized order.\n *\n * @exception {DeveloperError} indices length must be a multiple of three.\n * @exception {DeveloperError} cacheSize must be greater than two.\n *\n * @example\n * const indices = [0, 1, 2, 3, 4, 5];\n * const maxIndex = 5;\n * const cacheSize = 3;\n * const reorderedIndices = Cesium.Tipsify.tipsify({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\n */\nTipsify.tipsify = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const indices = options.indices;\n  const maximumIndex = options.maximumIndex;\n  const cacheSize = options.cacheSize ?? 24;\n\n  let cursor;\n\n  function skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne) {\n    while (deadEnd.length >= 1) {\n      // while the stack is not empty\n      const d = deadEnd[deadEnd.length - 1]; // top of the stack\n      deadEnd.splice(deadEnd.length - 1, 1); // pop the stack\n\n      if (vertices[d].numLiveTriangles > 0) {\n        return d;\n      }\n    }\n\n    while (cursor < maximumIndexPlusOne) {\n      if (vertices[cursor].numLiveTriangles > 0) {\n        ++cursor;\n        return cursor - 1;\n      }\n      ++cursor;\n    }\n    return -1;\n  }\n\n  function getNextVertex(\n    indices,\n    cacheSize,\n    oneRing,\n    vertices,\n    s,\n    deadEnd,\n    maximumIndexPlusOne,\n  ) {\n    let n = -1;\n    let p;\n    let m = -1;\n    let itOneRing = 0;\n    while (itOneRing < oneRing.length) {\n      const index = oneRing[itOneRing];\n      if (vertices[index].numLiveTriangles) {\n        p = 0;\n        if (\n          s -\n            vertices[index].timeStamp +\n            2 * vertices[index].numLiveTriangles <=\n          cacheSize\n        ) {\n          p = s - vertices[index].timeStamp;\n        }\n        if (p > m || m === -1) {\n          m = p;\n          n = index;\n        }\n      }\n      ++itOneRing;\n    }\n    if (n === -1) {\n      return skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne);\n    }\n    return n;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(indices)) {\n    throw new DeveloperError(\"indices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const numIndices = indices.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numIndices < 3 || numIndices % 3 !== 0) {\n    throw new DeveloperError(\"indices length must be a multiple of three.\");\n  }\n  if (maximumIndex <= 0) {\n    throw new DeveloperError(\"maximumIndex must be greater than zero.\");\n  }\n  if (cacheSize < 3) {\n    throw new DeveloperError(\"cacheSize must be greater than two.\");\n  }\n  //>>includeEnd('debug');\n\n  // Determine maximum index\n  let maximumIndexPlusOne = 0;\n  let currentIndex = 0;\n  let intoIndices = indices[currentIndex];\n  const endIndex = numIndices;\n  if (defined(maximumIndex)) {\n    maximumIndexPlusOne = maximumIndex + 1;\n  } else {\n    while (currentIndex < endIndex) {\n      if (intoIndices > maximumIndexPlusOne) {\n        maximumIndexPlusOne = intoIndices;\n      }\n      ++currentIndex;\n      intoIndices = indices[currentIndex];\n    }\n    if (maximumIndexPlusOne === -1) {\n      return 0;\n    }\n    ++maximumIndexPlusOne;\n  }\n\n  // Vertices\n  const vertices = [];\n  let i;\n  for (i = 0; i < maximumIndexPlusOne; i++) {\n    vertices[i] = {\n      numLiveTriangles: 0,\n      timeStamp: 0,\n      vertexTriangles: [],\n    };\n  }\n  currentIndex = 0;\n  let triangle = 0;\n  while (currentIndex < endIndex) {\n    vertices[indices[currentIndex]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex]].numLiveTriangles;\n    vertices[indices[currentIndex + 1]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex + 1]].numLiveTriangles;\n    vertices[indices[currentIndex + 2]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex + 2]].numLiveTriangles;\n    ++triangle;\n    currentIndex += 3;\n  }\n\n  // Starting index\n  let f = 0;\n\n  // Time Stamp\n  let s = cacheSize + 1;\n  cursor = 1;\n\n  // Process\n  let oneRing = [];\n  const deadEnd = []; //Stack\n  let vertex;\n  let intoVertices;\n  let currentOutputIndex = 0;\n  const outputIndices = [];\n  const numTriangles = numIndices / 3;\n  const triangleEmitted = [];\n  for (i = 0; i < numTriangles; i++) {\n    triangleEmitted[i] = false;\n  }\n  let index;\n  let limit;\n  while (f !== -1) {\n    oneRing = [];\n    intoVertices = vertices[f];\n    limit = intoVertices.vertexTriangles.length;\n    for (let k = 0; k < limit; ++k) {\n      triangle = intoVertices.vertexTriangles[k];\n      if (!triangleEmitted[triangle]) {\n        triangleEmitted[triangle] = true;\n        currentIndex = triangle + triangle + triangle;\n        for (let j = 0; j < 3; ++j) {\n          // Set this index as a possible next index\n          index = indices[currentIndex];\n          oneRing.push(index);\n          deadEnd.push(index);\n\n          // Output index\n          outputIndices[currentOutputIndex] = index;\n          ++currentOutputIndex;\n\n          // Cache processing\n          vertex = vertices[index];\n          --vertex.numLiveTriangles;\n          if (s - vertex.timeStamp > cacheSize) {\n            vertex.timeStamp = s;\n            ++s;\n          }\n          ++currentIndex;\n        }\n      }\n    }\n    f = getNextVertex(\n      indices,\n      cacheSize,\n      oneRing,\n      vertices,\n      s,\n      deadEnd,\n      maximumIndexPlusOne,\n    );\n  }\n\n  return outputIndices;\n};\nexport default Tipsify;\n"],"names":["Tipsify","calculateACMR","options","EMPTY_OBJECT","indices","maximumIndex","cacheSize","numIndices","length","currentIndex","intoIndices","vertexTimeStamps","i","s","j","tipsify","cursor","skipDeadEnd","vertices","deadEnd","maximumIndexPlusOne","d","splice","numLiveTriangles","getNextVertex","oneRing","n","p","m","itOneRing","index","timeStamp","endIndex","vertexTriangles","triangle","push","f","vertex","intoVertices","currentOutputIndex","outputIndices","numTriangles","triangleEmitted","limit","k"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 29644, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PixelFormat.js"],"sourcesContent":["import PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport WebGLConstants from \"./WebGLConstants.js\";\n\n/**\n * The format of a pixel, i.e., the number of components it has and what they represent.\n *\n * @enum {number}\n */\nconst PixelFormat = {\n  /**\n   * A pixel format containing a depth value.\n   *\n   * @type {number}\n   * @constant\n   */\n  DEPTH_COMPONENT: WebGLConstants.DEPTH_COMPONENT,\n\n  /**\n   * A pixel format containing a depth and stencil value, most often used with {@link PixelDatatype.UNSIGNED_INT_24_8}.\n   *\n   * @type {number}\n   * @constant\n   */\n  DEPTH_STENCIL: WebGLConstants.DEPTH_STENCIL,\n\n  /**\n   * A pixel format containing an alpha channel.\n   *\n   * @type {number}\n   * @constant\n   */\n  ALPHA: WebGLConstants.ALPHA,\n\n  /**\n   * A pixel format containing a red channel\n   *\n   * @type {number}\n   * @constant\n   */\n  RED: WebGLConstants.RED,\n\n  /**\n   * A pixel format containing red and green channels.\n   *\n   * @type {number}\n   * @constant\n   */\n  RG: WebGLConstants.RG,\n\n  /**\n   * A pixel format containing red, green, and blue channels.\n   *\n   * @type {number}\n   * @constant\n   */\n  RGB: WebGLConstants.RGB,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels.\n   *\n   * @type {number}\n   * @constant\n   */\n  RGBA: WebGLConstants.RGBA,\n\n  /**\n   * A pixel format containing a red channel as an integer.\n   * @type {number}\n   * @constant\n   */\n  RED_INTEGER: WebGLConstants.RED_INTEGER,\n\n  /**\n   * A pixel format containing red and green channels as integers.\n   * @type {number}\n   * @constant\n   */\n  RG_INTEGER: WebGLConstants.RG_INTEGER,\n\n  /**\n   * A pixel format containing red, green, and blue channels as integers.\n   * @type {number}\n   * @constant\n   */\n  RGB_INTEGER: WebGLConstants.RGB_INTEGER,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels as integers.\n   * @type {number}\n   * @constant\n   */\n  RGBA_INTEGER: WebGLConstants.RGBA_INTEGER,\n\n  /**\n   * A pixel format containing a luminance (intensity) channel.\n   *\n   * @type {number}\n   * @constant\n   */\n  LUMINANCE: WebGLConstants.LUMINANCE,\n\n  /**\n   * A pixel format containing luminance (intensity) and alpha channels.\n   *\n   * @type {number}\n   * @constant\n   */\n  LUMINANCE_ALPHA: WebGLConstants.LUMINANCE_ALPHA,\n\n  /**\n   * A pixel format containing red, green, and blue channels that is DXT1 compressed.\n   *\n   * @type {number}\n   * @constant\n   */\n  RGB_DXT1: WebGLConstants.COMPRESSED_RGB_S3TC_DXT1_EXT,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels that is DXT1 compressed.\n   *\n   * @type {number}\n   * @constant\n   */\n  RGBA_DXT1: WebGLConstants.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels that is DXT3 compressed.\n   *\n   * @type {number}\n   * @constant\n   */\n  RGBA_DXT3: WebGLConstants.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels that is DXT5 compressed.\n   *\n   * @type {number}\n   * @constant\n   */\n  RGBA_DXT5: WebGLConstants.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n\n  /**\n   * A pixel format containing red, green, and blue channels that is PVR 4bpp compressed.\n   *\n   * @type {number}\n   * @constant\n   */\n  RGB_PVRTC_4BPPV1: WebGLConstants.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,\n\n  /**\n   * A pixel format containing red, green, and blue channels that is PVR 2bpp compressed.\n   *\n   * @type {number}\n   * @constant\n   */\n  RGB_PVRTC_2BPPV1: WebGLConstants.COMPRESSED_RGB_PVRTC_2BPPV1_IMG,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels that is PVR 4bpp compressed.\n   *\n   * @type {number}\n   * @constant\n   */\n  RGBA_PVRTC_4BPPV1: WebGLConstants.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels that is PVR 2bpp compressed.\n   *\n   * @type {number}\n   * @constant\n   */\n  RGBA_PVRTC_2BPPV1: WebGLConstants.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels that is ASTC compressed.\n   *\n   * @type {number}\n   * @constant\n   */\n  RGBA_ASTC: WebGLConstants.COMPRESSED_RGBA_ASTC_4x4_WEBGL,\n\n  /**\n   * A pixel format containing red, green, and blue channels that is ETC1 compressed.\n   *\n   * @type {number}\n   * @constant\n   */\n  RGB_ETC1: WebGLConstants.COMPRESSED_RGB_ETC1_WEBGL,\n\n  /**\n   * A pixel format containing red, green, and blue channels that is ETC2 compressed.\n   *\n   * @type {number}\n   * @constant\n   */\n  RGB8_ETC2: WebGLConstants.COMPRESSED_RGB8_ETC2,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels that is ETC2 compressed.\n   *\n   * @type {number}\n   * @constant\n   */\n  RGBA8_ETC2_EAC: WebGLConstants.COMPRESSED_RGBA8_ETC2_EAC,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels that is BC7 compressed.\n   *\n   * @type {number}\n   * @constant\n   */\n  RGBA_BC7: WebGLConstants.COMPRESSED_RGBA_BPTC_UNORM,\n};\n\n/**\n * @private\n */\nPixelFormat.componentsLength = function (pixelFormat) {\n  switch (pixelFormat) {\n    case PixelFormat.RGB:\n    case PixelFormat.RGB_INTEGER:\n      return 3;\n    case PixelFormat.RGBA:\n    case PixelFormat.RGBA_INTEGER:\n      return 4;\n    case PixelFormat.LUMINANCE_ALPHA:\n    case PixelFormat.RG:\n    case PixelFormat.RG_INTEGER:\n      return 2;\n    case PixelFormat.ALPHA:\n    case PixelFormat.RED:\n    case PixelFormat.RED_INTEGER:\n    case PixelFormat.LUMINANCE:\n      return 1;\n    default:\n      return 1;\n  }\n};\n\n/**\n * @private\n */\nPixelFormat.validate = function (pixelFormat) {\n  return (\n    pixelFormat === PixelFormat.DEPTH_COMPONENT ||\n    pixelFormat === PixelFormat.DEPTH_STENCIL ||\n    pixelFormat === PixelFormat.ALPHA ||\n    pixelFormat === PixelFormat.RED ||\n    pixelFormat === PixelFormat.RG ||\n    pixelFormat === PixelFormat.RGB ||\n    pixelFormat === PixelFormat.RGBA ||\n    pixelFormat === PixelFormat.RED_INTEGER ||\n    pixelFormat === PixelFormat.RG_INTEGER ||\n    pixelFormat === PixelFormat.RGB_INTEGER ||\n    pixelFormat === PixelFormat.RGBA_INTEGER ||\n    pixelFormat === PixelFormat.LUMINANCE ||\n    pixelFormat === PixelFormat.LUMINANCE_ALPHA ||\n    pixelFormat === PixelFormat.RGB_DXT1 ||\n    pixelFormat === PixelFormat.RGBA_DXT1 ||\n    pixelFormat === PixelFormat.RGBA_DXT3 ||\n    pixelFormat === PixelFormat.RGBA_DXT5 ||\n    pixelFormat === PixelFormat.RGB_PVRTC_4BPPV1 ||\n    pixelFormat === PixelFormat.RGB_PVRTC_2BPPV1 ||\n    pixelFormat === PixelFormat.RGBA_PVRTC_4BPPV1 ||\n    pixelFormat === PixelFormat.RGBA_PVRTC_2BPPV1 ||\n    pixelFormat === PixelFormat.RGBA_ASTC ||\n    pixelFormat === PixelFormat.RGB_ETC1 ||\n    pixelFormat === PixelFormat.RGB8_ETC2 ||\n    pixelFormat === PixelFormat.RGBA8_ETC2_EAC ||\n    pixelFormat === PixelFormat.RGBA_BC7\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.isColorFormat = function (pixelFormat) {\n  return (\n    pixelFormat === PixelFormat.RED ||\n    pixelFormat === PixelFormat.ALPHA ||\n    pixelFormat === PixelFormat.RGB ||\n    pixelFormat === PixelFormat.RGBA ||\n    pixelFormat === PixelFormat.LUMINANCE ||\n    pixelFormat === PixelFormat.LUMINANCE_ALPHA\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.isDepthFormat = function (pixelFormat) {\n  return (\n    pixelFormat === PixelFormat.DEPTH_COMPONENT ||\n    pixelFormat === PixelFormat.DEPTH_STENCIL\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.isCompressedFormat = function (pixelFormat) {\n  return (\n    pixelFormat === PixelFormat.RGB_DXT1 ||\n    pixelFormat === PixelFormat.RGBA_DXT1 ||\n    pixelFormat === PixelFormat.RGBA_DXT3 ||\n    pixelFormat === PixelFormat.RGBA_DXT5 ||\n    pixelFormat === PixelFormat.RGB_PVRTC_4BPPV1 ||\n    pixelFormat === PixelFormat.RGB_PVRTC_2BPPV1 ||\n    pixelFormat === PixelFormat.RGBA_PVRTC_4BPPV1 ||\n    pixelFormat === PixelFormat.RGBA_PVRTC_2BPPV1 ||\n    pixelFormat === PixelFormat.RGBA_ASTC ||\n    pixelFormat === PixelFormat.RGB_ETC1 ||\n    pixelFormat === PixelFormat.RGB8_ETC2 ||\n    pixelFormat === PixelFormat.RGBA8_ETC2_EAC ||\n    pixelFormat === PixelFormat.RGBA_BC7\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.isDXTFormat = function (pixelFormat) {\n  return (\n    pixelFormat === PixelFormat.RGB_DXT1 ||\n    pixelFormat === PixelFormat.RGBA_DXT1 ||\n    pixelFormat === PixelFormat.RGBA_DXT3 ||\n    pixelFormat === PixelFormat.RGBA_DXT5\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.isPVRTCFormat = function (pixelFormat) {\n  return (\n    pixelFormat === PixelFormat.RGB_PVRTC_4BPPV1 ||\n    pixelFormat === PixelFormat.RGB_PVRTC_2BPPV1 ||\n    pixelFormat === PixelFormat.RGBA_PVRTC_4BPPV1 ||\n    pixelFormat === PixelFormat.RGBA_PVRTC_2BPPV1\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.isASTCFormat = function (pixelFormat) {\n  return pixelFormat === PixelFormat.RGBA_ASTC;\n};\n\n/**\n * @private\n */\nPixelFormat.isETC1Format = function (pixelFormat) {\n  return pixelFormat === PixelFormat.RGB_ETC1;\n};\n\n/**\n * @private\n */\nPixelFormat.isETC2Format = function (pixelFormat) {\n  return (\n    pixelFormat === PixelFormat.RGB8_ETC2 ||\n    pixelFormat === PixelFormat.RGBA8_ETC2_EAC\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.isBC7Format = function (pixelFormat) {\n  return pixelFormat === PixelFormat.RGBA_BC7;\n};\n\n/**\n * @private\n */\nPixelFormat.compressedTextureSizeInBytes = function (\n  pixelFormat,\n  width,\n  height,\n) {\n  switch (pixelFormat) {\n    case PixelFormat.RGB_DXT1:\n    case PixelFormat.RGBA_DXT1:\n    case PixelFormat.RGB_ETC1:\n    case PixelFormat.RGB8_ETC2:\n      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;\n\n    case PixelFormat.RGBA_DXT3:\n    case PixelFormat.RGBA_DXT5:\n    case PixelFormat.RGBA_ASTC:\n    case PixelFormat.RGBA8_ETC2_EAC:\n      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;\n\n    case PixelFormat.RGB_PVRTC_4BPPV1:\n    case PixelFormat.RGBA_PVRTC_4BPPV1:\n      return Math.floor((Math.max(width, 8) * Math.max(height, 8) * 4 + 7) / 8);\n\n    case PixelFormat.RGB_PVRTC_2BPPV1:\n    case PixelFormat.RGBA_PVRTC_2BPPV1:\n      return Math.floor(\n        (Math.max(width, 16) * Math.max(height, 8) * 2 + 7) / 8,\n      );\n\n    case PixelFormat.RGBA_BC7:\n      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;\n\n    default:\n      return 0;\n  }\n};\n\n/**\n * @private\n */\nPixelFormat.textureSizeInBytes = function (\n  pixelFormat,\n  pixelDatatype,\n  width,\n  height,\n) {\n  let componentsLength = PixelFormat.componentsLength(pixelFormat);\n  if (PixelDatatype.isPacked(pixelDatatype)) {\n    componentsLength = 1;\n  }\n  return (\n    componentsLength * PixelDatatype.sizeInBytes(pixelDatatype) * width * height\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.texture3DSizeInBytes = function (\n  pixelFormat,\n  pixelDatatype,\n  width,\n  height,\n  depth,\n) {\n  let componentsLength = PixelFormat.componentsLength(pixelFormat);\n  if (PixelDatatype.isPacked(pixelDatatype)) {\n    componentsLength = 1;\n  }\n  return (\n    componentsLength *\n    PixelDatatype.sizeInBytes(pixelDatatype) *\n    width *\n    height *\n    depth\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.alignmentInBytes = function (pixelFormat, pixelDatatype, width) {\n  const mod =\n    PixelFormat.textureSizeInBytes(pixelFormat, pixelDatatype, width, 1) % 4;\n  return mod === 0 ? 4 : mod === 2 ? 2 : 1;\n};\n\n/**\n * @private\n * @param {PixelFormat} pixelFormat The pixel format.\n * @param {PixelDatatype} pixelDatatype The pixel datatype.\n * @param {number} width The width of the texture.\n * @param {number} height The height of the texture.\n * @returns {TypedArray} The typed array.\n */\nPixelFormat.createTypedArray = function (\n  pixelFormat,\n  pixelDatatype,\n  width,\n  height,\n) {\n  const constructor = PixelDatatype.getTypedArrayConstructor(pixelDatatype);\n  const size = PixelFormat.componentsLength(pixelFormat) * width * height;\n  return new constructor(size);\n};\n\n/**\n * @private\n */\nPixelFormat.flipY = function (\n  bufferView,\n  pixelFormat,\n  pixelDatatype,\n  width,\n  height,\n) {\n  if (height === 1) {\n    return bufferView;\n  }\n  const flipped = PixelFormat.createTypedArray(\n    pixelFormat,\n    pixelDatatype,\n    width,\n    height,\n  );\n  const numberOfComponents = PixelFormat.componentsLength(pixelFormat);\n  const textureWidth = width * numberOfComponents;\n  for (let i = 0; i < height; ++i) {\n    const row = i * width * numberOfComponents;\n    const flippedRow = (height - i - 1) * width * numberOfComponents;\n    for (let j = 0; j < textureWidth; ++j) {\n      flipped[flippedRow + j] = bufferView[row + j];\n    }\n  }\n  return flipped;\n};\n\n/**\n * @private\n */\nPixelFormat.toInternalFormat = function (pixelFormat, pixelDatatype, context) {\n  // WebGL 1 require internalFormat to be the same as PixelFormat\n  if (!context.webgl2) {\n    return pixelFormat;\n  }\n\n  // Convert pixelFormat to correct internalFormat for WebGL 2\n  if (pixelFormat === PixelFormat.DEPTH_STENCIL) {\n    return WebGLConstants.DEPTH24_STENCIL8;\n  }\n\n  if (pixelFormat === PixelFormat.DEPTH_COMPONENT) {\n    if (pixelDatatype === PixelDatatype.UNSIGNED_SHORT) {\n      return WebGLConstants.DEPTH_COMPONENT16;\n    } else if (pixelDatatype === PixelDatatype.UNSIGNED_INT) {\n      return WebGLConstants.DEPTH_COMPONENT24;\n    }\n  }\n\n  if (pixelDatatype === PixelDatatype.FLOAT) {\n    switch (pixelFormat) {\n      case PixelFormat.RGBA:\n        return WebGLConstants.RGBA32F;\n      case PixelFormat.RGB:\n        return WebGLConstants.RGB32F;\n      case PixelFormat.RG:\n        return WebGLConstants.RG32F;\n      case PixelFormat.RED:\n        return WebGLConstants.R32F;\n    }\n  }\n\n  if (pixelDatatype === PixelDatatype.HALF_FLOAT) {\n    switch (pixelFormat) {\n      case PixelFormat.RGBA:\n        return WebGLConstants.RGBA16F;\n      case PixelFormat.RGB:\n        return WebGLConstants.RGB16F;\n      case PixelFormat.RG:\n        return WebGLConstants.RG16F;\n      case PixelFormat.RED:\n        return WebGLConstants.R16F;\n    }\n  }\n\n  if (pixelDatatype === PixelDatatype.UNSIGNED_BYTE) {\n    switch (pixelFormat) {\n      case PixelFormat.RGBA:\n        return WebGLConstants.RGBA8;\n      case PixelFormat.RGB:\n        return WebGLConstants.RGB8;\n      case PixelFormat.RG:\n        return WebGLConstants.RG8;\n      case PixelFormat.RED:\n        return WebGLConstants.R8;\n    }\n  }\n\n  if (pixelDatatype === PixelDatatype.INT) {\n    switch (pixelFormat) {\n      case PixelFormat.RGBA_INTEGER:\n        return WebGLConstants.RGBA32I;\n      case PixelFormat.RGB_INTEGER:\n        return WebGLConstants.RGB32I;\n      case PixelFormat.RG_INTEGER:\n        return WebGLConstants.RG32I;\n      case PixelFormat.RED_INTEGER:\n        return WebGLConstants.R32I;\n    }\n  }\n\n  if (pixelDatatype === PixelDatatype.UNSIGNED_INT) {\n    switch (pixelFormat) {\n      case PixelFormat.RGBA_INTEGER:\n        return WebGLConstants.RGBA32UI;\n      case PixelFormat.RGB_INTEGER:\n        return WebGLConstants.RGB32UI;\n      case PixelFormat.RG_INTEGER:\n        return WebGLConstants.RG32UI;\n      case PixelFormat.RED_INTEGER:\n        return WebGLConstants.R32UI;\n    }\n  }\n\n  return pixelFormat;\n};\n\nexport default Object.freeze(PixelFormat);\n"],"names":["PixelFormat","DEPTH_COMPONENT","DEPTH_STENCIL","ALPHA","RED","RG","RGB","RGBA","RED_INTEGER","RG_INTEGER","RGB_INTEGER","RGBA_INTEGER","LUMINANCE","LUMINANCE_ALPHA","RGB_DXT1","COMPRESSED_RGB_S3TC_DXT1_EXT","RGBA_DXT1","COMPRESSED_RGBA_S3TC_DXT1_EXT","RGBA_DXT3","COMPRESSED_RGBA_S3TC_DXT3_EXT","RGBA_DXT5","COMPRESSED_RGBA_S3TC_DXT5_EXT","RGB_PVRTC_4BPPV1","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","RGB_PVRTC_2BPPV1","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","RGBA_PVRTC_4BPPV1","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","RGBA_PVRTC_2BPPV1","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","RGBA_ASTC","COMPRESSED_RGBA_ASTC_4x4_WEBGL","RGB_ETC1","COMPRESSED_RGB_ETC1_WEBGL","RGB8_ETC2","COMPRESSED_RGB8_ETC2","RGBA8_ETC2_EAC","COMPRESSED_RGBA8_ETC2_EAC","RGBA_BC7","COMPRESSED_RGBA_BPTC_UNORM","componentsLength","pixelFormat","validate","isColorFormat","isDepthFormat","isCompressedFormat","isDXTFormat","isPVRTCFormat","isASTCFormat","isETC1Format","isETC2Format","isBC7Format","compressedTextureSizeInBytes","width","height","Math","floor","max","ceil","textureSizeInBytes","pixelDatatype","isPacked","sizeInBytes","texture3DSizeInBytes","depth","alignmentInBytes","mod","createTypedArray","constructor","getTypedArrayConstructor","size","flipY","bufferView","flipped","numberOfComponents","textureWidth","i","row","flippedRow","j","toInternalFormat","context","webgl2","DEPTH24_STENCIL8","UNSIGNED_SHORT","DEPTH_COMPONENT16","UNSIGNED_INT","DEPTH_COMPONENT24","FLOAT","RGBA32F","RGB32F","RG32F","R32F","HALF_FLOAT","RGBA16F","RGB16F","RG16F","R16F","UNSIGNED_BYTE","RGBA8","RGB8","RG8","R8","INT","RGBA32I","RGB32I","RG32I","R32I","RGBA32UI","RGB32UI","RG32UI","R32UI","Object","freeze"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 30048, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/subdivideArray.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Subdivides an array into a number of smaller, equal sized arrays.\n *\n * @function subdivideArray\n *\n * @param {Array} array The array to divide.\n * @param {number} numberOfArrays The number of arrays to divide the provided array into.\n *\n * @exception {DeveloperError} numberOfArrays must be greater than 0.\n */\nfunction subdivideArray(array, numberOfArrays) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required.\");\n  }\n\n  if (!defined(numberOfArrays) || numberOfArrays < 1) {\n    throw new DeveloperError(\"numberOfArrays must be greater than 0.\");\n  }\n  //>>includeEnd('debug');\n\n  const result = [];\n  const len = array.length;\n  let i = 0;\n  while (i < len) {\n    const size = Math.ceil((len - i) / numberOfArrays--);\n    result.push(array.slice(i, i + size));\n    i += size;\n  }\n  return result;\n}\nexport default subdivideArray;\n"],"names":["subdivideArray","array","numberOfArrays","result","len","length","i","size","Math","ceil","push","slice"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;;;CASC,GACD,SAASA,eAAeC,KAAK,EAAEC,cAAc;IAC3C,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACD,QAAQ;QACnB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IAEA,IAAI,CAAC,IAAA,6KAAO,EAACC,mBAAmBA,iBAAiB,GAAG;QAClD,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAMC,SAAS,EAAE;IACjB,MAAMC,MAAMH,MAAMI,MAAM;IACxB,IAAIC,IAAI;IACR,MAAOA,IAAIF,IAAK;QACd,MAAMG,OAAOC,KAAKC,IAAI,CAAC,CAACL,MAAME,CAAC,IAAIJ;QACnCC,OAAOO,IAAI,CAACT,MAAMU,KAAK,CAACL,GAAGA,IAAIC;QAC/BD,KAAKC;IACP;IACA,OAAOJ;AACT;uCACeH","ignoreList":[0]}},
    {"offset": {"line": 30089, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/OffsetGeometryInstanceAttribute.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Value and type information for per-instance geometry attribute that determines the geometry instance offset\n *\n * @alias OffsetGeometryInstanceAttribute\n * @constructor\n *\n * @param {number} [x=0] The x translation\n * @param {number} [y=0] The y translation\n * @param {number} [z=0] The z translation\n *\n * @private\n *\n * @see GeometryInstance\n * @see GeometryInstanceAttribute\n */\nfunction OffsetGeometryInstanceAttribute(x, y, z) {\n  x = x ?? 0;\n  y = y ?? 0;\n  z = z ?? 0;\n\n  /**\n   * The values for the attributes stored in a typed array.\n   *\n   * @type Float32Array\n   */\n  this.value = new Float32Array([x, y, z]);\n}\n\nObject.defineProperties(OffsetGeometryInstanceAttribute.prototype, {\n  /**\n   * The datatype of each component in the attribute, e.g., individual elements in\n   * {@link OffsetGeometryInstanceAttribute#value}.\n   *\n   * @memberof OffsetGeometryInstanceAttribute.prototype\n   *\n   * @type {ComponentDatatype}\n   * @readonly\n   *\n   * @default {@link ComponentDatatype.FLOAT}\n   */\n  componentDatatype: {\n    get: function () {\n      return ComponentDatatype.FLOAT;\n    },\n  },\n\n  /**\n   * The number of components in the attributes, i.e., {@link OffsetGeometryInstanceAttribute#value}.\n   *\n   * @memberof OffsetGeometryInstanceAttribute.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @default 3\n   */\n  componentsPerAttribute: {\n    get: function () {\n      return 3;\n    },\n  },\n\n  /**\n   * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n   * indicate that the components should be mapped to the range [0, 1] (unsigned)\n   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n   *\n   * @memberof OffsetGeometryInstanceAttribute.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  normalize: {\n    get: function () {\n      return false;\n    },\n  },\n});\n\n/**\n * Creates a new {@link OffsetGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.\n *\n * @param {Cartesian3} offset The cartesian offset\n * @returns {OffsetGeometryInstanceAttribute} The new {@link OffsetGeometryInstanceAttribute} instance.\n */\nOffsetGeometryInstanceAttribute.fromCartesian3 = function (offset) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"offset\", offset);\n  //>>includeEnd('debug');\n\n  return new OffsetGeometryInstanceAttribute(offset.x, offset.y, offset.z);\n};\n\n/**\n * Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.\n *\n * @param {Cartesian3} offset The cartesian offset\n * @param {Float32Array} [result] The array to store the result in, if undefined a new instance will be created.\n * @returns {Float32Array} The modified result parameter or a new instance if result was undefined.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.modelMatrix = Cesium.OffsetGeometryInstanceAttribute.toValue(modelMatrix, attributes.modelMatrix);\n */\nOffsetGeometryInstanceAttribute.toValue = function (offset, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"offset\", offset);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Float32Array([offset.x, offset.y, offset.z]);\n  }\n\n  result[0] = offset.x;\n  result[1] = offset.y;\n  result[2] = offset.z;\n  return result;\n};\nexport default OffsetGeometryInstanceAttribute;\n"],"names":["OffsetGeometryInstanceAttribute","x","y","z","value","Float32Array","Object","defineProperties","prototype","componentDatatype","get","FLOAT","componentsPerAttribute","normalize","fromCartesian3","offset","defined","toValue","result"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;;;;;;;CAcC,GACD,SAASA,gCAAgCC,CAAC,EAAEC,CAAC,EAAEC,CAAC;IAC9CF,IAAIA,KAAK;IACTC,IAAIA,KAAK;IACTC,IAAIA,KAAK;IAET;;;;GAIC,GACD,IAAI,CAACC,KAAK,GAAG,IAAIC,aAAa;QAACJ;QAAGC;QAAGC;KAAE;AACzC;AAEAG,OAAOC,gBAAgB,CAACP,gCAAgCQ,SAAS,EAAE;IACjE;;;;;;;;;;GAUC,GACDC,mBAAmB;QACjBC,KAAK;YACH,OAAO,uLAAiB,CAACC,KAAK;QAChC;IACF;IAEA;;;;;;;;;GASC,GACDC,wBAAwB;QACtBF,KAAK;YACH,OAAO;QACT;IACF;IAEA;;;;;;;;;;;GAWC,GACDG,WAAW;QACTH,KAAK;YACH,OAAO;QACT;IACF;AACF;AAEA;;;;;CAKC,GACDV,gCAAgCc,cAAc,GAAG,SAAUC,MAAM;IAC/D,yCAAyC;IACzC,2KAAK,CAACC,OAAO,CAAC,UAAUD;IACxB,wBAAwB;IAExB,OAAO,IAAIf,gCAAgCe,OAAOd,CAAC,EAAEc,OAAOb,CAAC,EAAEa,OAAOZ,CAAC;AACzE;AAEA;;;;;;;;;;CAUC,GACDH,gCAAgCiB,OAAO,GAAG,SAAUF,MAAM,EAAEG,MAAM;IAChE,yCAAyC;IACzC,2KAAK,CAACF,OAAO,CAAC,UAAUD;IACxB,wBAAwB;IAExB,IAAI,CAAC,IAAA,6KAAO,EAACG,SAAS;QACpBA,SAAS,IAAIb,aAAa;YAACU,OAAOd,CAAC;YAAEc,OAAOb,CAAC;YAAEa,OAAOZ,CAAC;SAAC;IAC1D;IAEAe,MAAM,CAAC,EAAE,GAAGH,OAAOd,CAAC;IACpBiB,MAAM,CAAC,EAAE,GAAGH,OAAOb,CAAC;IACpBgB,MAAM,CAAC,EAAE,GAAGH,OAAOZ,CAAC;IACpB,OAAOe;AACT;uCACelB","ignoreList":[0]}},
    {"offset": {"line": 30216, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/AxisAlignedBoundingBox.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport Intersect from \"./Intersect.js\";\n\n/**\n * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n * @alias AxisAlignedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [minimum=Cartesian3.ZERO] The minimum point along the x, y, and z axes.\n * @param {Cartesian3} [maximum=Cartesian3.ZERO] The maximum point along the x, y, and z axes.\n * @param {Cartesian3} [center] The center of the box; automatically computed if not supplied.\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nfunction AxisAlignedBoundingBox(minimum, maximum, center) {\n  /**\n   * The minimum point defining the bounding box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.minimum = Cartesian3.clone(minimum ?? Cartesian3.ZERO);\n\n  /**\n   * The maximum point defining the bounding box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.maximum = Cartesian3.clone(maximum ?? Cartesian3.ZERO);\n\n  // If center was not defined, compute it.\n  if (!defined(center)) {\n    center = Cartesian3.midpoint(this.minimum, this.maximum, new Cartesian3());\n  } else {\n    center = Cartesian3.clone(center);\n  }\n\n  /**\n   * The center point of the bounding box.\n   * @type {Cartesian3}\n   */\n  this.center = center;\n}\n\n/**\n * Creates an instance of an AxisAlignedBoundingBox from its corners.\n *\n * @param {Cartesian3} minimum The minimum point along the x, y, and z axes.\n * @param {Cartesian3} maximum The maximum point along the x, y, and z axes.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an axis aligned bounding box from the two corners.\n * const box = Cesium.AxisAlignedBoundingBox.fromCorners(new Cesium.Cartesian3(-1, -1, -1), new Cesium.Cartesian3(1, 1, 1));\n */\nAxisAlignedBoundingBox.fromCorners = function (minimum, maximum, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"minimum\", minimum);\n  Check.defined(\"maximum\", maximum);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new AxisAlignedBoundingBox();\n  }\n\n  result.minimum = Cartesian3.clone(minimum, result.minimum);\n  result.maximum = Cartesian3.clone(maximum, result.maximum);\n  result.center = Cartesian3.midpoint(minimum, maximum, result.center);\n\n  return result;\n};\n\n/**\n * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n * finding the points spaced the farthest apart on the x, y, and z axes.\n *\n * @param {Cartesian3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an axis aligned bounding box enclosing two points.\n * const box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\nAxisAlignedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new AxisAlignedBoundingBox();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.minimum = Cartesian3.clone(Cartesian3.ZERO, result.minimum);\n    result.maximum = Cartesian3.clone(Cartesian3.ZERO, result.maximum);\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    return result;\n  }\n\n  let minimumX = positions[0].x;\n  let minimumY = positions[0].y;\n  let minimumZ = positions[0].z;\n\n  let maximumX = positions[0].x;\n  let maximumY = positions[0].y;\n  let maximumZ = positions[0].z;\n\n  const length = positions.length;\n  for (let i = 1; i < length; i++) {\n    const p = positions[i];\n    const x = p.x;\n    const y = p.y;\n    const z = p.z;\n\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n\n  const minimum = result.minimum;\n  minimum.x = minimumX;\n  minimum.y = minimumY;\n  minimum.z = minimumZ;\n\n  const maximum = result.maximum;\n  maximum.x = maximumX;\n  maximum.y = maximumY;\n  maximum.z = maximumZ;\n\n  result.center = Cartesian3.midpoint(minimum, maximum, result.center);\n\n  return result;\n};\n\n/**\n * Duplicates a AxisAlignedBoundingBox instance.\n *\n * @param {AxisAlignedBoundingBox} box The bounding box to duplicate.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\nAxisAlignedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new AxisAlignedBoundingBox(box.minimum, box.maximum, box.center);\n  }\n\n  result.minimum = Cartesian3.clone(box.minimum, result.minimum);\n  result.maximum = Cartesian3.clone(box.maximum, result.maximum);\n  result.center = Cartesian3.clone(box.center, result.center);\n  return result;\n};\n\n/**\n * Compares the provided AxisAlignedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {AxisAlignedBoundingBox} [left] The first AxisAlignedBoundingBox.\n * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nAxisAlignedBoundingBox.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      Cartesian3.equals(left.minimum, right.minimum) &&\n      Cartesian3.equals(left.maximum, right.maximum))\n  );\n};\n\nlet intersectScratch = new Cartesian3();\n/**\n * Determines which side of a plane a box is located.\n *\n * @param {AxisAlignedBoundingBox} box The bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nAxisAlignedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"box\", box);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  intersectScratch = Cartesian3.subtract(\n    box.maximum,\n    box.minimum,\n    intersectScratch,\n  );\n  const h = Cartesian3.multiplyByScalar(\n    intersectScratch,\n    0.5,\n    intersectScratch,\n  ); //The positive half diagonal\n  const normal = plane.normal;\n  const e =\n    h.x * Math.abs(normal.x) +\n    h.y * Math.abs(normal.y) +\n    h.z * Math.abs(normal.z);\n  const s = Cartesian3.dot(box.center, normal) + plane.distance; //signed distance from center\n\n  if (s - e > 0) {\n    return Intersect.INSIDE;\n  }\n\n  if (s + e < 0) {\n    //Not in front because normals point inward\n    return Intersect.OUTSIDE;\n  }\n\n  return Intersect.INTERSECTING;\n};\n\n/**\n * Determines whether two axis aligned bounding boxes intersect.\n *\n * @param {AxisAlignedBoundingBox} box first box\n * @param {AxisAlignedBoundingBox} other second box\n * @returns {boolean} <code>true</code> if the boxes intersect; otherwise, <code>false</code>.\n */\nAxisAlignedBoundingBox.intersectAxisAlignedBoundingBox = function (box, other) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"box\", box);\n  Check.defined(\"other\", other);\n  //>>includeEnd('debug');\n\n  // This short circuits in favor of AABBs that do not intersect.\n  return (\n    box.minimum.x <= other.maximum.x &&\n    box.maximum.x >= other.minimum.x &&\n    box.minimum.y <= other.maximum.y &&\n    box.maximum.y >= other.minimum.y &&\n    box.minimum.z <= other.maximum.z &&\n    box.maximum.z >= other.minimum.z\n  );\n};\n\n/**\n * Duplicates this AxisAlignedBoundingBox instance.\n *\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n */\nAxisAlignedBoundingBox.prototype.clone = function (result) {\n  return AxisAlignedBoundingBox.clone(this, result);\n};\n\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nAxisAlignedBoundingBox.prototype.intersectPlane = function (plane) {\n  return AxisAlignedBoundingBox.intersectPlane(this, plane);\n};\n\n/**\n * Determines whether some other axis aligned bounding box intersects this box.\n *\n * @param {AxisAlignedBoundingBox} other The other axis aligned bounding box.\n * @returns {boolean} <code>true</code> if the boxes intersect; otherwise, <code>false</code>.\n */\nAxisAlignedBoundingBox.prototype.intersectAxisAlignedBoundingBox = function (\n  other,\n) {\n  return AxisAlignedBoundingBox.intersectAxisAlignedBoundingBox(this, other);\n};\n\n/**\n * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {AxisAlignedBoundingBox} [right] The right hand side AxisAlignedBoundingBox.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nAxisAlignedBoundingBox.prototype.equals = function (right) {\n  return AxisAlignedBoundingBox.equals(this, right);\n};\nexport default AxisAlignedBoundingBox;\n"],"names":["AxisAlignedBoundingBox","minimum","maximum","center","clone","ZERO","midpoint","fromCorners","result","defined","fromPoints","positions","length","minimumX","x","minimumY","y","minimumZ","z","maximumX","maximumY","maximumZ","i","p","Math","min","max","box","undefined","equals","left","right","intersectScratch","intersectPlane","plane","subtract","h","multiplyByScalar","normal","e","abs","s","dot","distance","INSIDE","OUTSIDE","INTERSECTING","intersectAxisAlignedBoundingBox","other","prototype"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 30448, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/EllipsoidTangentPlane.js"],"sourcesContent":["import AxisAlignedBoundingBox from \"./AxisAlignedBoundingBox.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport Ray from \"./Ray.js\";\nimport Transforms from \"./Transforms.js\";\n\nconst scratchCart4 = new Cartesian4();\n/**\n * A plane tangent to the provided ellipsoid at the provided origin.\n * If origin is not on the surface of the ellipsoid, it's surface projection will be used.\n * If origin is at the center of the ellipsoid, an exception will be thrown.\n * @alias EllipsoidTangentPlane\n * @constructor\n *\n * @param {Cartesian3} origin The point on the surface of the ellipsoid where the tangent plane touches.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to use.\n *\n * @exception {DeveloperError} origin must not be at the center of the ellipsoid.\n */\nfunction EllipsoidTangentPlane(origin, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"origin\", origin);\n  //>>includeEnd('debug');\n\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n  origin = ellipsoid.scaleToGeodeticSurface(origin);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(origin)) {\n    throw new DeveloperError(\n      \"origin must not be at the center of the ellipsoid.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const eastNorthUp = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid);\n  this._ellipsoid = ellipsoid;\n  this._origin = origin;\n  this._xAxis = Cartesian3.fromCartesian4(\n    Matrix4.getColumn(eastNorthUp, 0, scratchCart4),\n  );\n  this._yAxis = Cartesian3.fromCartesian4(\n    Matrix4.getColumn(eastNorthUp, 1, scratchCart4),\n  );\n\n  const normal = Cartesian3.fromCartesian4(\n    Matrix4.getColumn(eastNorthUp, 2, scratchCart4),\n  );\n  this._plane = Plane.fromPointNormal(origin, normal);\n}\n\nObject.defineProperties(EllipsoidTangentPlane.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the origin.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @type {Cartesian3}\n   */\n  origin: {\n    get: function () {\n      return this._origin;\n    },\n  },\n\n  /**\n   * Gets the plane which is tangent to the ellipsoid.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Plane}\n   */\n  plane: {\n    get: function () {\n      return this._plane;\n    },\n  },\n\n  /**\n   * Gets the local X-axis (east) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  xAxis: {\n    get: function () {\n      return this._xAxis;\n    },\n  },\n\n  /**\n   * Gets the local Y-axis (north) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  yAxis: {\n    get: function () {\n      return this._yAxis;\n    },\n  },\n\n  /**\n   * Gets the local Z-axis (up) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  zAxis: {\n    get: function () {\n      return this._plane.normal;\n    },\n  },\n});\n\nconst tmp = new AxisAlignedBoundingBox();\n/**\n * Creates a new instance from the provided ellipsoid and the center\n * point of the provided Cartesians.\n *\n * @param {Cartesian3[]} cartesians The list of positions surrounding the center point.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to use.\n * @returns {EllipsoidTangentPlane} The new instance of EllipsoidTangentPlane.\n */\nEllipsoidTangentPlane.fromPoints = function (cartesians, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  const box = AxisAlignedBoundingBox.fromPoints(cartesians, tmp);\n  return new EllipsoidTangentPlane(box.center, ellipsoid);\n};\n\nconst scratchProjectPointOntoPlaneRay = new Ray();\nconst scratchProjectPointOntoPlaneCartesian3 = new Cartesian3();\n\n/**\n * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided. Undefined if there is no intersection point\n */\nEllipsoidTangentPlane.prototype.projectPointOntoPlane = function (\n  cartesian,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  const ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = cartesian;\n  Cartesian3.normalize(cartesian, ray.direction);\n\n  let intersectionPoint = IntersectionTests.rayPlane(\n    ray,\n    this._plane,\n    scratchProjectPointOntoPlaneCartesian3,\n  );\n  if (!defined(intersectionPoint)) {\n    Cartesian3.negate(ray.direction, ray.direction);\n    intersectionPoint = IntersectionTests.rayPlane(\n      ray,\n      this._plane,\n      scratchProjectPointOntoPlaneCartesian3,\n    );\n  }\n\n  if (defined(intersectionPoint)) {\n    const v = Cartesian3.subtract(\n      intersectionPoint,\n      this._origin,\n      intersectionPoint,\n    );\n    const x = Cartesian3.dot(this._xAxis, v);\n    const y = Cartesian3.dot(this._yAxis, v);\n\n    if (!defined(result)) {\n      return new Cartesian2(x, y);\n    }\n    result.x = x;\n    result.y = y;\n    return result;\n  }\n  return undefined;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.\n * The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.\n *\n * @see EllipsoidTangentPlane.projectPointOntoPlane\n *\n * @param {Cartesian3[]} cartesians The array of points to project.\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointsOntoPlane = function (\n  cartesians,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  let count = 0;\n  const length = cartesians.length;\n  for (let i = 0; i < length; i++) {\n    const p = this.projectPointOntoPlane(cartesians[i], result[count]);\n    if (defined(p)) {\n      result[count] = p;\n      count++;\n    }\n  }\n  result.length = count;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointToNearestOnPlane = function (\n  cartesian,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  const ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = cartesian;\n  Cartesian3.clone(this._plane.normal, ray.direction);\n\n  let intersectionPoint = IntersectionTests.rayPlane(\n    ray,\n    this._plane,\n    scratchProjectPointOntoPlaneCartesian3,\n  );\n  if (!defined(intersectionPoint)) {\n    Cartesian3.negate(ray.direction, ray.direction);\n    intersectionPoint = IntersectionTests.rayPlane(\n      ray,\n      this._plane,\n      scratchProjectPointOntoPlaneCartesian3,\n    );\n  }\n\n  const v = Cartesian3.subtract(\n    intersectionPoint,\n    this._origin,\n    intersectionPoint,\n  );\n  const x = Cartesian3.dot(this._xAxis, v);\n  const y = Cartesian3.dot(this._yAxis, v);\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.\n *\n * @see EllipsoidTangentPlane.projectPointToNearestOnPlane\n *\n * @param {Cartesian3[]} cartesians The array of points to project.\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided. This will have the same length as <code>cartesians</code>.\n */\nEllipsoidTangentPlane.prototype.projectPointsToNearestOnPlane = function (\n  cartesians,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  const length = cartesians.length;\n  result.length = length;\n  for (let i = 0; i < length; i++) {\n    result[i] = this.projectPointToNearestOnPlane(cartesians[i], result[i]);\n  }\n  return result;\n};\n\nconst projectPointsOntoEllipsoidScratch = new Cartesian3();\n/**\n * Computes the projection of the provided 2D position onto the 3D ellipsoid.\n *\n * @param {Cartesian2} cartesian The points to project.\n * @param {Cartesian3} [result] The Cartesian3 instance to store result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointOntoEllipsoid = function (\n  cartesian,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const ellipsoid = this._ellipsoid;\n  const origin = this._origin;\n  const xAxis = this._xAxis;\n  const yAxis = this._yAxis;\n  const tmp = projectPointsOntoEllipsoidScratch;\n\n  Cartesian3.multiplyByScalar(xAxis, cartesian.x, tmp);\n  result = Cartesian3.add(origin, tmp, result);\n  Cartesian3.multiplyByScalar(yAxis, cartesian.y, tmp);\n  Cartesian3.add(result, tmp, result);\n  ellipsoid.scaleToGeocentricSurface(result, result);\n\n  return result;\n};\n\n/**\n * Computes the projection of the provided 2D positions onto the 3D ellipsoid.\n *\n * @param {Cartesian2[]} cartesians The array of points to project.\n * @param {Cartesian3[]} [result] The array of Cartesian3 instances onto which to store results.\n * @returns {Cartesian3[]} The modified result parameter or a new array of Cartesian3 instances if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function (\n  cartesians,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  const length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    result[i] = this.projectPointOntoEllipsoid(cartesians[i], result[i]);\n  }\n\n  return result;\n};\nexport default EllipsoidTangentPlane;\n"],"names":["scratchCart4","EllipsoidTangentPlane","origin","ellipsoid","defined","default","scaleToGeodeticSurface","eastNorthUp","eastNorthUpToFixedFrame","_ellipsoid","_origin","_xAxis","fromCartesian4","getColumn","_yAxis","normal","_plane","fromPointNormal","Object","defineProperties","prototype","get","plane","xAxis","yAxis","zAxis","tmp","fromPoints","cartesians","box","center","scratchProjectPointOntoPlaneRay","scratchProjectPointOntoPlaneCartesian3","projectPointOntoPlane","cartesian","result","ray","normalize","direction","intersectionPoint","rayPlane","negate","v","subtract","x","dot","y","undefined","projectPointsOntoPlane","count","length","i","p","projectPointToNearestOnPlane","clone","projectPointsToNearestOnPlane","projectPointsOntoEllipsoidScratch","projectPointOntoEllipsoid","multiplyByScalar","add","scaleToGeocentricSurface","projectPointsOntoEllipsoid","Array"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 30747, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/OrientedBoundingBox.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Intersect from \"./Intersect.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Creates an instance of an OrientedBoundingBox.\n * An OrientedBoundingBox of some object is a closed and convex rectangular cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\n * @alias OrientedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\n *                                          Equivalently, the transformation matrix, to rotate and scale a 2x2x2\n *                                          cube centered at the origin.\n *\n *\n * @example\n * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\n * const center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\n * const halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\n *\n * const obb = new Cesium.OrientedBoundingBox(center, halfAxes);\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nfunction OrientedBoundingBox(center, halfAxes) {\n  /**\n   * The center of the box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Cartesian3.clone(center ?? Cartesian3.ZERO);\n  /**\n   * The three orthogonal half-axes of the bounding box. Equivalently, the\n   * transformation matrix, to rotate and scale a 2x2x2 cube centered at the\n   * origin.\n   * @type {Matrix3}\n   * @default {@link Matrix3.ZERO}\n   */\n  this.halfAxes = Matrix3.clone(halfAxes ?? Matrix3.ZERO);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nOrientedBoundingBox.packedLength =\n  Cartesian3.packedLength + Matrix3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {OrientedBoundingBox} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nOrientedBoundingBox.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  Cartesian3.pack(value.center, array, startingIndex);\n  Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {OrientedBoundingBox} [result] The object into which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  Cartesian3.unpack(array, startingIndex, result.center);\n  Matrix3.unpack(\n    array,\n    startingIndex + Cartesian3.packedLength,\n    result.halfAxes,\n  );\n  return result;\n};\n\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4 = new Cartesian3();\nconst scratchCartesian5 = new Cartesian3();\nconst scratchCartesian6 = new Cartesian3();\nconst scratchCovarianceResult = new Matrix3();\nconst scratchEigenResult = {\n  unitary: new Matrix3(),\n  diagonal: new Matrix3(),\n};\n\n/**\n * Computes an instance of an OrientedBoundingBox of the given positions.\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\n *\n * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an object oriented bounding box enclosing two points.\n * const box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\nOrientedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.halfAxes = Matrix3.ZERO;\n    result.center = Cartesian3.ZERO;\n    return result;\n  }\n\n  let i;\n  const length = positions.length;\n\n  const meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\n  for (i = 1; i < length; i++) {\n    Cartesian3.add(meanPoint, positions[i], meanPoint);\n  }\n  const invLength = 1.0 / length;\n  Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\n\n  let exx = 0.0;\n  let exy = 0.0;\n  let exz = 0.0;\n  let eyy = 0.0;\n  let eyz = 0.0;\n  let ezz = 0.0;\n  let p;\n\n  for (i = 0; i < length; i++) {\n    p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n\n  const covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n\n  const eigenDecomposition = Matrix3.computeEigenDecomposition(\n    covarianceMatrix,\n    scratchEigenResult,\n  );\n  const rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\n\n  let v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\n  let v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\n  let v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\n\n  let u1 = -Number.MAX_VALUE;\n  let u2 = -Number.MAX_VALUE;\n  let u3 = -Number.MAX_VALUE;\n  let l1 = Number.MAX_VALUE;\n  let l2 = Number.MAX_VALUE;\n  let l3 = Number.MAX_VALUE;\n\n  for (i = 0; i < length; i++) {\n    p = positions[i];\n    u1 = Math.max(Cartesian3.dot(v1, p), u1);\n    u2 = Math.max(Cartesian3.dot(v2, p), u2);\n    u3 = Math.max(Cartesian3.dot(v3, p), u3);\n\n    l1 = Math.min(Cartesian3.dot(v1, p), l1);\n    l2 = Math.min(Cartesian3.dot(v2, p), l2);\n    l3 = Math.min(Cartesian3.dot(v3, p), l3);\n  }\n\n  v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\n  v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\n  v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\n\n  const center = Cartesian3.add(v1, v2, result.center);\n  Cartesian3.add(center, v3, center);\n\n  const scale = scratchCartesian3;\n  scale.x = u1 - l1;\n  scale.y = u2 - l2;\n  scale.z = u3 - l3;\n  Cartesian3.multiplyByScalar(scale, 0.5, scale);\n  Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\n\n  return result;\n};\n\nconst scratchOffset = new Cartesian3();\nconst scratchScale = new Cartesian3();\nfunction fromPlaneExtents(\n  planeOrigin,\n  planeXAxis,\n  planeYAxis,\n  planeZAxis,\n  minimumX,\n  maximumX,\n  minimumY,\n  maximumY,\n  minimumZ,\n  maximumZ,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(minimumX) ||\n    !defined(maximumX) ||\n    !defined(minimumY) ||\n    !defined(maximumY) ||\n    !defined(minimumZ) ||\n    !defined(maximumZ)\n  ) {\n    throw new DeveloperError(\n      \"all extents (minimum/maximum X/Y/Z) are required.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  const halfAxes = result.halfAxes;\n  Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\n\n  let centerOffset = scratchOffset;\n  centerOffset.x = (minimumX + maximumX) / 2.0;\n  centerOffset.y = (minimumY + maximumY) / 2.0;\n  centerOffset.z = (minimumZ + maximumZ) / 2.0;\n\n  const scale = scratchScale;\n  scale.x = (maximumX - minimumX) / 2.0;\n  scale.y = (maximumY - minimumY) / 2.0;\n  scale.z = (maximumZ - minimumZ) / 2.0;\n\n  const center = result.center;\n  centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\n  Cartesian3.add(planeOrigin, centerOffset, center);\n  Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\n\n  return result;\n}\n\nconst scratchRectangleCenterCartographic = new Cartographic();\nconst scratchRectangleCenter = new Cartesian3();\nconst scratchPerimeterCartographicNC = new Cartographic();\nconst scratchPerimeterCartographicNW = new Cartographic();\nconst scratchPerimeterCartographicCW = new Cartographic();\nconst scratchPerimeterCartographicSW = new Cartographic();\nconst scratchPerimeterCartographicSC = new Cartographic();\nconst scratchPerimeterCartesianNC = new Cartesian3();\nconst scratchPerimeterCartesianNW = new Cartesian3();\nconst scratchPerimeterCartesianCW = new Cartesian3();\nconst scratchPerimeterCartesianSW = new Cartesian3();\nconst scratchPerimeterCartesianSC = new Cartesian3();\nconst scratchPerimeterProjectedNC = new Cartesian2();\nconst scratchPerimeterProjectedNW = new Cartesian2();\nconst scratchPerimeterProjectedCW = new Cartesian2();\nconst scratchPerimeterProjectedSW = new Cartesian2();\nconst scratchPerimeterProjectedSC = new Cartesian2();\n\nconst scratchPlaneOrigin = new Cartesian3();\nconst scratchPlaneNormal = new Cartesian3();\nconst scratchPlaneXAxis = new Cartesian3();\nconst scratchHorizonCartesian = new Cartesian3();\nconst scratchHorizonProjected = new Cartesian2();\nconst scratchMaxY = new Cartesian3();\nconst scratchMinY = new Cartesian3();\nconst scratchZ = new Cartesian3();\nconst scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n\n/**\n * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\n * There are no guarantees about the orientation of the bounding box.\n *\n * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\n * @param {number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\n * @param {number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the rectangle is defined.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\n *\n * @exception {DeveloperError} rectangle.width must be between 0 and 2 * pi.\n * @exception {DeveloperError} rectangle.height must be between 0 and pi.\n * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\n */\nOrientedBoundingBox.fromRectangle = function (\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  ellipsoid,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  }\n  if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\n    throw new DeveloperError(\"Rectangle width must be between 0 and 2 * pi\");\n  }\n  if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\n    throw new DeveloperError(\"Rectangle height must be between 0 and pi\");\n  }\n  if (\n    defined(ellipsoid) &&\n    !CesiumMath.equalsEpsilon(\n      ellipsoid.radii.x,\n      ellipsoid.radii.y,\n      CesiumMath.EPSILON15,\n    )\n  ) {\n    throw new DeveloperError(\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  minimumHeight = minimumHeight ?? 0.0;\n  maximumHeight = maximumHeight ?? 0.0;\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n\n  let minX, maxX, minY, maxY, minZ, maxZ, plane;\n\n  if (rectangle.width <= CesiumMath.PI) {\n    // The bounding box will be aligned with the tangent plane at the center of the rectangle.\n    const tangentPointCartographic = Rectangle.center(\n      rectangle,\n      scratchRectangleCenterCartographic,\n    );\n    const tangentPoint = ellipsoid.cartographicToCartesian(\n      tangentPointCartographic,\n      scratchRectangleCenter,\n    );\n    const tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\n    plane = tangentPlane.plane;\n\n    // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\n    const lonCenter = tangentPointCartographic.longitude;\n    const latCenter =\n      rectangle.south < 0.0 && rectangle.north > 0.0\n        ? 0.0\n        : tangentPointCartographic.latitude;\n\n    // Compute XY extents using the rectangle at maximum height\n    const perimeterCartographicNC = Cartographic.fromRadians(\n      lonCenter,\n      rectangle.north,\n      maximumHeight,\n      scratchPerimeterCartographicNC,\n    );\n    const perimeterCartographicNW = Cartographic.fromRadians(\n      rectangle.west,\n      rectangle.north,\n      maximumHeight,\n      scratchPerimeterCartographicNW,\n    );\n    const perimeterCartographicCW = Cartographic.fromRadians(\n      rectangle.west,\n      latCenter,\n      maximumHeight,\n      scratchPerimeterCartographicCW,\n    );\n    const perimeterCartographicSW = Cartographic.fromRadians(\n      rectangle.west,\n      rectangle.south,\n      maximumHeight,\n      scratchPerimeterCartographicSW,\n    );\n    const perimeterCartographicSC = Cartographic.fromRadians(\n      lonCenter,\n      rectangle.south,\n      maximumHeight,\n      scratchPerimeterCartographicSC,\n    );\n\n    const perimeterCartesianNC = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNC,\n      scratchPerimeterCartesianNC,\n    );\n    let perimeterCartesianNW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNW,\n      scratchPerimeterCartesianNW,\n    );\n    const perimeterCartesianCW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicCW,\n      scratchPerimeterCartesianCW,\n    );\n    let perimeterCartesianSW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSW,\n      scratchPerimeterCartesianSW,\n    );\n    const perimeterCartesianSC = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSC,\n      scratchPerimeterCartesianSC,\n    );\n\n    const perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianNC,\n      scratchPerimeterProjectedNC,\n    );\n    const perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianNW,\n      scratchPerimeterProjectedNW,\n    );\n    const perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianCW,\n      scratchPerimeterProjectedCW,\n    );\n    const perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianSW,\n      scratchPerimeterProjectedSW,\n    );\n    const perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianSC,\n      scratchPerimeterProjectedSC,\n    );\n\n    minX = Math.min(\n      perimeterProjectedNW.x,\n      perimeterProjectedCW.x,\n      perimeterProjectedSW.x,\n    );\n    maxX = -minX; // symmetrical\n\n    maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\n    minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);\n\n    // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\n    perimeterCartographicNW.height = perimeterCartographicSW.height =\n      minimumHeight;\n    perimeterCartesianNW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNW,\n      scratchPerimeterCartesianNW,\n    );\n    perimeterCartesianSW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSW,\n      scratchPerimeterCartesianSW,\n    );\n\n    minZ = Math.min(\n      Plane.getPointDistance(plane, perimeterCartesianNW),\n      Plane.getPointDistance(plane, perimeterCartesianSW),\n    );\n    maxZ = maximumHeight; // Since the tangent plane touches the surface at height = 0, this is okay\n\n    return fromPlaneExtents(\n      tangentPlane.origin,\n      tangentPlane.xAxis,\n      tangentPlane.yAxis,\n      tangentPlane.zAxis,\n      minX,\n      maxX,\n      minY,\n      maxY,\n      minZ,\n      maxZ,\n      result,\n    );\n  }\n\n  // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\n  const fullyAboveEquator = rectangle.south > 0.0;\n  const fullyBelowEquator = rectangle.north < 0.0;\n  const latitudeNearestToEquator = fullyAboveEquator\n    ? rectangle.south\n    : fullyBelowEquator\n      ? rectangle.north\n      : 0.0;\n  const centerLongitude = Rectangle.center(\n    rectangle,\n    scratchRectangleCenterCartographic,\n  ).longitude;\n\n  // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\n  // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\n  const planeOrigin = Cartesian3.fromRadians(\n    centerLongitude,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchPlaneOrigin,\n  );\n  planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\n  const isPole =\n    Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 &&\n    Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\n  const planeNormal = !isPole\n    ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal)\n    : Cartesian3.UNIT_X;\n  const planeYAxis = Cartesian3.UNIT_Z;\n  const planeXAxis = Cartesian3.cross(\n    planeNormal,\n    planeYAxis,\n    scratchPlaneXAxis,\n  );\n  plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);\n\n  // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\n  const horizonCartesian = Cartesian3.fromRadians(\n    centerLongitude + CesiumMath.PI_OVER_TWO,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchHorizonCartesian,\n  );\n  maxX = Cartesian3.dot(\n    Plane.projectPointOntoPlane(\n      plane,\n      horizonCartesian,\n      scratchHorizonProjected,\n    ),\n    planeXAxis,\n  );\n  minX = -maxX; // symmetrical\n\n  // Get the min and max Y, using the height that will give the largest extent\n  maxY = Cartesian3.fromRadians(\n    0.0,\n    rectangle.north,\n    fullyBelowEquator ? minimumHeight : maximumHeight,\n    ellipsoid,\n    scratchMaxY,\n  ).z;\n  minY = Cartesian3.fromRadians(\n    0.0,\n    rectangle.south,\n    fullyAboveEquator ? minimumHeight : maximumHeight,\n    ellipsoid,\n    scratchMinY,\n  ).z;\n\n  const farZ = Cartesian3.fromRadians(\n    rectangle.east,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchZ,\n  );\n  minZ = Plane.getPointDistance(plane, farZ);\n  maxZ = 0.0; // plane origin starts at maxZ already\n\n  // min and max are local to the plane axes\n  return fromPlaneExtents(\n    planeOrigin,\n    planeXAxis,\n    planeYAxis,\n    planeNormal,\n    minX,\n    maxX,\n    minY,\n    maxY,\n    minZ,\n    maxZ,\n    result,\n  );\n};\n\n/**\n * Computes an OrientedBoundingBox that bounds an affine transformation.\n *\n * @param {Matrix4} transformation The affine transformation.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\n */\nOrientedBoundingBox.fromTransformation = function (transformation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"transformation\", transformation);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  result.center = Matrix4.getTranslation(transformation, result.center);\n  result.halfAxes = Matrix4.getMatrix3(transformation, result.halfAxes);\n  result.halfAxes = Matrix3.multiplyByScalar(\n    result.halfAxes,\n    0.5,\n    result.halfAxes,\n  );\n  return result;\n};\n\n/**\n * Duplicates a OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} box The bounding box to duplicate.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\nOrientedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new OrientedBoundingBox(box.center, box.halfAxes);\n  }\n\n  Cartesian3.clone(box.center, result.center);\n  Matrix3.clone(box.halfAxes, result.halfAxes);\n\n  return result;\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {OrientedBoundingBox} box The oriented bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const center = box.center;\n  const normal = plane.normal;\n  const halfAxes = box.halfAxes;\n  const normalX = normal.x,\n    normalY = normal.y,\n    normalZ = normal.z;\n  // plane is used as if it is its normal; the first three components are assumed to be normalized\n  const radEffective =\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN0ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN0ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN0ROW2],\n    ) +\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN1ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN1ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN1ROW2],\n    ) +\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN2ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN2ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN2ROW2],\n    );\n  const distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n\n  if (distanceToPlane <= -radEffective) {\n    // The entire box is on the negative side of the plane normal\n    return Intersect.OUTSIDE;\n  } else if (distanceToPlane >= radEffective) {\n    // The entire box is on the positive side of the plane normal\n    return Intersect.INSIDE;\n  }\n  return Intersect.INTERSECTING;\n};\n\nconst scratchCartesianU = new Cartesian3();\nconst scratchCartesianV = new Cartesian3();\nconst scratchCartesianW = new Cartesian3();\nconst scratchValidAxis2 = new Cartesian3();\nconst scratchValidAxis3 = new Cartesian3();\nconst scratchPPrime = new Cartesian3();\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {OrientedBoundingBox} box The box.\n * @param {Cartesian3} cartesian The point\n * @returns {number} The distance squared from the oriented bounding box to the point. Returns 0 if the point is inside the box.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\n * });\n */\nOrientedBoundingBox.distanceSquaredTo = function (box, cartesian) {\n  // See Geometric Tools for Computer Graphics 10.4.2\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\n\n  const halfAxes = box.halfAxes;\n  let u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  let v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  let w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  const uHalf = Cartesian3.magnitude(u);\n  const vHalf = Cartesian3.magnitude(v);\n  const wHalf = Cartesian3.magnitude(w);\n\n  let uValid = true;\n  let vValid = true;\n  let wValid = true;\n\n  if (uHalf > 0) {\n    Cartesian3.divideByScalar(u, uHalf, u);\n  } else {\n    uValid = false;\n  }\n\n  if (vHalf > 0) {\n    Cartesian3.divideByScalar(v, vHalf, v);\n  } else {\n    vValid = false;\n  }\n\n  if (wHalf > 0) {\n    Cartesian3.divideByScalar(w, wHalf, w);\n  } else {\n    wValid = false;\n  }\n\n  const numberOfDegenerateAxes = !uValid + !vValid + !wValid;\n  let validAxis1;\n  let validAxis2;\n  let validAxis3;\n\n  if (numberOfDegenerateAxes === 1) {\n    let degenerateAxis = u;\n    validAxis1 = v;\n    validAxis2 = w;\n    if (!vValid) {\n      degenerateAxis = v;\n      validAxis1 = u;\n    } else if (!wValid) {\n      degenerateAxis = w;\n      validAxis2 = u;\n    }\n\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\n\n    if (degenerateAxis === u) {\n      u = validAxis3;\n    } else if (degenerateAxis === v) {\n      v = validAxis3;\n    } else if (degenerateAxis === w) {\n      w = validAxis3;\n    }\n  } else if (numberOfDegenerateAxes === 2) {\n    validAxis1 = u;\n    if (vValid) {\n      validAxis1 = v;\n    } else if (wValid) {\n      validAxis1 = w;\n    }\n\n    let crossVector = Cartesian3.UNIT_Y;\n    if (crossVector.equalsEpsilon(validAxis1, CesiumMath.EPSILON3)) {\n      crossVector = Cartesian3.UNIT_X;\n    }\n\n    validAxis2 = Cartesian3.cross(validAxis1, crossVector, scratchValidAxis2);\n    Cartesian3.normalize(validAxis2, validAxis2);\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\n    Cartesian3.normalize(validAxis3, validAxis3);\n\n    if (validAxis1 === u) {\n      v = validAxis2;\n      w = validAxis3;\n    } else if (validAxis1 === v) {\n      w = validAxis2;\n      u = validAxis3;\n    } else if (validAxis1 === w) {\n      u = validAxis2;\n      v = validAxis3;\n    }\n  } else if (numberOfDegenerateAxes === 3) {\n    u = Cartesian3.UNIT_X;\n    v = Cartesian3.UNIT_Y;\n    w = Cartesian3.UNIT_Z;\n  }\n\n  const pPrime = scratchPPrime;\n  pPrime.x = Cartesian3.dot(offset, u);\n  pPrime.y = Cartesian3.dot(offset, v);\n  pPrime.z = Cartesian3.dot(offset, w);\n\n  let distanceSquared = 0.0;\n  let d;\n\n  if (pPrime.x < -uHalf) {\n    d = pPrime.x + uHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.x > uHalf) {\n    d = pPrime.x - uHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.y < -vHalf) {\n    d = pPrime.y + vHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.y > vHalf) {\n    d = pPrime.y - vHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.z < -wHalf) {\n    d = pPrime.z + wHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.z > wHalf) {\n    d = pPrime.z - wHalf;\n    distanceSquared += d * d;\n  }\n\n  return distanceSquared;\n};\n\nconst scratchCorner = new Cartesian3();\nconst scratchToCenter = new Cartesian3();\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.computePlaneDistances = function (\n  box,\n  position,\n  direction,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  let minDist = Number.POSITIVE_INFINITY;\n  let maxDist = Number.NEGATIVE_INFINITY;\n\n  const center = box.center;\n  const halfAxes = box.halfAxes;\n\n  const u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  const v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  const w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  // project first corner\n  const corner = Cartesian3.add(u, v, scratchCorner);\n  Cartesian3.add(corner, w, corner);\n  Cartesian3.add(corner, center, corner);\n\n  const toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\n  let mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project second corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project third corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fourth corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fifth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project sixth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project seventh corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project eighth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  result.start = minDist;\n  result.stop = maxDist;\n  return result;\n};\n\nconst scratchXAxis = new Cartesian3();\nconst scratchYAxis = new Cartesian3();\nconst scratchZAxis = new Cartesian3();\n\n/**\n * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).\n *\n * @param {OrientedBoundingBox} box The oriented bounding box.\n * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.\n * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.\n */\nOrientedBoundingBox.computeCorners = function (box, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"box\", box);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n    ];\n  }\n\n  const center = box.center;\n  const halfAxes = box.halfAxes;\n  const xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n  const yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n  const zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n\n  Cartesian3.clone(center, result[0]);\n  Cartesian3.subtract(result[0], xAxis, result[0]);\n  Cartesian3.subtract(result[0], yAxis, result[0]);\n  Cartesian3.subtract(result[0], zAxis, result[0]);\n\n  Cartesian3.clone(center, result[1]);\n  Cartesian3.subtract(result[1], xAxis, result[1]);\n  Cartesian3.subtract(result[1], yAxis, result[1]);\n  Cartesian3.add(result[1], zAxis, result[1]);\n\n  Cartesian3.clone(center, result[2]);\n  Cartesian3.subtract(result[2], xAxis, result[2]);\n  Cartesian3.add(result[2], yAxis, result[2]);\n  Cartesian3.subtract(result[2], zAxis, result[2]);\n\n  Cartesian3.clone(center, result[3]);\n  Cartesian3.subtract(result[3], xAxis, result[3]);\n  Cartesian3.add(result[3], yAxis, result[3]);\n  Cartesian3.add(result[3], zAxis, result[3]);\n\n  Cartesian3.clone(center, result[4]);\n  Cartesian3.add(result[4], xAxis, result[4]);\n  Cartesian3.subtract(result[4], yAxis, result[4]);\n  Cartesian3.subtract(result[4], zAxis, result[4]);\n\n  Cartesian3.clone(center, result[5]);\n  Cartesian3.add(result[5], xAxis, result[5]);\n  Cartesian3.subtract(result[5], yAxis, result[5]);\n  Cartesian3.add(result[5], zAxis, result[5]);\n\n  Cartesian3.clone(center, result[6]);\n  Cartesian3.add(result[6], xAxis, result[6]);\n  Cartesian3.add(result[6], yAxis, result[6]);\n  Cartesian3.subtract(result[6], zAxis, result[6]);\n\n  Cartesian3.clone(center, result[7]);\n  Cartesian3.add(result[7], xAxis, result[7]);\n  Cartesian3.add(result[7], yAxis, result[7]);\n  Cartesian3.add(result[7], zAxis, result[7]);\n\n  return result;\n};\n\nconst scratchRotationScale = new Matrix3();\n\n/**\n * Computes a transformation matrix from an oriented bounding box.\n *\n * @param {OrientedBoundingBox} box The oriented bounding box.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new {@link Matrix4} instance if none was provided.\n */\nOrientedBoundingBox.computeTransformation = function (box, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"box\", box);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n\n  const translation = box.center;\n  const rotationScale = Matrix3.multiplyByUniformScale(\n    box.halfAxes,\n    2.0,\n    scratchRotationScale,\n  );\n  return Matrix4.fromRotationTranslation(rotationScale, translation, result);\n};\n\nconst scratchBoundingSphere = new BoundingSphere();\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\n * @param {Occluder} occluder The occluder.\n * @returns {boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.isOccluded = function (box, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(occluder)) {\n    throw new DeveloperError(\"occluder is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const sphere = BoundingSphere.fromOrientedBoundingBox(\n    box,\n    scratchBoundingSphere,\n  );\n\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.prototype.intersectPlane = function (plane) {\n  return OrientedBoundingBox.intersectPlane(this, plane);\n};\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\nOrientedBoundingBox.prototype.distanceSquaredTo = function (cartesian) {\n  return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\n};\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.prototype.computePlaneDistances = function (\n  position,\n  direction,\n  result,\n) {\n  return OrientedBoundingBox.computePlaneDistances(\n    this,\n    position,\n    direction,\n    result,\n  );\n};\n\n/**\n * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).\n *\n * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.\n * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.\n */\nOrientedBoundingBox.prototype.computeCorners = function (result) {\n  return OrientedBoundingBox.computeCorners(this, result);\n};\n\n/**\n * Computes a transformation matrix from an oriented bounding box.\n *\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new {@link Matrix4} instance if none was provided.\n */\nOrientedBoundingBox.prototype.computeTransformation = function (result) {\n  return OrientedBoundingBox.computeTransformation(this, result);\n};\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.prototype.isOccluded = function (occluder) {\n  return OrientedBoundingBox.isOccluded(this, occluder);\n};\n\n/**\n * Compares the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} [left] The first OrientedBoundingBox.\n * @param {OrientedBoundingBox} [right] The second OrientedBoundingBox.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      Matrix3.equals(left.halfAxes, right.halfAxes))\n  );\n};\n\n/**\n * Duplicates this OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.prototype.clone = function (result) {\n  return OrientedBoundingBox.clone(this, result);\n};\n\n/**\n * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.prototype.equals = function (right) {\n  return OrientedBoundingBox.equals(this, right);\n};\nexport default OrientedBoundingBox;\n"],"names":["OrientedBoundingBox","center","halfAxes","clone","ZERO","packedLength","pack","value","array","startingIndex","typeOf","object","defined","unpack","result","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCovarianceResult","scratchEigenResult","unitary","diagonal","fromPoints","positions","length","i","meanPoint","add","invLength","multiplyByScalar","exx","exy","exz","eyy","eyz","ezz","p","subtract","x","y","z","covarianceMatrix","eigenDecomposition","computeEigenDecomposition","rotation","v1","getColumn","v2","v3","u1","Number","MAX_VALUE","u2","u3","l1","l2","l3","Math","max","dot","min","scale","multiplyByScale","scratchOffset","scratchScale","fromPlaneExtents","planeOrigin","planeXAxis","planeYAxis","planeZAxis","minimumX","maximumX","minimumY","maximumY","minimumZ","maximumZ","setColumn","centerOffset","multiplyByVector","scratchRectangleCenterCartographic","scratchRectangleCenter","scratchPerimeterCartographicNC","scratchPerimeterCartographicNW","scratchPerimeterCartographicCW","scratchPerimeterCartographicSW","scratchPerimeterCartographicSC","scratchPerimeterCartesianNC","scratchPerimeterCartesianNW","scratchPerimeterCartesianCW","scratchPerimeterCartesianSW","scratchPerimeterCartesianSC","scratchPerimeterProjectedNC","scratchPerimeterProjectedNW","scratchPerimeterProjectedCW","scratchPerimeterProjectedSW","scratchPerimeterProjectedSC","scratchPlaneOrigin","scratchPlaneNormal","scratchPlaneXAxis","scratchHorizonCartesian","scratchHorizonProjected","scratchMaxY","scratchMinY","scratchZ","scratchPlane","UNIT_X","fromRectangle","rectangle","minimumHeight","maximumHeight","ellipsoid","width","TWO_PI","height","PI","equalsEpsilon","radii","EPSILON15","default","minX","maxX","minY","maxY","minZ","maxZ","plane","tangentPointCartographic","tangentPoint","cartographicToCartesian","tangentPlane","lonCenter","longitude","latCenter","south","north","latitude","perimeterCartographicNC","fromRadians","perimeterCartographicNW","west","perimeterCartographicCW","perimeterCartographicSW","perimeterCartographicSC","perimeterCartesianNC","perimeterCartesianNW","perimeterCartesianCW","perimeterCartesianSW","perimeterCartesianSC","perimeterProjectedNC","projectPointToNearestOnPlane","perimeterProjectedNW","perimeterProjectedCW","perimeterProjectedSW","perimeterProjectedSC","getPointDistance","origin","xAxis","yAxis","zAxis","fullyAboveEquator","fullyBelowEquator","latitudeNearestToEquator","centerLongitude","isPole","abs","EPSILON10","planeNormal","normalize","UNIT_Z","cross","fromPointNormal","horizonCartesian","PI_OVER_TWO","projectPointOntoPlane","farZ","east","fromTransformation","transformation","getTranslation","getMatrix3","box","undefined","intersectPlane","normal","normalX","normalY","normalZ","radEffective","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","distanceToPlane","distance","OUTSIDE","INSIDE","INTERSECTING","scratchCartesianU","scratchCartesianV","scratchCartesianW","scratchValidAxis2","scratchValidAxis3","scratchPPrime","distanceSquaredTo","cartesian","offset","u","v","w","uHalf","magnitude","vHalf","wHalf","uValid","vValid","wValid","divideByScalar","numberOfDegenerateAxes","validAxis1","validAxis2","validAxis3","degenerateAxis","crossVector","UNIT_Y","EPSILON3","pPrime","distanceSquared","d","scratchCorner","scratchToCenter","computePlaneDistances","position","direction","minDist","POSITIVE_INFINITY","maxDist","NEGATIVE_INFINITY","corner","toCenter","mag","start","stop","scratchXAxis","scratchYAxis","scratchZAxis","computeCorners","scratchRotationScale","computeTransformation","translation","rotationScale","multiplyByUniformScale","fromRotationTranslation","scratchBoundingSphere","isOccluded","occluder","sphere","fromOrientedBoundingBox","isBoundingSphereVisible","prototype","equals","left","right"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 31619, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/VerticalExaggeration.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport defined from \"./defined.js\";\n\n/**\n * @private\n */\nconst VerticalExaggeration = {};\n\n/**\n * Scales a height relative to an offset.\n *\n * @param {number} height The height.\n * @param {number} scale A scalar used to exaggerate the terrain. If the value is 1.0 there will be no effect.\n * @param {number} relativeHeight The height relative to which terrain is exaggerated. If the value is 0.0 terrain will be exaggerated relative to the ellipsoid surface.\n */\nVerticalExaggeration.getHeight = function (height, scale, relativeHeight) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!Number.isFinite(scale)) {\n    throw new DeveloperError(\"scale must be a finite number.\");\n  }\n  if (!Number.isFinite(relativeHeight)) {\n    throw new DeveloperError(\"relativeHeight must be a finite number.\");\n  }\n  //>>includeEnd('debug');\n  return (height - relativeHeight) * scale + relativeHeight;\n};\n\nconst scratchCartographic = new Cartographic();\n\n/**\n * Scales a position by exaggeration.\n *\n * @param {Cartesian3} position The position.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @param {number} verticalExaggeration A scalar used to exaggerate the terrain. If the value is 1.0 there will be no effect.\n * @param {number} verticalExaggerationRelativeHeight The height relative to which terrain is exaggerated. If the value is 0.0 terrain will be exaggerated relative to the ellipsoid surface.\n * @param {Cartesian3} [result] The object onto which to store the result.\n */\nVerticalExaggeration.getPosition = function (\n  position,\n  ellipsoid,\n  verticalExaggeration,\n  verticalExaggerationRelativeHeight,\n  result,\n) {\n  const cartographic = ellipsoid.cartesianToCartographic(\n    position,\n    scratchCartographic,\n  );\n  // If the position is too near the center of the ellipsoid, exaggeration is undefined.\n  if (!defined(cartographic)) {\n    return Cartesian3.clone(position, result);\n  }\n  const newHeight = VerticalExaggeration.getHeight(\n    cartographic.height,\n    verticalExaggeration,\n    verticalExaggerationRelativeHeight,\n  );\n  return Cartesian3.fromRadians(\n    cartographic.longitude,\n    cartographic.latitude,\n    newHeight,\n    ellipsoid,\n    result,\n  );\n};\n\nexport default VerticalExaggeration;\n"],"names":["VerticalExaggeration","getHeight","height","scale","relativeHeight","Number","isFinite","scratchCartographic","getPosition","position","ellipsoid","verticalExaggeration","verticalExaggerationRelativeHeight","result","cartographic","cartesianToCartographic","clone","newHeight","fromRadians","longitude","latitude"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;CAEC,GACD,MAAMA,uBAAuB,CAAC;AAE9B;;;;;;CAMC,GACDA,qBAAqBC,SAAS,GAAG,SAAUC,MAAM,EAAEC,KAAK,EAAEC,cAAc;IACtE,yCAAyC;IACzC,IAAI,CAACC,OAAOC,QAAQ,CAACH,QAAQ;QAC3B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAACE,OAAOC,QAAQ,CAACF,iBAAiB;QACpC,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IACxB,OAAO,CAACF,SAASE,cAAc,IAAID,QAAQC;AAC7C;AAEA,MAAMG,sBAAsB,IAAI,kLAAY;AAE5C;;;;;;;;CAQC,GACDP,qBAAqBQ,WAAW,GAAG,SACjCC,QAAQ,EACRC,SAAS,EACTC,oBAAoB,EACpBC,kCAAkC,EAClCC,MAAM;IAEN,MAAMC,eAAeJ,UAAUK,uBAAuB,CACpDN,UACAF;IAEF,sFAAsF;IACtF,IAAI,CAAC,IAAA,6KAAO,EAACO,eAAe;QAC1B,OAAO,gLAAU,CAACE,KAAK,CAACP,UAAUI;IACpC;IACA,MAAMI,YAAYjB,qBAAqBC,SAAS,CAC9Ca,aAAaZ,MAAM,EACnBS,sBACAC;IAEF,OAAO,gLAAU,CAACM,WAAW,CAC3BJ,aAAaK,SAAS,EACtBL,aAAaM,QAAQ,EACrBH,WACAP,WACAG;AAEJ;uCAEeb","ignoreList":[0]}},
    {"offset": {"line": 31674, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/ColorGeometryInstanceAttribute.js"],"sourcesContent":["import Color from \"./Color.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Value and type information for per-instance geometry color.\n *\n * @alias ColorGeometryInstanceAttribute\n * @constructor\n *\n * @param {number} [red=1.0] The red component.\n * @param {number} [green=1.0] The green component.\n * @param {number} [blue=1.0] The blue component.\n * @param {number} [alpha=1.0] The alpha component.\n *\n *\n * @example\n * const instance = new Cesium.GeometryInstance({\n *   geometry : Cesium.BoxGeometry.fromDimensions({\n *     dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(0.0, 0.0)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   id : 'box',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(red, green, blue, alpha)\n *   }\n * });\n *\n * @see GeometryInstance\n * @see GeometryInstanceAttribute\n */\nfunction ColorGeometryInstanceAttribute(red, green, blue, alpha) {\n  red = red ?? 1.0;\n  green = green ?? 1.0;\n  blue = blue ?? 1.0;\n  alpha = alpha ?? 1.0;\n\n  /**\n   * The values for the attributes stored in a typed array.\n   *\n   * @type Uint8Array\n   *\n   * @default [255, 255, 255, 255]\n   */\n  this.value = new Uint8Array([\n    Color.floatToByte(red),\n    Color.floatToByte(green),\n    Color.floatToByte(blue),\n    Color.floatToByte(alpha),\n  ]);\n}\n\nObject.defineProperties(ColorGeometryInstanceAttribute.prototype, {\n  /**\n   * The datatype of each component in the attribute, e.g., individual elements in\n   * {@link ColorGeometryInstanceAttribute#value}.\n   *\n   * @memberof ColorGeometryInstanceAttribute.prototype\n   *\n   * @type {ComponentDatatype}\n   * @readonly\n   *\n   * @default {@link ComponentDatatype.UNSIGNED_BYTE}\n   */\n  componentDatatype: {\n    get: function () {\n      return ComponentDatatype.UNSIGNED_BYTE;\n    },\n  },\n\n  /**\n   * The number of components in the attributes, i.e., {@link ColorGeometryInstanceAttribute#value}.\n   *\n   * @memberof ColorGeometryInstanceAttribute.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @default 4\n   */\n  componentsPerAttribute: {\n    get: function () {\n      return 4;\n    },\n  },\n\n  /**\n   * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n   * indicate that the components should be mapped to the range [0, 1] (unsigned)\n   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n   *\n   * @memberof ColorGeometryInstanceAttribute.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  normalize: {\n    get: function () {\n      return true;\n    },\n  },\n});\n\n/**\n * Creates a new {@link ColorGeometryInstanceAttribute} instance given the provided {@link Color}.\n *\n * @param {Color} color The color.\n * @returns {ColorGeometryInstanceAttribute} The new {@link ColorGeometryInstanceAttribute} instance.\n *\n * @example\n * const instance = new Cesium.GeometryInstance({\n *   geometry : geometry,\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.CORNFLOWERBLUE),\n *   }\n * });\n */\nColorGeometryInstanceAttribute.fromColor = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(color)) {\n    throw new DeveloperError(\"color is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return new ColorGeometryInstanceAttribute(\n    color.red,\n    color.green,\n    color.blue,\n    color.alpha,\n  );\n};\n\n/**\n * Converts a color to a typed array that can be used to assign a color attribute.\n *\n * @param {Color} color The color.\n * @param {Uint8Array} [result] The array to store the result in, if undefined a new instance will be created.\n *\n * @returns {Uint8Array} The modified result parameter or a new instance if result was undefined.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA, attributes.color);\n */\nColorGeometryInstanceAttribute.toValue = function (color, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(color)) {\n    throw new DeveloperError(\"color is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Uint8Array(color.toBytes());\n  }\n  return color.toBytes(result);\n};\n\n/**\n * Compares the provided ColorGeometryInstanceAttributes and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {ColorGeometryInstanceAttribute} [left] The first ColorGeometryInstanceAttribute.\n * @param {ColorGeometryInstanceAttribute} [right] The second ColorGeometryInstanceAttribute.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nColorGeometryInstanceAttribute.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.value[0] === right.value[0] &&\n      left.value[1] === right.value[1] &&\n      left.value[2] === right.value[2] &&\n      left.value[3] === right.value[3])\n  );\n};\nexport default ColorGeometryInstanceAttribute;\n"],"names":["ColorGeometryInstanceAttribute","red","green","blue","alpha","value","Uint8Array","floatToByte","Object","defineProperties","prototype","componentDatatype","get","UNSIGNED_BYTE","componentsPerAttribute","normalize","fromColor","color","toValue","result","toBytes","equals","left","right"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2BC,GACD,SAASA,+BAA+BC,GAAG,EAAEC,KAAK,EAAEC,IAAI,EAAEC,KAAK;IAC7DH,MAAMA,OAAO;IACbC,QAAQA,SAAS;IACjBC,OAAOA,QAAQ;IACfC,QAAQA,SAAS;IAEjB;;;;;;GAMC,GACD,IAAI,CAACC,KAAK,GAAG,IAAIC,WAAW;QAC1B,2KAAK,CAACC,WAAW,CAACN;QAClB,2KAAK,CAACM,WAAW,CAACL;QAClB,2KAAK,CAACK,WAAW,CAACJ;QAClB,2KAAK,CAACI,WAAW,CAACH;KACnB;AACH;AAEAI,OAAOC,gBAAgB,CAACT,+BAA+BU,SAAS,EAAE;IAChE;;;;;;;;;;GAUC,GACDC,mBAAmB;QACjBC,KAAK;YACH,OAAO,uLAAiB,CAACC,aAAa;QACxC;IACF;IAEA;;;;;;;;;GASC,GACDC,wBAAwB;QACtBF,KAAK;YACH,OAAO;QACT;IACF;IAEA;;;;;;;;;;;GAWC,GACDG,WAAW;QACTH,KAAK;YACH,OAAO;QACT;IACF;AACF;AAEA;;;;;;;;;;;;;CAaC,GACDZ,+BAA+BgB,SAAS,GAAG,SAAUC,KAAK;IACxD,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACA,QAAQ;QACnB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,OAAO,IAAIjB,+BACTiB,MAAMhB,GAAG,EACTgB,MAAMf,KAAK,EACXe,MAAMd,IAAI,EACVc,MAAMb,KAAK;AAEf;AAEA;;;;;;;;;;;CAWC,GACDJ,+BAA+BkB,OAAO,GAAG,SAAUD,KAAK,EAAEE,MAAM;IAC9D,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACF,QAAQ;QACnB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,IAAI,CAAC,IAAA,6KAAO,EAACE,SAAS;QACpB,OAAO,IAAIb,WAAWW,MAAMG,OAAO;IACrC;IACA,OAAOH,MAAMG,OAAO,CAACD;AACvB;AAEA;;;;;;;CAOC,GACDnB,+BAA+BqB,MAAM,GAAG,SAAUC,IAAI,EAAEC,KAAK;IAC3D,OACED,SAASC,SACR,IAAA,6KAAO,EAACD,SACP,IAAA,6KAAO,EAACC,UACRD,KAAKjB,KAAK,CAAC,EAAE,KAAKkB,MAAMlB,KAAK,CAAC,EAAE,IAChCiB,KAAKjB,KAAK,CAAC,EAAE,KAAKkB,MAAMlB,KAAK,CAAC,EAAE,IAChCiB,KAAKjB,KAAK,CAAC,EAAE,KAAKkB,MAAMlB,KAAK,CAAC,EAAE,IAChCiB,KAAKjB,KAAK,CAAC,EAAE,KAAKkB,MAAMlB,KAAK,CAAC,EAAE;AAEtC;uCACeL","ignoreList":[0]}},
    {"offset": {"line": 31836, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/AssociativeArray.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * A collection of key-value pairs that is stored as a hash for easy\n * lookup but also provides an array for fast iteration.\n * @alias AssociativeArray\n * @constructor\n */\nfunction AssociativeArray() {\n  this._array = [];\n  this._hash = {};\n}\n\nObject.defineProperties(AssociativeArray.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof AssociativeArray.prototype\n   *\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      return this._array.length;\n    },\n  },\n  /**\n   * Gets an unordered array of all values in the collection.\n   * This is a live array that will automatically reflect the values in the collection,\n   * it should not be modified directly.\n   * @memberof AssociativeArray.prototype\n   *\n   * @type {Array}\n   */\n  values: {\n    get: function () {\n      return this._array;\n    },\n  },\n});\n\n/**\n * Determines if the provided key is in the array.\n *\n * @param {string|number} key The key to check.\n * @returns {boolean} <code>true</code> if the key is in the array, <code>false</code> otherwise.\n */\nAssociativeArray.prototype.contains = function (key) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof key !== \"string\" && typeof key !== \"number\") {\n    throw new DeveloperError(\"key is required to be a string or number.\");\n  }\n  //>>includeEnd('debug');\n  return defined(this._hash[key]);\n};\n\n/**\n * Associates the provided key with the provided value.  If the key already\n * exists, it is overwritten with the new value.\n *\n * @param {string|number} key A unique identifier.\n * @param {*} value The value to associate with the provided key.\n */\nAssociativeArray.prototype.set = function (key, value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof key !== \"string\" && typeof key !== \"number\") {\n    throw new DeveloperError(\"key is required to be a string or number.\");\n  }\n  //>>includeEnd('debug');\n\n  const oldValue = this._hash[key];\n  if (value !== oldValue) {\n    this.remove(key);\n    this._hash[key] = value;\n    this._array.push(value);\n  }\n};\n\n/**\n * Retrieves the value associated with the provided key.\n *\n * @param {string|number} key The key whose value is to be retrieved.\n * @returns {*} The associated value, or undefined if the key does not exist in the collection.\n */\nAssociativeArray.prototype.get = function (key) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof key !== \"string\" && typeof key !== \"number\") {\n    throw new DeveloperError(\"key is required to be a string or number.\");\n  }\n  //>>includeEnd('debug');\n  return this._hash[key];\n};\n\n/**\n * Removes a key-value pair from the collection.\n *\n * @param {string|number} key The key to be removed.\n * @returns {boolean} True if it was removed, false if the key was not in the collection.\n */\nAssociativeArray.prototype.remove = function (key) {\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(key) && typeof key !== \"string\" && typeof key !== \"number\") {\n    throw new DeveloperError(\"key is required to be a string or number.\");\n  }\n  //>>includeEnd('debug');\n\n  const value = this._hash[key];\n  const hasValue = defined(value);\n  if (hasValue) {\n    const array = this._array;\n    array.splice(array.indexOf(value), 1);\n    delete this._hash[key];\n  }\n  return hasValue;\n};\n\n/**\n * Clears the collection.\n */\nAssociativeArray.prototype.removeAll = function () {\n  const array = this._array;\n  if (array.length > 0) {\n    this._hash = {};\n    array.length = 0;\n  }\n};\nexport default AssociativeArray;\n"],"names":["AssociativeArray","_array","_hash","Object","defineProperties","prototype","length","get","values","contains","key","set","value","oldValue","remove","push","hasValue","array","splice","indexOf","removeAll"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;CAKC,GACD,SAASA;IACP,IAAI,CAACC,MAAM,GAAG,EAAE;IAChB,IAAI,CAACC,KAAK,GAAG,CAAC;AAChB;AAEAC,OAAOC,gBAAgB,CAACJ,iBAAiBK,SAAS,EAAE;IAClD;;;;;GAKC,GACDC,QAAQ;QACNC,KAAK;YACH,OAAO,IAAI,CAACN,MAAM,CAACK,MAAM;QAC3B;IACF;IACA;;;;;;;GAOC,GACDE,QAAQ;QACND,KAAK;YACH,OAAO,IAAI,CAACN,MAAM;QACpB;IACF;AACF;AAEA;;;;;CAKC,GACDD,iBAAiBK,SAAS,CAACI,QAAQ,GAAG,SAAUC,GAAG;IACjD,yCAAyC;IACzC,IAAI,OAAOA,QAAQ,YAAY,OAAOA,QAAQ,UAAU;QACtD,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IACxB,OAAO,IAAA,6KAAO,EAAC,IAAI,CAACR,KAAK,CAACQ,IAAI;AAChC;AAEA;;;;;;CAMC,GACDV,iBAAiBK,SAAS,CAACM,GAAG,GAAG,SAAUD,GAAG,EAAEE,KAAK;IACnD,yCAAyC;IACzC,IAAI,OAAOF,QAAQ,YAAY,OAAOA,QAAQ,UAAU;QACtD,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAMG,WAAW,IAAI,CAACX,KAAK,CAACQ,IAAI;IAChC,IAAIE,UAAUC,UAAU;QACtB,IAAI,CAACC,MAAM,CAACJ;QACZ,IAAI,CAACR,KAAK,CAACQ,IAAI,GAAGE;QAClB,IAAI,CAACX,MAAM,CAACc,IAAI,CAACH;IACnB;AACF;AAEA;;;;;CAKC,GACDZ,iBAAiBK,SAAS,CAACE,GAAG,GAAG,SAAUG,GAAG;IAC5C,yCAAyC;IACzC,IAAI,OAAOA,QAAQ,YAAY,OAAOA,QAAQ,UAAU;QACtD,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IACxB,OAAO,IAAI,CAACR,KAAK,CAACQ,IAAI;AACxB;AAEA;;;;;CAKC,GACDV,iBAAiBK,SAAS,CAACS,MAAM,GAAG,SAAUJ,GAAG;IAC/C,yCAAyC;IACzC,IAAI,IAAA,6KAAO,EAACA,QAAQ,OAAOA,QAAQ,YAAY,OAAOA,QAAQ,UAAU;QACtE,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAME,QAAQ,IAAI,CAACV,KAAK,CAACQ,IAAI;IAC7B,MAAMM,WAAW,IAAA,6KAAO,EAACJ;IACzB,IAAII,UAAU;QACZ,MAAMC,QAAQ,IAAI,CAAChB,MAAM;QACzBgB,MAAMC,MAAM,CAACD,MAAME,OAAO,CAACP,QAAQ;QACnC,OAAO,IAAI,CAACV,KAAK,CAACQ,IAAI;IACxB;IACA,OAAOM;AACT;AAEA;;CAEC,GACDhB,iBAAiBK,SAAS,CAACe,SAAS,GAAG;IACrC,MAAMH,QAAQ,IAAI,CAAChB,MAAM;IACzB,IAAIgB,MAAMX,MAAM,GAAG,GAAG;QACpB,IAAI,CAACJ,KAAK,GAAG,CAAC;QACde,MAAMX,MAAM,GAAG;IACjB;AACF;uCACeN","ignoreList":[0]}},
    {"offset": {"line": 31956, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/DistanceDisplayCondition.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Determines visibility based on the distance to the camera.\n *\n * @alias DistanceDisplayCondition\n * @constructor\n *\n * @param {number} [near=0.0] The smallest distance in the interval where the object is visible.\n * @param {number} [far=Number.MAX_VALUE] The largest distance in the interval where the object is visible.\n *\n * @example\n * // Make a billboard that is only visible when the distance to the camera is between 10 and 20 meters.\n * billboard.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(10.0, 20.0);\n */\nfunction DistanceDisplayCondition(near, far) {\n  near = near ?? 0.0;\n  this._near = near;\n\n  far = far ?? Number.MAX_VALUE;\n  this._far = far;\n}\n\nObject.defineProperties(DistanceDisplayCondition.prototype, {\n  /**\n   * The smallest distance in the interval where the object is visible.\n   * @memberof DistanceDisplayCondition.prototype\n   * @type {number}\n   * @default 0.0\n   */\n  near: {\n    get: function () {\n      return this._near;\n    },\n    set: function (value) {\n      this._near = value;\n    },\n  },\n  /**\n   * The largest distance in the interval where the object is visible.\n   * @memberof DistanceDisplayCondition.prototype\n   * @type {number}\n   * @default Number.MAX_VALUE\n   */\n  far: {\n    get: function () {\n      return this._far;\n    },\n    set: function (value) {\n      this._far = value;\n    },\n  },\n});\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nDistanceDisplayCondition.packedLength = 2;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {DistanceDisplayCondition} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nDistanceDisplayCondition.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value.near;\n  array[startingIndex] = value.far;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {DistanceDisplayCondition} [result] The object into which to store the result.\n * @returns {DistanceDisplayCondition} The modified result parameter or a new DistanceDisplayCondition instance if one was not provided.\n */\nDistanceDisplayCondition.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new DistanceDisplayCondition();\n  }\n  result.near = array[startingIndex++];\n  result.far = array[startingIndex];\n  return result;\n};\n\n/**\n * Determines if two distance display conditions are equal.\n *\n * @param {DistanceDisplayCondition} [left] A distance display condition.\n * @param {DistanceDisplayCondition} [right] Another distance display condition.\n * @return {boolean} Whether the two distance display conditions are equal.\n */\nDistanceDisplayCondition.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.near === right.near &&\n      left.far === right.far)\n  );\n};\n\n/**\n * Duplicates a distance display condition instance.\n *\n * @param {DistanceDisplayCondition} [value] The distance display condition to duplicate.\n * @param {DistanceDisplayCondition} [result] The result onto which to store the result.\n * @return {DistanceDisplayCondition} The duplicated instance.\n */\nDistanceDisplayCondition.clone = function (value, result) {\n  if (!defined(value)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new DistanceDisplayCondition();\n  }\n\n  result.near = value.near;\n  result.far = value.far;\n  return result;\n};\n\n/**\n * Duplicates this instance.\n *\n * @param {DistanceDisplayCondition} [result] The result onto which to store the result.\n * @return {DistanceDisplayCondition} The duplicated instance.\n */\nDistanceDisplayCondition.prototype.clone = function (result) {\n  return DistanceDisplayCondition.clone(this, result);\n};\n\n/**\n * Determines if this distance display condition is equal to another.\n *\n * @param {DistanceDisplayCondition} [other] Another distance display condition.\n * @return {boolean} Whether this distance display condition is equal to the other.\n */\nDistanceDisplayCondition.prototype.equals = function (other) {\n  return DistanceDisplayCondition.equals(this, other);\n};\nexport default DistanceDisplayCondition;\n"],"names":["DistanceDisplayCondition","near","far","_near","Number","MAX_VALUE","_far","Object","defineProperties","prototype","get","set","value","packedLength","pack","array","startingIndex","unpack","result","equals","left","right","clone","undefined","other"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;;;;;;CAYC,GACD,SAASA,yBAAyBC,IAAI,EAAEC,GAAG;IACzCD,OAAOA,QAAQ;IACf,IAAI,CAACE,KAAK,GAAGF;IAEbC,MAAMA,OAAOE,OAAOC,SAAS;IAC7B,IAAI,CAACC,IAAI,GAAGJ;AACd;AAEAK,OAAOC,gBAAgB,CAACR,yBAAyBS,SAAS,EAAE;IAC1D;;;;;GAKC,GACDR,MAAM;QACJS,KAAK;YACH,OAAO,IAAI,CAACP,KAAK;QACnB;QACAQ,KAAK,SAAUC,KAAK;YAClB,IAAI,CAACT,KAAK,GAAGS;QACf;IACF;IACA;;;;;GAKC,GACDV,KAAK;QACHQ,KAAK;YACH,OAAO,IAAI,CAACJ,IAAI;QAClB;QACAK,KAAK,SAAUC,KAAK;YAClB,IAAI,CAACN,IAAI,GAAGM;QACd;IACF;AACF;AAEA;;;CAGC,GACDZ,yBAAyBa,YAAY,GAAG;AAExC;;;;;;;;CAQC,GACDb,yBAAyBc,IAAI,GAAG,SAAUF,KAAK,EAAEG,KAAK,EAAEC,aAAa;IACnE,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACJ,QAAQ;QACnB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACG,QAAQ;QACnB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjCD,KAAK,CAACC,gBAAgB,GAAGJ,MAAMX,IAAI;IACnCc,KAAK,CAACC,cAAc,GAAGJ,MAAMV,GAAG;IAEhC,OAAOa;AACT;AAEA;;;;;;;CAOC,GACDf,yBAAyBiB,MAAM,GAAG,SAAUF,KAAK,EAAEC,aAAa,EAAEE,MAAM;IACtE,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACH,QAAQ;QACnB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjC,IAAI,CAAC,IAAA,6KAAO,EAACE,SAAS;QACpBA,SAAS,IAAIlB;IACf;IACAkB,OAAOjB,IAAI,GAAGc,KAAK,CAACC,gBAAgB;IACpCE,OAAOhB,GAAG,GAAGa,KAAK,CAACC,cAAc;IACjC,OAAOE;AACT;AAEA;;;;;;CAMC,GACDlB,yBAAyBmB,MAAM,GAAG,SAAUC,IAAI,EAAEC,KAAK;IACrD,OACED,SAASC,SACR,IAAA,6KAAO,EAACD,SACP,IAAA,6KAAO,EAACC,UACRD,KAAKnB,IAAI,KAAKoB,MAAMpB,IAAI,IACxBmB,KAAKlB,GAAG,KAAKmB,MAAMnB,GAAG;AAE5B;AAEA;;;;;;CAMC,GACDF,yBAAyBsB,KAAK,GAAG,SAAUV,KAAK,EAAEM,MAAM;IACtD,IAAI,CAAC,IAAA,6KAAO,EAACN,QAAQ;QACnB,OAAOW;IACT;IAEA,IAAI,CAAC,IAAA,6KAAO,EAACL,SAAS;QACpBA,SAAS,IAAIlB;IACf;IAEAkB,OAAOjB,IAAI,GAAGW,MAAMX,IAAI;IACxBiB,OAAOhB,GAAG,GAAGU,MAAMV,GAAG;IACtB,OAAOgB;AACT;AAEA;;;;;CAKC,GACDlB,yBAAyBS,SAAS,CAACa,KAAK,GAAG,SAAUJ,MAAM;IACzD,OAAOlB,yBAAyBsB,KAAK,CAAC,IAAI,EAAEJ;AAC9C;AAEA;;;;;CAKC,GACDlB,yBAAyBS,SAAS,CAACU,MAAM,GAAG,SAAUK,KAAK;IACzD,OAAOxB,yBAAyBmB,MAAM,CAAC,IAAI,EAAEK;AAC/C;uCACexB","ignoreList":[0]}},
    {"offset": {"line": 32104, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/NearFarScalar.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Represents a scalar value's lower and upper bound at a near distance and far distance in eye space.\n * @alias NearFarScalar\n * @constructor\n *\n * @param {number} [near=0.0] The lower bound of the camera range.\n * @param {number} [nearValue=0.0] The value at the lower bound of the camera range.\n * @param {number} [far=1.0] The upper bound of the camera range.\n * @param {number} [farValue=0.0] The value at the upper bound of the camera range.\n *\n * @see Packable\n */\nfunction NearFarScalar(near, nearValue, far, farValue) {\n  /**\n   * The lower bound of the camera range.\n   * @type {number}\n   * @default 0.0\n   */\n  this.near = near ?? 0.0;\n  /**\n   * The value at the lower bound of the camera range.\n   * @type {number}\n   * @default 0.0\n   */\n  this.nearValue = nearValue ?? 0.0;\n  /**\n   * The upper bound of the camera range.\n   * @type {number}\n   * @default 1.0\n   */\n  this.far = far ?? 1.0;\n  /**\n   * The value at the upper bound of the camera range.\n   * @type {number}\n   * @default 0.0\n   */\n  this.farValue = farValue ?? 0.0;\n}\n\n/**\n * Duplicates a NearFarScalar instance.\n *\n * @param {NearFarScalar} nearFarScalar The NearFarScalar to duplicate.\n * @param {NearFarScalar} [result] The object onto which to store the result.\n * @returns {NearFarScalar} The modified result parameter or a new NearFarScalar instance if one was not provided. (Returns undefined if nearFarScalar is undefined)\n */\nNearFarScalar.clone = function (nearFarScalar, result) {\n  if (!defined(nearFarScalar)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new NearFarScalar(\n      nearFarScalar.near,\n      nearFarScalar.nearValue,\n      nearFarScalar.far,\n      nearFarScalar.farValue,\n    );\n  }\n\n  result.near = nearFarScalar.near;\n  result.nearValue = nearFarScalar.nearValue;\n  result.far = nearFarScalar.far;\n  result.farValue = nearFarScalar.farValue;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nNearFarScalar.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {NearFarScalar} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nNearFarScalar.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value.near;\n  array[startingIndex++] = value.nearValue;\n  array[startingIndex++] = value.far;\n  array[startingIndex] = value.farValue;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {NearFarScalar} [result] The object into which to store the result.\n * @returns {NearFarScalar} The modified result parameter or a new NearFarScalar instance if one was not provided.\n */\nNearFarScalar.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new NearFarScalar();\n  }\n  result.near = array[startingIndex++];\n  result.nearValue = array[startingIndex++];\n  result.far = array[startingIndex++];\n  result.farValue = array[startingIndex];\n  return result;\n};\n\n/**\n * Compares the provided NearFarScalar and returns <code>true</code> if they are equal,\n * <code>false</code> otherwise.\n *\n * @param {NearFarScalar} [left] The first NearFarScalar.\n * @param {NearFarScalar} [right] The second NearFarScalar.\n * @returns {boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.\n */\nNearFarScalar.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.near === right.near &&\n      left.nearValue === right.nearValue &&\n      left.far === right.far &&\n      left.farValue === right.farValue)\n  );\n};\n\n/**\n * Duplicates this instance.\n *\n * @param {NearFarScalar} [result] The object onto which to store the result.\n * @returns {NearFarScalar} The modified result parameter or a new NearFarScalar instance if one was not provided.\n */\nNearFarScalar.prototype.clone = function (result) {\n  return NearFarScalar.clone(this, result);\n};\n\n/**\n * Compares this instance to the provided NearFarScalar and returns <code>true</code> if they are equal,\n * <code>false</code> otherwise.\n *\n * @param {NearFarScalar} [right] The right hand side NearFarScalar.\n * @returns {boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.\n */\nNearFarScalar.prototype.equals = function (right) {\n  return NearFarScalar.equals(this, right);\n};\nexport default NearFarScalar;\n"],"names":["NearFarScalar","near","nearValue","far","farValue","clone","nearFarScalar","result","undefined","packedLength","pack","value","array","startingIndex","unpack","equals","left","right","prototype"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 32247, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/EllipsoidalOccluder.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Determine whether or not other objects are visible or hidden behind the visible horizon defined by\n * an {@link Ellipsoid} and a camera position.  The ellipsoid is assumed to be located at the\n * origin of the coordinate system.  This class uses the algorithm described in the\n * {@link https://cesium.com/blog/2013/04/25/Horizon-culling/|Horizon Culling} blog post.\n *\n * @alias EllipsoidalOccluder\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to use as an occluder.\n * @param {Cartesian3} [cameraPosition] The coordinate of the viewer/camera.  If this parameter is not\n *        specified, {@link EllipsoidalOccluder#cameraPosition} must be called before\n *        testing visibility.\n *\n * @constructor\n *\n * @example\n * // Construct an ellipsoidal occluder with radii 1.0, 1.1, and 0.9.\n * const cameraPosition = new Cesium.Cartesian3(5.0, 6.0, 7.0);\n * const occluderEllipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(occluderEllipsoid, cameraPosition);\n *\n * @private\n */\nfunction EllipsoidalOccluder(ellipsoid, cameraPosition) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  //>>includeEnd('debug');\n\n  this._ellipsoid = ellipsoid;\n  this._cameraPosition = new Cartesian3();\n  this._cameraPositionInScaledSpace = new Cartesian3();\n  this._distanceToLimbInScaledSpaceSquared = 0.0;\n\n  // cameraPosition fills in the above values\n  if (defined(cameraPosition)) {\n    this.cameraPosition = cameraPosition;\n  }\n}\n\nObject.defineProperties(EllipsoidalOccluder.prototype, {\n  /**\n   * Gets the occluding ellipsoid.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n  /**\n   * Gets or sets the position of the camera.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Cartesian3}\n   */\n  cameraPosition: {\n    get: function () {\n      return this._cameraPosition;\n    },\n    set: function (cameraPosition) {\n      // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n      const ellipsoid = this._ellipsoid;\n      const cv = ellipsoid.transformPositionToScaledSpace(\n        cameraPosition,\n        this._cameraPositionInScaledSpace,\n      );\n      const vhMagnitudeSquared = Cartesian3.magnitudeSquared(cv) - 1.0;\n\n      Cartesian3.clone(cameraPosition, this._cameraPosition);\n      this._cameraPositionInScaledSpace = cv;\n      this._distanceToLimbInScaledSpaceSquared = vhMagnitudeSquared;\n    },\n  },\n});\n\nconst scratchCartesian = new Cartesian3();\n\n/**\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {Cartesian3} occludee The point to test for visibility.\n * @returns {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * const ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * const point = new Cesium.Cartesian3(0, -3, -3);\n * occluder.isPointVisible(point); //returns true\n */\nEllipsoidalOccluder.prototype.isPointVisible = function (occludee) {\n  const ellipsoid = this._ellipsoid;\n  const occludeeScaledSpacePosition = ellipsoid.transformPositionToScaledSpace(\n    occludee,\n    scratchCartesian,\n  );\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    this._cameraPositionInScaledSpace,\n    this._distanceToLimbInScaledSpaceSquared,\n  );\n};\n\n/**\n * Determines whether or not a point expressed in the ellipsoid scaled space, is hidden from view by the\n * occluder.  To transform a Cartesian X, Y, Z position in the coordinate system aligned with the ellipsoid\n * into the scaled space, call {@link Ellipsoid#transformPositionToScaledSpace}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space.\n * @returns {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * const ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * const point = new Cesium.Cartesian3(0, -3, -3);\n * const scaledSpacePoint = ellipsoid.transformPositionToScaledSpace(point);\n * occluder.isScaledSpacePointVisible(scaledSpacePoint); //returns true\n */\nEllipsoidalOccluder.prototype.isScaledSpacePointVisible = function (\n  occludeeScaledSpacePosition,\n) {\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    this._cameraPositionInScaledSpace,\n    this._distanceToLimbInScaledSpaceSquared,\n  );\n};\n\nconst scratchCameraPositionInScaledSpaceShrunk = new Cartesian3();\n\n/**\n * Similar to {@link EllipsoidalOccluder#isScaledSpacePointVisible} except tests against an\n * ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. This is intended to be used with points generated by\n * {@link EllipsoidalOccluder#computeHorizonCullingPointPossiblyUnderEllipsoid} or\n * {@link EllipsoidalOccluder#computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space of the possibly-shrunk ellipsoid.\n * @returns {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n */\nEllipsoidalOccluder.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid =\n  function (occludeeScaledSpacePosition, minimumHeight) {\n    const ellipsoid = this._ellipsoid;\n    let vhMagnitudeSquared;\n    let cv;\n\n    if (\n      defined(minimumHeight) &&\n      minimumHeight < 0.0 &&\n      ellipsoid.minimumRadius > -minimumHeight\n    ) {\n      // This code is similar to the cameraPosition setter, but unrolled for performance because it will be called a lot.\n      cv = scratchCameraPositionInScaledSpaceShrunk;\n      cv.x = this._cameraPosition.x / (ellipsoid.radii.x + minimumHeight);\n      cv.y = this._cameraPosition.y / (ellipsoid.radii.y + minimumHeight);\n      cv.z = this._cameraPosition.z / (ellipsoid.radii.z + minimumHeight);\n      vhMagnitudeSquared = cv.x * cv.x + cv.y * cv.y + cv.z * cv.z - 1.0;\n    } else {\n      cv = this._cameraPositionInScaledSpace;\n      vhMagnitudeSquared = this._distanceToLimbInScaledSpaceSquared;\n    }\n\n    return isScaledSpacePointVisible(\n      occludeeScaledSpacePosition,\n      cv,\n      vhMagnitudeSquared,\n    );\n  };\n\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid's axes.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPoint = function (\n  directionToPoint,\n  positions,\n  result,\n) {\n  return computeHorizonCullingPointFromPositions(\n    this._ellipsoid,\n    directionToPoint,\n    positions,\n    result,\n  );\n};\n\nconst scratchEllipsoidShrunk = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPoint} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid's axes.\n * @param {number} [minimumHeight] The minimum height of all positions. If this value is undefined, all positions are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid =\n  function (directionToPoint, positions, minimumHeight, result) {\n    const possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(\n      this._ellipsoid,\n      minimumHeight,\n      scratchEllipsoidShrunk,\n    );\n    return computeHorizonCullingPointFromPositions(\n      possiblyShrunkEllipsoid,\n      directionToPoint,\n      positions,\n      result,\n    );\n  };\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {number[]|Float32Array|Float64Array} vertices  The vertices from which to compute the horizon culling point. The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid's axes.\n * @param {number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices =\n  function (directionToPoint, vertices, stride, center, result) {\n    return computeHorizonCullingPointFromVertices(\n      this._ellipsoid,\n      directionToPoint,\n      vertices,\n      stride,\n      center,\n      result,\n    );\n  };\n\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPointFromVertices} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {number[]|Float32Array|Float64Array} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid's axes.\n * @param {number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {number} [minimumHeight] The minimum height of all vertices. If this value is undefined, all vertices are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid =\n  function (directionToPoint, vertices, stride, center, minimumHeight, result) {\n    const possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(\n      this._ellipsoid,\n      minimumHeight,\n      scratchEllipsoidShrunk,\n    );\n    return computeHorizonCullingPointFromVertices(\n      possiblyShrunkEllipsoid,\n      directionToPoint,\n      vertices,\n      stride,\n      center,\n      result,\n    );\n  };\n\nconst subsampleScratch = [];\n\n/**\n * Computes a point that can be used for horizon culling of a rectangle.  If the point is below\n * the horizon, the ellipsoid-conforming rectangle is guaranteed to be below the horizon as well.\n * The returned point is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Rectangle} rectangle The rectangle for which to compute the horizon culling point.\n * @param {Ellipsoid} ellipsoid The ellipsoid on which the rectangle is defined.  This may be different from\n *                    the ellipsoid used by this instance for occlusion testing.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle =\n  function (rectangle, ellipsoid, result) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.typeOf.object(\"rectangle\", rectangle);\n    //>>includeEnd('debug');\n\n    const positions = Rectangle.subsample(\n      rectangle,\n      ellipsoid,\n      0.0,\n      subsampleScratch,\n    );\n    const bs = BoundingSphere.fromPoints(positions);\n\n    // If the bounding sphere center is too close to the center of the occluder, it doesn't make\n    // sense to try to horizon cull it.\n    if (Cartesian3.magnitude(bs.center) < 0.1 * ellipsoid.minimumRadius) {\n      return undefined;\n    }\n\n    return this.computeHorizonCullingPoint(bs.center, positions, result);\n  };\n\nconst scratchEllipsoidShrunkRadii = new Cartesian3();\n\nfunction getPossiblyShrunkEllipsoid(ellipsoid, minimumHeight, result) {\n  if (\n    defined(minimumHeight) &&\n    minimumHeight < 0.0 &&\n    ellipsoid.minimumRadius > -minimumHeight\n  ) {\n    const ellipsoidShrunkRadii = Cartesian3.fromElements(\n      ellipsoid.radii.x + minimumHeight,\n      ellipsoid.radii.y + minimumHeight,\n      ellipsoid.radii.z + minimumHeight,\n      scratchEllipsoidShrunkRadii,\n    );\n    ellipsoid = Ellipsoid.fromCartesian3(ellipsoidShrunkRadii, result);\n  }\n  return ellipsoid;\n}\n\nfunction computeHorizonCullingPointFromPositions(\n  ellipsoid,\n  directionToPoint,\n  positions,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(\n    ellipsoid,\n    directionToPoint,\n  );\n  let resultMagnitude = 0.0;\n\n  for (let i = 0, len = positions.length; i < len; ++i) {\n    const position = positions[i];\n    const candidateMagnitude = computeMagnitude(\n      ellipsoid,\n      position,\n      scaledSpaceDirectionToPoint,\n    );\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn't, so return undefined\n      return undefined;\n    }\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nconst positionScratch = new Cartesian3();\n\nfunction computeHorizonCullingPointFromVertices(\n  ellipsoid,\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\n  Check.defined(\"vertices\", vertices);\n  Check.typeOf.number(\"stride\", stride);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  stride = stride ?? 3;\n  center = center ?? Cartesian3.ZERO;\n  const scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(\n    ellipsoid,\n    directionToPoint,\n  );\n  let resultMagnitude = 0.0;\n\n  for (let i = 0, len = vertices.length; i < len; i += stride) {\n    positionScratch.x = vertices[i] + center.x;\n    positionScratch.y = vertices[i + 1] + center.y;\n    positionScratch.z = vertices[i + 2] + center.z;\n\n    const candidateMagnitude = computeMagnitude(\n      ellipsoid,\n      positionScratch,\n      scaledSpaceDirectionToPoint,\n    );\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn't, so return undefined\n      return undefined;\n    }\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nfunction isScaledSpacePointVisible(\n  occludeeScaledSpacePosition,\n  cameraPositionInScaledSpace,\n  distanceToLimbInScaledSpaceSquared,\n) {\n  // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n  const cv = cameraPositionInScaledSpace;\n  const vhMagnitudeSquared = distanceToLimbInScaledSpaceSquared;\n  const vt = Cartesian3.subtract(\n    occludeeScaledSpacePosition,\n    cv,\n    scratchCartesian,\n  );\n  const vtDotVc = -Cartesian3.dot(vt, cv);\n  // If vhMagnitudeSquared < 0 then we are below the surface of the ellipsoid and\n  // in this case, set the culling plane to be on V.\n  const isOccluded =\n    vhMagnitudeSquared < 0\n      ? vtDotVc > 0\n      : vtDotVc > vhMagnitudeSquared &&\n        (vtDotVc * vtDotVc) / Cartesian3.magnitudeSquared(vt) >\n          vhMagnitudeSquared;\n  return !isOccluded;\n}\n\nconst scaledSpaceScratch = new Cartesian3();\nconst directionScratch = new Cartesian3();\n\nfunction computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint) {\n  const scaledSpacePosition = ellipsoid.transformPositionToScaledSpace(\n    position,\n    scaledSpaceScratch,\n  );\n  let magnitudeSquared = Cartesian3.magnitudeSquared(scaledSpacePosition);\n  let magnitude = Math.sqrt(magnitudeSquared);\n  const direction = Cartesian3.divideByScalar(\n    scaledSpacePosition,\n    magnitude,\n    directionScratch,\n  );\n\n  // For the purpose of this computation, points below the ellipsoid are consider to be on it instead.\n  magnitudeSquared = Math.max(1.0, magnitudeSquared);\n  magnitude = Math.max(1.0, magnitude);\n\n  const cosAlpha = Cartesian3.dot(direction, scaledSpaceDirectionToPoint);\n  const sinAlpha = Cartesian3.magnitude(\n    Cartesian3.cross(direction, scaledSpaceDirectionToPoint, direction),\n  );\n  const cosBeta = 1.0 / magnitude;\n  const sinBeta = Math.sqrt(magnitudeSquared - 1.0) * cosBeta;\n\n  return 1.0 / (cosAlpha * cosBeta - sinAlpha * sinBeta);\n}\n\nfunction magnitudeToPoint(\n  scaledSpaceDirectionToPoint,\n  resultMagnitude,\n  result,\n) {\n  // The horizon culling point is undefined if there were no positions from which to compute it,\n  // the directionToPoint is pointing opposite all of the positions,  or if we computed NaN or infinity.\n  if (\n    resultMagnitude <= 0.0 ||\n    resultMagnitude === 1.0 / 0.0 ||\n    resultMagnitude !== resultMagnitude\n  ) {\n    return undefined;\n  }\n\n  return Cartesian3.multiplyByScalar(\n    scaledSpaceDirectionToPoint,\n    resultMagnitude,\n    result,\n  );\n}\n\nconst directionToPointScratch = new Cartesian3();\n\nfunction computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint) {\n  if (Cartesian3.equals(directionToPoint, Cartesian3.ZERO)) {\n    return directionToPoint;\n  }\n\n  ellipsoid.transformPositionToScaledSpace(\n    directionToPoint,\n    directionToPointScratch,\n  );\n  return Cartesian3.normalize(directionToPointScratch, directionToPointScratch);\n}\nexport default EllipsoidalOccluder;\n"],"names":["EllipsoidalOccluder","ellipsoid","cameraPosition","typeOf","object","_ellipsoid","_cameraPosition","_cameraPositionInScaledSpace","_distanceToLimbInScaledSpaceSquared","Object","defineProperties","prototype","get","set","cv","transformPositionToScaledSpace","vhMagnitudeSquared","magnitudeSquared","clone","scratchCartesian","isPointVisible","occludee","occludeeScaledSpacePosition","isScaledSpacePointVisible","scratchCameraPositionInScaledSpaceShrunk","isScaledSpacePointVisiblePossiblyUnderEllipsoid","minimumHeight","minimumRadius","x","radii","y","z","computeHorizonCullingPoint","directionToPoint","positions","result","computeHorizonCullingPointFromPositions","scratchEllipsoidShrunk","UNIT_SPHERE","computeHorizonCullingPointPossiblyUnderEllipsoid","possiblyShrunkEllipsoid","getPossiblyShrunkEllipsoid","computeHorizonCullingPointFromVertices","vertices","stride","center","computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid","subsampleScratch","computeHorizonCullingPointFromRectangle","rectangle","subsample","bs","fromPoints","magnitude","undefined","scratchEllipsoidShrunkRadii","ellipsoidShrunkRadii","fromElements","fromCartesian3","defined","scaledSpaceDirectionToPoint","computeScaledSpaceDirectionToPoint","resultMagnitude","i","len","length","position","candidateMagnitude","computeMagnitude","Math","max","magnitudeToPoint","positionScratch","number","ZERO","cameraPositionInScaledSpace","distanceToLimbInScaledSpaceSquared","vt","subtract","vtDotVc","dot","isOccluded","scaledSpaceScratch","directionScratch","scaledSpacePosition","sqrt","direction","divideByScalar","cosAlpha","sinAlpha","cross","cosBeta","sinBeta","multiplyByScalar","directionToPointScratch","equals","normalize"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 32600, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/CullingVolume.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Intersect from \"./Intersect.js\";\nimport Plane from \"./Plane.js\";\n\n/**\n * The culling volume defined by planes.\n *\n * @alias CullingVolume\n * @constructor\n *\n * @param {Cartesian4[]} [planes] An array of clipping planes.\n */\nfunction CullingVolume(planes) {\n  /**\n   * Each plane is represented by a Cartesian4 object, where the x, y, and z components\n   * define the unit vector normal to the plane, and the w component is the distance of the\n   * plane from the origin.\n   * @type {Cartesian4[]}\n   * @default []\n   */\n  this.planes = planes ?? [];\n}\n\nconst faces = [new Cartesian3(), new Cartesian3(), new Cartesian3()];\nCartesian3.clone(Cartesian3.UNIT_X, faces[0]);\nCartesian3.clone(Cartesian3.UNIT_Y, faces[1]);\nCartesian3.clone(Cartesian3.UNIT_Z, faces[2]);\n\nconst scratchPlaneCenter = new Cartesian3();\nconst scratchPlaneNormal = new Cartesian3();\nconst scratchPlane = new Plane(new Cartesian3(1.0, 0.0, 0.0), 0.0);\n\n/**\n * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n * The planes are aligned to the x, y, and z axes in world coordinates.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere used to create the culling volume.\n * @param {CullingVolume} [result] The object onto which to store the result.\n * @returns {CullingVolume} The culling volume created from the bounding sphere.\n */\nCullingVolume.fromBoundingSphere = function (boundingSphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new CullingVolume();\n  }\n\n  const length = faces.length;\n  const planes = result.planes;\n  planes.length = 2 * length;\n\n  const center = boundingSphere.center;\n  const radius = boundingSphere.radius;\n\n  let planeIndex = 0;\n\n  for (let i = 0; i < length; ++i) {\n    const faceNormal = faces[i];\n\n    let plane0 = planes[planeIndex];\n    let plane1 = planes[planeIndex + 1];\n\n    if (!defined(plane0)) {\n      plane0 = planes[planeIndex] = new Cartesian4();\n    }\n    if (!defined(plane1)) {\n      plane1 = planes[planeIndex + 1] = new Cartesian4();\n    }\n\n    Cartesian3.multiplyByScalar(faceNormal, -radius, scratchPlaneCenter);\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\n\n    plane0.x = faceNormal.x;\n    plane0.y = faceNormal.y;\n    plane0.z = faceNormal.z;\n    plane0.w = -Cartesian3.dot(faceNormal, scratchPlaneCenter);\n\n    Cartesian3.multiplyByScalar(faceNormal, radius, scratchPlaneCenter);\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\n\n    plane1.x = -faceNormal.x;\n    plane1.y = -faceNormal.y;\n    plane1.z = -faceNormal.z;\n    plane1.w = -Cartesian3.dot(\n      Cartesian3.negate(faceNormal, scratchPlaneNormal),\n      scratchPlaneCenter,\n    );\n\n    planeIndex += 2;\n  }\n\n  return result;\n};\n\n/**\n * Determines whether a bounding volume intersects the culling volume.\n *\n * @param {object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\n * @returns {Intersect}  Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.\n */\nCullingVolume.prototype.computeVisibility = function (boundingVolume) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingVolume)) {\n    throw new DeveloperError(\"boundingVolume is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planes = this.planes;\n  let intersecting = false;\n  for (let k = 0, len = planes.length; k < len; ++k) {\n    const result = boundingVolume.intersectPlane(\n      Plane.fromCartesian4(planes[k], scratchPlane),\n    );\n    if (result === Intersect.OUTSIDE) {\n      return Intersect.OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      intersecting = true;\n    }\n  }\n\n  return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;\n};\n\n/**\n * Determines whether a bounding volume intersects the culling volume.\n *\n * @param {object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\n * @param {number} parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n *                                 volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n *                                 the parent (and therefore this) volume is completely inside plane[planeIndex]\n *                                 and that plane check can be skipped.\n * @returns {number} A plane mask as described above (which can be applied to this boundingVolume's children).\n *\n * @private\n */\nCullingVolume.prototype.computeVisibilityWithPlaneMask = function (\n  boundingVolume,\n  parentPlaneMask,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingVolume)) {\n    throw new DeveloperError(\"boundingVolume is required.\");\n  }\n  if (!defined(parentPlaneMask)) {\n    throw new DeveloperError(\"parentPlaneMask is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (\n    parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n    parentPlaneMask === CullingVolume.MASK_INSIDE\n  ) {\n    // parent is completely outside or completely inside, so this child is as well.\n    return parentPlaneMask;\n  }\n\n  // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n  // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n  let mask = CullingVolume.MASK_INSIDE;\n\n  const planes = this.planes;\n  for (let k = 0, len = planes.length; k < len; ++k) {\n    // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n    const flag = k < 31 ? 1 << k : 0;\n    if (k < 31 && (parentPlaneMask & flag) === 0) {\n      // boundingVolume is known to be INSIDE this plane.\n      continue;\n    }\n\n    const result = boundingVolume.intersectPlane(\n      Plane.fromCartesian4(planes[k], scratchPlane),\n    );\n    if (result === Intersect.OUTSIDE) {\n      return CullingVolume.MASK_OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      mask |= flag;\n    }\n  }\n\n  return mask;\n};\n\n/**\n * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n * represents the case where the object bounding volume is entirely outside the culling volume.\n *\n * @type {number}\n * @private\n */\nCullingVolume.MASK_OUTSIDE = 0xffffffff;\n\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume is entirely inside the culling volume.\n *\n * @type {number}\n * @private\n */\nCullingVolume.MASK_INSIDE = 0x00000000;\n\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n *\n * @type {number}\n * @private\n */\nCullingVolume.MASK_INDETERMINATE = 0x7fffffff;\nexport default CullingVolume;\n"],"names":["CullingVolume","planes","faces","clone","UNIT_X","UNIT_Y","UNIT_Z","scratchPlaneCenter","scratchPlaneNormal","scratchPlane","fromBoundingSphere","boundingSphere","result","length","center","radius","planeIndex","i","faceNormal","plane0","plane1","multiplyByScalar","add","x","y","z","w","dot","negate","prototype","computeVisibility","boundingVolume","intersecting","k","len","intersectPlane","fromCartesian4","OUTSIDE","INTERSECTING","INSIDE","computeVisibilityWithPlaneMask","parentPlaneMask","MASK_OUTSIDE","MASK_INSIDE","mask","flag","MASK_INDETERMINATE"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 32783, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/OrthographicOffCenterFrustum.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport CullingVolume from \"./CullingVolume.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias OrthographicOffCenterFrustum\n * @constructor\n *\n * @param {object} [options] An object with the following properties:\n * @param {number} [options.left] The left clipping plane distance.\n * @param {number} [options.right] The right clipping plane distance.\n * @param {number} [options.top] The top clipping plane distance.\n * @param {number} [options.bottom] The bottom clipping plane distance.\n * @param {number} [options.near=1.0] The near clipping plane distance.\n * @param {number} [options.far=500000000.0] The far clipping plane distance.\n *\n * @example\n * const maxRadii = ellipsoid.maximumRadius;\n *\n * const frustum = new Cesium.OrthographicOffCenterFrustum();\n * frustum.right = maxRadii * Cesium.Math.PI;\n * frustum.left = -c.frustum.right;\n * frustum.top = c.frustum.right * (canvas.clientHeight / canvas.clientWidth);\n * frustum.bottom = -c.frustum.top;\n * frustum.near = 0.01 * maxRadii;\n * frustum.far = 50.0 * maxRadii;\n */\nfunction OrthographicOffCenterFrustum(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  /**\n   * The left clipping plane.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.left = options.left;\n  this._left = undefined;\n\n  /**\n   * The right clipping plane.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.right = options.right;\n  this._right = undefined;\n\n  /**\n   * The top clipping plane.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.top = options.top;\n  this._top = undefined;\n\n  /**\n   * The bottom clipping plane.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.bottom = options.bottom;\n  this._bottom = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {number}\n   * @default 1.0\n   */\n  this.near = options.near ?? 1.0;\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {number}\n   * @default 500000000.0;\n   */\n  this.far = options.far ?? 500000000.0;\n  this._far = this.far;\n\n  this._cullingVolume = new CullingVolume();\n  this._orthographicMatrix = new Matrix4();\n}\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(frustum.right) ||\n    !defined(frustum.left) ||\n    !defined(frustum.top) ||\n    !defined(frustum.bottom) ||\n    !defined(frustum.near) ||\n    !defined(frustum.far)\n  ) {\n    throw new DeveloperError(\n      \"right, left, top, bottom, near, or far parameters are not set.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (\n    frustum.top !== frustum._top ||\n    frustum.bottom !== frustum._bottom ||\n    frustum.left !== frustum._left ||\n    frustum.right !== frustum._right ||\n    frustum.near !== frustum._near ||\n    frustum.far !== frustum._far\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.left > frustum.right) {\n      throw new DeveloperError(\"right must be greater than left.\");\n    }\n    if (frustum.bottom > frustum.top) {\n      throw new DeveloperError(\"top must be greater than bottom.\");\n    }\n    if (frustum.near <= 0 || frustum.near > frustum.far) {\n      throw new DeveloperError(\n        \"near must be greater than zero and less than far.\",\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._left = frustum.left;\n    frustum._right = frustum.right;\n    frustum._top = frustum.top;\n    frustum._bottom = frustum.bottom;\n    frustum._near = frustum.near;\n    frustum._far = frustum.far;\n    frustum._orthographicMatrix = Matrix4.computeOrthographicOffCenter(\n      frustum.left,\n      frustum.right,\n      frustum.bottom,\n      frustum.top,\n      frustum.near,\n      frustum.far,\n      frustum._orthographicMatrix,\n    );\n  }\n}\n\nObject.defineProperties(OrthographicOffCenterFrustum.prototype, {\n  /**\n   * Gets the orthographic projection matrix computed from the view frustum.\n   * @memberof OrthographicOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._orthographicMatrix;\n    },\n  },\n});\n\nconst getPlanesRight = new Cartesian3();\nconst getPlanesNearCenter = new Cartesian3();\nconst getPlanesPoint = new Cartesian3();\nconst negateScratch = new Cartesian3();\n\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nOrthographicOffCenterFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  if (!defined(up)) {\n    throw new DeveloperError(\"up is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planes = this._cullingVolume.planes;\n  const t = this.top;\n  const b = this.bottom;\n  const r = this.right;\n  const l = this.left;\n  const n = this.near;\n  const f = this.far;\n\n  const right = Cartesian3.cross(direction, up, getPlanesRight);\n  Cartesian3.normalize(right, right);\n  const nearCenter = getPlanesNearCenter;\n  Cartesian3.multiplyByScalar(direction, n, nearCenter);\n  Cartesian3.add(position, nearCenter, nearCenter);\n\n  const point = getPlanesPoint;\n\n  // Left plane\n  Cartesian3.multiplyByScalar(right, l, point);\n  Cartesian3.add(nearCenter, point, point);\n\n  let plane = planes[0];\n  if (!defined(plane)) {\n    plane = planes[0] = new Cartesian4();\n  }\n  plane.x = right.x;\n  plane.y = right.y;\n  plane.z = right.z;\n  plane.w = -Cartesian3.dot(right, point);\n\n  // Right plane\n  Cartesian3.multiplyByScalar(right, r, point);\n  Cartesian3.add(nearCenter, point, point);\n\n  plane = planes[1];\n  if (!defined(plane)) {\n    plane = planes[1] = new Cartesian4();\n  }\n  plane.x = -right.x;\n  plane.y = -right.y;\n  plane.z = -right.z;\n  plane.w = -Cartesian3.dot(Cartesian3.negate(right, negateScratch), point);\n\n  // Bottom plane\n  Cartesian3.multiplyByScalar(up, b, point);\n  Cartesian3.add(nearCenter, point, point);\n\n  plane = planes[2];\n  if (!defined(plane)) {\n    plane = planes[2] = new Cartesian4();\n  }\n  plane.x = up.x;\n  plane.y = up.y;\n  plane.z = up.z;\n  plane.w = -Cartesian3.dot(up, point);\n\n  // Top plane\n  Cartesian3.multiplyByScalar(up, t, point);\n  Cartesian3.add(nearCenter, point, point);\n\n  plane = planes[3];\n  if (!defined(plane)) {\n    plane = planes[3] = new Cartesian4();\n  }\n  plane.x = -up.x;\n  plane.y = -up.y;\n  plane.z = -up.z;\n  plane.w = -Cartesian3.dot(Cartesian3.negate(up, negateScratch), point);\n\n  // Near plane\n  plane = planes[4];\n  if (!defined(plane)) {\n    plane = planes[4] = new Cartesian4();\n  }\n  plane.x = direction.x;\n  plane.y = direction.y;\n  plane.z = direction.z;\n  plane.w = -Cartesian3.dot(direction, nearCenter);\n\n  // Far plane\n  Cartesian3.multiplyByScalar(direction, f, point);\n  Cartesian3.add(position, point, point);\n\n  plane = planes[5];\n  if (!defined(plane)) {\n    plane = planes[5] = new Cartesian4();\n  }\n  plane.x = -direction.x;\n  plane.y = -direction.y;\n  plane.z = -direction.z;\n  plane.w = -Cartesian3.dot(Cartesian3.negate(direction, negateScratch), point);\n\n  return this._cullingVolume;\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {number} drawingBufferWidth The width of the drawing buffer.\n * @param {number} drawingBufferHeight The height of the drawing buffer.\n * @param {number} distance The distance to the near plane in meters.\n * @param {number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());\n */\nOrthographicOffCenterFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result,\n) {\n  update(this);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {\n    throw new DeveloperError(\n      \"Both drawingBufferWidth and drawingBufferHeight are required.\",\n    );\n  }\n  if (drawingBufferWidth <= 0) {\n    throw new DeveloperError(\"drawingBufferWidth must be greater than zero.\");\n  }\n  if (drawingBufferHeight <= 0) {\n    throw new DeveloperError(\"drawingBufferHeight must be greater than zero.\");\n  }\n  if (!defined(distance)) {\n    throw new DeveloperError(\"distance is required.\");\n  }\n  if (!defined(pixelRatio)) {\n    throw new DeveloperError(\"pixelRatio is required.\");\n  }\n  if (pixelRatio <= 0) {\n    throw new DeveloperError(\"pixelRatio must be greater than zero.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"A result object is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const frustumWidth = this.right - this.left;\n  const frustumHeight = this.top - this.bottom;\n  const pixelWidth = (pixelRatio * frustumWidth) / drawingBufferWidth;\n  const pixelHeight = (pixelRatio * frustumHeight) / drawingBufferHeight;\n\n  result.x = pixelWidth;\n  result.y = pixelHeight;\n  return result;\n};\n\n/**\n * Returns a duplicate of a OrthographicOffCenterFrustum instance.\n *\n * @param {OrthographicOffCenterFrustum} [result] The object onto which to store the result.\n * @returns {OrthographicOffCenterFrustum} The modified result parameter or a new OrthographicOffCenterFrustum instance if one was not provided.\n */\nOrthographicOffCenterFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new OrthographicOffCenterFrustum();\n  }\n\n  result.left = this.left;\n  result.right = this.right;\n  result.top = this.top;\n  result.bottom = this.bottom;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._left = undefined;\n  result._right = undefined;\n  result._top = undefined;\n  result._bottom = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  return result;\n};\n\n/**\n * Compares the provided OrthographicOffCenterFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrthographicOffCenterFrustum} [other] The right hand side OrthographicOffCenterFrustum.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrthographicOffCenterFrustum.prototype.equals = function (other) {\n  return (\n    defined(other) &&\n    other instanceof OrthographicOffCenterFrustum &&\n    this.right === other.right &&\n    this.left === other.left &&\n    this.top === other.top &&\n    this.bottom === other.bottom &&\n    this.near === other.near &&\n    this.far === other.far\n  );\n};\n\n/**\n * Compares the provided OrthographicOffCenterFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {OrthographicOffCenterFrustum} other The right hand side OrthographicOffCenterFrustum.\n * @param {number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nOrthographicOffCenterFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return (\n    other === this ||\n    (defined(other) &&\n      other instanceof OrthographicOffCenterFrustum &&\n      CesiumMath.equalsEpsilon(\n        this.right,\n        other.right,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.left,\n        other.left,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.top,\n        other.top,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.bottom,\n        other.bottom,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.near,\n        other.near,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.far,\n        other.far,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ))\n  );\n};\nexport default OrthographicOffCenterFrustum;\n"],"names":["OrthographicOffCenterFrustum","options","EMPTY_OBJECT","left","_left","undefined","right","_right","top","_top","bottom","_bottom","near","_near","far","_far","_cullingVolume","_orthographicMatrix","update","frustum","computeOrthographicOffCenter","Object","defineProperties","prototype","projectionMatrix","get","getPlanesRight","getPlanesNearCenter","getPlanesPoint","negateScratch","computeCullingVolume","position","direction","up","planes","t","b","r","l","n","f","cross","normalize","nearCenter","multiplyByScalar","add","point","plane","x","y","z","w","dot","negate","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","distance","pixelRatio","result","frustumWidth","frustumHeight","pixelWidth","pixelHeight","clone","equals","other","equalsEpsilon","relativeEpsilon","absoluteEpsilon"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 33119, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/OrthographicFrustum.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrthographicOffCenterFrustum from \"./OrthographicOffCenterFrustum.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias OrthographicFrustum\n * @constructor\n *\n * @param {object} [options] An object with the following properties:\n * @param {number} [options.width] The width of the frustum in meters.\n * @param {number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\n * @param {number} [options.near=1.0] The distance of the near plane.\n * @param {number} [options.far=500000000.0] The distance of the far plane.\n *\n * @example\n * const maxRadii = ellipsoid.maximumRadius;\n *\n * const frustum = new Cesium.OrthographicFrustum();\n * frustum.near = 0.01 * maxRadii;\n * frustum.far = 50.0 * maxRadii;\n */\nfunction OrthographicFrustum(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  this._offCenterFrustum = new OrthographicOffCenterFrustum();\n\n  /**\n   * The horizontal width of the frustum in meters.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.width = options.width;\n  this._width = undefined;\n\n  /**\n   * The aspect ratio of the frustum's width to it's height.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.aspectRatio = options.aspectRatio;\n  this._aspectRatio = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {number}\n   * @default 1.0\n   */\n  this.near = options.near ?? 1.0;\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {number}\n   * @default 500000000.0;\n   */\n  this.far = options.far ?? 500000000.0;\n  this._far = this.far;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nOrthographicFrustum.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {OrthographicFrustum} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nOrthographicFrustum.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value.width;\n  array[startingIndex++] = value.aspectRatio;\n  array[startingIndex++] = value.near;\n  array[startingIndex] = value.far;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {OrthographicFrustum} [result] The object into which to store the result.\n * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\n */\nOrthographicFrustum.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new OrthographicFrustum();\n  }\n\n  result.width = array[startingIndex++];\n  result.aspectRatio = array[startingIndex++];\n  result.near = array[startingIndex++];\n  result.far = array[startingIndex];\n\n  return result;\n};\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(frustum.width) ||\n    !defined(frustum.aspectRatio) ||\n    !defined(frustum.near) ||\n    !defined(frustum.far)\n  ) {\n    throw new DeveloperError(\n      \"width, aspectRatio, near, or far parameters are not set.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const f = frustum._offCenterFrustum;\n\n  if (\n    frustum.width !== frustum._width ||\n    frustum.aspectRatio !== frustum._aspectRatio ||\n    frustum.near !== frustum._near ||\n    frustum.far !== frustum._far\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.aspectRatio < 0) {\n      throw new DeveloperError(\"aspectRatio must be positive.\");\n    }\n    if (frustum.near < 0 || frustum.near > frustum.far) {\n      throw new DeveloperError(\n        \"near must be greater than zero and less than far.\",\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._aspectRatio = frustum.aspectRatio;\n    frustum._width = frustum.width;\n    frustum._near = frustum.near;\n    frustum._far = frustum.far;\n\n    const ratio = 1.0 / frustum.aspectRatio;\n    f.right = frustum.width * 0.5;\n    f.left = -f.right;\n    f.top = ratio * f.right;\n    f.bottom = -f.top;\n    f.near = frustum.near;\n    f.far = frustum.far;\n  }\n}\n\nObject.defineProperties(OrthographicFrustum.prototype, {\n  /**\n   * Gets the orthographic projection matrix computed from the view frustum.\n   * @memberof OrthographicFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum.projectionMatrix;\n    },\n  },\n  /**\n   * Gets the orthographic projection matrix computed from the view frustum.\n   * @memberof OrthographicFrustum.prototype\n   * @type {OrthographicOffCenterFrustum}\n   * @readonly\n   * @private\n   */\n  offCenterFrustum: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum;\n    },\n  },\n});\n\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nOrthographicFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up,\n) {\n  update(this);\n  return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {number} drawingBufferWidth The width of the drawing buffer.\n * @param {number} drawingBufferHeight The height of the drawing buffer.\n * @param {number} distance The distance to the near plane in meters.\n * @param {number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());\n */\nOrthographicFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result,\n) {\n  update(this);\n  return this._offCenterFrustum.getPixelDimensions(\n    drawingBufferWidth,\n    drawingBufferHeight,\n    distance,\n    pixelRatio,\n    result,\n  );\n};\n\n/**\n * Returns a duplicate of a OrthographicFrustum instance.\n *\n * @param {OrthographicFrustum} [result] The object onto which to store the result.\n * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\n */\nOrthographicFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new OrthographicFrustum();\n  }\n\n  result.aspectRatio = this.aspectRatio;\n  result.width = this.width;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._aspectRatio = undefined;\n  result._width = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  this._offCenterFrustum.clone(result._offCenterFrustum);\n\n  return result;\n};\n\n/**\n * Compares the provided OrthographicFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrthographicFrustum} [other] The right hand side OrthographicFrustum.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrthographicFrustum.prototype.equals = function (other) {\n  if (!defined(other) || !(other instanceof OrthographicFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n\n  return (\n    this.width === other.width &&\n    this.aspectRatio === other.aspectRatio &&\n    this._offCenterFrustum.equals(other._offCenterFrustum)\n  );\n};\n\n/**\n * Compares the provided OrthographicFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {OrthographicFrustum} other The right hand side OrthographicFrustum.\n * @param {number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nOrthographicFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  if (!defined(other) || !(other instanceof OrthographicFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n\n  return (\n    CesiumMath.equalsEpsilon(\n      this.width,\n      other.width,\n      relativeEpsilon,\n      absoluteEpsilon,\n    ) &&\n    CesiumMath.equalsEpsilon(\n      this.aspectRatio,\n      other.aspectRatio,\n      relativeEpsilon,\n      absoluteEpsilon,\n    ) &&\n    this._offCenterFrustum.equalsEpsilon(\n      other._offCenterFrustum,\n      relativeEpsilon,\n      absoluteEpsilon,\n    )\n  );\n};\nexport default OrthographicFrustum;\n"],"names":["OrthographicFrustum","options","EMPTY_OBJECT","_offCenterFrustum","width","_width","undefined","aspectRatio","_aspectRatio","near","_near","far","_far","packedLength","pack","value","array","startingIndex","typeOf","object","defined","unpack","result","update","frustum","f","ratio","right","left","top","bottom","Object","defineProperties","prototype","projectionMatrix","get","offCenterFrustum","computeCullingVolume","position","direction","up","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","distance","pixelRatio","clone","equals","other","equalsEpsilon","relativeEpsilon","absoluteEpsilon"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;CAqBC,GACD,SAASA,oBAAoBC,OAAO;IAClCA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC,IAAI,CAACC,iBAAiB,GAAG,IAAI,kMAA4B;IAEzD;;;;GAIC,GACD,IAAI,CAACC,KAAK,GAAGH,QAAQG,KAAK;IAC1B,IAAI,CAACC,MAAM,GAAGC;IAEd;;;;GAIC,GACD,IAAI,CAACC,WAAW,GAAGN,QAAQM,WAAW;IACtC,IAAI,CAACC,YAAY,GAAGF;IAEpB;;;;GAIC,GACD,IAAI,CAACG,IAAI,GAAGR,QAAQQ,IAAI,IAAI;IAC5B,IAAI,CAACC,KAAK,GAAG,IAAI,CAACD,IAAI;IAEtB;;;;GAIC,GACD,IAAI,CAACE,GAAG,GAAGV,QAAQU,GAAG,IAAI;IAC1B,IAAI,CAACC,IAAI,GAAG,IAAI,CAACD,GAAG;AACtB;AAEA;;;CAGC,GACDX,oBAAoBa,YAAY,GAAG;AAEnC;;;;;;;;CAQC,GACDb,oBAAoBc,IAAI,GAAG,SAAUC,KAAK,EAAEC,KAAK,EAAEC,aAAa;IAC9D,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,SAASJ;IAC7B,2KAAK,CAACK,OAAO,CAAC,SAASJ;IACvB,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjCD,KAAK,CAACC,gBAAgB,GAAGF,MAAMX,KAAK;IACpCY,KAAK,CAACC,gBAAgB,GAAGF,MAAMR,WAAW;IAC1CS,KAAK,CAACC,gBAAgB,GAAGF,MAAMN,IAAI;IACnCO,KAAK,CAACC,cAAc,GAAGF,MAAMJ,GAAG;IAEhC,OAAOK;AACT;AAEA;;;;;;;CAOC,GACDhB,oBAAoBqB,MAAM,GAAG,SAAUL,KAAK,EAAEC,aAAa,EAAEK,MAAM;IACjE,yCAAyC;IACzC,2KAAK,CAACF,OAAO,CAAC,SAASJ;IACvB,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjC,IAAI,CAAC,IAAA,6KAAO,EAACK,SAAS;QACpBA,SAAS,IAAItB;IACf;IAEAsB,OAAOlB,KAAK,GAAGY,KAAK,CAACC,gBAAgB;IACrCK,OAAOf,WAAW,GAAGS,KAAK,CAACC,gBAAgB;IAC3CK,OAAOb,IAAI,GAAGO,KAAK,CAACC,gBAAgB;IACpCK,OAAOX,GAAG,GAAGK,KAAK,CAACC,cAAc;IAEjC,OAAOK;AACT;AAEA,SAASC,OAAOC,OAAO;IACrB,yCAAyC;IACzC,IACE,CAAC,IAAA,6KAAO,EAACA,QAAQpB,KAAK,KACtB,CAAC,IAAA,6KAAO,EAACoB,QAAQjB,WAAW,KAC5B,CAAC,IAAA,6KAAO,EAACiB,QAAQf,IAAI,KACrB,CAAC,IAAA,6KAAO,EAACe,QAAQb,GAAG,GACpB;QACA,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,wBAAwB;IAExB,MAAMc,IAAID,QAAQrB,iBAAiB;IAEnC,IACEqB,QAAQpB,KAAK,KAAKoB,QAAQnB,MAAM,IAChCmB,QAAQjB,WAAW,KAAKiB,QAAQhB,YAAY,IAC5CgB,QAAQf,IAAI,KAAKe,QAAQd,KAAK,IAC9Bc,QAAQb,GAAG,KAAKa,QAAQZ,IAAI,EAC5B;QACA,yCAAyC;QACzC,IAAIY,QAAQjB,WAAW,GAAG,GAAG;YAC3B,MAAM,IAAI,oLAAc,CAAC;QAC3B;QACA,IAAIiB,QAAQf,IAAI,GAAG,KAAKe,QAAQf,IAAI,GAAGe,QAAQb,GAAG,EAAE;YAClD,MAAM,IAAI,oLAAc,CACtB;QAEJ;QACA,wBAAwB;QAExBa,QAAQhB,YAAY,GAAGgB,QAAQjB,WAAW;QAC1CiB,QAAQnB,MAAM,GAAGmB,QAAQpB,KAAK;QAC9BoB,QAAQd,KAAK,GAAGc,QAAQf,IAAI;QAC5Be,QAAQZ,IAAI,GAAGY,QAAQb,GAAG;QAE1B,MAAMe,QAAQ,MAAMF,QAAQjB,WAAW;QACvCkB,EAAEE,KAAK,GAAGH,QAAQpB,KAAK,GAAG;QAC1BqB,EAAEG,IAAI,GAAG,CAACH,EAAEE,KAAK;QACjBF,EAAEI,GAAG,GAAGH,QAAQD,EAAEE,KAAK;QACvBF,EAAEK,MAAM,GAAG,CAACL,EAAEI,GAAG;QACjBJ,EAAEhB,IAAI,GAAGe,QAAQf,IAAI;QACrBgB,EAAEd,GAAG,GAAGa,QAAQb,GAAG;IACrB;AACF;AAEAoB,OAAOC,gBAAgB,CAAChC,oBAAoBiC,SAAS,EAAE;IACrD;;;;;GAKC,GACDC,kBAAkB;QAChBC,KAAK;YACHZ,OAAO,IAAI;YACX,OAAO,IAAI,CAACpB,iBAAiB,CAAC+B,gBAAgB;QAChD;IACF;IACA;;;;;;GAMC,GACDE,kBAAkB;QAChBD,KAAK;YACHZ,OAAO,IAAI;YACX,OAAO,IAAI,CAACpB,iBAAiB;QAC/B;IACF;AACF;AAEA;;;;;;;;;;;;CAYC,GACDH,oBAAoBiC,SAAS,CAACI,oBAAoB,GAAG,SACnDC,QAAQ,EACRC,SAAS,EACTC,EAAE;IAEFjB,OAAO,IAAI;IACX,OAAO,IAAI,CAACpB,iBAAiB,CAACkC,oBAAoB,CAACC,UAAUC,WAAWC;AAC1E;AAEA;;;;;;;;;;;;;;;;;;CAkBC,GACDxC,oBAAoBiC,SAAS,CAACQ,kBAAkB,GAAG,SACjDC,kBAAkB,EAClBC,mBAAmB,EACnBC,QAAQ,EACRC,UAAU,EACVvB,MAAM;IAENC,OAAO,IAAI;IACX,OAAO,IAAI,CAACpB,iBAAiB,CAACsC,kBAAkB,CAC9CC,oBACAC,qBACAC,UACAC,YACAvB;AAEJ;AAEA;;;;;CAKC,GACDtB,oBAAoBiC,SAAS,CAACa,KAAK,GAAG,SAAUxB,MAAM;IACpD,IAAI,CAAC,IAAA,6KAAO,EAACA,SAAS;QACpBA,SAAS,IAAItB;IACf;IAEAsB,OAAOf,WAAW,GAAG,IAAI,CAACA,WAAW;IACrCe,OAAOlB,KAAK,GAAG,IAAI,CAACA,KAAK;IACzBkB,OAAOb,IAAI,GAAG,IAAI,CAACA,IAAI;IACvBa,OAAOX,GAAG,GAAG,IAAI,CAACA,GAAG;IAErB,4CAA4C;IAC5CW,OAAOd,YAAY,GAAGF;IACtBgB,OAAOjB,MAAM,GAAGC;IAChBgB,OAAOZ,KAAK,GAAGJ;IACfgB,OAAOV,IAAI,GAAGN;IAEd,IAAI,CAACH,iBAAiB,CAAC2C,KAAK,CAACxB,OAAOnB,iBAAiB;IAErD,OAAOmB;AACT;AAEA;;;;;;CAMC,GACDtB,oBAAoBiC,SAAS,CAACc,MAAM,GAAG,SAAUC,KAAK;IACpD,IAAI,CAAC,IAAA,6KAAO,EAACA,UAAU,CAAC,CAACA,iBAAiBhD,mBAAmB,GAAG;QAC9D,OAAO;IACT;IAEAuB,OAAO,IAAI;IACXA,OAAOyB;IAEP,OACE,IAAI,CAAC5C,KAAK,KAAK4C,MAAM5C,KAAK,IAC1B,IAAI,CAACG,WAAW,KAAKyC,MAAMzC,WAAW,IACtC,IAAI,CAACJ,iBAAiB,CAAC4C,MAAM,CAACC,MAAM7C,iBAAiB;AAEzD;AAEA;;;;;;;;;CASC,GACDH,oBAAoBiC,SAAS,CAACgB,aAAa,GAAG,SAC5CD,KAAK,EACLE,eAAe,EACfC,eAAe;IAEf,IAAI,CAAC,IAAA,6KAAO,EAACH,UAAU,CAAC,CAACA,iBAAiBhD,mBAAmB,GAAG;QAC9D,OAAO;IACT;IAEAuB,OAAO,IAAI;IACXA,OAAOyB;IAEP,OACE,0KAAU,CAACC,aAAa,CACtB,IAAI,CAAC7C,KAAK,EACV4C,MAAM5C,KAAK,EACX8C,iBACAC,oBAEF,0KAAU,CAACF,aAAa,CACtB,IAAI,CAAC1C,WAAW,EAChByC,MAAMzC,WAAW,EACjB2C,iBACAC,oBAEF,IAAI,CAAChD,iBAAiB,CAAC8C,aAAa,CAClCD,MAAM7C,iBAAiB,EACvB+C,iBACAC;AAGN;uCACenD","ignoreList":[0]}},
    {"offset": {"line": 33378, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TexturePacker.js"],"sourcesContent":["import BoundingRectangle from \"./BoundingRectangle.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\n\n/**\n * @typedef {object} TexturePacker.PackableObject\n * Any object, such as an <code>Image</code> with the following properties:\n * @private\n * @property {number} width The width of the image, or other object, usually in pixels\n * @property {number} height The height of the image, or other object, usually in pixels\n */\n\n/**\n * A texture atlas is recursively broken down into regions of space called nodes.\n * Nodes contain either an image reference or child nodes.\n * @private\n * @constructor\n * @param {object} options An options object with the following properties:\n * @param {number} options.x The x-offset of the texture node\n * @param {number} options.y The y-offset of the texture node\n * @param {number} options.width The width of the texture node\n * @param {number} options.height The width of the texture node\n */\nfunction TextureNode({ x, y, width, height }) {\n  /**\n   * @type {BoundingRectangle}\n   */\n  this.rectangle = new BoundingRectangle(x, y, width, height);\n\n  /**\n   * @type {TextureNode|undefined}\n   */\n  this.childNode1 = undefined;\n  /**\n   * @type {TextureNode|undefined}\n   */\n  this.childNode2 = undefined;\n\n  /**\n   * Identifier referencing an image or packed data\n   * @type {number|undefined}\n   */\n  this.index = undefined;\n}\n\n/**\n * Typically used with {@link TextureAtlas} to calculate efficient regions of the larger areas to store images or other data. Typically, all units are specified in pixels.\n * @alias TexturePacker\n * @constructor\n * @private\n * @param {options} options Object with the following properties:\n * @param {number} options.width Width of the atlas, in pixels\n * @param {number} options.height Height of atlas, in pixels\n * @param {number} options.borderPadding Amount of border padding, in pixels\n */\nfunction TexturePacker({ width, height, borderPadding }) {\n  this._width = width;\n  this._height = height;\n\n  this._borderPadding = borderPadding;\n\n  this._root = new TextureNode({\n    x: borderPadding,\n    y: borderPadding,\n    width: width - 2 * borderPadding,\n    height: height - 2 * borderPadding,\n  });\n}\n\n/**\n * Inserts the given object into the next available region based on it's dimensions. Where convenient, it's most efficient to pack items largest to smallest.\n * @private\n * @param {number} index An identifier referencing the image or other stored data\n * @param {TexturePacker.PackableObject} packableObject An object, such as an <code>Image</code>, with <code>width</code> and <code>height</code> properties in pixels.\n * @returns {TextureNode|undefined} The created region, or <code>undefined</code> if there is no region large enough to accommodate the object's dimensions.\n */\nTexturePacker.prototype.pack = function (index, { width, height }) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"image.width\", width, 1);\n  Check.typeOf.number.greaterThanOrEquals(\"image.height\", height, 1);\n  //>>includeEnd('debug');\n\n  const node = this._findNode(this._root, { width, height });\n  if (!defined(node)) {\n    return;\n  }\n\n  node.index = index;\n  return node;\n};\n\n// A recursive function that finds the best place to insert\n// a new image based on existing image 'nodes'.\n// Inspired by: http://blackpawn.com/texts/lightmaps/default.html\nTexturePacker.prototype._findNode = function (node, { width, height }) {\n  if (!defined(node)) {\n    return undefined;\n  }\n\n  // Leaf node\n  if (!defined(node.childNode1) && !defined(node.childNode2)) {\n    if (defined(node.index)) {\n      // Node already contains an image: Skip it.\n      return undefined;\n    }\n\n    const { rectangle } = node;\n\n    const nodeWidth = rectangle.width;\n    const nodeHeight = rectangle.height;\n    const widthDifference = nodeWidth - width;\n    const heightDifference = nodeHeight - height;\n\n    // Node is smaller than the image.\n    if (widthDifference < 0 || heightDifference < 0) {\n      return undefined;\n    }\n\n    // If the node is the same size as the image, return the node\n    if (widthDifference === 0 && heightDifference === 0) {\n      return node;\n    }\n\n    const borderPadding = this._borderPadding;\n\n    // Vertical split (childNode1 = left half, childNode2 = right half).\n    if (widthDifference > heightDifference) {\n      node.childNode1 = new TextureNode({\n        x: rectangle.x,\n        y: rectangle.y,\n        width,\n        height: nodeHeight,\n      });\n\n      // Apply padding only along the vertical \"cut\".\n      const widthDifferencePadded = widthDifference - borderPadding;\n\n      if (widthDifferencePadded > 0) {\n        node.childNode2 = new TextureNode({\n          x: rectangle.x + width + borderPadding,\n          y: rectangle.y,\n          width: widthDifferencePadded,\n          height: nodeHeight,\n        });\n      }\n\n      return this._findNode(node.childNode1, { width, height });\n    }\n\n    // Horizontal split (childNode1 = bottom half, childNode2 = top half).\n    node.childNode1 = new TextureNode({\n      x: rectangle.x,\n      y: rectangle.y,\n      width: nodeWidth,\n      height,\n    });\n\n    // Apply padding only along the horizontal \"cut\".\n    const heightDifferencePadded = heightDifference - borderPadding;\n\n    if (heightDifferencePadded > 0) {\n      node.childNode2 = new TextureNode({\n        x: rectangle.x,\n        y: rectangle.y + height + borderPadding,\n        width: nodeWidth,\n        height: heightDifferencePadded,\n      });\n    }\n\n    return this._findNode(node.childNode1, { width, height });\n  }\n\n  // If not a leaf node\n  return (\n    this._findNode(node.childNode1, { width, height }) ||\n    this._findNode(node.childNode2, { width, height })\n  );\n};\n\nexport default TexturePacker;\n"],"names":["TextureNode","x","y","width","height","rectangle","childNode1","undefined","childNode2","index","TexturePacker","borderPadding","_width","_height","_borderPadding","_root","prototype","pack","typeOf","number","greaterThanOrEquals","node","_findNode","nodeWidth","nodeHeight","widthDifference","heightDifference","widthDifferencePadded","heightDifferencePadded"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 33547, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/oneTimeWarning.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\nconst warnings = {};\n\n/**\n * Logs a one time message to the console.  Use this function instead of\n * <code>console.log</code> directly since this does not log duplicate messages\n * unless it is called from multiple workers.\n *\n * @function oneTimeWarning\n *\n * @param {string} identifier The unique identifier for this warning.\n * @param {string} [message=identifier] The message to log to the console.\n *\n * @example\n * for(let i=0;i<foo.length;++i) {\n *    if (!defined(foo[i].bar)) {\n *       // Something that can be recovered from but may happen a lot\n *       oneTimeWarning('foo.bar undefined', 'foo.bar is undefined. Setting to 0.');\n *       foo[i].bar = 0;\n *       // ...\n *    }\n * }\n *\n * @private\n */\nfunction oneTimeWarning(identifier, message) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(identifier)) {\n    throw new DeveloperError(\"identifier is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(warnings[identifier])) {\n    warnings[identifier] = true;\n    console.warn(message ?? identifier);\n  }\n}\n\noneTimeWarning.geometryOutlines =\n  \"Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.\";\n\noneTimeWarning.geometryZIndex =\n  \"Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored\";\n\noneTimeWarning.geometryHeightReference =\n  \"Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored\";\noneTimeWarning.geometryExtrudedHeightReference =\n  \"Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored\";\nexport default oneTimeWarning;\n"],"names":["warnings","oneTimeWarning","identifier","message","console","warn","geometryOutlines","geometryZIndex","geometryHeightReference","geometryExtrudedHeightReference"],"mappings":";;;;AAAA;AACA;;;AAEA,MAAMA,WAAW,CAAC;AAElB;;;;;;;;;;;;;;;;;;;;;CAqBC,GACD,SAASC,eAAeC,UAAU,EAAEC,OAAO;IACzC,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACD,aAAa;QACxB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,IAAI,CAAC,IAAA,6KAAO,EAACF,QAAQ,CAACE,WAAW,GAAG;QAClCF,QAAQ,CAACE,WAAW,GAAG;QACvBE,QAAQC,IAAI,CAACF,WAAWD;IAC1B;AACF;AAEAD,eAAeK,gBAAgB,GAC7B;AAEFL,eAAeM,cAAc,GAC3B;AAEFN,eAAeO,uBAAuB,GACpC;AACFP,eAAeQ,+BAA+B,GAC5C;uCACaR","ignoreList":[0]}},
    {"offset": {"line": 33597, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/deprecationWarning.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport oneTimeWarning from \"./oneTimeWarning.js\";\n\n/**\n * Logs a deprecation message to the console.  Use this function instead of\n * <code>console.log</code> directly since this does not log duplicate messages\n * unless it is called from multiple workers.\n *\n * @function deprecationWarning\n *\n * @param {string} identifier The unique identifier for this deprecated API.\n * @param {string} message The message to log to the console.\n *\n * @example\n * // Deprecated function or class\n * function Foo() {\n *    deprecationWarning('Foo', 'Foo was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use newFoo instead.');\n *    // ...\n * }\n *\n * // Deprecated function\n * Bar.prototype.func = function() {\n *    deprecationWarning('Bar.func', 'Bar.func() was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use Bar.newFunc() instead.');\n *    // ...\n * };\n *\n * // Deprecated property\n * Object.defineProperties(Bar.prototype, {\n *     prop : {\n *         get : function() {\n *             deprecationWarning('Bar.prop', 'Bar.prop was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use Bar.newProp instead.');\n *             // ...\n *         },\n *         set : function(value) {\n *             deprecationWarning('Bar.prop', 'Bar.prop was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use Bar.newProp instead.');\n *             // ...\n *         }\n *     }\n * });\n *\n * @private\n */\nfunction deprecationWarning(identifier, message) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(identifier) || !defined(message)) {\n    throw new DeveloperError(\"identifier and message are required.\");\n  }\n  //>>includeEnd('debug');\n\n  oneTimeWarning(identifier, message);\n}\nexport default deprecationWarning;\n"],"names":["deprecationWarning","identifier","message"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsCC,GACD,SAASA,mBAAmBC,UAAU,EAAEC,OAAO;IAC7C,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACD,eAAe,CAAC,IAAA,6KAAO,EAACC,UAAU;QAC7C,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,IAAA,oLAAc,EAACD,YAAYC;AAC7B;uCACeF","ignoreList":[0]}},
    {"offset": {"line": 33658, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/writeTextToCanvas.js"],"sourcesContent":["import Color from \"./Color.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\nfunction measureText(context2D, textString, font, stroke, fill) {\n  const metrics = context2D.measureText(textString);\n  const isSpace = !/\\S/.test(textString);\n\n  if (!isSpace) {\n    const fontSize = document.defaultView\n      .getComputedStyle(context2D.canvas)\n      .getPropertyValue(\"font-size\")\n      .replace(\"px\", \"\");\n    const canvas = document.createElement(\"canvas\");\n    const padding = 100;\n    const width = (metrics.width + padding) | 0;\n    const height = 3 * fontSize;\n    const baseline = height / 2;\n    canvas.width = width;\n    canvas.height = height;\n\n    const ctx = canvas.getContext(\"2d\");\n    ctx.font = font;\n    ctx.fillStyle = \"white\";\n    ctx.fillRect(0, 0, canvas.width + 1, canvas.height + 1);\n\n    if (stroke) {\n      ctx.strokeStyle = \"black\";\n      ctx.lineWidth = context2D.lineWidth;\n      ctx.strokeText(textString, padding / 2, baseline);\n    }\n\n    if (fill) {\n      ctx.fillStyle = \"black\";\n      ctx.fillText(textString, padding / 2, baseline);\n    }\n\n    // Context image data has width * height * 4 elements, because\n    // each pixel's R, G, B and A are consecutive values in the array.\n    const pixelData = ctx.getImageData(0, 0, width, height).data;\n    const length = pixelData.length;\n    const width4 = width * 4;\n    let i, j;\n\n    let ascent, descent;\n    // Find the number of rows (from the top) until the first non-white pixel\n    for (i = 0; i < length; ++i) {\n      if (pixelData[i] !== 255) {\n        ascent = (i / width4) | 0;\n        break;\n      }\n    }\n\n    // Find the number of rows (from the bottom) until the first non-white pixel\n    for (i = length - 1; i >= 0; --i) {\n      if (pixelData[i] !== 255) {\n        descent = (i / width4) | 0;\n        break;\n      }\n    }\n\n    let minx = -1;\n    // For each column, for each row, check for first non-white pixel\n    for (i = 0; i < width && minx === -1; ++i) {\n      for (j = 0; j < height; ++j) {\n        const pixelIndex = i * 4 + j * width4;\n        if (\n          pixelData[pixelIndex] !== 255 ||\n          pixelData[pixelIndex + 1] !== 255 ||\n          pixelData[pixelIndex + 2] !== 255 ||\n          pixelData[pixelIndex + 3] !== 255\n        ) {\n          minx = i;\n          break;\n        }\n      }\n    }\n\n    return {\n      width: metrics.width,\n      height: descent - ascent,\n      ascent: baseline - ascent,\n      descent: descent - baseline,\n      minx: minx - padding / 2,\n    };\n  }\n\n  return {\n    width: metrics.width,\n    height: 0,\n    ascent: 0,\n    descent: 0,\n    minx: 0,\n  };\n}\n\nlet imageSmoothingEnabledName;\n\n/**\n * Writes the given text into a new canvas.  The canvas will be sized to fit the text.\n * If text is blank, returns undefined.\n *\n * @param {string} text The text to write.\n * @param {object} [options] Object with the following properties:\n * @param {string} [options.font='10px sans-serif'] The CSS font to use.\n * @param {boolean} [options.fill=true] Whether to fill the text.\n * @param {boolean} [options.stroke=false] Whether to stroke the text.\n * @param {Color} [options.fillColor=Color.WHITE] The fill color.\n * @param {Color} [options.strokeColor=Color.BLACK] The stroke color.\n * @param {number} [options.strokeWidth=1] The stroke width.\n * @param {Color} [options.backgroundColor=Color.TRANSPARENT] The background color of the canvas.\n * @param {number} [options.padding=0] The pixel size of the padding to add around the text.\n * @returns {HTMLCanvasElement|undefined} A new canvas with the given text drawn into it.  The dimensions object\n *                   from measureText will also be added to the returned canvas. If text is\n *                   blank, returns undefined.\n * @function writeTextToCanvas\n */\nfunction writeTextToCanvas(text, options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(text)) {\n    throw new DeveloperError(\"text is required.\");\n  }\n  //>>includeEnd('debug');\n  if (text === \"\") {\n    return undefined;\n  }\n\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const font = options.font ?? \"10px sans-serif\";\n  const stroke = options.stroke ?? false;\n  const fill = options.fill ?? true;\n  const strokeWidth = options.strokeWidth ?? 1;\n  const backgroundColor = options.backgroundColor ?? Color.TRANSPARENT;\n  const padding = options.padding ?? 0;\n  const doublePadding = padding * 2.0;\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 1;\n  canvas.height = 1;\n  canvas.style.font = font;\n  // Since multiple read-back operations are expected for labels, use the willReadFrequently option â€“ See https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently\n  const context2D = canvas.getContext(\"2d\", { willReadFrequently: true });\n\n  if (!defined(imageSmoothingEnabledName)) {\n    if (defined(context2D.imageSmoothingEnabled)) {\n      imageSmoothingEnabledName = \"imageSmoothingEnabled\";\n    } else if (defined(context2D.mozImageSmoothingEnabled)) {\n      imageSmoothingEnabledName = \"mozImageSmoothingEnabled\";\n    } else if (defined(context2D.webkitImageSmoothingEnabled)) {\n      imageSmoothingEnabledName = \"webkitImageSmoothingEnabled\";\n    } else if (defined(context2D.msImageSmoothingEnabled)) {\n      imageSmoothingEnabledName = \"msImageSmoothingEnabled\";\n    }\n  }\n\n  context2D.font = font;\n  context2D.lineJoin = \"round\";\n  context2D.lineWidth = strokeWidth;\n  context2D[imageSmoothingEnabledName] = false;\n\n  // in order for measureText to calculate style, the canvas has to be\n  // (temporarily) added to the DOM.\n  canvas.style.visibility = \"hidden\";\n  document.body.appendChild(canvas);\n\n  const dimensions = measureText(context2D, text, font, stroke, fill);\n  // Set canvas.dimensions to be accessed in LabelCollection\n  canvas.dimensions = dimensions;\n\n  document.body.removeChild(canvas);\n  canvas.style.visibility = \"\";\n\n  // Some characters, such as the letter j, have a non-zero starting position.\n  // This value is used for kerning later, but we need to take it into account\n  // now in order to draw the text completely on the canvas\n  const x = -dimensions.minx;\n\n  // Expand the width to include the starting position.\n  const width = Math.ceil(dimensions.width) + x + doublePadding;\n\n  // While the height of the letter is correct, we need to adjust\n  // where we start drawing it so that letters like j and y properly dip\n  // below the line.\n\n  const height = dimensions.height + doublePadding;\n  const baseline = height - dimensions.ascent + padding;\n  const y = height - baseline + doublePadding;\n\n  canvas.width = width;\n  canvas.height = height;\n\n  // Properties must be explicitly set again after changing width and height\n  context2D.font = font;\n  context2D.lineJoin = \"round\";\n  context2D.lineWidth = strokeWidth;\n  context2D[imageSmoothingEnabledName] = false;\n\n  // Draw background\n  if (backgroundColor !== Color.TRANSPARENT) {\n    context2D.fillStyle = backgroundColor.toCssColorString();\n    context2D.fillRect(0, 0, canvas.width, canvas.height);\n  }\n\n  if (stroke) {\n    const strokeColor = options.strokeColor ?? Color.BLACK;\n    context2D.strokeStyle = strokeColor.toCssColorString();\n    context2D.strokeText(text, x + padding, y);\n  }\n\n  if (fill) {\n    const fillColor = options.fillColor ?? Color.WHITE;\n    context2D.fillStyle = fillColor.toCssColorString();\n    context2D.fillText(text, x + padding, y);\n  }\n\n  return canvas;\n}\nexport default writeTextToCanvas;\n"],"names":["measureText","context2D","textString","font","stroke","fill","metrics","isSpace","test","fontSize","document","defaultView","getComputedStyle","canvas","getPropertyValue","replace","createElement","padding","width","height","baseline","ctx","getContext","fillStyle","fillRect","strokeStyle","lineWidth","strokeText","fillText","pixelData","getImageData","data","length","width4","i","j","ascent","descent","minx","pixelIndex","imageSmoothingEnabledName","writeTextToCanvas","text","options","undefined","EMPTY_OBJECT","strokeWidth","backgroundColor","TRANSPARENT","doublePadding","style","willReadFrequently","imageSmoothingEnabled","mozImageSmoothingEnabled","webkitImageSmoothingEnabled","msImageSmoothingEnabled","lineJoin","visibility","body","appendChild","dimensions","removeChild","x","Math","ceil","y","toCssColorString","strokeColor","BLACK","fillColor","WHITE"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 33852, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TimeInterval.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport JulianDate from \"./JulianDate.js\";\n\n/**\n * An interval defined by a start and a stop time; optionally including those times as part of the interval.\n * Arbitrary data can optionally be associated with each instance for used with {@link TimeIntervalCollection}.\n *\n * @alias TimeInterval\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {JulianDate} [options.start=new JulianDate()] The start time of the interval.\n * @param {JulianDate} [options.stop=new JulianDate()] The stop time of the interval.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.\n * @param {object} [options.data] Arbitrary data associated with this interval.\n *\n * @example\n * // Create an instance that spans August 1st, 1980 and is associated\n * // with a Cartesian position.\n * const timeInterval = new Cesium.TimeInterval({\n *     start : Cesium.JulianDate.fromIso8601('1980-08-01T00:00:00Z'),\n *     stop : Cesium.JulianDate.fromIso8601('1980-08-02T00:00:00Z'),\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : Cesium.Cartesian3.fromDegrees(39.921037, -75.170082)\n * });\n *\n * @example\n * // Create two instances from ISO 8601 intervals with associated numeric data\n * // then compute their intersection, summing the data they contain.\n * const left = Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2000/2010',\n *     data : 2\n * });\n *\n * const right = Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '1995/2005',\n *     data : 3\n * });\n *\n * //The result of the below intersection will be an interval equivalent to\n * //const intersection = Cesium.TimeInterval.fromIso8601({\n * //  iso8601 : '2000/2005',\n * //  data : 5\n * //});\n * const intersection = new Cesium.TimeInterval();\n * Cesium.TimeInterval.intersect(left, right, intersection, function(leftData, rightData) {\n *     return leftData + rightData;\n * });\n *\n * @example\n * // Check if an interval contains a specific time.\n * const dateToCheck = Cesium.JulianDate.fromIso8601('1982-09-08T11:30:00Z');\n * const containsDate = Cesium.TimeInterval.contains(timeInterval, dateToCheck);\n */\nfunction TimeInterval(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  /**\n   * Gets or sets the start time of this interval.\n   * @type {JulianDate}\n   */\n  this.start = defined(options.start)\n    ? JulianDate.clone(options.start)\n    : new JulianDate();\n\n  /**\n   * Gets or sets the stop time of this interval.\n   * @type {JulianDate}\n   */\n  this.stop = defined(options.stop)\n    ? JulianDate.clone(options.stop)\n    : new JulianDate();\n\n  /**\n   * Gets or sets the data associated with this interval.\n   * @type {*}\n   */\n  this.data = options.data;\n\n  /**\n   * Gets or sets whether or not the start time is included in this interval.\n   * @type {boolean}\n   * @default true\n   */\n  this.isStartIncluded = options.isStartIncluded ?? true;\n\n  /**\n   * Gets or sets whether or not the stop time is included in this interval.\n   * @type {boolean}\n   * @default true\n   */\n  this.isStopIncluded = options.isStopIncluded ?? true;\n}\n\nObject.defineProperties(TimeInterval.prototype, {\n  /**\n   * Gets whether or not this interval is empty.\n   * @memberof TimeInterval.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isEmpty: {\n    get: function () {\n      const stopComparedToStart = JulianDate.compare(this.stop, this.start);\n      return (\n        stopComparedToStart < 0 ||\n        (stopComparedToStart === 0 &&\n          (!this.isStartIncluded || !this.isStopIncluded))\n      );\n    },\n  },\n});\n\nconst scratchInterval = {\n  start: undefined,\n  stop: undefined,\n  isStartIncluded: undefined,\n  isStopIncluded: undefined,\n  data: undefined,\n};\n\n/**\n * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} interval.\n *\n * @throws DeveloperError if options.iso8601 does not match proper formatting.\n *\n * @param {object} options Object with the following properties:\n * @param {string} options.iso8601 An ISO 8601 interval.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.\n * @param {object} [options.data] Arbitrary data associated with this interval.\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\nTimeInterval.fromIso8601 = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.string(\"options.iso8601\", options.iso8601);\n  //>>includeEnd('debug');\n\n  const dates = options.iso8601.split(\"/\");\n  if (dates.length !== 2) {\n    throw new DeveloperError(\n      \"options.iso8601 is an invalid ISO 8601 interval.\",\n    );\n  }\n  const start = JulianDate.fromIso8601(dates[0]);\n  const stop = JulianDate.fromIso8601(dates[1]);\n  const isStartIncluded = options.isStartIncluded ?? true;\n  const isStopIncluded = options.isStopIncluded ?? true;\n  const data = options.data;\n\n  if (!defined(result)) {\n    scratchInterval.start = start;\n    scratchInterval.stop = stop;\n    scratchInterval.isStartIncluded = isStartIncluded;\n    scratchInterval.isStopIncluded = isStopIncluded;\n    scratchInterval.data = data;\n    return new TimeInterval(scratchInterval);\n  }\n\n  result.start = start;\n  result.stop = stop;\n  result.isStartIncluded = isStartIncluded;\n  result.isStopIncluded = isStopIncluded;\n  result.data = data;\n  return result;\n};\n\n/**\n * Creates an ISO8601 representation of the provided interval.\n *\n * @param {TimeInterval} timeInterval The interval to be converted.\n * @param {number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.\n * @returns {string} The ISO8601 representation of the provided interval.\n */\nTimeInterval.toIso8601 = function (timeInterval, precision) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"timeInterval\", timeInterval);\n  //>>includeEnd('debug');\n\n  return `${JulianDate.toIso8601(\n    timeInterval.start,\n    precision,\n  )}/${JulianDate.toIso8601(timeInterval.stop, precision)}`;\n};\n\n/**\n * Duplicates the provided instance.\n *\n * @param {TimeInterval} [timeInterval] The instance to clone.\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\nTimeInterval.clone = function (timeInterval, result) {\n  if (!defined(timeInterval)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new TimeInterval(timeInterval);\n  }\n  result.start = timeInterval.start;\n  result.stop = timeInterval.stop;\n  result.isStartIncluded = timeInterval.isStartIncluded;\n  result.isStopIncluded = timeInterval.isStopIncluded;\n  result.data = timeInterval.data;\n  return result;\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TimeInterval} [left] The first instance.\n * @param {TimeInterval} [right] The second instance.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nTimeInterval.equals = function (left, right, dataComparer) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      ((left.isEmpty && right.isEmpty) ||\n        (left.isStartIncluded === right.isStartIncluded &&\n          left.isStopIncluded === right.isStopIncluded &&\n          JulianDate.equals(left.start, right.start) &&\n          JulianDate.equals(left.stop, right.stop) &&\n          (left.data === right.data ||\n            (defined(dataComparer) && dataComparer(left.data, right.data))))))\n  );\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {TimeInterval} [left] The first instance.\n * @param {TimeInterval} [right] The second instance.\n * @param {number} [epsilon=0] The maximum number of seconds that should separate the two instances.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nTimeInterval.equalsEpsilon = function (left, right, epsilon, dataComparer) {\n  epsilon = epsilon ?? 0;\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      ((left.isEmpty && right.isEmpty) ||\n        (left.isStartIncluded === right.isStartIncluded &&\n          left.isStopIncluded === right.isStopIncluded &&\n          JulianDate.equalsEpsilon(left.start, right.start, epsilon) &&\n          JulianDate.equalsEpsilon(left.stop, right.stop, epsilon) &&\n          (left.data === right.data ||\n            (defined(dataComparer) && dataComparer(left.data, right.data))))))\n  );\n};\n\n/**\n * Computes the intersection of two intervals, optionally merging their data.\n *\n * @param {TimeInterval} left The first interval.\n * @param {TimeInterval} [right] The second interval.\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @param {TimeInterval.MergeCallback} [mergeCallback] A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.\n * @returns {TimeInterval} The modified result parameter.\n */\nTimeInterval.intersect = function (left, right, result, mergeCallback) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  //>>includeEnd('debug');\n\n  if (!defined(right)) {\n    return TimeInterval.clone(TimeInterval.EMPTY, result);\n  }\n\n  const leftStart = left.start;\n  const leftStop = left.stop;\n\n  const rightStart = right.start;\n  const rightStop = right.stop;\n\n  const intersectsStartRight =\n    JulianDate.greaterThanOrEquals(rightStart, leftStart) &&\n    JulianDate.greaterThanOrEquals(leftStop, rightStart);\n  const intersectsStartLeft =\n    !intersectsStartRight &&\n    JulianDate.lessThanOrEquals(rightStart, leftStart) &&\n    JulianDate.lessThanOrEquals(leftStart, rightStop);\n\n  if (!intersectsStartRight && !intersectsStartLeft) {\n    return TimeInterval.clone(TimeInterval.EMPTY, result);\n  }\n\n  const leftIsStartIncluded = left.isStartIncluded;\n  const leftIsStopIncluded = left.isStopIncluded;\n  const rightIsStartIncluded = right.isStartIncluded;\n  const rightIsStopIncluded = right.isStopIncluded;\n  const leftLessThanRight = JulianDate.lessThan(leftStop, rightStop);\n\n  if (!defined(result)) {\n    result = new TimeInterval();\n  }\n\n  result.start = intersectsStartRight ? rightStart : leftStart;\n  result.isStartIncluded =\n    (leftIsStartIncluded && rightIsStartIncluded) ||\n    (!JulianDate.equals(rightStart, leftStart) &&\n      ((intersectsStartRight && rightIsStartIncluded) ||\n        (intersectsStartLeft && leftIsStartIncluded)));\n  result.stop = leftLessThanRight ? leftStop : rightStop;\n  result.isStopIncluded = leftLessThanRight\n    ? leftIsStopIncluded\n    : (leftIsStopIncluded && rightIsStopIncluded) ||\n      (!JulianDate.equals(rightStop, leftStop) && rightIsStopIncluded);\n  result.data = defined(mergeCallback)\n    ? mergeCallback(left.data, right.data)\n    : left.data;\n  return result;\n};\n\n/**\n * Checks if the specified date is inside the provided interval.\n *\n * @param {TimeInterval} timeInterval The interval.\n * @param {JulianDate} julianDate The date to check.\n * @returns {boolean} <code>true</code> if the interval contains the specified date, <code>false</code> otherwise.\n */\nTimeInterval.contains = function (timeInterval, julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"timeInterval\", timeInterval);\n  Check.typeOf.object(\"julianDate\", julianDate);\n  //>>includeEnd('debug');\n\n  if (timeInterval.isEmpty) {\n    return false;\n  }\n\n  const startComparedToDate = JulianDate.compare(\n    timeInterval.start,\n    julianDate,\n  );\n  if (startComparedToDate === 0) {\n    return timeInterval.isStartIncluded;\n  }\n\n  const dateComparedToStop = JulianDate.compare(julianDate, timeInterval.stop);\n  if (dateComparedToStop === 0) {\n    return timeInterval.isStopIncluded;\n  }\n\n  return startComparedToDate < 0 && dateComparedToStop < 0;\n};\n\n/**\n * Duplicates this instance.\n *\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\nTimeInterval.prototype.clone = function (result) {\n  return TimeInterval.clone(this, result);\n};\n\n/**\n * Compares this instance against the provided instance componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TimeInterval} [right] The right hand side interval.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nTimeInterval.prototype.equals = function (right, dataComparer) {\n  return TimeInterval.equals(this, right, dataComparer);\n};\n\n/**\n * Compares this instance against the provided instance componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {TimeInterval} [right] The right hand side interval.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nTimeInterval.prototype.equalsEpsilon = function (right, epsilon, dataComparer) {\n  return TimeInterval.equalsEpsilon(this, right, epsilon, dataComparer);\n};\n\n/**\n * Creates a string representing this TimeInterval in ISO8601 format.\n *\n * @returns {string} A string representing this TimeInterval in ISO8601 format.\n */\nTimeInterval.prototype.toString = function () {\n  return TimeInterval.toIso8601(this);\n};\n\n/**\n * An immutable empty interval.\n *\n * @type {TimeInterval}\n * @constant\n */\nTimeInterval.EMPTY = Object.freeze(\n  new TimeInterval({\n    start: new JulianDate(),\n    stop: new JulianDate(),\n    isStartIncluded: false,\n    isStopIncluded: false,\n  }),\n);\n\n/**\n * Function interface for merging interval data.\n * @callback TimeInterval.MergeCallback\n *\n * @param {*} leftData The first data instance.\n * @param {*} rightData The second data instance.\n * @returns {*} The result of merging the two data instances.\n */\n\n/**\n * Function interface for comparing interval data.\n * @callback TimeInterval.DataComparer\n * @param {*} leftData The first data instance.\n * @param {*} rightData The second data instance.\n * @returns {boolean} <code>true</code> if the provided instances are equal, <code>false</code> otherwise.\n */\nexport default TimeInterval;\n"],"names":["TimeInterval","options","EMPTY_OBJECT","start","clone","stop","data","isStartIncluded","isStopIncluded","Object","defineProperties","prototype","isEmpty","get","stopComparedToStart","compare","scratchInterval","undefined","fromIso8601","result","typeOf","object","string","iso8601","dates","split","length","toIso8601","timeInterval","precision","equals","left","right","dataComparer","equalsEpsilon","epsilon","intersect","mergeCallback","EMPTY","leftStart","leftStop","rightStart","rightStop","intersectsStartRight","greaterThanOrEquals","intersectsStartLeft","lessThanOrEquals","leftIsStartIncluded","leftIsStopIncluded","rightIsStartIncluded","rightIsStopIncluded","leftLessThanRight","lessThan","contains","julianDate","startComparedToDate","dateComparedToStop","toString","freeze"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 34177, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Iso8601.js"],"sourcesContent":["import JulianDate from \"./JulianDate.js\";\nimport TimeInterval from \"./TimeInterval.js\";\n\nconst MINIMUM_VALUE = Object.freeze(\n  JulianDate.fromIso8601(\"0000-01-01T00:00:00Z\"),\n);\nconst MAXIMUM_VALUE = Object.freeze(\n  JulianDate.fromIso8601(\"9999-12-31T24:00:00Z\"),\n);\nconst MAXIMUM_INTERVAL = Object.freeze(\n  new TimeInterval({\n    start: MINIMUM_VALUE,\n    stop: MAXIMUM_VALUE,\n  }),\n);\n\n/**\n * Constants related to ISO8601 support.\n *\n * @namespace\n *\n * @see {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601 on Wikipedia}\n * @see JulianDate\n * @see TimeInterval\n */\nconst Iso8601 = {\n  /**\n   * A {@link JulianDate} representing the earliest time representable by an ISO8601 date.\n   * This is equivalent to the date string '0000-01-01T00:00:00Z'\n   *\n   * @type {JulianDate}\n   * @constant\n   */\n  MINIMUM_VALUE: MINIMUM_VALUE,\n\n  /**\n   * A {@link JulianDate} representing the latest time representable by an ISO8601 date.\n   * This is equivalent to the date string '9999-12-31T24:00:00Z'\n   *\n   * @type {JulianDate}\n   * @constant\n   */\n  MAXIMUM_VALUE: MAXIMUM_VALUE,\n\n  /**\n   * A {@link TimeInterval} representing the largest interval representable by an ISO8601 interval.\n   * This is equivalent to the interval string '0000-01-01T00:00:00Z/9999-12-31T24:00:00Z'\n   *\n   * @type {TimeInterval}\n   * @constant\n   */\n  MAXIMUM_INTERVAL: MAXIMUM_INTERVAL,\n};\nexport default Iso8601;\n"],"names":["MINIMUM_VALUE","Object","freeze","fromIso8601","MAXIMUM_VALUE","MAXIMUM_INTERVAL","start","stop","Iso8601"],"mappings":";;;;AAAA;AACA;;;AAEA,MAAMA,gBAAgBC,OAAOC,MAAM,CACjC,gLAAU,CAACC,WAAW,CAAC;AAEzB,MAAMC,gBAAgBH,OAAOC,MAAM,CACjC,gLAAU,CAACC,WAAW,CAAC;AAEzB,MAAME,mBAAmBJ,OAAOC,MAAM,CACpC,IAAI,kLAAY,CAAC;IACfI,OAAON;IACPO,MAAMH;AACR;AAGF;;;;;;;;CAQC,GACD,MAAMI,UAAU;IACd;;;;;;GAMC,GACDR,eAAeA;IAEf;;;;;;GAMC,GACDI,eAAeA;IAEf;;;;;;GAMC,GACDC,kBAAkBA;AACpB;uCACeG","ignoreList":[0]}},
    {"offset": {"line": 34227, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TrackingReferenceFrame.js"],"sourcesContent":["/**\n * Constants for identifying well-known tracking reference frames.\n *\n * @enum {number}\n */\nconst TrackingReferenceFrame = {\n  /**\n   * Auto-detect algorithm. The reference frame used to track the Entity will\n   * be automatically selected based on its trajectory: near-surface slow moving\n   * objects will be tracked in the entity's local east-north-up reference\n   * frame, while faster objects like satellites will use VVLH (Vehicle Velocity,\n   * Local Horizontal).\n   *\n   * @type {number}\n   * @constant\n   */\n  AUTODETECT: 0,\n\n  /**\n   * The entity's local East-North-Up reference frame.\n   *\n   * @type {number}\n   * @constant\n   */\n  ENU: 1,\n\n  /**\n   * The entity's inertial reference frame. If entity has no defined orientation\n   * property, it falls back to auto-detect algorithm.\n   *\n   * @type {number}\n   * @constant\n   */\n  INERTIAL: 2,\n\n  /**\n   * The entity's inertial reference frame with orientation fixed to its\n   * {@link VelocityOrientationProperty}, ignoring its own orientation.\n   *\n   * @type {number}\n   * @constant\n   */\n  VELOCITY: 3,\n};\nexport default Object.freeze(TrackingReferenceFrame);\n"],"names":["TrackingReferenceFrame","AUTODETECT","ENU","INERTIAL","VELOCITY","Object","freeze"],"mappings":";;;;AAAA;;;;CAIC,GACD,MAAMA,yBAAyB;IAC7B;;;;;;;;;GASC,GACDC,YAAY;IAEZ;;;;;GAKC,GACDC,KAAK;IAEL;;;;;;GAMC,GACDC,UAAU;IAEV;;;;;;GAMC,GACDC,UAAU;AACZ;uCACeC,OAAOC,MAAM,CAACN","ignoreList":[0]}},
    {"offset": {"line": 34272, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/ReferenceFrame.js"],"sourcesContent":["/**\n * Constants for identifying well-known reference frames.\n *\n * @enum {number}\n */\nconst ReferenceFrame = {\n  /**\n   * The fixed frame.\n   *\n   * @type {number}\n   * @constant\n   */\n  FIXED: 0,\n\n  /**\n   * The inertial frame.\n   *\n   * @type {number}\n   * @constant\n   */\n  INERTIAL: 1,\n};\nexport default Object.freeze(ReferenceFrame);\n"],"names":["ReferenceFrame","FIXED","INERTIAL","Object","freeze"],"mappings":";;;;AAAA;;;;CAIC,GACD,MAAMA,iBAAiB;IACrB;;;;;GAKC,GACDC,OAAO;IAEP;;;;;GAKC,GACDC,UAAU;AACZ;uCACeC,OAAOC,MAAM,CAACJ","ignoreList":[0]}},
    {"offset": {"line": 34299, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TranslationRotationScale.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport Quaternion from \"./Quaternion.js\";\n\nconst defaultScale = new Cartesian3(1.0, 1.0, 1.0);\nconst defaultTranslation = Cartesian3.ZERO;\nconst defaultRotation = Quaternion.IDENTITY;\n\n/**\n * An affine transformation defined by a translation, rotation, and scale.\n * @alias TranslationRotationScale\n * @constructor\n *\n * @param {Cartesian3} [translation=Cartesian3.ZERO] A {@link Cartesian3} specifying the (x, y, z) translation to apply to the node.\n * @param {Quaternion} [rotation=Quaternion.IDENTITY] A {@link Quaternion} specifying the (x, y, z, w) rotation to apply to the node.\n * @param {Cartesian3} [scale=new Cartesian3(1.0, 1.0, 1.0)] A {@link Cartesian3} specifying the (x, y, z) scaling to apply to the node.\n */\nfunction TranslationRotationScale(translation, rotation, scale) {\n  /**\n   * Gets or sets the (x, y, z) translation to apply to the node.\n   * @type {Cartesian3}\n   * @default Cartesian3.ZERO\n   */\n  this.translation = Cartesian3.clone(translation ?? defaultTranslation);\n\n  /**\n   * Gets or sets the (x, y, z, w) rotation to apply to the node.\n   * @type {Quaternion}\n   * @default Quaternion.IDENTITY\n   */\n  this.rotation = Quaternion.clone(rotation ?? defaultRotation);\n\n  /**\n   * Gets or sets the (x, y, z) scaling to apply to the node.\n   * @type {Cartesian3}\n   * @default new Cartesian3(1.0, 1.0, 1.0)\n   */\n  this.scale = Cartesian3.clone(scale ?? defaultScale);\n}\n\n/**\n * Compares this instance against the provided instance and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TranslationRotationScale} [right] The right hand side TranslationRotationScale.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nTranslationRotationScale.prototype.equals = function (right) {\n  return (\n    this === right ||\n    (defined(right) &&\n      Cartesian3.equals(this.translation, right.translation) &&\n      Quaternion.equals(this.rotation, right.rotation) &&\n      Cartesian3.equals(this.scale, right.scale))\n  );\n};\nexport default TranslationRotationScale;\n"],"names":["defaultScale","defaultTranslation","ZERO","defaultRotation","IDENTITY","TranslationRotationScale","translation","rotation","scale","clone","prototype","equals","right"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,MAAMA,eAAe,IAAI,gLAAU,CAAC,KAAK,KAAK;AAC9C,MAAMC,qBAAqB,gLAAU,CAACC,IAAI;AAC1C,MAAMC,kBAAkB,gLAAU,CAACC,QAAQ;AAE3C;;;;;;;;CAQC,GACD,SAASC,yBAAyBC,WAAW,EAAEC,QAAQ,EAAEC,KAAK;IAC5D;;;;GAIC,GACD,IAAI,CAACF,WAAW,GAAG,gLAAU,CAACG,KAAK,CAACH,eAAeL;IAEnD;;;;GAIC,GACD,IAAI,CAACM,QAAQ,GAAG,gLAAU,CAACE,KAAK,CAACF,YAAYJ;IAE7C;;;;GAIC,GACD,IAAI,CAACK,KAAK,GAAG,gLAAU,CAACC,KAAK,CAACD,SAASR;AACzC;AAEA;;;;;;CAMC,GACDK,yBAAyBK,SAAS,CAACC,MAAM,GAAG,SAAUC,KAAK;IACzD,OACE,IAAI,KAAKA,SACR,IAAA,6KAAO,EAACA,UACP,gLAAU,CAACD,MAAM,CAAC,IAAI,CAACL,WAAW,EAAEM,MAAMN,WAAW,KACrD,gLAAU,CAACK,MAAM,CAAC,IAAI,CAACJ,QAAQ,EAAEK,MAAML,QAAQ,KAC/C,gLAAU,CAACI,MAAM,CAAC,IAAI,CAACH,KAAK,EAAEI,MAAMJ,KAAK;AAE/C;uCACeH","ignoreList":[0]}},
    {"offset": {"line": 34351, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PolygonHierarchy.js"],"sourcesContent":["import defined from \"./defined.js\";\n\n/**\n * An hierarchy of linear rings which define a polygon and its holes.\n * The holes themselves may also have holes which nest inner polygons.\n * @alias PolygonHierarchy\n * @constructor\n *\n * @param {Cartesian3[]} [positions] A linear ring defining the outer boundary of the polygon or hole.\n * @param {PolygonHierarchy[]} [holes] An array of polygon hierarchies defining holes in the polygon.\n */\nfunction PolygonHierarchy(positions, holes) {\n  /**\n   * A linear ring defining the outer boundary of the polygon or hole.\n   * @type {Cartesian3[]}\n   */\n  this.positions = defined(positions) ? positions : [];\n\n  /**\n   * An array of polygon hierarchies defining holes in the polygon.\n   * @type {PolygonHierarchy[]}\n   */\n  this.holes = defined(holes) ? holes : [];\n}\nexport default PolygonHierarchy;\n"],"names":["PolygonHierarchy","positions","holes"],"mappings":";;;;AAAA;;AAEA;;;;;;;;CAQC,GACD,SAASA,iBAAiBC,SAAS,EAAEC,KAAK;IACxC;;;GAGC,GACD,IAAI,CAACD,SAAS,GAAG,IAAA,6KAAO,EAACA,aAAaA,YAAY,EAAE;IAEpD;;;GAGC,GACD,IAAI,CAACC,KAAK,GAAG,IAAA,6KAAO,EAACA,SAASA,QAAQ,EAAE;AAC1C;uCACeF","ignoreList":[0]}},
    {"offset": {"line": 34380, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/BoxOutlineGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nconst diffScratch = new Cartesian3();\n\n/**\n * A description of the outline of a cube centered at the origin.\n *\n * @alias BoxOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.minimum The minimum x, y, and z coordinates of the box.\n * @param {Cartesian3} options.maximum The maximum x, y, and z coordinates of the box.\n *\n * @see BoxOutlineGeometry.fromDimensions\n * @see BoxOutlineGeometry.createGeometry\n * @see Packable\n *\n * @example\n * const box = new Cesium.BoxOutlineGeometry({\n *   maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0),\n *   minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0)\n * });\n * const geometry = Cesium.BoxOutlineGeometry.createGeometry(box);\n */\nfunction BoxOutlineGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const min = options.minimum;\n  const max = options.maximum;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._min = Cartesian3.clone(min);\n  this._max = Cartesian3.clone(max);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createBoxOutlineGeometry\";\n}\n\n/**\n * Creates an outline of a cube centered at the origin given its dimensions.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.dimensions The width, depth, and height of the box stored in the x, y, and z coordinates of the <code>Cartesian3</code>, respectively.\n * @returns {BoxOutlineGeometry}\n *\n * @exception {DeveloperError} All dimensions components must be greater than or equal to zero.\n *\n *\n * @example\n * const box = Cesium.BoxOutlineGeometry.fromDimensions({\n *   dimensions : new Cesium.Cartesian3(500000.0, 500000.0, 500000.0)\n * });\n * const geometry = Cesium.BoxOutlineGeometry.createGeometry(box);\n *\n * @see BoxOutlineGeometry.createGeometry\n */\nBoxOutlineGeometry.fromDimensions = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const dimensions = options.dimensions;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"dimensions\", dimensions);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.x\", dimensions.x, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.y\", dimensions.y, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.z\", dimensions.z, 0);\n  //>>includeEnd('debug');\n\n  const corner = Cartesian3.multiplyByScalar(dimensions, 0.5, new Cartesian3());\n\n  return new BoxOutlineGeometry({\n    minimum: Cartesian3.negate(corner, new Cartesian3()),\n    maximum: corner,\n    offsetAttribute: options.offsetAttribute,\n  });\n};\n\n/**\n * Creates an outline of a cube from the dimensions of an AxisAlignedBoundingBox.\n *\n * @param {AxisAlignedBoundingBox} boundingBox A description of the AxisAlignedBoundingBox.\n * @returns {BoxOutlineGeometry}\n *\n *\n *\n * @example\n * const aabb = Cesium.AxisAlignedBoundingBox.fromPoints(Cesium.Cartesian3.fromDegreesArray([\n *      -72.0, 40.0,\n *      -70.0, 35.0,\n *      -75.0, 30.0,\n *      -70.0, 30.0,\n *      -68.0, 40.0\n * ]));\n * const box = Cesium.BoxOutlineGeometry.fromAxisAlignedBoundingBox(aabb);\n *\n *  @see BoxOutlineGeometry.createGeometry\n */\nBoxOutlineGeometry.fromAxisAlignedBoundingBox = function (boundingBox) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundindBox\", boundingBox);\n  //>>includeEnd('debug');\n\n  return new BoxOutlineGeometry({\n    minimum: boundingBox.minimum,\n    maximum: boundingBox.maximum,\n  });\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nBoxOutlineGeometry.packedLength = 2 * Cartesian3.packedLength + 1;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoxOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nBoxOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  Cartesian3.pack(value._min, array, startingIndex);\n  Cartesian3.pack(value._max, array, startingIndex + Cartesian3.packedLength);\n  array[startingIndex + Cartesian3.packedLength * 2] =\n    value._offsetAttribute ?? -1;\n\n  return array;\n};\n\nconst scratchMin = new Cartesian3();\nconst scratchMax = new Cartesian3();\nconst scratchOptions = {\n  minimum: scratchMin,\n  maximum: scratchMax,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoxOutlineGeometry} [result] The object into which to store the result.\n * @returns {BoxOutlineGeometry} The modified result parameter or a new BoxOutlineGeometry instance if one was not provided.\n */\nBoxOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const min = Cartesian3.unpack(array, startingIndex, scratchMin);\n  const max = Cartesian3.unpack(\n    array,\n    startingIndex + Cartesian3.packedLength,\n    scratchMax,\n  );\n  const offsetAttribute = array[startingIndex + Cartesian3.packedLength * 2];\n\n  if (!defined(result)) {\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new BoxOutlineGeometry(scratchOptions);\n  }\n\n  result._min = Cartesian3.clone(min, result._min);\n  result._max = Cartesian3.clone(max, result._max);\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of a box, including its vertices, indices, and a bounding sphere.\n *\n * @param {BoxOutlineGeometry} boxGeometry A description of the box outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nBoxOutlineGeometry.createGeometry = function (boxGeometry) {\n  const min = boxGeometry._min;\n  const max = boxGeometry._max;\n\n  if (Cartesian3.equals(min, max)) {\n    return;\n  }\n\n  const attributes = new GeometryAttributes();\n  const indices = new Uint16Array(12 * 2);\n  const positions = new Float64Array(8 * 3);\n\n  positions[0] = min.x;\n  positions[1] = min.y;\n  positions[2] = min.z;\n  positions[3] = max.x;\n  positions[4] = min.y;\n  positions[5] = min.z;\n  positions[6] = max.x;\n  positions[7] = max.y;\n  positions[8] = min.z;\n  positions[9] = min.x;\n  positions[10] = max.y;\n  positions[11] = min.z;\n\n  positions[12] = min.x;\n  positions[13] = min.y;\n  positions[14] = max.z;\n  positions[15] = max.x;\n  positions[16] = min.y;\n  positions[17] = max.z;\n  positions[18] = max.x;\n  positions[19] = max.y;\n  positions[20] = max.z;\n  positions[21] = min.x;\n  positions[22] = max.y;\n  positions[23] = max.z;\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n\n  // top\n  indices[0] = 4;\n  indices[1] = 5;\n  indices[2] = 5;\n  indices[3] = 6;\n  indices[4] = 6;\n  indices[5] = 7;\n  indices[6] = 7;\n  indices[7] = 4;\n\n  // bottom\n  indices[8] = 0;\n  indices[9] = 1;\n  indices[10] = 1;\n  indices[11] = 2;\n  indices[12] = 2;\n  indices[13] = 3;\n  indices[14] = 3;\n  indices[15] = 0;\n\n  // left\n  indices[16] = 0;\n  indices[17] = 4;\n  indices[18] = 1;\n  indices[19] = 5;\n\n  //right\n  indices[20] = 2;\n  indices[21] = 6;\n  indices[22] = 3;\n  indices[23] = 7;\n\n  const diff = Cartesian3.subtract(max, min, diffScratch);\n  const radius = Cartesian3.magnitude(diff) * 0.5;\n\n  if (defined(boxGeometry._offsetAttribute)) {\n    const length = positions.length;\n    const offsetValue =\n      boxGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n    const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: new BoundingSphere(Cartesian3.ZERO, radius),\n    offsetAttribute: boxGeometry._offsetAttribute,\n  });\n};\nexport default BoxOutlineGeometry;\n"],"names":["diffScratch","BoxOutlineGeometry","options","EMPTY_OBJECT","min","minimum","max","maximum","typeOf","object","offsetAttribute","TOP","_min","clone","_max","_offsetAttribute","_workerName","fromDimensions","dimensions","number","greaterThanOrEquals","x","y","z","corner","multiplyByScalar","negate","fromAxisAlignedBoundingBox","boundingBox","packedLength","pack","value","array","startingIndex","defined","scratchMin","scratchMax","scratchOptions","undefined","unpack","result","createGeometry","boxGeometry","equals","attributes","indices","Uint16Array","positions","Float64Array","position","componentDatatype","DOUBLE","componentsPerAttribute","values","diff","subtract","radius","magnitude","length","offsetValue","NONE","applyOffset","Uint8Array","fill","UNSIGNED_BYTE","primitiveType","LINES","boundingSphere","ZERO"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 34656, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"],"sourcesContent":["import ComponentDatatype from \"./ComponentDatatype.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Value and type information for per-instance geometry attribute that determines if the geometry instance has a distance display condition.\n *\n * @alias DistanceDisplayConditionGeometryInstanceAttribute\n * @constructor\n *\n * @param {number} [near=0.0] The near distance.\n * @param {number} [far=Number.MAX_VALUE] The far distance.\n *\n * @exception {DeveloperError} far must be greater than near.\n *\n * @example\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.BoxGeometry({\n *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),\n *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   id : 'box',\n *   attributes : {\n *     distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(100.0, 10000.0)\n *   }\n * });\n *\n * @see GeometryInstance\n * @see GeometryInstanceAttribute\n */\nfunction DistanceDisplayConditionGeometryInstanceAttribute(near, far) {\n  near = near ?? 0.0;\n  far = far ?? Number.MAX_VALUE;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (far <= near) {\n    throw new DeveloperError(\n      \"far distance must be greater than near distance.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The values for the attributes stored in a typed array.\n   *\n   * @type {Float32Array}\n   *\n   * @default [0.0, 0.0, Number.MAX_VALUE]\n   */\n  this.value = new Float32Array([near, far]);\n}\n\nObject.defineProperties(\n  DistanceDisplayConditionGeometryInstanceAttribute.prototype,\n  {\n    /**\n     * The datatype of each component in the attribute, e.g., individual elements in\n     * {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.\n     *\n     * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n     *\n     * @type {ComponentDatatype}\n     * @readonly\n     *\n     * @default {@link ComponentDatatype.FLOAT}\n     */\n    componentDatatype: {\n      get: function () {\n        return ComponentDatatype.FLOAT;\n      },\n    },\n\n    /**\n     * The number of components in the attributes, i.e., {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.\n     *\n     * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n     *\n     * @type {number}\n     * @readonly\n     *\n     * @default 3\n     */\n    componentsPerAttribute: {\n      get: function () {\n        return 2;\n      },\n    },\n\n    /**\n     * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n     * indicate that the components should be mapped to the range [0, 1] (unsigned)\n     * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n     *\n     * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n     *\n     * @type {boolean}\n     * @readonly\n     *\n     * @default false\n     */\n    normalize: {\n      get: function () {\n        return false;\n      },\n    },\n  },\n);\n\n/**\n * Creates a new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.\n *\n * @param {DistanceDisplayCondition} distanceDisplayCondition The distance display condition.\n * @returns {DistanceDisplayConditionGeometryInstanceAttribute} The new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance.\n *\n * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near\n *\n * @example\n * const distanceDisplayCondition = new Cesium.DistanceDisplayCondition(100.0, 10000.0);\n * const instance = new Cesium.GeometryInstance({\n *   geometry : geometry,\n *   attributes : {\n *     distanceDisplayCondition : Cesium.DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n *   }\n * });\n */\nDistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition =\n  function (distanceDisplayCondition) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(distanceDisplayCondition)) {\n      throw new DeveloperError(\"distanceDisplayCondition is required.\");\n    }\n    if (distanceDisplayCondition.far <= distanceDisplayCondition.near) {\n      throw new DeveloperError(\n        \"distanceDisplayCondition.far distance must be greater than distanceDisplayCondition.near distance.\",\n      );\n    }\n    //>>includeEnd('debug');\n\n    return new DistanceDisplayConditionGeometryInstanceAttribute(\n      distanceDisplayCondition.near,\n      distanceDisplayCondition.far,\n    );\n  };\n\n/**\n * Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.\n *\n * @param {DistanceDisplayCondition} distanceDisplayCondition The distance display condition value.\n * @param {Float32Array} [result] The array to store the result in, if undefined a new instance will be created.\n * @returns {Float32Array} The modified result parameter or a new instance if result was undefined.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n */\nDistanceDisplayConditionGeometryInstanceAttribute.toValue = function (\n  distanceDisplayCondition,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(distanceDisplayCondition)) {\n    throw new DeveloperError(\"distanceDisplayCondition is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Float32Array([\n      distanceDisplayCondition.near,\n      distanceDisplayCondition.far,\n    ]);\n  }\n  result[0] = distanceDisplayCondition.near;\n  result[1] = distanceDisplayCondition.far;\n  return result;\n};\nexport default DistanceDisplayConditionGeometryInstanceAttribute;\n"],"names":["DistanceDisplayConditionGeometryInstanceAttribute","near","far","Number","MAX_VALUE","value","Float32Array","Object","defineProperties","prototype","componentDatatype","get","FLOAT","componentsPerAttribute","normalize","fromDistanceDisplayCondition","distanceDisplayCondition","toValue","result"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BC,GACD,SAASA,kDAAkDC,IAAI,EAAEC,GAAG;IAClED,OAAOA,QAAQ;IACfC,MAAMA,OAAOC,OAAOC,SAAS;IAE7B,yCAAyC;IACzC,IAAIF,OAAOD,MAAM;QACf,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,wBAAwB;IAExB;;;;;;GAMC,GACD,IAAI,CAACI,KAAK,GAAG,IAAIC,aAAa;QAACL;QAAMC;KAAI;AAC3C;AAEAK,OAAOC,gBAAgB,CACrBR,kDAAkDS,SAAS,EAC3D;IACE;;;;;;;;;;KAUC,GACDC,mBAAmB;QACjBC,KAAK;YACH,OAAO,uLAAiB,CAACC,KAAK;QAChC;IACF;IAEA;;;;;;;;;KASC,GACDC,wBAAwB;QACtBF,KAAK;YACH,OAAO;QACT;IACF;IAEA;;;;;;;;;;;KAWC,GACDG,WAAW;QACTH,KAAK;YACH,OAAO;QACT;IACF;AACF;AAGF;;;;;;;;;;;;;;;;CAgBC,GACDX,kDAAkDe,4BAA4B,GAC5E,SAAUC,wBAAwB;IAChC,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACA,2BAA2B;QACtC,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAIA,yBAAyBd,GAAG,IAAIc,yBAAyBf,IAAI,EAAE;QACjE,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,wBAAwB;IAExB,OAAO,IAAID,kDACTgB,yBAAyBf,IAAI,EAC7Be,yBAAyBd,GAAG;AAEhC;AAEF;;;;;;;;;;CAUC,GACDF,kDAAkDiB,OAAO,GAAG,SAC1DD,wBAAwB,EACxBE,MAAM;IAEN,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACF,2BAA2B;QACtC,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,IAAI,CAAC,IAAA,6KAAO,EAACE,SAAS;QACpB,OAAO,IAAIZ,aAAa;YACtBU,yBAAyBf,IAAI;YAC7Be,yBAAyBd,GAAG;SAC7B;IACH;IACAgB,MAAM,CAAC,EAAE,GAAGF,yBAAyBf,IAAI;IACzCiB,MAAM,CAAC,EAAE,GAAGF,yBAAyBd,GAAG;IACxC,OAAOgB;AACT;uCACelB","ignoreList":[0]}},
    {"offset": {"line": 34818, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/ShowGeometryInstanceAttribute.js"],"sourcesContent":["import ComponentDatatype from \"./ComponentDatatype.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Value and type information for per-instance geometry attribute that determines if the geometry instance will be shown.\n *\n * @alias ShowGeometryInstanceAttribute\n * @constructor\n *\n * @param {boolean} [show=true] Determines if the geometry instance will be shown.\n *\n *\n * @example\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.BoxGeometry({\n *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),\n *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   id : 'box',\n *   attributes : {\n *     show : new Cesium.ShowGeometryInstanceAttribute(false)\n *   }\n * });\n *\n * @see GeometryInstance\n * @see GeometryInstanceAttribute\n */\nfunction ShowGeometryInstanceAttribute(show) {\n  show = show ?? true;\n\n  /**\n   * The values for the attributes stored in a typed array.\n   *\n   * @type Uint8Array\n   *\n   * @default [1.0]\n   */\n  this.value = ShowGeometryInstanceAttribute.toValue(show);\n}\n\nObject.defineProperties(ShowGeometryInstanceAttribute.prototype, {\n  /**\n   * The datatype of each component in the attribute, e.g., individual elements in\n   * {@link ColorGeometryInstanceAttribute#value}.\n   *\n   * @memberof ShowGeometryInstanceAttribute.prototype\n   *\n   * @type {ComponentDatatype}\n   * @readonly\n   *\n   * @default {@link ComponentDatatype.UNSIGNED_BYTE}\n   */\n  componentDatatype: {\n    get: function () {\n      return ComponentDatatype.UNSIGNED_BYTE;\n    },\n  },\n\n  /**\n   * The number of components in the attributes, i.e., {@link ColorGeometryInstanceAttribute#value}.\n   *\n   * @memberof ShowGeometryInstanceAttribute.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @default 1\n   */\n  componentsPerAttribute: {\n    get: function () {\n      return 1;\n    },\n  },\n\n  /**\n   * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n   * indicate that the components should be mapped to the range [0, 1] (unsigned)\n   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n   *\n   * @memberof ShowGeometryInstanceAttribute.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  normalize: {\n    get: function () {\n      return false;\n    },\n  },\n});\n\n/**\n * Converts a boolean show to a typed array that can be used to assign a show attribute.\n *\n * @param {boolean} show The show value.\n * @param {Uint8Array} [result] The array to store the result in, if undefined a new instance will be created.\n * @returns {Uint8Array} The modified result parameter or a new instance if result was undefined.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true, attributes.show);\n */\nShowGeometryInstanceAttribute.toValue = function (show, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(show)) {\n    throw new DeveloperError(\"show is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Uint8Array([show]);\n  }\n  result[0] = show;\n  return result;\n};\nexport default ShowGeometryInstanceAttribute;\n"],"names":["ShowGeometryInstanceAttribute","show","value","toValue","Object","defineProperties","prototype","componentDatatype","get","UNSIGNED_BYTE","componentsPerAttribute","normalize","result","Uint8Array"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;CA0BC,GACD,SAASA,8BAA8BC,IAAI;IACzCA,OAAOA,QAAQ;IAEf;;;;;;GAMC,GACD,IAAI,CAACC,KAAK,GAAGF,8BAA8BG,OAAO,CAACF;AACrD;AAEAG,OAAOC,gBAAgB,CAACL,8BAA8BM,SAAS,EAAE;IAC/D;;;;;;;;;;GAUC,GACDC,mBAAmB;QACjBC,KAAK;YACH,OAAO,uLAAiB,CAACC,aAAa;QACxC;IACF;IAEA;;;;;;;;;GASC,GACDC,wBAAwB;QACtBF,KAAK;YACH,OAAO;QACT;IACF;IAEA;;;;;;;;;;;GAWC,GACDG,WAAW;QACTH,KAAK;YACH,OAAO;QACT;IACF;AACF;AAEA;;;;;;;;;;CAUC,GACDR,8BAA8BG,OAAO,GAAG,SAAUF,IAAI,EAAEW,MAAM;IAC5D,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACX,OAAO;QAClB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,IAAI,CAAC,IAAA,6KAAO,EAACW,SAAS;QACpB,OAAO,IAAIC,WAAW;YAACZ;SAAK;IAC9B;IACAW,MAAM,CAAC,EAAE,GAAGX;IACZ,OAAOW;AACT;uCACeZ","ignoreList":[0]}},
    {"offset": {"line": 34940, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/CornerType.js"],"sourcesContent":["/**\n * Style options for corners.\n *\n * @demo The {@link https://sandcastle.cesium.com/index.html?src=Corridor.html&label=Geometries|Corridor Demo}\n * demonstrates the three corner types, as used by {@link CorridorGraphics}.\n *\n * @enum {number}\n */\nconst CornerType = {\n  /**\n   * <img src=\"Images/CornerTypeRounded.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n   *\n   * Corner has a smooth edge.\n   * @type {number}\n   * @constant\n   */\n  ROUNDED: 0,\n\n  /**\n   * <img src=\"Images/CornerTypeMitered.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n   *\n   * Corner point is the intersection of adjacent edges.\n   * @type {number}\n   * @constant\n   */\n  MITERED: 1,\n\n  /**\n   * <img src=\"Images/CornerTypeBeveled.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n   *\n   * Corner is clipped.\n   * @type {number}\n   * @constant\n   */\n  BEVELED: 2,\n};\nexport default Object.freeze(CornerType);\n"],"names":["CornerType","ROUNDED","MITERED","BEVELED","Object","freeze"],"mappings":";;;;AAAA;;;;;;;CAOC,GACD,MAAMA,aAAa;IACjB;;;;;;GAMC,GACDC,SAAS;IAET;;;;;;GAMC,GACDC,SAAS;IAET;;;;;;GAMC,GACDC,SAAS;AACX;uCACeC,OAAOC,MAAM,CAACL","ignoreList":[0]}},
    {"offset": {"line": 34979, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PolylinePipeline.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\n\n/**\n * @private\n */\nconst PolylinePipeline = {};\n\nPolylinePipeline.numberOfPoints = function (p0, p1, minDistance) {\n  const distance = Cartesian3.distance(p0, p1);\n  return Math.ceil(distance / minDistance);\n};\n\nPolylinePipeline.numberOfPointsRhumbLine = function (p0, p1, granularity) {\n  const radiansDistanceSquared =\n    Math.pow(p0.longitude - p1.longitude, 2) +\n    Math.pow(p0.latitude - p1.latitude, 2);\n\n  return Math.max(\n    1,\n    Math.ceil(Math.sqrt(radiansDistanceSquared / (granularity * granularity))),\n  );\n};\n\nconst cartoScratch = new Cartographic();\nPolylinePipeline.extractHeights = function (positions, ellipsoid) {\n  const length = positions.length;\n  const heights = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const p = positions[i];\n    heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;\n  }\n  return heights;\n};\n\nconst wrapLongitudeInversMatrix = new Matrix4();\nconst wrapLongitudeOrigin = new Cartesian3();\nconst wrapLongitudeXZNormal = new Cartesian3();\nconst wrapLongitudeXZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst wrapLongitudeYZNormal = new Cartesian3();\nconst wrapLongitudeYZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst wrapLongitudeIntersection = new Cartesian3();\nconst wrapLongitudeOffset = new Cartesian3();\n\nconst subdivideHeightsScratchArray = [];\n\nfunction subdivideHeights(numPoints, h0, h1) {\n  const heights = subdivideHeightsScratchArray;\n  heights.length = numPoints;\n\n  let i;\n  if (h0 === h1) {\n    for (i = 0; i < numPoints; i++) {\n      heights[i] = h0;\n    }\n    return heights;\n  }\n\n  const dHeight = h1 - h0;\n  const heightPerVertex = dHeight / numPoints;\n\n  for (i = 0; i < numPoints; i++) {\n    const h = h0 + i * heightPerVertex;\n    heights[i] = h;\n  }\n\n  return heights;\n}\n\nconst carto1 = new Cartographic();\nconst carto2 = new Cartographic();\nconst cartesian = new Cartesian3();\nconst scaleFirst = new Cartesian3();\nconst scaleLast = new Cartesian3();\nconst ellipsoidGeodesic = new EllipsoidGeodesic();\nlet ellipsoidRhumb = new EllipsoidRhumbLine();\n\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n//and this prevents duplication of end point.\nfunction generateCartesianArc(\n  p0,\n  p1,\n  minDistance,\n  ellipsoid,\n  h0,\n  h1,\n  array,\n  offset,\n) {\n  const first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\n  const last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\n  const numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\n  const start = ellipsoid.cartesianToCartographic(first, carto1);\n  const end = ellipsoid.cartesianToCartographic(last, carto2);\n  const heights = subdivideHeights(numPoints, h0, h1);\n\n  ellipsoidGeodesic.setEndPoints(start, end);\n  const surfaceDistanceBetweenPoints =\n    ellipsoidGeodesic.surfaceDistance / numPoints;\n\n  let index = offset;\n  start.height = h0;\n  let cart = ellipsoid.cartographicToCartesian(start, cartesian);\n  Cartesian3.pack(cart, array, index);\n  index += 3;\n\n  for (let i = 1; i < numPoints; i++) {\n    const carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(\n      i * surfaceDistanceBetweenPoints,\n      carto2,\n    );\n    carto.height = heights[i];\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n    Cartesian3.pack(cart, array, index);\n    index += 3;\n  }\n\n  return index;\n}\n\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n//and this prevents duplication of end point.\nfunction generateCartesianRhumbArc(\n  p0,\n  p1,\n  granularity,\n  ellipsoid,\n  h0,\n  h1,\n  array,\n  offset,\n) {\n  const start = ellipsoid.cartesianToCartographic(p0, carto1);\n  const end = ellipsoid.cartesianToCartographic(p1, carto2);\n  const numPoints = PolylinePipeline.numberOfPointsRhumbLine(\n    start,\n    end,\n    granularity,\n  );\n  start.height = 0.0;\n  end.height = 0.0;\n  const heights = subdivideHeights(numPoints, h0, h1);\n\n  if (!ellipsoidRhumb.ellipsoid.equals(ellipsoid)) {\n    ellipsoidRhumb = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  }\n  ellipsoidRhumb.setEndPoints(start, end);\n  const surfaceDistanceBetweenPoints =\n    ellipsoidRhumb.surfaceDistance / numPoints;\n\n  let index = offset;\n  start.height = h0;\n  let cart = ellipsoid.cartographicToCartesian(start, cartesian);\n  Cartesian3.pack(cart, array, index);\n  index += 3;\n\n  for (let i = 1; i < numPoints; i++) {\n    const carto = ellipsoidRhumb.interpolateUsingSurfaceDistance(\n      i * surfaceDistanceBetweenPoints,\n      carto2,\n    );\n    carto.height = heights[i];\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n    Cartesian3.pack(cart, array, index);\n    index += 3;\n  }\n\n  return index;\n}\n\n/**\n * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.\n *\n * @param {Cartesian3[]} positions The polyline's Cartesian positions.\n * @param {Matrix4} [modelMatrix=Matrix4.IDENTITY] The polyline's model matrix. Assumed to be an affine\n * transformation matrix, where the upper left 3x3 elements are a rotation matrix, and\n * the upper three elements in the fourth column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].\n * The matrix is not verified to be in the proper form.\n * @returns {object} An object with a <code>positions</code> property that is an array of positions and a\n * <code>segments</code> property.\n *\n *\n * @example\n * const polylines = new Cesium.PolylineCollection();\n * const polyline = polylines.add(...);\n * const positions = polyline.positions;\n * const modelMatrix = polylines.modelMatrix;\n * const segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);\n *\n * @see PolygonPipeline.wrapLongitude\n * @see Polyline\n * @see PolylineCollection\n */\nPolylinePipeline.wrapLongitude = function (positions, modelMatrix) {\n  const cartesians = [];\n  const segments = [];\n\n  if (defined(positions) && positions.length > 0) {\n    modelMatrix = modelMatrix ?? Matrix4.IDENTITY;\n    const inverseModelMatrix = Matrix4.inverseTransformation(\n      modelMatrix,\n      wrapLongitudeInversMatrix,\n    );\n\n    const origin = Matrix4.multiplyByPoint(\n      inverseModelMatrix,\n      Cartesian3.ZERO,\n      wrapLongitudeOrigin,\n    );\n    const xzNormal = Cartesian3.normalize(\n      Matrix4.multiplyByPointAsVector(\n        inverseModelMatrix,\n        Cartesian3.UNIT_Y,\n        wrapLongitudeXZNormal,\n      ),\n      wrapLongitudeXZNormal,\n    );\n    const xzPlane = Plane.fromPointNormal(\n      origin,\n      xzNormal,\n      wrapLongitudeXZPlane,\n    );\n    const yzNormal = Cartesian3.normalize(\n      Matrix4.multiplyByPointAsVector(\n        inverseModelMatrix,\n        Cartesian3.UNIT_X,\n        wrapLongitudeYZNormal,\n      ),\n      wrapLongitudeYZNormal,\n    );\n    const yzPlane = Plane.fromPointNormal(\n      origin,\n      yzNormal,\n      wrapLongitudeYZPlane,\n    );\n\n    let count = 1;\n    cartesians.push(Cartesian3.clone(positions[0]));\n    let prev = cartesians[0];\n\n    const length = positions.length;\n    for (let i = 1; i < length; ++i) {\n      const cur = positions[i];\n\n      // intersects the IDL if either endpoint is on the negative side of the yz-plane\n      if (\n        Plane.getPointDistance(yzPlane, prev) < 0.0 ||\n        Plane.getPointDistance(yzPlane, cur) < 0.0\n      ) {\n        // and intersects the xz-plane\n        const intersection = IntersectionTests.lineSegmentPlane(\n          prev,\n          cur,\n          xzPlane,\n          wrapLongitudeIntersection,\n        );\n        if (defined(intersection)) {\n          // move point on the xz-plane slightly away from the plane\n          const offset = Cartesian3.multiplyByScalar(\n            xzNormal,\n            5.0e-9,\n            wrapLongitudeOffset,\n          );\n          if (Plane.getPointDistance(xzPlane, prev) < 0.0) {\n            Cartesian3.negate(offset, offset);\n          }\n\n          cartesians.push(\n            Cartesian3.add(intersection, offset, new Cartesian3()),\n          );\n          segments.push(count + 1);\n\n          Cartesian3.negate(offset, offset);\n          cartesians.push(\n            Cartesian3.add(intersection, offset, new Cartesian3()),\n          );\n          count = 1;\n        }\n      }\n\n      cartesians.push(Cartesian3.clone(positions[i]));\n      count++;\n\n      prev = cur;\n    }\n\n    segments.push(count);\n  }\n\n  return {\n    positions: cartesians,\n    lengths: segments,\n  };\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {number|number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the positions lie.\n * @returns {number[]} A new array of positions of type {number} that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateArc = function (options) {\n  if (!defined(options)) {\n    options = {};\n  }\n  const positions = options.positions;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = positions.length;\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  let height = options.height ?? 0;\n  const hasHeightArray = Array.isArray(height);\n\n  if (length < 1) {\n    return [];\n  } else if (length === 1) {\n    const p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n    height = hasHeightArray ? height[0] : height;\n    if (height !== 0) {\n      const n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n      Cartesian3.multiplyByScalar(n, height, n);\n      Cartesian3.add(p, n, p);\n    }\n\n    return [p.x, p.y, p.z];\n  }\n\n  let minDistance = options.minDistance;\n  if (!defined(minDistance)) {\n    const granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n    minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  }\n\n  let numPoints = 0;\n  let i;\n\n  for (i = 0; i < length - 1; i++) {\n    numPoints += PolylinePipeline.numberOfPoints(\n      positions[i],\n      positions[i + 1],\n      minDistance,\n    );\n  }\n\n  const arrayLength = (numPoints + 1) * 3;\n  const newPositions = new Array(arrayLength);\n  let offset = 0;\n\n  for (i = 0; i < length - 1; i++) {\n    const p0 = positions[i];\n    const p1 = positions[i + 1];\n\n    const h0 = hasHeightArray ? height[i] : height;\n    const h1 = hasHeightArray ? height[i + 1] : height;\n\n    offset = generateCartesianArc(\n      p0,\n      p1,\n      minDistance,\n      ellipsoid,\n      h0,\n      h1,\n      newPositions,\n      offset,\n    );\n  }\n\n  subdivideHeightsScratchArray.length = 0;\n\n  const lastPoint = positions[length - 1];\n  const carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n  carto.height = hasHeightArray ? height[length - 1] : height;\n  const cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n  return newPositions;\n};\n\nconst scratchCartographic0 = new Cartographic();\nconst scratchCartographic1 = new Cartographic();\n\n/**\n * Subdivides polyline and raises all points to the specified height using Rhumb lines.  Returns an array of numbers to represent the positions.\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {number|number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the positions lie.\n * @returns {number[]} A new array of positions of type {number} that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateRhumbArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateRhumbArc = function (options) {\n  if (!defined(options)) {\n    options = {};\n  }\n  const positions = options.positions;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = positions.length;\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  let height = options.height ?? 0;\n  const hasHeightArray = Array.isArray(height);\n\n  if (length < 1) {\n    return [];\n  } else if (length === 1) {\n    const p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n    height = hasHeightArray ? height[0] : height;\n    if (height !== 0) {\n      const n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n      Cartesian3.multiplyByScalar(n, height, n);\n      Cartesian3.add(p, n, p);\n    }\n\n    return [p.x, p.y, p.z];\n  }\n\n  const granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n\n  let numPoints = 0;\n  let i;\n\n  let c0 = ellipsoid.cartesianToCartographic(\n    positions[0],\n    scratchCartographic0,\n  );\n  let c1;\n  for (i = 0; i < length - 1; i++) {\n    c1 = ellipsoid.cartesianToCartographic(\n      positions[i + 1],\n      scratchCartographic1,\n    );\n    numPoints += PolylinePipeline.numberOfPointsRhumbLine(c0, c1, granularity);\n    c0 = Cartographic.clone(c1, scratchCartographic0);\n  }\n\n  const arrayLength = (numPoints + 1) * 3;\n  const newPositions = new Array(arrayLength);\n  let offset = 0;\n\n  for (i = 0; i < length - 1; i++) {\n    const p0 = positions[i];\n    const p1 = positions[i + 1];\n\n    const h0 = hasHeightArray ? height[i] : height;\n    const h1 = hasHeightArray ? height[i + 1] : height;\n\n    offset = generateCartesianRhumbArc(\n      p0,\n      p1,\n      granularity,\n      ellipsoid,\n      h0,\n      h1,\n      newPositions,\n      offset,\n    );\n  }\n\n  subdivideHeightsScratchArray.length = 0;\n\n  const lastPoint = positions[length - 1];\n  const carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n  carto.height = hasHeightArray ? height[length - 1] : height;\n  const cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n  return newPositions;\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {number|number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the positions lie.\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateCartesianArc = function (options) {\n  const numberArray = PolylinePipeline.generateArc(options);\n  const size = numberArray.length / 3;\n  const newPositions = new Array(size);\n  for (let i = 0; i < size; i++) {\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\n  }\n  return newPositions;\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height using Rhumb Lines. Returns an array of new {Cartesian3} positions.\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {number|number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the positions lie.\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateCartesianRhumbArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateCartesianRhumbArc = function (options) {\n  const numberArray = PolylinePipeline.generateRhumbArc(options);\n  const size = numberArray.length / 3;\n  const newPositions = new Array(size);\n  for (let i = 0; i < size; i++) {\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\n  }\n  return newPositions;\n};\nexport default PolylinePipeline;\n"],"names":["PolylinePipeline","numberOfPoints","p0","p1","minDistance","distance","Math","ceil","numberOfPointsRhumbLine","granularity","radiansDistanceSquared","pow","longitude","latitude","max","sqrt","cartoScratch","extractHeights","positions","ellipsoid","length","heights","Array","i","p","cartesianToCartographic","height","wrapLongitudeInversMatrix","wrapLongitudeOrigin","wrapLongitudeXZNormal","wrapLongitudeXZPlane","UNIT_X","wrapLongitudeYZNormal","wrapLongitudeYZPlane","wrapLongitudeIntersection","wrapLongitudeOffset","subdivideHeightsScratchArray","subdivideHeights","numPoints","h0","h1","dHeight","heightPerVertex","h","carto1","carto2","cartesian","scaleFirst","scaleLast","ellipsoidGeodesic","ellipsoidRhumb","generateCartesianArc","array","offset","first","scaleToGeodeticSurface","last","start","end","setEndPoints","surfaceDistanceBetweenPoints","surfaceDistance","index","cart","cartographicToCartesian","pack","carto","interpolateUsingSurfaceDistance","generateCartesianRhumbArc","equals","undefined","wrapLongitude","modelMatrix","cartesians","segments","IDENTITY","inverseModelMatrix","inverseTransformation","origin","multiplyByPoint","ZERO","xzNormal","normalize","multiplyByPointAsVector","UNIT_Y","xzPlane","fromPointNormal","yzNormal","yzPlane","count","push","clone","prev","cur","getPointDistance","intersection","lineSegmentPlane","multiplyByScalar","negate","add","lengths","generateArc","options","default","hasHeightArray","isArray","n","geodeticSurfaceNormal","x","y","z","RADIANS_PER_DEGREE","chordLength","maximumRadius","arrayLength","newPositions","lastPoint","scratchCartographic0","scratchCartographic1","generateRhumbArc","c0","c1","numberArray","size","unpack"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAEA;;CAEC,GACD,MAAMA,mBAAmB,CAAC;AAE1BA,iBAAiBC,cAAc,GAAG,SAAUC,EAAE,EAAEC,EAAE,EAAEC,WAAW;IAC7D,MAAMC,WAAW,gLAAU,CAACA,QAAQ,CAACH,IAAIC;IACzC,OAAOG,KAAKC,IAAI,CAACF,WAAWD;AAC9B;AAEAJ,iBAAiBQ,uBAAuB,GAAG,SAAUN,EAAE,EAAEC,EAAE,EAAEM,WAAW;IACtE,MAAMC,yBACJJ,KAAKK,GAAG,CAACT,GAAGU,SAAS,GAAGT,GAAGS,SAAS,EAAE,KACtCN,KAAKK,GAAG,CAACT,GAAGW,QAAQ,GAAGV,GAAGU,QAAQ,EAAE;IAEtC,OAAOP,KAAKQ,GAAG,CACb,GACAR,KAAKC,IAAI,CAACD,KAAKS,IAAI,CAACL,yBAAyB,CAACD,cAAcA,WAAW;AAE3E;AAEA,MAAMO,eAAe,IAAI,kLAAY;AACrChB,iBAAiBiB,cAAc,GAAG,SAAUC,SAAS,EAAEC,SAAS;IAC9D,MAAMC,SAASF,UAAUE,MAAM;IAC/B,MAAMC,UAAU,IAAIC,MAAMF;IAC1B,IAAK,IAAIG,IAAI,GAAGA,IAAIH,QAAQG,IAAK;QAC/B,MAAMC,IAAIN,SAAS,CAACK,EAAE;QACtBF,OAAO,CAACE,EAAE,GAAGJ,UAAUM,uBAAuB,CAACD,GAAGR,cAAcU,MAAM;IACxE;IACA,OAAOL;AACT;AAEA,MAAMM,4BAA4B,IAAI,6KAAO;AAC7C,MAAMC,sBAAsB,IAAI,gLAAU;AAC1C,MAAMC,wBAAwB,IAAI,gLAAU;AAC5C,MAAMC,uBAAuB,IAAI,2KAAK,CAAC,gLAAU,CAACC,MAAM,EAAE;AAC1D,MAAMC,wBAAwB,IAAI,gLAAU;AAC5C,MAAMC,uBAAuB,IAAI,2KAAK,CAAC,gLAAU,CAACF,MAAM,EAAE;AAC1D,MAAMG,4BAA4B,IAAI,gLAAU;AAChD,MAAMC,sBAAsB,IAAI,gLAAU;AAE1C,MAAMC,+BAA+B,EAAE;AAEvC,SAASC,iBAAiBC,SAAS,EAAEC,EAAE,EAAEC,EAAE;IACzC,MAAMnB,UAAUe;IAChBf,QAAQD,MAAM,GAAGkB;IAEjB,IAAIf;IACJ,IAAIgB,OAAOC,IAAI;QACb,IAAKjB,IAAI,GAAGA,IAAIe,WAAWf,IAAK;YAC9BF,OAAO,CAACE,EAAE,GAAGgB;QACf;QACA,OAAOlB;IACT;IAEA,MAAMoB,UAAUD,KAAKD;IACrB,MAAMG,kBAAkBD,UAAUH;IAElC,IAAKf,IAAI,GAAGA,IAAIe,WAAWf,IAAK;QAC9B,MAAMoB,IAAIJ,KAAKhB,IAAImB;QACnBrB,OAAO,CAACE,EAAE,GAAGoB;IACf;IAEA,OAAOtB;AACT;AAEA,MAAMuB,SAAS,IAAI,kLAAY;AAC/B,MAAMC,SAAS,IAAI,kLAAY;AAC/B,MAAMC,YAAY,IAAI,gLAAU;AAChC,MAAMC,aAAa,IAAI,gLAAU;AACjC,MAAMC,YAAY,IAAI,gLAAU;AAChC,MAAMC,oBAAoB,IAAI,uLAAiB;AAC/C,IAAIC,iBAAiB,IAAI,wLAAkB;AAE3C,sFAAsF;AACtF,mGAAmG;AACnG,6CAA6C;AAC7C,SAASC,qBACPjD,EAAE,EACFC,EAAE,EACFC,WAAW,EACXe,SAAS,EACToB,EAAE,EACFC,EAAE,EACFY,KAAK,EACLC,MAAM;IAEN,MAAMC,QAAQnC,UAAUoC,sBAAsB,CAACrD,IAAI6C;IACnD,MAAMS,OAAOrC,UAAUoC,sBAAsB,CAACpD,IAAI6C;IAClD,MAAMV,YAAYtC,iBAAiBC,cAAc,CAACC,IAAIC,IAAIC;IAC1D,MAAMqD,QAAQtC,UAAUM,uBAAuB,CAAC6B,OAAOV;IACvD,MAAMc,MAAMvC,UAAUM,uBAAuB,CAAC+B,MAAMX;IACpD,MAAMxB,UAAUgB,iBAAiBC,WAAWC,IAAIC;IAEhDS,kBAAkBU,YAAY,CAACF,OAAOC;IACtC,MAAME,+BACJX,kBAAkBY,eAAe,GAAGvB;IAEtC,IAAIwB,QAAQT;IACZI,MAAM/B,MAAM,GAAGa;IACf,IAAIwB,OAAO5C,UAAU6C,uBAAuB,CAACP,OAAOX;IACpD,gLAAU,CAACmB,IAAI,CAACF,MAAMX,OAAOU;IAC7BA,SAAS;IAET,IAAK,IAAIvC,IAAI,GAAGA,IAAIe,WAAWf,IAAK;QAClC,MAAM2C,QAAQjB,kBAAkBkB,+BAA+B,CAC7D5C,IAAIqC,8BACJf;QAEFqB,MAAMxC,MAAM,GAAGL,OAAO,CAACE,EAAE;QACzBwC,OAAO5C,UAAU6C,uBAAuB,CAACE,OAAOpB;QAChD,gLAAU,CAACmB,IAAI,CAACF,MAAMX,OAAOU;QAC7BA,SAAS;IACX;IAEA,OAAOA;AACT;AAEA,sFAAsF;AACtF,mGAAmG;AACnG,6CAA6C;AAC7C,SAASM,0BACPlE,EAAE,EACFC,EAAE,EACFM,WAAW,EACXU,SAAS,EACToB,EAAE,EACFC,EAAE,EACFY,KAAK,EACLC,MAAM;IAEN,MAAMI,QAAQtC,UAAUM,uBAAuB,CAACvB,IAAI0C;IACpD,MAAMc,MAAMvC,UAAUM,uBAAuB,CAACtB,IAAI0C;IAClD,MAAMP,YAAYtC,iBAAiBQ,uBAAuB,CACxDiD,OACAC,KACAjD;IAEFgD,MAAM/B,MAAM,GAAG;IACfgC,IAAIhC,MAAM,GAAG;IACb,MAAML,UAAUgB,iBAAiBC,WAAWC,IAAIC;IAEhD,IAAI,CAACU,eAAe/B,SAAS,CAACkD,MAAM,CAAClD,YAAY;QAC/C+B,iBAAiB,IAAI,wLAAkB,CAACoB,WAAWA,WAAWnD;IAChE;IACA+B,eAAeS,YAAY,CAACF,OAAOC;IACnC,MAAME,+BACJV,eAAeW,eAAe,GAAGvB;IAEnC,IAAIwB,QAAQT;IACZI,MAAM/B,MAAM,GAAGa;IACf,IAAIwB,OAAO5C,UAAU6C,uBAAuB,CAACP,OAAOX;IACpD,gLAAU,CAACmB,IAAI,CAACF,MAAMX,OAAOU;IAC7BA,SAAS;IAET,IAAK,IAAIvC,IAAI,GAAGA,IAAIe,WAAWf,IAAK;QAClC,MAAM2C,QAAQhB,eAAeiB,+BAA+B,CAC1D5C,IAAIqC,8BACJf;QAEFqB,MAAMxC,MAAM,GAAGL,OAAO,CAACE,EAAE;QACzBwC,OAAO5C,UAAU6C,uBAAuB,CAACE,OAAOpB;QAChD,gLAAU,CAACmB,IAAI,CAACF,MAAMX,OAAOU;QAC7BA,SAAS;IACX;IAEA,OAAOA;AACT;AAEA;;;;;;;;;;;;;;;;;;;;;;CAsBC,GACD9D,iBAAiBuE,aAAa,GAAG,SAAUrD,SAAS,EAAEsD,WAAW;IAC/D,MAAMC,aAAa,EAAE;IACrB,MAAMC,WAAW,EAAE;IAEnB,IAAI,IAAA,6KAAO,EAACxD,cAAcA,UAAUE,MAAM,GAAG,GAAG;QAC9CoD,cAAcA,eAAe,6KAAO,CAACG,QAAQ;QAC7C,MAAMC,qBAAqB,6KAAO,CAACC,qBAAqB,CACtDL,aACA7C;QAGF,MAAMmD,SAAS,6KAAO,CAACC,eAAe,CACpCH,oBACA,gLAAU,CAACI,IAAI,EACfpD;QAEF,MAAMqD,WAAW,gLAAU,CAACC,SAAS,CACnC,6KAAO,CAACC,uBAAuB,CAC7BP,oBACA,gLAAU,CAACQ,MAAM,EACjBvD,wBAEFA;QAEF,MAAMwD,UAAU,2KAAK,CAACC,eAAe,CACnCR,QACAG,UACAnD;QAEF,MAAMyD,WAAW,gLAAU,CAACL,SAAS,CACnC,6KAAO,CAACC,uBAAuB,CAC7BP,oBACA,gLAAU,CAAC7C,MAAM,EACjBC,wBAEFA;QAEF,MAAMwD,UAAU,2KAAK,CAACF,eAAe,CACnCR,QACAS,UACAtD;QAGF,IAAIwD,QAAQ;QACZhB,WAAWiB,IAAI,CAAC,gLAAU,CAACC,KAAK,CAACzE,SAAS,CAAC,EAAE;QAC7C,IAAI0E,OAAOnB,UAAU,CAAC,EAAE;QAExB,MAAMrD,SAASF,UAAUE,MAAM;QAC/B,IAAK,IAAIG,IAAI,GAAGA,IAAIH,QAAQ,EAAEG,EAAG;YAC/B,MAAMsE,MAAM3E,SAAS,CAACK,EAAE;YAExB,gFAAgF;YAChF,IACE,2KAAK,CAACuE,gBAAgB,CAACN,SAASI,QAAQ,OACxC,2KAAK,CAACE,gBAAgB,CAACN,SAASK,OAAO,KACvC;gBACA,8BAA8B;gBAC9B,MAAME,eAAe,uLAAiB,CAACC,gBAAgB,CACrDJ,MACAC,KACAR,SACAnD;gBAEF,IAAI,IAAA,6KAAO,EAAC6D,eAAe;oBACzB,0DAA0D;oBAC1D,MAAM1C,SAAS,gLAAU,CAAC4C,gBAAgB,CACxChB,UACA,QACA9C;oBAEF,IAAI,2KAAK,CAAC2D,gBAAgB,CAACT,SAASO,QAAQ,KAAK;wBAC/C,gLAAU,CAACM,MAAM,CAAC7C,QAAQA;oBAC5B;oBAEAoB,WAAWiB,IAAI,CACb,gLAAU,CAACS,GAAG,CAACJ,cAAc1C,QAAQ,IAAI,gLAAU;oBAErDqB,SAASgB,IAAI,CAACD,QAAQ;oBAEtB,gLAAU,CAACS,MAAM,CAAC7C,QAAQA;oBAC1BoB,WAAWiB,IAAI,CACb,gLAAU,CAACS,GAAG,CAACJ,cAAc1C,QAAQ,IAAI,gLAAU;oBAErDoC,QAAQ;gBACV;YACF;YAEAhB,WAAWiB,IAAI,CAAC,gLAAU,CAACC,KAAK,CAACzE,SAAS,CAACK,EAAE;YAC7CkE;YAEAG,OAAOC;QACT;QAEAnB,SAASgB,IAAI,CAACD;IAChB;IAEA,OAAO;QACLvE,WAAWuD;QACX2B,SAAS1B;IACX;AACF;AAEA;;;;;;;;;;;;;;;;;;;CAmBC,GACD1E,iBAAiBqG,WAAW,GAAG,SAAUC,OAAO;IAC9C,IAAI,CAAC,IAAA,6KAAO,EAACA,UAAU;QACrBA,UAAU,CAAC;IACb;IACA,MAAMpF,YAAYoF,QAAQpF,SAAS;IACnC,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACA,YAAY;QACvB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAME,SAASF,UAAUE,MAAM;IAC/B,MAAMD,YAAYmF,QAAQnF,SAAS,IAAI,+KAAS,CAACoF,OAAO;IACxD,IAAI7E,SAAS4E,QAAQ5E,MAAM,IAAI;IAC/B,MAAM8E,iBAAiBlF,MAAMmF,OAAO,CAAC/E;IAErC,IAAIN,SAAS,GAAG;QACd,OAAO,EAAE;IACX,OAAO,IAAIA,WAAW,GAAG;QACvB,MAAMI,IAAIL,UAAUoC,sBAAsB,CAACrC,SAAS,CAAC,EAAE,EAAE6B;QACzDrB,SAAS8E,iBAAiB9E,MAAM,CAAC,EAAE,GAAGA;QACtC,IAAIA,WAAW,GAAG;YAChB,MAAMgF,IAAIvF,UAAUwF,qBAAqB,CAACnF,GAAGsB;YAC7C,gLAAU,CAACmD,gBAAgB,CAACS,GAAGhF,QAAQgF;YACvC,gLAAU,CAACP,GAAG,CAAC3E,GAAGkF,GAAGlF;QACvB;QAEA,OAAO;YAACA,EAAEoF,CAAC;YAAEpF,EAAEqF,CAAC;YAAErF,EAAEsF,CAAC;SAAC;IACxB;IAEA,IAAI1G,cAAckG,QAAQlG,WAAW;IACrC,IAAI,CAAC,IAAA,6KAAO,EAACA,cAAc;QACzB,MAAMK,cAAc6F,QAAQ7F,WAAW,IAAI,0KAAU,CAACsG,kBAAkB;QACxE3G,cAAc,0KAAU,CAAC4G,WAAW,CAACvG,aAAaU,UAAU8F,aAAa;IAC3E;IAEA,IAAI3E,YAAY;IAChB,IAAIf;IAEJ,IAAKA,IAAI,GAAGA,IAAIH,SAAS,GAAGG,IAAK;QAC/Be,aAAatC,iBAAiBC,cAAc,CAC1CiB,SAAS,CAACK,EAAE,EACZL,SAAS,CAACK,IAAI,EAAE,EAChBnB;IAEJ;IAEA,MAAM8G,cAAc,CAAC5E,YAAY,CAAC,IAAI;IACtC,MAAM6E,eAAe,IAAI7F,MAAM4F;IAC/B,IAAI7D,SAAS;IAEb,IAAK9B,IAAI,GAAGA,IAAIH,SAAS,GAAGG,IAAK;QAC/B,MAAMrB,KAAKgB,SAAS,CAACK,EAAE;QACvB,MAAMpB,KAAKe,SAAS,CAACK,IAAI,EAAE;QAE3B,MAAMgB,KAAKiE,iBAAiB9E,MAAM,CAACH,EAAE,GAAGG;QACxC,MAAMc,KAAKgE,iBAAiB9E,MAAM,CAACH,IAAI,EAAE,GAAGG;QAE5C2B,SAASF,qBACPjD,IACAC,IACAC,aACAe,WACAoB,IACAC,IACA2E,cACA9D;IAEJ;IAEAjB,6BAA6BhB,MAAM,GAAG;IAEtC,MAAMgG,YAAYlG,SAAS,CAACE,SAAS,EAAE;IACvC,MAAM8C,QAAQ/C,UAAUM,uBAAuB,CAAC2F,WAAWxE;IAC3DsB,MAAMxC,MAAM,GAAG8E,iBAAiB9E,MAAM,CAACN,SAAS,EAAE,GAAGM;IACrD,MAAMqC,OAAO5C,UAAU6C,uBAAuB,CAACE,OAAOpB;IACtD,gLAAU,CAACmB,IAAI,CAACF,MAAMoD,cAAcD,cAAc;IAElD,OAAOC;AACT;AAEA,MAAME,uBAAuB,IAAI,kLAAY;AAC7C,MAAMC,uBAAuB,IAAI,kLAAY;AAE7C;;;;;;;;;;;;;;;;;;;CAmBC,GACDtH,iBAAiBuH,gBAAgB,GAAG,SAAUjB,OAAO;IACnD,IAAI,CAAC,IAAA,6KAAO,EAACA,UAAU;QACrBA,UAAU,CAAC;IACb;IACA,MAAMpF,YAAYoF,QAAQpF,SAAS;IACnC,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACA,YAAY;QACvB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAME,SAASF,UAAUE,MAAM;IAC/B,MAAMD,YAAYmF,QAAQnF,SAAS,IAAI,+KAAS,CAACoF,OAAO;IACxD,IAAI7E,SAAS4E,QAAQ5E,MAAM,IAAI;IAC/B,MAAM8E,iBAAiBlF,MAAMmF,OAAO,CAAC/E;IAErC,IAAIN,SAAS,GAAG;QACd,OAAO,EAAE;IACX,OAAO,IAAIA,WAAW,GAAG;QACvB,MAAMI,IAAIL,UAAUoC,sBAAsB,CAACrC,SAAS,CAAC,EAAE,EAAE6B;QACzDrB,SAAS8E,iBAAiB9E,MAAM,CAAC,EAAE,GAAGA;QACtC,IAAIA,WAAW,GAAG;YAChB,MAAMgF,IAAIvF,UAAUwF,qBAAqB,CAACnF,GAAGsB;YAC7C,gLAAU,CAACmD,gBAAgB,CAACS,GAAGhF,QAAQgF;YACvC,gLAAU,CAACP,GAAG,CAAC3E,GAAGkF,GAAGlF;QACvB;QAEA,OAAO;YAACA,EAAEoF,CAAC;YAAEpF,EAAEqF,CAAC;YAAErF,EAAEsF,CAAC;SAAC;IACxB;IAEA,MAAMrG,cAAc6F,QAAQ7F,WAAW,IAAI,0KAAU,CAACsG,kBAAkB;IAExE,IAAIzE,YAAY;IAChB,IAAIf;IAEJ,IAAIiG,KAAKrG,UAAUM,uBAAuB,CACxCP,SAAS,CAAC,EAAE,EACZmG;IAEF,IAAII;IACJ,IAAKlG,IAAI,GAAGA,IAAIH,SAAS,GAAGG,IAAK;QAC/BkG,KAAKtG,UAAUM,uBAAuB,CACpCP,SAAS,CAACK,IAAI,EAAE,EAChB+F;QAEFhF,aAAatC,iBAAiBQ,uBAAuB,CAACgH,IAAIC,IAAIhH;QAC9D+G,KAAK,kLAAY,CAAC7B,KAAK,CAAC8B,IAAIJ;IAC9B;IAEA,MAAMH,cAAc,CAAC5E,YAAY,CAAC,IAAI;IACtC,MAAM6E,eAAe,IAAI7F,MAAM4F;IAC/B,IAAI7D,SAAS;IAEb,IAAK9B,IAAI,GAAGA,IAAIH,SAAS,GAAGG,IAAK;QAC/B,MAAMrB,KAAKgB,SAAS,CAACK,EAAE;QACvB,MAAMpB,KAAKe,SAAS,CAACK,IAAI,EAAE;QAE3B,MAAMgB,KAAKiE,iBAAiB9E,MAAM,CAACH,EAAE,GAAGG;QACxC,MAAMc,KAAKgE,iBAAiB9E,MAAM,CAACH,IAAI,EAAE,GAAGG;QAE5C2B,SAASe,0BACPlE,IACAC,IACAM,aACAU,WACAoB,IACAC,IACA2E,cACA9D;IAEJ;IAEAjB,6BAA6BhB,MAAM,GAAG;IAEtC,MAAMgG,YAAYlG,SAAS,CAACE,SAAS,EAAE;IACvC,MAAM8C,QAAQ/C,UAAUM,uBAAuB,CAAC2F,WAAWxE;IAC3DsB,MAAMxC,MAAM,GAAG8E,iBAAiB9E,MAAM,CAACN,SAAS,EAAE,GAAGM;IACrD,MAAMqC,OAAO5C,UAAU6C,uBAAuB,CAACE,OAAOpB;IACtD,gLAAU,CAACmB,IAAI,CAACF,MAAMoD,cAAcD,cAAc;IAElD,OAAOC;AACT;AAEA;;;;;;;;;;;;;;;;;;;CAmBC,GACDnH,iBAAiBmD,oBAAoB,GAAG,SAAUmD,OAAO;IACvD,MAAMoB,cAAc1H,iBAAiBqG,WAAW,CAACC;IACjD,MAAMqB,OAAOD,YAAYtG,MAAM,GAAG;IAClC,MAAM+F,eAAe,IAAI7F,MAAMqG;IAC/B,IAAK,IAAIpG,IAAI,GAAGA,IAAIoG,MAAMpG,IAAK;QAC7B4F,YAAY,CAAC5F,EAAE,GAAG,gLAAU,CAACqG,MAAM,CAACF,aAAanG,IAAI;IACvD;IACA,OAAO4F;AACT;AAEA;;;;;;;;;;;;;;;;;;;CAmBC,GACDnH,iBAAiBoE,yBAAyB,GAAG,SAAUkC,OAAO;IAC5D,MAAMoB,cAAc1H,iBAAiBuH,gBAAgB,CAACjB;IACtD,MAAMqB,OAAOD,YAAYtG,MAAM,GAAG;IAClC,MAAM+F,eAAe,IAAI7F,MAAMqG;IAC/B,IAAK,IAAIpG,IAAI,GAAGA,IAAIoG,MAAMpG,IAAK;QAC7B4F,YAAY,CAAC5F,EAAE,GAAG,gLAAU,CAACqG,MAAM,CAACF,aAAanG,IAAI;IACvD;IACA,OAAO4F;AACT;uCACenH","ignoreList":[0]}},
    {"offset": {"line": 35399, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PolylineVolumeGeometryLibrary.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport CornerType from \"./CornerType.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Transforms from \"./Transforms.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\n\nconst scratch2Array = [new Cartesian3(), new Cartesian3()];\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4 = new Cartesian3();\nconst scratchCartesian5 = new Cartesian3();\nconst scratchCartesian6 = new Cartesian3();\nconst scratchCartesian7 = new Cartesian3();\nconst scratchCartesian8 = new Cartesian3();\nconst scratchCartesian9 = new Cartesian3();\n\nconst scratch1 = new Cartesian3();\nconst scratch2 = new Cartesian3();\n\n/**\n * @private\n */\nconst PolylineVolumeGeometryLibrary = {};\n\nlet cartographic = new Cartographic();\nfunction scaleToSurface(positions, ellipsoid) {\n  const heights = new Array(positions.length);\n  for (let i = 0; i < positions.length; i++) {\n    const pos = positions[i];\n    cartographic = ellipsoid.cartesianToCartographic(pos, cartographic);\n    heights[i] = cartographic.height;\n    positions[i] = ellipsoid.scaleToGeodeticSurface(pos, pos);\n  }\n  return heights;\n}\n\nfunction subdivideHeights(points, h0, h1, granularity) {\n  const p0 = points[0];\n  const p1 = points[1];\n  const angleBetween = Cartesian3.angleBetween(p0, p1);\n  const numPoints = Math.ceil(angleBetween / granularity);\n  const heights = new Array(numPoints);\n  let i;\n  if (h0 === h1) {\n    for (i = 0; i < numPoints; i++) {\n      heights[i] = h0;\n    }\n    heights.push(h1);\n    return heights;\n  }\n\n  const dHeight = h1 - h0;\n  const heightPerVertex = dHeight / numPoints;\n\n  for (i = 1; i < numPoints; i++) {\n    const h = h0 + i * heightPerVertex;\n    heights[i] = h;\n  }\n\n  heights[0] = h0;\n  heights.push(h1);\n  return heights;\n}\n\nconst nextScratch = new Cartesian3();\nconst prevScratch = new Cartesian3();\n\nfunction computeRotationAngle(start, end, position, ellipsoid) {\n  const tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n  const next = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, start, nextScratch),\n    nextScratch,\n  );\n  const prev = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, end, prevScratch),\n    prevScratch,\n  );\n  const angle = Cartesian2.angleBetween(next, prev);\n\n  return prev.x * next.y - prev.y * next.x >= 0.0 ? -angle : angle;\n}\n\nconst negativeX = new Cartesian3(-1, 0, 0);\nlet transform = new Matrix4();\nconst translation = new Matrix4();\nlet rotationZ = new Matrix3();\nconst scaleMatrix = Matrix3.IDENTITY.clone();\nconst westScratch = new Cartesian3();\nconst finalPosScratch = new Cartesian4();\nconst heightCartesian = new Cartesian3();\nfunction addPosition(\n  center,\n  left,\n  shape,\n  finalPositions,\n  ellipsoid,\n  height,\n  xScalar,\n  repeat,\n) {\n  let west = westScratch;\n  let finalPosition = finalPosScratch;\n  transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, transform);\n\n  west = Matrix4.multiplyByPointAsVector(transform, negativeX, west);\n  west = Cartesian3.normalize(west, west);\n  const angle = computeRotationAngle(west, left, center, ellipsoid);\n  rotationZ = Matrix3.fromRotationZ(angle, rotationZ);\n\n  heightCartesian.z = height;\n  transform = Matrix4.multiplyTransformation(\n    transform,\n    Matrix4.fromRotationTranslation(rotationZ, heightCartesian, translation),\n    transform,\n  );\n  const scale = scaleMatrix;\n  scale[0] = xScalar;\n\n  for (let j = 0; j < repeat; j++) {\n    for (let i = 0; i < shape.length; i += 3) {\n      finalPosition = Cartesian3.fromArray(shape, i, finalPosition);\n      finalPosition = Matrix3.multiplyByVector(\n        scale,\n        finalPosition,\n        finalPosition,\n      );\n      finalPosition = Matrix4.multiplyByPoint(\n        transform,\n        finalPosition,\n        finalPosition,\n      );\n      finalPositions.push(finalPosition.x, finalPosition.y, finalPosition.z);\n    }\n  }\n\n  return finalPositions;\n}\n\nconst centerScratch = new Cartesian3();\nfunction addPositions(\n  centers,\n  left,\n  shape,\n  finalPositions,\n  ellipsoid,\n  heights,\n  xScalar,\n) {\n  for (let i = 0; i < centers.length; i += 3) {\n    const center = Cartesian3.fromArray(centers, i, centerScratch);\n    finalPositions = addPosition(\n      center,\n      left,\n      shape,\n      finalPositions,\n      ellipsoid,\n      heights[i / 3],\n      xScalar,\n      1,\n    );\n  }\n  return finalPositions;\n}\n\nfunction convertShapeTo3DDuplicate(shape2D, boundingRectangle) {\n  //orientate 2D shape to XZ plane center at (0, 0, 0), duplicate points\n  const length = shape2D.length;\n  const shape = new Array(length * 6);\n  let index = 0;\n  const xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n  const yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n  let point = shape2D[0];\n  shape[index++] = point.x - xOffset;\n  shape[index++] = 0.0;\n  shape[index++] = point.y - yOffset;\n  for (let i = 1; i < length; i++) {\n    point = shape2D[i];\n    const x = point.x - xOffset;\n    const z = point.y - yOffset;\n    shape[index++] = x;\n    shape[index++] = 0.0;\n    shape[index++] = z;\n\n    shape[index++] = x;\n    shape[index++] = 0.0;\n    shape[index++] = z;\n  }\n  point = shape2D[0];\n  shape[index++] = point.x - xOffset;\n  shape[index++] = 0.0;\n  shape[index++] = point.y - yOffset;\n\n  return shape;\n}\n\nfunction convertShapeTo3D(shape2D, boundingRectangle) {\n  //orientate 2D shape to XZ plane center at (0, 0, 0)\n  const length = shape2D.length;\n  const shape = new Array(length * 3);\n  let index = 0;\n  const xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n  const yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n  for (let i = 0; i < length; i++) {\n    shape[index++] = shape2D[i].x - xOffset;\n    shape[index++] = 0;\n    shape[index++] = shape2D[i].y - yOffset;\n  }\n\n  return shape;\n}\n\nconst quaterion = new Quaternion();\nconst startPointScratch = new Cartesian3();\nconst rotMatrix = new Matrix3();\nfunction computeRoundCorner(\n  pivot,\n  startPoint,\n  endPoint,\n  cornerType,\n  leftIsOutside,\n  ellipsoid,\n  finalPositions,\n  shape,\n  height,\n  duplicatePoints,\n) {\n  const angle = Cartesian3.angleBetween(\n    Cartesian3.subtract(startPoint, pivot, scratch1),\n    Cartesian3.subtract(endPoint, pivot, scratch2),\n  );\n  const granularity =\n    cornerType === CornerType.BEVELED\n      ? 0\n      : Math.ceil(angle / CesiumMath.toRadians(5));\n\n  let m;\n  if (leftIsOutside) {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(\n        Cartesian3.negate(pivot, scratch1),\n        angle / (granularity + 1),\n        quaterion,\n      ),\n      rotMatrix,\n    );\n  } else {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(pivot, angle / (granularity + 1), quaterion),\n      rotMatrix,\n    );\n  }\n\n  let left;\n  let surfacePoint;\n  startPoint = Cartesian3.clone(startPoint, startPointScratch);\n  if (granularity > 0) {\n    const repeat = duplicatePoints ? 2 : 1;\n    for (let i = 0; i < granularity; i++) {\n      startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n      left = Cartesian3.subtract(startPoint, pivot, scratch1);\n      left = Cartesian3.normalize(left, left);\n      if (!leftIsOutside) {\n        left = Cartesian3.negate(left, left);\n      }\n      surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n      finalPositions = addPosition(\n        surfacePoint,\n        left,\n        shape,\n        finalPositions,\n        ellipsoid,\n        height,\n        1,\n        repeat,\n      );\n    }\n  } else {\n    left = Cartesian3.subtract(startPoint, pivot, scratch1);\n    left = Cartesian3.normalize(left, left);\n    if (!leftIsOutside) {\n      left = Cartesian3.negate(left, left);\n    }\n    surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n    finalPositions = addPosition(\n      surfacePoint,\n      left,\n      shape,\n      finalPositions,\n      ellipsoid,\n      height,\n      1,\n      1,\n    );\n\n    endPoint = Cartesian3.clone(endPoint, startPointScratch);\n    left = Cartesian3.subtract(endPoint, pivot, scratch1);\n    left = Cartesian3.normalize(left, left);\n    if (!leftIsOutside) {\n      left = Cartesian3.negate(left, left);\n    }\n    surfacePoint = ellipsoid.scaleToGeodeticSurface(endPoint, scratch2);\n    finalPositions = addPosition(\n      surfacePoint,\n      left,\n      shape,\n      finalPositions,\n      ellipsoid,\n      height,\n      1,\n      1,\n    );\n  }\n\n  return finalPositions;\n}\n\nPolylineVolumeGeometryLibrary.removeDuplicatesFromShape = function (\n  shapePositions,\n) {\n  const length = shapePositions.length;\n  const cleanedPositions = [];\n  for (let i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n    const v0 = shapePositions[i0];\n    const v1 = shapePositions[i1];\n\n    if (!Cartesian2.equals(v0, v1)) {\n      cleanedPositions.push(v1); // Shallow copy!\n    }\n  }\n\n  return cleanedPositions;\n};\n\nPolylineVolumeGeometryLibrary.angleIsGreaterThanPi = function (\n  forward,\n  backward,\n  position,\n  ellipsoid,\n) {\n  const tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n  const next = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, forward, nextScratch),\n    nextScratch,\n  );\n  const prev = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, backward, prevScratch),\n    prevScratch,\n  );\n\n  return prev.x * next.y - prev.y * next.x >= 0.0;\n};\n\nconst scratchForwardProjection = new Cartesian3();\nconst scratchBackwardProjection = new Cartesian3();\n\nPolylineVolumeGeometryLibrary.computePositions = function (\n  positions,\n  shape2D,\n  boundingRectangle,\n  geometry,\n  duplicatePoints,\n) {\n  const ellipsoid = geometry._ellipsoid;\n  const heights = scaleToSurface(positions, ellipsoid);\n  const granularity = geometry._granularity;\n  const cornerType = geometry._cornerType;\n  const shapeForSides = duplicatePoints\n    ? convertShapeTo3DDuplicate(shape2D, boundingRectangle)\n    : convertShapeTo3D(shape2D, boundingRectangle);\n  const shapeForEnds = duplicatePoints\n    ? convertShapeTo3D(shape2D, boundingRectangle)\n    : undefined;\n  const heightOffset = boundingRectangle.height / 2;\n  const width = boundingRectangle.width / 2;\n  let length = positions.length;\n  let finalPositions = [];\n  let ends = duplicatePoints ? [] : undefined;\n\n  let forward = scratchCartesian1;\n  let backward = scratchCartesian2;\n  let cornerDirection = scratchCartesian3;\n  let surfaceNormal = scratchCartesian4;\n  let pivot = scratchCartesian5;\n  let start = scratchCartesian6;\n  let end = scratchCartesian7;\n  let left = scratchCartesian8;\n  let previousPosition = scratchCartesian9;\n\n  let position = positions[0];\n  let nextPosition = positions[1];\n  surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n  forward = Cartesian3.subtract(nextPosition, position, forward);\n  forward = Cartesian3.normalize(forward, forward);\n  left = Cartesian3.cross(surfaceNormal, forward, left);\n  left = Cartesian3.normalize(left, left);\n  let h0 = heights[0];\n  let h1 = heights[1];\n  if (duplicatePoints) {\n    ends = addPosition(\n      position,\n      left,\n      shapeForEnds,\n      ends,\n      ellipsoid,\n      h0 + heightOffset,\n      1,\n      1,\n    );\n  }\n  previousPosition = Cartesian3.clone(position, previousPosition);\n  position = nextPosition;\n  backward = Cartesian3.negate(forward, backward);\n  let subdividedHeights;\n  let subdividedPositions;\n  for (let i = 1; i < length - 1; i++) {\n    const repeat = duplicatePoints ? 2 : 1;\n    nextPosition = positions[i + 1];\n    if (position.equals(nextPosition)) {\n      oneTimeWarning(\n        \"Positions are too close and are considered equivalent with rounding error.\",\n      );\n      continue;\n    }\n    forward = Cartesian3.subtract(nextPosition, position, forward);\n    forward = Cartesian3.normalize(forward, forward);\n    surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n\n    const forwardProjection = Cartesian3.multiplyByScalar(\n      surfaceNormal,\n      Cartesian3.dot(forward, surfaceNormal),\n      scratchForwardProjection,\n    );\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n    Cartesian3.normalize(forwardProjection, forwardProjection);\n\n    const backwardProjection = Cartesian3.multiplyByScalar(\n      surfaceNormal,\n      Cartesian3.dot(backward, surfaceNormal),\n      scratchBackwardProjection,\n    );\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n    Cartesian3.normalize(backwardProjection, backwardProjection);\n\n    const doCorner = !CesiumMath.equalsEpsilon(\n      Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)),\n      1.0,\n      CesiumMath.EPSILON7,\n    );\n\n    if (doCorner) {\n      cornerDirection = Cartesian3.add(forward, backward, cornerDirection);\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      cornerDirection = Cartesian3.cross(\n        cornerDirection,\n        surfaceNormal,\n        cornerDirection,\n      );\n      cornerDirection = Cartesian3.cross(\n        surfaceNormal,\n        cornerDirection,\n        cornerDirection,\n      );\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      const scalar =\n        1 /\n        Math.max(\n          0.25,\n          Cartesian3.magnitude(\n            Cartesian3.cross(cornerDirection, backward, scratch1),\n          ),\n        );\n      const leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(\n        forward,\n        backward,\n        position,\n        ellipsoid,\n      );\n      if (leftIsOutside) {\n        pivot = Cartesian3.add(\n          position,\n          Cartesian3.multiplyByScalar(\n            cornerDirection,\n            scalar * width,\n            cornerDirection,\n          ),\n          pivot,\n        );\n        start = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, width, start),\n          start,\n        );\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(\n          scratch2Array,\n          h0 + heightOffset,\n          h1 + heightOffset,\n          granularity,\n        );\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scratch2Array,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        finalPositions = addPositions(\n          subdividedPositions,\n          left,\n          shapeForSides,\n          finalPositions,\n          ellipsoid,\n          subdividedHeights,\n          1,\n        );\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        end = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, width, end),\n          end,\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          computeRoundCorner(\n            pivot,\n            start,\n            end,\n            cornerType,\n            leftIsOutside,\n            ellipsoid,\n            finalPositions,\n            shapeForSides,\n            h1 + heightOffset,\n            duplicatePoints,\n          );\n        } else {\n          cornerDirection = Cartesian3.negate(cornerDirection, cornerDirection);\n          finalPositions = addPosition(\n            position,\n            cornerDirection,\n            shapeForSides,\n            finalPositions,\n            ellipsoid,\n            h1 + heightOffset,\n            scalar,\n            repeat,\n          );\n        }\n        previousPosition = Cartesian3.clone(end, previousPosition);\n      } else {\n        pivot = Cartesian3.add(\n          position,\n          Cartesian3.multiplyByScalar(\n            cornerDirection,\n            scalar * width,\n            cornerDirection,\n          ),\n          pivot,\n        );\n        start = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, -width, start),\n          start,\n        );\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(\n          scratch2Array,\n          h0 + heightOffset,\n          h1 + heightOffset,\n          granularity,\n        );\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scratch2Array,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        finalPositions = addPositions(\n          subdividedPositions,\n          left,\n          shapeForSides,\n          finalPositions,\n          ellipsoid,\n          subdividedHeights,\n          1,\n        );\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        end = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, -width, end),\n          end,\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          computeRoundCorner(\n            pivot,\n            start,\n            end,\n            cornerType,\n            leftIsOutside,\n            ellipsoid,\n            finalPositions,\n            shapeForSides,\n            h1 + heightOffset,\n            duplicatePoints,\n          );\n        } else {\n          finalPositions = addPosition(\n            position,\n            cornerDirection,\n            shapeForSides,\n            finalPositions,\n            ellipsoid,\n            h1 + heightOffset,\n            scalar,\n            repeat,\n          );\n        }\n        previousPosition = Cartesian3.clone(end, previousPosition);\n      }\n      backward = Cartesian3.negate(forward, backward);\n    } else {\n      finalPositions = addPosition(\n        previousPosition,\n        left,\n        shapeForSides,\n        finalPositions,\n        ellipsoid,\n        h0 + heightOffset,\n        1,\n        1,\n      );\n      previousPosition = position;\n    }\n    h0 = h1;\n    h1 = heights[i + 1];\n    position = nextPosition;\n  }\n\n  scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n  scratch2Array[1] = Cartesian3.clone(position, scratch2Array[1]);\n  subdividedHeights = subdivideHeights(\n    scratch2Array,\n    h0 + heightOffset,\n    h1 + heightOffset,\n    granularity,\n  );\n  subdividedPositions = PolylinePipeline.generateArc({\n    positions: scratch2Array,\n    granularity: granularity,\n    ellipsoid: ellipsoid,\n  });\n  finalPositions = addPositions(\n    subdividedPositions,\n    left,\n    shapeForSides,\n    finalPositions,\n    ellipsoid,\n    subdividedHeights,\n    1,\n  );\n  if (duplicatePoints) {\n    ends = addPosition(\n      position,\n      left,\n      shapeForEnds,\n      ends,\n      ellipsoid,\n      h1 + heightOffset,\n      1,\n      1,\n    );\n  }\n\n  length = finalPositions.length;\n  const posLength = duplicatePoints ? length + ends.length : length;\n  const combinedPositions = new Float64Array(posLength);\n  combinedPositions.set(finalPositions);\n  if (duplicatePoints) {\n    combinedPositions.set(ends, length);\n  }\n\n  return combinedPositions;\n};\nexport default PolylineVolumeGeometryLibrary;\n"],"names":["scratch2Array","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCartesian7","scratchCartesian8","scratchCartesian9","scratch1","scratch2","PolylineVolumeGeometryLibrary","cartographic","scaleToSurface","positions","ellipsoid","heights","Array","length","i","pos","cartesianToCartographic","height","scaleToGeodeticSurface","subdivideHeights","points","h0","h1","granularity","p0","p1","angleBetween","numPoints","Math","ceil","push","dHeight","heightPerVertex","h","nextScratch","prevScratch","computeRotationAngle","start","end","position","tangentPlane","next","projectPointOntoPlane","add","prev","angle","x","y","negativeX","transform","translation","rotationZ","scaleMatrix","IDENTITY","clone","westScratch","finalPosScratch","heightCartesian","addPosition","center","left","shape","finalPositions","xScalar","repeat","west","finalPosition","eastNorthUpToFixedFrame","multiplyByPointAsVector","normalize","fromRotationZ","z","multiplyTransformation","fromRotationTranslation","scale","j","fromArray","multiplyByVector","multiplyByPoint","centerScratch","addPositions","centers","convertShapeTo3DDuplicate","shape2D","boundingRectangle","index","xOffset","width","yOffset","point","convertShapeTo3D","quaterion","startPointScratch","rotMatrix","computeRoundCorner","pivot","startPoint","endPoint","cornerType","leftIsOutside","duplicatePoints","subtract","BEVELED","toRadians","m","fromQuaternion","fromAxisAngle","negate","surfacePoint","removeDuplicatesFromShape","shapePositions","cleanedPositions","i0","i1","v0","v1","equals","angleIsGreaterThanPi","forward","backward","scratchForwardProjection","scratchBackwardProjection","computePositions","geometry","_ellipsoid","_granularity","_cornerType","shapeForSides","shapeForEnds","undefined","heightOffset","ends","cornerDirection","surfaceNormal","previousPosition","nextPosition","geodeticSurfaceNormal","cross","subdividedHeights","subdividedPositions","forwardProjection","multiplyByScalar","dot","backwardProjection","doCorner","equalsEpsilon","abs","EPSILON7","scalar","max","magnitude","generateArc","ROUNDED","posLength","combinedPositions","Float64Array","set"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 35779, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/CorridorGeometryLibrary.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport CornerType from \"./CornerType.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PolylineVolumeGeometryLibrary from \"./PolylineVolumeGeometryLibrary.js\";\nimport Quaternion from \"./Quaternion.js\";\n\n/**\n * @private\n */\nconst CorridorGeometryLibrary = {};\n\nconst scratch1 = new Cartesian3();\nconst scratch2 = new Cartesian3();\nconst scratch3 = new Cartesian3();\nconst scratch4 = new Cartesian3();\n\nconst scaleArray2 = [new Cartesian3(), new Cartesian3()];\n\nconst cartesian1 = new Cartesian3();\nconst cartesian2 = new Cartesian3();\nconst cartesian3 = new Cartesian3();\nconst cartesian4 = new Cartesian3();\nconst cartesian5 = new Cartesian3();\nconst cartesian6 = new Cartesian3();\nconst cartesian7 = new Cartesian3();\nconst cartesian8 = new Cartesian3();\nconst cartesian9 = new Cartesian3();\nconst cartesian10 = new Cartesian3();\n\nconst quaterion = new Quaternion();\nconst rotMatrix = new Matrix3();\nfunction computeRoundCorner(\n  cornerPoint,\n  startPoint,\n  endPoint,\n  cornerType,\n  leftIsOutside,\n) {\n  const angle = Cartesian3.angleBetween(\n    Cartesian3.subtract(startPoint, cornerPoint, scratch1),\n    Cartesian3.subtract(endPoint, cornerPoint, scratch2),\n  );\n  const granularity =\n    cornerType === CornerType.BEVELED\n      ? 1\n      : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;\n\n  const size = granularity * 3;\n  const array = new Array(size);\n\n  array[size - 3] = endPoint.x;\n  array[size - 2] = endPoint.y;\n  array[size - 1] = endPoint.z;\n\n  let m;\n  if (leftIsOutside) {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(\n        Cartesian3.negate(cornerPoint, scratch1),\n        angle / granularity,\n        quaterion,\n      ),\n      rotMatrix,\n    );\n  } else {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion),\n      rotMatrix,\n    );\n  }\n\n  let index = 0;\n  startPoint = Cartesian3.clone(startPoint, scratch1);\n  for (let i = 0; i < granularity; i++) {\n    startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n    array[index++] = startPoint.x;\n    array[index++] = startPoint.y;\n    array[index++] = startPoint.z;\n  }\n\n  return array;\n}\n\nfunction addEndCaps(calculatedPositions) {\n  let cornerPoint = cartesian1;\n  let startPoint = cartesian2;\n  let endPoint = cartesian3;\n\n  let leftEdge = calculatedPositions[1];\n  startPoint = Cartesian3.fromArray(\n    calculatedPositions[1],\n    leftEdge.length - 3,\n    startPoint,\n  );\n  endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n  const firstEndCap = computeRoundCorner(\n    cornerPoint,\n    startPoint,\n    endPoint,\n    CornerType.ROUNDED,\n    false,\n  );\n\n  const length = calculatedPositions.length - 1;\n  const rightEdge = calculatedPositions[length - 1];\n  leftEdge = calculatedPositions[length];\n  startPoint = Cartesian3.fromArray(\n    rightEdge,\n    rightEdge.length - 3,\n    startPoint,\n  );\n  endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n  const lastEndCap = computeRoundCorner(\n    cornerPoint,\n    startPoint,\n    endPoint,\n    CornerType.ROUNDED,\n    false,\n  );\n\n  return [firstEndCap, lastEndCap];\n}\n\nfunction computeMiteredCorner(\n  position,\n  leftCornerDirection,\n  lastPoint,\n  leftIsOutside,\n) {\n  let cornerPoint = scratch1;\n  if (leftIsOutside) {\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n  } else {\n    leftCornerDirection = Cartesian3.negate(\n      leftCornerDirection,\n      leftCornerDirection,\n    );\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n  }\n  return [\n    cornerPoint.x,\n    cornerPoint.y,\n    cornerPoint.z,\n    lastPoint.x,\n    lastPoint.y,\n    lastPoint.z,\n  ];\n}\n\nfunction addShiftedPositions(positions, left, scalar, calculatedPositions) {\n  const rightPositions = new Array(positions.length);\n  const leftPositions = new Array(positions.length);\n  const scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);\n  const scaledRight = Cartesian3.negate(scaledLeft, scratch2);\n  let rightIndex = 0;\n  let leftIndex = positions.length - 1;\n\n  for (let i = 0; i < positions.length; i += 3) {\n    const pos = Cartesian3.fromArray(positions, i, scratch3);\n    const rightPos = Cartesian3.add(pos, scaledRight, scratch4);\n    rightPositions[rightIndex++] = rightPos.x;\n    rightPositions[rightIndex++] = rightPos.y;\n    rightPositions[rightIndex++] = rightPos.z;\n\n    const leftPos = Cartesian3.add(pos, scaledLeft, scratch4);\n    leftPositions[leftIndex--] = leftPos.z;\n    leftPositions[leftIndex--] = leftPos.y;\n    leftPositions[leftIndex--] = leftPos.x;\n  }\n  calculatedPositions.push(rightPositions, leftPositions);\n\n  return calculatedPositions;\n}\n\n/**\n * @private\n */\nCorridorGeometryLibrary.addAttribute = function (\n  attribute,\n  value,\n  front,\n  back,\n) {\n  const x = value.x;\n  const y = value.y;\n  const z = value.z;\n  if (defined(front)) {\n    attribute[front] = x;\n    attribute[front + 1] = y;\n    attribute[front + 2] = z;\n  }\n  if (defined(back)) {\n    attribute[back] = z;\n    attribute[back - 1] = y;\n    attribute[back - 2] = x;\n  }\n};\n\nconst scratchForwardProjection = new Cartesian3();\nconst scratchBackwardProjection = new Cartesian3();\n\n/**\n * @private\n */\nCorridorGeometryLibrary.computePositions = function (params) {\n  const granularity = params.granularity;\n  const positions = params.positions;\n  const ellipsoid = params.ellipsoid;\n  const width = params.width / 2;\n  const cornerType = params.cornerType;\n  const saveAttributes = params.saveAttributes;\n  let normal = cartesian1;\n  let forward = cartesian2;\n  let backward = cartesian3;\n  let left = cartesian4;\n  let cornerDirection = cartesian5;\n  let startPoint = cartesian6;\n  let previousPos = cartesian7;\n  let rightPos = cartesian8;\n  let leftPos = cartesian9;\n  let center = cartesian10;\n  let calculatedPositions = [];\n  const calculatedLefts = saveAttributes ? [] : undefined;\n  const calculatedNormals = saveAttributes ? [] : undefined;\n  let position = positions[0]; //add first point\n  let nextPosition = positions[1];\n\n  forward = Cartesian3.normalize(\n    Cartesian3.subtract(nextPosition, position, forward),\n    forward,\n  );\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n  left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n  if (saveAttributes) {\n    calculatedLefts.push(left.x, left.y, left.z);\n    calculatedNormals.push(normal.x, normal.y, normal.z);\n  }\n  previousPos = Cartesian3.clone(position, previousPos);\n  position = nextPosition;\n  backward = Cartesian3.negate(forward, backward);\n\n  let subdividedPositions;\n  const corners = [];\n  let i;\n  const length = positions.length;\n  for (i = 1; i < length - 1; i++) {\n    // add middle points and corners\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n    nextPosition = positions[i + 1];\n    forward = Cartesian3.normalize(\n      Cartesian3.subtract(nextPosition, position, forward),\n      forward,\n    );\n\n    const forwardProjection = Cartesian3.multiplyByScalar(\n      normal,\n      Cartesian3.dot(forward, normal),\n      scratchForwardProjection,\n    );\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n    Cartesian3.normalize(forwardProjection, forwardProjection);\n\n    const backwardProjection = Cartesian3.multiplyByScalar(\n      normal,\n      Cartesian3.dot(backward, normal),\n      scratchBackwardProjection,\n    );\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n    Cartesian3.normalize(backwardProjection, backwardProjection);\n\n    const doCorner = !CesiumMath.equalsEpsilon(\n      Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)),\n      1.0,\n      CesiumMath.EPSILON7,\n    );\n\n    if (doCorner) {\n      cornerDirection = Cartesian3.normalize(\n        Cartesian3.add(forward, backward, cornerDirection),\n        cornerDirection,\n      );\n      cornerDirection = Cartesian3.cross(\n        cornerDirection,\n        normal,\n        cornerDirection,\n      );\n      cornerDirection = Cartesian3.cross(\n        normal,\n        cornerDirection,\n        cornerDirection,\n      );\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      const scalar =\n        width /\n        Math.max(\n          0.25,\n          Cartesian3.magnitude(\n            Cartesian3.cross(cornerDirection, backward, scratch1),\n          ),\n        );\n      const leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(\n        forward,\n        backward,\n        position,\n        ellipsoid,\n      );\n      cornerDirection = Cartesian3.multiplyByScalar(\n        cornerDirection,\n        scalar,\n        cornerDirection,\n      );\n      if (leftIsOutside) {\n        rightPos = Cartesian3.add(position, cornerDirection, rightPos);\n        center = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width, center),\n          center,\n        );\n        leftPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width * 2, leftPos),\n          leftPos,\n        );\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scaleArray2,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        calculatedPositions = addShiftedPositions(\n          subdividedPositions,\n          left,\n          width,\n          calculatedPositions,\n        );\n        if (saveAttributes) {\n          calculatedLefts.push(left.x, left.y, left.z);\n          calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        startPoint = Cartesian3.clone(leftPos, startPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.cross(normal, forward, left),\n          left,\n        );\n        leftPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width * 2, leftPos),\n          leftPos,\n        );\n        previousPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width, previousPos),\n          previousPos,\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          corners.push({\n            leftPositions: computeRoundCorner(\n              rightPos,\n              startPoint,\n              leftPos,\n              cornerType,\n              leftIsOutside,\n            ),\n          });\n        } else {\n          corners.push({\n            leftPositions: computeMiteredCorner(\n              position,\n              Cartesian3.negate(cornerDirection, cornerDirection),\n              leftPos,\n              leftIsOutside,\n            ),\n          });\n        }\n      } else {\n        leftPos = Cartesian3.add(position, cornerDirection, leftPos);\n        center = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width, center),\n            center,\n          ),\n          center,\n        );\n        rightPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width * 2, rightPos),\n            rightPos,\n          ),\n          rightPos,\n        );\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scaleArray2,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        calculatedPositions = addShiftedPositions(\n          subdividedPositions,\n          left,\n          width,\n          calculatedPositions,\n        );\n        if (saveAttributes) {\n          calculatedLefts.push(left.x, left.y, left.z);\n          calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        startPoint = Cartesian3.clone(rightPos, startPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.cross(normal, forward, left),\n          left,\n        );\n        rightPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width * 2, rightPos),\n            rightPos,\n          ),\n          rightPos,\n        );\n        previousPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width, previousPos),\n            previousPos,\n          ),\n          previousPos,\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          corners.push({\n            rightPositions: computeRoundCorner(\n              leftPos,\n              startPoint,\n              rightPos,\n              cornerType,\n              leftIsOutside,\n            ),\n          });\n        } else {\n          corners.push({\n            rightPositions: computeMiteredCorner(\n              position,\n              cornerDirection,\n              rightPos,\n              leftIsOutside,\n            ),\n          });\n        }\n      }\n      backward = Cartesian3.negate(forward, backward);\n    }\n    position = nextPosition;\n  }\n\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n  scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n  scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);\n  subdividedPositions = PolylinePipeline.generateArc({\n    positions: scaleArray2,\n    granularity: granularity,\n    ellipsoid: ellipsoid,\n  });\n  calculatedPositions = addShiftedPositions(\n    subdividedPositions,\n    left,\n    width,\n    calculatedPositions,\n  );\n  if (saveAttributes) {\n    calculatedLefts.push(left.x, left.y, left.z);\n    calculatedNormals.push(normal.x, normal.y, normal.z);\n  }\n\n  let endPositions;\n  if (cornerType === CornerType.ROUNDED) {\n    endPositions = addEndCaps(calculatedPositions);\n  }\n\n  return {\n    positions: calculatedPositions,\n    corners: corners,\n    lefts: calculatedLefts,\n    normals: calculatedNormals,\n    endPositions: endPositions,\n  };\n};\nexport default CorridorGeometryLibrary;\n"],"names":["CorridorGeometryLibrary","scratch1","scratch2","scratch3","scratch4","scaleArray2","cartesian1","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","cartesian7","cartesian8","cartesian9","cartesian10","quaterion","rotMatrix","computeRoundCorner","cornerPoint","startPoint","endPoint","cornerType","leftIsOutside","angle","angleBetween","subtract","granularity","BEVELED","Math","ceil","toRadians","size","array","Array","x","y","z","m","fromQuaternion","fromAxisAngle","negate","index","clone","i","multiplyByVector","addEndCaps","calculatedPositions","leftEdge","fromArray","length","midpoint","firstEndCap","ROUNDED","rightEdge","lastEndCap","computeMiteredCorner","position","leftCornerDirection","lastPoint","add","addShiftedPositions","positions","left","scalar","rightPositions","leftPositions","scaledLeft","multiplyByScalar","scaledRight","rightIndex","leftIndex","pos","rightPos","leftPos","push","addAttribute","attribute","value","front","back","scratchForwardProjection","scratchBackwardProjection","computePositions","params","ellipsoid","width","saveAttributes","normal","forward","backward","cornerDirection","previousPos","center","calculatedLefts","undefined","calculatedNormals","nextPosition","normalize","geodeticSurfaceNormal","cross","subdividedPositions","corners","forwardProjection","dot","backwardProjection","doCorner","equalsEpsilon","abs","EPSILON7","max","magnitude","angleIsGreaterThanPi","generateArc","endPositions","lefts","normals"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 36075, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PolygonPipeline.js"],"sourcesContent":["import earcut from \"earcut\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\nconst scaleToGeodeticHeightN = new Cartesian3();\nconst scaleToGeodeticHeightP = new Cartesian3();\n\n/**\n * @private\n */\nconst PolygonPipeline = {};\n\n/**\n * @exception {DeveloperError} At least three positions are required.\n */\nPolygonPipeline.computeArea2D = function (positions) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"positions.length\",\n    positions.length,\n    3,\n  );\n  //>>includeEnd('debug');\n\n  const length = positions.length;\n  let area = 0.0;\n\n  for (let i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n    const v0 = positions[i0];\n    const v1 = positions[i1];\n\n    area += v0.x * v1.y - v1.x * v0.y;\n  }\n\n  return area * 0.5;\n};\n\n/**\n * @returns {WindingOrder} The winding order.\n *\n * @exception {DeveloperError} At least three positions are required.\n */\nPolygonPipeline.computeWindingOrder2D = function (positions) {\n  const area = PolygonPipeline.computeArea2D(positions);\n  return area > 0.0 ? WindingOrder.COUNTER_CLOCKWISE : WindingOrder.CLOCKWISE;\n};\n\n/**\n * Triangulate a polygon.\n *\n * @param {Cartesian2[]} positions Cartesian2 array containing the vertices of the polygon\n * @param {number[]} [holes] An array of the staring indices of the holes.\n * @returns {number[]} Index array representing triangles that fill the polygon\n */\nPolygonPipeline.triangulate = function (positions, holes) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  const flattenedPositions = Cartesian2.packArray(positions);\n  return earcut(flattenedPositions, holes, 2);\n};\n\nconst subdivisionV0Scratch = new Cartesian3();\nconst subdivisionV1Scratch = new Cartesian3();\nconst subdivisionV2Scratch = new Cartesian3();\nconst subdivisionS0Scratch = new Cartesian3();\nconst subdivisionS1Scratch = new Cartesian3();\nconst subdivisionS2Scratch = new Cartesian3();\nconst subdivisionMidScratch = new Cartesian3();\nconst subdivisionT0Scratch = new Cartesian2();\nconst subdivisionT1Scratch = new Cartesian2();\nconst subdivisionT2Scratch = new Cartesian2();\nconst subdivisionTexcoordMidScratch = new Cartesian2();\n\n/**\n * Subdivides positions and raises points to the surface of the ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid the polygon in on.\n * @param {Cartesian3[]} positions An array of {@link Cartesian3} positions of the polygon.\n * @param {number[]} indices An array of indices that determines the triangles in the polygon.\n * @param {Cartesian2[]} texcoords An optional array of {@link Cartesian2} texture coordinates of the polygon.\n * @param {number} [granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n *\n * @exception {DeveloperError} At least three indices are required.\n * @exception {DeveloperError} The number of indices must be divisable by three.\n * @exception {DeveloperError} Granularity must be greater than zero.\n */\nPolygonPipeline.computeSubdivision = function (\n  ellipsoid,\n  positions,\n  indices,\n  texcoords,\n  granularity,\n) {\n  granularity = granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n\n  const hasTexcoords = defined(texcoords);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.defined(\"positions\", positions);\n  Check.defined(\"indices\", indices);\n  Check.typeOf.number.greaterThanOrEquals(\"indices.length\", indices.length, 3);\n  Check.typeOf.number.equals(\"indices.length % 3\", \"0\", indices.length % 3, 0);\n  Check.typeOf.number.greaterThan(\"granularity\", granularity, 0.0);\n  //>>includeEnd('debug');\n\n  // triangles that need (or might need) to be subdivided.\n  const triangles = indices.slice(0);\n\n  // New positions due to edge splits are appended to the positions list.\n  let i;\n  const length = positions.length;\n  const subdividedPositions = new Array(length * 3);\n  const subdividedTexcoords = new Array(length * 2);\n  let q = 0;\n  let p = 0;\n  for (i = 0; i < length; i++) {\n    const item = positions[i];\n    subdividedPositions[q++] = item.x;\n    subdividedPositions[q++] = item.y;\n    subdividedPositions[q++] = item.z;\n\n    if (hasTexcoords) {\n      const texcoordItem = texcoords[i];\n      subdividedTexcoords[p++] = texcoordItem.x;\n      subdividedTexcoords[p++] = texcoordItem.y;\n    }\n  }\n\n  const subdividedIndices = [];\n\n  // Used to make sure shared edges are not split more than once.\n  const edges = {};\n\n  const radius = ellipsoid.maximumRadius;\n  const minDistance = CesiumMath.chordLength(granularity, radius);\n  const minDistanceSqrd = minDistance * minDistance;\n\n  while (triangles.length > 0) {\n    const i2 = triangles.pop();\n    const i1 = triangles.pop();\n    const i0 = triangles.pop();\n\n    const v0 = Cartesian3.fromArray(\n      subdividedPositions,\n      i0 * 3,\n      subdivisionV0Scratch,\n    );\n    const v1 = Cartesian3.fromArray(\n      subdividedPositions,\n      i1 * 3,\n      subdivisionV1Scratch,\n    );\n    const v2 = Cartesian3.fromArray(\n      subdividedPositions,\n      i2 * 3,\n      subdivisionV2Scratch,\n    );\n\n    let t0, t1, t2;\n    if (hasTexcoords) {\n      t0 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i0 * 2,\n        subdivisionT0Scratch,\n      );\n      t1 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i1 * 2,\n        subdivisionT1Scratch,\n      );\n      t2 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i2 * 2,\n        subdivisionT2Scratch,\n      );\n    }\n\n    const s0 = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(v0, subdivisionS0Scratch),\n      radius,\n      subdivisionS0Scratch,\n    );\n    const s1 = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(v1, subdivisionS1Scratch),\n      radius,\n      subdivisionS1Scratch,\n    );\n    const s2 = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(v2, subdivisionS2Scratch),\n      radius,\n      subdivisionS2Scratch,\n    );\n\n    const g0 = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(s0, s1, subdivisionMidScratch),\n    );\n    const g1 = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(s1, s2, subdivisionMidScratch),\n    );\n    const g2 = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(s2, s0, subdivisionMidScratch),\n    );\n\n    const max = Math.max(g0, g1, g2);\n    let edge;\n    let mid;\n    let midTexcoord;\n\n    // if the max length squared of a triangle edge is greater than the chord length of squared\n    // of the granularity, subdivide the triangle\n    if (max > minDistanceSqrd) {\n      if (g0 === max) {\n        edge = `${Math.min(i0, i1)} ${Math.max(i0, i1)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = Cartesian3.add(v0, v1, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t0, t1, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i0, i, i2);\n        triangles.push(i, i1, i2);\n      } else if (g1 === max) {\n        edge = `${Math.min(i1, i2)} ${Math.max(i1, i2)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = Cartesian3.add(v1, v2, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t1, t2, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i1, i, i0);\n        triangles.push(i, i2, i0);\n      } else if (g2 === max) {\n        edge = `${Math.min(i2, i0)} ${Math.max(i2, i0)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = Cartesian3.add(v2, v0, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t2, t0, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i2, i, i1);\n        triangles.push(i, i0, i1);\n      }\n    } else {\n      subdividedIndices.push(i0);\n      subdividedIndices.push(i1);\n      subdividedIndices.push(i2);\n    }\n  }\n\n  const geometryOptions = {\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: subdividedPositions,\n      }),\n    },\n    indices: subdividedIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  };\n\n  if (hasTexcoords) {\n    geometryOptions.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: subdividedTexcoords,\n    });\n  }\n\n  return new Geometry(geometryOptions);\n};\n\nconst subdivisionC0Scratch = new Cartographic();\nconst subdivisionC1Scratch = new Cartographic();\nconst subdivisionC2Scratch = new Cartographic();\nconst subdivisionCartographicScratch = new Cartographic();\n\n/**\n * Subdivides positions on rhumb lines and raises points to the surface of the ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid the polygon in on.\n * @param {Cartesian3[]} positions An array of {@link Cartesian3} positions of the polygon.\n * @param {number[]} indices An array of indices that determines the triangles in the polygon.\n * @param {Cartesian2[]} texcoords An optional array of {@link Cartesian2} texture coordinates of the polygon.\n * @param {number} [granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n *\n * @exception {DeveloperError} At least three indices are required.\n * @exception {DeveloperError} The number of indices must be divisable by three.\n * @exception {DeveloperError} Granularity must be greater than zero.\n */\nPolygonPipeline.computeRhumbLineSubdivision = function (\n  ellipsoid,\n  positions,\n  indices,\n  texcoords,\n  granularity,\n) {\n  granularity = granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n\n  const hasTexcoords = defined(texcoords);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.defined(\"positions\", positions);\n  Check.defined(\"indices\", indices);\n  Check.typeOf.number.greaterThanOrEquals(\"indices.length\", indices.length, 3);\n  Check.typeOf.number.equals(\"indices.length % 3\", \"0\", indices.length % 3, 0);\n  Check.typeOf.number.greaterThan(\"granularity\", granularity, 0.0);\n  //>>includeEnd('debug');\n\n  // triangles that need (or might need) to be subdivided.\n  const triangles = indices.slice(0);\n\n  // New positions due to edge splits are appended to the positions list.\n  let i;\n  const length = positions.length;\n  const subdividedPositions = new Array(length * 3);\n  const subdividedTexcoords = new Array(length * 2);\n  let q = 0;\n  let p = 0;\n  for (i = 0; i < length; i++) {\n    const item = positions[i];\n    subdividedPositions[q++] = item.x;\n    subdividedPositions[q++] = item.y;\n    subdividedPositions[q++] = item.z;\n\n    if (hasTexcoords) {\n      const texcoordItem = texcoords[i];\n      subdividedTexcoords[p++] = texcoordItem.x;\n      subdividedTexcoords[p++] = texcoordItem.y;\n    }\n  }\n\n  const subdividedIndices = [];\n\n  // Used to make sure shared edges are not split more than once.\n  const edges = {};\n\n  const radius = ellipsoid.maximumRadius;\n  const minDistance = CesiumMath.chordLength(granularity, radius);\n\n  const rhumb0 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  const rhumb1 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  const rhumb2 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n\n  while (triangles.length > 0) {\n    const i2 = triangles.pop();\n    const i1 = triangles.pop();\n    const i0 = triangles.pop();\n\n    const v0 = Cartesian3.fromArray(\n      subdividedPositions,\n      i0 * 3,\n      subdivisionV0Scratch,\n    );\n    const v1 = Cartesian3.fromArray(\n      subdividedPositions,\n      i1 * 3,\n      subdivisionV1Scratch,\n    );\n    const v2 = Cartesian3.fromArray(\n      subdividedPositions,\n      i2 * 3,\n      subdivisionV2Scratch,\n    );\n\n    let t0, t1, t2;\n    if (hasTexcoords) {\n      t0 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i0 * 2,\n        subdivisionT0Scratch,\n      );\n      t1 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i1 * 2,\n        subdivisionT1Scratch,\n      );\n      t2 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i2 * 2,\n        subdivisionT2Scratch,\n      );\n    }\n\n    const c0 = ellipsoid.cartesianToCartographic(v0, subdivisionC0Scratch);\n    const c1 = ellipsoid.cartesianToCartographic(v1, subdivisionC1Scratch);\n    const c2 = ellipsoid.cartesianToCartographic(v2, subdivisionC2Scratch);\n\n    rhumb0.setEndPoints(c0, c1);\n    const g0 = rhumb0.surfaceDistance;\n    rhumb1.setEndPoints(c1, c2);\n    const g1 = rhumb1.surfaceDistance;\n    rhumb2.setEndPoints(c2, c0);\n    const g2 = rhumb2.surfaceDistance;\n\n    const max = Math.max(g0, g1, g2);\n    let edge;\n    let mid;\n    let midHeight;\n    let midCartesian3;\n    let midTexcoord;\n\n    // if the max length squared of a triangle edge is greater than granularity, subdivide the triangle\n    if (max > minDistance) {\n      if (g0 === max) {\n        edge = `${Math.min(i0, i1)} ${Math.max(i0, i1)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = rhumb0.interpolateUsingFraction(\n            0.5,\n            subdivisionCartographicScratch,\n          );\n          midHeight = (c0.height + c1.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(\n            mid.longitude,\n            mid.latitude,\n            midHeight,\n            ellipsoid,\n            subdivisionMidScratch,\n          );\n          subdividedPositions.push(\n            midCartesian3.x,\n            midCartesian3.y,\n            midCartesian3.z,\n          );\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t0, t1, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i0, i, i2);\n        triangles.push(i, i1, i2);\n      } else if (g1 === max) {\n        edge = `${Math.min(i1, i2)} ${Math.max(i1, i2)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = rhumb1.interpolateUsingFraction(\n            0.5,\n            subdivisionCartographicScratch,\n          );\n          midHeight = (c1.height + c2.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(\n            mid.longitude,\n            mid.latitude,\n            midHeight,\n            ellipsoid,\n            subdivisionMidScratch,\n          );\n          subdividedPositions.push(\n            midCartesian3.x,\n            midCartesian3.y,\n            midCartesian3.z,\n          );\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t1, t2, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i1, i, i0);\n        triangles.push(i, i2, i0);\n      } else if (g2 === max) {\n        edge = `${Math.min(i2, i0)} ${Math.max(i2, i0)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = rhumb2.interpolateUsingFraction(\n            0.5,\n            subdivisionCartographicScratch,\n          );\n          midHeight = (c2.height + c0.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(\n            mid.longitude,\n            mid.latitude,\n            midHeight,\n            ellipsoid,\n            subdivisionMidScratch,\n          );\n          subdividedPositions.push(\n            midCartesian3.x,\n            midCartesian3.y,\n            midCartesian3.z,\n          );\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t2, t0, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i2, i, i1);\n        triangles.push(i, i0, i1);\n      }\n    } else {\n      subdividedIndices.push(i0);\n      subdividedIndices.push(i1);\n      subdividedIndices.push(i2);\n    }\n  }\n\n  const geometryOptions = {\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: subdividedPositions,\n      }),\n    },\n    indices: subdividedIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  };\n\n  if (hasTexcoords) {\n    geometryOptions.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: subdividedTexcoords,\n    });\n  }\n\n  return new Geometry(geometryOptions);\n};\n\n/**\n * Scales each position of a geometry's position attribute to a height, in place.\n *\n * @param {number[]} positions The array of numbers representing the positions to be scaled\n * @param {number} [height=0.0] The desired height to add to the positions\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the positions lie.\n * @param {boolean} [scaleToSurface=true] <code>true</code> if the positions need to be scaled to the surface before the height is added.\n * @returns {number[]} The input array of positions, scaled to height\n */\nPolygonPipeline.scaleToGeodeticHeight = function (\n  positions,\n  height,\n  ellipsoid,\n  scaleToSurface,\n) {\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n\n  let n = scaleToGeodeticHeightN;\n  let p = scaleToGeodeticHeightP;\n\n  height = height ?? 0.0;\n  scaleToSurface = scaleToSurface ?? true;\n\n  if (defined(positions)) {\n    const length = positions.length;\n\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.fromArray(positions, i, p);\n\n      if (scaleToSurface) {\n        p = ellipsoid.scaleToGeodeticSurface(p, p);\n      }\n\n      if (height !== 0) {\n        n = ellipsoid.geodeticSurfaceNormal(p, n);\n\n        Cartesian3.multiplyByScalar(n, height, n);\n        Cartesian3.add(p, n, p);\n      }\n\n      positions[i] = p.x;\n      positions[i + 1] = p.y;\n      positions[i + 2] = p.z;\n    }\n  }\n\n  return positions;\n};\nexport default PolygonPipeline;\n"],"names":["scaleToGeodeticHeightN","scaleToGeodeticHeightP","PolygonPipeline","computeArea2D","positions","defined","typeOf","number","greaterThanOrEquals","length","area","i0","i1","v0","v1","x","y","computeWindingOrder2D","COUNTER_CLOCKWISE","CLOCKWISE","triangulate","holes","flattenedPositions","packArray","subdivisionV0Scratch","subdivisionV1Scratch","subdivisionV2Scratch","subdivisionS0Scratch","subdivisionS1Scratch","subdivisionS2Scratch","subdivisionMidScratch","subdivisionT0Scratch","subdivisionT1Scratch","subdivisionT2Scratch","subdivisionTexcoordMidScratch","computeSubdivision","ellipsoid","indices","texcoords","granularity","RADIANS_PER_DEGREE","hasTexcoords","object","equals","greaterThan","triangles","slice","i","subdividedPositions","Array","subdividedTexcoords","q","p","item","z","texcoordItem","subdividedIndices","edges","radius","maximumRadius","minDistance","chordLength","minDistanceSqrd","i2","pop","fromArray","v2","t0","t1","t2","s0","multiplyByScalar","normalize","s1","s2","g0","magnitudeSquared","subtract","g1","g2","max","Math","edge","mid","midTexcoord","min","add","push","geometryOptions","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","primitiveType","TRIANGLES","st","FLOAT","subdivisionC0Scratch","subdivisionC1Scratch","subdivisionC2Scratch","subdivisionCartographicScratch","computeRhumbLineSubdivision","rhumb0","undefined","rhumb1","rhumb2","c0","cartesianToCartographic","c1","c2","setEndPoints","surfaceDistance","midHeight","midCartesian3","interpolateUsingFraction","height","fromRadians","longitude","latitude","scaleToGeodeticHeight","scaleToSurface","default","n","scaleToGeodeticSurface","geodeticSurfaceNormal"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 36517, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/CorridorGeometry.js"],"sourcesContent":["import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport CorridorGeometryLibrary from \"./CorridorGeometryLibrary.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst cartesian1 = new Cartesian3();\nconst cartesian2 = new Cartesian3();\nconst cartesian3 = new Cartesian3();\nconst cartesian4 = new Cartesian3();\nconst cartesian5 = new Cartesian3();\nconst cartesian6 = new Cartesian3();\n\nconst scratch1 = new Cartesian3();\nconst scratch2 = new Cartesian3();\n\nfunction scaleToSurface(positions, ellipsoid) {\n  for (let i = 0; i < positions.length; i++) {\n    positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n  }\n  return positions;\n}\n\nfunction addNormals(attr, normal, left, front, back, vertexFormat) {\n  const normals = attr.normals;\n  const tangents = attr.tangents;\n  const bitangents = attr.bitangents;\n  const forward = Cartesian3.normalize(\n    Cartesian3.cross(left, normal, scratch1),\n    scratch1,\n  );\n  if (vertexFormat.normal) {\n    CorridorGeometryLibrary.addAttribute(normals, normal, front, back);\n  }\n  if (vertexFormat.tangent) {\n    CorridorGeometryLibrary.addAttribute(tangents, forward, front, back);\n  }\n  if (vertexFormat.bitangent) {\n    CorridorGeometryLibrary.addAttribute(bitangents, left, front, back);\n  }\n}\n\nfunction combine(computedPositions, vertexFormat, ellipsoid) {\n  const positions = computedPositions.positions;\n  const corners = computedPositions.corners;\n  const endPositions = computedPositions.endPositions;\n  const computedLefts = computedPositions.lefts;\n  const computedNormals = computedPositions.normals;\n  const attributes = new GeometryAttributes();\n  let corner;\n  let leftCount = 0;\n  let rightCount = 0;\n  let i;\n  let indicesLength = 0;\n  let length;\n  for (i = 0; i < positions.length; i += 2) {\n    length = positions[i].length - 3;\n    leftCount += length; //subtracting 3 to account for duplicate points at corners\n    indicesLength += length * 2;\n    rightCount += positions[i + 1].length - 3;\n  }\n  leftCount += 3; //add back count for end positions\n  rightCount += 3;\n  for (i = 0; i < corners.length; i++) {\n    corner = corners[i];\n    const leftSide = corners[i].leftPositions;\n    if (defined(leftSide)) {\n      length = leftSide.length;\n      leftCount += length;\n      indicesLength += length;\n    } else {\n      length = corners[i].rightPositions.length;\n      rightCount += length;\n      indicesLength += length;\n    }\n  }\n\n  const addEndPositions = defined(endPositions);\n  let endPositionLength;\n  if (addEndPositions) {\n    endPositionLength = endPositions[0].length - 3;\n    leftCount += endPositionLength;\n    rightCount += endPositionLength;\n    endPositionLength /= 3;\n    indicesLength += endPositionLength * 6;\n  }\n  const size = leftCount + rightCount;\n  const finalPositions = new Float64Array(size);\n  const normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(size)\n    : undefined;\n  const attr = {\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents,\n  };\n  let front = 0;\n  let back = size - 1;\n  let UL, LL, UR, LR;\n  let normal = cartesian1;\n  let left = cartesian2;\n  let rightPos, leftPos;\n  const halfLength = endPositionLength / 2;\n\n  const indices = IndexDatatype.createTypedArray(size / 3, indicesLength);\n  let index = 0;\n  if (addEndPositions) {\n    // add rounded end\n    leftPos = cartesian3;\n    rightPos = cartesian4;\n    const firstEndPositions = endPositions[0];\n    normal = Cartesian3.fromArray(computedNormals, 0, normal);\n    left = Cartesian3.fromArray(computedLefts, 0, left);\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength - 1 - i) * 3,\n        leftPos,\n      );\n      rightPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength + i) * 3,\n        rightPos,\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back,\n      );\n      addNormals(attr, normal, left, front, back, vertexFormat);\n\n      LL = front / 3;\n      LR = LL + 1;\n      UL = (back - 2) / 3;\n      UR = UL - 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  let posIndex = 0;\n  let compIndex = 0;\n  let rightEdge = positions[posIndex++]; //add first two edges\n  let leftEdge = positions[posIndex++];\n  finalPositions.set(rightEdge, front);\n  finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n  left = Cartesian3.fromArray(computedLefts, compIndex, left);\n  let rightNormal;\n  let leftNormal;\n  length = leftEdge.length - 3;\n  for (i = 0; i < length; i += 3) {\n    rightNormal = ellipsoid.geodeticSurfaceNormal(\n      Cartesian3.fromArray(rightEdge, i, scratch1),\n      scratch1,\n    );\n    leftNormal = ellipsoid.geodeticSurfaceNormal(\n      Cartesian3.fromArray(leftEdge, length - i, scratch2),\n      scratch2,\n    );\n    normal = Cartesian3.normalize(\n      Cartesian3.add(rightNormal, leftNormal, normal),\n      normal,\n    );\n    addNormals(attr, normal, left, front, back, vertexFormat);\n\n    LL = front / 3;\n    LR = LL + 1;\n    UL = (back - 2) / 3;\n    UR = UL - 1;\n    indices[index++] = UL;\n    indices[index++] = LL;\n    indices[index++] = UR;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n\n    front += 3;\n    back -= 3;\n  }\n\n  rightNormal = ellipsoid.geodeticSurfaceNormal(\n    Cartesian3.fromArray(rightEdge, length, scratch1),\n    scratch1,\n  );\n  leftNormal = ellipsoid.geodeticSurfaceNormal(\n    Cartesian3.fromArray(leftEdge, length, scratch2),\n    scratch2,\n  );\n  normal = Cartesian3.normalize(\n    Cartesian3.add(rightNormal, leftNormal, normal),\n    normal,\n  );\n  compIndex += 3;\n  for (i = 0; i < corners.length; i++) {\n    let j;\n    corner = corners[i];\n    const l = corner.leftPositions;\n    const r = corner.rightPositions;\n    let pivot;\n    let start;\n    let outsidePoint = cartesian6;\n    let previousPoint = cartesian3;\n    let nextPoint = cartesian4;\n    normal = Cartesian3.fromArray(computedNormals, compIndex, normal);\n    if (defined(l)) {\n      addNormals(attr, normal, left, undefined, back, vertexFormat);\n      back -= 3;\n      pivot = LR;\n      start = UR;\n      for (j = 0; j < l.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n        indices[index++] = pivot;\n        indices[index++] = start - j - 1;\n        indices[index++] = start - j;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          undefined,\n          back,\n        );\n        previousPoint = Cartesian3.fromArray(\n          finalPositions,\n          (start - j - 1) * 3,\n          previousPoint,\n        );\n        nextPoint = Cartesian3.fromArray(finalPositions, pivot * 3, nextPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.subtract(previousPoint, nextPoint, left),\n          left,\n        );\n        addNormals(attr, normal, left, undefined, back, vertexFormat);\n        back -= 3;\n      }\n      outsidePoint = Cartesian3.fromArray(\n        finalPositions,\n        pivot * 3,\n        outsidePoint,\n      );\n      previousPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, start * 3, previousPoint),\n        outsidePoint,\n        previousPoint,\n      );\n      nextPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, (start - j) * 3, nextPoint),\n        outsidePoint,\n        nextPoint,\n      );\n      left = Cartesian3.normalize(\n        Cartesian3.add(previousPoint, nextPoint, left),\n        left,\n      );\n      addNormals(attr, normal, left, front, undefined, vertexFormat);\n      front += 3;\n    } else {\n      addNormals(attr, normal, left, front, undefined, vertexFormat);\n      front += 3;\n      pivot = UR;\n      start = LR;\n      for (j = 0; j < r.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n        indices[index++] = pivot;\n        indices[index++] = start + j;\n        indices[index++] = start + j + 1;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          front,\n        );\n        previousPoint = Cartesian3.fromArray(\n          finalPositions,\n          pivot * 3,\n          previousPoint,\n        );\n        nextPoint = Cartesian3.fromArray(\n          finalPositions,\n          (start + j) * 3,\n          nextPoint,\n        );\n        left = Cartesian3.normalize(\n          Cartesian3.subtract(previousPoint, nextPoint, left),\n          left,\n        );\n        addNormals(attr, normal, left, front, undefined, vertexFormat);\n        front += 3;\n      }\n      outsidePoint = Cartesian3.fromArray(\n        finalPositions,\n        pivot * 3,\n        outsidePoint,\n      );\n      previousPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, (start + j) * 3, previousPoint),\n        outsidePoint,\n        previousPoint,\n      );\n      nextPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, start * 3, nextPoint),\n        outsidePoint,\n        nextPoint,\n      );\n      left = Cartesian3.normalize(\n        Cartesian3.negate(Cartesian3.add(nextPoint, previousPoint, left), left),\n        left,\n      );\n      addNormals(attr, normal, left, undefined, back, vertexFormat);\n      back -= 3;\n    }\n    rightEdge = positions[posIndex++];\n    leftEdge = positions[posIndex++];\n    rightEdge.splice(0, 3); //remove duplicate points added by corner\n    leftEdge.splice(leftEdge.length - 3, 3);\n    finalPositions.set(rightEdge, front);\n    finalPositions.set(leftEdge, back - leftEdge.length + 1);\n    length = leftEdge.length - 3;\n\n    compIndex += 3;\n    left = Cartesian3.fromArray(computedLefts, compIndex, left);\n    for (j = 0; j < leftEdge.length; j += 3) {\n      rightNormal = ellipsoid.geodeticSurfaceNormal(\n        Cartesian3.fromArray(rightEdge, j, scratch1),\n        scratch1,\n      );\n      leftNormal = ellipsoid.geodeticSurfaceNormal(\n        Cartesian3.fromArray(leftEdge, length - j, scratch2),\n        scratch2,\n      );\n      normal = Cartesian3.normalize(\n        Cartesian3.add(rightNormal, leftNormal, normal),\n        normal,\n      );\n      addNormals(attr, normal, left, front, back, vertexFormat);\n\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n    front -= 3;\n    back += 3;\n  }\n  normal = Cartesian3.fromArray(\n    computedNormals,\n    computedNormals.length - 3,\n    normal,\n  );\n  addNormals(attr, normal, left, front, back, vertexFormat);\n\n  if (addEndPositions) {\n    // add rounded end\n    front += 3;\n    back -= 3;\n    leftPos = cartesian3;\n    rightPos = cartesian4;\n    const lastEndPositions = endPositions[1];\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        lastEndPositions,\n        (endPositionLength - i - 1) * 3,\n        leftPos,\n      );\n      rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back,\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      addNormals(attr, normal, left, front, back, vertexFormat);\n\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions,\n  });\n\n  if (vertexFormat.st) {\n    const st = new Float32Array((size / 3) * 2);\n    let rightSt;\n    let leftSt;\n    let stIndex = 0;\n    if (addEndPositions) {\n      leftCount /= 3;\n      rightCount /= 3;\n      const theta = Math.PI / (endPositionLength + 1);\n      leftSt = 1 / (leftCount - endPositionLength + 1);\n      rightSt = 1 / (rightCount - endPositionLength + 1);\n      let a;\n      const halfEndPos = endPositionLength / 2;\n      for (i = halfEndPos + 1; i < endPositionLength + 1; i++) {\n        // lower left rounded end\n        a = CesiumMath.PI_OVER_TWO + theta * i;\n        st[stIndex++] = rightSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = 1; i < rightCount - endPositionLength + 1; i++) {\n        // bottom edge\n        st[stIndex++] = i * rightSt;\n        st[stIndex++] = 0;\n      }\n      for (i = endPositionLength; i > halfEndPos; i--) {\n        // lower right rounded end\n        a = CesiumMath.PI_OVER_TWO - i * theta;\n        st[stIndex++] = 1 - rightSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = halfEndPos; i > 0; i--) {\n        // upper right rounded end\n        a = CesiumMath.PI_OVER_TWO - theta * i;\n        st[stIndex++] = 1 - leftSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = leftCount - endPositionLength; i > 0; i--) {\n        // top edge\n        st[stIndex++] = i * leftSt;\n        st[stIndex++] = 1;\n      }\n      for (i = 1; i < halfEndPos + 1; i++) {\n        // upper left rounded end\n        a = CesiumMath.PI_OVER_TWO + theta * i;\n        st[stIndex++] = leftSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n    } else {\n      leftCount /= 3;\n      rightCount /= 3;\n      leftSt = 1 / (leftCount - 1);\n      rightSt = 1 / (rightCount - 1);\n      for (i = 0; i < rightCount; i++) {\n        // bottom edge\n        st[stIndex++] = i * rightSt;\n        st[stIndex++] = 0;\n      }\n      for (i = leftCount; i > 0; i--) {\n        // top edge\n        st[stIndex++] = (i - 1) * leftSt;\n        st[stIndex++] = 1;\n      }\n    }\n\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.bitangents,\n    });\n  }\n\n  return {\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\nfunction extrudedAttributes(attributes, vertexFormat) {\n  if (\n    !vertexFormat.normal &&\n    !vertexFormat.tangent &&\n    !vertexFormat.bitangent &&\n    !vertexFormat.st\n  ) {\n    return attributes;\n  }\n  const positions = attributes.position.values;\n  let topNormals;\n  let topBitangents;\n  if (vertexFormat.normal || vertexFormat.bitangent) {\n    topNormals = attributes.normal.values;\n    topBitangents = attributes.bitangent.values;\n  }\n  const size = attributes.position.values.length / 18;\n  const threeSize = size * 3;\n  const twoSize = size * 2;\n  const sixSize = threeSize * 2;\n  let i;\n  if (vertexFormat.normal || vertexFormat.bitangent || vertexFormat.tangent) {\n    const normals = vertexFormat.normal\n      ? new Float32Array(threeSize * 6)\n      : undefined;\n    const tangents = vertexFormat.tangent\n      ? new Float32Array(threeSize * 6)\n      : undefined;\n    const bitangents = vertexFormat.bitangent\n      ? new Float32Array(threeSize * 6)\n      : undefined;\n    let topPosition = cartesian1;\n    let bottomPosition = cartesian2;\n    let previousPosition = cartesian3;\n    let normal = cartesian4;\n    let tangent = cartesian5;\n    let bitangent = cartesian6;\n    let attrIndex = sixSize;\n    for (i = 0; i < threeSize; i += 3) {\n      const attrIndexOffset = attrIndex + sixSize;\n      topPosition = Cartesian3.fromArray(positions, i, topPosition);\n      bottomPosition = Cartesian3.fromArray(\n        positions,\n        i + threeSize,\n        bottomPosition,\n      );\n      previousPosition = Cartesian3.fromArray(\n        positions,\n        (i + 3) % threeSize,\n        previousPosition,\n      );\n      bottomPosition = Cartesian3.subtract(\n        bottomPosition,\n        topPosition,\n        bottomPosition,\n      );\n      previousPosition = Cartesian3.subtract(\n        previousPosition,\n        topPosition,\n        previousPosition,\n      );\n      normal = Cartesian3.normalize(\n        Cartesian3.cross(bottomPosition, previousPosition, normal),\n        normal,\n      );\n      if (vertexFormat.normal) {\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset);\n        CorridorGeometryLibrary.addAttribute(\n          normals,\n          normal,\n          attrIndexOffset + 3,\n        );\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex);\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex + 3);\n      }\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        bitangent = Cartesian3.fromArray(topNormals, i, bitangent);\n        if (vertexFormat.bitangent) {\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndexOffset,\n          );\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndexOffset + 3,\n          );\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndex,\n          );\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndex + 3,\n          );\n        }\n\n        if (vertexFormat.tangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(bitangent, normal, tangent),\n            tangent,\n          );\n          CorridorGeometryLibrary.addAttribute(\n            tangents,\n            tangent,\n            attrIndexOffset,\n          );\n          CorridorGeometryLibrary.addAttribute(\n            tangents,\n            tangent,\n            attrIndexOffset + 3,\n          );\n          CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex);\n          CorridorGeometryLibrary.addAttribute(\n            tangents,\n            tangent,\n            attrIndex + 3,\n          );\n        }\n      }\n      attrIndex += 6;\n    }\n\n    if (vertexFormat.normal) {\n      normals.set(topNormals); //top\n      for (i = 0; i < threeSize; i += 3) {\n        //bottom normals\n        normals[i + threeSize] = -topNormals[i];\n        normals[i + threeSize + 1] = -topNormals[i + 1];\n        normals[i + threeSize + 2] = -topNormals[i + 2];\n      }\n      attributes.normal.values = normals;\n    } else {\n      attributes.normal = undefined;\n    }\n\n    if (vertexFormat.bitangent) {\n      bitangents.set(topBitangents); //top\n      bitangents.set(topBitangents, threeSize); //bottom\n      attributes.bitangent.values = bitangents;\n    } else {\n      attributes.bitangent = undefined;\n    }\n\n    if (vertexFormat.tangent) {\n      const topTangents = attributes.tangent.values;\n      tangents.set(topTangents); //top\n      tangents.set(topTangents, threeSize); //bottom\n      attributes.tangent.values = tangents;\n    }\n  }\n  if (vertexFormat.st) {\n    const topSt = attributes.st.values;\n    const st = new Float32Array(twoSize * 6);\n    st.set(topSt); //top\n    st.set(topSt, twoSize); //bottom\n    let index = twoSize * 2;\n\n    for (let j = 0; j < 2; j++) {\n      st[index++] = topSt[0];\n      st[index++] = topSt[1];\n      for (i = 2; i < twoSize; i += 2) {\n        const s = topSt[i];\n        const t = topSt[i + 1];\n        st[index++] = s;\n        st[index++] = t;\n        st[index++] = s;\n        st[index++] = t;\n      }\n      st[index++] = topSt[0];\n      st[index++] = topSt[1];\n    }\n    attributes.st.values = st;\n  }\n\n  return attributes;\n}\n\nfunction addWallPositions(positions, index, wallPositions) {\n  wallPositions[index++] = positions[0];\n  wallPositions[index++] = positions[1];\n  wallPositions[index++] = positions[2];\n  for (let i = 3; i < positions.length; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n    wallPositions[index++] = x;\n    wallPositions[index++] = y;\n    wallPositions[index++] = z;\n    wallPositions[index++] = x;\n    wallPositions[index++] = y;\n    wallPositions[index++] = z;\n  }\n  wallPositions[index++] = positions[0];\n  wallPositions[index++] = positions[1];\n  wallPositions[index++] = positions[2];\n\n  return wallPositions;\n}\n\nfunction computePositionsExtruded(params, vertexFormat) {\n  const topVertexFormat = new VertexFormat({\n    position: vertexFormat.position,\n    normal:\n      vertexFormat.normal || vertexFormat.bitangent || params.shadowVolume,\n    tangent: vertexFormat.tangent,\n    bitangent: vertexFormat.normal || vertexFormat.bitangent,\n    st: vertexFormat.st,\n  });\n  const ellipsoid = params.ellipsoid;\n  const computedPositions = CorridorGeometryLibrary.computePositions(params);\n  const attr = combine(computedPositions, topVertexFormat, ellipsoid);\n  const height = params.height;\n  const extrudedHeight = params.extrudedHeight;\n  let attributes = attr.attributes;\n  const indices = attr.indices;\n  let positions = attributes.position.values;\n  let length = positions.length;\n  const newPositions = new Float64Array(length * 6);\n  let extrudedPositions = new Float64Array(length);\n  extrudedPositions.set(positions);\n  let wallPositions = new Float64Array(length * 4);\n\n  positions = PolygonPipeline.scaleToGeodeticHeight(\n    positions,\n    height,\n    ellipsoid,\n  );\n  wallPositions = addWallPositions(positions, 0, wallPositions);\n  extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(\n    extrudedPositions,\n    extrudedHeight,\n    ellipsoid,\n  );\n  wallPositions = addWallPositions(\n    extrudedPositions,\n    length * 2,\n    wallPositions,\n  );\n  newPositions.set(positions);\n  newPositions.set(extrudedPositions, length);\n  newPositions.set(wallPositions, length * 2);\n  attributes.position.values = newPositions;\n\n  attributes = extrudedAttributes(attributes, vertexFormat);\n  let i;\n  const size = length / 3;\n  if (params.shadowVolume) {\n    const topNormals = attributes.normal.values;\n    length = topNormals.length;\n\n    let extrudeNormals = new Float32Array(length * 6);\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n    //only get normals for bottom layer that's going to be pushed down\n    extrudeNormals.set(topNormals, length); //bottom face\n    extrudeNormals = addWallPositions(topNormals, length * 4, extrudeNormals); //bottom wall\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n    if (!vertexFormat.normal) {\n      attributes.normal = undefined;\n    }\n  }\n  if (defined(params.offsetAttribute)) {\n    let applyOffset = new Uint8Array(size * 6);\n    if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = applyOffset\n        .fill(1, 0, size) // top face\n        .fill(1, size * 2, size * 4); // top wall\n    } else {\n      const applyOffsetValue =\n        params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = applyOffset.fill(applyOffsetValue);\n    }\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  const iLength = indices.length;\n  const twoSize = size + size;\n  const newIndices = IndexDatatype.createTypedArray(\n    newPositions.length / 3,\n    iLength * 2 + twoSize * 3,\n  );\n  newIndices.set(indices);\n  let index = iLength;\n  for (i = 0; i < iLength; i += 3) {\n    // bottom indices\n    const v0 = indices[i];\n    const v1 = indices[i + 1];\n    const v2 = indices[i + 2];\n    newIndices[index++] = v2 + size;\n    newIndices[index++] = v1 + size;\n    newIndices[index++] = v0 + size;\n  }\n\n  let UL, LL, UR, LR;\n\n  for (i = 0; i < twoSize; i += 2) {\n    //wall indices\n    UL = i + twoSize;\n    LL = UL + twoSize;\n    UR = UL + 1;\n    LR = LL + 1;\n    newIndices[index++] = UL;\n    newIndices[index++] = LL;\n    newIndices[index++] = UR;\n    newIndices[index++] = UR;\n    newIndices[index++] = LL;\n    newIndices[index++] = LR;\n  }\n\n  return {\n    attributes: attributes,\n    indices: newIndices,\n  };\n}\n\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartographic = new Cartographic();\n\nfunction computeOffsetPoints(\n  position1,\n  position2,\n  ellipsoid,\n  halfWidth,\n  min,\n  max,\n) {\n  // Compute direction of offset the point\n  const direction = Cartesian3.subtract(\n    position2,\n    position1,\n    scratchCartesian1,\n  );\n  Cartesian3.normalize(direction, direction);\n  const normal = ellipsoid.geodeticSurfaceNormal(position1, scratchCartesian2);\n  const offsetDirection = Cartesian3.cross(\n    direction,\n    normal,\n    scratchCartesian1,\n  );\n  Cartesian3.multiplyByScalar(offsetDirection, halfWidth, offsetDirection);\n\n  let minLat = min.latitude;\n  let minLon = min.longitude;\n  let maxLat = max.latitude;\n  let maxLon = max.longitude;\n\n  // Compute 2 offset points\n  Cartesian3.add(position1, offsetDirection, scratchCartesian2);\n  ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n  let lat = scratchCartographic.latitude;\n  let lon = scratchCartographic.longitude;\n  minLat = Math.min(minLat, lat);\n  minLon = Math.min(minLon, lon);\n  maxLat = Math.max(maxLat, lat);\n  maxLon = Math.max(maxLon, lon);\n\n  Cartesian3.subtract(position1, offsetDirection, scratchCartesian2);\n  ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n  lat = scratchCartographic.latitude;\n  lon = scratchCartographic.longitude;\n  minLat = Math.min(minLat, lat);\n  minLon = Math.min(minLon, lon);\n  maxLat = Math.max(maxLat, lat);\n  maxLon = Math.max(maxLon, lon);\n\n  min.latitude = minLat;\n  min.longitude = minLon;\n  max.latitude = maxLat;\n  max.longitude = maxLon;\n}\n\nconst scratchCartesianOffset = new Cartesian3();\nconst scratchCartesianEnds = new Cartesian3();\nconst scratchCartographicMin = new Cartographic();\nconst scratchCartographicMax = new Cartographic();\n\nfunction computeRectangle(positions, ellipsoid, width, cornerType, result) {\n  positions = scaleToSurface(positions, ellipsoid);\n  const cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon,\n  );\n  const length = cleanPositions.length;\n  if (length < 2 || width <= 0) {\n    return new Rectangle();\n  }\n  const halfWidth = width * 0.5;\n\n  scratchCartographicMin.latitude = Number.POSITIVE_INFINITY;\n  scratchCartographicMin.longitude = Number.POSITIVE_INFINITY;\n  scratchCartographicMax.latitude = Number.NEGATIVE_INFINITY;\n  scratchCartographicMax.longitude = Number.NEGATIVE_INFINITY;\n\n  let lat, lon;\n  if (cornerType === CornerType.ROUNDED) {\n    // Compute start cap\n    const first = cleanPositions[0];\n    Cartesian3.subtract(first, cleanPositions[1], scratchCartesianOffset);\n    Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n    Cartesian3.multiplyByScalar(\n      scratchCartesianOffset,\n      halfWidth,\n      scratchCartesianOffset,\n    );\n    Cartesian3.add(first, scratchCartesianOffset, scratchCartesianEnds);\n\n    ellipsoid.cartesianToCartographic(\n      scratchCartesianEnds,\n      scratchCartographic,\n    );\n    lat = scratchCartographic.latitude;\n    lon = scratchCartographic.longitude;\n    scratchCartographicMin.latitude = Math.min(\n      scratchCartographicMin.latitude,\n      lat,\n    );\n    scratchCartographicMin.longitude = Math.min(\n      scratchCartographicMin.longitude,\n      lon,\n    );\n    scratchCartographicMax.latitude = Math.max(\n      scratchCartographicMax.latitude,\n      lat,\n    );\n    scratchCartographicMax.longitude = Math.max(\n      scratchCartographicMax.longitude,\n      lon,\n    );\n  }\n\n  // Compute the rest\n  for (let i = 0; i < length - 1; ++i) {\n    computeOffsetPoints(\n      cleanPositions[i],\n      cleanPositions[i + 1],\n      ellipsoid,\n      halfWidth,\n      scratchCartographicMin,\n      scratchCartographicMax,\n    );\n  }\n\n  // Compute ending point\n  const last = cleanPositions[length - 1];\n  Cartesian3.subtract(last, cleanPositions[length - 2], scratchCartesianOffset);\n  Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n  Cartesian3.multiplyByScalar(\n    scratchCartesianOffset,\n    halfWidth,\n    scratchCartesianOffset,\n  );\n  Cartesian3.add(last, scratchCartesianOffset, scratchCartesianEnds);\n  computeOffsetPoints(\n    last,\n    scratchCartesianEnds,\n    ellipsoid,\n    halfWidth,\n    scratchCartographicMin,\n    scratchCartographicMax,\n  );\n\n  if (cornerType === CornerType.ROUNDED) {\n    // Compute end cap\n    ellipsoid.cartesianToCartographic(\n      scratchCartesianEnds,\n      scratchCartographic,\n    );\n    lat = scratchCartographic.latitude;\n    lon = scratchCartographic.longitude;\n    scratchCartographicMin.latitude = Math.min(\n      scratchCartographicMin.latitude,\n      lat,\n    );\n    scratchCartographicMin.longitude = Math.min(\n      scratchCartographicMin.longitude,\n      lon,\n    );\n    scratchCartographicMax.latitude = Math.max(\n      scratchCartographicMax.latitude,\n      lat,\n    );\n    scratchCartographicMax.longitude = Math.max(\n      scratchCartographicMax.longitude,\n      lon,\n    );\n  }\n\n  const rectangle = defined(result) ? result : new Rectangle();\n  rectangle.north = scratchCartographicMax.latitude;\n  rectangle.south = scratchCartographicMin.latitude;\n  rectangle.east = scratchCartographicMax.longitude;\n  rectangle.west = scratchCartographicMin.longitude;\n\n  return rectangle;\n}\n\n/**\n * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias CorridorGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n * @param {number} options.width The distance between the edges of the corridor in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number} [options.height=0] The distance in meters between the ellipsoid surface and the positions.\n * @param {number} [options.extrudedHeight] The distance in meters between the ellipsoid surface and the extruded face.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see CorridorGeometry.createGeometry\n * @see Packable\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}\n *\n * @example\n * const corridor = new Cesium.CorridorGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });\n */\nfunction CorridorGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const positions = options.positions;\n  const width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", positions);\n  Check.defined(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  const height = options.height ?? 0.0;\n  const extrudedHeight = options.extrudedHeight ?? height;\n\n  this._positions = positions;\n  this._ellipsoid = Ellipsoid.clone(options.ellipsoid ?? Ellipsoid.default);\n  this._vertexFormat = VertexFormat.clone(\n    options.vertexFormat ?? VertexFormat.DEFAULT,\n  );\n  this._width = width;\n  this._height = Math.max(height, extrudedHeight);\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._cornerType = options.cornerType ?? CornerType.ROUNDED;\n  this._granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  this._shadowVolume = options.shadowVolume ?? false;\n  this._workerName = \"createCorridorGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._rectangle = undefined;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    1 +\n    positions.length * Cartesian3.packedLength +\n    Ellipsoid.packedLength +\n    VertexFormat.packedLength +\n    7;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CorridorGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCorridorGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const positions = value._positions;\n  const length = positions.length;\n  array[startingIndex++] = length;\n\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = value._offsetAttribute ?? -1;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  positions: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  width: undefined,\n  height: undefined,\n  extrudedHeight: undefined,\n  cornerType: undefined,\n  granularity: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CorridorGeometry} [result] The object into which to store the result.\n * @returns {CorridorGeometry} The modified result parameter or a new CorridorGeometry instance if one was not provided.\n */\nCorridorGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const width = array[startingIndex++];\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const cornerType = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const shadowVolume = array[startingIndex++] === 1.0;\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.width = width;\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new CorridorGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._width = width;\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the bounding rectangle given the provided options\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n * @param {number} options.width The distance between the edges of the corridor in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle.\n */\nCorridorGeometry.computeRectangle = function (options, result) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const positions = options.positions;\n  const width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", positions);\n  Check.defined(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  const cornerType = options.cornerType ?? CornerType.ROUNDED;\n\n  return computeRectangle(positions, ellipsoid, width, cornerType, result);\n};\n\n/**\n * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n *\n * @param {CorridorGeometry} corridorGeometry A description of the corridor.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCorridorGeometry.createGeometry = function (corridorGeometry) {\n  let positions = corridorGeometry._positions;\n  const width = corridorGeometry._width;\n  const ellipsoid = corridorGeometry._ellipsoid;\n\n  positions = scaleToSurface(positions, ellipsoid);\n  const cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon,\n  );\n\n  if (cleanPositions.length < 2 || width <= 0) {\n    return;\n  }\n\n  const height = corridorGeometry._height;\n  const extrudedHeight = corridorGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2,\n  );\n\n  const vertexFormat = corridorGeometry._vertexFormat;\n  const params = {\n    ellipsoid: ellipsoid,\n    positions: cleanPositions,\n    width: width,\n    cornerType: corridorGeometry._cornerType,\n    granularity: corridorGeometry._granularity,\n    saveAttributes: true,\n  };\n  let attr;\n  if (extrude) {\n    params.height = height;\n    params.extrudedHeight = extrudedHeight;\n    params.shadowVolume = corridorGeometry._shadowVolume;\n    params.offsetAttribute = corridorGeometry._offsetAttribute;\n    attr = computePositionsExtruded(params, vertexFormat);\n  } else {\n    const computedPositions = CorridorGeometryLibrary.computePositions(params);\n    attr = combine(computedPositions, vertexFormat, ellipsoid);\n    attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      attr.attributes.position.values,\n      height,\n      ellipsoid,\n    );\n\n    if (defined(corridorGeometry._offsetAttribute)) {\n      const applyOffsetValue =\n        corridorGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      const length = attr.attributes.position.values.length;\n      const applyOffset = new Uint8Array(length / 3).fill(applyOffsetValue);\n      attr.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n  const attributes = attr.attributes;\n  const boundingSphere = BoundingSphere.fromVertices(\n    attributes.position.values,\n    undefined,\n    3,\n  );\n  if (!vertexFormat.position) {\n    attr.attributes.position.values = undefined;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: attr.indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: corridorGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nCorridorGeometry.createShadowVolume = function (\n  corridorGeometry,\n  minHeightFunc,\n  maxHeightFunc,\n) {\n  const granularity = corridorGeometry._granularity;\n  const ellipsoid = corridorGeometry._ellipsoid;\n\n  const minHeight = minHeightFunc(granularity, ellipsoid);\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new CorridorGeometry({\n    positions: corridorGeometry._positions,\n    width: corridorGeometry._width,\n    cornerType: corridorGeometry._cornerType,\n    ellipsoid: ellipsoid,\n    granularity: granularity,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n  });\n};\n\nObject.defineProperties(CorridorGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        this._rectangle = computeRectangle(\n          this._positions,\n          this._ellipsoid,\n          this._width,\n          this._cornerType,\n        );\n      }\n      return this._rectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering CorridorGeometries as GroundPrimitives.\n   *\n   * Corridors don't support stRotation,\n   * so just return the corners of the original system.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      return [0, 0, 0, 1, 1, 0];\n    },\n  },\n});\nexport default CorridorGeometry;\n"],"names":["cartesian1","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","scratch1","scratch2","scaleToSurface","positions","ellipsoid","i","length","scaleToGeodeticSurface","addNormals","attr","normal","left","front","back","vertexFormat","normals","tangents","bitangents","forward","normalize","cross","addAttribute","tangent","bitangent","combine","computedPositions","corners","endPositions","computedLefts","lefts","computedNormals","attributes","corner","leftCount","rightCount","indicesLength","leftSide","leftPositions","rightPositions","addEndPositions","endPositionLength","size","finalPositions","Float64Array","Float32Array","undefined","UL","LL","UR","LR","rightPos","leftPos","halfLength","indices","createTypedArray","index","firstEndPositions","fromArray","posIndex","compIndex","rightEdge","leftEdge","set","rightNormal","leftNormal","geodeticSurfaceNormal","add","j","l","r","pivot","start","outsidePoint","previousPoint","nextPoint","subtract","negate","splice","lastEndPositions","position","componentDatatype","DOUBLE","componentsPerAttribute","values","st","rightSt","leftSt","stIndex","theta","Math","PI","a","halfEndPos","PI_OVER_TWO","cos","sin","FLOAT","extrudedAttributes","topNormals","topBitangents","threeSize","twoSize","sixSize","topPosition","bottomPosition","previousPosition","attrIndex","attrIndexOffset","topTangents","topSt","s","t","addWallPositions","wallPositions","x","y","z","computePositionsExtruded","params","topVertexFormat","shadowVolume","computePositions","height","extrudedHeight","newPositions","extrudedPositions","scaleToGeodeticHeight","extrudeNormals","extrudeDirection","offsetAttribute","applyOffset","Uint8Array","TOP","fill","applyOffsetValue","NONE","UNSIGNED_BYTE","iLength","newIndices","v0","v1","v2","scratchCartesian1","scratchCartesian2","scratchCartographic","computeOffsetPoints","position1","position2","halfWidth","min","max","direction","offsetDirection","multiplyByScalar","minLat","latitude","minLon","longitude","maxLat","maxLon","cartesianToCartographic","lat","lon","scratchCartesianOffset","scratchCartesianEnds","scratchCartographicMin","scratchCartographicMax","computeRectangle","width","cornerType","result","cleanPositions","equalsEpsilon","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","ROUNDED","first","last","rectangle","north","south","east","west","CorridorGeometry","options","EMPTY_OBJECT","defined","_positions","_ellipsoid","clone","default","_vertexFormat","DEFAULT","_width","_height","_extrudedHeight","_cornerType","_granularity","granularity","RADIANS_PER_DEGREE","_shadowVolume","_workerName","_offsetAttribute","_rectangle","packedLength","pack","value","array","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","unpack","Array","createGeometry","corridorGeometry","extrude","EPSILON2","saveAttributes","boundingSphere","fromVertices","primitiveType","TRIANGLES","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","Object","defineProperties","prototype","get","textureCoordinateRotationPoints"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AAEA,MAAMA,aAAa,IAAI,gLAAU;AACjC,MAAMC,aAAa,IAAI,gLAAU;AACjC,MAAMC,aAAa,IAAI,gLAAU;AACjC,MAAMC,aAAa,IAAI,gLAAU;AACjC,MAAMC,aAAa,IAAI,gLAAU;AACjC,MAAMC,aAAa,IAAI,gLAAU;AAEjC,MAAMC,WAAW,IAAI,gLAAU;AAC/B,MAAMC,WAAW,IAAI,gLAAU;AAE/B,SAASC,eAAeC,SAAS,EAAEC,SAAS;IAC1C,IAAK,IAAIC,IAAI,GAAGA,IAAIF,UAAUG,MAAM,EAAED,IAAK;QACzCF,SAAS,CAACE,EAAE,GAAGD,UAAUG,sBAAsB,CAACJ,SAAS,CAACE,EAAE,EAAEF,SAAS,CAACE,EAAE;IAC5E;IACA,OAAOF;AACT;AAEA,SAASK,WAAWC,IAAI,EAAEC,MAAM,EAAEC,IAAI,EAAEC,KAAK,EAAEC,IAAI,EAAEC,YAAY;IAC/D,MAAMC,UAAUN,KAAKM,OAAO;IAC5B,MAAMC,WAAWP,KAAKO,QAAQ;IAC9B,MAAMC,aAAaR,KAAKQ,UAAU;IAClC,MAAMC,UAAU,gLAAU,CAACC,SAAS,CAClC,gLAAU,CAACC,KAAK,CAACT,MAAMD,QAAQV,WAC/BA;IAEF,IAAIc,aAAaJ,MAAM,EAAE;QACvB,6LAAuB,CAACW,YAAY,CAACN,SAASL,QAAQE,OAAOC;IAC/D;IACA,IAAIC,aAAaQ,OAAO,EAAE;QACxB,6LAAuB,CAACD,YAAY,CAACL,UAAUE,SAASN,OAAOC;IACjE;IACA,IAAIC,aAAaS,SAAS,EAAE;QAC1B,6LAAuB,CAACF,YAAY,CAACJ,YAAYN,MAAMC,OAAOC;IAChE;AACF;AAEA,SAASW,QAAQC,iBAAiB,EAAEX,YAAY,EAAEV,SAAS;IACzD,MAAMD,YAAYsB,kBAAkBtB,SAAS;IAC7C,MAAMuB,UAAUD,kBAAkBC,OAAO;IACzC,MAAMC,eAAeF,kBAAkBE,YAAY;IACnD,MAAMC,gBAAgBH,kBAAkBI,KAAK;IAC7C,MAAMC,kBAAkBL,kBAAkBV,OAAO;IACjD,MAAMgB,aAAa,IAAI,wLAAkB;IACzC,IAAIC;IACJ,IAAIC,YAAY;IAChB,IAAIC,aAAa;IACjB,IAAI7B;IACJ,IAAI8B,gBAAgB;IACpB,IAAI7B;IACJ,IAAKD,IAAI,GAAGA,IAAIF,UAAUG,MAAM,EAAED,KAAK,EAAG;QACxCC,SAASH,SAAS,CAACE,EAAE,CAACC,MAAM,GAAG;QAC/B2B,aAAa3B,QAAQ,0DAA0D;QAC/E6B,iBAAiB7B,SAAS;QAC1B4B,cAAc/B,SAAS,CAACE,IAAI,EAAE,CAACC,MAAM,GAAG;IAC1C;IACA2B,aAAa,GAAG,kCAAkC;IAClDC,cAAc;IACd,IAAK7B,IAAI,GAAGA,IAAIqB,QAAQpB,MAAM,EAAED,IAAK;QACnC2B,SAASN,OAAO,CAACrB,EAAE;QACnB,MAAM+B,WAAWV,OAAO,CAACrB,EAAE,CAACgC,aAAa;QACzC,IAAI,IAAA,6KAAO,EAACD,WAAW;YACrB9B,SAAS8B,SAAS9B,MAAM;YACxB2B,aAAa3B;YACb6B,iBAAiB7B;QACnB,OAAO;YACLA,SAASoB,OAAO,CAACrB,EAAE,CAACiC,cAAc,CAAChC,MAAM;YACzC4B,cAAc5B;YACd6B,iBAAiB7B;QACnB;IACF;IAEA,MAAMiC,kBAAkB,IAAA,6KAAO,EAACZ;IAChC,IAAIa;IACJ,IAAID,iBAAiB;QACnBC,oBAAoBb,YAAY,CAAC,EAAE,CAACrB,MAAM,GAAG;QAC7C2B,aAAaO;QACbN,cAAcM;QACdA,qBAAqB;QACrBL,iBAAiBK,oBAAoB;IACvC;IACA,MAAMC,OAAOR,YAAYC;IACzB,MAAMQ,iBAAiB,IAAIC,aAAaF;IACxC,MAAM1B,UAAUD,aAAaJ,MAAM,GAAG,IAAIkC,aAAaH,QAAQI;IAC/D,MAAM7B,WAAWF,aAAaQ,OAAO,GAAG,IAAIsB,aAAaH,QAAQI;IACjE,MAAM5B,aAAaH,aAAaS,SAAS,GACrC,IAAIqB,aAAaH,QACjBI;IACJ,MAAMpC,OAAO;QACXM,SAASA;QACTC,UAAUA;QACVC,YAAYA;IACd;IACA,IAAIL,QAAQ;IACZ,IAAIC,OAAO4B,OAAO;IAClB,IAAIK,IAAIC,IAAIC,IAAIC;IAChB,IAAIvC,SAAShB;IACb,IAAIiB,OAAOhB;IACX,IAAIuD,UAAUC;IACd,MAAMC,aAAaZ,oBAAoB;IAEvC,MAAMa,UAAU,mLAAa,CAACC,gBAAgB,CAACb,OAAO,GAAGN;IACzD,IAAIoB,QAAQ;IACZ,IAAIhB,iBAAiB;QACnB,kBAAkB;QAClBY,UAAUvD;QACVsD,WAAWrD;QACX,MAAM2D,oBAAoB7B,YAAY,CAAC,EAAE;QACzCjB,SAAS,gLAAU,CAAC+C,SAAS,CAAC3B,iBAAiB,GAAGpB;QAClDC,OAAO,gLAAU,CAAC8C,SAAS,CAAC7B,eAAe,GAAGjB;QAC9C,IAAKN,IAAI,GAAGA,IAAI+C,YAAY/C,IAAK;YAC/B8C,UAAU,gLAAU,CAACM,SAAS,CAC5BD,mBACA,CAACJ,aAAa,IAAI/C,CAAC,IAAI,GACvB8C;YAEFD,WAAW,gLAAU,CAACO,SAAS,CAC7BD,mBACA,CAACJ,aAAa/C,CAAC,IAAI,GACnB6C;YAEF,6LAAuB,CAAC7B,YAAY,CAACqB,gBAAgBQ,UAAUtC;YAC/D,6LAAuB,CAACS,YAAY,CAClCqB,gBACAS,SACAN,WACAhC;YAEFL,WAAWC,MAAMC,QAAQC,MAAMC,OAAOC,MAAMC;YAE5CiC,KAAKnC,QAAQ;YACbqC,KAAKF,KAAK;YACVD,KAAK,CAACjC,OAAO,CAAC,IAAI;YAClBmC,KAAKF,KAAK;YACVO,OAAO,CAACE,QAAQ,GAAGT;YACnBO,OAAO,CAACE,QAAQ,GAAGR;YACnBM,OAAO,CAACE,QAAQ,GAAGP;YACnBK,OAAO,CAACE,QAAQ,GAAGP;YACnBK,OAAO,CAACE,QAAQ,GAAGR;YACnBM,OAAO,CAACE,QAAQ,GAAGN;YAEnBrC,SAAS;YACTC,QAAQ;QACV;IACF;IAEA,IAAI6C,WAAW;IACf,IAAIC,YAAY;IAChB,IAAIC,YAAYzD,SAAS,CAACuD,WAAW,EAAE,qBAAqB;IAC5D,IAAIG,WAAW1D,SAAS,CAACuD,WAAW;IACpChB,eAAeoB,GAAG,CAACF,WAAWhD;IAC9B8B,eAAeoB,GAAG,CAACD,UAAUhD,OAAOgD,SAASvD,MAAM,GAAG;IAEtDK,OAAO,gLAAU,CAAC8C,SAAS,CAAC7B,eAAe+B,WAAWhD;IACtD,IAAIoD;IACJ,IAAIC;IACJ1D,SAASuD,SAASvD,MAAM,GAAG;IAC3B,IAAKD,IAAI,GAAGA,IAAIC,QAAQD,KAAK,EAAG;QAC9B0D,cAAc3D,UAAU6D,qBAAqB,CAC3C,gLAAU,CAACR,SAAS,CAACG,WAAWvD,GAAGL,WACnCA;QAEFgE,aAAa5D,UAAU6D,qBAAqB,CAC1C,gLAAU,CAACR,SAAS,CAACI,UAAUvD,SAASD,GAAGJ,WAC3CA;QAEFS,SAAS,gLAAU,CAACS,SAAS,CAC3B,gLAAU,CAAC+C,GAAG,CAACH,aAAaC,YAAYtD,SACxCA;QAEFF,WAAWC,MAAMC,QAAQC,MAAMC,OAAOC,MAAMC;QAE5CiC,KAAKnC,QAAQ;QACbqC,KAAKF,KAAK;QACVD,KAAK,CAACjC,OAAO,CAAC,IAAI;QAClBmC,KAAKF,KAAK;QACVO,OAAO,CAACE,QAAQ,GAAGT;QACnBO,OAAO,CAACE,QAAQ,GAAGR;QACnBM,OAAO,CAACE,QAAQ,GAAGP;QACnBK,OAAO,CAACE,QAAQ,GAAGP;QACnBK,OAAO,CAACE,QAAQ,GAAGR;QACnBM,OAAO,CAACE,QAAQ,GAAGN;QAEnBrC,SAAS;QACTC,QAAQ;IACV;IAEAkD,cAAc3D,UAAU6D,qBAAqB,CAC3C,gLAAU,CAACR,SAAS,CAACG,WAAWtD,QAAQN,WACxCA;IAEFgE,aAAa5D,UAAU6D,qBAAqB,CAC1C,gLAAU,CAACR,SAAS,CAACI,UAAUvD,QAAQL,WACvCA;IAEFS,SAAS,gLAAU,CAACS,SAAS,CAC3B,gLAAU,CAAC+C,GAAG,CAACH,aAAaC,YAAYtD,SACxCA;IAEFiD,aAAa;IACb,IAAKtD,IAAI,GAAGA,IAAIqB,QAAQpB,MAAM,EAAED,IAAK;QACnC,IAAI8D;QACJnC,SAASN,OAAO,CAACrB,EAAE;QACnB,MAAM+D,IAAIpC,OAAOK,aAAa;QAC9B,MAAMgC,IAAIrC,OAAOM,cAAc;QAC/B,IAAIgC;QACJ,IAAIC;QACJ,IAAIC,eAAezE;QACnB,IAAI0E,gBAAgB7E;QACpB,IAAI8E,YAAY7E;QAChBa,SAAS,gLAAU,CAAC+C,SAAS,CAAC3B,iBAAiB6B,WAAWjD;QAC1D,IAAI,IAAA,6KAAO,EAAC0D,IAAI;YACd5D,WAAWC,MAAMC,QAAQC,MAAMkC,WAAWhC,MAAMC;YAChDD,QAAQ;YACRyD,QAAQrB;YACRsB,QAAQvB;YACR,IAAKmB,IAAI,GAAGA,IAAIC,EAAE9D,MAAM,GAAG,GAAG6D,IAAK;gBACjCK,eAAe,gLAAU,CAACf,SAAS,CAACW,GAAGD,IAAI,GAAGK;gBAC9CnB,OAAO,CAACE,QAAQ,GAAGe;gBACnBjB,OAAO,CAACE,QAAQ,GAAGgB,QAAQJ,IAAI;gBAC/Bd,OAAO,CAACE,QAAQ,GAAGgB,QAAQJ;gBAC3B,6LAAuB,CAAC9C,YAAY,CAClCqB,gBACA8B,cACA3B,WACAhC;gBAEF4D,gBAAgB,gLAAU,CAAChB,SAAS,CAClCf,gBACA,CAAC6B,QAAQJ,IAAI,CAAC,IAAI,GAClBM;gBAEFC,YAAY,gLAAU,CAACjB,SAAS,CAACf,gBAAgB4B,QAAQ,GAAGI;gBAC5D/D,OAAO,gLAAU,CAACQ,SAAS,CACzB,gLAAU,CAACwD,QAAQ,CAACF,eAAeC,WAAW/D,OAC9CA;gBAEFH,WAAWC,MAAMC,QAAQC,MAAMkC,WAAWhC,MAAMC;gBAChDD,QAAQ;YACV;YACA2D,eAAe,gLAAU,CAACf,SAAS,CACjCf,gBACA4B,QAAQ,GACRE;YAEFC,gBAAgB,gLAAU,CAACE,QAAQ,CACjC,gLAAU,CAAClB,SAAS,CAACf,gBAAgB6B,QAAQ,GAAGE,gBAChDD,cACAC;YAEFC,YAAY,gLAAU,CAACC,QAAQ,CAC7B,gLAAU,CAAClB,SAAS,CAACf,gBAAgB,CAAC6B,QAAQJ,CAAC,IAAI,GAAGO,YACtDF,cACAE;YAEF/D,OAAO,gLAAU,CAACQ,SAAS,CACzB,gLAAU,CAAC+C,GAAG,CAACO,eAAeC,WAAW/D,OACzCA;YAEFH,WAAWC,MAAMC,QAAQC,MAAMC,OAAOiC,WAAW/B;YACjDF,SAAS;QACX,OAAO;YACLJ,WAAWC,MAAMC,QAAQC,MAAMC,OAAOiC,WAAW/B;YACjDF,SAAS;YACT0D,QAAQtB;YACRuB,QAAQtB;YACR,IAAKkB,IAAI,GAAGA,IAAIE,EAAE/D,MAAM,GAAG,GAAG6D,IAAK;gBACjCK,eAAe,gLAAU,CAACf,SAAS,CAACY,GAAGF,IAAI,GAAGK;gBAC9CnB,OAAO,CAACE,QAAQ,GAAGe;gBACnBjB,OAAO,CAACE,QAAQ,GAAGgB,QAAQJ;gBAC3Bd,OAAO,CAACE,QAAQ,GAAGgB,QAAQJ,IAAI;gBAC/B,6LAAuB,CAAC9C,YAAY,CAClCqB,gBACA8B,cACA5D;gBAEF6D,gBAAgB,gLAAU,CAAChB,SAAS,CAClCf,gBACA4B,QAAQ,GACRG;gBAEFC,YAAY,gLAAU,CAACjB,SAAS,CAC9Bf,gBACA,CAAC6B,QAAQJ,CAAC,IAAI,GACdO;gBAEF/D,OAAO,gLAAU,CAACQ,SAAS,CACzB,gLAAU,CAACwD,QAAQ,CAACF,eAAeC,WAAW/D,OAC9CA;gBAEFH,WAAWC,MAAMC,QAAQC,MAAMC,OAAOiC,WAAW/B;gBACjDF,SAAS;YACX;YACA4D,eAAe,gLAAU,CAACf,SAAS,CACjCf,gBACA4B,QAAQ,GACRE;YAEFC,gBAAgB,gLAAU,CAACE,QAAQ,CACjC,gLAAU,CAAClB,SAAS,CAACf,gBAAgB,CAAC6B,QAAQJ,CAAC,IAAI,GAAGM,gBACtDD,cACAC;YAEFC,YAAY,gLAAU,CAACC,QAAQ,CAC7B,gLAAU,CAAClB,SAAS,CAACf,gBAAgB6B,QAAQ,GAAGG,YAChDF,cACAE;YAEF/D,OAAO,gLAAU,CAACQ,SAAS,CACzB,gLAAU,CAACyD,MAAM,CAAC,gLAAU,CAACV,GAAG,CAACQ,WAAWD,eAAe9D,OAAOA,OAClEA;YAEFH,WAAWC,MAAMC,QAAQC,MAAMkC,WAAWhC,MAAMC;YAChDD,QAAQ;QACV;QACA+C,YAAYzD,SAAS,CAACuD,WAAW;QACjCG,WAAW1D,SAAS,CAACuD,WAAW;QAChCE,UAAUiB,MAAM,CAAC,GAAG,IAAI,yCAAyC;QACjEhB,SAASgB,MAAM,CAAChB,SAASvD,MAAM,GAAG,GAAG;QACrCoC,eAAeoB,GAAG,CAACF,WAAWhD;QAC9B8B,eAAeoB,GAAG,CAACD,UAAUhD,OAAOgD,SAASvD,MAAM,GAAG;QACtDA,SAASuD,SAASvD,MAAM,GAAG;QAE3BqD,aAAa;QACbhD,OAAO,gLAAU,CAAC8C,SAAS,CAAC7B,eAAe+B,WAAWhD;QACtD,IAAKwD,IAAI,GAAGA,IAAIN,SAASvD,MAAM,EAAE6D,KAAK,EAAG;YACvCJ,cAAc3D,UAAU6D,qBAAqB,CAC3C,gLAAU,CAACR,SAAS,CAACG,WAAWO,GAAGnE,WACnCA;YAEFgE,aAAa5D,UAAU6D,qBAAqB,CAC1C,gLAAU,CAACR,SAAS,CAACI,UAAUvD,SAAS6D,GAAGlE,WAC3CA;YAEFS,SAAS,gLAAU,CAACS,SAAS,CAC3B,gLAAU,CAAC+C,GAAG,CAACH,aAAaC,YAAYtD,SACxCA;YAEFF,WAAWC,MAAMC,QAAQC,MAAMC,OAAOC,MAAMC;YAE5CmC,KAAKrC,QAAQ;YACbmC,KAAKE,KAAK;YACVD,KAAK,CAACnC,OAAO,CAAC,IAAI;YAClBiC,KAAKE,KAAK;YACVK,OAAO,CAACE,QAAQ,GAAGT;YACnBO,OAAO,CAACE,QAAQ,GAAGR;YACnBM,OAAO,CAACE,QAAQ,GAAGP;YACnBK,OAAO,CAACE,QAAQ,GAAGP;YACnBK,OAAO,CAACE,QAAQ,GAAGR;YACnBM,OAAO,CAACE,QAAQ,GAAGN;YAEnBrC,SAAS;YACTC,QAAQ;QACV;QACAD,SAAS;QACTC,QAAQ;IACV;IACAH,SAAS,gLAAU,CAAC+C,SAAS,CAC3B3B,iBACAA,gBAAgBxB,MAAM,GAAG,GACzBI;IAEFF,WAAWC,MAAMC,QAAQC,MAAMC,OAAOC,MAAMC;IAE5C,IAAIyB,iBAAiB;QACnB,kBAAkB;QAClB3B,SAAS;QACTC,QAAQ;QACRsC,UAAUvD;QACVsD,WAAWrD;QACX,MAAMiF,mBAAmBnD,YAAY,CAAC,EAAE;QACxC,IAAKtB,IAAI,GAAGA,IAAI+C,YAAY/C,IAAK;YAC/B8C,UAAU,gLAAU,CAACM,SAAS,CAC5BqB,kBACA,CAACtC,oBAAoBnC,IAAI,CAAC,IAAI,GAC9B8C;YAEFD,WAAW,gLAAU,CAACO,SAAS,CAACqB,kBAAkBzE,IAAI,GAAG6C;YACzD,6LAAuB,CAAC7B,YAAY,CAClCqB,gBACAS,SACAN,WACAhC;YAEF,6LAAuB,CAACQ,YAAY,CAACqB,gBAAgBQ,UAAUtC;YAC/DJ,WAAWC,MAAMC,QAAQC,MAAMC,OAAOC,MAAMC;YAE5CmC,KAAKrC,QAAQ;YACbmC,KAAKE,KAAK;YACVD,KAAK,CAACnC,OAAO,CAAC,IAAI;YAClBiC,KAAKE,KAAK;YACVK,OAAO,CAACE,QAAQ,GAAGT;YACnBO,OAAO,CAACE,QAAQ,GAAGR;YACnBM,OAAO,CAACE,QAAQ,GAAGP;YACnBK,OAAO,CAACE,QAAQ,GAAGP;YACnBK,OAAO,CAACE,QAAQ,GAAGR;YACnBM,OAAO,CAACE,QAAQ,GAAGN;YAEnBrC,SAAS;YACTC,QAAQ;QACV;IACF;IAEAkB,WAAWgD,QAAQ,GAAG,IAAI,uLAAiB,CAAC;QAC1CC,mBAAmB,uLAAiB,CAACC,MAAM;QAC3CC,wBAAwB;QACxBC,QAAQzC;IACV;IAEA,IAAI5B,aAAasE,EAAE,EAAE;QACnB,MAAMA,KAAK,IAAIxC,aAAa,AAACH,OAAO,IAAK;QACzC,IAAI4C;QACJ,IAAIC;QACJ,IAAIC,UAAU;QACd,IAAIhD,iBAAiB;YACnBN,aAAa;YACbC,cAAc;YACd,MAAMsD,QAAQC,KAAKC,EAAE,GAAG,CAAClD,oBAAoB,CAAC;YAC9C8C,SAAS,IAAI,CAACrD,YAAYO,oBAAoB,CAAC;YAC/C6C,UAAU,IAAI,CAACnD,aAAaM,oBAAoB,CAAC;YACjD,IAAImD;YACJ,MAAMC,aAAapD,oBAAoB;YACvC,IAAKnC,IAAIuF,aAAa,GAAGvF,IAAImC,oBAAoB,GAAGnC,IAAK;gBACvD,yBAAyB;gBACzBsF,IAAI,0KAAU,CAACE,WAAW,GAAGL,QAAQnF;gBACrC+E,EAAE,CAACG,UAAU,GAAGF,UAAU,CAAC,IAAII,KAAKK,GAAG,CAACH,EAAE;gBAC1CP,EAAE,CAACG,UAAU,GAAG,MAAM,CAAC,IAAIE,KAAKM,GAAG,CAACJ,EAAE;YACxC;YACA,IAAKtF,IAAI,GAAGA,IAAI6B,aAAaM,oBAAoB,GAAGnC,IAAK;gBACvD,cAAc;gBACd+E,EAAE,CAACG,UAAU,GAAGlF,IAAIgF;gBACpBD,EAAE,CAACG,UAAU,GAAG;YAClB;YACA,IAAKlF,IAAImC,mBAAmBnC,IAAIuF,YAAYvF,IAAK;gBAC/C,0BAA0B;gBAC1BsF,IAAI,0KAAU,CAACE,WAAW,GAAGxF,IAAImF;gBACjCJ,EAAE,CAACG,UAAU,GAAG,IAAIF,UAAU,CAAC,IAAII,KAAKK,GAAG,CAACH,EAAE;gBAC9CP,EAAE,CAACG,UAAU,GAAG,MAAM,CAAC,IAAIE,KAAKM,GAAG,CAACJ,EAAE;YACxC;YACA,IAAKtF,IAAIuF,YAAYvF,IAAI,GAAGA,IAAK;gBAC/B,0BAA0B;gBAC1BsF,IAAI,0KAAU,CAACE,WAAW,GAAGL,QAAQnF;gBACrC+E,EAAE,CAACG,UAAU,GAAG,IAAID,SAAS,CAAC,IAAIG,KAAKK,GAAG,CAACH,EAAE;gBAC7CP,EAAE,CAACG,UAAU,GAAG,MAAM,CAAC,IAAIE,KAAKM,GAAG,CAACJ,EAAE;YACxC;YACA,IAAKtF,IAAI4B,YAAYO,mBAAmBnC,IAAI,GAAGA,IAAK;gBAClD,WAAW;gBACX+E,EAAE,CAACG,UAAU,GAAGlF,IAAIiF;gBACpBF,EAAE,CAACG,UAAU,GAAG;YAClB;YACA,IAAKlF,IAAI,GAAGA,IAAIuF,aAAa,GAAGvF,IAAK;gBACnC,yBAAyB;gBACzBsF,IAAI,0KAAU,CAACE,WAAW,GAAGL,QAAQnF;gBACrC+E,EAAE,CAACG,UAAU,GAAGD,SAAS,CAAC,IAAIG,KAAKK,GAAG,CAACH,EAAE;gBACzCP,EAAE,CAACG,UAAU,GAAG,MAAM,CAAC,IAAIE,KAAKM,GAAG,CAACJ,EAAE;YACxC;QACF,OAAO;YACL1D,aAAa;YACbC,cAAc;YACdoD,SAAS,IAAI,CAACrD,YAAY,CAAC;YAC3BoD,UAAU,IAAI,CAACnD,aAAa,CAAC;YAC7B,IAAK7B,IAAI,GAAGA,IAAI6B,YAAY7B,IAAK;gBAC/B,cAAc;gBACd+E,EAAE,CAACG,UAAU,GAAGlF,IAAIgF;gBACpBD,EAAE,CAACG,UAAU,GAAG;YAClB;YACA,IAAKlF,IAAI4B,WAAW5B,IAAI,GAAGA,IAAK;gBAC9B,WAAW;gBACX+E,EAAE,CAACG,UAAU,GAAG,CAAClF,IAAI,CAAC,IAAIiF;gBAC1BF,EAAE,CAACG,UAAU,GAAG;YAClB;QACF;QAEAxD,WAAWqD,EAAE,GAAG,IAAI,uLAAiB,CAAC;YACpCJ,mBAAmB,uLAAiB,CAACgB,KAAK;YAC1Cd,wBAAwB;YACxBC,QAAQC;QACV;IACF;IAEA,IAAItE,aAAaJ,MAAM,EAAE;QACvBqB,WAAWrB,MAAM,GAAG,IAAI,uLAAiB,CAAC;YACxCsE,mBAAmB,uLAAiB,CAACgB,KAAK;YAC1Cd,wBAAwB;YACxBC,QAAQ1E,KAAKM,OAAO;QACtB;IACF;IAEA,IAAID,aAAaQ,OAAO,EAAE;QACxBS,WAAWT,OAAO,GAAG,IAAI,uLAAiB,CAAC;YACzC0D,mBAAmB,uLAAiB,CAACgB,KAAK;YAC1Cd,wBAAwB;YACxBC,QAAQ1E,KAAKO,QAAQ;QACvB;IACF;IAEA,IAAIF,aAAaS,SAAS,EAAE;QAC1BQ,WAAWR,SAAS,GAAG,IAAI,uLAAiB,CAAC;YAC3CyD,mBAAmB,uLAAiB,CAACgB,KAAK;YAC1Cd,wBAAwB;YACxBC,QAAQ1E,KAAKQ,UAAU;QACzB;IACF;IAEA,OAAO;QACLc,YAAYA;QACZsB,SAASA;IACX;AACF;AAEA,SAAS4C,mBAAmBlE,UAAU,EAAEjB,YAAY;IAClD,IACE,CAACA,aAAaJ,MAAM,IACpB,CAACI,aAAaQ,OAAO,IACrB,CAACR,aAAaS,SAAS,IACvB,CAACT,aAAasE,EAAE,EAChB;QACA,OAAOrD;IACT;IACA,MAAM5B,YAAY4B,WAAWgD,QAAQ,CAACI,MAAM;IAC5C,IAAIe;IACJ,IAAIC;IACJ,IAAIrF,aAAaJ,MAAM,IAAII,aAAaS,SAAS,EAAE;QACjD2E,aAAanE,WAAWrB,MAAM,CAACyE,MAAM;QACrCgB,gBAAgBpE,WAAWR,SAAS,CAAC4D,MAAM;IAC7C;IACA,MAAM1C,OAAOV,WAAWgD,QAAQ,CAACI,MAAM,CAAC7E,MAAM,GAAG;IACjD,MAAM8F,YAAY3D,OAAO;IACzB,MAAM4D,UAAU5D,OAAO;IACvB,MAAM6D,UAAUF,YAAY;IAC5B,IAAI/F;IACJ,IAAIS,aAAaJ,MAAM,IAAII,aAAaS,SAAS,IAAIT,aAAaQ,OAAO,EAAE;QACzE,MAAMP,UAAUD,aAAaJ,MAAM,GAC/B,IAAIkC,aAAawD,YAAY,KAC7BvD;QACJ,MAAM7B,WAAWF,aAAaQ,OAAO,GACjC,IAAIsB,aAAawD,YAAY,KAC7BvD;QACJ,MAAM5B,aAAaH,aAAaS,SAAS,GACrC,IAAIqB,aAAawD,YAAY,KAC7BvD;QACJ,IAAI0D,cAAc7G;QAClB,IAAI8G,iBAAiB7G;QACrB,IAAI8G,mBAAmB7G;QACvB,IAAIc,SAASb;QACb,IAAIyB,UAAUxB;QACd,IAAIyB,YAAYxB;QAChB,IAAI2G,YAAYJ;QAChB,IAAKjG,IAAI,GAAGA,IAAI+F,WAAW/F,KAAK,EAAG;YACjC,MAAMsG,kBAAkBD,YAAYJ;YACpCC,cAAc,gLAAU,CAAC9C,SAAS,CAACtD,WAAWE,GAAGkG;YACjDC,iBAAiB,gLAAU,CAAC/C,SAAS,CACnCtD,WACAE,IAAI+F,WACJI;YAEFC,mBAAmB,gLAAU,CAAChD,SAAS,CACrCtD,WACA,CAACE,IAAI,CAAC,IAAI+F,WACVK;YAEFD,iBAAiB,gLAAU,CAAC7B,QAAQ,CAClC6B,gBACAD,aACAC;YAEFC,mBAAmB,gLAAU,CAAC9B,QAAQ,CACpC8B,kBACAF,aACAE;YAEF/F,SAAS,gLAAU,CAACS,SAAS,CAC3B,gLAAU,CAACC,KAAK,CAACoF,gBAAgBC,kBAAkB/F,SACnDA;YAEF,IAAII,aAAaJ,MAAM,EAAE;gBACvB,6LAAuB,CAACW,YAAY,CAACN,SAASL,QAAQiG;gBACtD,6LAAuB,CAACtF,YAAY,CAClCN,SACAL,QACAiG,kBAAkB;gBAEpB,6LAAuB,CAACtF,YAAY,CAACN,SAASL,QAAQgG;gBACtD,6LAAuB,CAACrF,YAAY,CAACN,SAASL,QAAQgG,YAAY;YACpE;YACA,IAAI5F,aAAaQ,OAAO,IAAIR,aAAaS,SAAS,EAAE;gBAClDA,YAAY,gLAAU,CAACkC,SAAS,CAACyC,YAAY7F,GAAGkB;gBAChD,IAAIT,aAAaS,SAAS,EAAE;oBAC1B,6LAAuB,CAACF,YAAY,CAClCJ,YACAM,WACAoF;oBAEF,6LAAuB,CAACtF,YAAY,CAClCJ,YACAM,WACAoF,kBAAkB;oBAEpB,6LAAuB,CAACtF,YAAY,CAClCJ,YACAM,WACAmF;oBAEF,6LAAuB,CAACrF,YAAY,CAClCJ,YACAM,WACAmF,YAAY;gBAEhB;gBAEA,IAAI5F,aAAaQ,OAAO,EAAE;oBACxBA,UAAU,gLAAU,CAACH,SAAS,CAC5B,gLAAU,CAACC,KAAK,CAACG,WAAWb,QAAQY,UACpCA;oBAEF,6LAAuB,CAACD,YAAY,CAClCL,UACAM,SACAqF;oBAEF,6LAAuB,CAACtF,YAAY,CAClCL,UACAM,SACAqF,kBAAkB;oBAEpB,6LAAuB,CAACtF,YAAY,CAACL,UAAUM,SAASoF;oBACxD,6LAAuB,CAACrF,YAAY,CAClCL,UACAM,SACAoF,YAAY;gBAEhB;YACF;YACAA,aAAa;QACf;QAEA,IAAI5F,aAAaJ,MAAM,EAAE;YACvBK,QAAQ+C,GAAG,CAACoC,aAAa,KAAK;YAC9B,IAAK7F,IAAI,GAAGA,IAAI+F,WAAW/F,KAAK,EAAG;gBACjC,gBAAgB;gBAChBU,OAAO,CAACV,IAAI+F,UAAU,GAAG,CAACF,UAAU,CAAC7F,EAAE;gBACvCU,OAAO,CAACV,IAAI+F,YAAY,EAAE,GAAG,CAACF,UAAU,CAAC7F,IAAI,EAAE;gBAC/CU,OAAO,CAACV,IAAI+F,YAAY,EAAE,GAAG,CAACF,UAAU,CAAC7F,IAAI,EAAE;YACjD;YACA0B,WAAWrB,MAAM,CAACyE,MAAM,GAAGpE;QAC7B,OAAO;YACLgB,WAAWrB,MAAM,GAAGmC;QACtB;QAEA,IAAI/B,aAAaS,SAAS,EAAE;YAC1BN,WAAW6C,GAAG,CAACqC,gBAAgB,KAAK;YACpClF,WAAW6C,GAAG,CAACqC,eAAeC,YAAY,QAAQ;YAClDrE,WAAWR,SAAS,CAAC4D,MAAM,GAAGlE;QAChC,OAAO;YACLc,WAAWR,SAAS,GAAGsB;QACzB;QAEA,IAAI/B,aAAaQ,OAAO,EAAE;YACxB,MAAMsF,cAAc7E,WAAWT,OAAO,CAAC6D,MAAM;YAC7CnE,SAAS8C,GAAG,CAAC8C,cAAc,KAAK;YAChC5F,SAAS8C,GAAG,CAAC8C,aAAaR,YAAY,QAAQ;YAC9CrE,WAAWT,OAAO,CAAC6D,MAAM,GAAGnE;QAC9B;IACF;IACA,IAAIF,aAAasE,EAAE,EAAE;QACnB,MAAMyB,QAAQ9E,WAAWqD,EAAE,CAACD,MAAM;QAClC,MAAMC,KAAK,IAAIxC,aAAayD,UAAU;QACtCjB,GAAGtB,GAAG,CAAC+C,QAAQ,KAAK;QACpBzB,GAAGtB,GAAG,CAAC+C,OAAOR,UAAU,QAAQ;QAChC,IAAI9C,QAAQ8C,UAAU;QAEtB,IAAK,IAAIlC,IAAI,GAAGA,IAAI,GAAGA,IAAK;YAC1BiB,EAAE,CAAC7B,QAAQ,GAAGsD,KAAK,CAAC,EAAE;YACtBzB,EAAE,CAAC7B,QAAQ,GAAGsD,KAAK,CAAC,EAAE;YACtB,IAAKxG,IAAI,GAAGA,IAAIgG,SAAShG,KAAK,EAAG;gBAC/B,MAAMyG,IAAID,KAAK,CAACxG,EAAE;gBAClB,MAAM0G,IAAIF,KAAK,CAACxG,IAAI,EAAE;gBACtB+E,EAAE,CAAC7B,QAAQ,GAAGuD;gBACd1B,EAAE,CAAC7B,QAAQ,GAAGwD;gBACd3B,EAAE,CAAC7B,QAAQ,GAAGuD;gBACd1B,EAAE,CAAC7B,QAAQ,GAAGwD;YAChB;YACA3B,EAAE,CAAC7B,QAAQ,GAAGsD,KAAK,CAAC,EAAE;YACtBzB,EAAE,CAAC7B,QAAQ,GAAGsD,KAAK,CAAC,EAAE;QACxB;QACA9E,WAAWqD,EAAE,CAACD,MAAM,GAAGC;IACzB;IAEA,OAAOrD;AACT;AAEA,SAASiF,iBAAiB7G,SAAS,EAAEoD,KAAK,EAAE0D,aAAa;IACvDA,aAAa,CAAC1D,QAAQ,GAAGpD,SAAS,CAAC,EAAE;IACrC8G,aAAa,CAAC1D,QAAQ,GAAGpD,SAAS,CAAC,EAAE;IACrC8G,aAAa,CAAC1D,QAAQ,GAAGpD,SAAS,CAAC,EAAE;IACrC,IAAK,IAAIE,IAAI,GAAGA,IAAIF,UAAUG,MAAM,EAAED,KAAK,EAAG;QAC5C,MAAM6G,IAAI/G,SAAS,CAACE,EAAE;QACtB,MAAM8G,IAAIhH,SAAS,CAACE,IAAI,EAAE;QAC1B,MAAM+G,IAAIjH,SAAS,CAACE,IAAI,EAAE;QAC1B4G,aAAa,CAAC1D,QAAQ,GAAG2D;QACzBD,aAAa,CAAC1D,QAAQ,GAAG4D;QACzBF,aAAa,CAAC1D,QAAQ,GAAG6D;QACzBH,aAAa,CAAC1D,QAAQ,GAAG2D;QACzBD,aAAa,CAAC1D,QAAQ,GAAG4D;QACzBF,aAAa,CAAC1D,QAAQ,GAAG6D;IAC3B;IACAH,aAAa,CAAC1D,QAAQ,GAAGpD,SAAS,CAAC,EAAE;IACrC8G,aAAa,CAAC1D,QAAQ,GAAGpD,SAAS,CAAC,EAAE;IACrC8G,aAAa,CAAC1D,QAAQ,GAAGpD,SAAS,CAAC,EAAE;IAErC,OAAO8G;AACT;AAEA,SAASI,yBAAyBC,MAAM,EAAExG,YAAY;IACpD,MAAMyG,kBAAkB,IAAI,kLAAY,CAAC;QACvCxC,UAAUjE,aAAaiE,QAAQ;QAC/BrE,QACEI,aAAaJ,MAAM,IAAII,aAAaS,SAAS,IAAI+F,OAAOE,YAAY;QACtElG,SAASR,aAAaQ,OAAO;QAC7BC,WAAWT,aAAaJ,MAAM,IAAII,aAAaS,SAAS;QACxD6D,IAAItE,aAAasE,EAAE;IACrB;IACA,MAAMhF,YAAYkH,OAAOlH,SAAS;IAClC,MAAMqB,oBAAoB,6LAAuB,CAACgG,gBAAgB,CAACH;IACnE,MAAM7G,OAAOe,QAAQC,mBAAmB8F,iBAAiBnH;IACzD,MAAMsH,SAASJ,OAAOI,MAAM;IAC5B,MAAMC,iBAAiBL,OAAOK,cAAc;IAC5C,IAAI5F,aAAatB,KAAKsB,UAAU;IAChC,MAAMsB,UAAU5C,KAAK4C,OAAO;IAC5B,IAAIlD,YAAY4B,WAAWgD,QAAQ,CAACI,MAAM;IAC1C,IAAI7E,SAASH,UAAUG,MAAM;IAC7B,MAAMsH,eAAe,IAAIjF,aAAarC,SAAS;IAC/C,IAAIuH,oBAAoB,IAAIlF,aAAarC;IACzCuH,kBAAkB/D,GAAG,CAAC3D;IACtB,IAAI8G,gBAAgB,IAAItE,aAAarC,SAAS;IAE9CH,YAAY,qLAAe,CAAC2H,qBAAqB,CAC/C3H,WACAuH,QACAtH;IAEF6G,gBAAgBD,iBAAiB7G,WAAW,GAAG8G;IAC/CY,oBAAoB,qLAAe,CAACC,qBAAqB,CACvDD,mBACAF,gBACAvH;IAEF6G,gBAAgBD,iBACda,mBACAvH,SAAS,GACT2G;IAEFW,aAAa9D,GAAG,CAAC3D;IACjByH,aAAa9D,GAAG,CAAC+D,mBAAmBvH;IACpCsH,aAAa9D,GAAG,CAACmD,eAAe3G,SAAS;IACzCyB,WAAWgD,QAAQ,CAACI,MAAM,GAAGyC;IAE7B7F,aAAakE,mBAAmBlE,YAAYjB;IAC5C,IAAIT;IACJ,MAAMoC,OAAOnC,SAAS;IACtB,IAAIgH,OAAOE,YAAY,EAAE;QACvB,MAAMtB,aAAanE,WAAWrB,MAAM,CAACyE,MAAM;QAC3C7E,SAAS4F,WAAW5F,MAAM;QAE1B,IAAIyH,iBAAiB,IAAInF,aAAatC,SAAS;QAC/C,IAAKD,IAAI,GAAGA,IAAIC,QAAQD,IAAK;YAC3B6F,UAAU,CAAC7F,EAAE,GAAG,CAAC6F,UAAU,CAAC7F,EAAE;QAChC;QACA,kEAAkE;QAClE0H,eAAejE,GAAG,CAACoC,YAAY5F,SAAS,aAAa;QACrDyH,iBAAiBf,iBAAiBd,YAAY5F,SAAS,GAAGyH,iBAAiB,aAAa;QACxFhG,WAAWiG,gBAAgB,GAAG,IAAI,uLAAiB,CAAC;YAClDhD,mBAAmB,uLAAiB,CAACgB,KAAK;YAC1Cd,wBAAwB;YACxBC,QAAQ4C;QACV;QACA,IAAI,CAACjH,aAAaJ,MAAM,EAAE;YACxBqB,WAAWrB,MAAM,GAAGmC;QACtB;IACF;IACA,IAAI,IAAA,6KAAO,EAACyE,OAAOW,eAAe,GAAG;QACnC,IAAIC,cAAc,IAAIC,WAAW1F,OAAO;QACxC,IAAI6E,OAAOW,eAAe,KAAK,6LAAuB,CAACG,GAAG,EAAE;YAC1DF,cAAcA,YACXG,IAAI,CAAC,GAAG,GAAG5F,MAAM,WAAW;aAC5B4F,IAAI,CAAC,GAAG5F,OAAO,GAAGA,OAAO,IAAI,WAAW;QAC7C,OAAO;YACL,MAAM6F,mBACJhB,OAAOW,eAAe,KAAK,6LAAuB,CAACM,IAAI,GAAG,IAAI;YAChEL,cAAcA,YAAYG,IAAI,CAACC;QACjC;QACAvG,WAAWmG,WAAW,GAAG,IAAI,uLAAiB,CAAC;YAC7ClD,mBAAmB,uLAAiB,CAACwD,aAAa;YAClDtD,wBAAwB;YACxBC,QAAQ+C;QACV;IACF;IAEA,MAAMO,UAAUpF,QAAQ/C,MAAM;IAC9B,MAAM+F,UAAU5D,OAAOA;IACvB,MAAMiG,aAAa,mLAAa,CAACpF,gBAAgB,CAC/CsE,aAAatH,MAAM,GAAG,GACtBmI,UAAU,IAAIpC,UAAU;IAE1BqC,WAAW5E,GAAG,CAACT;IACf,IAAIE,QAAQkF;IACZ,IAAKpI,IAAI,GAAGA,IAAIoI,SAASpI,KAAK,EAAG;QAC/B,iBAAiB;QACjB,MAAMsI,KAAKtF,OAAO,CAAChD,EAAE;QACrB,MAAMuI,KAAKvF,OAAO,CAAChD,IAAI,EAAE;QACzB,MAAMwI,KAAKxF,OAAO,CAAChD,IAAI,EAAE;QACzBqI,UAAU,CAACnF,QAAQ,GAAGsF,KAAKpG;QAC3BiG,UAAU,CAACnF,QAAQ,GAAGqF,KAAKnG;QAC3BiG,UAAU,CAACnF,QAAQ,GAAGoF,KAAKlG;IAC7B;IAEA,IAAIK,IAAIC,IAAIC,IAAIC;IAEhB,IAAK5C,IAAI,GAAGA,IAAIgG,SAAShG,KAAK,EAAG;QAC/B,cAAc;QACdyC,KAAKzC,IAAIgG;QACTtD,KAAKD,KAAKuD;QACVrD,KAAKF,KAAK;QACVG,KAAKF,KAAK;QACV2F,UAAU,CAACnF,QAAQ,GAAGT;QACtB4F,UAAU,CAACnF,QAAQ,GAAGR;QACtB2F,UAAU,CAACnF,QAAQ,GAAGP;QACtB0F,UAAU,CAACnF,QAAQ,GAAGP;QACtB0F,UAAU,CAACnF,QAAQ,GAAGR;QACtB2F,UAAU,CAACnF,QAAQ,GAAGN;IACxB;IAEA,OAAO;QACLlB,YAAYA;QACZsB,SAASqF;IACX;AACF;AAEA,MAAMI,oBAAoB,IAAI,gLAAU;AACxC,MAAMC,oBAAoB,IAAI,gLAAU;AACxC,MAAMC,sBAAsB,IAAI,kLAAY;AAE5C,SAASC,oBACPC,SAAS,EACTC,SAAS,EACT/I,SAAS,EACTgJ,SAAS,EACTC,GAAG,EACHC,GAAG;IAEH,wCAAwC;IACxC,MAAMC,YAAY,gLAAU,CAAC5E,QAAQ,CACnCwE,WACAD,WACAJ;IAEF,gLAAU,CAAC3H,SAAS,CAACoI,WAAWA;IAChC,MAAM7I,SAASN,UAAU6D,qBAAqB,CAACiF,WAAWH;IAC1D,MAAMS,kBAAkB,gLAAU,CAACpI,KAAK,CACtCmI,WACA7I,QACAoI;IAEF,gLAAU,CAACW,gBAAgB,CAACD,iBAAiBJ,WAAWI;IAExD,IAAIE,SAASL,IAAIM,QAAQ;IACzB,IAAIC,SAASP,IAAIQ,SAAS;IAC1B,IAAIC,SAASR,IAAIK,QAAQ;IACzB,IAAII,SAAST,IAAIO,SAAS;IAE1B,0BAA0B;IAC1B,gLAAU,CAAC3F,GAAG,CAACgF,WAAWM,iBAAiBT;IAC3C3I,UAAU4J,uBAAuB,CAACjB,mBAAmBC;IAErD,IAAIiB,MAAMjB,oBAAoBW,QAAQ;IACtC,IAAIO,MAAMlB,oBAAoBa,SAAS;IACvCH,SAASjE,KAAK4D,GAAG,CAACK,QAAQO;IAC1BL,SAASnE,KAAK4D,GAAG,CAACO,QAAQM;IAC1BJ,SAASrE,KAAK6D,GAAG,CAACQ,QAAQG;IAC1BF,SAAStE,KAAK6D,GAAG,CAACS,QAAQG;IAE1B,gLAAU,CAACvF,QAAQ,CAACuE,WAAWM,iBAAiBT;IAChD3I,UAAU4J,uBAAuB,CAACjB,mBAAmBC;IAErDiB,MAAMjB,oBAAoBW,QAAQ;IAClCO,MAAMlB,oBAAoBa,SAAS;IACnCH,SAASjE,KAAK4D,GAAG,CAACK,QAAQO;IAC1BL,SAASnE,KAAK4D,GAAG,CAACO,QAAQM;IAC1BJ,SAASrE,KAAK6D,GAAG,CAACQ,QAAQG;IAC1BF,SAAStE,KAAK6D,GAAG,CAACS,QAAQG;IAE1Bb,IAAIM,QAAQ,GAAGD;IACfL,IAAIQ,SAAS,GAAGD;IAChBN,IAAIK,QAAQ,GAAGG;IACfR,IAAIO,SAAS,GAAGE;AAClB;AAEA,MAAMI,yBAAyB,IAAI,gLAAU;AAC7C,MAAMC,uBAAuB,IAAI,gLAAU;AAC3C,MAAMC,yBAAyB,IAAI,kLAAY;AAC/C,MAAMC,yBAAyB,IAAI,kLAAY;AAE/C,SAASC,iBAAiBpK,SAAS,EAAEC,SAAS,EAAEoK,KAAK,EAAEC,UAAU,EAAEC,MAAM;IACvEvK,YAAYD,eAAeC,WAAWC;IACtC,MAAMuK,iBAAiB,IAAA,2LAAqB,EAC1CxK,WACA,gLAAU,CAACyK,aAAa;IAE1B,MAAMtK,SAASqK,eAAerK,MAAM;IACpC,IAAIA,SAAS,KAAKkK,SAAS,GAAG;QAC5B,OAAO,IAAI,+KAAS;IACtB;IACA,MAAMpB,YAAYoB,QAAQ;IAE1BH,uBAAuBV,QAAQ,GAAGkB,OAAOC,iBAAiB;IAC1DT,uBAAuBR,SAAS,GAAGgB,OAAOC,iBAAiB;IAC3DR,uBAAuBX,QAAQ,GAAGkB,OAAOE,iBAAiB;IAC1DT,uBAAuBT,SAAS,GAAGgB,OAAOE,iBAAiB;IAE3D,IAAId,KAAKC;IACT,IAAIO,eAAe,gLAAU,CAACO,OAAO,EAAE;QACrC,oBAAoB;QACpB,MAAMC,QAAQN,cAAc,CAAC,EAAE;QAC/B,gLAAU,CAAChG,QAAQ,CAACsG,OAAON,cAAc,CAAC,EAAE,EAAER;QAC9C,gLAAU,CAAChJ,SAAS,CAACgJ,wBAAwBA;QAC7C,gLAAU,CAACV,gBAAgB,CACzBU,wBACAf,WACAe;QAEF,gLAAU,CAACjG,GAAG,CAAC+G,OAAOd,wBAAwBC;QAE9ChK,UAAU4J,uBAAuB,CAC/BI,sBACApB;QAEFiB,MAAMjB,oBAAoBW,QAAQ;QAClCO,MAAMlB,oBAAoBa,SAAS;QACnCQ,uBAAuBV,QAAQ,GAAGlE,KAAK4D,GAAG,CACxCgB,uBAAuBV,QAAQ,EAC/BM;QAEFI,uBAAuBR,SAAS,GAAGpE,KAAK4D,GAAG,CACzCgB,uBAAuBR,SAAS,EAChCK;QAEFI,uBAAuBX,QAAQ,GAAGlE,KAAK6D,GAAG,CACxCgB,uBAAuBX,QAAQ,EAC/BM;QAEFK,uBAAuBT,SAAS,GAAGpE,KAAK6D,GAAG,CACzCgB,uBAAuBT,SAAS,EAChCK;IAEJ;IAEA,mBAAmB;IACnB,IAAK,IAAI7J,IAAI,GAAGA,IAAIC,SAAS,GAAG,EAAED,EAAG;QACnC4I,oBACE0B,cAAc,CAACtK,EAAE,EACjBsK,cAAc,CAACtK,IAAI,EAAE,EACrBD,WACAgJ,WACAiB,wBACAC;IAEJ;IAEA,uBAAuB;IACvB,MAAMY,OAAOP,cAAc,CAACrK,SAAS,EAAE;IACvC,gLAAU,CAACqE,QAAQ,CAACuG,MAAMP,cAAc,CAACrK,SAAS,EAAE,EAAE6J;IACtD,gLAAU,CAAChJ,SAAS,CAACgJ,wBAAwBA;IAC7C,gLAAU,CAACV,gBAAgB,CACzBU,wBACAf,WACAe;IAEF,gLAAU,CAACjG,GAAG,CAACgH,MAAMf,wBAAwBC;IAC7CnB,oBACEiC,MACAd,sBACAhK,WACAgJ,WACAiB,wBACAC;IAGF,IAAIG,eAAe,gLAAU,CAACO,OAAO,EAAE;QACrC,kBAAkB;QAClB5K,UAAU4J,uBAAuB,CAC/BI,sBACApB;QAEFiB,MAAMjB,oBAAoBW,QAAQ;QAClCO,MAAMlB,oBAAoBa,SAAS;QACnCQ,uBAAuBV,QAAQ,GAAGlE,KAAK4D,GAAG,CACxCgB,uBAAuBV,QAAQ,EAC/BM;QAEFI,uBAAuBR,SAAS,GAAGpE,KAAK4D,GAAG,CACzCgB,uBAAuBR,SAAS,EAChCK;QAEFI,uBAAuBX,QAAQ,GAAGlE,KAAK6D,GAAG,CACxCgB,uBAAuBX,QAAQ,EAC/BM;QAEFK,uBAAuBT,SAAS,GAAGpE,KAAK6D,GAAG,CACzCgB,uBAAuBT,SAAS,EAChCK;IAEJ;IAEA,MAAMiB,YAAY,IAAA,6KAAO,EAACT,UAAUA,SAAS,IAAI,+KAAS;IAC1DS,UAAUC,KAAK,GAAGd,uBAAuBX,QAAQ;IACjDwB,UAAUE,KAAK,GAAGhB,uBAAuBV,QAAQ;IACjDwB,UAAUG,IAAI,GAAGhB,uBAAuBT,SAAS;IACjDsB,UAAUI,IAAI,GAAGlB,uBAAuBR,SAAS;IAEjD,OAAOsB;AACT;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2BC,GACD,SAASK,iBAAiBC,OAAO;IAC/BA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IACxC,MAAMvL,YAAYsL,QAAQtL,SAAS;IACnC,MAAMqK,QAAQiB,QAAQjB,KAAK;IAE3B,yCAAyC;IACzC,2KAAK,CAACmB,OAAO,CAAC,qBAAqBxL;IACnC,2KAAK,CAACwL,OAAO,CAAC,iBAAiBnB;IAC/B,wBAAwB;IAExB,MAAM9C,SAAS+D,QAAQ/D,MAAM,IAAI;IACjC,MAAMC,iBAAiB8D,QAAQ9D,cAAc,IAAID;IAEjD,IAAI,CAACkE,UAAU,GAAGzL;IAClB,IAAI,CAAC0L,UAAU,GAAG,+KAAS,CAACC,KAAK,CAACL,QAAQrL,SAAS,IAAI,+KAAS,CAAC2L,OAAO;IACxE,IAAI,CAACC,aAAa,GAAG,kLAAY,CAACF,KAAK,CACrCL,QAAQ3K,YAAY,IAAI,kLAAY,CAACmL,OAAO;IAE9C,IAAI,CAACC,MAAM,GAAG1B;IACd,IAAI,CAAC2B,OAAO,GAAG1G,KAAK6D,GAAG,CAAC5B,QAAQC;IAChC,IAAI,CAACyE,eAAe,GAAG3G,KAAK4D,GAAG,CAAC3B,QAAQC;IACxC,IAAI,CAAC0E,WAAW,GAAGZ,QAAQhB,UAAU,IAAI,gLAAU,CAACO,OAAO;IAC3D,IAAI,CAACsB,YAAY,GAAGb,QAAQc,WAAW,IAAI,0KAAU,CAACC,kBAAkB;IACxE,IAAI,CAACC,aAAa,GAAGhB,QAAQjE,YAAY,IAAI;IAC7C,IAAI,CAACkF,WAAW,GAAG;IACnB,IAAI,CAACC,gBAAgB,GAAGlB,QAAQxD,eAAe;IAC/C,IAAI,CAAC2E,UAAU,GAAG/J;IAElB;;;GAGC,GACD,IAAI,CAACgK,YAAY,GACf,IACA1M,UAAUG,MAAM,GAAG,gLAAU,CAACuM,YAAY,GAC1C,+KAAS,CAACA,YAAY,GACtB,kLAAY,CAACA,YAAY,GACzB;AACJ;AAEA;;;;;;;;CAQC,GACDrB,iBAAiBsB,IAAI,GAAG,SAAUC,KAAK,EAAEC,KAAK,EAAEC,aAAa;IAC3D,yCAAyC;IACzC,2KAAK,CAACtB,OAAO,CAAC,SAASoB;IACvB,2KAAK,CAACpB,OAAO,CAAC,SAASqB;IACvB,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjC,MAAM9M,YAAY4M,MAAMnB,UAAU;IAClC,MAAMtL,SAASH,UAAUG,MAAM;IAC/B0M,KAAK,CAACC,gBAAgB,GAAG3M;IAEzB,IAAK,IAAID,IAAI,GAAGA,IAAIC,QAAQ,EAAED,GAAG4M,iBAAiB,gLAAU,CAACJ,YAAY,CAAE;QACzE,gLAAU,CAACC,IAAI,CAAC3M,SAAS,CAACE,EAAE,EAAE2M,OAAOC;IACvC;IAEA,+KAAS,CAACH,IAAI,CAACC,MAAMlB,UAAU,EAAEmB,OAAOC;IACxCA,iBAAiB,+KAAS,CAACJ,YAAY;IAEvC,kLAAY,CAACC,IAAI,CAACC,MAAMf,aAAa,EAAEgB,OAAOC;IAC9CA,iBAAiB,kLAAY,CAACJ,YAAY;IAE1CG,KAAK,CAACC,gBAAgB,GAAGF,MAAMb,MAAM;IACrCc,KAAK,CAACC,gBAAgB,GAAGF,MAAMZ,OAAO;IACtCa,KAAK,CAACC,gBAAgB,GAAGF,MAAMX,eAAe;IAC9CY,KAAK,CAACC,gBAAgB,GAAGF,MAAMV,WAAW;IAC1CW,KAAK,CAACC,gBAAgB,GAAGF,MAAMT,YAAY;IAC3CU,KAAK,CAACC,gBAAgB,GAAGF,MAAMN,aAAa,GAAG,MAAM;IACrDO,KAAK,CAACC,cAAc,GAAGF,MAAMJ,gBAAgB,IAAI,CAAC;IAElD,OAAOK;AACT;AAEA,MAAME,mBAAmB,+KAAS,CAACpB,KAAK,CAAC,+KAAS,CAACqB,WAAW;AAC9D,MAAMC,sBAAsB,IAAI,kLAAY;AAC5C,MAAMC,iBAAiB;IACrBlN,WAAW0C;IACXzC,WAAW8M;IACXpM,cAAcsM;IACd5C,OAAO3H;IACP6E,QAAQ7E;IACR8E,gBAAgB9E;IAChB4H,YAAY5H;IACZ0J,aAAa1J;IACb2E,cAAc3E;IACdoF,iBAAiBpF;AACnB;AAEA;;;;;;;CAOC,GACD2I,iBAAiB8B,MAAM,GAAG,SAAUN,KAAK,EAAEC,aAAa,EAAEvC,MAAM;IAC9D,yCAAyC;IACzC,2KAAK,CAACiB,OAAO,CAAC,SAASqB;IACvB,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjC,MAAM3M,SAAS0M,KAAK,CAACC,gBAAgB;IACrC,MAAM9M,YAAY,IAAIoN,MAAMjN;IAE5B,IAAK,IAAID,IAAI,GAAGA,IAAIC,QAAQ,EAAED,GAAG4M,iBAAiB,gLAAU,CAACJ,YAAY,CAAE;QACzE1M,SAAS,CAACE,EAAE,GAAG,gLAAU,CAACiN,MAAM,CAACN,OAAOC;IAC1C;IAEA,MAAM7M,YAAY,+KAAS,CAACkN,MAAM,CAACN,OAAOC,eAAeC;IACzDD,iBAAiB,+KAAS,CAACJ,YAAY;IAEvC,MAAM/L,eAAe,kLAAY,CAACwM,MAAM,CACtCN,OACAC,eACAG;IAEFH,iBAAiB,kLAAY,CAACJ,YAAY;IAE1C,MAAMrC,QAAQwC,KAAK,CAACC,gBAAgB;IACpC,MAAMvF,SAASsF,KAAK,CAACC,gBAAgB;IACrC,MAAMtF,iBAAiBqF,KAAK,CAACC,gBAAgB;IAC7C,MAAMxC,aAAauC,KAAK,CAACC,gBAAgB;IACzC,MAAMV,cAAcS,KAAK,CAACC,gBAAgB;IAC1C,MAAMzF,eAAewF,KAAK,CAACC,gBAAgB,KAAK;IAChD,MAAMhF,kBAAkB+E,KAAK,CAACC,cAAc;IAE5C,IAAI,CAAC,IAAA,6KAAO,EAACvC,SAAS;QACpB2C,eAAelN,SAAS,GAAGA;QAC3BkN,eAAe7C,KAAK,GAAGA;QACvB6C,eAAe3F,MAAM,GAAGA;QACxB2F,eAAe1F,cAAc,GAAGA;QAChC0F,eAAe5C,UAAU,GAAGA;QAC5B4C,eAAed,WAAW,GAAGA;QAC7Bc,eAAe7F,YAAY,GAAGA;QAC9B6F,eAAepF,eAAe,GAC5BA,oBAAoB,CAAC,IAAIpF,YAAYoF;QAEvC,OAAO,IAAIuD,iBAAiB6B;IAC9B;IAEA3C,OAAOkB,UAAU,GAAGzL;IACpBuK,OAAOmB,UAAU,GAAG,+KAAS,CAACC,KAAK,CAAC1L,WAAWsK,OAAOmB,UAAU;IAChEnB,OAAOsB,aAAa,GAAG,kLAAY,CAACF,KAAK,CAAChL,cAAc4J,OAAOsB,aAAa;IAC5EtB,OAAOwB,MAAM,GAAG1B;IAChBE,OAAOyB,OAAO,GAAGzE;IACjBgD,OAAO0B,eAAe,GAAGzE;IACzB+C,OAAO2B,WAAW,GAAG5B;IACrBC,OAAO4B,YAAY,GAAGC;IACtB7B,OAAO+B,aAAa,GAAGjF;IACvBkD,OAAOiC,gBAAgB,GACrB1E,oBAAoB,CAAC,IAAIpF,YAAYoF;IAEvC,OAAOyC;AACT;AAEA;;;;;;;;;;;CAWC,GACDc,iBAAiBjB,gBAAgB,GAAG,SAAUkB,OAAO,EAAEf,MAAM;IAC3De,UAAUA,WAAW,4KAAM,CAACC,YAAY;IACxC,MAAMvL,YAAYsL,QAAQtL,SAAS;IACnC,MAAMqK,QAAQiB,QAAQjB,KAAK;IAE3B,yCAAyC;IACzC,2KAAK,CAACmB,OAAO,CAAC,qBAAqBxL;IACnC,2KAAK,CAACwL,OAAO,CAAC,iBAAiBnB;IAC/B,wBAAwB;IAExB,MAAMpK,YAAYqL,QAAQrL,SAAS,IAAI,+KAAS,CAAC2L,OAAO;IACxD,MAAMtB,aAAagB,QAAQhB,UAAU,IAAI,gLAAU,CAACO,OAAO;IAE3D,OAAOT,iBAAiBpK,WAAWC,WAAWoK,OAAOC,YAAYC;AACnE;AAEA;;;;;CAKC,GACDc,iBAAiBgC,cAAc,GAAG,SAAUC,gBAAgB;IAC1D,IAAItN,YAAYsN,iBAAiB7B,UAAU;IAC3C,MAAMpB,QAAQiD,iBAAiBvB,MAAM;IACrC,MAAM9L,YAAYqN,iBAAiB5B,UAAU;IAE7C1L,YAAYD,eAAeC,WAAWC;IACtC,MAAMuK,iBAAiB,IAAA,2LAAqB,EAC1CxK,WACA,gLAAU,CAACyK,aAAa;IAG1B,IAAID,eAAerK,MAAM,GAAG,KAAKkK,SAAS,GAAG;QAC3C;IACF;IAEA,MAAM9C,SAAS+F,iBAAiBtB,OAAO;IACvC,MAAMxE,iBAAiB8F,iBAAiBrB,eAAe;IACvD,MAAMsB,UAAU,CAAC,0KAAU,CAAC9C,aAAa,CACvClD,QACAC,gBACA,GACA,0KAAU,CAACgG,QAAQ;IAGrB,MAAM7M,eAAe2M,iBAAiBzB,aAAa;IACnD,MAAM1E,SAAS;QACblH,WAAWA;QACXD,WAAWwK;QACXH,OAAOA;QACPC,YAAYgD,iBAAiBpB,WAAW;QACxCE,aAAakB,iBAAiBnB,YAAY;QAC1CsB,gBAAgB;IAClB;IACA,IAAInN;IACJ,IAAIiN,SAAS;QACXpG,OAAOI,MAAM,GAAGA;QAChBJ,OAAOK,cAAc,GAAGA;QACxBL,OAAOE,YAAY,GAAGiG,iBAAiBhB,aAAa;QACpDnF,OAAOW,eAAe,GAAGwF,iBAAiBd,gBAAgB;QAC1DlM,OAAO4G,yBAAyBC,QAAQxG;IAC1C,OAAO;QACL,MAAMW,oBAAoB,6LAAuB,CAACgG,gBAAgB,CAACH;QACnE7G,OAAOe,QAAQC,mBAAmBX,cAAcV;QAChDK,KAAKsB,UAAU,CAACgD,QAAQ,CAACI,MAAM,GAAG,qLAAe,CAAC2C,qBAAqB,CACrErH,KAAKsB,UAAU,CAACgD,QAAQ,CAACI,MAAM,EAC/BuC,QACAtH;QAGF,IAAI,IAAA,6KAAO,EAACqN,iBAAiBd,gBAAgB,GAAG;YAC9C,MAAMrE,mBACJmF,iBAAiBd,gBAAgB,KAAK,6LAAuB,CAACpE,IAAI,GAC9D,IACA;YACN,MAAMjI,SAASG,KAAKsB,UAAU,CAACgD,QAAQ,CAACI,MAAM,CAAC7E,MAAM;YACrD,MAAM4H,cAAc,IAAIC,WAAW7H,SAAS,GAAG+H,IAAI,CAACC;YACpD7H,KAAKsB,UAAU,CAACmG,WAAW,GAAG,IAAI,uLAAiB,CAAC;gBAClDlD,mBAAmB,uLAAiB,CAACwD,aAAa;gBAClDtD,wBAAwB;gBACxBC,QAAQ+C;YACV;QACF;IACF;IACA,MAAMnG,aAAatB,KAAKsB,UAAU;IAClC,MAAM8L,iBAAiB,oLAAc,CAACC,YAAY,CAChD/L,WAAWgD,QAAQ,CAACI,MAAM,EAC1BtC,WACA;IAEF,IAAI,CAAC/B,aAAaiE,QAAQ,EAAE;QAC1BtE,KAAKsB,UAAU,CAACgD,QAAQ,CAACI,MAAM,GAAGtC;IACpC;IAEA,OAAO,IAAI,8KAAQ,CAAC;QAClBd,YAAYA;QACZsB,SAAS5C,KAAK4C,OAAO;QACrB0K,eAAe,mLAAa,CAACC,SAAS;QACtCH,gBAAgBA;QAChB5F,iBAAiBwF,iBAAiBd,gBAAgB;IACpD;AACF;AAEA;;CAEC,GACDnB,iBAAiByC,kBAAkB,GAAG,SACpCR,gBAAgB,EAChBS,aAAa,EACbC,aAAa;IAEb,MAAM5B,cAAckB,iBAAiBnB,YAAY;IACjD,MAAMlM,YAAYqN,iBAAiB5B,UAAU;IAE7C,MAAMuC,YAAYF,cAAc3B,aAAanM;IAC7C,MAAMiO,YAAYF,cAAc5B,aAAanM;IAE7C,OAAO,IAAIoL,iBAAiB;QAC1BrL,WAAWsN,iBAAiB7B,UAAU;QACtCpB,OAAOiD,iBAAiBvB,MAAM;QAC9BzB,YAAYgD,iBAAiBpB,WAAW;QACxCjM,WAAWA;QACXmM,aAAaA;QACb5E,gBAAgByG;QAChB1G,QAAQ2G;QACRvN,cAAc,kLAAY,CAACwN,aAAa;QACxC9G,cAAc;IAChB;AACF;AAEA+G,OAAOC,gBAAgB,CAAChD,iBAAiBiD,SAAS,EAAE;IAClD;;GAEC,GACDtD,WAAW;QACTuD,KAAK;YACH,IAAI,CAAC,IAAA,6KAAO,EAAC,IAAI,CAAC9B,UAAU,GAAG;gBAC7B,IAAI,CAACA,UAAU,GAAGrC,iBAChB,IAAI,CAACqB,UAAU,EACf,IAAI,CAACC,UAAU,EACf,IAAI,CAACK,MAAM,EACX,IAAI,CAACG,WAAW;YAEpB;YACA,OAAO,IAAI,CAACO,UAAU;QACxB;IACF;IACA;;;;;;GAMC,GACD+B,iCAAiC;QAC/BD,KAAK;YACH,OAAO;gBAAC;gBAAG;gBAAG;gBAAG;gBAAG;gBAAG;aAAE;QAC3B;IACF;AACF;uCACelD","ignoreList":[0]}},
    {"offset": {"line": 37544, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/CorridorOutlineGeometry.js"],"sourcesContent":["import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport CorridorGeometryLibrary from \"./CorridorGeometryLibrary.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nconst cartesian1 = new Cartesian3();\nconst cartesian2 = new Cartesian3();\nconst cartesian3 = new Cartesian3();\n\nfunction scaleToSurface(positions, ellipsoid) {\n  for (let i = 0; i < positions.length; i++) {\n    positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n  }\n  return positions;\n}\n\nfunction combine(computedPositions, cornerType) {\n  const wallIndices = [];\n  const positions = computedPositions.positions;\n  const corners = computedPositions.corners;\n  const endPositions = computedPositions.endPositions;\n  const attributes = new GeometryAttributes();\n  let corner;\n  let leftCount = 0;\n  let rightCount = 0;\n  let i;\n  let indicesLength = 0;\n  let length;\n  for (i = 0; i < positions.length; i += 2) {\n    length = positions[i].length - 3;\n    leftCount += length; //subtracting 3 to account for duplicate points at corners\n    indicesLength += (length / 3) * 4;\n    rightCount += positions[i + 1].length - 3;\n  }\n  leftCount += 3; //add back count for end positions\n  rightCount += 3;\n  for (i = 0; i < corners.length; i++) {\n    corner = corners[i];\n    const leftSide = corners[i].leftPositions;\n    if (defined(leftSide)) {\n      length = leftSide.length;\n      leftCount += length;\n      indicesLength += (length / 3) * 2;\n    } else {\n      length = corners[i].rightPositions.length;\n      rightCount += length;\n      indicesLength += (length / 3) * 2;\n    }\n  }\n\n  const addEndPositions = defined(endPositions);\n  let endPositionLength;\n  if (addEndPositions) {\n    endPositionLength = endPositions[0].length - 3;\n    leftCount += endPositionLength;\n    rightCount += endPositionLength;\n    endPositionLength /= 3;\n    indicesLength += endPositionLength * 4;\n  }\n  const size = leftCount + rightCount;\n  const finalPositions = new Float64Array(size);\n  let front = 0;\n  let back = size - 1;\n  let UL, LL, UR, LR;\n  let rightPos, leftPos;\n  const halfLength = endPositionLength / 2;\n\n  const indices = IndexDatatype.createTypedArray(size / 3, indicesLength + 4);\n  let index = 0;\n\n  indices[index++] = front / 3;\n  indices[index++] = (back - 2) / 3;\n  if (addEndPositions) {\n    // add rounded end\n    wallIndices.push(front / 3);\n    leftPos = cartesian1;\n    rightPos = cartesian2;\n    const firstEndPositions = endPositions[0];\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength - 1 - i) * 3,\n        leftPos,\n      );\n      rightPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength + i) * 3,\n        rightPos,\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back,\n      );\n\n      LL = front / 3;\n      LR = LL + 1;\n      UL = (back - 2) / 3;\n      UR = UL - 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  let posIndex = 0;\n  let rightEdge = positions[posIndex++]; //add first two edges\n  let leftEdge = positions[posIndex++];\n  finalPositions.set(rightEdge, front);\n  finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n  length = leftEdge.length - 3;\n  wallIndices.push(front / 3, (back - 2) / 3);\n  for (i = 0; i < length; i += 3) {\n    LL = front / 3;\n    LR = LL + 1;\n    UL = (back - 2) / 3;\n    UR = UL - 1;\n    indices[index++] = UL;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n\n    front += 3;\n    back -= 3;\n  }\n\n  for (i = 0; i < corners.length; i++) {\n    let j;\n    corner = corners[i];\n    const l = corner.leftPositions;\n    const r = corner.rightPositions;\n    let start;\n    let outsidePoint = cartesian3;\n    if (defined(l)) {\n      back -= 3;\n      start = UR;\n      wallIndices.push(LR);\n      for (j = 0; j < l.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n        indices[index++] = start - j - 1;\n        indices[index++] = start - j;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          undefined,\n          back,\n        );\n        back -= 3;\n      }\n      wallIndices.push(start - Math.floor(l.length / 6));\n      if (cornerType === CornerType.BEVELED) {\n        wallIndices.push((back - 2) / 3 + 1);\n      }\n      front += 3;\n    } else {\n      front += 3;\n      start = LR;\n      wallIndices.push(UR);\n      for (j = 0; j < r.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n        indices[index++] = start + j;\n        indices[index++] = start + j + 1;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          front,\n        );\n        front += 3;\n      }\n      wallIndices.push(start + Math.floor(r.length / 6));\n      if (cornerType === CornerType.BEVELED) {\n        wallIndices.push(front / 3 - 1);\n      }\n      back -= 3;\n    }\n    rightEdge = positions[posIndex++];\n    leftEdge = positions[posIndex++];\n    rightEdge.splice(0, 3); //remove duplicate points added by corner\n    leftEdge.splice(leftEdge.length - 3, 3);\n    finalPositions.set(rightEdge, front);\n    finalPositions.set(leftEdge, back - leftEdge.length + 1);\n    length = leftEdge.length - 3;\n\n    for (j = 0; j < leftEdge.length; j += 3) {\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n      front += 3;\n      back -= 3;\n    }\n    front -= 3;\n    back += 3;\n    wallIndices.push(front / 3, (back - 2) / 3);\n  }\n\n  if (addEndPositions) {\n    // add rounded end\n    front += 3;\n    back -= 3;\n    leftPos = cartesian1;\n    rightPos = cartesian2;\n    const lastEndPositions = endPositions[1];\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        lastEndPositions,\n        (endPositionLength - i - 1) * 3,\n        leftPos,\n      );\n      rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back,\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n\n    wallIndices.push(front / 3);\n  } else {\n    wallIndices.push(front / 3, (back - 2) / 3);\n  }\n  indices[index++] = front / 3;\n  indices[index++] = (back - 2) / 3;\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions,\n  });\n\n  return {\n    attributes: attributes,\n    indices: indices,\n    wallIndices: wallIndices,\n  };\n}\n\nfunction computePositionsExtruded(params) {\n  const ellipsoid = params.ellipsoid;\n  const computedPositions = CorridorGeometryLibrary.computePositions(params);\n  const attr = combine(computedPositions, params.cornerType);\n  const wallIndices = attr.wallIndices;\n  const height = params.height;\n  const extrudedHeight = params.extrudedHeight;\n  const attributes = attr.attributes;\n  const indices = attr.indices;\n  let positions = attributes.position.values;\n  let length = positions.length;\n  let extrudedPositions = new Float64Array(length);\n  extrudedPositions.set(positions);\n  const newPositions = new Float64Array(length * 2);\n\n  positions = PolygonPipeline.scaleToGeodeticHeight(\n    positions,\n    height,\n    ellipsoid,\n  );\n  extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(\n    extrudedPositions,\n    extrudedHeight,\n    ellipsoid,\n  );\n  newPositions.set(positions);\n  newPositions.set(extrudedPositions, length);\n  attributes.position.values = newPositions;\n\n  length /= 3;\n  if (defined(params.offsetAttribute)) {\n    let applyOffset = new Uint8Array(length * 2);\n    if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = applyOffset.fill(1, 0, length);\n    } else {\n      const applyOffsetValue =\n        params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = applyOffset.fill(applyOffsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  let i;\n  const iLength = indices.length;\n  const newIndices = IndexDatatype.createTypedArray(\n    newPositions.length / 3,\n    (iLength + wallIndices.length) * 2,\n  );\n  newIndices.set(indices);\n  let index = iLength;\n  for (i = 0; i < iLength; i += 2) {\n    // bottom indices\n    const v0 = indices[i];\n    const v1 = indices[i + 1];\n    newIndices[index++] = v0 + length;\n    newIndices[index++] = v1 + length;\n  }\n\n  let UL, LL;\n  for (i = 0; i < wallIndices.length; i++) {\n    //wall indices\n    UL = wallIndices[i];\n    LL = UL + length;\n    newIndices[index++] = UL;\n    newIndices[index++] = LL;\n  }\n\n  return {\n    attributes: attributes,\n    indices: newIndices,\n  };\n}\n\n/**\n * A description of a corridor outline.\n *\n * @alias CorridorOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor outline.\n * @param {number} options.width The distance between the edges of the corridor outline.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number} [options.height=0] The distance in meters between the positions and the ellipsoid surface.\n * @param {number} [options.extrudedHeight] The distance in meters between the extruded face and the ellipsoid surface.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see CorridorOutlineGeometry.createGeometry\n *\n * @example\n * const corridor = new Cesium.CorridorOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });\n */\nfunction CorridorOutlineGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const positions = options.positions;\n  const width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.positions\", positions);\n  Check.typeOf.number(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  const height = options.height ?? 0.0;\n  const extrudedHeight = options.extrudedHeight ?? height;\n\n  this._positions = positions;\n  this._ellipsoid = Ellipsoid.clone(options.ellipsoid ?? Ellipsoid.default);\n  this._width = width;\n  this._height = Math.max(height, extrudedHeight);\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._cornerType = options.cornerType ?? CornerType.ROUNDED;\n  this._granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCorridorOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + 6;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CorridorOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCorridorOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const positions = value._positions;\n  const length = positions.length;\n  array[startingIndex++] = length;\n\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex] = value._offsetAttribute ?? -1;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchOptions = {\n  positions: undefined,\n  ellipsoid: scratchEllipsoid,\n  width: undefined,\n  height: undefined,\n  extrudedHeight: undefined,\n  cornerType: undefined,\n  granularity: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CorridorOutlineGeometry} [result] The object into which to store the result.\n * @returns {CorridorOutlineGeometry} The modified result parameter or a new CorridorOutlineGeometry instance if one was not provided.\n */\nCorridorOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const width = array[startingIndex++];\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const cornerType = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.width = width;\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CorridorOutlineGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._width = width;\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n *\n * @param {CorridorOutlineGeometry} corridorOutlineGeometry A description of the corridor.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCorridorOutlineGeometry.createGeometry = function (corridorOutlineGeometry) {\n  let positions = corridorOutlineGeometry._positions;\n  const width = corridorOutlineGeometry._width;\n  const ellipsoid = corridorOutlineGeometry._ellipsoid;\n\n  positions = scaleToSurface(positions, ellipsoid);\n  const cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon,\n  );\n\n  if (cleanPositions.length < 2 || width <= 0) {\n    return;\n  }\n\n  const height = corridorOutlineGeometry._height;\n  const extrudedHeight = corridorOutlineGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2,\n  );\n\n  const params = {\n    ellipsoid: ellipsoid,\n    positions: cleanPositions,\n    width: width,\n    cornerType: corridorOutlineGeometry._cornerType,\n    granularity: corridorOutlineGeometry._granularity,\n    saveAttributes: false,\n  };\n  let attr;\n  if (extrude) {\n    params.height = height;\n    params.extrudedHeight = extrudedHeight;\n    params.offsetAttribute = corridorOutlineGeometry._offsetAttribute;\n    attr = computePositionsExtruded(params);\n  } else {\n    const computedPositions = CorridorGeometryLibrary.computePositions(params);\n    attr = combine(computedPositions, params.cornerType);\n    attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      attr.attributes.position.values,\n      height,\n      ellipsoid,\n    );\n\n    if (defined(corridorOutlineGeometry._offsetAttribute)) {\n      const length = attr.attributes.position.values.length;\n      const offsetValue =\n        corridorOutlineGeometry._offsetAttribute ===\n        GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n      attr.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n  const attributes = attr.attributes;\n  const boundingSphere = BoundingSphere.fromVertices(\n    attributes.position.values,\n    undefined,\n    3,\n  );\n\n  return new Geometry({\n    attributes: attributes,\n    indices: attr.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: corridorOutlineGeometry._offsetAttribute,\n  });\n};\nexport default CorridorOutlineGeometry;\n"],"names":["cartesian1","cartesian2","cartesian3","scaleToSurface","positions","ellipsoid","i","length","scaleToGeodeticSurface","combine","computedPositions","cornerType","wallIndices","corners","endPositions","attributes","corner","leftCount","rightCount","indicesLength","leftSide","leftPositions","rightPositions","addEndPositions","endPositionLength","size","finalPositions","Float64Array","front","back","UL","LL","UR","LR","rightPos","leftPos","halfLength","indices","createTypedArray","index","push","firstEndPositions","fromArray","addAttribute","undefined","posIndex","rightEdge","leftEdge","set","j","l","r","start","outsidePoint","Math","floor","BEVELED","splice","lastEndPositions","position","componentDatatype","DOUBLE","componentsPerAttribute","values","computePositionsExtruded","params","computePositions","attr","height","extrudedHeight","extrudedPositions","newPositions","scaleToGeodeticHeight","offsetAttribute","applyOffset","Uint8Array","TOP","fill","applyOffsetValue","NONE","UNSIGNED_BYTE","iLength","newIndices","v0","v1","CorridorOutlineGeometry","options","EMPTY_OBJECT","width","typeOf","object","number","_positions","_ellipsoid","clone","default","_width","_height","max","_extrudedHeight","min","_cornerType","ROUNDED","_granularity","granularity","RADIANS_PER_DEGREE","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchOptions","unpack","result","Array","createGeometry","corridorOutlineGeometry","cleanPositions","equalsEpsilon","extrude","EPSILON2","saveAttributes","offsetValue","boundingSphere","fromVertices","primitiveType","LINES"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 38043, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/CylinderGeometryLibrary.js"],"sourcesContent":["import CesiumMath from \"./Math.js\";\n\n/**\n * @private\n */\nconst CylinderGeometryLibrary = {};\n\n/**\n * @private\n */\nCylinderGeometryLibrary.computePositions = function (\n  length,\n  topRadius,\n  bottomRadius,\n  slices,\n  fill,\n) {\n  const topZ = length * 0.5;\n  const bottomZ = -topZ;\n\n  const twoSlice = slices + slices;\n  const size = fill ? 2 * twoSlice : twoSlice;\n  const positions = new Float64Array(size * 3);\n  let i;\n  let index = 0;\n  let tbIndex = 0;\n  const bottomOffset = fill ? twoSlice * 3 : 0;\n  const topOffset = fill ? (twoSlice + slices) * 3 : slices * 3;\n\n  for (i = 0; i < slices; i++) {\n    const angle = (i / slices) * CesiumMath.TWO_PI;\n    const x = Math.cos(angle);\n    const y = Math.sin(angle);\n    const bottomX = x * bottomRadius;\n    const bottomY = y * bottomRadius;\n    const topX = x * topRadius;\n    const topY = y * topRadius;\n\n    positions[tbIndex + bottomOffset] = bottomX;\n    positions[tbIndex + bottomOffset + 1] = bottomY;\n    positions[tbIndex + bottomOffset + 2] = bottomZ;\n\n    positions[tbIndex + topOffset] = topX;\n    positions[tbIndex + topOffset + 1] = topY;\n    positions[tbIndex + topOffset + 2] = topZ;\n    tbIndex += 3;\n    if (fill) {\n      positions[index++] = bottomX;\n      positions[index++] = bottomY;\n      positions[index++] = bottomZ;\n      positions[index++] = topX;\n      positions[index++] = topY;\n      positions[index++] = topZ;\n    }\n  }\n\n  return positions;\n};\nexport default CylinderGeometryLibrary;\n"],"names":["CylinderGeometryLibrary","computePositions","length","topRadius","bottomRadius","slices","fill","topZ","bottomZ","twoSlice","size","positions","Float64Array","i","index","tbIndex","bottomOffset","topOffset","angle","TWO_PI","x","Math","cos","y","sin","bottomX","bottomY","topX","topY"],"mappings":";;;;AAAA;;AAEA;;CAEC,GACD,MAAMA,0BAA0B,CAAC;AAEjC;;CAEC,GACDA,wBAAwBC,gBAAgB,GAAG,SACzCC,MAAM,EACNC,SAAS,EACTC,YAAY,EACZC,MAAM,EACNC,IAAI;IAEJ,MAAMC,OAAOL,SAAS;IACtB,MAAMM,UAAU,CAACD;IAEjB,MAAME,WAAWJ,SAASA;IAC1B,MAAMK,OAAOJ,OAAO,IAAIG,WAAWA;IACnC,MAAME,YAAY,IAAIC,aAAaF,OAAO;IAC1C,IAAIG;IACJ,IAAIC,QAAQ;IACZ,IAAIC,UAAU;IACd,MAAMC,eAAeV,OAAOG,WAAW,IAAI;IAC3C,MAAMQ,YAAYX,OAAO,CAACG,WAAWJ,MAAM,IAAI,IAAIA,SAAS;IAE5D,IAAKQ,IAAI,GAAGA,IAAIR,QAAQQ,IAAK;QAC3B,MAAMK,QAAQ,AAACL,IAAIR,SAAU,0KAAU,CAACc,MAAM;QAC9C,MAAMC,IAAIC,KAAKC,GAAG,CAACJ;QACnB,MAAMK,IAAIF,KAAKG,GAAG,CAACN;QACnB,MAAMO,UAAUL,IAAIhB;QACpB,MAAMsB,UAAUH,IAAInB;QACpB,MAAMuB,OAAOP,IAAIjB;QACjB,MAAMyB,OAAOL,IAAIpB;QAEjBQ,SAAS,CAACI,UAAUC,aAAa,GAAGS;QACpCd,SAAS,CAACI,UAAUC,eAAe,EAAE,GAAGU;QACxCf,SAAS,CAACI,UAAUC,eAAe,EAAE,GAAGR;QAExCG,SAAS,CAACI,UAAUE,UAAU,GAAGU;QACjChB,SAAS,CAACI,UAAUE,YAAY,EAAE,GAAGW;QACrCjB,SAAS,CAACI,UAAUE,YAAY,EAAE,GAAGV;QACrCQ,WAAW;QACX,IAAIT,MAAM;YACRK,SAAS,CAACG,QAAQ,GAAGW;YACrBd,SAAS,CAACG,QAAQ,GAAGY;YACrBf,SAAS,CAACG,QAAQ,GAAGN;YACrBG,SAAS,CAACG,QAAQ,GAAGa;YACrBhB,SAAS,CAACG,QAAQ,GAAGc;YACrBjB,SAAS,CAACG,QAAQ,GAAGP;QACvB;IACF;IAEA,OAAOI;AACT;uCACeX","ignoreList":[0]}},
    {"offset": {"line": 38096, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/CylinderGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CylinderGeometryLibrary from \"./CylinderGeometryLibrary.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst radiusScratch = new Cartesian2();\nconst normalScratch = new Cartesian3();\nconst bitangentScratch = new Cartesian3();\nconst tangentScratch = new Cartesian3();\nconst positionScratch = new Cartesian3();\n\n/**\n * A description of a cylinder.\n *\n * @alias CylinderGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number} options.length The length of the cylinder.\n * @param {number} options.topRadius The radius of the top of the cylinder.\n * @param {number} options.bottomRadius The radius of the bottom of the cylinder.\n * @param {number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n *\n * @see CylinderGeometry.createGeometry\n *\n * @example\n * // create cylinder geometry\n * const cylinder = new Cesium.CylinderGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * const geometry = Cesium.CylinderGeometry.createGeometry(cylinder);\n */\nfunction CylinderGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const length = options.length;\n  const topRadius = options.topRadius;\n  const bottomRadius = options.bottomRadius;\n  const vertexFormat = options.vertexFormat ?? VertexFormat.DEFAULT;\n  const slices = options.slices ?? 128;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(length)) {\n    throw new DeveloperError(\"options.length must be defined.\");\n  }\n  if (!defined(topRadius)) {\n    throw new DeveloperError(\"options.topRadius must be defined.\");\n  }\n  if (!defined(bottomRadius)) {\n    throw new DeveloperError(\"options.bottomRadius must be defined.\");\n  }\n  if (slices < 3) {\n    throw new DeveloperError(\n      \"options.slices must be greater than or equal to 3.\",\n    );\n  }\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._length = length;\n  this._topRadius = topRadius;\n  this._bottomRadius = bottomRadius;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._slices = slices;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCylinderGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nCylinderGeometry.packedLength = VertexFormat.packedLength + 5;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CylinderGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCylinderGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._length;\n  array[startingIndex++] = value._topRadius;\n  array[startingIndex++] = value._bottomRadius;\n  array[startingIndex++] = value._slices;\n  array[startingIndex] = value._offsetAttribute ?? -1;\n\n  return array;\n};\n\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  vertexFormat: scratchVertexFormat,\n  length: undefined,\n  topRadius: undefined,\n  bottomRadius: undefined,\n  slices: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CylinderGeometry} [result] The object into which to store the result.\n * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.\n */\nCylinderGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const length = array[startingIndex++];\n  const topRadius = array[startingIndex++];\n  const bottomRadius = array[startingIndex++];\n  const slices = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.length = length;\n    scratchOptions.topRadius = topRadius;\n    scratchOptions.bottomRadius = bottomRadius;\n    scratchOptions.slices = slices;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CylinderGeometry(scratchOptions);\n  }\n\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._length = length;\n  result._topRadius = topRadius;\n  result._bottomRadius = bottomRadius;\n  result._slices = slices;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.\n *\n * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCylinderGeometry.createGeometry = function (cylinderGeometry) {\n  let length = cylinderGeometry._length;\n  const topRadius = cylinderGeometry._topRadius;\n  const bottomRadius = cylinderGeometry._bottomRadius;\n  const vertexFormat = cylinderGeometry._vertexFormat;\n  const slices = cylinderGeometry._slices;\n\n  if (\n    length <= 0 ||\n    topRadius < 0 ||\n    bottomRadius < 0 ||\n    (topRadius === 0 && bottomRadius === 0)\n  ) {\n    return;\n  }\n\n  const twoSlices = slices + slices;\n  const threeSlices = slices + twoSlices;\n  const numVertices = twoSlices + twoSlices;\n\n  const positions = CylinderGeometryLibrary.computePositions(\n    length,\n    topRadius,\n    bottomRadius,\n    slices,\n    true,\n  );\n\n  const st = vertexFormat.st ? new Float32Array(numVertices * 2) : undefined;\n  const normals = vertexFormat.normal\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n  const tangents = vertexFormat.tangent\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n\n  let i;\n  const computeNormal =\n    vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent;\n\n  if (computeNormal) {\n    const computeTangent = vertexFormat.tangent || vertexFormat.bitangent;\n\n    let normalIndex = 0;\n    let tangentIndex = 0;\n    let bitangentIndex = 0;\n\n    const theta = Math.atan2(bottomRadius - topRadius, length);\n    const normal = normalScratch;\n    normal.z = Math.sin(theta);\n    const normalScale = Math.cos(theta);\n    let tangent = tangentScratch;\n    let bitangent = bitangentScratch;\n\n    for (i = 0; i < slices; i++) {\n      const angle = (i / slices) * CesiumMath.TWO_PI;\n      const x = normalScale * Math.cos(angle);\n      const y = normalScale * Math.sin(angle);\n      if (computeNormal) {\n        normal.x = x;\n        normal.y = y;\n\n        if (computeTangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent),\n            tangent,\n          );\n        }\n\n        if (vertexFormat.normal) {\n          normals[normalIndex++] = normal.x;\n          normals[normalIndex++] = normal.y;\n          normals[normalIndex++] = normal.z;\n          normals[normalIndex++] = normal.x;\n          normals[normalIndex++] = normal.y;\n          normals[normalIndex++] = normal.z;\n        }\n\n        if (vertexFormat.tangent) {\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n        }\n\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(\n            Cartesian3.cross(normal, tangent, bitangent),\n            bitangent,\n          );\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n        }\n      }\n    }\n\n    for (i = 0; i < slices; i++) {\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = -1;\n      }\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = 1;\n        tangents[tangentIndex++] = 0;\n        tangents[tangentIndex++] = 0;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = 0;\n        bitangents[bitangentIndex++] = -1;\n        bitangents[bitangentIndex++] = 0;\n      }\n    }\n\n    for (i = 0; i < slices; i++) {\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 1;\n      }\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = 1;\n        tangents[tangentIndex++] = 0;\n        tangents[tangentIndex++] = 0;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = 0;\n        bitangents[bitangentIndex++] = 1;\n        bitangents[bitangentIndex++] = 0;\n      }\n    }\n  }\n\n  const numIndices = 12 * slices - 12;\n  const indices = IndexDatatype.createTypedArray(numVertices, numIndices);\n  let index = 0;\n  let j = 0;\n  for (i = 0; i < slices - 1; i++) {\n    indices[index++] = j;\n    indices[index++] = j + 2;\n    indices[index++] = j + 3;\n\n    indices[index++] = j;\n    indices[index++] = j + 3;\n    indices[index++] = j + 1;\n\n    j += 2;\n  }\n\n  indices[index++] = twoSlices - 2;\n  indices[index++] = 0;\n  indices[index++] = 1;\n  indices[index++] = twoSlices - 2;\n  indices[index++] = 1;\n  indices[index++] = twoSlices - 1;\n\n  for (i = 1; i < slices - 1; i++) {\n    indices[index++] = twoSlices + i + 1;\n    indices[index++] = twoSlices + i;\n    indices[index++] = twoSlices;\n  }\n\n  for (i = 1; i < slices - 1; i++) {\n    indices[index++] = threeSlices;\n    indices[index++] = threeSlices + i;\n    indices[index++] = threeSlices + i + 1;\n  }\n\n  let textureCoordIndex = 0;\n  if (vertexFormat.st) {\n    const rad = Math.max(topRadius, bottomRadius);\n    for (i = 0; i < numVertices; i++) {\n      const position = Cartesian3.fromArray(positions, i * 3, positionScratch);\n      st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);\n      st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st,\n    });\n  }\n\n  radiusScratch.x = length * 0.5;\n  radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n  const boundingSphere = new BoundingSphere(\n    Cartesian3.ZERO,\n    Cartesian2.magnitude(radiusScratch),\n  );\n\n  if (defined(cylinderGeometry._offsetAttribute)) {\n    length = positions.length;\n    const offsetValue =\n      cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: cylinderGeometry._offsetAttribute,\n  });\n};\n\nlet unitCylinderGeometry;\n\n/**\n * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.\n * @returns {Geometry} The computed vertices and indices.\n *\n * @private\n */\nCylinderGeometry.getUnitCylinder = function () {\n  if (!defined(unitCylinderGeometry)) {\n    unitCylinderGeometry = CylinderGeometry.createGeometry(\n      new CylinderGeometry({\n        topRadius: 1.0,\n        bottomRadius: 1.0,\n        length: 1.0,\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      }),\n    );\n  }\n  return unitCylinderGeometry;\n};\nexport default CylinderGeometry;\n"],"names":["radiusScratch","normalScratch","bitangentScratch","tangentScratch","positionScratch","CylinderGeometry","options","EMPTY_OBJECT","length","topRadius","bottomRadius","vertexFormat","DEFAULT","slices","offsetAttribute","TOP","_length","_topRadius","_bottomRadius","_vertexFormat","clone","_slices","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchVertexFormat","scratchOptions","undefined","unpack","result","createGeometry","cylinderGeometry","twoSlices","threeSlices","numVertices","positions","computePositions","st","Float32Array","normals","normal","tangents","tangent","bitangents","bitangent","i","computeNormal","computeTangent","normalIndex","tangentIndex","bitangentIndex","theta","Math","atan2","z","sin","normalScale","cos","angle","TWO_PI","x","y","normalize","cross","UNIT_Z","numIndices","indices","createTypedArray","index","j","textureCoordIndex","rad","max","position","fromArray","attributes","componentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","boundingSphere","ZERO","magnitude","offsetValue","NONE","applyOffset","Uint8Array","fill","UNSIGNED_BYTE","primitiveType","TRIANGLES","unitCylinderGeometry","getUnitCylinder","POSITION_ONLY"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 38495, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/CylinderOutlineGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CylinderGeometryLibrary from \"./CylinderGeometryLibrary.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nconst radiusScratch = new Cartesian2();\n\n/**\n * A description of the outline of a cylinder.\n *\n * @alias CylinderOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number} options.length The length of the cylinder.\n * @param {number} options.topRadius The radius of the top of the cylinder.\n * @param {number} options.bottomRadius The radius of the bottom of the cylinder.\n * @param {number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n * @param {number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surfaces of the cylinder.\n *\n * @exception {DeveloperError} options.length must be greater than 0.\n * @exception {DeveloperError} options.topRadius must be greater than 0.\n * @exception {DeveloperError} options.bottomRadius must be greater than 0.\n * @exception {DeveloperError} bottomRadius and topRadius cannot both equal 0.\n * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n *\n * @see CylinderOutlineGeometry.createGeometry\n *\n * @example\n * // create cylinder geometry\n * const cylinder = new Cesium.CylinderOutlineGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * const geometry = Cesium.CylinderOutlineGeometry.createGeometry(cylinder);\n */\nfunction CylinderOutlineGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const length = options.length;\n  const topRadius = options.topRadius;\n  const bottomRadius = options.bottomRadius;\n  const slices = options.slices ?? 128;\n  const numberOfVerticalLines = Math.max(\n    options.numberOfVerticalLines ?? 16,\n    0,\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.positions\", length);\n  Check.typeOf.number(\"options.topRadius\", topRadius);\n  Check.typeOf.number(\"options.bottomRadius\", bottomRadius);\n  Check.typeOf.number.greaterThanOrEquals(\"options.slices\", slices, 3);\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._length = length;\n  this._topRadius = topRadius;\n  this._bottomRadius = bottomRadius;\n  this._slices = slices;\n  this._numberOfVerticalLines = numberOfVerticalLines;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCylinderOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nCylinderOutlineGeometry.packedLength = 6;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CylinderOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCylinderOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value._length;\n  array[startingIndex++] = value._topRadius;\n  array[startingIndex++] = value._bottomRadius;\n  array[startingIndex++] = value._slices;\n  array[startingIndex++] = value._numberOfVerticalLines;\n  array[startingIndex] = value._offsetAttribute ?? -1;\n\n  return array;\n};\n\nconst scratchOptions = {\n  length: undefined,\n  topRadius: undefined,\n  bottomRadius: undefined,\n  slices: undefined,\n  numberOfVerticalLines: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CylinderOutlineGeometry} [result] The object into which to store the result.\n * @returns {CylinderOutlineGeometry} The modified result parameter or a new CylinderOutlineGeometry instance if one was not provided.\n */\nCylinderOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const length = array[startingIndex++];\n  const topRadius = array[startingIndex++];\n  const bottomRadius = array[startingIndex++];\n  const slices = array[startingIndex++];\n  const numberOfVerticalLines = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.length = length;\n    scratchOptions.topRadius = topRadius;\n    scratchOptions.bottomRadius = bottomRadius;\n    scratchOptions.slices = slices;\n    scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CylinderOutlineGeometry(scratchOptions);\n  }\n\n  result._length = length;\n  result._topRadius = topRadius;\n  result._bottomRadius = bottomRadius;\n  result._slices = slices;\n  result._numberOfVerticalLines = numberOfVerticalLines;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of a cylinder, including its vertices, indices, and a bounding sphere.\n *\n * @param {CylinderOutlineGeometry} cylinderGeometry A description of the cylinder outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCylinderOutlineGeometry.createGeometry = function (cylinderGeometry) {\n  let length = cylinderGeometry._length;\n  const topRadius = cylinderGeometry._topRadius;\n  const bottomRadius = cylinderGeometry._bottomRadius;\n  const slices = cylinderGeometry._slices;\n  const numberOfVerticalLines = cylinderGeometry._numberOfVerticalLines;\n\n  if (\n    length <= 0 ||\n    topRadius < 0 ||\n    bottomRadius < 0 ||\n    (topRadius === 0 && bottomRadius === 0)\n  ) {\n    return;\n  }\n\n  const numVertices = slices * 2;\n\n  const positions = CylinderGeometryLibrary.computePositions(\n    length,\n    topRadius,\n    bottomRadius,\n    slices,\n    false,\n  );\n  let numIndices = slices * 2;\n  let numSide;\n  if (numberOfVerticalLines > 0) {\n    const numSideLines = Math.min(numberOfVerticalLines, slices);\n    numSide = Math.round(slices / numSideLines);\n    numIndices += numSideLines;\n  }\n\n  const indices = IndexDatatype.createTypedArray(numVertices, numIndices * 2);\n  let index = 0;\n  let i;\n  for (i = 0; i < slices - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n    indices[index++] = i + slices;\n    indices[index++] = i + 1 + slices;\n  }\n\n  indices[index++] = slices - 1;\n  indices[index++] = 0;\n  indices[index++] = slices + slices - 1;\n  indices[index++] = slices;\n\n  if (numberOfVerticalLines > 0) {\n    for (i = 0; i < slices; i += numSide) {\n      indices[index++] = i;\n      indices[index++] = i + slices;\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n\n  radiusScratch.x = length * 0.5;\n  radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n  const boundingSphere = new BoundingSphere(\n    Cartesian3.ZERO,\n    Cartesian2.magnitude(radiusScratch),\n  );\n\n  if (defined(cylinderGeometry._offsetAttribute)) {\n    length = positions.length;\n    const offsetValue =\n      cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: cylinderGeometry._offsetAttribute,\n  });\n};\nexport default CylinderOutlineGeometry;\n"],"names":["radiusScratch","CylinderOutlineGeometry","options","EMPTY_OBJECT","length","topRadius","bottomRadius","slices","numberOfVerticalLines","Math","max","typeOf","number","greaterThanOrEquals","offsetAttribute","TOP","_length","_topRadius","_bottomRadius","_slices","_numberOfVerticalLines","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","object","defined","scratchOptions","undefined","unpack","result","createGeometry","cylinderGeometry","numVertices","positions","computePositions","numIndices","numSide","numSideLines","min","round","indices","createTypedArray","index","i","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","x","y","boundingSphere","ZERO","magnitude","offsetValue","NONE","applyOffset","Uint8Array","fill","UNSIGNED_BYTE","primitiveType","LINES"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 38726, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/EllipseGeometryLibrary.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Quaternion from \"./Quaternion.js\";\n\nconst EllipseGeometryLibrary = {};\n\nconst rotAxis = new Cartesian3();\nconst tempVec = new Cartesian3();\nconst unitQuat = new Quaternion();\nconst rotMtx = new Matrix3();\n\nfunction pointOnEllipsoid(\n  theta,\n  rotation,\n  northVec,\n  eastVec,\n  aSqr,\n  ab,\n  bSqr,\n  mag,\n  unitPos,\n  result,\n) {\n  const azimuth = theta + rotation;\n\n  Cartesian3.multiplyByScalar(eastVec, Math.cos(azimuth), rotAxis);\n  Cartesian3.multiplyByScalar(northVec, Math.sin(azimuth), tempVec);\n  Cartesian3.add(rotAxis, tempVec, rotAxis);\n\n  let cosThetaSquared = Math.cos(theta);\n  cosThetaSquared = cosThetaSquared * cosThetaSquared;\n\n  let sinThetaSquared = Math.sin(theta);\n  sinThetaSquared = sinThetaSquared * sinThetaSquared;\n\n  const radius =\n    ab / Math.sqrt(bSqr * cosThetaSquared + aSqr * sinThetaSquared);\n  const angle = radius / mag;\n\n  // Create the quaternion to rotate the position vector to the boundary of the ellipse.\n  Quaternion.fromAxisAngle(rotAxis, angle, unitQuat);\n  Matrix3.fromQuaternion(unitQuat, rotMtx);\n\n  Matrix3.multiplyByVector(rotMtx, unitPos, result);\n  Cartesian3.normalize(result, result);\n  Cartesian3.multiplyByScalar(result, mag, result);\n  return result;\n}\n\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchNormal = new Cartesian3();\n/**\n * Returns the positions raised to the given heights\n * @private\n */\nEllipseGeometryLibrary.raisePositionsToHeight = function (\n  positions,\n  options,\n  extrude,\n) {\n  const ellipsoid = options.ellipsoid;\n  const height = options.height;\n  const extrudedHeight = options.extrudedHeight;\n  const size = extrude ? (positions.length / 3) * 2 : positions.length / 3;\n\n  const finalPositions = new Float64Array(size * 3);\n\n  const length = positions.length;\n  const bottomOffset = extrude ? length : 0;\n  for (let i = 0; i < length; i += 3) {\n    const i1 = i + 1;\n    const i2 = i + 2;\n\n    const position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n    ellipsoid.scaleToGeodeticSurface(position, position);\n\n    const extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n    const normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n    const scaledNormal = Cartesian3.multiplyByScalar(\n      normal,\n      height,\n      scratchCartesian3,\n    );\n    Cartesian3.add(position, scaledNormal, position);\n\n    if (extrude) {\n      Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n      Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n\n      finalPositions[i + bottomOffset] = extrudedPosition.x;\n      finalPositions[i1 + bottomOffset] = extrudedPosition.y;\n      finalPositions[i2 + bottomOffset] = extrudedPosition.z;\n    }\n\n    finalPositions[i] = position.x;\n    finalPositions[i1] = position.y;\n    finalPositions[i2] = position.z;\n  }\n\n  return finalPositions;\n};\n\nconst unitPosScratch = new Cartesian3();\nconst eastVecScratch = new Cartesian3();\nconst northVecScratch = new Cartesian3();\n/**\n * Returns an array of positions that make up the ellipse.\n * @private\n */\nEllipseGeometryLibrary.computeEllipsePositions = function (\n  options,\n  addFillPositions,\n  addEdgePositions,\n) {\n  const semiMinorAxis = options.semiMinorAxis;\n  const semiMajorAxis = options.semiMajorAxis;\n  const rotation = options.rotation;\n  const center = options.center;\n\n  // Computing the arc-length of the ellipse is too expensive to be practical. Estimating it using the\n  // arc length of the sphere is too inaccurate and creates sharp edges when either the semi-major or\n  // semi-minor axis is much bigger than the other. Instead, scale the angle delta to make\n  // the distance along the ellipse boundary more closely match the granularity.\n  const granularity = options.granularity * 8.0;\n\n  const aSqr = semiMinorAxis * semiMinorAxis;\n  const bSqr = semiMajorAxis * semiMajorAxis;\n  const ab = semiMajorAxis * semiMinorAxis;\n\n  const mag = Cartesian3.magnitude(center);\n\n  const unitPos = Cartesian3.normalize(center, unitPosScratch);\n  let eastVec = Cartesian3.cross(Cartesian3.UNIT_Z, center, eastVecScratch);\n  eastVec = Cartesian3.normalize(eastVec, eastVec);\n  const northVec = Cartesian3.cross(unitPos, eastVec, northVecScratch);\n\n  // The number of points in the first quadrant\n  let numPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);\n\n  const deltaTheta = CesiumMath.PI_OVER_TWO / (numPts - 1);\n  let theta = CesiumMath.PI_OVER_TWO - numPts * deltaTheta;\n  if (theta < 0.0) {\n    numPts -= Math.ceil(Math.abs(theta) / deltaTheta);\n  }\n\n  // If the number of points were three, the ellipse\n  // would be tessellated like below:\n  //\n  //         *---*\n  //       / | \\ | \\\n  //     *---*---*---*\n  //   / | \\ | \\ | \\ | \\\n  //  / .*---*---*---*. \\\n  // * ` | \\ | \\ | \\ | `*\n  //  \\`.*---*---*---*.`/\n  //   \\ | \\ | \\ | \\ | /\n  //     *---*---*---*\n  //       \\ | \\ | /\n  //         *---*\n  // The first and last column have one position and fan to connect to the adjacent column.\n  // Each other vertical column contains an even number of positions.\n  const size = 2 * (numPts * (numPts + 2));\n  const positions = addFillPositions ? new Array(size * 3) : undefined;\n  let positionIndex = 0;\n  let position = scratchCartesian1;\n  let reflectedPosition = scratchCartesian2;\n\n  const outerPositionsLength = numPts * 4 * 3;\n  let outerRightIndex = outerPositionsLength - 1;\n  let outerLeftIndex = 0;\n  const outerPositions = addEdgePositions\n    ? new Array(outerPositionsLength)\n    : undefined;\n\n  let i;\n  let j;\n  let numInterior;\n  let t;\n  let interiorPosition;\n\n  // Compute points in the 'eastern' half of the ellipse\n  theta = CesiumMath.PI_OVER_TWO;\n  position = pointOnEllipsoid(\n    theta,\n    rotation,\n    northVec,\n    eastVec,\n    aSqr,\n    ab,\n    bSqr,\n    mag,\n    unitPos,\n    position,\n  );\n  if (addFillPositions) {\n    positions[positionIndex++] = position.x;\n    positions[positionIndex++] = position.y;\n    positions[positionIndex++] = position.z;\n  }\n  if (addEdgePositions) {\n    outerPositions[outerRightIndex--] = position.z;\n    outerPositions[outerRightIndex--] = position.y;\n    outerPositions[outerRightIndex--] = position.x;\n  }\n  theta = CesiumMath.PI_OVER_TWO - deltaTheta;\n  for (i = 1; i < numPts + 1; ++i) {\n    position = pointOnEllipsoid(\n      theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      position,\n    );\n    reflectedPosition = pointOnEllipsoid(\n      Math.PI - theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      reflectedPosition,\n    );\n\n    if (addFillPositions) {\n      positions[positionIndex++] = position.x;\n      positions[positionIndex++] = position.y;\n      positions[positionIndex++] = position.z;\n\n      numInterior = 2 * i + 2;\n      for (j = 1; j < numInterior - 1; ++j) {\n        t = j / (numInterior - 1);\n        interiorPosition = Cartesian3.lerp(\n          position,\n          reflectedPosition,\n          t,\n          scratchCartesian3,\n        );\n        positions[positionIndex++] = interiorPosition.x;\n        positions[positionIndex++] = interiorPosition.y;\n        positions[positionIndex++] = interiorPosition.z;\n      }\n\n      positions[positionIndex++] = reflectedPosition.x;\n      positions[positionIndex++] = reflectedPosition.y;\n      positions[positionIndex++] = reflectedPosition.z;\n    }\n\n    if (addEdgePositions) {\n      outerPositions[outerRightIndex--] = position.z;\n      outerPositions[outerRightIndex--] = position.y;\n      outerPositions[outerRightIndex--] = position.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\n    }\n\n    theta = CesiumMath.PI_OVER_TWO - (i + 1) * deltaTheta;\n  }\n\n  // Compute points in the 'western' half of the ellipse\n  for (i = numPts; i > 1; --i) {\n    theta = CesiumMath.PI_OVER_TWO - (i - 1) * deltaTheta;\n\n    position = pointOnEllipsoid(\n      -theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      position,\n    );\n    reflectedPosition = pointOnEllipsoid(\n      theta + Math.PI,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      reflectedPosition,\n    );\n\n    if (addFillPositions) {\n      positions[positionIndex++] = position.x;\n      positions[positionIndex++] = position.y;\n      positions[positionIndex++] = position.z;\n\n      numInterior = 2 * (i - 1) + 2;\n      for (j = 1; j < numInterior - 1; ++j) {\n        t = j / (numInterior - 1);\n        interiorPosition = Cartesian3.lerp(\n          position,\n          reflectedPosition,\n          t,\n          scratchCartesian3,\n        );\n        positions[positionIndex++] = interiorPosition.x;\n        positions[positionIndex++] = interiorPosition.y;\n        positions[positionIndex++] = interiorPosition.z;\n      }\n\n      positions[positionIndex++] = reflectedPosition.x;\n      positions[positionIndex++] = reflectedPosition.y;\n      positions[positionIndex++] = reflectedPosition.z;\n    }\n\n    if (addEdgePositions) {\n      outerPositions[outerRightIndex--] = position.z;\n      outerPositions[outerRightIndex--] = position.y;\n      outerPositions[outerRightIndex--] = position.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\n    }\n  }\n\n  theta = CesiumMath.PI_OVER_TWO;\n  position = pointOnEllipsoid(\n    -theta,\n    rotation,\n    northVec,\n    eastVec,\n    aSqr,\n    ab,\n    bSqr,\n    mag,\n    unitPos,\n    position,\n  );\n\n  const r = {};\n  if (addFillPositions) {\n    positions[positionIndex++] = position.x;\n    positions[positionIndex++] = position.y;\n    positions[positionIndex++] = position.z;\n    r.positions = positions;\n    r.numPts = numPts;\n  }\n  if (addEdgePositions) {\n    outerPositions[outerRightIndex--] = position.z;\n    outerPositions[outerRightIndex--] = position.y;\n    outerPositions[outerRightIndex--] = position.x;\n    r.outerPositions = outerPositions;\n  }\n\n  return r;\n};\nexport default EllipseGeometryLibrary;\n"],"names":["EllipseGeometryLibrary","rotAxis","tempVec","unitQuat","rotMtx","pointOnEllipsoid","theta","rotation","northVec","eastVec","aSqr","ab","bSqr","mag","unitPos","result","azimuth","multiplyByScalar","Math","cos","sin","add","cosThetaSquared","sinThetaSquared","radius","sqrt","angle","fromAxisAngle","fromQuaternion","multiplyByVector","normalize","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchNormal","raisePositionsToHeight","positions","options","extrude","ellipsoid","height","extrudedHeight","size","length","finalPositions","Float64Array","bottomOffset","i","i1","i2","position","fromArray","scaleToGeodeticSurface","extrudedPosition","clone","normal","geodeticSurfaceNormal","scaledNormal","x","y","z","unitPosScratch","eastVecScratch","northVecScratch","computeEllipsePositions","addFillPositions","addEdgePositions","semiMinorAxis","semiMajorAxis","center","granularity","magnitude","cross","UNIT_Z","numPts","ceil","PI_OVER_TWO","deltaTheta","abs","Array","undefined","positionIndex","reflectedPosition","outerPositionsLength","outerRightIndex","outerLeftIndex","outerPositions","j","numInterior","t","interiorPosition","PI","lerp","r"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 38956, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/EllipseGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EllipseGeometryLibrary from \"./EllipseGeometryLibrary.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4 = new Cartesian3();\nconst texCoordScratch = new Cartesian2();\nconst textureMatrixScratch = new Matrix3();\nconst tangentMatrixScratch = new Matrix3();\nconst quaternionScratch = new Quaternion();\n\nconst scratchNormal = new Cartesian3();\nconst scratchTangent = new Cartesian3();\nconst scratchBitangent = new Cartesian3();\n\nconst scratchCartographic = new Cartographic();\nconst projectedCenterScratch = new Cartesian3();\n\nconst scratchMinTexCoord = new Cartesian2();\nconst scratchMaxTexCoord = new Cartesian2();\n\nfunction computeTopBottomAttributes(positions, options, extrude) {\n  const vertexFormat = options.vertexFormat;\n  const center = options.center;\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const ellipsoid = options.ellipsoid;\n  const stRotation = options.stRotation;\n  const size = extrude ? (positions.length / 3) * 2 : positions.length / 3;\n  const shadowVolume = options.shadowVolume;\n\n  const textureCoordinates = vertexFormat.st\n    ? new Float32Array(size * 2)\n    : undefined;\n  const normals = vertexFormat.normal ? new Float32Array(size * 3) : undefined;\n  const tangents = vertexFormat.tangent\n    ? new Float32Array(size * 3)\n    : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(size * 3)\n    : undefined;\n\n  const extrudeNormals = shadowVolume ? new Float32Array(size * 3) : undefined;\n\n  let textureCoordIndex = 0;\n\n  // Raise positions to a height above the ellipsoid and compute the\n  // texture coordinates, normals, tangents, and bitangents.\n  let normal = scratchNormal;\n  let tangent = scratchTangent;\n  let bitangent = scratchBitangent;\n\n  const projection = new GeographicProjection(ellipsoid);\n  const projectedCenter = projection.project(\n    ellipsoid.cartesianToCartographic(center, scratchCartographic),\n    projectedCenterScratch,\n  );\n\n  const geodeticNormal = ellipsoid.scaleToGeodeticSurface(\n    center,\n    scratchCartesian1,\n  );\n  ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n\n  let textureMatrix = textureMatrixScratch;\n  let tangentMatrix = tangentMatrixScratch;\n  if (stRotation !== 0) {\n    let rotation = Quaternion.fromAxisAngle(\n      geodeticNormal,\n      stRotation,\n      quaternionScratch,\n    );\n    textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n    rotation = Quaternion.fromAxisAngle(\n      geodeticNormal,\n      -stRotation,\n      quaternionScratch,\n    );\n    tangentMatrix = Matrix3.fromQuaternion(rotation, tangentMatrix);\n  } else {\n    textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n    tangentMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentMatrix);\n  }\n\n  const minTexCoord = Cartesian2.fromElements(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    scratchMinTexCoord,\n  );\n  const maxTexCoord = Cartesian2.fromElements(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    scratchMaxTexCoord,\n  );\n\n  let length = positions.length;\n  const bottomOffset = extrude ? length : 0;\n  const stOffset = (bottomOffset / 3) * 2;\n  for (let i = 0; i < length; i += 3) {\n    const i1 = i + 1;\n    const i2 = i + 2;\n    const position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n\n    if (vertexFormat.st) {\n      const rotatedPoint = Matrix3.multiplyByVector(\n        textureMatrix,\n        position,\n        scratchCartesian2,\n      );\n      const projectedPoint = projection.project(\n        ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic),\n        scratchCartesian3,\n      );\n      Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n      texCoordScratch.x =\n        (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n      texCoordScratch.y =\n        (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n      minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n      minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n      maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n      maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n      if (extrude) {\n        textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n        textureCoordinates[textureCoordIndex + 1 + stOffset] =\n          texCoordScratch.y;\n      }\n\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n    }\n\n    if (\n      vertexFormat.normal ||\n      vertexFormat.tangent ||\n      vertexFormat.bitangent ||\n      shadowVolume\n    ) {\n      normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n      if (shadowVolume) {\n        extrudeNormals[i + bottomOffset] = -normal.x;\n        extrudeNormals[i1 + bottomOffset] = -normal.y;\n        extrudeNormals[i2 + bottomOffset] = -normal.z;\n      }\n\n      if (\n        vertexFormat.normal ||\n        vertexFormat.tangent ||\n        vertexFormat.bitangent\n      ) {\n        if (vertexFormat.tangent || vertexFormat.bitangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent),\n            tangent,\n          );\n          Matrix3.multiplyByVector(tangentMatrix, tangent, tangent);\n        }\n        if (vertexFormat.normal) {\n          normals[i] = normal.x;\n          normals[i1] = normal.y;\n          normals[i2] = normal.z;\n          if (extrude) {\n            normals[i + bottomOffset] = -normal.x;\n            normals[i1 + bottomOffset] = -normal.y;\n            normals[i2 + bottomOffset] = -normal.z;\n          }\n        }\n\n        if (vertexFormat.tangent) {\n          tangents[i] = tangent.x;\n          tangents[i1] = tangent.y;\n          tangents[i2] = tangent.z;\n          if (extrude) {\n            tangents[i + bottomOffset] = -tangent.x;\n            tangents[i1 + bottomOffset] = -tangent.y;\n            tangents[i2 + bottomOffset] = -tangent.z;\n          }\n        }\n\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(\n            Cartesian3.cross(normal, tangent, bitangent),\n            bitangent,\n          );\n          bitangents[i] = bitangent.x;\n          bitangents[i1] = bitangent.y;\n          bitangents[i2] = bitangent.z;\n          if (extrude) {\n            bitangents[i + bottomOffset] = bitangent.x;\n            bitangents[i1 + bottomOffset] = bitangent.y;\n            bitangents[i2 + bottomOffset] = bitangent.z;\n          }\n        }\n      }\n    }\n  }\n\n  if (vertexFormat.st) {\n    length = textureCoordinates.length;\n    for (let k = 0; k < length; k += 2) {\n      textureCoordinates[k] =\n        (textureCoordinates[k] - minTexCoord.x) /\n        (maxTexCoord.x - minTexCoord.x);\n      textureCoordinates[k + 1] =\n        (textureCoordinates[k + 1] - minTexCoord.y) /\n        (maxTexCoord.y - minTexCoord.y);\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    const finalPositions = EllipseGeometryLibrary.raisePositionsToHeight(\n      positions,\n      options,\n      extrude,\n    );\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: finalPositions,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (shadowVolume) {\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n  }\n\n  if (extrude && defined(options.offsetAttribute)) {\n    let offsetAttribute = new Uint8Array(size);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n    } else {\n      const offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = offsetAttribute.fill(offsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  return attributes;\n}\n\nfunction topIndices(numPts) {\n  // numTriangles in half = 3 + 8 + 12 + ... = -1 + 4 + (4 + 4) + (4 + 4 + 4) + ... = -1 + 4 * (1 + 2 + 3 + ...)\n  //              = -1 + 4 * ((n * ( n + 1)) / 2)\n  // total triangles = 2 * numTriangles in half\n  // indices = total triangles * 3;\n  // Substitute numPts for n above\n\n  const indices = new Array(12 * (numPts * (numPts + 1)) - 6);\n  let indicesIndex = 0;\n  let prevIndex;\n  let numInterior;\n  let positionIndex;\n  let i;\n  let j;\n  // Indices triangles to the 'right' of the north vector\n\n  prevIndex = 0;\n  positionIndex = 1;\n  for (i = 0; i < 3; i++) {\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  for (i = 2; i < numPts + 1; ++i) {\n    positionIndex = i * (i + 1) - 1;\n    prevIndex = (i - 1) * i - 1;\n\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n\n    numInterior = 2 * i;\n    for (j = 0; j < numInterior - 1; ++j) {\n      indices[indicesIndex++] = positionIndex;\n      indices[indicesIndex++] = prevIndex++;\n      indices[indicesIndex++] = prevIndex;\n\n      indices[indicesIndex++] = positionIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex;\n    }\n\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  // Indices for center column of triangles\n  numInterior = numPts * 2;\n  ++positionIndex;\n  ++prevIndex;\n  for (i = 0; i < numInterior - 1; ++i) {\n    indices[indicesIndex++] = positionIndex;\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  indices[indicesIndex++] = positionIndex;\n  indices[indicesIndex++] = prevIndex++;\n  indices[indicesIndex++] = prevIndex;\n\n  indices[indicesIndex++] = positionIndex++;\n  indices[indicesIndex++] = prevIndex++;\n  indices[indicesIndex++] = prevIndex;\n\n  // Reverse the process creating indices to the 'left' of the north vector\n  ++prevIndex;\n  for (i = numPts - 1; i > 1; --i) {\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n\n    numInterior = 2 * i;\n    for (j = 0; j < numInterior - 1; ++j) {\n      indices[indicesIndex++] = positionIndex;\n      indices[indicesIndex++] = prevIndex++;\n      indices[indicesIndex++] = prevIndex;\n\n      indices[indicesIndex++] = positionIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex;\n    }\n\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = positionIndex++;\n  }\n\n  for (i = 0; i < 3; i++) {\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n  return indices;\n}\n\nlet boundingSphereCenter = new Cartesian3();\n\nfunction computeEllipse(options) {\n  const center = options.center;\n  boundingSphereCenter = Cartesian3.multiplyByScalar(\n    options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter),\n    options.height,\n    boundingSphereCenter,\n  );\n  boundingSphereCenter = Cartesian3.add(\n    center,\n    boundingSphereCenter,\n    boundingSphereCenter,\n  );\n  const boundingSphere = new BoundingSphere(\n    boundingSphereCenter,\n    options.semiMajorAxis,\n  );\n  const cep = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    true,\n    false,\n  );\n  const positions = cep.positions;\n  const numPts = cep.numPts;\n  const attributes = computeTopBottomAttributes(positions, options, false);\n  let indices = topIndices(numPts);\n  indices = IndexDatatype.createTypedArray(positions.length / 3, indices);\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\nfunction computeWallAttributes(positions, options) {\n  const vertexFormat = options.vertexFormat;\n  const center = options.center;\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const ellipsoid = options.ellipsoid;\n  const height = options.height;\n  const extrudedHeight = options.extrudedHeight;\n  const stRotation = options.stRotation;\n  const size = (positions.length / 3) * 2;\n\n  const finalPositions = new Float64Array(size * 3);\n  const textureCoordinates = vertexFormat.st\n    ? new Float32Array(size * 2)\n    : undefined;\n  const normals = vertexFormat.normal ? new Float32Array(size * 3) : undefined;\n  const tangents = vertexFormat.tangent\n    ? new Float32Array(size * 3)\n    : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(size * 3)\n    : undefined;\n\n  const shadowVolume = options.shadowVolume;\n  const extrudeNormals = shadowVolume ? new Float32Array(size * 3) : undefined;\n\n  let textureCoordIndex = 0;\n\n  // Raise positions to a height above the ellipsoid and compute the\n  // texture coordinates, normals, tangents, and bitangents.\n  let normal = scratchNormal;\n  let tangent = scratchTangent;\n  let bitangent = scratchBitangent;\n\n  const projection = new GeographicProjection(ellipsoid);\n  const projectedCenter = projection.project(\n    ellipsoid.cartesianToCartographic(center, scratchCartographic),\n    projectedCenterScratch,\n  );\n\n  const geodeticNormal = ellipsoid.scaleToGeodeticSurface(\n    center,\n    scratchCartesian1,\n  );\n  ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n  const rotation = Quaternion.fromAxisAngle(\n    geodeticNormal,\n    stRotation,\n    quaternionScratch,\n  );\n  const textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrixScratch);\n\n  const minTexCoord = Cartesian2.fromElements(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    scratchMinTexCoord,\n  );\n  const maxTexCoord = Cartesian2.fromElements(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    scratchMaxTexCoord,\n  );\n\n  let length = positions.length;\n  const stOffset = (length / 3) * 2;\n  for (let i = 0; i < length; i += 3) {\n    const i1 = i + 1;\n    const i2 = i + 2;\n    let position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n    let extrudedPosition;\n\n    if (vertexFormat.st) {\n      const rotatedPoint = Matrix3.multiplyByVector(\n        textureMatrix,\n        position,\n        scratchCartesian2,\n      );\n      const projectedPoint = projection.project(\n        ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic),\n        scratchCartesian3,\n      );\n      Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n      texCoordScratch.x =\n        (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n      texCoordScratch.y =\n        (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n      minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n      minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n      maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n      maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n      textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n    }\n\n    position = ellipsoid.scaleToGeodeticSurface(position, position);\n    extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n    if (shadowVolume) {\n      extrudeNormals[i + length] = -normal.x;\n      extrudeNormals[i1 + length] = -normal.y;\n      extrudeNormals[i2 + length] = -normal.z;\n    }\n\n    let scaledNormal = Cartesian3.multiplyByScalar(\n      normal,\n      height,\n      scratchCartesian4,\n    );\n    position = Cartesian3.add(position, scaledNormal, position);\n    scaledNormal = Cartesian3.multiplyByScalar(\n      normal,\n      extrudedHeight,\n      scaledNormal,\n    );\n    extrudedPosition = Cartesian3.add(\n      extrudedPosition,\n      scaledNormal,\n      extrudedPosition,\n    );\n\n    if (vertexFormat.position) {\n      finalPositions[i + length] = extrudedPosition.x;\n      finalPositions[i1 + length] = extrudedPosition.y;\n      finalPositions[i2 + length] = extrudedPosition.z;\n\n      finalPositions[i] = position.x;\n      finalPositions[i1] = position.y;\n      finalPositions[i2] = position.z;\n    }\n\n    if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n      bitangent = Cartesian3.clone(normal, bitangent);\n      const next = Cartesian3.fromArray(\n        positions,\n        (i + 3) % length,\n        scratchCartesian4,\n      );\n      Cartesian3.subtract(next, position, next);\n      const bottom = Cartesian3.subtract(\n        extrudedPosition,\n        position,\n        scratchCartesian3,\n      );\n\n      normal = Cartesian3.normalize(\n        Cartesian3.cross(bottom, next, normal),\n        normal,\n      );\n\n      if (vertexFormat.normal) {\n        normals[i] = normal.x;\n        normals[i1] = normal.y;\n        normals[i2] = normal.z;\n\n        normals[i + length] = normal.x;\n        normals[i1 + length] = normal.y;\n        normals[i2 + length] = normal.z;\n      }\n\n      if (vertexFormat.tangent) {\n        tangent = Cartesian3.normalize(\n          Cartesian3.cross(bitangent, normal, tangent),\n          tangent,\n        );\n        tangents[i] = tangent.x;\n        tangents[i1] = tangent.y;\n        tangents[i2] = tangent.z;\n\n        tangents[i + length] = tangent.x;\n        tangents[i + 1 + length] = tangent.y;\n        tangents[i + 2 + length] = tangent.z;\n      }\n\n      if (vertexFormat.bitangent) {\n        bitangents[i] = bitangent.x;\n        bitangents[i1] = bitangent.y;\n        bitangents[i2] = bitangent.z;\n\n        bitangents[i + length] = bitangent.x;\n        bitangents[i1 + length] = bitangent.y;\n        bitangents[i2 + length] = bitangent.z;\n      }\n    }\n  }\n\n  if (vertexFormat.st) {\n    length = textureCoordinates.length;\n    for (let k = 0; k < length; k += 2) {\n      textureCoordinates[k] =\n        (textureCoordinates[k] - minTexCoord.x) /\n        (maxTexCoord.x - minTexCoord.x);\n      textureCoordinates[k + 1] =\n        (textureCoordinates[k + 1] - minTexCoord.y) /\n        (maxTexCoord.y - minTexCoord.y);\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: finalPositions,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (shadowVolume) {\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n  }\n\n  if (defined(options.offsetAttribute)) {\n    let offsetAttribute = new Uint8Array(size);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n    } else {\n      const offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = offsetAttribute.fill(offsetValue);\n    }\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  return attributes;\n}\n\nfunction computeWallIndices(positions) {\n  const length = positions.length / 3;\n  const indices = IndexDatatype.createTypedArray(length, length * 6);\n  let index = 0;\n  for (let i = 0; i < length; i++) {\n    const UL = i;\n    const LL = i + length;\n    const UR = (UL + 1) % length;\n    const LR = UR + length;\n    indices[index++] = UL;\n    indices[index++] = LL;\n    indices[index++] = UR;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n  }\n\n  return indices;\n}\n\nconst topBoundingSphere = new BoundingSphere();\nconst bottomBoundingSphere = new BoundingSphere();\n\nfunction computeExtrudedEllipse(options) {\n  const center = options.center;\n  const ellipsoid = options.ellipsoid;\n  const semiMajorAxis = options.semiMajorAxis;\n  let scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1),\n    options.height,\n    scratchCartesian1,\n  );\n  topBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    topBoundingSphere.center,\n  );\n  topBoundingSphere.radius = semiMajorAxis;\n\n  scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scaledNormal),\n    options.extrudedHeight,\n    scaledNormal,\n  );\n  bottomBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    bottomBoundingSphere.center,\n  );\n  bottomBoundingSphere.radius = semiMajorAxis;\n\n  const cep = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    true,\n    true,\n  );\n  const positions = cep.positions;\n  const numPts = cep.numPts;\n  const outerPositions = cep.outerPositions;\n  const boundingSphere = BoundingSphere.union(\n    topBoundingSphere,\n    bottomBoundingSphere,\n  );\n  const topBottomAttributes = computeTopBottomAttributes(\n    positions,\n    options,\n    true,\n  );\n  let indices = topIndices(numPts);\n  const length = indices.length;\n  indices.length = length * 2;\n  const posLength = positions.length / 3;\n  for (let i = 0; i < length; i += 3) {\n    indices[i + length] = indices[i + 2] + posLength;\n    indices[i + 1 + length] = indices[i + 1] + posLength;\n    indices[i + 2 + length] = indices[i] + posLength;\n  }\n\n  const topBottomIndices = IndexDatatype.createTypedArray(\n    (posLength * 2) / 3,\n    indices,\n  );\n\n  const topBottomGeo = new Geometry({\n    attributes: topBottomAttributes,\n    indices: topBottomIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n\n  const wallAttributes = computeWallAttributes(outerPositions, options);\n  indices = computeWallIndices(outerPositions);\n  const wallIndices = IndexDatatype.createTypedArray(\n    (outerPositions.length * 2) / 3,\n    indices,\n  );\n\n  const wallGeo = new Geometry({\n    attributes: wallAttributes,\n    indices: wallIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n\n  const geo = GeometryPipeline.combineInstances([\n    new GeometryInstance({\n      geometry: topBottomGeo,\n    }),\n    new GeometryInstance({\n      geometry: wallGeo,\n    }),\n  ]);\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: geo[0].attributes,\n    indices: geo[0].indices,\n  };\n}\n\nfunction computeRectangle(\n  center,\n  semiMajorAxis,\n  semiMinorAxis,\n  rotation,\n  granularity,\n  ellipsoid,\n  result,\n) {\n  const cep = EllipseGeometryLibrary.computeEllipsePositions(\n    {\n      center: center,\n      semiMajorAxis: semiMajorAxis,\n      semiMinorAxis: semiMinorAxis,\n      rotation: rotation,\n      granularity: granularity,\n    },\n    false,\n    true,\n  );\n  const positionsFlat = cep.outerPositions;\n  const positionsCount = positionsFlat.length / 3;\n  const positions = new Array(positionsCount);\n  for (let i = 0; i < positionsCount; ++i) {\n    positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n  }\n  const rectangle = Rectangle.fromCartesianArray(positions, ellipsoid, result);\n  // Rectangle width goes beyond 180 degrees when the ellipse crosses a pole.\n  // When this happens, make the rectangle into a \"circle\" around the pole\n  if (rectangle.width > CesiumMath.PI) {\n    rectangle.north =\n      rectangle.north > 0.0\n        ? CesiumMath.PI_OVER_TWO - CesiumMath.EPSILON7\n        : rectangle.north;\n    rectangle.south =\n      rectangle.south < 0.0\n        ? CesiumMath.EPSILON7 - CesiumMath.PI_OVER_TWO\n        : rectangle.south;\n    rectangle.east = CesiumMath.PI;\n    rectangle.west = -CesiumMath.PI;\n  }\n  return rectangle;\n}\n\n/**\n * A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias EllipseGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid the ellipse will be on.\n * @param {number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n * @param {number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n * @param {number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n * @param {number} [options.stRotation=0.0] The rotation of the texture coordinates counter-clockwise from north.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n * @exception {DeveloperError} granularity must be greater than zero.\n *\n *\n * @example\n * // Create an ellipse.\n * const ellipse = new Cesium.EllipseGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * const geometry = Cesium.EllipseGeometry.createGeometry(ellipse);\n *\n * @see EllipseGeometry.createGeometry\n */\nfunction EllipseGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const center = options.center;\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  const vertexFormat = options.vertexFormat ?? VertexFormat.DEFAULT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.center\", center);\n  Check.typeOf.number(\"options.semiMajorAxis\", semiMajorAxis);\n  Check.typeOf.number(\"options.semiMinorAxis\", semiMinorAxis);\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\n      \"semiMajorAxis must be greater than or equal to the semiMinorAxis.\",\n    );\n  }\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  const height = options.height ?? 0.0;\n  const extrudedHeight = options.extrudedHeight ?? height;\n\n  this._center = Cartesian3.clone(center);\n  this._semiMajorAxis = semiMajorAxis;\n  this._semiMinorAxis = semiMinorAxis;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._rotation = options.rotation ?? 0.0;\n  this._stRotation = options.stRotation ?? 0.0;\n  this._height = Math.max(extrudedHeight, height);\n  this._granularity = granularity;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._extrudedHeight = Math.min(extrudedHeight, height);\n  this._shadowVolume = options.shadowVolume ?? false;\n  this._workerName = \"createEllipseGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n\n  this._rectangle = undefined;\n  this._textureCoordinateRotationPoints = undefined;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nEllipseGeometry.packedLength =\n  Cartesian3.packedLength +\n  Ellipsoid.packedLength +\n  VertexFormat.packedLength +\n  9;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipseGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nEllipseGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  Cartesian3.pack(value._center, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._semiMajorAxis;\n  array[startingIndex++] = value._semiMinorAxis;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = value._offsetAttribute ?? -1;\n\n  return array;\n};\n\nconst scratchCenter = new Cartesian3();\nconst scratchEllipsoid = new Ellipsoid();\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  center: scratchCenter,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  semiMajorAxis: undefined,\n  semiMinorAxis: undefined,\n  rotation: undefined,\n  stRotation: undefined,\n  height: undefined,\n  granularity: undefined,\n  extrudedHeight: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipseGeometry} [result] The object into which to store the result.\n * @returns {EllipseGeometry} The modified result parameter or a new EllipseGeometry instance if one was not provided.\n */\nEllipseGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n  startingIndex += Cartesian3.packedLength;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const semiMajorAxis = array[startingIndex++];\n  const semiMinorAxis = array[startingIndex++];\n  const rotation = array[startingIndex++];\n  const stRotation = array[startingIndex++];\n  const height = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const shadowVolume = array[startingIndex++] === 1.0;\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.granularity = granularity;\n    scratchOptions.stRotation = stRotation;\n    scratchOptions.rotation = rotation;\n    scratchOptions.semiMajorAxis = semiMajorAxis;\n    scratchOptions.semiMinorAxis = semiMinorAxis;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new EllipseGeometry(scratchOptions);\n  }\n\n  result._center = Cartesian3.clone(center, result._center);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._semiMajorAxis = semiMajorAxis;\n  result._semiMinorAxis = semiMinorAxis;\n  result._rotation = rotation;\n  result._stRotation = stRotation;\n  result._height = height;\n  result._granularity = granularity;\n  result._extrudedHeight = extrudedHeight;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the bounding rectangle based on the provided options\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid the ellipse will be on.\n * @param {number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n * @param {Rectangle} [result] An object in which to store the result\n *\n * @returns {Rectangle} The result rectangle\n */\nEllipseGeometry.computeRectangle = function (options, result) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const center = options.center;\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  const rotation = options.rotation ?? 0.0;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.center\", center);\n  Check.typeOf.number(\"options.semiMajorAxis\", semiMajorAxis);\n  Check.typeOf.number(\"options.semiMinorAxis\", semiMinorAxis);\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\n      \"semiMajorAxis must be greater than or equal to the semiMinorAxis.\",\n    );\n  }\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  return computeRectangle(\n    center,\n    semiMajorAxis,\n    semiMinorAxis,\n    rotation,\n    granularity,\n    ellipsoid,\n    result,\n  );\n};\n\n/**\n * Computes the geometric representation of a ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipseGeometry} ellipseGeometry A description of the ellipse.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipseGeometry.createGeometry = function (ellipseGeometry) {\n  if (\n    ellipseGeometry._semiMajorAxis <= 0.0 ||\n    ellipseGeometry._semiMinorAxis <= 0.0\n  ) {\n    return;\n  }\n\n  const height = ellipseGeometry._height;\n  const extrudedHeight = ellipseGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2,\n  );\n\n  ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(\n    ellipseGeometry._center,\n    ellipseGeometry._center,\n  );\n  const options = {\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipseGeometry._ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    height: height,\n    granularity: ellipseGeometry._granularity,\n    vertexFormat: ellipseGeometry._vertexFormat,\n    stRotation: ellipseGeometry._stRotation,\n  };\n  let geometry;\n  if (extrude) {\n    options.extrudedHeight = extrudedHeight;\n    options.shadowVolume = ellipseGeometry._shadowVolume;\n    options.offsetAttribute = ellipseGeometry._offsetAttribute;\n    geometry = computeExtrudedEllipse(options);\n  } else {\n    geometry = computeEllipse(options);\n\n    if (defined(ellipseGeometry._offsetAttribute)) {\n      const length = geometry.attributes.position.values.length;\n      const offsetValue =\n        ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: geometry.boundingSphere,\n    offsetAttribute: ellipseGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nEllipseGeometry.createShadowVolume = function (\n  ellipseGeometry,\n  minHeightFunc,\n  maxHeightFunc,\n) {\n  const granularity = ellipseGeometry._granularity;\n  const ellipsoid = ellipseGeometry._ellipsoid;\n\n  const minHeight = minHeightFunc(granularity, ellipsoid);\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new EllipseGeometry({\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    stRotation: ellipseGeometry._stRotation,\n    granularity: granularity,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n  });\n};\n\nfunction textureCoordinateRotationPoints(ellipseGeometry) {\n  const stRotation = -ellipseGeometry._stRotation;\n  if (stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n\n  const cep = EllipseGeometryLibrary.computeEllipsePositions(\n    {\n      center: ellipseGeometry._center,\n      semiMajorAxis: ellipseGeometry._semiMajorAxis,\n      semiMinorAxis: ellipseGeometry._semiMinorAxis,\n      rotation: ellipseGeometry._rotation,\n      granularity: ellipseGeometry._granularity,\n    },\n    false,\n    true,\n  );\n  const positionsFlat = cep.outerPositions;\n  const positionsCount = positionsFlat.length / 3;\n  const positions = new Array(positionsCount);\n  for (let i = 0; i < positionsCount; ++i) {\n    positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n  }\n\n  const ellipsoid = ellipseGeometry._ellipsoid;\n  const boundingRectangle = ellipseGeometry.rectangle;\n  return Geometry._textureCoordinateRotationPoints(\n    positions,\n    stRotation,\n    ellipsoid,\n    boundingRectangle,\n  );\n}\n\nObject.defineProperties(EllipseGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        this._rectangle = computeRectangle(\n          this._center,\n          this._semiMajorAxis,\n          this._semiMinorAxis,\n          this._rotation,\n          this._granularity,\n          this._ellipsoid,\n        );\n      }\n      return this._rectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering EllipseGeometries as GroundPrimitives.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints =\n          textureCoordinateRotationPoints(this);\n      }\n      return this._textureCoordinateRotationPoints;\n    },\n  },\n});\nexport default EllipseGeometry;\n"],"names":["scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","texCoordScratch","textureMatrixScratch","tangentMatrixScratch","quaternionScratch","scratchNormal","scratchTangent","scratchBitangent","scratchCartographic","projectedCenterScratch","scratchMinTexCoord","scratchMaxTexCoord","computeTopBottomAttributes","positions","options","extrude","vertexFormat","center","semiMajorAxis","semiMinorAxis","ellipsoid","stRotation","size","length","shadowVolume","textureCoordinates","st","Float32Array","undefined","normals","normal","tangents","tangent","bitangents","bitangent","extrudeNormals","textureCoordIndex","projection","projectedCenter","project","cartesianToCartographic","geodeticNormal","scaleToGeodeticSurface","geodeticSurfaceNormal","textureMatrix","tangentMatrix","rotation","fromAxisAngle","fromQuaternion","clone","IDENTITY","minTexCoord","fromElements","Number","POSITIVE_INFINITY","maxTexCoord","NEGATIVE_INFINITY","bottomOffset","stOffset","i","i1","i2","position","fromArray","rotatedPoint","multiplyByVector","projectedPoint","subtract","x","y","Math","min","max","z","normalize","cross","UNIT_Z","k","attributes","finalPositions","raisePositionsToHeight","componentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","extrudeDirection","offsetAttribute","Uint8Array","TOP","fill","offsetValue","NONE","applyOffset","UNSIGNED_BYTE","topIndices","numPts","indices","Array","indicesIndex","prevIndex","numInterior","positionIndex","j","boundingSphereCenter","computeEllipse","multiplyByScalar","height","add","boundingSphere","cep","computeEllipsePositions","createTypedArray","computeWallAttributes","extrudedHeight","Float64Array","extrudedPosition","scaledNormal","next","bottom","computeWallIndices","index","UL","LL","UR","LR","topBoundingSphere","bottomBoundingSphere","computeExtrudedEllipse","radius","outerPositions","union","topBottomAttributes","posLength","topBottomIndices","topBottomGeo","primitiveType","TRIANGLES","wallAttributes","wallIndices","wallGeo","geo","combineInstances","geometry","computeRectangle","granularity","result","positionsFlat","positionsCount","rectangle","fromCartesianArray","width","PI","north","PI_OVER_TWO","EPSILON7","south","east","west","EllipseGeometry","EMPTY_OBJECT","default","RADIANS_PER_DEGREE","DEFAULT","defined","typeOf","number","_center","_semiMajorAxis","_semiMinorAxis","_ellipsoid","_rotation","_stRotation","_height","_granularity","_vertexFormat","_extrudedHeight","_shadowVolume","_workerName","_offsetAttribute","_rectangle","_textureCoordinateRotationPoints","packedLength","pack","value","array","startingIndex","scratchCenter","scratchEllipsoid","scratchVertexFormat","scratchOptions","unpack","createGeometry","ellipseGeometry","equalsEpsilon","EPSILON2","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","textureCoordinateRotationPoints","boundingRectangle","Object","defineProperties","prototype","get"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 39910, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/EllipseOutlineGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EllipseGeometryLibrary from \"./EllipseGeometryLibrary.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nconst scratchCartesian1 = new Cartesian3();\nlet boundingSphereCenter = new Cartesian3();\n\nfunction computeEllipse(options) {\n  const center = options.center;\n  boundingSphereCenter = Cartesian3.multiplyByScalar(\n    options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter),\n    options.height,\n    boundingSphereCenter,\n  );\n  boundingSphereCenter = Cartesian3.add(\n    center,\n    boundingSphereCenter,\n    boundingSphereCenter,\n  );\n  const boundingSphere = new BoundingSphere(\n    boundingSphereCenter,\n    options.semiMajorAxis,\n  );\n  const positions = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    false,\n    true,\n  ).outerPositions;\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: EllipseGeometryLibrary.raisePositionsToHeight(\n        positions,\n        options,\n        false,\n      ),\n    }),\n  });\n\n  const length = positions.length / 3;\n  const indices = IndexDatatype.createTypedArray(length, length * 2);\n  let index = 0;\n  for (let i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n  }\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\nconst topBoundingSphere = new BoundingSphere();\nconst bottomBoundingSphere = new BoundingSphere();\nfunction computeExtrudedEllipse(options) {\n  const center = options.center;\n  const ellipsoid = options.ellipsoid;\n  const semiMajorAxis = options.semiMajorAxis;\n  let scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1),\n    options.height,\n    scratchCartesian1,\n  );\n  topBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    topBoundingSphere.center,\n  );\n  topBoundingSphere.radius = semiMajorAxis;\n\n  scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scaledNormal),\n    options.extrudedHeight,\n    scaledNormal,\n  );\n  bottomBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    bottomBoundingSphere.center,\n  );\n  bottomBoundingSphere.radius = semiMajorAxis;\n\n  let positions = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    false,\n    true,\n  ).outerPositions;\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: EllipseGeometryLibrary.raisePositionsToHeight(\n        positions,\n        options,\n        true,\n      ),\n    }),\n  });\n\n  positions = attributes.position.values;\n  const boundingSphere = BoundingSphere.union(\n    topBoundingSphere,\n    bottomBoundingSphere,\n  );\n  let length = positions.length / 3;\n\n  if (defined(options.offsetAttribute)) {\n    let applyOffset = new Uint8Array(length);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = applyOffset.fill(1, 0, length / 2);\n    } else {\n      const offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = applyOffset.fill(offsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  let numberOfVerticalLines = options.numberOfVerticalLines ?? 16;\n  numberOfVerticalLines = CesiumMath.clamp(\n    numberOfVerticalLines,\n    0,\n    length / 2,\n  );\n\n  const indices = IndexDatatype.createTypedArray(\n    length,\n    length * 2 + numberOfVerticalLines * 2,\n  );\n\n  length /= 2;\n  let index = 0;\n  let i;\n  for (i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n    indices[index++] = i + length;\n    indices[index++] = ((i + 1) % length) + length;\n  }\n\n  let numSide;\n  if (numberOfVerticalLines > 0) {\n    const numSideLines = Math.min(numberOfVerticalLines, length);\n    numSide = Math.round(length / numSideLines);\n\n    const maxI = Math.min(numSide * numberOfVerticalLines, length);\n    for (i = 0; i < maxI; i += numSide) {\n      indices[index++] = i;\n      indices[index++] = i + length;\n    }\n  }\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\n/**\n * A description of the outline of an ellipse on an ellipsoid.\n *\n * @alias EllipseOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid the ellipse will be on.\n * @param {number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n * @param {number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n * @param {number} [options.rotation=0.0] The angle from north (counter-clockwise) in radians.\n * @param {number} [options.granularity=0.02] The angular distance between points on the ellipse in radians.\n * @param {number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surface of an extruded ellipse.\n *\n * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n * @exception {DeveloperError} granularity must be greater than zero.\n *\n * @see EllipseOutlineGeometry.createGeometry\n *\n * @example\n * const ellipse = new Cesium.EllipseOutlineGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * const geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);\n */\nfunction EllipseOutlineGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const center = options.center;\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(center)) {\n    throw new DeveloperError(\"center is required.\");\n  }\n  if (!defined(semiMajorAxis)) {\n    throw new DeveloperError(\"semiMajorAxis is required.\");\n  }\n  if (!defined(semiMinorAxis)) {\n    throw new DeveloperError(\"semiMinorAxis is required.\");\n  }\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\n      \"semiMajorAxis must be greater than or equal to the semiMinorAxis.\",\n    );\n  }\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  const height = options.height ?? 0.0;\n  const extrudedHeight = options.extrudedHeight ?? height;\n\n  this._center = Cartesian3.clone(center);\n  this._semiMajorAxis = semiMajorAxis;\n  this._semiMinorAxis = semiMinorAxis;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._rotation = options.rotation ?? 0.0;\n  this._height = Math.max(extrudedHeight, height);\n  this._granularity = granularity;\n  this._extrudedHeight = Math.min(extrudedHeight, height);\n  this._numberOfVerticalLines = Math.max(\n    options.numberOfVerticalLines ?? 16,\n    0,\n  );\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipseOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nEllipseOutlineGeometry.packedLength =\n  Cartesian3.packedLength + Ellipsoid.packedLength + 8;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipseOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nEllipseOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  Cartesian3.pack(value._center, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._semiMajorAxis;\n  array[startingIndex++] = value._semiMinorAxis;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._numberOfVerticalLines;\n  array[startingIndex] = value._offsetAttribute ?? -1;\n\n  return array;\n};\n\nconst scratchCenter = new Cartesian3();\nconst scratchEllipsoid = new Ellipsoid();\nconst scratchOptions = {\n  center: scratchCenter,\n  ellipsoid: scratchEllipsoid,\n  semiMajorAxis: undefined,\n  semiMinorAxis: undefined,\n  rotation: undefined,\n  height: undefined,\n  granularity: undefined,\n  extrudedHeight: undefined,\n  numberOfVerticalLines: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipseOutlineGeometry} [result] The object into which to store the result.\n * @returns {EllipseOutlineGeometry} The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.\n */\nEllipseOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n  startingIndex += Cartesian3.packedLength;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const semiMajorAxis = array[startingIndex++];\n  const semiMinorAxis = array[startingIndex++];\n  const rotation = array[startingIndex++];\n  const height = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const numberOfVerticalLines = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.granularity = granularity;\n    scratchOptions.rotation = rotation;\n    scratchOptions.semiMajorAxis = semiMajorAxis;\n    scratchOptions.semiMinorAxis = semiMinorAxis;\n    scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new EllipseOutlineGeometry(scratchOptions);\n  }\n\n  result._center = Cartesian3.clone(center, result._center);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._semiMajorAxis = semiMajorAxis;\n  result._semiMinorAxis = semiMinorAxis;\n  result._rotation = rotation;\n  result._height = height;\n  result._granularity = granularity;\n  result._extrudedHeight = extrudedHeight;\n  result._numberOfVerticalLines = numberOfVerticalLines;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipseOutlineGeometry} ellipseGeometry A description of the ellipse.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipseOutlineGeometry.createGeometry = function (ellipseGeometry) {\n  if (\n    ellipseGeometry._semiMajorAxis <= 0.0 ||\n    ellipseGeometry._semiMinorAxis <= 0.0\n  ) {\n    return;\n  }\n\n  const height = ellipseGeometry._height;\n  const extrudedHeight = ellipseGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2,\n  );\n\n  ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(\n    ellipseGeometry._center,\n    ellipseGeometry._center,\n  );\n  const options = {\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipseGeometry._ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    height: height,\n    granularity: ellipseGeometry._granularity,\n    numberOfVerticalLines: ellipseGeometry._numberOfVerticalLines,\n  };\n  let geometry;\n  if (extrude) {\n    options.extrudedHeight = extrudedHeight;\n    options.offsetAttribute = ellipseGeometry._offsetAttribute;\n    geometry = computeExtrudedEllipse(options);\n  } else {\n    geometry = computeEllipse(options);\n\n    if (defined(ellipseGeometry._offsetAttribute)) {\n      const length = geometry.attributes.position.values.length;\n      const offsetValue =\n        ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: geometry.boundingSphere,\n    offsetAttribute: ellipseGeometry._offsetAttribute,\n  });\n};\nexport default EllipseOutlineGeometry;\n"],"names":["scratchCartesian1","boundingSphereCenter","computeEllipse","options","center","multiplyByScalar","ellipsoid","geodeticSurfaceNormal","height","add","boundingSphere","semiMajorAxis","positions","computeEllipsePositions","outerPositions","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","raisePositionsToHeight","length","indices","createTypedArray","index","i","topBoundingSphere","bottomBoundingSphere","computeExtrudedEllipse","scaledNormal","radius","extrudedHeight","union","offsetAttribute","applyOffset","Uint8Array","TOP","fill","offsetValue","NONE","UNSIGNED_BYTE","numberOfVerticalLines","clamp","numSide","numSideLines","Math","min","round","maxI","EllipseOutlineGeometry","EMPTY_OBJECT","default","semiMinorAxis","granularity","RADIANS_PER_DEGREE","_center","clone","_semiMajorAxis","_semiMinorAxis","_ellipsoid","_rotation","rotation","_height","max","_granularity","_extrudedHeight","_numberOfVerticalLines","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchCenter","scratchEllipsoid","scratchOptions","undefined","unpack","result","createGeometry","ellipseGeometry","extrude","equalsEpsilon","EPSILON2","scaleToGeodeticSurface","geometry","primitiveType","LINES"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 40259, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/EllipsoidGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst scratchPosition = new Cartesian3();\nconst scratchNormal = new Cartesian3();\nconst scratchTangent = new Cartesian3();\nconst scratchBitangent = new Cartesian3();\nconst scratchNormalST = new Cartesian3();\nconst defaultRadii = new Cartesian3(1.0, 1.0, 1.0);\n\nconst cos = Math.cos;\nconst sin = Math.sin;\n\n/**\n * A description of an ellipsoid centered at the origin.\n *\n * @alias EllipsoidGeometry\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\n * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\n * @param {number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {number} [options.stackPartitions=64] The number of times to partition the ellipsoid into stacks.\n * @param {number} [options.slicePartitions=64] The number of times to partition the ellipsoid into radial slices.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} options.slicePartitions cannot be less than three.\n * @exception {DeveloperError} options.stackPartitions cannot be less than three.\n *\n * @see EllipsoidGeometry#createGeometry\n *\n * @example\n * const ellipsoid = new Cesium.EllipsoidGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0)\n * });\n * const geometry = Cesium.EllipsoidGeometry.createGeometry(ellipsoid);\n */\nfunction EllipsoidGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const radii = options.radii ?? defaultRadii;\n  const innerRadii = options.innerRadii ?? radii;\n  const minimumClock = options.minimumClock ?? 0.0;\n  const maximumClock = options.maximumClock ?? CesiumMath.TWO_PI;\n  const minimumCone = options.minimumCone ?? 0.0;\n  const maximumCone = options.maximumCone ?? CesiumMath.PI;\n  const stackPartitions = Math.round(options.stackPartitions ?? 64);\n  const slicePartitions = Math.round(options.slicePartitions ?? 64);\n  const vertexFormat = options.vertexFormat ?? VertexFormat.DEFAULT;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (slicePartitions < 3) {\n    throw new DeveloperError(\n      \"options.slicePartitions cannot be less than three.\",\n    );\n  }\n  if (stackPartitions < 3) {\n    throw new DeveloperError(\n      \"options.stackPartitions cannot be less than three.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._radii = Cartesian3.clone(radii);\n  this._innerRadii = Cartesian3.clone(innerRadii);\n  this._minimumClock = minimumClock;\n  this._maximumClock = maximumClock;\n  this._minimumCone = minimumCone;\n  this._maximumCone = maximumCone;\n  this._stackPartitions = stackPartitions;\n  this._slicePartitions = slicePartitions;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipsoidGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nEllipsoidGeometry.packedLength =\n  2 * Cartesian3.packedLength + VertexFormat.packedLength + 7;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipsoidGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nEllipsoidGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  Cartesian3.pack(value._radii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Cartesian3.pack(value._innerRadii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._minimumClock;\n  array[startingIndex++] = value._maximumClock;\n  array[startingIndex++] = value._minimumCone;\n  array[startingIndex++] = value._maximumCone;\n  array[startingIndex++] = value._stackPartitions;\n  array[startingIndex++] = value._slicePartitions;\n  array[startingIndex] = value._offsetAttribute ?? -1;\n\n  return array;\n};\n\nconst scratchRadii = new Cartesian3();\nconst scratchInnerRadii = new Cartesian3();\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  radii: scratchRadii,\n  innerRadii: scratchInnerRadii,\n  vertexFormat: scratchVertexFormat,\n  minimumClock: undefined,\n  maximumClock: undefined,\n  minimumCone: undefined,\n  maximumCone: undefined,\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipsoidGeometry} [result] The object into which to store the result.\n * @returns {EllipsoidGeometry} The modified result parameter or a new EllipsoidGeometry instance if one was not provided.\n */\nEllipsoidGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const radii = Cartesian3.unpack(array, startingIndex, scratchRadii);\n  startingIndex += Cartesian3.packedLength;\n\n  const innerRadii = Cartesian3.unpack(array, startingIndex, scratchInnerRadii);\n  startingIndex += Cartesian3.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const minimumClock = array[startingIndex++];\n  const maximumClock = array[startingIndex++];\n  const minimumCone = array[startingIndex++];\n  const maximumCone = array[startingIndex++];\n  const stackPartitions = array[startingIndex++];\n  const slicePartitions = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.minimumClock = minimumClock;\n    scratchOptions.maximumClock = maximumClock;\n    scratchOptions.minimumCone = minimumCone;\n    scratchOptions.maximumCone = maximumCone;\n    scratchOptions.stackPartitions = stackPartitions;\n    scratchOptions.slicePartitions = slicePartitions;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipsoidGeometry(scratchOptions);\n  }\n\n  result._radii = Cartesian3.clone(radii, result._radii);\n  result._innerRadii = Cartesian3.clone(innerRadii, result._innerRadii);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._minimumClock = minimumClock;\n  result._maximumClock = maximumClock;\n  result._minimumCone = minimumCone;\n  result._maximumCone = maximumCone;\n  result._stackPartitions = stackPartitions;\n  result._slicePartitions = slicePartitions;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipsoidGeometry} ellipsoidGeometry A description of the ellipsoid.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipsoidGeometry.createGeometry = function (ellipsoidGeometry) {\n  const radii = ellipsoidGeometry._radii;\n  if (radii.x <= 0 || radii.y <= 0 || radii.z <= 0) {\n    return;\n  }\n\n  const innerRadii = ellipsoidGeometry._innerRadii;\n  if (innerRadii.x <= 0 || innerRadii.y <= 0 || innerRadii.z <= 0) {\n    return;\n  }\n\n  const minimumClock = ellipsoidGeometry._minimumClock;\n  const maximumClock = ellipsoidGeometry._maximumClock;\n  const minimumCone = ellipsoidGeometry._minimumCone;\n  const maximumCone = ellipsoidGeometry._maximumCone;\n  const vertexFormat = ellipsoidGeometry._vertexFormat;\n\n  // Add an extra slice and stack so that the number of partitions is the\n  // number of surfaces rather than the number of joints\n  let slicePartitions = ellipsoidGeometry._slicePartitions + 1;\n  let stackPartitions = ellipsoidGeometry._stackPartitions + 1;\n\n  slicePartitions = Math.round(\n    (slicePartitions * Math.abs(maximumClock - minimumClock)) /\n      CesiumMath.TWO_PI,\n  );\n  stackPartitions = Math.round(\n    (stackPartitions * Math.abs(maximumCone - minimumCone)) / CesiumMath.PI,\n  );\n\n  if (slicePartitions < 2) {\n    slicePartitions = 2;\n  }\n  if (stackPartitions < 2) {\n    stackPartitions = 2;\n  }\n\n  let i;\n  let j;\n  let index = 0;\n\n  // Create arrays for theta and phi. Duplicate first and last angle to\n  // allow different normals at the intersections.\n  const phis = [minimumCone];\n  const thetas = [minimumClock];\n  for (i = 0; i < stackPartitions; i++) {\n    phis.push(\n      minimumCone + (i * (maximumCone - minimumCone)) / (stackPartitions - 1),\n    );\n  }\n  phis.push(maximumCone);\n  for (j = 0; j < slicePartitions; j++) {\n    thetas.push(\n      minimumClock +\n        (j * (maximumClock - minimumClock)) / (slicePartitions - 1),\n    );\n  }\n  thetas.push(maximumClock);\n  const numPhis = phis.length;\n  const numThetas = thetas.length;\n\n  // Allow for extra indices if there is an inner surface and if we need\n  // to close the sides if the clock range is not a full circle\n  let extraIndices = 0;\n  let vertexMultiplier = 1.0;\n  const hasInnerSurface =\n    innerRadii.x !== radii.x ||\n    innerRadii.y !== radii.y ||\n    innerRadii.z !== radii.z;\n  let isTopOpen = false;\n  let isBotOpen = false;\n  let isClockOpen = false;\n  if (hasInnerSurface) {\n    vertexMultiplier = 2.0;\n    if (minimumCone > 0.0) {\n      isTopOpen = true;\n      extraIndices += slicePartitions - 1;\n    }\n    if (maximumCone < Math.PI) {\n      isBotOpen = true;\n      extraIndices += slicePartitions - 1;\n    }\n    if ((maximumClock - minimumClock) % CesiumMath.TWO_PI) {\n      isClockOpen = true;\n      extraIndices += (stackPartitions - 1) * 2 + 1;\n    } else {\n      extraIndices += 1;\n    }\n  }\n\n  const vertexCount = numThetas * numPhis * vertexMultiplier;\n  const positions = new Float64Array(vertexCount * 3);\n  const isInner = new Array(vertexCount).fill(false);\n  const negateNormal = new Array(vertexCount).fill(false);\n\n  // Multiply by 6 because there are two triangles per sector\n  const indexCount = slicePartitions * stackPartitions * vertexMultiplier;\n  const numIndices =\n    6 *\n    (indexCount +\n      extraIndices +\n      1 -\n      (slicePartitions + stackPartitions) * vertexMultiplier);\n  const indices = IndexDatatype.createTypedArray(indexCount, numIndices);\n\n  const normals = vertexFormat.normal\n    ? new Float32Array(vertexCount * 3)\n    : undefined;\n  const tangents = vertexFormat.tangent\n    ? new Float32Array(vertexCount * 3)\n    : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(vertexCount * 3)\n    : undefined;\n  const st = vertexFormat.st ? new Float32Array(vertexCount * 2) : undefined;\n\n  // Calculate sin/cos phi\n  const sinPhi = new Array(numPhis);\n  const cosPhi = new Array(numPhis);\n  for (i = 0; i < numPhis; i++) {\n    sinPhi[i] = sin(phis[i]);\n    cosPhi[i] = cos(phis[i]);\n  }\n\n  // Calculate sin/cos theta\n  const sinTheta = new Array(numThetas);\n  const cosTheta = new Array(numThetas);\n  for (j = 0; j < numThetas; j++) {\n    cosTheta[j] = cos(thetas[j]);\n    sinTheta[j] = sin(thetas[j]);\n  }\n\n  // Create outer surface\n  for (i = 0; i < numPhis; i++) {\n    for (j = 0; j < numThetas; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Create inner surface\n  let vertexIndex = vertexCount / 2.0;\n  if (hasInnerSurface) {\n    for (i = 0; i < numPhis; i++) {\n      for (j = 0; j < numThetas; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n\n        // Keep track of which vertices are the inner and which ones\n        // need the normal to be negated\n        isInner[vertexIndex] = true;\n        if (i > 0 && i !== numPhis - 1 && j !== 0 && j !== numThetas - 1) {\n          negateNormal[vertexIndex] = true;\n        }\n        vertexIndex++;\n      }\n    }\n  }\n\n  // Create indices for outer surface\n  index = 0;\n  let topOffset;\n  let bottomOffset;\n  for (i = 1; i < numPhis - 2; i++) {\n    topOffset = i * numThetas;\n    bottomOffset = (i + 1) * numThetas;\n\n    for (j = 1; j < numThetas - 2; j++) {\n      indices[index++] = bottomOffset + j;\n      indices[index++] = bottomOffset + j + 1;\n      indices[index++] = topOffset + j + 1;\n\n      indices[index++] = bottomOffset + j;\n      indices[index++] = topOffset + j + 1;\n      indices[index++] = topOffset + j;\n    }\n  }\n\n  // Create indices for inner surface\n  if (hasInnerSurface) {\n    const offset = numPhis * numThetas;\n    for (i = 1; i < numPhis - 2; i++) {\n      topOffset = offset + i * numThetas;\n      bottomOffset = offset + (i + 1) * numThetas;\n\n      for (j = 1; j < numThetas - 2; j++) {\n        indices[index++] = bottomOffset + j;\n        indices[index++] = topOffset + j;\n        indices[index++] = topOffset + j + 1;\n\n        indices[index++] = bottomOffset + j;\n        indices[index++] = topOffset + j + 1;\n        indices[index++] = bottomOffset + j + 1;\n      }\n    }\n  }\n\n  let outerOffset;\n  let innerOffset;\n  if (hasInnerSurface) {\n    if (isTopOpen) {\n      // Connect the top of the inner surface to the top of the outer surface\n      innerOffset = numPhis * numThetas;\n      for (i = 1; i < numThetas - 2; i++) {\n        indices[index++] = i;\n        indices[index++] = i + 1;\n        indices[index++] = innerOffset + i + 1;\n\n        indices[index++] = i;\n        indices[index++] = innerOffset + i + 1;\n        indices[index++] = innerOffset + i;\n      }\n    }\n\n    if (isBotOpen) {\n      // Connect the bottom of the inner surface to the bottom of the outer surface\n      outerOffset = numPhis * numThetas - numThetas;\n      innerOffset = numPhis * numThetas * vertexMultiplier - numThetas;\n      for (i = 1; i < numThetas - 2; i++) {\n        indices[index++] = outerOffset + i + 1;\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n\n        indices[index++] = outerOffset + i + 1;\n        indices[index++] = innerOffset + i;\n        indices[index++] = innerOffset + i + 1;\n      }\n    }\n  }\n\n  // Connect the edges if clock is not closed\n  if (isClockOpen) {\n    for (i = 1; i < numPhis - 2; i++) {\n      innerOffset = numThetas * numPhis + numThetas * i;\n      outerOffset = numThetas * i;\n      indices[index++] = innerOffset;\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = outerOffset;\n\n      indices[index++] = innerOffset;\n      indices[index++] = innerOffset + numThetas;\n      indices[index++] = outerOffset + numThetas;\n    }\n\n    for (i = 1; i < numPhis - 2; i++) {\n      innerOffset = numThetas * numPhis + numThetas * (i + 1) - 1;\n      outerOffset = numThetas * (i + 1) - 1;\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = innerOffset;\n      indices[index++] = outerOffset;\n\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = innerOffset + numThetas;\n      indices[index++] = innerOffset;\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    });\n  }\n\n  let stIndex = 0;\n  let normalIndex = 0;\n  let tangentIndex = 0;\n  let bitangentIndex = 0;\n  const vertexCountHalf = vertexCount / 2.0;\n\n  let ellipsoid;\n  const ellipsoidOuter = Ellipsoid.fromCartesian3(radii);\n  const ellipsoidInner = Ellipsoid.fromCartesian3(innerRadii);\n\n  if (\n    vertexFormat.st ||\n    vertexFormat.normal ||\n    vertexFormat.tangent ||\n    vertexFormat.bitangent\n  ) {\n    for (i = 0; i < vertexCount; i++) {\n      ellipsoid = isInner[i] ? ellipsoidInner : ellipsoidOuter;\n      const position = Cartesian3.fromArray(positions, i * 3, scratchPosition);\n      const normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n      if (negateNormal[i]) {\n        Cartesian3.negate(normal, normal);\n      }\n\n      if (vertexFormat.st) {\n        const normalST = Cartesian2.negate(normal, scratchNormalST);\n        st[stIndex++] =\n          Math.atan2(normalST.y, normalST.x) / CesiumMath.TWO_PI + 0.5;\n        st[stIndex++] = Math.asin(normal.z) / Math.PI + 0.5;\n      }\n\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n      }\n\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        const tangent = scratchTangent;\n\n        // Use UNIT_X for the poles\n        let tangetOffset = 0;\n        let unit;\n        if (isInner[i]) {\n          tangetOffset = vertexCountHalf;\n        }\n        if (\n          !isTopOpen &&\n          i >= tangetOffset &&\n          i < tangetOffset + numThetas * 2\n        ) {\n          unit = Cartesian3.UNIT_X;\n        } else {\n          unit = Cartesian3.UNIT_Z;\n        }\n        Cartesian3.cross(unit, normal, tangent);\n        Cartesian3.normalize(tangent, tangent);\n\n        if (vertexFormat.tangent) {\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n        }\n\n        if (vertexFormat.bitangent) {\n          const bitangent = Cartesian3.cross(normal, tangent, scratchBitangent);\n          Cartesian3.normalize(bitangent, bitangent);\n\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n        }\n      }\n    }\n\n    if (vertexFormat.st) {\n      attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: st,\n      });\n    }\n\n    if (vertexFormat.normal) {\n      attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n\n    if (vertexFormat.tangent) {\n      attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n\n    if (vertexFormat.bitangent) {\n      attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n  }\n\n  if (defined(ellipsoidGeometry._offsetAttribute)) {\n    const length = positions.length;\n    const offsetValue =\n      ellipsoidGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromEllipsoid(ellipsoidOuter),\n    offsetAttribute: ellipsoidGeometry._offsetAttribute,\n  });\n};\n\nlet unitEllipsoidGeometry;\n\n/**\n * Returns the geometric representation of a unit ellipsoid, including its vertices, indices, and a bounding sphere.\n * @returns {Geometry} The computed vertices and indices.\n *\n * @private\n */\nEllipsoidGeometry.getUnitEllipsoid = function () {\n  if (!defined(unitEllipsoidGeometry)) {\n    unitEllipsoidGeometry = EllipsoidGeometry.createGeometry(\n      new EllipsoidGeometry({\n        radii: new Cartesian3(1.0, 1.0, 1.0),\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      }),\n    );\n  }\n  return unitEllipsoidGeometry;\n};\nexport default EllipsoidGeometry;\n"],"names":["scratchPosition","scratchNormal","scratchTangent","scratchBitangent","scratchNormalST","defaultRadii","cos","Math","sin","EllipsoidGeometry","options","EMPTY_OBJECT","radii","innerRadii","minimumClock","maximumClock","TWO_PI","minimumCone","maximumCone","PI","stackPartitions","round","slicePartitions","vertexFormat","DEFAULT","_radii","clone","_innerRadii","_minimumClock","_maximumClock","_minimumCone","_maximumCone","_stackPartitions","_slicePartitions","_vertexFormat","_offsetAttribute","offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchRadii","scratchInnerRadii","scratchVertexFormat","scratchOptions","undefined","unpack","result","createGeometry","ellipsoidGeometry","x","y","z","abs","i","j","index","phis","thetas","push","numPhis","length","numThetas","extraIndices","vertexMultiplier","hasInnerSurface","isTopOpen","isBotOpen","isClockOpen","vertexCount","positions","Float64Array","isInner","Array","fill","negateNormal","indexCount","numIndices","indices","createTypedArray","normals","normal","Float32Array","tangents","tangent","bitangents","bitangent","st","sinPhi","cosPhi","sinTheta","cosTheta","vertexIndex","topOffset","bottomOffset","offset","outerOffset","innerOffset","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","stIndex","normalIndex","tangentIndex","bitangentIndex","vertexCountHalf","ellipsoid","ellipsoidOuter","fromCartesian3","ellipsoidInner","fromArray","geodeticSurfaceNormal","negate","normalST","atan2","asin","tangetOffset","unit","UNIT_X","UNIT_Z","cross","normalize","FLOAT","offsetValue","NONE","applyOffset","Uint8Array","UNSIGNED_BYTE","primitiveType","TRIANGLES","boundingSphere","fromEllipsoid","unitEllipsoidGeometry","getUnitEllipsoid","POSITION_ONLY"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AAEA,MAAMA,kBAAkB,IAAI,gLAAU;AACtC,MAAMC,gBAAgB,IAAI,gLAAU;AACpC,MAAMC,iBAAiB,IAAI,gLAAU;AACrC,MAAMC,mBAAmB,IAAI,gLAAU;AACvC,MAAMC,kBAAkB,IAAI,gLAAU;AACtC,MAAMC,eAAe,IAAI,gLAAU,CAAC,KAAK,KAAK;AAE9C,MAAMC,MAAMC,KAAKD,GAAG;AACpB,MAAME,MAAMD,KAAKC,GAAG;AAEpB;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BC,GACD,SAASC,kBAAkBC,OAAO;IAChCA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC,MAAMC,QAAQF,QAAQE,KAAK,IAAIP;IAC/B,MAAMQ,aAAaH,QAAQG,UAAU,IAAID;IACzC,MAAME,eAAeJ,QAAQI,YAAY,IAAI;IAC7C,MAAMC,eAAeL,QAAQK,YAAY,IAAI,0KAAU,CAACC,MAAM;IAC9D,MAAMC,cAAcP,QAAQO,WAAW,IAAI;IAC3C,MAAMC,cAAcR,QAAQQ,WAAW,IAAI,0KAAU,CAACC,EAAE;IACxD,MAAMC,kBAAkBb,KAAKc,KAAK,CAACX,QAAQU,eAAe,IAAI;IAC9D,MAAME,kBAAkBf,KAAKc,KAAK,CAACX,QAAQY,eAAe,IAAI;IAC9D,MAAMC,eAAeb,QAAQa,YAAY,IAAI,kLAAY,CAACC,OAAO;IAEjE,yCAAyC;IACzC,IAAIF,kBAAkB,GAAG;QACvB,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,IAAIF,kBAAkB,GAAG;QACvB,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,wBAAwB;IAExB,IAAI,CAACK,MAAM,GAAG,gLAAU,CAACC,KAAK,CAACd;IAC/B,IAAI,CAACe,WAAW,GAAG,gLAAU,CAACD,KAAK,CAACb;IACpC,IAAI,CAACe,aAAa,GAAGd;IACrB,IAAI,CAACe,aAAa,GAAGd;IACrB,IAAI,CAACe,YAAY,GAAGb;IACpB,IAAI,CAACc,YAAY,GAAGb;IACpB,IAAI,CAACc,gBAAgB,GAAGZ;IACxB,IAAI,CAACa,gBAAgB,GAAGX;IACxB,IAAI,CAACY,aAAa,GAAG,kLAAY,CAACR,KAAK,CAACH;IACxC,IAAI,CAACY,gBAAgB,GAAGzB,QAAQ0B,eAAe;IAC/C,IAAI,CAACC,WAAW,GAAG;AACrB;AAEA;;;CAGC,GACD5B,kBAAkB6B,YAAY,GAC5B,IAAI,gLAAU,CAACA,YAAY,GAAG,kLAAY,CAACA,YAAY,GAAG;AAE5D;;;;;;;;CAQC,GACD7B,kBAAkB8B,IAAI,GAAG,SAAUC,KAAK,EAAEC,KAAK,EAAEC,aAAa;IAC5D,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACF,QAAQ;QACnB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACC,QAAQ;QACnB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjC,gLAAU,CAACH,IAAI,CAACC,MAAMf,MAAM,EAAEgB,OAAOC;IACrCA,iBAAiB,gLAAU,CAACJ,YAAY;IAExC,gLAAU,CAACC,IAAI,CAACC,MAAMb,WAAW,EAAEc,OAAOC;IAC1CA,iBAAiB,gLAAU,CAACJ,YAAY;IAExC,kLAAY,CAACC,IAAI,CAACC,MAAMN,aAAa,EAAEO,OAAOC;IAC9CA,iBAAiB,kLAAY,CAACJ,YAAY;IAE1CG,KAAK,CAACC,gBAAgB,GAAGF,MAAMZ,aAAa;IAC5Ca,KAAK,CAACC,gBAAgB,GAAGF,MAAMX,aAAa;IAC5CY,KAAK,CAACC,gBAAgB,GAAGF,MAAMV,YAAY;IAC3CW,KAAK,CAACC,gBAAgB,GAAGF,MAAMT,YAAY;IAC3CU,KAAK,CAACC,gBAAgB,GAAGF,MAAMR,gBAAgB;IAC/CS,KAAK,CAACC,gBAAgB,GAAGF,MAAMP,gBAAgB;IAC/CQ,KAAK,CAACC,cAAc,GAAGF,MAAML,gBAAgB,IAAI,CAAC;IAElD,OAAOM;AACT;AAEA,MAAME,eAAe,IAAI,gLAAU;AACnC,MAAMC,oBAAoB,IAAI,gLAAU;AACxC,MAAMC,sBAAsB,IAAI,kLAAY;AAC5C,MAAMC,iBAAiB;IACrBlC,OAAO+B;IACP9B,YAAY+B;IACZrB,cAAcsB;IACd/B,cAAciC;IACdhC,cAAcgC;IACd9B,aAAa8B;IACb7B,aAAa6B;IACb3B,iBAAiB2B;IACjBzB,iBAAiByB;IACjBX,iBAAiBW;AACnB;AAEA;;;;;;;CAOC,GACDtC,kBAAkBuC,MAAM,GAAG,SAAUP,KAAK,EAAEC,aAAa,EAAEO,MAAM;IAC/D,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACR,QAAQ;QACnB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjC,MAAM9B,QAAQ,gLAAU,CAACoC,MAAM,CAACP,OAAOC,eAAeC;IACtDD,iBAAiB,gLAAU,CAACJ,YAAY;IAExC,MAAMzB,aAAa,gLAAU,CAACmC,MAAM,CAACP,OAAOC,eAAeE;IAC3DF,iBAAiB,gLAAU,CAACJ,YAAY;IAExC,MAAMf,eAAe,kLAAY,CAACyB,MAAM,CACtCP,OACAC,eACAG;IAEFH,iBAAiB,kLAAY,CAACJ,YAAY;IAE1C,MAAMxB,eAAe2B,KAAK,CAACC,gBAAgB;IAC3C,MAAM3B,eAAe0B,KAAK,CAACC,gBAAgB;IAC3C,MAAMzB,cAAcwB,KAAK,CAACC,gBAAgB;IAC1C,MAAMxB,cAAcuB,KAAK,CAACC,gBAAgB;IAC1C,MAAMtB,kBAAkBqB,KAAK,CAACC,gBAAgB;IAC9C,MAAMpB,kBAAkBmB,KAAK,CAACC,gBAAgB;IAC9C,MAAMN,kBAAkBK,KAAK,CAACC,cAAc;IAE5C,IAAI,CAAC,IAAA,6KAAO,EAACO,SAAS;QACpBH,eAAehC,YAAY,GAAGA;QAC9BgC,eAAe/B,YAAY,GAAGA;QAC9B+B,eAAe7B,WAAW,GAAGA;QAC7B6B,eAAe5B,WAAW,GAAGA;QAC7B4B,eAAe1B,eAAe,GAAGA;QACjC0B,eAAexB,eAAe,GAAGA;QACjCwB,eAAeV,eAAe,GAC5BA,oBAAoB,CAAC,IAAIW,YAAYX;QACvC,OAAO,IAAI3B,kBAAkBqC;IAC/B;IAEAG,OAAOxB,MAAM,GAAG,gLAAU,CAACC,KAAK,CAACd,OAAOqC,OAAOxB,MAAM;IACrDwB,OAAOtB,WAAW,GAAG,gLAAU,CAACD,KAAK,CAACb,YAAYoC,OAAOtB,WAAW;IACpEsB,OAAOf,aAAa,GAAG,kLAAY,CAACR,KAAK,CAACH,cAAc0B,OAAOf,aAAa;IAC5Ee,OAAOrB,aAAa,GAAGd;IACvBmC,OAAOpB,aAAa,GAAGd;IACvBkC,OAAOnB,YAAY,GAAGb;IACtBgC,OAAOlB,YAAY,GAAGb;IACtB+B,OAAOjB,gBAAgB,GAAGZ;IAC1B6B,OAAOhB,gBAAgB,GAAGX;IAC1B2B,OAAOd,gBAAgB,GACrBC,oBAAoB,CAAC,IAAIW,YAAYX;IAEvC,OAAOa;AACT;AAEA;;;;;CAKC,GACDxC,kBAAkByC,cAAc,GAAG,SAAUC,iBAAiB;IAC5D,MAAMvC,QAAQuC,kBAAkB1B,MAAM;IACtC,IAAIb,MAAMwC,CAAC,IAAI,KAAKxC,MAAMyC,CAAC,IAAI,KAAKzC,MAAM0C,CAAC,IAAI,GAAG;QAChD;IACF;IAEA,MAAMzC,aAAasC,kBAAkBxB,WAAW;IAChD,IAAId,WAAWuC,CAAC,IAAI,KAAKvC,WAAWwC,CAAC,IAAI,KAAKxC,WAAWyC,CAAC,IAAI,GAAG;QAC/D;IACF;IAEA,MAAMxC,eAAeqC,kBAAkBvB,aAAa;IACpD,MAAMb,eAAeoC,kBAAkBtB,aAAa;IACpD,MAAMZ,cAAckC,kBAAkBrB,YAAY;IAClD,MAAMZ,cAAciC,kBAAkBpB,YAAY;IAClD,MAAMR,eAAe4B,kBAAkBjB,aAAa;IAEpD,uEAAuE;IACvE,sDAAsD;IACtD,IAAIZ,kBAAkB6B,kBAAkBlB,gBAAgB,GAAG;IAC3D,IAAIb,kBAAkB+B,kBAAkBnB,gBAAgB,GAAG;IAE3DV,kBAAkBf,KAAKc,KAAK,CAC1B,AAACC,kBAAkBf,KAAKgD,GAAG,CAACxC,eAAeD,gBACzC,0KAAU,CAACE,MAAM;IAErBI,kBAAkBb,KAAKc,KAAK,CAC1B,AAACD,kBAAkBb,KAAKgD,GAAG,CAACrC,cAAcD,eAAgB,0KAAU,CAACE,EAAE;IAGzE,IAAIG,kBAAkB,GAAG;QACvBA,kBAAkB;IACpB;IACA,IAAIF,kBAAkB,GAAG;QACvBA,kBAAkB;IACpB;IAEA,IAAIoC;IACJ,IAAIC;IACJ,IAAIC,QAAQ;IAEZ,qEAAqE;IACrE,gDAAgD;IAChD,MAAMC,OAAO;QAAC1C;KAAY;IAC1B,MAAM2C,SAAS;QAAC9C;KAAa;IAC7B,IAAK0C,IAAI,GAAGA,IAAIpC,iBAAiBoC,IAAK;QACpCG,KAAKE,IAAI,CACP5C,cAAc,AAACuC,IAAI,CAACtC,cAAcD,WAAW,IAAK,CAACG,kBAAkB,CAAC;IAE1E;IACAuC,KAAKE,IAAI,CAAC3C;IACV,IAAKuC,IAAI,GAAGA,IAAInC,iBAAiBmC,IAAK;QACpCG,OAAOC,IAAI,CACT/C,eACE,AAAC2C,IAAI,CAAC1C,eAAeD,YAAY,IAAK,CAACQ,kBAAkB,CAAC;IAEhE;IACAsC,OAAOC,IAAI,CAAC9C;IACZ,MAAM+C,UAAUH,KAAKI,MAAM;IAC3B,MAAMC,YAAYJ,OAAOG,MAAM;IAE/B,sEAAsE;IACtE,6DAA6D;IAC7D,IAAIE,eAAe;IACnB,IAAIC,mBAAmB;IACvB,MAAMC,kBACJtD,WAAWuC,CAAC,KAAKxC,MAAMwC,CAAC,IACxBvC,WAAWwC,CAAC,KAAKzC,MAAMyC,CAAC,IACxBxC,WAAWyC,CAAC,KAAK1C,MAAM0C,CAAC;IAC1B,IAAIc,YAAY;IAChB,IAAIC,YAAY;IAChB,IAAIC,cAAc;IAClB,IAAIH,iBAAiB;QACnBD,mBAAmB;QACnB,IAAIjD,cAAc,KAAK;YACrBmD,YAAY;YACZH,gBAAgB3C,kBAAkB;QACpC;QACA,IAAIJ,cAAcX,KAAKY,EAAE,EAAE;YACzBkD,YAAY;YACZJ,gBAAgB3C,kBAAkB;QACpC;QACA,IAAI,CAACP,eAAeD,YAAY,IAAI,0KAAU,CAACE,MAAM,EAAE;YACrDsD,cAAc;YACdL,gBAAgB,CAAC7C,kBAAkB,CAAC,IAAI,IAAI;QAC9C,OAAO;YACL6C,gBAAgB;QAClB;IACF;IAEA,MAAMM,cAAcP,YAAYF,UAAUI;IAC1C,MAAMM,YAAY,IAAIC,aAAaF,cAAc;IACjD,MAAMG,UAAU,IAAIC,MAAMJ,aAAaK,IAAI,CAAC;IAC5C,MAAMC,eAAe,IAAIF,MAAMJ,aAAaK,IAAI,CAAC;IAEjD,2DAA2D;IAC3D,MAAME,aAAaxD,kBAAkBF,kBAAkB8C;IACvD,MAAMa,aACJ,IACA,CAACD,aACCb,eACA,IACA,CAAC3C,kBAAkBF,eAAe,IAAI8C,gBAAgB;IAC1D,MAAMc,UAAU,mLAAa,CAACC,gBAAgB,CAACH,YAAYC;IAE3D,MAAMG,UAAU3D,aAAa4D,MAAM,GAC/B,IAAIC,aAAab,cAAc,KAC/BxB;IACJ,MAAMsC,WAAW9D,aAAa+D,OAAO,GACjC,IAAIF,aAAab,cAAc,KAC/BxB;IACJ,MAAMwC,aAAahE,aAAaiE,SAAS,GACrC,IAAIJ,aAAab,cAAc,KAC/BxB;IACJ,MAAM0C,KAAKlE,aAAakE,EAAE,GAAG,IAAIL,aAAab,cAAc,KAAKxB;IAEjE,wBAAwB;IACxB,MAAM2C,SAAS,IAAIf,MAAMb;IACzB,MAAM6B,SAAS,IAAIhB,MAAMb;IACzB,IAAKN,IAAI,GAAGA,IAAIM,SAASN,IAAK;QAC5BkC,MAAM,CAAClC,EAAE,GAAGhD,IAAImD,IAAI,CAACH,EAAE;QACvBmC,MAAM,CAACnC,EAAE,GAAGlD,IAAIqD,IAAI,CAACH,EAAE;IACzB;IAEA,0BAA0B;IAC1B,MAAMoC,WAAW,IAAIjB,MAAMX;IAC3B,MAAM6B,WAAW,IAAIlB,MAAMX;IAC3B,IAAKP,IAAI,GAAGA,IAAIO,WAAWP,IAAK;QAC9BoC,QAAQ,CAACpC,EAAE,GAAGnD,IAAIsD,MAAM,CAACH,EAAE;QAC3BmC,QAAQ,CAACnC,EAAE,GAAGjD,IAAIoD,MAAM,CAACH,EAAE;IAC7B;IAEA,uBAAuB;IACvB,IAAKD,IAAI,GAAGA,IAAIM,SAASN,IAAK;QAC5B,IAAKC,IAAI,GAAGA,IAAIO,WAAWP,IAAK;YAC9Be,SAAS,CAACd,QAAQ,GAAG9C,MAAMwC,CAAC,GAAGsC,MAAM,CAAClC,EAAE,GAAGqC,QAAQ,CAACpC,EAAE;YACtDe,SAAS,CAACd,QAAQ,GAAG9C,MAAMyC,CAAC,GAAGqC,MAAM,CAAClC,EAAE,GAAGoC,QAAQ,CAACnC,EAAE;YACtDe,SAAS,CAACd,QAAQ,GAAG9C,MAAM0C,CAAC,GAAGqC,MAAM,CAACnC,EAAE;QAC1C;IACF;IAEA,uBAAuB;IACvB,IAAIsC,cAAcvB,cAAc;IAChC,IAAIJ,iBAAiB;QACnB,IAAKX,IAAI,GAAGA,IAAIM,SAASN,IAAK;YAC5B,IAAKC,IAAI,GAAGA,IAAIO,WAAWP,IAAK;gBAC9Be,SAAS,CAACd,QAAQ,GAAG7C,WAAWuC,CAAC,GAAGsC,MAAM,CAAClC,EAAE,GAAGqC,QAAQ,CAACpC,EAAE;gBAC3De,SAAS,CAACd,QAAQ,GAAG7C,WAAWwC,CAAC,GAAGqC,MAAM,CAAClC,EAAE,GAAGoC,QAAQ,CAACnC,EAAE;gBAC3De,SAAS,CAACd,QAAQ,GAAG7C,WAAWyC,CAAC,GAAGqC,MAAM,CAACnC,EAAE;gBAE7C,4DAA4D;gBAC5D,gCAAgC;gBAChCkB,OAAO,CAACoB,YAAY,GAAG;gBACvB,IAAItC,IAAI,KAAKA,MAAMM,UAAU,KAAKL,MAAM,KAAKA,MAAMO,YAAY,GAAG;oBAChEa,YAAY,CAACiB,YAAY,GAAG;gBAC9B;gBACAA;YACF;QACF;IACF;IAEA,mCAAmC;IACnCpC,QAAQ;IACR,IAAIqC;IACJ,IAAIC;IACJ,IAAKxC,IAAI,GAAGA,IAAIM,UAAU,GAAGN,IAAK;QAChCuC,YAAYvC,IAAIQ;QAChBgC,eAAe,CAACxC,IAAI,CAAC,IAAIQ;QAEzB,IAAKP,IAAI,GAAGA,IAAIO,YAAY,GAAGP,IAAK;YAClCuB,OAAO,CAACtB,QAAQ,GAAGsC,eAAevC;YAClCuB,OAAO,CAACtB,QAAQ,GAAGsC,eAAevC,IAAI;YACtCuB,OAAO,CAACtB,QAAQ,GAAGqC,YAAYtC,IAAI;YAEnCuB,OAAO,CAACtB,QAAQ,GAAGsC,eAAevC;YAClCuB,OAAO,CAACtB,QAAQ,GAAGqC,YAAYtC,IAAI;YACnCuB,OAAO,CAACtB,QAAQ,GAAGqC,YAAYtC;QACjC;IACF;IAEA,mCAAmC;IACnC,IAAIU,iBAAiB;QACnB,MAAM8B,SAASnC,UAAUE;QACzB,IAAKR,IAAI,GAAGA,IAAIM,UAAU,GAAGN,IAAK;YAChCuC,YAAYE,SAASzC,IAAIQ;YACzBgC,eAAeC,SAAS,CAACzC,IAAI,CAAC,IAAIQ;YAElC,IAAKP,IAAI,GAAGA,IAAIO,YAAY,GAAGP,IAAK;gBAClCuB,OAAO,CAACtB,QAAQ,GAAGsC,eAAevC;gBAClCuB,OAAO,CAACtB,QAAQ,GAAGqC,YAAYtC;gBAC/BuB,OAAO,CAACtB,QAAQ,GAAGqC,YAAYtC,IAAI;gBAEnCuB,OAAO,CAACtB,QAAQ,GAAGsC,eAAevC;gBAClCuB,OAAO,CAACtB,QAAQ,GAAGqC,YAAYtC,IAAI;gBACnCuB,OAAO,CAACtB,QAAQ,GAAGsC,eAAevC,IAAI;YACxC;QACF;IACF;IAEA,IAAIyC;IACJ,IAAIC;IACJ,IAAIhC,iBAAiB;QACnB,IAAIC,WAAW;YACb,uEAAuE;YACvE+B,cAAcrC,UAAUE;YACxB,IAAKR,IAAI,GAAGA,IAAIQ,YAAY,GAAGR,IAAK;gBAClCwB,OAAO,CAACtB,QAAQ,GAAGF;gBACnBwB,OAAO,CAACtB,QAAQ,GAAGF,IAAI;gBACvBwB,OAAO,CAACtB,QAAQ,GAAGyC,cAAc3C,IAAI;gBAErCwB,OAAO,CAACtB,QAAQ,GAAGF;gBACnBwB,OAAO,CAACtB,QAAQ,GAAGyC,cAAc3C,IAAI;gBACrCwB,OAAO,CAACtB,QAAQ,GAAGyC,cAAc3C;YACnC;QACF;QAEA,IAAIa,WAAW;YACb,6EAA6E;YAC7E6B,cAAcpC,UAAUE,YAAYA;YACpCmC,cAAcrC,UAAUE,YAAYE,mBAAmBF;YACvD,IAAKR,IAAI,GAAGA,IAAIQ,YAAY,GAAGR,IAAK;gBAClCwB,OAAO,CAACtB,QAAQ,GAAGwC,cAAc1C,IAAI;gBACrCwB,OAAO,CAACtB,QAAQ,GAAGwC,cAAc1C;gBACjCwB,OAAO,CAACtB,QAAQ,GAAGyC,cAAc3C;gBAEjCwB,OAAO,CAACtB,QAAQ,GAAGwC,cAAc1C,IAAI;gBACrCwB,OAAO,CAACtB,QAAQ,GAAGyC,cAAc3C;gBACjCwB,OAAO,CAACtB,QAAQ,GAAGyC,cAAc3C,IAAI;YACvC;QACF;IACF;IAEA,2CAA2C;IAC3C,IAAIc,aAAa;QACf,IAAKd,IAAI,GAAGA,IAAIM,UAAU,GAAGN,IAAK;YAChC2C,cAAcnC,YAAYF,UAAUE,YAAYR;YAChD0C,cAAclC,YAAYR;YAC1BwB,OAAO,CAACtB,QAAQ,GAAGyC;YACnBnB,OAAO,CAACtB,QAAQ,GAAGwC,cAAclC;YACjCgB,OAAO,CAACtB,QAAQ,GAAGwC;YAEnBlB,OAAO,CAACtB,QAAQ,GAAGyC;YACnBnB,OAAO,CAACtB,QAAQ,GAAGyC,cAAcnC;YACjCgB,OAAO,CAACtB,QAAQ,GAAGwC,cAAclC;QACnC;QAEA,IAAKR,IAAI,GAAGA,IAAIM,UAAU,GAAGN,IAAK;YAChC2C,cAAcnC,YAAYF,UAAUE,YAAY,CAACR,IAAI,CAAC,IAAI;YAC1D0C,cAAclC,YAAY,CAACR,IAAI,CAAC,IAAI;YACpCwB,OAAO,CAACtB,QAAQ,GAAGwC,cAAclC;YACjCgB,OAAO,CAACtB,QAAQ,GAAGyC;YACnBnB,OAAO,CAACtB,QAAQ,GAAGwC;YAEnBlB,OAAO,CAACtB,QAAQ,GAAGwC,cAAclC;YACjCgB,OAAO,CAACtB,QAAQ,GAAGyC,cAAcnC;YACjCgB,OAAO,CAACtB,QAAQ,GAAGyC;QACrB;IACF;IAEA,MAAMC,aAAa,IAAI,wLAAkB;IAEzC,IAAI7E,aAAa8E,QAAQ,EAAE;QACzBD,WAAWC,QAAQ,GAAG,IAAI,uLAAiB,CAAC;YAC1CC,mBAAmB,uLAAiB,CAACC,MAAM;YAC3CC,wBAAwB;YACxBC,QAAQjC;QACV;IACF;IAEA,IAAIkC,UAAU;IACd,IAAIC,cAAc;IAClB,IAAIC,eAAe;IACnB,IAAIC,iBAAiB;IACrB,MAAMC,kBAAkBvC,cAAc;IAEtC,IAAIwC;IACJ,MAAMC,iBAAiB,+KAAS,CAACC,cAAc,CAACrG;IAChD,MAAMsG,iBAAiB,+KAAS,CAACD,cAAc,CAACpG;IAEhD,IACEU,aAAakE,EAAE,IACflE,aAAa4D,MAAM,IACnB5D,aAAa+D,OAAO,IACpB/D,aAAaiE,SAAS,EACtB;QACA,IAAKhC,IAAI,GAAGA,IAAIe,aAAaf,IAAK;YAChCuD,YAAYrC,OAAO,CAAClB,EAAE,GAAG0D,iBAAiBF;YAC1C,MAAMX,WAAW,gLAAU,CAACc,SAAS,CAAC3C,WAAWhB,IAAI,GAAGxD;YACxD,MAAMmF,SAAS4B,UAAUK,qBAAqB,CAACf,UAAUpG;YACzD,IAAI4E,YAAY,CAACrB,EAAE,EAAE;gBACnB,gLAAU,CAAC6D,MAAM,CAAClC,QAAQA;YAC5B;YAEA,IAAI5D,aAAakE,EAAE,EAAE;gBACnB,MAAM6B,WAAW,gLAAU,CAACD,MAAM,CAAClC,QAAQ/E;gBAC3CqF,EAAE,CAACiB,UAAU,GACXnG,KAAKgH,KAAK,CAACD,SAASjE,CAAC,EAAEiE,SAASlE,CAAC,IAAI,0KAAU,CAACpC,MAAM,GAAG;gBAC3DyE,EAAE,CAACiB,UAAU,GAAGnG,KAAKiH,IAAI,CAACrC,OAAO7B,CAAC,IAAI/C,KAAKY,EAAE,GAAG;YAClD;YAEA,IAAII,aAAa4D,MAAM,EAAE;gBACvBD,OAAO,CAACyB,cAAc,GAAGxB,OAAO/B,CAAC;gBACjC8B,OAAO,CAACyB,cAAc,GAAGxB,OAAO9B,CAAC;gBACjC6B,OAAO,CAACyB,cAAc,GAAGxB,OAAO7B,CAAC;YACnC;YAEA,IAAI/B,aAAa+D,OAAO,IAAI/D,aAAaiE,SAAS,EAAE;gBAClD,MAAMF,UAAUpF;gBAEhB,2BAA2B;gBAC3B,IAAIuH,eAAe;gBACnB,IAAIC;gBACJ,IAAIhD,OAAO,CAAClB,EAAE,EAAE;oBACdiE,eAAeX;gBACjB;gBACA,IACE,CAAC1C,aACDZ,KAAKiE,gBACLjE,IAAIiE,eAAezD,YAAY,GAC/B;oBACA0D,OAAO,gLAAU,CAACC,MAAM;gBAC1B,OAAO;oBACLD,OAAO,gLAAU,CAACE,MAAM;gBAC1B;gBACA,gLAAU,CAACC,KAAK,CAACH,MAAMvC,QAAQG;gBAC/B,gLAAU,CAACwC,SAAS,CAACxC,SAASA;gBAE9B,IAAI/D,aAAa+D,OAAO,EAAE;oBACxBD,QAAQ,CAACuB,eAAe,GAAGtB,QAAQlC,CAAC;oBACpCiC,QAAQ,CAACuB,eAAe,GAAGtB,QAAQjC,CAAC;oBACpCgC,QAAQ,CAACuB,eAAe,GAAGtB,QAAQhC,CAAC;gBACtC;gBAEA,IAAI/B,aAAaiE,SAAS,EAAE;oBAC1B,MAAMA,YAAY,gLAAU,CAACqC,KAAK,CAAC1C,QAAQG,SAASnF;oBACpD,gLAAU,CAAC2H,SAAS,CAACtC,WAAWA;oBAEhCD,UAAU,CAACsB,iBAAiB,GAAGrB,UAAUpC,CAAC;oBAC1CmC,UAAU,CAACsB,iBAAiB,GAAGrB,UAAUnC,CAAC;oBAC1CkC,UAAU,CAACsB,iBAAiB,GAAGrB,UAAUlC,CAAC;gBAC5C;YACF;QACF;QAEA,IAAI/B,aAAakE,EAAE,EAAE;YACnBW,WAAWX,EAAE,GAAG,IAAI,uLAAiB,CAAC;gBACpCa,mBAAmB,uLAAiB,CAACyB,KAAK;gBAC1CvB,wBAAwB;gBACxBC,QAAQhB;YACV;QACF;QAEA,IAAIlE,aAAa4D,MAAM,EAAE;YACvBiB,WAAWjB,MAAM,GAAG,IAAI,uLAAiB,CAAC;gBACxCmB,mBAAmB,uLAAiB,CAACyB,KAAK;gBAC1CvB,wBAAwB;gBACxBC,QAAQvB;YACV;QACF;QAEA,IAAI3D,aAAa+D,OAAO,EAAE;YACxBc,WAAWd,OAAO,GAAG,IAAI,uLAAiB,CAAC;gBACzCgB,mBAAmB,uLAAiB,CAACyB,KAAK;gBAC1CvB,wBAAwB;gBACxBC,QAAQpB;YACV;QACF;QAEA,IAAI9D,aAAaiE,SAAS,EAAE;YAC1BY,WAAWZ,SAAS,GAAG,IAAI,uLAAiB,CAAC;gBAC3Cc,mBAAmB,uLAAiB,CAACyB,KAAK;gBAC1CvB,wBAAwB;gBACxBC,QAAQlB;YACV;QACF;IACF;IAEA,IAAI,IAAA,6KAAO,EAACpC,kBAAkBhB,gBAAgB,GAAG;QAC/C,MAAM4B,SAASS,UAAUT,MAAM;QAC/B,MAAMiE,cACJ7E,kBAAkBhB,gBAAgB,KAAK,6LAAuB,CAAC8F,IAAI,GAC/D,IACA;QACN,MAAMC,cAAc,IAAIC,WAAWpE,SAAS,GAAGa,IAAI,CAACoD;QACpD5B,WAAW8B,WAAW,GAAG,IAAI,uLAAiB,CAAC;YAC7C5B,mBAAmB,uLAAiB,CAAC8B,aAAa;YAClD5B,wBAAwB;YACxBC,QAAQyB;QACV;IACF;IAEA,OAAO,IAAI,8KAAQ,CAAC;QAClB9B,YAAYA;QACZpB,SAASA;QACTqD,eAAe,mLAAa,CAACC,SAAS;QACtCC,gBAAgB,oLAAc,CAACC,aAAa,CAACxB;QAC7C5E,iBAAiBe,kBAAkBhB,gBAAgB;IACrD;AACF;AAEA,IAAIsG;AAEJ;;;;;CAKC,GACDhI,kBAAkBiI,gBAAgB,GAAG;IACnC,IAAI,CAAC,IAAA,6KAAO,EAACD,wBAAwB;QACnCA,wBAAwBhI,kBAAkByC,cAAc,CACtD,IAAIzC,kBAAkB;YACpBG,OAAO,IAAI,gLAAU,CAAC,KAAK,KAAK;YAChCW,cAAc,kLAAY,CAACoH,aAAa;QAC1C;IAEJ;IACA,OAAOF;AACT;uCACehI","ignoreList":[0]}},
    {"offset": {"line": 40806, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/EllipsoidOutlineGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nconst defaultRadii = new Cartesian3(1.0, 1.0, 1.0);\nconst cos = Math.cos;\nconst sin = Math.sin;\n\n/**\n * A description of the outline of an ellipsoid centered at the origin.\n *\n * @alias EllipsoidOutlineGeometry\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\n * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\n * @param {number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {number} [options.stackPartitions=10] The count of stacks for the ellipsoid (1 greater than the number of parallel lines).\n * @param {number} [options.slicePartitions=8] The count of slices for the ellipsoid (Equal to the number of radial lines).\n * @param {number} [options.subdivisions=128] The number of points per line, determining the granularity of the curvature.\n *\n * @exception {DeveloperError} options.stackPartitions must be greater than or equal to one.\n * @exception {DeveloperError} options.slicePartitions must be greater than or equal to zero.\n * @exception {DeveloperError} options.subdivisions must be greater than or equal to zero.\n *\n * @example\n * const ellipsoid = new Cesium.EllipsoidOutlineGeometry({\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0),\n *   stackPartitions: 6,\n *   slicePartitions: 5\n * });\n * const geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(ellipsoid);\n */\nfunction EllipsoidOutlineGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const radii = options.radii ?? defaultRadii;\n  const innerRadii = options.innerRadii ?? radii;\n  const minimumClock = options.minimumClock ?? 0.0;\n  const maximumClock = options.maximumClock ?? CesiumMath.TWO_PI;\n  const minimumCone = options.minimumCone ?? 0.0;\n  const maximumCone = options.maximumCone ?? CesiumMath.PI;\n  const stackPartitions = Math.round(options.stackPartitions ?? 10);\n  const slicePartitions = Math.round(options.slicePartitions ?? 8);\n  const subdivisions = Math.round(options.subdivisions ?? 128);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (stackPartitions < 1) {\n    throw new DeveloperError(\"options.stackPartitions cannot be less than 1\");\n  }\n  if (slicePartitions < 0) {\n    throw new DeveloperError(\"options.slicePartitions cannot be less than 0\");\n  }\n  if (subdivisions < 0) {\n    throw new DeveloperError(\n      \"options.subdivisions must be greater than or equal to zero.\",\n    );\n  }\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._radii = Cartesian3.clone(radii);\n  this._innerRadii = Cartesian3.clone(innerRadii);\n  this._minimumClock = minimumClock;\n  this._maximumClock = maximumClock;\n  this._minimumCone = minimumCone;\n  this._maximumCone = maximumCone;\n  this._stackPartitions = stackPartitions;\n  this._slicePartitions = slicePartitions;\n  this._subdivisions = subdivisions;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipsoidOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nEllipsoidOutlineGeometry.packedLength = 2 * Cartesian3.packedLength + 8;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipsoidOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nEllipsoidOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  Cartesian3.pack(value._radii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Cartesian3.pack(value._innerRadii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  array[startingIndex++] = value._minimumClock;\n  array[startingIndex++] = value._maximumClock;\n  array[startingIndex++] = value._minimumCone;\n  array[startingIndex++] = value._maximumCone;\n  array[startingIndex++] = value._stackPartitions;\n  array[startingIndex++] = value._slicePartitions;\n  array[startingIndex++] = value._subdivisions;\n  array[startingIndex] = value._offsetAttribute ?? -1;\n\n  return array;\n};\n\nconst scratchRadii = new Cartesian3();\nconst scratchInnerRadii = new Cartesian3();\nconst scratchOptions = {\n  radii: scratchRadii,\n  innerRadii: scratchInnerRadii,\n  minimumClock: undefined,\n  maximumClock: undefined,\n  minimumCone: undefined,\n  maximumCone: undefined,\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  subdivisions: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipsoidOutlineGeometry} [result] The object into which to store the result.\n * @returns {EllipsoidOutlineGeometry} The modified result parameter or a new EllipsoidOutlineGeometry instance if one was not provided.\n */\nEllipsoidOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const radii = Cartesian3.unpack(array, startingIndex, scratchRadii);\n  startingIndex += Cartesian3.packedLength;\n\n  const innerRadii = Cartesian3.unpack(array, startingIndex, scratchInnerRadii);\n  startingIndex += Cartesian3.packedLength;\n\n  const minimumClock = array[startingIndex++];\n  const maximumClock = array[startingIndex++];\n  const minimumCone = array[startingIndex++];\n  const maximumCone = array[startingIndex++];\n  const stackPartitions = array[startingIndex++];\n  const slicePartitions = array[startingIndex++];\n  const subdivisions = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.minimumClock = minimumClock;\n    scratchOptions.maximumClock = maximumClock;\n    scratchOptions.minimumCone = minimumCone;\n    scratchOptions.maximumCone = maximumCone;\n    scratchOptions.stackPartitions = stackPartitions;\n    scratchOptions.slicePartitions = slicePartitions;\n    scratchOptions.subdivisions = subdivisions;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipsoidOutlineGeometry(scratchOptions);\n  }\n\n  result._radii = Cartesian3.clone(radii, result._radii);\n  result._innerRadii = Cartesian3.clone(innerRadii, result._innerRadii);\n  result._minimumClock = minimumClock;\n  result._maximumClock = maximumClock;\n  result._minimumCone = minimumCone;\n  result._maximumCone = maximumCone;\n  result._stackPartitions = stackPartitions;\n  result._slicePartitions = slicePartitions;\n  result._subdivisions = subdivisions;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipsoidOutlineGeometry} ellipsoidGeometry A description of the ellipsoid outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipsoidOutlineGeometry.createGeometry = function (ellipsoidGeometry) {\n  const radii = ellipsoidGeometry._radii;\n  if (radii.x <= 0 || radii.y <= 0 || radii.z <= 0) {\n    return;\n  }\n\n  const innerRadii = ellipsoidGeometry._innerRadii;\n  if (innerRadii.x <= 0 || innerRadii.y <= 0 || innerRadii.z <= 0) {\n    return;\n  }\n\n  const minimumClock = ellipsoidGeometry._minimumClock;\n  const maximumClock = ellipsoidGeometry._maximumClock;\n  const minimumCone = ellipsoidGeometry._minimumCone;\n  const maximumCone = ellipsoidGeometry._maximumCone;\n  const subdivisions = ellipsoidGeometry._subdivisions;\n  const ellipsoid = Ellipsoid.fromCartesian3(radii);\n\n  // Add an extra slice and stack to remain consistent with EllipsoidGeometry\n  let slicePartitions = ellipsoidGeometry._slicePartitions + 1;\n  let stackPartitions = ellipsoidGeometry._stackPartitions + 1;\n\n  slicePartitions = Math.round(\n    (slicePartitions * Math.abs(maximumClock - minimumClock)) /\n      CesiumMath.TWO_PI,\n  );\n  stackPartitions = Math.round(\n    (stackPartitions * Math.abs(maximumCone - minimumCone)) / CesiumMath.PI,\n  );\n\n  if (slicePartitions < 2) {\n    slicePartitions = 2;\n  }\n  if (stackPartitions < 2) {\n    stackPartitions = 2;\n  }\n\n  let extraIndices = 0;\n  let vertexMultiplier = 1.0;\n  const hasInnerSurface =\n    innerRadii.x !== radii.x ||\n    innerRadii.y !== radii.y ||\n    innerRadii.z !== radii.z;\n  let isTopOpen = false;\n  let isBotOpen = false;\n  if (hasInnerSurface) {\n    vertexMultiplier = 2.0;\n    // Add 2x slicePartitions to connect the top/bottom of the outer to\n    // the top/bottom of the inner\n    if (minimumCone > 0.0) {\n      isTopOpen = true;\n      extraIndices += slicePartitions;\n    }\n    if (maximumCone < Math.PI) {\n      isBotOpen = true;\n      extraIndices += slicePartitions;\n    }\n  }\n\n  const vertexCount =\n    subdivisions * vertexMultiplier * (stackPartitions + slicePartitions);\n  const positions = new Float64Array(vertexCount * 3);\n\n  // Multiply by two because two points define each line segment\n  const numIndices =\n    2 *\n    (vertexCount +\n      extraIndices -\n      (slicePartitions + stackPartitions) * vertexMultiplier);\n  const indices = IndexDatatype.createTypedArray(vertexCount, numIndices);\n\n  let i;\n  let j;\n  let theta;\n  let phi;\n  let index = 0;\n\n  // Calculate sin/cos phi\n  const sinPhi = new Array(stackPartitions);\n  const cosPhi = new Array(stackPartitions);\n  for (i = 0; i < stackPartitions; i++) {\n    phi =\n      minimumCone + (i * (maximumCone - minimumCone)) / (stackPartitions - 1);\n    sinPhi[i] = sin(phi);\n    cosPhi[i] = cos(phi);\n  }\n\n  // Calculate sin/cos theta\n  const sinTheta = new Array(subdivisions);\n  const cosTheta = new Array(subdivisions);\n  for (i = 0; i < subdivisions; i++) {\n    theta =\n      minimumClock + (i * (maximumClock - minimumClock)) / (subdivisions - 1);\n    sinTheta[i] = sin(theta);\n    cosTheta[i] = cos(theta);\n  }\n\n  // Calculate the latitude lines on the outer surface\n  for (i = 0; i < stackPartitions; i++) {\n    for (j = 0; j < subdivisions; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Calculate the latitude lines on the inner surface\n  if (hasInnerSurface) {\n    for (i = 0; i < stackPartitions; i++) {\n      for (j = 0; j < subdivisions; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n      }\n    }\n  }\n\n  // Calculate sin/cos phi\n  sinPhi.length = subdivisions;\n  cosPhi.length = subdivisions;\n  for (i = 0; i < subdivisions; i++) {\n    phi = minimumCone + (i * (maximumCone - minimumCone)) / (subdivisions - 1);\n    sinPhi[i] = sin(phi);\n    cosPhi[i] = cos(phi);\n  }\n\n  // Calculate sin/cos theta for each slice partition\n  sinTheta.length = slicePartitions;\n  cosTheta.length = slicePartitions;\n  for (i = 0; i < slicePartitions; i++) {\n    theta =\n      minimumClock +\n      (i * (maximumClock - minimumClock)) / (slicePartitions - 1);\n    sinTheta[i] = sin(theta);\n    cosTheta[i] = cos(theta);\n  }\n\n  // Calculate the longitude lines on the outer surface\n  for (i = 0; i < subdivisions; i++) {\n    for (j = 0; j < slicePartitions; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Calculate the longitude lines on the inner surface\n  if (hasInnerSurface) {\n    for (i = 0; i < subdivisions; i++) {\n      for (j = 0; j < slicePartitions; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n      }\n    }\n  }\n\n  // Create indices for the latitude lines\n  index = 0;\n  for (i = 0; i < stackPartitions * vertexMultiplier; i++) {\n    const topOffset = i * subdivisions;\n    for (j = 0; j < subdivisions - 1; j++) {\n      indices[index++] = topOffset + j;\n      indices[index++] = topOffset + j + 1;\n    }\n  }\n\n  // Create indices for the outer longitude lines\n  let offset = stackPartitions * subdivisions * vertexMultiplier;\n  for (i = 0; i < slicePartitions; i++) {\n    for (j = 0; j < subdivisions - 1; j++) {\n      indices[index++] = offset + i + j * slicePartitions;\n      indices[index++] = offset + i + (j + 1) * slicePartitions;\n    }\n  }\n\n  // Create indices for the inner longitude lines\n  if (hasInnerSurface) {\n    offset =\n      stackPartitions * subdivisions * vertexMultiplier +\n      slicePartitions * subdivisions;\n    for (i = 0; i < slicePartitions; i++) {\n      for (j = 0; j < subdivisions - 1; j++) {\n        indices[index++] = offset + i + j * slicePartitions;\n        indices[index++] = offset + i + (j + 1) * slicePartitions;\n      }\n    }\n  }\n\n  if (hasInnerSurface) {\n    let outerOffset = stackPartitions * subdivisions * vertexMultiplier;\n    let innerOffset = outerOffset + subdivisions * slicePartitions;\n    if (isTopOpen) {\n      // Draw lines from the top of the inner surface to the top of the outer surface\n      for (i = 0; i < slicePartitions; i++) {\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n      }\n    }\n\n    if (isBotOpen) {\n      // Draw lines from the top of the inner surface to the top of the outer surface\n      outerOffset += subdivisions * slicePartitions - slicePartitions;\n      innerOffset += subdivisions * slicePartitions - slicePartitions;\n      for (i = 0; i < slicePartitions; i++) {\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n      }\n    }\n  }\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  if (defined(ellipsoidGeometry._offsetAttribute)) {\n    const length = positions.length;\n    const offsetValue =\n      ellipsoidGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromEllipsoid(ellipsoid),\n    offsetAttribute: ellipsoidGeometry._offsetAttribute,\n  });\n};\nexport default EllipsoidOutlineGeometry;\n"],"names":["defaultRadii","cos","Math","sin","EllipsoidOutlineGeometry","options","EMPTY_OBJECT","radii","innerRadii","minimumClock","maximumClock","TWO_PI","minimumCone","maximumCone","PI","stackPartitions","round","slicePartitions","subdivisions","offsetAttribute","TOP","_radii","clone","_innerRadii","_minimumClock","_maximumClock","_minimumCone","_maximumCone","_stackPartitions","_slicePartitions","_subdivisions","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchRadii","scratchInnerRadii","scratchOptions","undefined","unpack","result","createGeometry","ellipsoidGeometry","x","y","z","ellipsoid","fromCartesian3","abs","extraIndices","vertexMultiplier","hasInnerSurface","isTopOpen","isBotOpen","vertexCount","positions","Float64Array","numIndices","indices","createTypedArray","i","j","theta","phi","index","sinPhi","Array","cosPhi","sinTheta","cosTheta","length","topOffset","offset","outerOffset","innerOffset","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","offsetValue","NONE","applyOffset","Uint8Array","fill","UNSIGNED_BYTE","primitiveType","LINES","boundingSphere","fromEllipsoid"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 41209, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PlaneGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\n/**\n * Describes geometry representing a plane centered at the origin, with a unit width and length.\n *\n * @alias PlaneGeometry\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @example\n * const planeGeometry = new Cesium.PlaneGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY\n * });\n */\nfunction PlaneGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const vertexFormat = options.vertexFormat ?? VertexFormat.DEFAULT;\n\n  this._vertexFormat = vertexFormat;\n  this._workerName = \"createPlaneGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nPlaneGeometry.packedLength = VertexFormat.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PlaneGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nPlaneGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n\n  return array;\n};\n\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  vertexFormat: scratchVertexFormat,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PlaneGeometry} [result] The object into which to store the result.\n * @returns {PlaneGeometry} The modified result parameter or a new PlaneGeometry instance if one was not provided.\n */\nPlaneGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n\n  if (!defined(result)) {\n    return new PlaneGeometry(scratchOptions);\n  }\n\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n\n  return result;\n};\n\nconst min = new Cartesian3(-0.5, -0.5, 0.0);\nconst max = new Cartesian3(0.5, 0.5, 0.0);\n\n/**\n * Computes the geometric representation of a plane, including its vertices, indices, and a bounding sphere.\n *\n * @param {PlaneGeometry} planeGeometry A description of the plane.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPlaneGeometry.createGeometry = function (planeGeometry) {\n  const vertexFormat = planeGeometry._vertexFormat;\n\n  const attributes = new GeometryAttributes();\n  let indices;\n  let positions;\n\n  if (vertexFormat.position) {\n    // 4 corner points.  Duplicated 3 times each for each incident edge/face.\n    positions = new Float64Array(4 * 3);\n\n    // +z face\n    positions[0] = min.x;\n    positions[1] = min.y;\n    positions[2] = 0.0;\n    positions[3] = max.x;\n    positions[4] = min.y;\n    positions[5] = 0.0;\n    positions[6] = max.x;\n    positions[7] = max.y;\n    positions[8] = 0.0;\n    positions[9] = min.x;\n    positions[10] = max.y;\n    positions[11] = 0.0;\n\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    });\n\n    if (vertexFormat.normal) {\n      const normals = new Float32Array(4 * 3);\n\n      // +z face\n      normals[0] = 0.0;\n      normals[1] = 0.0;\n      normals[2] = 1.0;\n      normals[3] = 0.0;\n      normals[4] = 0.0;\n      normals[5] = 1.0;\n      normals[6] = 0.0;\n      normals[7] = 0.0;\n      normals[8] = 1.0;\n      normals[9] = 0.0;\n      normals[10] = 0.0;\n      normals[11] = 1.0;\n\n      attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n\n    if (vertexFormat.st) {\n      const texCoords = new Float32Array(4 * 2);\n\n      // +z face\n      texCoords[0] = 0.0;\n      texCoords[1] = 0.0;\n      texCoords[2] = 1.0;\n      texCoords[3] = 0.0;\n      texCoords[4] = 1.0;\n      texCoords[5] = 1.0;\n      texCoords[6] = 0.0;\n      texCoords[7] = 1.0;\n\n      attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: texCoords,\n      });\n    }\n\n    if (vertexFormat.tangent) {\n      const tangents = new Float32Array(4 * 3);\n\n      // +z face\n      tangents[0] = 1.0;\n      tangents[1] = 0.0;\n      tangents[2] = 0.0;\n      tangents[3] = 1.0;\n      tangents[4] = 0.0;\n      tangents[5] = 0.0;\n      tangents[6] = 1.0;\n      tangents[7] = 0.0;\n      tangents[8] = 0.0;\n      tangents[9] = 1.0;\n      tangents[10] = 0.0;\n      tangents[11] = 0.0;\n\n      attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n\n    if (vertexFormat.bitangent) {\n      const bitangents = new Float32Array(4 * 3);\n\n      // +z face\n      bitangents[0] = 0.0;\n      bitangents[1] = 1.0;\n      bitangents[2] = 0.0;\n      bitangents[3] = 0.0;\n      bitangents[4] = 1.0;\n      bitangents[5] = 0.0;\n      bitangents[6] = 0.0;\n      bitangents[7] = 1.0;\n      bitangents[8] = 0.0;\n      bitangents[9] = 0.0;\n      bitangents[10] = 1.0;\n      bitangents[11] = 0.0;\n\n      attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n\n    // 2 triangles\n    indices = new Uint16Array(2 * 3);\n\n    // +z face\n    indices[0] = 0;\n    indices[1] = 1;\n    indices[2] = 2;\n    indices[3] = 0;\n    indices[4] = 2;\n    indices[5] = 3;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: new BoundingSphere(Cartesian3.ZERO, Math.sqrt(2.0)),\n  });\n};\nexport default PlaneGeometry;\n"],"names":["PlaneGeometry","options","EMPTY_OBJECT","vertexFormat","DEFAULT","_vertexFormat","_workerName","packedLength","pack","value","array","startingIndex","typeOf","object","defined","scratchVertexFormat","scratchOptions","unpack","result","clone","min","max","createGeometry","planeGeometry","attributes","indices","positions","position","Float64Array","x","y","componentDatatype","DOUBLE","componentsPerAttribute","values","normal","normals","Float32Array","FLOAT","st","texCoords","tangent","tangents","bitangent","bitangents","Uint16Array","primitiveType","TRIANGLES","boundingSphere","ZERO","Math","sqrt"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 41433, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PlaneOutlineGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defined from \"./defined.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\n/**\n * Describes geometry representing the outline of a plane centered at the origin, with a unit width and length.\n *\n * @alias PlaneOutlineGeometry\n * @constructor\n *\n */\nfunction PlaneOutlineGeometry() {\n  this._workerName = \"createPlaneOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nPlaneOutlineGeometry.packedLength = 0;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PlaneOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n *\n * @returns {number[]} The array that was packed into\n */\nPlaneOutlineGeometry.pack = function (value, array) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PlaneOutlineGeometry} [result] The object into which to store the result.\n * @returns {PlaneOutlineGeometry} The modified result parameter or a new PlaneOutlineGeometry instance if one was not provided.\n */\nPlaneOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new PlaneOutlineGeometry();\n  }\n\n  return result;\n};\n\nconst min = new Cartesian3(-0.5, -0.5, 0.0);\nconst max = new Cartesian3(0.5, 0.5, 0.0);\n\n/**\n * Computes the geometric representation of an outline of a plane, including its vertices, indices, and a bounding sphere.\n *\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPlaneOutlineGeometry.createGeometry = function () {\n  const attributes = new GeometryAttributes();\n  const indices = new Uint16Array(4 * 2);\n  const positions = new Float64Array(4 * 3);\n\n  positions[0] = min.x;\n  positions[1] = min.y;\n  positions[2] = min.z;\n  positions[3] = max.x;\n  positions[4] = min.y;\n  positions[5] = min.z;\n  positions[6] = max.x;\n  positions[7] = max.y;\n  positions[8] = min.z;\n  positions[9] = min.x;\n  positions[10] = max.y;\n  positions[11] = min.z;\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n\n  indices[0] = 0;\n  indices[1] = 1;\n  indices[2] = 1;\n  indices[3] = 2;\n  indices[4] = 2;\n  indices[5] = 3;\n  indices[6] = 3;\n  indices[7] = 0;\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: new BoundingSphere(Cartesian3.ZERO, Math.sqrt(2.0)),\n  });\n};\nexport default PlaneOutlineGeometry;\n"],"names":["PlaneOutlineGeometry","_workerName","packedLength","pack","value","array","defined","unpack","startingIndex","result","min","max","createGeometry","attributes","indices","Uint16Array","positions","Float64Array","x","y","z","position","componentDatatype","DOUBLE","componentsPerAttribute","values","primitiveType","LINES","boundingSphere","ZERO","Math","sqrt"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAEA;;;;;;CAMC,GACD,SAASA;IACP,IAAI,CAACC,WAAW,GAAG;AACrB;AAEA;;;CAGC,GACDD,qBAAqBE,YAAY,GAAG;AAEpC;;;;;;;CAOC,GACDF,qBAAqBG,IAAI,GAAG,SAAUC,KAAK,EAAEC,KAAK;IAChD,yCAAyC;IACzC,2KAAK,CAACC,OAAO,CAAC,SAASF;IACvB,2KAAK,CAACE,OAAO,CAAC,SAASD;IACvB,wBAAwB;IAExB,OAAOA;AACT;AAEA;;;;;;;CAOC,GACDL,qBAAqBO,MAAM,GAAG,SAAUF,KAAK,EAAEG,aAAa,EAAEC,MAAM;IAClE,yCAAyC;IACzC,2KAAK,CAACH,OAAO,CAAC,SAASD;IACvB,wBAAwB;IAExB,IAAI,CAAC,IAAA,6KAAO,EAACI,SAAS;QACpB,OAAO,IAAIT;IACb;IAEA,OAAOS;AACT;AAEA,MAAMC,MAAM,IAAI,gLAAU,CAAC,CAAC,KAAK,CAAC,KAAK;AACvC,MAAMC,MAAM,IAAI,gLAAU,CAAC,KAAK,KAAK;AAErC;;;;CAIC,GACDX,qBAAqBY,cAAc,GAAG;IACpC,MAAMC,aAAa,IAAI,wLAAkB;IACzC,MAAMC,UAAU,IAAIC,YAAY,IAAI;IACpC,MAAMC,YAAY,IAAIC,aAAa,IAAI;IAEvCD,SAAS,CAAC,EAAE,GAAGN,IAAIQ,CAAC;IACpBF,SAAS,CAAC,EAAE,GAAGN,IAAIS,CAAC;IACpBH,SAAS,CAAC,EAAE,GAAGN,IAAIU,CAAC;IACpBJ,SAAS,CAAC,EAAE,GAAGL,IAAIO,CAAC;IACpBF,SAAS,CAAC,EAAE,GAAGN,IAAIS,CAAC;IACpBH,SAAS,CAAC,EAAE,GAAGN,IAAIU,CAAC;IACpBJ,SAAS,CAAC,EAAE,GAAGL,IAAIO,CAAC;IACpBF,SAAS,CAAC,EAAE,GAAGL,IAAIQ,CAAC;IACpBH,SAAS,CAAC,EAAE,GAAGN,IAAIU,CAAC;IACpBJ,SAAS,CAAC,EAAE,GAAGN,IAAIQ,CAAC;IACpBF,SAAS,CAAC,GAAG,GAAGL,IAAIQ,CAAC;IACrBH,SAAS,CAAC,GAAG,GAAGN,IAAIU,CAAC;IAErBP,WAAWQ,QAAQ,GAAG,IAAI,uLAAiB,CAAC;QAC1CC,mBAAmB,uLAAiB,CAACC,MAAM;QAC3CC,wBAAwB;QACxBC,QAAQT;IACV;IAEAF,OAAO,CAAC,EAAE,GAAG;IACbA,OAAO,CAAC,EAAE,GAAG;IACbA,OAAO,CAAC,EAAE,GAAG;IACbA,OAAO,CAAC,EAAE,GAAG;IACbA,OAAO,CAAC,EAAE,GAAG;IACbA,OAAO,CAAC,EAAE,GAAG;IACbA,OAAO,CAAC,EAAE,GAAG;IACbA,OAAO,CAAC,EAAE,GAAG;IAEb,OAAO,IAAI,8KAAQ,CAAC;QAClBD,YAAYA;QACZC,SAASA;QACTY,eAAe,mLAAa,CAACC,KAAK;QAClCC,gBAAgB,IAAI,oLAAc,CAAC,gLAAU,CAACC,IAAI,EAAEC,KAAKC,IAAI,CAAC;IAChE;AACF;uCACe/B","ignoreList":[0]}},
    {"offset": {"line": 41545, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/CoplanarPolygonGeometryLibrary.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\n\n/**\n * @private\n */\nconst CoplanarPolygonGeometryLibrary = {};\n\nconst scratchIntersectionPoint = new Cartesian3();\nconst scratchXAxis = new Cartesian3();\nconst scratchYAxis = new Cartesian3();\nconst scratchZAxis = new Cartesian3();\nconst obbScratch = new OrientedBoundingBox();\n\nCoplanarPolygonGeometryLibrary.validOutline = function (positions) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  const orientedBoundingBox = OrientedBoundingBox.fromPoints(\n    positions,\n    obbScratch,\n  );\n  const halfAxes = orientedBoundingBox.halfAxes;\n  const xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n  const yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n  const zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n\n  const xMag = Cartesian3.magnitude(xAxis);\n  const yMag = Cartesian3.magnitude(yAxis);\n  const zMag = Cartesian3.magnitude(zAxis);\n\n  // If all the points are on a line return undefined because we can't draw a polygon\n  return !(\n    (xMag === 0 && (yMag === 0 || zMag === 0)) ||\n    (yMag === 0 && zMag === 0)\n  );\n};\n\n// call after removeDuplicates\nCoplanarPolygonGeometryLibrary.computeProjectTo2DArguments = function (\n  positions,\n  centerResult,\n  planeAxis1Result,\n  planeAxis2Result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  Check.defined(\"centerResult\", centerResult);\n  Check.defined(\"planeAxis1Result\", planeAxis1Result);\n  Check.defined(\"planeAxis2Result\", planeAxis2Result);\n  //>>includeEnd('debug');\n\n  const orientedBoundingBox = OrientedBoundingBox.fromPoints(\n    positions,\n    obbScratch,\n  );\n  const halfAxes = orientedBoundingBox.halfAxes;\n  const xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n  const yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n  const zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n\n  const xMag = Cartesian3.magnitude(xAxis);\n  const yMag = Cartesian3.magnitude(yAxis);\n  const zMag = Cartesian3.magnitude(zAxis);\n  const min = Math.min(xMag, yMag, zMag);\n\n  // If all the points are on a line return undefined because we can't draw a polygon\n  if (\n    (xMag === 0 && (yMag === 0 || zMag === 0)) ||\n    (yMag === 0 && zMag === 0)\n  ) {\n    return false;\n  }\n\n  let planeAxis1;\n  let planeAxis2;\n\n  if (min === yMag || min === zMag) {\n    planeAxis1 = xAxis;\n  }\n  if (min === xMag) {\n    planeAxis1 = yAxis;\n  } else if (min === zMag) {\n    planeAxis2 = yAxis;\n  }\n  if (min === xMag || min === yMag) {\n    planeAxis2 = zAxis;\n  }\n\n  Cartesian3.normalize(planeAxis1, planeAxis1Result);\n  Cartesian3.normalize(planeAxis2, planeAxis2Result);\n  Cartesian3.clone(orientedBoundingBox.center, centerResult);\n  return true;\n};\n\nfunction projectTo2D(position, center, axis1, axis2, result) {\n  const v = Cartesian3.subtract(position, center, scratchIntersectionPoint);\n  const x = Cartesian3.dot(axis1, v);\n  const y = Cartesian3.dot(axis2, v);\n\n  return Cartesian2.fromElements(x, y, result);\n}\n\nCoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction = function (\n  center,\n  axis1,\n  axis2,\n) {\n  return function (positions) {\n    const positionResults = new Array(positions.length);\n    for (let i = 0; i < positions.length; i++) {\n      positionResults[i] = projectTo2D(positions[i], center, axis1, axis2);\n    }\n\n    return positionResults;\n  };\n};\n\nCoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction = function (\n  center,\n  axis1,\n  axis2,\n) {\n  return function (position, result) {\n    return projectTo2D(position, center, axis1, axis2, result);\n  };\n};\nexport default CoplanarPolygonGeometryLibrary;\n"],"names":["CoplanarPolygonGeometryLibrary","scratchIntersectionPoint","scratchXAxis","scratchYAxis","scratchZAxis","obbScratch","validOutline","positions","defined","orientedBoundingBox","fromPoints","halfAxes","xAxis","getColumn","yAxis","zAxis","xMag","magnitude","yMag","zMag","computeProjectTo2DArguments","centerResult","planeAxis1Result","planeAxis2Result","min","Math","planeAxis1","planeAxis2","normalize","clone","center","projectTo2D","position","axis1","axis2","result","v","subtract","x","dot","y","fromElements","createProjectPointsTo2DFunction","positionResults","Array","length","i","createProjectPointTo2DFunction"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 41646, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Queue.js"],"sourcesContent":["/**\n * A queue that can enqueue items at the end, and dequeue items from the front.\n *\n * @alias Queue\n * @constructor\n */\nfunction Queue() {\n  this._array = [];\n  this._offset = 0;\n  this._length = 0;\n}\n\nObject.defineProperties(Queue.prototype, {\n  /**\n   * The length of the queue.\n   *\n   * @memberof Queue.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._length;\n    },\n  },\n});\n\n/**\n * Enqueues the specified item.\n *\n * @param {*} item The item to enqueue.\n */\nQueue.prototype.enqueue = function (item) {\n  this._array.push(item);\n  this._length++;\n};\n\n/**\n * Dequeues an item.  Returns undefined if the queue is empty.\n *\n * @returns {*} The the dequeued item.\n */\nQueue.prototype.dequeue = function () {\n  if (this._length === 0) {\n    return undefined;\n  }\n\n  const array = this._array;\n  let offset = this._offset;\n  const item = array[offset];\n  array[offset] = undefined;\n\n  offset++;\n  if (offset > 10 && offset * 2 > array.length) {\n    //compact array\n    this._array = array.slice(offset);\n    offset = 0;\n  }\n\n  this._offset = offset;\n  this._length--;\n\n  return item;\n};\n\n/**\n * Returns the item at the front of the queue.  Returns undefined if the queue is empty.\n *\n * @returns {*} The item at the front of the queue.\n */\nQueue.prototype.peek = function () {\n  if (this._length === 0) {\n    return undefined;\n  }\n\n  return this._array[this._offset];\n};\n\n/**\n * Check whether this queue contains the specified item.\n *\n * @param {*} item The item to search for.\n */\nQueue.prototype.contains = function (item) {\n  return this._array.indexOf(item) !== -1;\n};\n\n/**\n * Remove all items from the queue.\n */\nQueue.prototype.clear = function () {\n  this._array.length = this._offset = this._length = 0;\n};\n\n/**\n * Sort the items in the queue in-place.\n *\n * @param {Queue.Comparator} compareFunction A function that defines the sort order.\n */\nQueue.prototype.sort = function (compareFunction) {\n  if (this._offset > 0) {\n    //compact array\n    this._array = this._array.slice(this._offset);\n    this._offset = 0;\n  }\n\n  this._array.sort(compareFunction);\n};\n\n/**\n * A function used to compare two items while sorting a queue.\n * @callback Queue.Comparator\n *\n * @param {*} a An item in the array.\n * @param {*} b An item in the array.\n * @returns {number} Returns a negative value if <code>a</code> is less than <code>b</code>,\n *          a positive value if <code>a</code> is greater than <code>b</code>, or\n *          0 if <code>a</code> is equal to <code>b</code>.\n *\n * @example\n * function compareNumbers(a, b) {\n *     return a - b;\n * }\n */\nexport default Queue;\n"],"names":["Queue","_array","_offset","_length","Object","defineProperties","prototype","length","get","enqueue","item","push","dequeue","undefined","array","offset","slice","peek","contains","indexOf","clear","sort","compareFunction"],"mappings":";;;;AAAA;;;;;CAKC,GACD,SAASA;IACP,IAAI,CAACC,MAAM,GAAG,EAAE;IAChB,IAAI,CAACC,OAAO,GAAG;IACf,IAAI,CAACC,OAAO,GAAG;AACjB;AAEAC,OAAOC,gBAAgB,CAACL,MAAMM,SAAS,EAAE;IACvC;;;;;;;GAOC,GACDC,QAAQ;QACNC,KAAK;YACH,OAAO,IAAI,CAACL,OAAO;QACrB;IACF;AACF;AAEA;;;;CAIC,GACDH,MAAMM,SAAS,CAACG,OAAO,GAAG,SAAUC,IAAI;IACtC,IAAI,CAACT,MAAM,CAACU,IAAI,CAACD;IACjB,IAAI,CAACP,OAAO;AACd;AAEA;;;;CAIC,GACDH,MAAMM,SAAS,CAACM,OAAO,GAAG;IACxB,IAAI,IAAI,CAACT,OAAO,KAAK,GAAG;QACtB,OAAOU;IACT;IAEA,MAAMC,QAAQ,IAAI,CAACb,MAAM;IACzB,IAAIc,SAAS,IAAI,CAACb,OAAO;IACzB,MAAMQ,OAAOI,KAAK,CAACC,OAAO;IAC1BD,KAAK,CAACC,OAAO,GAAGF;IAEhBE;IACA,IAAIA,SAAS,MAAMA,SAAS,IAAID,MAAMP,MAAM,EAAE;QAC5C,eAAe;QACf,IAAI,CAACN,MAAM,GAAGa,MAAME,KAAK,CAACD;QAC1BA,SAAS;IACX;IAEA,IAAI,CAACb,OAAO,GAAGa;IACf,IAAI,CAACZ,OAAO;IAEZ,OAAOO;AACT;AAEA;;;;CAIC,GACDV,MAAMM,SAAS,CAACW,IAAI,GAAG;IACrB,IAAI,IAAI,CAACd,OAAO,KAAK,GAAG;QACtB,OAAOU;IACT;IAEA,OAAO,IAAI,CAACZ,MAAM,CAAC,IAAI,CAACC,OAAO,CAAC;AAClC;AAEA;;;;CAIC,GACDF,MAAMM,SAAS,CAACY,QAAQ,GAAG,SAAUR,IAAI;IACvC,OAAO,IAAI,CAACT,MAAM,CAACkB,OAAO,CAACT,UAAU,CAAC;AACxC;AAEA;;CAEC,GACDV,MAAMM,SAAS,CAACc,KAAK,GAAG;IACtB,IAAI,CAACnB,MAAM,CAACM,MAAM,GAAG,IAAI,CAACL,OAAO,GAAG,IAAI,CAACC,OAAO,GAAG;AACrD;AAEA;;;;CAIC,GACDH,MAAMM,SAAS,CAACe,IAAI,GAAG,SAAUC,eAAe;IAC9C,IAAI,IAAI,CAACpB,OAAO,GAAG,GAAG;QACpB,eAAe;QACf,IAAI,CAACD,MAAM,GAAG,IAAI,CAACA,MAAM,CAACe,KAAK,CAAC,IAAI,CAACd,OAAO;QAC5C,IAAI,CAACA,OAAO,GAAG;IACjB;IAEA,IAAI,CAACD,MAAM,CAACoB,IAAI,CAACC;AACnB;uCAiBetB","ignoreList":[0]}},
    {"offset": {"line": 41743, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PolygonGeometryLibrary.js"],"sourcesContent":["import ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Plane from \"./Plane.js\";\nimport PolygonHierarchy from \"./PolygonHierarchy.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Queue from \"./Queue.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\n/**\n * @private\n */\nconst PolygonGeometryLibrary = {};\n\nPolygonGeometryLibrary.computeHierarchyPackedLength = function (\n  polygonHierarchy,\n  CartesianX,\n) {\n  let numComponents = 0;\n  const stack = [polygonHierarchy];\n  while (stack.length > 0) {\n    const hierarchy = stack.pop();\n    if (!defined(hierarchy)) {\n      continue;\n    }\n\n    numComponents += 2;\n\n    const positions = hierarchy.positions;\n    const holes = hierarchy.holes;\n\n    if (defined(positions) && positions.length > 0) {\n      numComponents += positions.length * CartesianX.packedLength;\n    }\n\n    if (defined(holes)) {\n      const length = holes.length;\n      for (let i = 0; i < length; ++i) {\n        stack.push(holes[i]);\n      }\n    }\n  }\n\n  return numComponents;\n};\n\nPolygonGeometryLibrary.packPolygonHierarchy = function (\n  polygonHierarchy,\n  array,\n  startingIndex,\n  CartesianX,\n) {\n  const stack = [polygonHierarchy];\n  while (stack.length > 0) {\n    const hierarchy = stack.pop();\n    if (!defined(hierarchy)) {\n      continue;\n    }\n\n    const positions = hierarchy.positions;\n    const holes = hierarchy.holes;\n\n    array[startingIndex++] = defined(positions) ? positions.length : 0;\n    array[startingIndex++] = defined(holes) ? holes.length : 0;\n\n    if (defined(positions)) {\n      const positionsLength = positions.length;\n      for (\n        let i = 0;\n        i < positionsLength;\n        ++i, startingIndex += CartesianX.packedLength\n      ) {\n        CartesianX.pack(positions[i], array, startingIndex);\n      }\n    }\n\n    if (defined(holes)) {\n      const holesLength = holes.length;\n      for (let j = 0; j < holesLength; ++j) {\n        stack.push(holes[j]);\n      }\n    }\n  }\n\n  return startingIndex;\n};\n\nPolygonGeometryLibrary.unpackPolygonHierarchy = function (\n  array,\n  startingIndex,\n  CartesianX,\n) {\n  const positionsLength = array[startingIndex++];\n  const holesLength = array[startingIndex++];\n\n  const positions = new Array(positionsLength);\n  const holes = holesLength > 0 ? new Array(holesLength) : undefined;\n\n  for (\n    let i = 0;\n    i < positionsLength;\n    ++i, startingIndex += CartesianX.packedLength\n  ) {\n    positions[i] = CartesianX.unpack(array, startingIndex);\n  }\n\n  for (let j = 0; j < holesLength; ++j) {\n    holes[j] = PolygonGeometryLibrary.unpackPolygonHierarchy(\n      array,\n      startingIndex,\n      CartesianX,\n    );\n    startingIndex = holes[j].startingIndex;\n    delete holes[j].startingIndex;\n  }\n\n  return {\n    positions: positions,\n    holes: holes,\n    startingIndex: startingIndex,\n  };\n};\n\nconst distance2DScratch = new Cartesian2();\nfunction getPointAtDistance2D(p0, p1, distance, length) {\n  Cartesian2.subtract(p1, p0, distance2DScratch);\n  Cartesian2.multiplyByScalar(\n    distance2DScratch,\n    distance / length,\n    distance2DScratch,\n  );\n  Cartesian2.add(p0, distance2DScratch, distance2DScratch);\n  return [distance2DScratch.x, distance2DScratch.y];\n}\n\nconst distanceScratch = new Cartesian3();\nfunction getPointAtDistance(p0, p1, distance, length) {\n  Cartesian3.subtract(p1, p0, distanceScratch);\n  Cartesian3.multiplyByScalar(\n    distanceScratch,\n    distance / length,\n    distanceScratch,\n  );\n  Cartesian3.add(p0, distanceScratch, distanceScratch);\n  return [distanceScratch.x, distanceScratch.y, distanceScratch.z];\n}\n\nPolygonGeometryLibrary.subdivideLineCount = function (p0, p1, minDistance) {\n  const distance = Cartesian3.distance(p0, p1);\n  const n = distance / minDistance;\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  return Math.pow(2, countDivide);\n};\n\nconst scratchCartographic0 = new Cartographic();\nconst scratchCartographic1 = new Cartographic();\nconst scratchCartographic2 = new Cartographic();\nconst scratchCartesian0 = new Cartesian3();\nconst scratchRhumbLine = new EllipsoidRhumbLine();\nPolygonGeometryLibrary.subdivideRhumbLineCount = function (\n  ellipsoid,\n  p0,\n  p1,\n  minDistance,\n) {\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  const rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\n  const n = rhumb.surfaceDistance / minDistance;\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  return Math.pow(2, countDivide);\n};\n\n/**\n * Subdivides texture coordinates based on the subdivision of the associated world positions.\n *\n * @param {Cartesian2} t0 First texture coordinate.\n * @param {Cartesian2} t1 Second texture coordinate.\n * @param {Cartesian3} p0 First world position.\n * @param {Cartesian3} p1 Second world position.\n * @param {number} minDistance Minimum distance for a segment.\n * @param {Cartesian2[]} result The subdivided texture coordinates.\n *\n * @private\n */\nPolygonGeometryLibrary.subdivideTexcoordLine = function (\n  t0,\n  t1,\n  p0,\n  p1,\n  minDistance,\n  result,\n) {\n  // Compute the number of subdivisions.\n  const subdivisions = PolygonGeometryLibrary.subdivideLineCount(\n    p0,\n    p1,\n    minDistance,\n  );\n\n  // Compute the distance between each subdivided point.\n  const length2D = Cartesian2.distance(t0, t1);\n  const distanceBetweenCoords = length2D / subdivisions;\n\n  // Resize the result array.\n  const texcoords = result;\n  texcoords.length = subdivisions * 2;\n\n  // Compute texture coordinates using linear interpolation.\n  let index = 0;\n  for (let i = 0; i < subdivisions; i++) {\n    const t = getPointAtDistance2D(t0, t1, i * distanceBetweenCoords, length2D);\n    texcoords[index++] = t[0];\n    texcoords[index++] = t[1];\n  }\n\n  return texcoords;\n};\n\nPolygonGeometryLibrary.subdivideLine = function (p0, p1, minDistance, result) {\n  const numVertices = PolygonGeometryLibrary.subdivideLineCount(\n    p0,\n    p1,\n    minDistance,\n  );\n  const length = Cartesian3.distance(p0, p1);\n  const distanceBetweenVertices = length / numVertices;\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  const positions = result;\n  positions.length = numVertices * 3;\n\n  let index = 0;\n  for (let i = 0; i < numVertices; i++) {\n    const p = getPointAtDistance(p0, p1, i * distanceBetweenVertices, length);\n    positions[index++] = p[0];\n    positions[index++] = p[1];\n    positions[index++] = p[2];\n  }\n\n  return positions;\n};\n\n/**\n * Subdivides texture coordinates based on the subdivision of the associated world positions using a rhumb line.\n *\n * @param {Cartesian2} t0 First texture coordinate.\n * @param {Cartesian2} t1 Second texture coordinate.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @param {Cartesian3} p0 First world position.\n * @param {Cartesian3} p1 Second world position.\n * @param {number} minDistance Minimum distance for a segment.\n * @param {Cartesian2[]} result The subdivided texture coordinates.\n *\n * @private\n */\nPolygonGeometryLibrary.subdivideTexcoordRhumbLine = function (\n  t0,\n  t1,\n  ellipsoid,\n  p0,\n  p1,\n  minDistance,\n  result,\n) {\n  // Compute the surface distance.\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  scratchRhumbLine.setEndPoints(c0, c1);\n  const n = scratchRhumbLine.surfaceDistance / minDistance;\n\n  // Compute the number of subdivisions.\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  const subdivisions = Math.pow(2, countDivide);\n\n  // Compute the distance between each subdivided point.\n  const length2D = Cartesian2.distance(t0, t1);\n  const distanceBetweenCoords = length2D / subdivisions;\n\n  // Resize the result array.\n  const texcoords = result;\n  texcoords.length = subdivisions * 2;\n\n  // Compute texture coordinates using linear interpolation.\n  let index = 0;\n  for (let i = 0; i < subdivisions; i++) {\n    const t = getPointAtDistance2D(t0, t1, i * distanceBetweenCoords, length2D);\n    texcoords[index++] = t[0];\n    texcoords[index++] = t[1];\n  }\n\n  return texcoords;\n};\n\n/**\n * Subdivide the line between 2 points every minDistance length\n * If the points are already closer than minDistance the first will be returned\n *\n * @private\n * @param {Ellipsoid} ellipsoid\n * @param {Cartesian3} p0 start point\n * @param {Cartesian3} p1 end point\n * @param {number} minDistance minimum distance between points in radians\n * @param {number[]} [result] if provided positions will be packed into this array starting at index 0\n * @returns {number[]} Cartesian3 positions packed into an array\n */\nPolygonGeometryLibrary.subdivideRhumbLine = function (\n  ellipsoid,\n  p0,\n  p1,\n  minDistance,\n  result,\n) {\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  const rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  if (rhumb.surfaceDistance <= minDistance) {\n    // no need to try and subdivide a line that's already shorter than the min distance\n    // this also inherently handles duplicated points which would have 0 distance\n    result.length = 3;\n    result[0] = p0.x;\n    result[1] = p0.y;\n    result[2] = p0.z;\n    return result;\n  }\n\n  const n = rhumb.surfaceDistance / minDistance;\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  const numVertices = Math.pow(2, countDivide);\n  const distanceBetweenVertices = rhumb.surfaceDistance / numVertices;\n\n  const positions = result;\n  positions.length = numVertices * 3;\n\n  let index = 0;\n  for (let i = 0; i < numVertices; i++) {\n    const c = rhumb.interpolateUsingSurfaceDistance(\n      i * distanceBetweenVertices,\n      scratchCartographic2,\n    );\n    const p = ellipsoid.cartographicToCartesian(c, scratchCartesian0);\n    positions[index++] = p.x;\n    positions[index++] = p.y;\n    positions[index++] = p.z;\n  }\n\n  return positions;\n};\n\nconst scaleToGeodeticHeightN1 = new Cartesian3();\nconst scaleToGeodeticHeightN2 = new Cartesian3();\nconst scaleToGeodeticHeightP1 = new Cartesian3();\nconst scaleToGeodeticHeightP2 = new Cartesian3();\n\nPolygonGeometryLibrary.scaleToGeodeticHeightExtruded = function (\n  geometry,\n  maxHeight,\n  minHeight,\n  ellipsoid,\n  perPositionHeight,\n) {\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n\n  const n1 = scaleToGeodeticHeightN1;\n  let n2 = scaleToGeodeticHeightN2;\n  const p = scaleToGeodeticHeightP1;\n  let p2 = scaleToGeodeticHeightP2;\n\n  if (\n    defined(geometry) &&\n    defined(geometry.attributes) &&\n    defined(geometry.attributes.position)\n  ) {\n    const positions = geometry.attributes.position.values;\n    const length = positions.length / 2;\n\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.fromArray(positions, i, p);\n\n      ellipsoid.geodeticSurfaceNormal(p, n1);\n      p2 = ellipsoid.scaleToGeodeticSurface(p, p2);\n      n2 = Cartesian3.multiplyByScalar(n1, minHeight, n2);\n      n2 = Cartesian3.add(p2, n2, n2);\n      positions[i + length] = n2.x;\n      positions[i + 1 + length] = n2.y;\n      positions[i + 2 + length] = n2.z;\n\n      if (perPositionHeight) {\n        p2 = Cartesian3.clone(p, p2);\n      }\n      n2 = Cartesian3.multiplyByScalar(n1, maxHeight, n2);\n      n2 = Cartesian3.add(p2, n2, n2);\n      positions[i] = n2.x;\n      positions[i + 1] = n2.y;\n      positions[i + 2] = n2.z;\n    }\n  }\n  return geometry;\n};\n\nPolygonGeometryLibrary.polygonOutlinesFromHierarchy = function (\n  polygonHierarchy,\n  scaleToEllipsoidSurface,\n  ellipsoid,\n) {\n  // create from a polygon hierarchy\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n  const polygons = [];\n  const queue = new Queue();\n  queue.enqueue(polygonHierarchy);\n  let i;\n  let j;\n  let length;\n  while (queue.length !== 0) {\n    const outerNode = queue.dequeue();\n    let outerRing = outerNode.positions;\n    if (scaleToEllipsoidSurface) {\n      length = outerRing.length;\n      for (i = 0; i < length; i++) {\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\n      }\n    }\n    outerRing = arrayRemoveDuplicates(\n      outerRing,\n      Cartesian3.equalsEpsilon,\n      true,\n    );\n    if (outerRing.length < 3) {\n      continue;\n    }\n\n    const numChildren = outerNode.holes ? outerNode.holes.length : 0;\n    // The outer polygon contains inner polygons\n    for (i = 0; i < numChildren; i++) {\n      const hole = outerNode.holes[i];\n      let holePositions = hole.positions;\n      if (scaleToEllipsoidSurface) {\n        length = holePositions.length;\n        for (j = 0; j < length; ++j) {\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\n        }\n      }\n      holePositions = arrayRemoveDuplicates(\n        holePositions,\n        Cartesian3.equalsEpsilon,\n        true,\n      );\n      if (holePositions.length < 3) {\n        continue;\n      }\n      polygons.push(holePositions);\n\n      let numGrandchildren = 0;\n      if (defined(hole.holes)) {\n        numGrandchildren = hole.holes.length;\n      }\n\n      for (j = 0; j < numGrandchildren; j++) {\n        queue.enqueue(hole.holes[j]);\n      }\n    }\n\n    polygons.push(outerRing);\n  }\n\n  return polygons;\n};\n\nconst scratchRhumbIntersection = new Cartographic();\nfunction computeEquatorIntersectionRhumb(start, end, ellipsoid) {\n  const c0 = ellipsoid.cartesianToCartographic(start, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(end, scratchCartographic1);\n\n  if (Math.sign(c0.latitude) === Math.sign(c1.latitude)) {\n    return;\n  }\n\n  scratchRhumbLine.setEndPoints(c0, c1);\n\n  const intersection = scratchRhumbLine.findIntersectionWithLatitude(\n    0,\n    scratchRhumbIntersection,\n  );\n\n  if (!defined(intersection)) {\n    return;\n  }\n\n  let minLongitude = Math.min(c0.longitude, c1.longitude);\n  let maxLongitude = Math.max(c0.longitude, c1.longitude);\n\n  if (Math.abs(maxLongitude - minLongitude) > CesiumMath.PI) {\n    // Crosses IDL, flip min and max\n    const swap = minLongitude;\n    minLongitude = maxLongitude;\n    maxLongitude = swap;\n  }\n\n  if (\n    intersection.longitude < minLongitude ||\n    intersection.longitude > maxLongitude\n  ) {\n    return;\n  }\n\n  return ellipsoid.cartographicToCartesian(intersection);\n}\n\nfunction computeEquatorIntersection(start, end, ellipsoid, arcType) {\n  if (arcType === ArcType.RHUMB) {\n    return computeEquatorIntersectionRhumb(start, end, ellipsoid);\n  }\n\n  const intersection = IntersectionTests.lineSegmentPlane(\n    start,\n    end,\n    Plane.ORIGIN_XY_PLANE,\n  );\n\n  if (!defined(intersection)) {\n    return;\n  }\n\n  return ellipsoid.scaleToGeodeticSurface(intersection, intersection);\n}\n\nconst scratchCartographic = new Cartographic();\nfunction computeEdgesOnPlane(positions, ellipsoid, arcType) {\n  const edgesOnPlane = [];\n  let startPoint,\n    endPoint,\n    type,\n    next,\n    intersection,\n    i = 0;\n  while (i < positions.length) {\n    startPoint = positions[i];\n    endPoint = positions[(i + 1) % positions.length];\n\n    type = CesiumMath.sign(startPoint.z);\n    next = CesiumMath.sign(endPoint.z);\n\n    const getLongitude = (position) => {\n      const cartographic = ellipsoid.cartesianToCartographic(\n        position,\n        scratchCartographic,\n      );\n      return cartographic.longitude;\n    };\n\n    if (type === 0) {\n      // The start position is on the split\n      edgesOnPlane.push({\n        position: i,\n        type: type,\n        visited: false,\n        next: next,\n        theta: getLongitude(startPoint),\n      });\n    } else if (next !== 0) {\n      intersection = computeEquatorIntersection(\n        startPoint,\n        endPoint,\n        ellipsoid,\n        arcType,\n      );\n\n      ++i;\n      if (!defined(intersection)) {\n        // The line segment is entirely above or below\n        continue;\n      }\n\n      // The line segment passed through\n      positions.splice(i, 0, intersection);\n      edgesOnPlane.push({\n        position: i,\n        type: type,\n        visited: false,\n        next: next,\n        theta: getLongitude(intersection),\n      });\n    }\n\n    ++i;\n  }\n\n  return edgesOnPlane;\n}\n\nfunction wirePolygon(\n  polygons,\n  polygonIndex,\n  positions,\n  edgesOnPlane,\n  toDelete,\n  startIndex,\n  abovePlane,\n) {\n  const polygon = [];\n  let i = startIndex;\n  const getMatchingEdge = (i) => (edge) => edge.position === i;\n  const polygonsToWire = [];\n  do {\n    const position = positions[i];\n    polygon.push(position);\n\n    const edgeIndex = edgesOnPlane.findIndex(getMatchingEdge(i));\n    const edge = edgesOnPlane[edgeIndex];\n    if (!defined(edge)) {\n      // The current segment does not intersect\n      ++i;\n      continue;\n    }\n\n    const { visited: hasBeenVisited, type, next } = edge;\n    edge.visited = true;\n\n    if (type === 0) {\n      if (next === 0) {\n        // Special case where we'll need to backtrack along the edge\n        const previousEdge = edgesOnPlane[edgeIndex - (abovePlane ? 1 : -1)];\n        if (previousEdge?.position === i + 1) {\n          previousEdge.visited = true;\n        } else {\n          ++i;\n          continue;\n        }\n      }\n\n      // Special case where 3 polygons meet\n      if (\n        (!hasBeenVisited && abovePlane && next > 0) ||\n        (startIndex === i && !abovePlane && next < 0)\n      ) {\n        ++i;\n        continue;\n      }\n    }\n\n    const followEdge = abovePlane ? type >= 0 : type <= 0;\n    if (!followEdge) {\n      ++i;\n      continue;\n    }\n\n    if (!hasBeenVisited) {\n      // Wire another polygon starting at this position on the other side of the edge\n      polygonsToWire.push(i);\n    }\n\n    // Continue counter-clockwise to the next edge\n    const nextEdgeIndex = edgeIndex + (abovePlane ? 1 : -1);\n    const nextEdge = edgesOnPlane[nextEdgeIndex];\n    if (!defined(nextEdge)) {\n      ++i;\n      continue;\n    }\n\n    i = nextEdge.position;\n  } while (\n    i < positions.length &&\n    i >= 0 &&\n    i !== startIndex &&\n    polygon.length < positions.length\n  );\n\n  polygons.splice(polygonIndex, toDelete, polygon);\n\n  for (const index of polygonsToWire) {\n    polygonIndex = wirePolygon(\n      polygons,\n      ++polygonIndex,\n      positions,\n      edgesOnPlane,\n      0,\n      index,\n      !abovePlane,\n    );\n  }\n\n  return polygonIndex;\n}\n\n/**\n * Splits an array of polygons, defined as a list of Cartesian3 positions in counter-clockwise winding order, along the equator.\n *\n * @param {Array<Cartesian3[]>} outerRings An array of polygons, defined as a list of Cartesian3 positions in counter-clockwise winding order.\n * @param {Ellipsoid} ellipsoid The ellipsoid to be used as a reference.\n * @param {ArcType} arcType The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {Array<Cartesian3[]>} [result] An array of split polygons.\n *\n * @returns {Array<Cartesian3[]>} An array of split polygons.\n */\nPolygonGeometryLibrary.splitPolygonsOnEquator = function (\n  outerRings,\n  ellipsoid,\n  arcType,\n  result,\n) {\n  if (!defined(result)) {\n    result = [];\n  }\n\n  result.splice(0, 0, ...outerRings);\n  result.length = outerRings.length;\n\n  let currentPolygon = 0;\n  while (currentPolygon < result.length) {\n    // Adapted from https://www.sciencedirect.com/science/article/abs/pii/B9780125434577500589#:~:text=If%20the%20plane%20intersects%20the,tree%20and%20polygon%20intersection%20libraries\n    const outerRing = result[currentPolygon];\n    const positions = outerRing.slice();\n\n    if (outerRing.length < 3) {\n      result[currentPolygon] = positions;\n      ++currentPolygon;\n      continue;\n    }\n\n    // Step 1: Get all edges which intersect the split line, splciing any found intersections points into the list of positions\n    const edgesOnPlane = computeEdgesOnPlane(positions, ellipsoid, arcType);\n    // If nothing intersected (no point were added), or there is only a single point on the plane, use the original polygon\n    if (positions.length === outerRing.length || edgesOnPlane.length <= 1) {\n      result[currentPolygon] = positions;\n      ++currentPolygon;\n      continue;\n    }\n\n    // Step 2: Sort the edges along the split line by the distance between their starting points and the starting point of the split line.\n    edgesOnPlane.sort((a, b) => {\n      return a.theta - b.theta;\n    });\n\n    // Step 3: Rewire polygons, splicing each polygon into the array of results\n    const north = positions[0].z >= 0.0;\n    currentPolygon = wirePolygon(\n      result,\n      currentPolygon,\n      positions,\n      edgesOnPlane,\n      1,\n      0,\n      north,\n    );\n  }\n\n  return result;\n};\n\nPolygonGeometryLibrary.polygonsFromHierarchy = function (\n  polygonHierarchy,\n  keepDuplicates,\n  projectPointsTo2D,\n  scaleToEllipsoidSurface,\n  ellipsoid,\n  splitPolygons,\n) {\n  // create from a polygon hierarchy\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n  const hierarchy = [];\n  const polygons = [];\n\n  const queue = new Queue();\n  queue.enqueue(polygonHierarchy);\n\n  let split = defined(splitPolygons);\n\n  while (queue.length !== 0) {\n    const outerNode = queue.dequeue();\n    let outerRing = outerNode.positions;\n    const holes = outerNode.holes;\n\n    let i;\n    let length;\n    if (scaleToEllipsoidSurface) {\n      length = outerRing.length;\n      for (i = 0; i < length; i++) {\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\n      }\n    }\n\n    if (!keepDuplicates) {\n      outerRing = arrayRemoveDuplicates(\n        outerRing,\n        Cartesian3.equalsEpsilon,\n        true,\n      );\n    }\n    if (outerRing.length < 3) {\n      continue;\n    }\n\n    let positions2D = projectPointsTo2D(outerRing);\n    if (!defined(positions2D)) {\n      continue;\n    }\n    const holeIndices = [];\n\n    let originalWindingOrder =\n      PolygonPipeline.computeWindingOrder2D(positions2D);\n    if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n      positions2D.reverse();\n      outerRing = outerRing.slice().reverse();\n    }\n\n    if (split) {\n      split = false;\n      let polygons = [outerRing];\n      polygons = splitPolygons(polygons, polygons);\n\n      if (polygons.length > 1) {\n        for (const positions of polygons) {\n          queue.enqueue(new PolygonHierarchy(positions, holes));\n        }\n\n        continue;\n      }\n    }\n\n    let positions = outerRing.slice();\n    const numChildren = defined(holes) ? holes.length : 0;\n    const polygonHoles = [];\n    let j;\n\n    for (i = 0; i < numChildren; i++) {\n      const hole = holes[i];\n      let holePositions = hole.positions;\n      if (scaleToEllipsoidSurface) {\n        length = holePositions.length;\n        for (j = 0; j < length; ++j) {\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\n        }\n      }\n\n      if (!keepDuplicates) {\n        holePositions = arrayRemoveDuplicates(\n          holePositions,\n          Cartesian3.equalsEpsilon,\n          true,\n        );\n      }\n      if (holePositions.length < 3) {\n        continue;\n      }\n\n      const holePositions2D = projectPointsTo2D(holePositions);\n      if (!defined(holePositions2D)) {\n        continue;\n      }\n\n      originalWindingOrder =\n        PolygonPipeline.computeWindingOrder2D(holePositions2D);\n      if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n        holePositions2D.reverse();\n        holePositions = holePositions.slice().reverse();\n      }\n\n      polygonHoles.push(holePositions);\n      holeIndices.push(positions.length);\n      positions = positions.concat(holePositions);\n      positions2D = positions2D.concat(holePositions2D);\n\n      let numGrandchildren = 0;\n      if (defined(hole.holes)) {\n        numGrandchildren = hole.holes.length;\n      }\n\n      for (j = 0; j < numGrandchildren; j++) {\n        queue.enqueue(hole.holes[j]);\n      }\n    }\n\n    hierarchy.push({\n      outerRing: outerRing,\n      holes: polygonHoles,\n    });\n    polygons.push({\n      positions: positions,\n      positions2D: positions2D,\n      holes: holeIndices,\n    });\n  }\n\n  return {\n    hierarchy: hierarchy,\n    polygons: polygons,\n  };\n};\n\nconst computeBoundingRectangleCartesian2 = new Cartesian2();\nconst computeBoundingRectangleCartesian3 = new Cartesian3();\nconst computeBoundingRectangleQuaternion = new Quaternion();\nconst computeBoundingRectangleMatrix3 = new Matrix3();\nPolygonGeometryLibrary.computeBoundingRectangle = function (\n  planeNormal,\n  projectPointTo2D,\n  positions,\n  angle,\n  result,\n) {\n  const rotation = Quaternion.fromAxisAngle(\n    planeNormal,\n    angle,\n    computeBoundingRectangleQuaternion,\n  );\n  const textureMatrix = Matrix3.fromQuaternion(\n    rotation,\n    computeBoundingRectangleMatrix3,\n  );\n\n  let minX = Number.POSITIVE_INFINITY;\n  let maxX = Number.NEGATIVE_INFINITY;\n  let minY = Number.POSITIVE_INFINITY;\n  let maxY = Number.NEGATIVE_INFINITY;\n\n  const length = positions.length;\n  for (let i = 0; i < length; ++i) {\n    const p = Cartesian3.clone(\n      positions[i],\n      computeBoundingRectangleCartesian3,\n    );\n    Matrix3.multiplyByVector(textureMatrix, p, p);\n    const st = projectPointTo2D(p, computeBoundingRectangleCartesian2);\n\n    if (defined(st)) {\n      minX = Math.min(minX, st.x);\n      maxX = Math.max(maxX, st.x);\n\n      minY = Math.min(minY, st.y);\n      maxY = Math.max(maxY, st.y);\n    }\n  }\n\n  result.x = minX;\n  result.y = minY;\n  result.width = maxX - minX;\n  result.height = maxY - minY;\n  return result;\n};\n\nPolygonGeometryLibrary.createGeometryFromPositions = function (\n  ellipsoid,\n  polygon,\n  textureCoordinates,\n  granularity,\n  perPositionHeight,\n  vertexFormat,\n  arcType,\n) {\n  let indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\n\n  /* If polygon is completely unrenderable, just use the first three vertices */\n  if (indices.length < 3) {\n    indices = [0, 1, 2];\n  }\n\n  const positions = polygon.positions;\n\n  const hasTexcoords = defined(textureCoordinates);\n  const texcoords = hasTexcoords ? textureCoordinates.positions : undefined;\n\n  if (perPositionHeight) {\n    const length = positions.length;\n    const flattenedPositions = new Array(length * 3);\n    let index = 0;\n    for (let i = 0; i < length; i++) {\n      const p = positions[i];\n      flattenedPositions[index++] = p.x;\n      flattenedPositions[index++] = p.y;\n      flattenedPositions[index++] = p.z;\n    }\n\n    const geometryOptions = {\n      attributes: {\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: flattenedPositions,\n        }),\n      },\n      indices: indices,\n      primitiveType: PrimitiveType.TRIANGLES,\n    };\n\n    if (hasTexcoords) {\n      geometryOptions.attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: Cartesian2.packArray(texcoords),\n      });\n    }\n\n    const geometry = new Geometry(geometryOptions);\n\n    if (vertexFormat.normal) {\n      return GeometryPipeline.computeNormal(geometry);\n    }\n\n    return geometry;\n  }\n\n  if (arcType === ArcType.GEODESIC) {\n    return PolygonPipeline.computeSubdivision(\n      ellipsoid,\n      positions,\n      indices,\n      texcoords,\n      granularity,\n    );\n  } else if (arcType === ArcType.RHUMB) {\n    return PolygonPipeline.computeRhumbLineSubdivision(\n      ellipsoid,\n      positions,\n      indices,\n      texcoords,\n      granularity,\n    );\n  }\n};\n\nconst computeWallTexcoordsSubdivided = [];\nconst computeWallIndicesSubdivided = [];\nconst p1Scratch = new Cartesian3();\nconst p2Scratch = new Cartesian3();\n\nPolygonGeometryLibrary.computeWallGeometry = function (\n  positions,\n  textureCoordinates,\n  ellipsoid,\n  granularity,\n  perPositionHeight,\n  arcType,\n) {\n  let edgePositions;\n  let topEdgeLength;\n  let i;\n  let p1;\n  let p2;\n  let t1;\n  let t2;\n  let edgeTexcoords;\n  let topEdgeTexcoordLength;\n\n  let length = positions.length;\n  let index = 0;\n  let textureIndex = 0;\n\n  const hasTexcoords = defined(textureCoordinates);\n  const texcoords = hasTexcoords ? textureCoordinates.positions : undefined;\n\n  if (!perPositionHeight) {\n    const minDistance = CesiumMath.chordLength(\n      granularity,\n      ellipsoid.maximumRadius,\n    );\n\n    let numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n        );\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n        );\n      }\n    }\n\n    topEdgeLength = (numVertices + length) * 3;\n    edgePositions = new Array(topEdgeLength * 2);\n\n    if (hasTexcoords) {\n      topEdgeTexcoordLength = (numVertices + length) * 2;\n      edgeTexcoords = new Array(topEdgeTexcoordLength * 2);\n    }\n\n    for (i = 0; i < length; i++) {\n      p1 = positions[i];\n      p2 = positions[(i + 1) % length];\n\n      let tempPositions;\n      let tempTexcoords;\n\n      if (hasTexcoords) {\n        t1 = texcoords[i];\n        t2 = texcoords[(i + 1) % length];\n      }\n\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\n          p1,\n          p2,\n          minDistance,\n          computeWallIndicesSubdivided,\n        );\n        if (hasTexcoords) {\n          tempTexcoords = PolygonGeometryLibrary.subdivideTexcoordLine(\n            t1,\n            t2,\n            p1,\n            p2,\n            minDistance,\n            computeWallTexcoordsSubdivided,\n          );\n        }\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\n          ellipsoid,\n          p1,\n          p2,\n          minDistance,\n          computeWallIndicesSubdivided,\n        );\n        if (hasTexcoords) {\n          tempTexcoords = PolygonGeometryLibrary.subdivideTexcoordRhumbLine(\n            t1,\n            t2,\n            ellipsoid,\n            p1,\n            p2,\n            minDistance,\n            computeWallTexcoordsSubdivided,\n          );\n        }\n      }\n      const tempPositionsLength = tempPositions.length;\n      for (let j = 0; j < tempPositionsLength; ++j, ++index) {\n        edgePositions[index] = tempPositions[j];\n        edgePositions[index + topEdgeLength] = tempPositions[j];\n      }\n\n      edgePositions[index] = p2.x;\n      edgePositions[index + topEdgeLength] = p2.x;\n      ++index;\n\n      edgePositions[index] = p2.y;\n      edgePositions[index + topEdgeLength] = p2.y;\n      ++index;\n\n      edgePositions[index] = p2.z;\n      edgePositions[index + topEdgeLength] = p2.z;\n      ++index;\n\n      if (hasTexcoords) {\n        const tempTexcoordsLength = tempTexcoords.length;\n        for (let k = 0; k < tempTexcoordsLength; ++k, ++textureIndex) {\n          edgeTexcoords[textureIndex] = tempTexcoords[k];\n          edgeTexcoords[textureIndex + topEdgeTexcoordLength] =\n            tempTexcoords[k];\n        }\n\n        edgeTexcoords[textureIndex] = t2.x;\n        edgeTexcoords[textureIndex + topEdgeTexcoordLength] = t2.x;\n        ++textureIndex;\n\n        edgeTexcoords[textureIndex] = t2.y;\n        edgeTexcoords[textureIndex + topEdgeTexcoordLength] = t2.y;\n        ++textureIndex;\n      }\n    }\n  } else {\n    topEdgeLength = length * 3 * 2;\n    edgePositions = new Array(topEdgeLength * 2);\n\n    if (hasTexcoords) {\n      topEdgeTexcoordLength = length * 2 * 2;\n      edgeTexcoords = new Array(topEdgeTexcoordLength * 2);\n    }\n\n    for (i = 0; i < length; i++) {\n      p1 = positions[i];\n      p2 = positions[(i + 1) % length];\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.x;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.y;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.z;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.x;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.y;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.z;\n      ++index;\n\n      if (hasTexcoords) {\n        t1 = texcoords[i];\n        t2 = texcoords[(i + 1) % length];\n        edgeTexcoords[textureIndex] = edgeTexcoords[\n          textureIndex + topEdgeTexcoordLength\n        ] = t1.x;\n        ++textureIndex;\n        edgeTexcoords[textureIndex] = edgeTexcoords[\n          textureIndex + topEdgeTexcoordLength\n        ] = t1.y;\n        ++textureIndex;\n        edgeTexcoords[textureIndex] = edgeTexcoords[\n          textureIndex + topEdgeTexcoordLength\n        ] = t2.x;\n        ++textureIndex;\n        edgeTexcoords[textureIndex] = edgeTexcoords[\n          textureIndex + topEdgeTexcoordLength\n        ] = t2.y;\n        ++textureIndex;\n      }\n    }\n  }\n\n  length = edgePositions.length;\n  const indices = IndexDatatype.createTypedArray(\n    length / 3,\n    length - positions.length * 6,\n  );\n  let edgeIndex = 0;\n  length /= 6;\n\n  for (i = 0; i < length; i++) {\n    const UL = i;\n    const UR = UL + 1;\n    const LL = UL + length;\n    const LR = LL + 1;\n\n    p1 = Cartesian3.fromArray(edgePositions, UL * 3, p1Scratch);\n    p2 = Cartesian3.fromArray(edgePositions, UR * 3, p2Scratch);\n    if (\n      Cartesian3.equalsEpsilon(\n        p1,\n        p2,\n        CesiumMath.EPSILON10,\n        CesiumMath.EPSILON10,\n      )\n    ) {\n      //skip corner\n      continue;\n    }\n\n    indices[edgeIndex++] = UL;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = LR;\n  }\n\n  const geometryOptions = {\n    attributes: new GeometryAttributes({\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: edgePositions,\n      }),\n    }),\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  };\n\n  if (hasTexcoords) {\n    geometryOptions.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: edgeTexcoords,\n    });\n  }\n\n  const geometry = new Geometry(geometryOptions);\n\n  return geometry;\n};\nexport default PolygonGeometryLibrary;\n"],"names":["PolygonGeometryLibrary","computeHierarchyPackedLength","polygonHierarchy","CartesianX","numComponents","stack","length","hierarchy","pop","positions","holes","packedLength","i","push","packPolygonHierarchy","array","startingIndex","positionsLength","pack","holesLength","j","unpackPolygonHierarchy","Array","undefined","unpack","distance2DScratch","getPointAtDistance2D","p0","p1","distance","subtract","multiplyByScalar","add","x","y","distanceScratch","getPointAtDistance","z","subdivideLineCount","minDistance","n","countDivide","Math","max","ceil","log2","pow","scratchCartographic0","scratchCartographic1","scratchCartographic2","scratchCartesian0","scratchRhumbLine","subdivideRhumbLineCount","ellipsoid","c0","cartesianToCartographic","c1","rhumb","surfaceDistance","subdivideTexcoordLine","t0","t1","result","subdivisions","length2D","distanceBetweenCoords","texcoords","index","t","subdivideLine","numVertices","distanceBetweenVertices","p","subdivideTexcoordRhumbLine","setEndPoints","subdivideRhumbLine","c","interpolateUsingSurfaceDistance","cartographicToCartesian","scaleToGeodeticHeightN1","scaleToGeodeticHeightN2","scaleToGeodeticHeightP1","scaleToGeodeticHeightP2","scaleToGeodeticHeightExtruded","geometry","maxHeight","minHeight","perPositionHeight","default","n1","n2","p2","attributes","position","values","fromArray","geodeticSurfaceNormal","scaleToGeodeticSurface","clone","polygonOutlinesFromHierarchy","scaleToEllipsoidSurface","polygons","queue","enqueue","outerNode","dequeue","outerRing","equalsEpsilon","numChildren","hole","holePositions","numGrandchildren","scratchRhumbIntersection","computeEquatorIntersectionRhumb","start","end","sign","latitude","intersection","findIntersectionWithLatitude","minLongitude","min","longitude","maxLongitude","abs","PI","swap","computeEquatorIntersection","arcType","RHUMB","lineSegmentPlane","ORIGIN_XY_PLANE","scratchCartographic","computeEdgesOnPlane","edgesOnPlane","startPoint","endPoint","type","next","getLongitude","cartographic","visited","theta","splice","wirePolygon","polygonIndex","toDelete","startIndex","abovePlane","polygon","getMatchingEdge","edge","polygonsToWire","edgeIndex","findIndex","hasBeenVisited","previousEdge","followEdge","nextEdgeIndex","nextEdge","splitPolygonsOnEquator","outerRings","currentPolygon","slice","sort","a","b","north","polygonsFromHierarchy","keepDuplicates","projectPointsTo2D","splitPolygons","split","positions2D","holeIndices","originalWindingOrder","computeWindingOrder2D","CLOCKWISE","reverse","polygonHoles","holePositions2D","concat","computeBoundingRectangleCartesian2","computeBoundingRectangleCartesian3","computeBoundingRectangleQuaternion","computeBoundingRectangleMatrix3","computeBoundingRectangle","planeNormal","projectPointTo2D","angle","rotation","fromAxisAngle","textureMatrix","fromQuaternion","minX","Number","POSITIVE_INFINITY","maxX","NEGATIVE_INFINITY","minY","maxY","multiplyByVector","st","width","height","createGeometryFromPositions","textureCoordinates","granularity","vertexFormat","indices","triangulate","hasTexcoords","flattenedPositions","geometryOptions","componentDatatype","DOUBLE","componentsPerAttribute","primitiveType","TRIANGLES","FLOAT","packArray","normal","computeNormal","GEODESIC","computeSubdivision","computeRhumbLineSubdivision","computeWallTexcoordsSubdivided","computeWallIndicesSubdivided","p1Scratch","p2Scratch","computeWallGeometry","edgePositions","topEdgeLength","t2","edgeTexcoords","topEdgeTexcoordLength","textureIndex","chordLength","maximumRadius","tempPositions","tempTexcoords","tempPositionsLength","tempTexcoordsLength","k","createTypedArray","UL","UR","LL","LR","EPSILON10"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 42651, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/CoplanarPolygonGeometry.js"],"sourcesContent":["import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingRectangle from \"./BoundingRectangle.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CoplanarPolygonGeometryLibrary from \"./CoplanarPolygonGeometryLibrary.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst scratchPosition = new Cartesian3();\nconst scratchBR = new BoundingRectangle();\nconst stScratch = new Cartesian2();\nconst textureCoordinatesOrigin = new Cartesian2();\nconst scratchNormal = new Cartesian3();\nconst scratchTangent = new Cartesian3();\nconst scratchBitangent = new Cartesian3();\nconst centerScratch = new Cartesian3();\nconst axis1Scratch = new Cartesian3();\nconst axis2Scratch = new Cartesian3();\nconst quaternionScratch = new Quaternion();\nconst textureMatrixScratch = new Matrix3();\nconst tangentRotationScratch = new Matrix3();\nconst surfaceNormalScratch = new Cartesian3();\n\nfunction createGeometryFromPolygon(\n  polygon,\n  vertexFormat,\n  boundingRectangle,\n  stRotation,\n  hardcodedTextureCoordinates,\n  projectPointTo2D,\n  normal,\n  tangent,\n  bitangent,\n) {\n  const positions = polygon.positions;\n  let indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\n\n  /* If polygon is completely unrenderable, just use the first three vertices */\n  if (indices.length < 3) {\n    indices = [0, 1, 2];\n  }\n\n  const newIndices = IndexDatatype.createTypedArray(\n    positions.length,\n    indices.length,\n  );\n  newIndices.set(indices);\n\n  let textureMatrix = textureMatrixScratch;\n  if (stRotation !== 0.0) {\n    let rotation = Quaternion.fromAxisAngle(\n      normal,\n      stRotation,\n      quaternionScratch,\n    );\n    textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n    if (vertexFormat.tangent || vertexFormat.bitangent) {\n      rotation = Quaternion.fromAxisAngle(\n        normal,\n        -stRotation,\n        quaternionScratch,\n      );\n      const tangentRotation = Matrix3.fromQuaternion(\n        rotation,\n        tangentRotationScratch,\n      );\n\n      tangent = Cartesian3.normalize(\n        Matrix3.multiplyByVector(tangentRotation, tangent, tangent),\n        tangent,\n      );\n      if (vertexFormat.bitangent) {\n        bitangent = Cartesian3.normalize(\n          Cartesian3.cross(normal, tangent, bitangent),\n          bitangent,\n        );\n      }\n    }\n  } else {\n    textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n  }\n\n  const stOrigin = textureCoordinatesOrigin;\n  if (vertexFormat.st) {\n    stOrigin.x = boundingRectangle.x;\n    stOrigin.y = boundingRectangle.y;\n  }\n\n  const length = positions.length;\n  const size = length * 3;\n  const flatPositions = new Float64Array(size);\n  const normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(size)\n    : undefined;\n  const textureCoordinates = vertexFormat.st\n    ? new Float32Array(length * 2)\n    : undefined;\n\n  let positionIndex = 0;\n  let normalIndex = 0;\n  let bitangentIndex = 0;\n  let tangentIndex = 0;\n  let stIndex = 0;\n\n  for (let i = 0; i < length; i++) {\n    const position = positions[i];\n    flatPositions[positionIndex++] = position.x;\n    flatPositions[positionIndex++] = position.y;\n    flatPositions[positionIndex++] = position.z;\n\n    if (vertexFormat.st) {\n      if (\n        defined(hardcodedTextureCoordinates) &&\n        hardcodedTextureCoordinates.positions.length === length\n      ) {\n        textureCoordinates[stIndex++] =\n          hardcodedTextureCoordinates.positions[i].x;\n        textureCoordinates[stIndex++] =\n          hardcodedTextureCoordinates.positions[i].y;\n      } else {\n        const p = Matrix3.multiplyByVector(\n          textureMatrix,\n          position,\n          scratchPosition,\n        );\n        const st = projectPointTo2D(p, stScratch);\n        Cartesian2.subtract(st, stOrigin, st);\n\n        const stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n        const sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n        textureCoordinates[stIndex++] = stx;\n        textureCoordinates[stIndex++] = sty;\n      }\n    }\n\n    if (vertexFormat.normal) {\n      normals[normalIndex++] = normal.x;\n      normals[normalIndex++] = normal.y;\n      normals[normalIndex++] = normal.z;\n    }\n\n    if (vertexFormat.tangent) {\n      tangents[tangentIndex++] = tangent.x;\n      tangents[tangentIndex++] = tangent.y;\n      tangents[tangentIndex++] = tangent.z;\n    }\n\n    if (vertexFormat.bitangent) {\n      bitangents[bitangentIndex++] = bitangent.x;\n      bitangents[bitangentIndex++] = bitangent.y;\n      bitangents[bitangentIndex++] = bitangent.z;\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: flatPositions,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: newIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n}\n\n/**\n * A description of a polygon composed of arbitrary coplanar positions.\n *\n * @alias CoplanarPolygonGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {PolygonHierarchy} [options.textureCoordinates] Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points.\n *\n * @example\n * const polygonGeometry = new Cesium.CoplanarPolygonGeometry({\n *  polygonHierarchy: new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArrayHeights([\n *      -90.0, 30.0, 0.0,\n *      -90.0, 30.0, 300000.0,\n *      -80.0, 30.0, 300000.0,\n *      -80.0, 30.0, 0.0\n *   ]))\n * });\n *\n */\nfunction CoplanarPolygonGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const polygonHierarchy = options.polygonHierarchy;\n  const textureCoordinates = options.textureCoordinates;\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.polygonHierarchy\", polygonHierarchy);\n  //>>includeEnd('debug');\n\n  const vertexFormat = options.vertexFormat ?? VertexFormat.DEFAULT;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._polygonHierarchy = polygonHierarchy;\n  this._stRotation = options.stRotation ?? 0.0;\n  this._ellipsoid = Ellipsoid.clone(options.ellipsoid ?? Ellipsoid.default);\n  this._workerName = \"createCoplanarPolygonGeometry\";\n  this._textureCoordinates = textureCoordinates;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    PolygonGeometryLibrary.computeHierarchyPackedLength(\n      polygonHierarchy,\n      Cartesian3,\n    ) +\n    VertexFormat.packedLength +\n    Ellipsoid.packedLength +\n    (defined(textureCoordinates)\n      ? PolygonGeometryLibrary.computeHierarchyPackedLength(\n          textureCoordinates,\n          Cartesian2,\n        )\n      : 1) +\n    2;\n}\n\n/**\n * A description of a coplanar polygon from an array of positions.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {PolygonHierarchy} [options.textureCoordinates] Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points.\n * @returns {CoplanarPolygonGeometry}\n *\n * @example\n * // create a polygon from points\n * const polygon = Cesium.CoplanarPolygonGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * @see PolygonGeometry#createGeometry\n */\nCoplanarPolygonGeometry.fromPositions = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  const newOptions = {\n    polygonHierarchy: {\n      positions: options.positions,\n    },\n    vertexFormat: options.vertexFormat,\n    stRotation: options.stRotation,\n    ellipsoid: options.ellipsoid,\n    textureCoordinates: options.textureCoordinates,\n  };\n  return new CoplanarPolygonGeometry(newOptions);\n};\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CoplanarPolygonGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCoplanarPolygonGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n    value._polygonHierarchy,\n    array,\n    startingIndex,\n    Cartesian3,\n  );\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._stRotation;\n  if (defined(value._textureCoordinates)) {\n    startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n      value._textureCoordinates,\n      array,\n      startingIndex,\n      Cartesian2,\n    );\n  } else {\n    array[startingIndex++] = -1.0;\n  }\n  array[startingIndex++] = value.packedLength;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  polygonHierarchy: {},\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CoplanarPolygonGeometry} [result] The object into which to store the result.\n * @returns {CoplanarPolygonGeometry} The modified result parameter or a new CoplanarPolygonGeometry instance if one was not provided.\n */\nCoplanarPolygonGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\n    array,\n    startingIndex,\n    Cartesian3,\n  );\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const stRotation = array[startingIndex++];\n  const textureCoordinates =\n    array[startingIndex] === -1.0\n      ? undefined\n      : PolygonGeometryLibrary.unpackPolygonHierarchy(\n          array,\n          startingIndex,\n          Cartesian2,\n        );\n  if (defined(textureCoordinates)) {\n    startingIndex = textureCoordinates.startingIndex;\n    delete textureCoordinates.startingIndex;\n  } else {\n    startingIndex++;\n  }\n  const packedLength = array[startingIndex++];\n\n  if (!defined(result)) {\n    result = new CoplanarPolygonGeometry(scratchOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._stRotation = stRotation;\n  result._textureCoordinates = textureCoordinates;\n  result.packedLength = packedLength;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.\n *\n * @param {CoplanarPolygonGeometry} polygonGeometry A description of the polygon.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCoplanarPolygonGeometry.createGeometry = function (polygonGeometry) {\n  const vertexFormat = polygonGeometry._vertexFormat;\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\n  const stRotation = polygonGeometry._stRotation;\n  const textureCoordinates = polygonGeometry._textureCoordinates;\n  const hasTextureCoordinates = defined(textureCoordinates);\n\n  let outerPositions = polygonHierarchy.positions;\n  outerPositions = arrayRemoveDuplicates(\n    outerPositions,\n    Cartesian3.equalsEpsilon,\n    true,\n  );\n  if (outerPositions.length < 3) {\n    return;\n  }\n\n  let normal = scratchNormal;\n  let tangent = scratchTangent;\n  let bitangent = scratchBitangent;\n  let axis1 = axis1Scratch;\n  const axis2 = axis2Scratch;\n\n  const validGeometry =\n    CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments(\n      outerPositions,\n      centerScratch,\n      axis1,\n      axis2,\n    );\n  if (!validGeometry) {\n    return undefined;\n  }\n\n  normal = Cartesian3.cross(axis1, axis2, normal);\n  normal = Cartesian3.normalize(normal, normal);\n\n  if (\n    !Cartesian3.equalsEpsilon(\n      centerScratch,\n      Cartesian3.ZERO,\n      CesiumMath.EPSILON6,\n    )\n  ) {\n    const surfaceNormal = polygonGeometry._ellipsoid.geodeticSurfaceNormal(\n      centerScratch,\n      surfaceNormalScratch,\n    );\n    if (Cartesian3.dot(normal, surfaceNormal) < 0) {\n      normal = Cartesian3.negate(normal, normal);\n      axis1 = Cartesian3.negate(axis1, axis1);\n    }\n  }\n\n  const projectPoints =\n    CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction(\n      centerScratch,\n      axis1,\n      axis2,\n    );\n  const projectPoint =\n    CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction(\n      centerScratch,\n      axis1,\n      axis2,\n    );\n\n  if (vertexFormat.tangent) {\n    tangent = Cartesian3.clone(axis1, tangent);\n  }\n  if (vertexFormat.bitangent) {\n    bitangent = Cartesian3.clone(axis2, bitangent);\n  }\n\n  const results = PolygonGeometryLibrary.polygonsFromHierarchy(\n    polygonHierarchy,\n    hasTextureCoordinates,\n    projectPoints,\n    false,\n  );\n  const hierarchy = results.hierarchy;\n  const polygons = results.polygons;\n\n  const dummyFunction = function (identity) {\n    return identity;\n  };\n\n  const textureCoordinatePolygons = hasTextureCoordinates\n    ? PolygonGeometryLibrary.polygonsFromHierarchy(\n        textureCoordinates,\n        true,\n        dummyFunction,\n        false,\n      ).polygons\n    : undefined;\n\n  if (hierarchy.length === 0) {\n    return;\n  }\n  outerPositions = hierarchy[0].outerRing;\n\n  const boundingSphere = BoundingSphere.fromPoints(outerPositions);\n  const boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(\n    normal,\n    projectPoint,\n    outerPositions,\n    stRotation,\n    scratchBR,\n  );\n\n  const geometries = [];\n  for (let i = 0; i < polygons.length; i++) {\n    const geometryInstance = new GeometryInstance({\n      geometry: createGeometryFromPolygon(\n        polygons[i],\n        vertexFormat,\n        boundingRectangle,\n        stRotation,\n        hasTextureCoordinates ? textureCoordinatePolygons[i] : undefined,\n        projectPoint,\n        normal,\n        tangent,\n        bitangent,\n      ),\n    });\n\n    geometries.push(geometryInstance);\n  }\n\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\n  geometry.attributes.position.values = new Float64Array(\n    geometry.attributes.position.values,\n  );\n  geometry.indices = IndexDatatype.createTypedArray(\n    geometry.attributes.position.values.length / 3,\n    geometry.indices,\n  );\n\n  const attributes = geometry.attributes;\n  if (!vertexFormat.position) {\n    delete attributes.position;\n  }\n  return new Geometry({\n    attributes: attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n  });\n};\nexport default CoplanarPolygonGeometry;\n"],"names":["scratchPosition","scratchBR","stScratch","textureCoordinatesOrigin","scratchNormal","scratchTangent","scratchBitangent","centerScratch","axis1Scratch","axis2Scratch","quaternionScratch","textureMatrixScratch","tangentRotationScratch","surfaceNormalScratch","createGeometryFromPolygon","polygon","vertexFormat","boundingRectangle","stRotation","hardcodedTextureCoordinates","projectPointTo2D","normal","tangent","bitangent","positions","indices","triangulate","positions2D","holes","length","newIndices","createTypedArray","set","textureMatrix","rotation","fromAxisAngle","fromQuaternion","tangentRotation","normalize","multiplyByVector","cross","clone","IDENTITY","stOrigin","st","x","y","size","flatPositions","Float64Array","normals","Float32Array","undefined","tangents","bitangents","textureCoordinates","positionIndex","normalIndex","bitangentIndex","tangentIndex","stIndex","i","position","z","p","subtract","stx","clamp","width","sty","height","attributes","componentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","primitiveType","TRIANGLES","CoplanarPolygonGeometry","options","EMPTY_OBJECT","polygonHierarchy","defined","DEFAULT","_vertexFormat","_polygonHierarchy","_stRotation","_ellipsoid","ellipsoid","default","_workerName","_textureCoordinates","packedLength","computeHierarchyPackedLength","fromPositions","newOptions","pack","value","array","startingIndex","typeOf","object","packPolygonHierarchy","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","unpack","result","unpackPolygonHierarchy","createGeometry","polygonGeometry","hasTextureCoordinates","outerPositions","equalsEpsilon","axis1","axis2","validGeometry","computeProjectTo2DArguments","ZERO","EPSILON6","surfaceNormal","geodeticSurfaceNormal","dot","negate","projectPoints","createProjectPointsTo2DFunction","projectPoint","createProjectPointTo2DFunction","results","polygonsFromHierarchy","hierarchy","polygons","dummyFunction","identity","textureCoordinatePolygons","outerRing","boundingSphere","fromPoints","computeBoundingRectangle","geometries","geometryInstance","geometry","push","combineInstances"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,MAAMA,kBAAkB,IAAI,gLAAU;AACtC,MAAMC,YAAY,IAAI,uLAAiB;AACvC,MAAMC,YAAY,IAAI,gLAAU;AAChC,MAAMC,2BAA2B,IAAI,gLAAU;AAC/C,MAAMC,gBAAgB,IAAI,gLAAU;AACpC,MAAMC,iBAAiB,IAAI,gLAAU;AACrC,MAAMC,mBAAmB,IAAI,gLAAU;AACvC,MAAMC,gBAAgB,IAAI,gLAAU;AACpC,MAAMC,eAAe,IAAI,gLAAU;AACnC,MAAMC,eAAe,IAAI,gLAAU;AACnC,MAAMC,oBAAoB,IAAI,gLAAU;AACxC,MAAMC,uBAAuB,IAAI,6KAAO;AACxC,MAAMC,yBAAyB,IAAI,6KAAO;AAC1C,MAAMC,uBAAuB,IAAI,gLAAU;AAE3C,SAASC,0BACPC,OAAO,EACPC,YAAY,EACZC,iBAAiB,EACjBC,UAAU,EACVC,2BAA2B,EAC3BC,gBAAgB,EAChBC,MAAM,EACNC,OAAO,EACPC,SAAS;IAET,MAAMC,YAAYT,QAAQS,SAAS;IACnC,IAAIC,UAAU,qLAAe,CAACC,WAAW,CAACX,QAAQY,WAAW,EAAEZ,QAAQa,KAAK;IAE5E,4EAA4E,GAC5E,IAAIH,QAAQI,MAAM,GAAG,GAAG;QACtBJ,UAAU;YAAC;YAAG;YAAG;SAAE;IACrB;IAEA,MAAMK,aAAa,mLAAa,CAACC,gBAAgB,CAC/CP,UAAUK,MAAM,EAChBJ,QAAQI,MAAM;IAEhBC,WAAWE,GAAG,CAACP;IAEf,IAAIQ,gBAAgBtB;IACpB,IAAIO,eAAe,KAAK;QACtB,IAAIgB,WAAW,gLAAU,CAACC,aAAa,CACrCd,QACAH,YACAR;QAEFuB,gBAAgB,6KAAO,CAACG,cAAc,CAACF,UAAUD;QAEjD,IAAIjB,aAAaM,OAAO,IAAIN,aAAaO,SAAS,EAAE;YAClDW,WAAW,gLAAU,CAACC,aAAa,CACjCd,QACA,CAACH,YACDR;YAEF,MAAM2B,kBAAkB,6KAAO,CAACD,cAAc,CAC5CF,UACAtB;YAGFU,UAAU,gLAAU,CAACgB,SAAS,CAC5B,6KAAO,CAACC,gBAAgB,CAACF,iBAAiBf,SAASA,UACnDA;YAEF,IAAIN,aAAaO,SAAS,EAAE;gBAC1BA,YAAY,gLAAU,CAACe,SAAS,CAC9B,gLAAU,CAACE,KAAK,CAACnB,QAAQC,SAASC,YAClCA;YAEJ;QACF;IACF,OAAO;QACLU,gBAAgB,6KAAO,CAACQ,KAAK,CAAC,6KAAO,CAACC,QAAQ,EAAET;IAClD;IAEA,MAAMU,WAAWxC;IACjB,IAAIa,aAAa4B,EAAE,EAAE;QACnBD,SAASE,CAAC,GAAG5B,kBAAkB4B,CAAC;QAChCF,SAASG,CAAC,GAAG7B,kBAAkB6B,CAAC;IAClC;IAEA,MAAMjB,SAASL,UAAUK,MAAM;IAC/B,MAAMkB,OAAOlB,SAAS;IACtB,MAAMmB,gBAAgB,IAAIC,aAAaF;IACvC,MAAMG,UAAUlC,aAAaK,MAAM,GAAG,IAAI8B,aAAaJ,QAAQK;IAC/D,MAAMC,WAAWrC,aAAaM,OAAO,GAAG,IAAI6B,aAAaJ,QAAQK;IACjE,MAAME,aAAatC,aAAaO,SAAS,GACrC,IAAI4B,aAAaJ,QACjBK;IACJ,MAAMG,qBAAqBvC,aAAa4B,EAAE,GACtC,IAAIO,aAAatB,SAAS,KAC1BuB;IAEJ,IAAII,gBAAgB;IACpB,IAAIC,cAAc;IAClB,IAAIC,iBAAiB;IACrB,IAAIC,eAAe;IACnB,IAAIC,UAAU;IAEd,IAAK,IAAIC,IAAI,GAAGA,IAAIhC,QAAQgC,IAAK;QAC/B,MAAMC,WAAWtC,SAAS,CAACqC,EAAE;QAC7Bb,aAAa,CAACQ,gBAAgB,GAAGM,SAASjB,CAAC;QAC3CG,aAAa,CAACQ,gBAAgB,GAAGM,SAAShB,CAAC;QAC3CE,aAAa,CAACQ,gBAAgB,GAAGM,SAASC,CAAC;QAE3C,IAAI/C,aAAa4B,EAAE,EAAE;YACnB,IACE,IAAA,6KAAO,EAACzB,gCACRA,4BAA4BK,SAAS,CAACK,MAAM,KAAKA,QACjD;gBACA0B,kBAAkB,CAACK,UAAU,GAC3BzC,4BAA4BK,SAAS,CAACqC,EAAE,CAAChB,CAAC;gBAC5CU,kBAAkB,CAACK,UAAU,GAC3BzC,4BAA4BK,SAAS,CAACqC,EAAE,CAACf,CAAC;YAC9C,OAAO;gBACL,MAAMkB,IAAI,6KAAO,CAACzB,gBAAgB,CAChCN,eACA6B,UACA9D;gBAEF,MAAM4C,KAAKxB,iBAAiB4C,GAAG9D;gBAC/B,gLAAU,CAAC+D,QAAQ,CAACrB,IAAID,UAAUC;gBAElC,MAAMsB,MAAM,0KAAU,CAACC,KAAK,CAACvB,GAAGC,CAAC,GAAG5B,kBAAkBmD,KAAK,EAAE,GAAG;gBAChE,MAAMC,MAAM,0KAAU,CAACF,KAAK,CAACvB,GAAGE,CAAC,GAAG7B,kBAAkBqD,MAAM,EAAE,GAAG;gBACjEf,kBAAkB,CAACK,UAAU,GAAGM;gBAChCX,kBAAkB,CAACK,UAAU,GAAGS;YAClC;QACF;QAEA,IAAIrD,aAAaK,MAAM,EAAE;YACvB6B,OAAO,CAACO,cAAc,GAAGpC,OAAOwB,CAAC;YACjCK,OAAO,CAACO,cAAc,GAAGpC,OAAOyB,CAAC;YACjCI,OAAO,CAACO,cAAc,GAAGpC,OAAO0C,CAAC;QACnC;QAEA,IAAI/C,aAAaM,OAAO,EAAE;YACxB+B,QAAQ,CAACM,eAAe,GAAGrC,QAAQuB,CAAC;YACpCQ,QAAQ,CAACM,eAAe,GAAGrC,QAAQwB,CAAC;YACpCO,QAAQ,CAACM,eAAe,GAAGrC,QAAQyC,CAAC;QACtC;QAEA,IAAI/C,aAAaO,SAAS,EAAE;YAC1B+B,UAAU,CAACI,iBAAiB,GAAGnC,UAAUsB,CAAC;YAC1CS,UAAU,CAACI,iBAAiB,GAAGnC,UAAUuB,CAAC;YAC1CQ,UAAU,CAACI,iBAAiB,GAAGnC,UAAUwC,CAAC;QAC5C;IACF;IAEA,MAAMQ,aAAa,IAAI,wLAAkB;IAEzC,IAAIvD,aAAa8C,QAAQ,EAAE;QACzBS,WAAWT,QAAQ,GAAG,IAAI,uLAAiB,CAAC;YAC1CU,mBAAmB,uLAAiB,CAACC,MAAM;YAC3CC,wBAAwB;YACxBC,QAAQ3B;QACV;IACF;IAEA,IAAIhC,aAAaK,MAAM,EAAE;QACvBkD,WAAWlD,MAAM,GAAG,IAAI,uLAAiB,CAAC;YACxCmD,mBAAmB,uLAAiB,CAACI,KAAK;YAC1CF,wBAAwB;YACxBC,QAAQzB;QACV;IACF;IAEA,IAAIlC,aAAaM,OAAO,EAAE;QACxBiD,WAAWjD,OAAO,GAAG,IAAI,uLAAiB,CAAC;YACzCkD,mBAAmB,uLAAiB,CAACI,KAAK;YAC1CF,wBAAwB;YACxBC,QAAQtB;QACV;IACF;IAEA,IAAIrC,aAAaO,SAAS,EAAE;QAC1BgD,WAAWhD,SAAS,GAAG,IAAI,uLAAiB,CAAC;YAC3CiD,mBAAmB,uLAAiB,CAACI,KAAK;YAC1CF,wBAAwB;YACxBC,QAAQrB;QACV;IACF;IAEA,IAAItC,aAAa4B,EAAE,EAAE;QACnB2B,WAAW3B,EAAE,GAAG,IAAI,uLAAiB,CAAC;YACpC4B,mBAAmB,uLAAiB,CAACI,KAAK;YAC1CF,wBAAwB;YACxBC,QAAQpB;QACV;IACF;IAEA,OAAO,IAAI,8KAAQ,CAAC;QAClBgB,YAAYA;QACZ9C,SAASK;QACT+C,eAAe,mLAAa,CAACC,SAAS;IACxC;AACF;AAEA;;;;;;;;;;;;;;;;;;;;;;;;CAwBC,GACD,SAASC,wBAAwBC,OAAO;IACtCA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IACxC,MAAMC,mBAAmBF,QAAQE,gBAAgB;IACjD,MAAM3B,qBAAqByB,QAAQzB,kBAAkB;IACrD,yCAAyC;IACzC,2KAAK,CAAC4B,OAAO,CAAC,4BAA4BD;IAC1C,wBAAwB;IAExB,MAAMlE,eAAegE,QAAQhE,YAAY,IAAI,kLAAY,CAACoE,OAAO;IACjE,IAAI,CAACC,aAAa,GAAG,kLAAY,CAAC5C,KAAK,CAACzB;IACxC,IAAI,CAACsE,iBAAiB,GAAGJ;IACzB,IAAI,CAACK,WAAW,GAAGP,QAAQ9D,UAAU,IAAI;IACzC,IAAI,CAACsE,UAAU,GAAG,+KAAS,CAAC/C,KAAK,CAACuC,QAAQS,SAAS,IAAI,+KAAS,CAACC,OAAO;IACxE,IAAI,CAACC,WAAW,GAAG;IACnB,IAAI,CAACC,mBAAmB,GAAGrC;IAE3B;;;GAGC,GACD,IAAI,CAACsC,YAAY,GACf,4LAAsB,CAACC,4BAA4B,CACjDZ,kBACA,gLAAU,IAEZ,kLAAY,CAACW,YAAY,GACzB,+KAAS,CAACA,YAAY,GACtB,CAAC,IAAA,6KAAO,EAACtC,sBACL,4LAAsB,CAACuC,4BAA4B,CACjDvC,oBACA,gLAAU,IAEZ,CAAC,IACL;AACJ;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;CAyBC,GACDwB,wBAAwBgB,aAAa,GAAG,SAAUf,OAAO;IACvDA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC,yCAAyC;IACzC,2KAAK,CAACE,OAAO,CAAC,qBAAqBH,QAAQxD,SAAS;IACpD,wBAAwB;IAExB,MAAMwE,aAAa;QACjBd,kBAAkB;YAChB1D,WAAWwD,QAAQxD,SAAS;QAC9B;QACAR,cAAcgE,QAAQhE,YAAY;QAClCE,YAAY8D,QAAQ9D,UAAU;QAC9BuE,WAAWT,QAAQS,SAAS;QAC5BlC,oBAAoByB,QAAQzB,kBAAkB;IAChD;IACA,OAAO,IAAIwB,wBAAwBiB;AACrC;AAEA;;;;;;;;CAQC,GACDjB,wBAAwBkB,IAAI,GAAG,SAAUC,KAAK,EAAEC,KAAK,EAAEC,aAAa;IAClE,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,SAASJ;IAC7B,2KAAK,CAACf,OAAO,CAAC,SAASgB;IACvB,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjCA,gBAAgB,4LAAsB,CAACG,oBAAoB,CACzDL,MAAMZ,iBAAiB,EACvBa,OACAC,eACA,gLAAU;IAGZ,+KAAS,CAACH,IAAI,CAACC,MAAMV,UAAU,EAAEW,OAAOC;IACxCA,iBAAiB,+KAAS,CAACP,YAAY;IAEvC,kLAAY,CAACI,IAAI,CAACC,MAAMb,aAAa,EAAEc,OAAOC;IAC9CA,iBAAiB,kLAAY,CAACP,YAAY;IAE1CM,KAAK,CAACC,gBAAgB,GAAGF,MAAMX,WAAW;IAC1C,IAAI,IAAA,6KAAO,EAACW,MAAMN,mBAAmB,GAAG;QACtCQ,gBAAgB,4LAAsB,CAACG,oBAAoB,CACzDL,MAAMN,mBAAmB,EACzBO,OACAC,eACA,gLAAU;IAEd,OAAO;QACLD,KAAK,CAACC,gBAAgB,GAAG,CAAC;IAC5B;IACAD,KAAK,CAACC,gBAAgB,GAAGF,MAAML,YAAY;IAE3C,OAAOM;AACT;AAEA,MAAMK,mBAAmB,+KAAS,CAAC/D,KAAK,CAAC,+KAAS,CAACgE,WAAW;AAC9D,MAAMC,sBAAsB,IAAI,kLAAY;AAC5C,MAAMC,iBAAiB;IACrBzB,kBAAkB,CAAC;AACrB;AACA;;;;;;;CAOC,GACDH,wBAAwB6B,MAAM,GAAG,SAAUT,KAAK,EAAEC,aAAa,EAAES,MAAM;IACrE,yCAAyC;IACzC,2KAAK,CAAC1B,OAAO,CAAC,SAASgB;IACvB,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjC,MAAMlB,mBAAmB,4LAAsB,CAAC4B,sBAAsB,CACpEX,OACAC,eACA,gLAAU;IAEZA,gBAAgBlB,iBAAiBkB,aAAa;IAC9C,OAAOlB,iBAAiBkB,aAAa;IAErC,MAAMX,YAAY,+KAAS,CAACmB,MAAM,CAACT,OAAOC,eAAeI;IACzDJ,iBAAiB,+KAAS,CAACP,YAAY;IAEvC,MAAM7E,eAAe,kLAAY,CAAC4F,MAAM,CACtCT,OACAC,eACAM;IAEFN,iBAAiB,kLAAY,CAACP,YAAY;IAE1C,MAAM3E,aAAaiF,KAAK,CAACC,gBAAgB;IACzC,MAAM7C,qBACJ4C,KAAK,CAACC,cAAc,KAAK,CAAC,MACtBhD,YACA,4LAAsB,CAAC0D,sBAAsB,CAC3CX,OACAC,eACA,gLAAU;IAElB,IAAI,IAAA,6KAAO,EAAC7C,qBAAqB;QAC/B6C,gBAAgB7C,mBAAmB6C,aAAa;QAChD,OAAO7C,mBAAmB6C,aAAa;IACzC,OAAO;QACLA;IACF;IACA,MAAMP,eAAeM,KAAK,CAACC,gBAAgB;IAE3C,IAAI,CAAC,IAAA,6KAAO,EAACS,SAAS;QACpBA,SAAS,IAAI9B,wBAAwB4B;IACvC;IAEAE,OAAOvB,iBAAiB,GAAGJ;IAC3B2B,OAAOrB,UAAU,GAAG,+KAAS,CAAC/C,KAAK,CAACgD,WAAWoB,OAAOrB,UAAU;IAChEqB,OAAOxB,aAAa,GAAG,kLAAY,CAAC5C,KAAK,CAACzB,cAAc6F,OAAOxB,aAAa;IAC5EwB,OAAOtB,WAAW,GAAGrE;IACrB2F,OAAOjB,mBAAmB,GAAGrC;IAC7BsD,OAAOhB,YAAY,GAAGA;IAEtB,OAAOgB;AACT;AAEA;;;;;CAKC,GACD9B,wBAAwBgC,cAAc,GAAG,SAAUC,eAAe;IAChE,MAAMhG,eAAegG,gBAAgB3B,aAAa;IAClD,MAAMH,mBAAmB8B,gBAAgB1B,iBAAiB;IAC1D,MAAMpE,aAAa8F,gBAAgBzB,WAAW;IAC9C,MAAMhC,qBAAqByD,gBAAgBpB,mBAAmB;IAC9D,MAAMqB,wBAAwB,IAAA,6KAAO,EAAC1D;IAEtC,IAAI2D,iBAAiBhC,iBAAiB1D,SAAS;IAC/C0F,iBAAiB,IAAA,2LAAqB,EACpCA,gBACA,gLAAU,CAACC,aAAa,EACxB;IAEF,IAAID,eAAerF,MAAM,GAAG,GAAG;QAC7B;IACF;IAEA,IAAIR,SAASjB;IACb,IAAIkB,UAAUjB;IACd,IAAIkB,YAAYjB;IAChB,IAAI8G,QAAQ5G;IACZ,MAAM6G,QAAQ5G;IAEd,MAAM6G,gBACJ,oMAA8B,CAACC,2BAA2B,CACxDL,gBACA3G,eACA6G,OACAC;IAEJ,IAAI,CAACC,eAAe;QAClB,OAAOlE;IACT;IAEA/B,SAAS,gLAAU,CAACmB,KAAK,CAAC4E,OAAOC,OAAOhG;IACxCA,SAAS,gLAAU,CAACiB,SAAS,CAACjB,QAAQA;IAEtC,IACE,CAAC,gLAAU,CAAC8F,aAAa,CACvB5G,eACA,gLAAU,CAACiH,IAAI,EACf,0KAAU,CAACC,QAAQ,GAErB;QACA,MAAMC,gBAAgBV,gBAAgBxB,UAAU,CAACmC,qBAAqB,CACpEpH,eACAM;QAEF,IAAI,gLAAU,CAAC+G,GAAG,CAACvG,QAAQqG,iBAAiB,GAAG;YAC7CrG,SAAS,gLAAU,CAACwG,MAAM,CAACxG,QAAQA;YACnC+F,QAAQ,gLAAU,CAACS,MAAM,CAACT,OAAOA;QACnC;IACF;IAEA,MAAMU,gBACJ,oMAA8B,CAACC,+BAA+B,CAC5DxH,eACA6G,OACAC;IAEJ,MAAMW,eACJ,oMAA8B,CAACC,8BAA8B,CAC3D1H,eACA6G,OACAC;IAGJ,IAAIrG,aAAaM,OAAO,EAAE;QACxBA,UAAU,gLAAU,CAACmB,KAAK,CAAC2E,OAAO9F;IACpC;IACA,IAAIN,aAAaO,SAAS,EAAE;QAC1BA,YAAY,gLAAU,CAACkB,KAAK,CAAC4E,OAAO9F;IACtC;IAEA,MAAM2G,UAAU,4LAAsB,CAACC,qBAAqB,CAC1DjD,kBACA+B,uBACAa,eACA;IAEF,MAAMM,YAAYF,QAAQE,SAAS;IACnC,MAAMC,WAAWH,QAAQG,QAAQ;IAEjC,MAAMC,gBAAgB,SAAUC,QAAQ;QACtC,OAAOA;IACT;IAEA,MAAMC,4BAA4BvB,wBAC9B,4LAAsB,CAACkB,qBAAqB,CAC1C5E,oBACA,MACA+E,eACA,OACAD,QAAQ,GACVjF;IAEJ,IAAIgF,UAAUvG,MAAM,KAAK,GAAG;QAC1B;IACF;IACAqF,iBAAiBkB,SAAS,CAAC,EAAE,CAACK,SAAS;IAEvC,MAAMC,iBAAiB,oLAAc,CAACC,UAAU,CAACzB;IACjD,MAAMjG,oBAAoB,4LAAsB,CAAC2H,wBAAwB,CACvEvH,QACA2G,cACAd,gBACAhG,YACAjB;IAGF,MAAM4I,aAAa,EAAE;IACrB,IAAK,IAAIhF,IAAI,GAAGA,IAAIwE,SAASxG,MAAM,EAAEgC,IAAK;QACxC,MAAMiF,mBAAmB,IAAI,sLAAgB,CAAC;YAC5CC,UAAUjI,0BACRuH,QAAQ,CAACxE,EAAE,EACX7C,cACAC,mBACAC,YACA+F,wBAAwBuB,yBAAyB,CAAC3E,EAAE,GAAGT,WACvD4E,cACA3G,QACAC,SACAC;QAEJ;QAEAsH,WAAWG,IAAI,CAACF;IAClB;IAEA,MAAMC,WAAW,sLAAgB,CAACE,gBAAgB,CAACJ,WAAW,CAAC,EAAE;IACjEE,SAASxE,UAAU,CAACT,QAAQ,CAACa,MAAM,GAAG,IAAI1B,aACxC8F,SAASxE,UAAU,CAACT,QAAQ,CAACa,MAAM;IAErCoE,SAAStH,OAAO,GAAG,mLAAa,CAACM,gBAAgB,CAC/CgH,SAASxE,UAAU,CAACT,QAAQ,CAACa,MAAM,CAAC9C,MAAM,GAAG,GAC7CkH,SAAStH,OAAO;IAGlB,MAAM8C,aAAawE,SAASxE,UAAU;IACtC,IAAI,CAACvD,aAAa8C,QAAQ,EAAE;QAC1B,OAAOS,WAAWT,QAAQ;IAC5B;IACA,OAAO,IAAI,8KAAQ,CAAC;QAClBS,YAAYA;QACZ9C,SAASsH,SAAStH,OAAO;QACzBoD,eAAekE,SAASlE,aAAa;QACrC6D,gBAAgBA;IAClB;AACF;uCACe3D","ignoreList":[0]}},
    {"offset": {"line": 43075, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/CoplanarPolygonOutlineGeometry.js"],"sourcesContent":["import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CoplanarPolygonGeometryLibrary from \"./CoplanarPolygonGeometryLibrary.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nfunction createGeometryFromPositions(positions) {\n  const length = positions.length;\n  const flatPositions = new Float64Array(length * 3);\n  const indices = IndexDatatype.createTypedArray(length, length * 2);\n\n  let positionIndex = 0;\n  let index = 0;\n\n  for (let i = 0; i < length; i++) {\n    const position = positions[i];\n    flatPositions[positionIndex++] = position.x;\n    flatPositions[positionIndex++] = position.y;\n    flatPositions[positionIndex++] = position.z;\n\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n  }\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: flatPositions,\n    }),\n  });\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n  });\n}\n\n/**\n * A description of the outline of a polygon composed of arbitrary coplanar positions.\n *\n * @alias CoplanarPolygonOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n *\n * @see CoplanarPolygonOutlineGeometry.createGeometry\n *\n * @example\n * const polygonOutline = new Cesium.CoplanarPolygonOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *      -90.0, 30.0, 0.0,\n *      -90.0, 30.0, 1000.0,\n *      -80.0, 30.0, 1000.0,\n *      -80.0, 30.0, 0.0\n *   ])\n * });\n * const geometry = Cesium.CoplanarPolygonOutlineGeometry.createGeometry(polygonOutline);\n */\nfunction CoplanarPolygonOutlineGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const polygonHierarchy = options.polygonHierarchy;\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.polygonHierarchy\", polygonHierarchy);\n  //>>includeEnd('debug');\n\n  this._polygonHierarchy = polygonHierarchy;\n  this._workerName = \"createCoplanarPolygonOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    PolygonGeometryLibrary.computeHierarchyPackedLength(\n      polygonHierarchy,\n      Cartesian3,\n    ) + 1;\n}\n\n/**\n * A description of a coplanar polygon outline from an array of positions.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @returns {CoplanarPolygonOutlineGeometry}\n */\nCoplanarPolygonOutlineGeometry.fromPositions = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  const newOptions = {\n    polygonHierarchy: {\n      positions: options.positions,\n    },\n  };\n  return new CoplanarPolygonOutlineGeometry(newOptions);\n};\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CoplanarPolygonOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCoplanarPolygonOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n    value._polygonHierarchy,\n    array,\n    startingIndex,\n    Cartesian3,\n  );\n\n  array[startingIndex] = value.packedLength;\n\n  return array;\n};\n\nconst scratchOptions = {\n  polygonHierarchy: {},\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CoplanarPolygonOutlineGeometry} [result] The object into which to store the result.\n * @returns {CoplanarPolygonOutlineGeometry} The modified result parameter or a new CoplanarPolygonOutlineGeometry instance if one was not provided.\n */\nCoplanarPolygonOutlineGeometry.unpack = function (\n  array,\n  startingIndex,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\n    array,\n    startingIndex,\n    Cartesian3,\n  );\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n  const packedLength = array[startingIndex];\n\n  if (!defined(result)) {\n    result = new CoplanarPolygonOutlineGeometry(scratchOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result.packedLength = packedLength;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.\n *\n * @param {CoplanarPolygonOutlineGeometry} polygonGeometry A description of the polygon.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCoplanarPolygonOutlineGeometry.createGeometry = function (polygonGeometry) {\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\n\n  let outerPositions = polygonHierarchy.positions;\n  outerPositions = arrayRemoveDuplicates(\n    outerPositions,\n    Cartesian3.equalsEpsilon,\n    true,\n  );\n  if (outerPositions.length < 3) {\n    return;\n  }\n  const isValid = CoplanarPolygonGeometryLibrary.validOutline(outerPositions);\n  if (!isValid) {\n    return undefined;\n  }\n\n  const polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(\n    polygonHierarchy,\n    false,\n  );\n\n  if (polygons.length === 0) {\n    return undefined;\n  }\n\n  const geometries = [];\n\n  for (let i = 0; i < polygons.length; i++) {\n    const geometryInstance = new GeometryInstance({\n      geometry: createGeometryFromPositions(polygons[i]),\n    });\n    geometries.push(geometryInstance);\n  }\n\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\n  const boundingSphere = BoundingSphere.fromPoints(polygonHierarchy.positions);\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n  });\n};\nexport default CoplanarPolygonOutlineGeometry;\n"],"names":["createGeometryFromPositions","positions","length","flatPositions","Float64Array","indices","createTypedArray","positionIndex","index","i","position","x","y","z","attributes","componentDatatype","DOUBLE","componentsPerAttribute","values","primitiveType","LINES","CoplanarPolygonOutlineGeometry","options","EMPTY_OBJECT","polygonHierarchy","defined","_polygonHierarchy","_workerName","packedLength","computeHierarchyPackedLength","fromPositions","newOptions","pack","value","array","startingIndex","typeOf","object","packPolygonHierarchy","scratchOptions","unpack","result","unpackPolygonHierarchy","createGeometry","polygonGeometry","outerPositions","equalsEpsilon","isValid","validOutline","undefined","polygons","polygonOutlinesFromHierarchy","geometries","geometryInstance","geometry","push","combineInstances","boundingSphere","fromPoints"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 43275, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Stereographic.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Ray from \"./Ray.js\";\n\n/**\n * Represents a point in stereographic coordinates, which can be obtained by projecting a cartesian coordinate from one pole onto a tangent plane at the other pole.\n * The stereographic projection faithfully represents the relative directions of all great circles passing through its center point.\n * To faithfully represents angles everywhere, this is a conformal projection, which means points are projected onto an arbrary sphere.\n * @param {Cartesian2} [position] The steroegraphic coordinates.\n * @param {EllipseGeometry} [tangentPlane] The tangent plane onto which the point was projected.\n */\nfunction Stereographic(position, tangentPlane) {\n  this.position = position;\n  if (!defined(this.position)) {\n    this.position = new Cartesian2();\n  }\n\n  this.tangentPlane = tangentPlane;\n  if (!defined(this.tangentPlane)) {\n    this.tangentPlane = Stereographic.NORTH_POLE_TANGENT_PLANE;\n  }\n}\n\nObject.defineProperties(Stereographic.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof Stereographic.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this.tangentPlane.ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the x coordinate\n   * @memberof Stereographic.prototype\n   * @type {number}\n   */\n  x: {\n    get: function () {\n      return this.position.x;\n    },\n  },\n\n  /**\n   * Gets the y coordinate\n   * @memberof Stereographic.prototype\n   * @type {number}\n   */\n  y: {\n    get: function () {\n      return this.position.y;\n    },\n  },\n\n  /**\n   * Computes the conformal latitude, or the ellipsoidal latitude projected onto an arbitrary sphere.\n   * @memberof Stereographic.prototype\n   * @type {number}\n   */\n  conformalLatitude: {\n    get: function () {\n      const r = Cartesian2.magnitude(this.position);\n      const d = 2 * this.ellipsoid.maximumRadius;\n      const sign = this.tangentPlane.plane.normal.z;\n      return sign * (CesiumMath.PI_OVER_TWO - 2 * Math.atan2(r, d));\n    },\n  },\n\n  /**\n   * Computes the longitude\n   * @memberof Stereographic.prototype\n   * @type {number}\n   */\n  longitude: {\n    get: function () {\n      let longitude = CesiumMath.PI_OVER_TWO + Math.atan2(this.y, this.x);\n      if (longitude > Math.PI) {\n        longitude -= CesiumMath.TWO_PI;\n      }\n\n      return longitude;\n    },\n  },\n});\n\nconst scratchCartographic = new Cartographic();\nconst scratchCartesian = new Cartesian3();\n\n/**\n * Computes the latitude based on an ellipsoid.\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which to compute the longitude.\n * @returns {number} The latitude\n */\nStereographic.prototype.getLatitude = function (ellipsoid) {\n  if (!defined(ellipsoid)) {\n    ellipsoid = Ellipsoid.default;\n  }\n\n  scratchCartographic.latitude = this.conformalLatitude;\n  scratchCartographic.longitude = this.longitude;\n  scratchCartographic.height = 0.0;\n  const cartesian = this.ellipsoid.cartographicToCartesian(\n    scratchCartographic,\n    scratchCartesian,\n  );\n  ellipsoid.cartesianToCartographic(cartesian, scratchCartographic);\n  return scratchCartographic.latitude;\n};\n\nconst scratchProjectPointOntoPlaneRay = new Ray();\nconst scratchProjectPointOntoPlaneRayDirection = new Cartesian3();\nconst scratchProjectPointOntoPlaneCartesian3 = new Cartesian3();\n\n/**\n * Computes the projection of the provided 3D position onto the 2D polar plane, radially outward from the provided origin.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Stereographic} [result] The object onto which to store the result.\n * @returns {Sterographic} The modified result parameter or a new Sterographic instance if none was provided.\n */\nStereographic.fromCartesian = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  const sign = CesiumMath.signNotZero(cartesian.z);\n  let tangentPlane = Stereographic.NORTH_POLE_TANGENT_PLANE;\n  let origin = Stereographic.SOUTH_POLE;\n  if (sign < 0) {\n    tangentPlane = Stereographic.SOUTH_POLE_TANGENT_PLANE;\n    origin = Stereographic.NORTH_POLE;\n  }\n\n  const ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = tangentPlane.ellipsoid.scaleToGeocentricSurface(\n    cartesian,\n    ray.origin,\n  );\n  ray.direction = Cartesian3.subtract(\n    ray.origin,\n    origin,\n    scratchProjectPointOntoPlaneRayDirection,\n  );\n  Cartesian3.normalize(ray.direction, ray.direction);\n\n  const intersectionPoint = IntersectionTests.rayPlane(\n    ray,\n    tangentPlane.plane,\n    scratchProjectPointOntoPlaneCartesian3,\n  );\n  const v = Cartesian3.subtract(intersectionPoint, origin, intersectionPoint);\n  const x = Cartesian3.dot(tangentPlane.xAxis, v);\n  const y = sign * Cartesian3.dot(tangentPlane.yAxis, v);\n\n  if (!defined(result)) {\n    return new Stereographic(new Cartesian2(x, y), tangentPlane);\n  }\n\n  result.position = new Cartesian2(x, y);\n  result.tangentPlane = tangentPlane;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D polar plane, radially outward from the provided origin.\n *\n * @param {Cartesian3[]} cartesians The points to project.\n * @param {Stereographic[]} [result] The object onto which to store the result.\n * @returns {Sterographic[]} The modified result parameter or a new Sterographic instance if none was provided.\n */\nStereographic.fromCartesianArray = function (cartesians, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  const length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (let i = 0; i < length; i++) {\n    result[i] = Stereographic.fromCartesian(cartesians[i], result[i]);\n  }\n  return result;\n};\n\n/**\n * Duplicates a Stereographic instance.\n *\n * @param {Stereographic} stereographic The Stereographic to duplicate.\n * @param {Stereographic} [result] The object onto which to store the result.\n * @returns {Stereographic} The modified result parameter or a new Stereographic instance if one was not provided. (Returns undefined if stereographic is undefined)\n */\nStereographic.clone = function (stereographic, result) {\n  if (!defined(stereographic)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Stereographic(\n      stereographic.position,\n      stereographic.tangentPlane,\n    );\n  }\n\n  result.position = stereographic.position;\n  result.tangentPlane = stereographic.tangentPlane;\n\n  return result;\n};\n\n/**\n * An Ellipsoid instance initialized to radii of (0.5, 0.5, 0.5).\n *\n * @type {Stereographic}\n * @constant\n */\nStereographic.HALF_UNIT_SPHERE = Object.freeze(new Ellipsoid(0.5, 0.5, 0.5));\n\nStereographic.NORTH_POLE = Object.freeze(new Cartesian3(0.0, 0.0, 0.5));\nStereographic.SOUTH_POLE = Object.freeze(new Cartesian3(0.0, 0.0, -0.5));\n\nStereographic.NORTH_POLE_TANGENT_PLANE = Object.freeze(\n  new EllipsoidTangentPlane(\n    Stereographic.NORTH_POLE,\n    Stereographic.HALF_UNIT_SPHERE,\n  ),\n);\nStereographic.SOUTH_POLE_TANGENT_PLANE = Object.freeze(\n  new EllipsoidTangentPlane(\n    Stereographic.SOUTH_POLE,\n    Stereographic.HALF_UNIT_SPHERE,\n  ),\n);\n\nexport default Stereographic;\n"],"names":["Stereographic","position","tangentPlane","NORTH_POLE_TANGENT_PLANE","Object","defineProperties","prototype","ellipsoid","get","x","y","conformalLatitude","r","magnitude","d","maximumRadius","sign","plane","normal","z","PI_OVER_TWO","Math","atan2","longitude","PI","TWO_PI","scratchCartographic","scratchCartesian","getLatitude","default","latitude","height","cartesian","cartographicToCartesian","cartesianToCartographic","scratchProjectPointOntoPlaneRay","scratchProjectPointOntoPlaneRayDirection","scratchProjectPointOntoPlaneCartesian3","fromCartesian","result","defined","signNotZero","origin","SOUTH_POLE","SOUTH_POLE_TANGENT_PLANE","NORTH_POLE","ray","scaleToGeocentricSurface","direction","subtract","normalize","intersectionPoint","rayPlane","v","dot","xAxis","yAxis","fromCartesianArray","cartesians","length","Array","i","clone","stereographic","undefined","HALF_UNIT_SPHERE","freeze"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 43475, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PolygonGeometry.js"],"sourcesContent":["import ArcType from \"./ArcType.js\";\nimport BoundingRectangle from \"./BoundingRectangle.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Stereographic from \"./Stereographic.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\nconst scratchCarto1 = new Cartographic();\nconst scratchCarto2 = new Cartographic();\nfunction adjustPosHeightsForNormal(position, p1, p2, ellipsoid) {\n  const carto1 = ellipsoid.cartesianToCartographic(position, scratchCarto1);\n  const height = carto1.height;\n  const p1Carto = ellipsoid.cartesianToCartographic(p1, scratchCarto2);\n  p1Carto.height = height;\n  ellipsoid.cartographicToCartesian(p1Carto, p1);\n\n  const p2Carto = ellipsoid.cartesianToCartographic(p2, scratchCarto2);\n  p2Carto.height = height - 100;\n  ellipsoid.cartographicToCartesian(p2Carto, p2);\n}\n\nconst scratchBoundingRectangle = new BoundingRectangle();\nconst scratchPosition = new Cartesian3();\nconst scratchNormal = new Cartesian3();\nconst scratchTangent = new Cartesian3();\nconst scratchBitangent = new Cartesian3();\nconst p1Scratch = new Cartesian3();\nconst p2Scratch = new Cartesian3();\nlet scratchPerPosNormal = new Cartesian3();\nlet scratchPerPosTangent = new Cartesian3();\nlet scratchPerPosBitangent = new Cartesian3();\n\nconst appendTextureCoordinatesOrigin = new Cartesian2();\nconst appendTextureCoordinatesCartesian2 = new Cartesian2();\nconst appendTextureCoordinatesCartesian3 = new Cartesian3();\nconst appendTextureCoordinatesQuaternion = new Quaternion();\nconst appendTextureCoordinatesMatrix3 = new Matrix3();\nconst tangentMatrixScratch = new Matrix3();\n\nfunction computeAttributes(options) {\n  const vertexFormat = options.vertexFormat;\n  const geometry = options.geometry;\n  const shadowVolume = options.shadowVolume;\n  const flatPositions = geometry.attributes.position.values;\n  const flatTexcoords = defined(geometry.attributes.st)\n    ? geometry.attributes.st.values\n    : undefined;\n\n  let length = flatPositions.length;\n  const wall = options.wall;\n  const top = options.top || wall;\n  const bottom = options.bottom || wall;\n  if (\n    vertexFormat.st ||\n    vertexFormat.normal ||\n    vertexFormat.tangent ||\n    vertexFormat.bitangent ||\n    shadowVolume\n  ) {\n    // PERFORMANCE_IDEA: Compute before subdivision, then just interpolate during subdivision.\n    // PERFORMANCE_IDEA: Compute with createGeometryFromPositions() for fast path when there's no holes.\n    const boundingRectangle = options.boundingRectangle;\n    const rotationAxis = options.rotationAxis;\n    const projectTo2d = options.projectTo2d;\n    const ellipsoid = options.ellipsoid;\n    const stRotation = options.stRotation;\n    const perPositionHeight = options.perPositionHeight;\n\n    const origin = appendTextureCoordinatesOrigin;\n    origin.x = boundingRectangle.x;\n    origin.y = boundingRectangle.y;\n\n    const textureCoordinates = vertexFormat.st\n      ? new Float32Array(2 * (length / 3))\n      : undefined;\n    let normals;\n    if (vertexFormat.normal) {\n      if (perPositionHeight && top && !wall) {\n        normals = geometry.attributes.normal.values;\n      } else {\n        normals = new Float32Array(length);\n      }\n    }\n    const tangents = vertexFormat.tangent\n      ? new Float32Array(length)\n      : undefined;\n    const bitangents = vertexFormat.bitangent\n      ? new Float32Array(length)\n      : undefined;\n    const extrudeNormals = shadowVolume ? new Float32Array(length) : undefined;\n\n    let textureCoordIndex = 0;\n    let attrIndex = 0;\n\n    let normal = scratchNormal;\n    let tangent = scratchTangent;\n    let bitangent = scratchBitangent;\n    let recomputeNormal = true;\n\n    let textureMatrix = appendTextureCoordinatesMatrix3;\n    let tangentRotationMatrix = tangentMatrixScratch;\n    if (stRotation !== 0.0) {\n      let rotation = Quaternion.fromAxisAngle(\n        rotationAxis,\n        stRotation,\n        appendTextureCoordinatesQuaternion,\n      );\n      textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n      rotation = Quaternion.fromAxisAngle(\n        rotationAxis,\n        -stRotation,\n        appendTextureCoordinatesQuaternion,\n      );\n      tangentRotationMatrix = Matrix3.fromQuaternion(\n        rotation,\n        tangentRotationMatrix,\n      );\n    } else {\n      textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n      tangentRotationMatrix = Matrix3.clone(\n        Matrix3.IDENTITY,\n        tangentRotationMatrix,\n      );\n    }\n\n    let bottomOffset = 0;\n    let bottomOffset2 = 0;\n\n    if (top && bottom) {\n      bottomOffset = length / 2;\n      bottomOffset2 = length / 3;\n\n      length /= 2;\n    }\n\n    for (let i = 0; i < length; i += 3) {\n      const position = Cartesian3.fromArray(\n        flatPositions,\n        i,\n        appendTextureCoordinatesCartesian3,\n      );\n\n      if (vertexFormat.st) {\n        if (!defined(flatTexcoords)) {\n          let p = Matrix3.multiplyByVector(\n            textureMatrix,\n            position,\n            scratchPosition,\n          );\n          p = ellipsoid.scaleToGeodeticSurface(p, p);\n          const st = projectTo2d([p], appendTextureCoordinatesCartesian2)[0];\n          Cartesian2.subtract(st, origin, st);\n\n          const stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n          const sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n          if (bottom) {\n            textureCoordinates[textureCoordIndex + bottomOffset2] = stx;\n            textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = sty;\n          }\n          if (top) {\n            textureCoordinates[textureCoordIndex] = stx;\n            textureCoordinates[textureCoordIndex + 1] = sty;\n          }\n\n          textureCoordIndex += 2;\n        }\n      }\n\n      if (\n        vertexFormat.normal ||\n        vertexFormat.tangent ||\n        vertexFormat.bitangent ||\n        shadowVolume\n      ) {\n        const attrIndex1 = attrIndex + 1;\n        const attrIndex2 = attrIndex + 2;\n\n        if (wall) {\n          if (i + 3 < length) {\n            const p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);\n\n            if (recomputeNormal) {\n              const p2 = Cartesian3.fromArray(\n                flatPositions,\n                i + length,\n                p2Scratch,\n              );\n              if (perPositionHeight) {\n                adjustPosHeightsForNormal(position, p1, p2, ellipsoid);\n              }\n              Cartesian3.subtract(p1, position, p1);\n              Cartesian3.subtract(p2, position, p2);\n              normal = Cartesian3.normalize(\n                Cartesian3.cross(p2, p1, normal),\n                normal,\n              );\n              recomputeNormal = false;\n            }\n\n            if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) {\n              // if we've reached a corner\n              recomputeNormal = true;\n            }\n          }\n\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\n            bitangent = ellipsoid.geodeticSurfaceNormal(position, bitangent);\n            if (vertexFormat.tangent) {\n              tangent = Cartesian3.normalize(\n                Cartesian3.cross(bitangent, normal, tangent),\n                tangent,\n              );\n            }\n          }\n        } else {\n          normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\n            if (perPositionHeight) {\n              scratchPerPosNormal = Cartesian3.fromArray(\n                normals,\n                attrIndex,\n                scratchPerPosNormal,\n              );\n              scratchPerPosTangent = Cartesian3.cross(\n                Cartesian3.UNIT_Z,\n                scratchPerPosNormal,\n                scratchPerPosTangent,\n              );\n              scratchPerPosTangent = Cartesian3.normalize(\n                Matrix3.multiplyByVector(\n                  tangentRotationMatrix,\n                  scratchPerPosTangent,\n                  scratchPerPosTangent,\n                ),\n                scratchPerPosTangent,\n              );\n              if (vertexFormat.bitangent) {\n                scratchPerPosBitangent = Cartesian3.normalize(\n                  Cartesian3.cross(\n                    scratchPerPosNormal,\n                    scratchPerPosTangent,\n                    scratchPerPosBitangent,\n                  ),\n                  scratchPerPosBitangent,\n                );\n              }\n            }\n\n            tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n            tangent = Cartesian3.normalize(\n              Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent),\n              tangent,\n            );\n            if (vertexFormat.bitangent) {\n              bitangent = Cartesian3.normalize(\n                Cartesian3.cross(normal, tangent, bitangent),\n                bitangent,\n              );\n            }\n          }\n        }\n\n        if (vertexFormat.normal) {\n          if (options.wall) {\n            normals[attrIndex + bottomOffset] = normal.x;\n            normals[attrIndex1 + bottomOffset] = normal.y;\n            normals[attrIndex2 + bottomOffset] = normal.z;\n          } else if (bottom) {\n            normals[attrIndex + bottomOffset] = -normal.x;\n            normals[attrIndex1 + bottomOffset] = -normal.y;\n            normals[attrIndex2 + bottomOffset] = -normal.z;\n          }\n\n          if ((top && !perPositionHeight) || wall) {\n            normals[attrIndex] = normal.x;\n            normals[attrIndex1] = normal.y;\n            normals[attrIndex2] = normal.z;\n          }\n        }\n\n        if (shadowVolume) {\n          if (wall) {\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n          }\n          extrudeNormals[attrIndex + bottomOffset] = -normal.x;\n          extrudeNormals[attrIndex1 + bottomOffset] = -normal.y;\n          extrudeNormals[attrIndex2 + bottomOffset] = -normal.z;\n        }\n\n        if (vertexFormat.tangent) {\n          if (options.wall) {\n            tangents[attrIndex + bottomOffset] = tangent.x;\n            tangents[attrIndex1 + bottomOffset] = tangent.y;\n            tangents[attrIndex2 + bottomOffset] = tangent.z;\n          } else if (bottom) {\n            tangents[attrIndex + bottomOffset] = -tangent.x;\n            tangents[attrIndex1 + bottomOffset] = -tangent.y;\n            tangents[attrIndex2 + bottomOffset] = -tangent.z;\n          }\n\n          if (top) {\n            if (perPositionHeight) {\n              tangents[attrIndex] = scratchPerPosTangent.x;\n              tangents[attrIndex1] = scratchPerPosTangent.y;\n              tangents[attrIndex2] = scratchPerPosTangent.z;\n            } else {\n              tangents[attrIndex] = tangent.x;\n              tangents[attrIndex1] = tangent.y;\n              tangents[attrIndex2] = tangent.z;\n            }\n          }\n        }\n\n        if (vertexFormat.bitangent) {\n          if (bottom) {\n            bitangents[attrIndex + bottomOffset] = bitangent.x;\n            bitangents[attrIndex1 + bottomOffset] = bitangent.y;\n            bitangents[attrIndex2 + bottomOffset] = bitangent.z;\n          }\n          if (top) {\n            if (perPositionHeight) {\n              bitangents[attrIndex] = scratchPerPosBitangent.x;\n              bitangents[attrIndex1] = scratchPerPosBitangent.y;\n              bitangents[attrIndex2] = scratchPerPosBitangent.z;\n            } else {\n              bitangents[attrIndex] = bitangent.x;\n              bitangents[attrIndex1] = bitangent.y;\n              bitangents[attrIndex2] = bitangent.z;\n            }\n          }\n        }\n        attrIndex += 3;\n      }\n    }\n\n    if (vertexFormat.st && !defined(flatTexcoords)) {\n      geometry.attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: textureCoordinates,\n      });\n    }\n\n    if (vertexFormat.normal) {\n      geometry.attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n\n    if (vertexFormat.tangent) {\n      geometry.attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n\n    if (vertexFormat.bitangent) {\n      geometry.attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n\n    if (shadowVolume) {\n      geometry.attributes.extrudeDirection = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: extrudeNormals,\n      });\n    }\n  }\n\n  if (options.extrude && defined(options.offsetAttribute)) {\n    const size = flatPositions.length / 3;\n    let offsetAttribute = new Uint8Array(size);\n\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      if ((top && bottom) || wall) {\n        offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n      } else if (top) {\n        offsetAttribute = offsetAttribute.fill(1);\n      }\n    } else {\n      const offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = offsetAttribute.fill(offsetValue);\n    }\n\n    geometry.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  return geometry;\n}\n\nconst createGeometryFromPositionsExtrudedPositions = [];\n\nfunction createGeometryFromPositionsExtruded(\n  ellipsoid,\n  polygon,\n  textureCoordinates,\n  granularity,\n  hierarchy,\n  perPositionHeight,\n  closeTop,\n  closeBottom,\n  vertexFormat,\n  arcType,\n) {\n  const geos = {\n    walls: [],\n  };\n  let i;\n\n  if (closeTop || closeBottom) {\n    const topGeo = PolygonGeometryLibrary.createGeometryFromPositions(\n      ellipsoid,\n      polygon,\n      textureCoordinates,\n      granularity,\n      perPositionHeight,\n      vertexFormat,\n      arcType,\n    );\n\n    const edgePoints = topGeo.attributes.position.values;\n    const indices = topGeo.indices;\n    let numPositions;\n    let newIndices;\n\n    if (closeTop && closeBottom) {\n      const topBottomPositions = edgePoints.concat(edgePoints);\n\n      numPositions = topBottomPositions.length / 3;\n\n      newIndices = IndexDatatype.createTypedArray(\n        numPositions,\n        indices.length * 2,\n      );\n      newIndices.set(indices);\n      const ilength = indices.length;\n\n      const length = numPositions / 2;\n\n      for (i = 0; i < ilength; i += 3) {\n        const i0 = newIndices[i] + length;\n        const i1 = newIndices[i + 1] + length;\n        const i2 = newIndices[i + 2] + length;\n\n        newIndices[i + ilength] = i2;\n        newIndices[i + 1 + ilength] = i1;\n        newIndices[i + 2 + ilength] = i0;\n      }\n\n      topGeo.attributes.position.values = topBottomPositions;\n      if (perPositionHeight && vertexFormat.normal) {\n        const normals = topGeo.attributes.normal.values;\n        topGeo.attributes.normal.values = new Float32Array(\n          topBottomPositions.length,\n        );\n        topGeo.attributes.normal.values.set(normals);\n      }\n\n      if (vertexFormat.st && defined(textureCoordinates)) {\n        const texcoords = topGeo.attributes.st.values;\n        topGeo.attributes.st.values = new Float32Array(numPositions * 2);\n        topGeo.attributes.st.values = texcoords.concat(texcoords);\n      }\n\n      topGeo.indices = newIndices;\n    } else if (closeBottom) {\n      numPositions = edgePoints.length / 3;\n      newIndices = IndexDatatype.createTypedArray(numPositions, indices.length);\n\n      for (i = 0; i < indices.length; i += 3) {\n        newIndices[i] = indices[i + 2];\n        newIndices[i + 1] = indices[i + 1];\n        newIndices[i + 2] = indices[i];\n      }\n\n      topGeo.indices = newIndices;\n    }\n\n    geos.topAndBottom = new GeometryInstance({\n      geometry: topGeo,\n    });\n  }\n\n  let outerRing = hierarchy.outerRing;\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\n  let positions2D = tangentPlane.projectPointsOntoPlane(\n    outerRing,\n    createGeometryFromPositionsExtrudedPositions,\n  );\n\n  let windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n  if (windingOrder === WindingOrder.CLOCKWISE) {\n    outerRing = outerRing.slice().reverse();\n  }\n\n  let wallGeo = PolygonGeometryLibrary.computeWallGeometry(\n    outerRing,\n    textureCoordinates,\n    ellipsoid,\n    granularity,\n    perPositionHeight,\n    arcType,\n  );\n  geos.walls.push(\n    new GeometryInstance({\n      geometry: wallGeo,\n    }),\n  );\n\n  const holes = hierarchy.holes;\n  for (i = 0; i < holes.length; i++) {\n    let hole = holes[i];\n    positions2D = tangentPlane.projectPointsOntoPlane(\n      hole,\n      createGeometryFromPositionsExtrudedPositions,\n    );\n\n    windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n    if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {\n      hole = hole.slice().reverse();\n    }\n\n    wallGeo = PolygonGeometryLibrary.computeWallGeometry(\n      hole,\n      textureCoordinates,\n      ellipsoid,\n      granularity,\n      perPositionHeight,\n      arcType,\n    );\n    geos.walls.push(\n      new GeometryInstance({\n        geometry: wallGeo,\n      }),\n    );\n  }\n\n  return geos;\n}\n\n/**\n * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias PolygonGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n * @param {number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n * @param {boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {PolygonHierarchy} [options.textureCoordinates] Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.\n *\n * @see PolygonGeometry#createGeometry\n * @see PolygonGeometry#fromPositions\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}\n *\n * @example\n * // 1. create a polygon from points\n * const polygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes\n * const polygonWithHole = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon\n * const extrudedPolygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);\n */\nfunction PolygonGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n  if (\n    defined(options.perPositionHeight) &&\n    options.perPositionHeight &&\n    defined(options.height)\n  ) {\n    throw new DeveloperError(\n      \"Cannot use both options.perPositionHeight and options.height\",\n    );\n  }\n  if (\n    defined(options.arcType) &&\n    options.arcType !== ArcType.GEODESIC &&\n    options.arcType !== ArcType.RHUMB\n  ) {\n    throw new DeveloperError(\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const polygonHierarchy = options.polygonHierarchy;\n  const vertexFormat = options.vertexFormat ?? VertexFormat.DEFAULT;\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  const granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  const stRotation = options.stRotation ?? 0.0;\n  const textureCoordinates = options.textureCoordinates;\n  const perPositionHeight = options.perPositionHeight ?? false;\n  const perPositionHeightExtrude =\n    perPositionHeight && defined(options.extrudedHeight);\n  let height = options.height ?? 0.0;\n  let extrudedHeight = options.extrudedHeight ?? height;\n\n  if (!perPositionHeightExtrude) {\n    const h = Math.max(height, extrudedHeight);\n    extrudedHeight = Math.min(height, extrudedHeight);\n    height = h;\n  }\n\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._granularity = granularity;\n  this._stRotation = stRotation;\n  this._height = height;\n  this._extrudedHeight = extrudedHeight;\n  this._closeTop = options.closeTop ?? true;\n  this._closeBottom = options.closeBottom ?? true;\n  this._polygonHierarchy = polygonHierarchy;\n  this._perPositionHeight = perPositionHeight;\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\n  this._shadowVolume = options.shadowVolume ?? false;\n  this._workerName = \"createPolygonGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._arcType = options.arcType ?? ArcType.GEODESIC;\n\n  this._rectangle = undefined;\n  this._textureCoordinateRotationPoints = undefined;\n  this._textureCoordinates = textureCoordinates;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    PolygonGeometryLibrary.computeHierarchyPackedLength(\n      polygonHierarchy,\n      Cartesian3,\n    ) +\n    Ellipsoid.packedLength +\n    VertexFormat.packedLength +\n    (textureCoordinates\n      ? PolygonGeometryLibrary.computeHierarchyPackedLength(\n          textureCoordinates,\n          Cartesian2,\n        )\n      : 1) +\n    12;\n}\n\n/**\n * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {number} [options.height=0.0] The height of the polygon.\n * @param {number} [options.extrudedHeight] The height of the polygon extrusion.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n * @param {boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {PolygonHierarchy} [options.textureCoordinates] Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.\n * @returns {PolygonGeometry}\n *\n * @example\n * // create a polygon from points\n * const polygon = Cesium.PolygonGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * @see PolygonGeometry#createGeometry\n */\nPolygonGeometry.fromPositions = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  const newOptions = {\n    polygonHierarchy: {\n      positions: options.positions,\n    },\n    height: options.height,\n    extrudedHeight: options.extrudedHeight,\n    vertexFormat: options.vertexFormat,\n    stRotation: options.stRotation,\n    ellipsoid: options.ellipsoid,\n    granularity: options.granularity,\n    perPositionHeight: options.perPositionHeight,\n    closeTop: options.closeTop,\n    closeBottom: options.closeBottom,\n    offsetAttribute: options.offsetAttribute,\n    arcType: options.arcType,\n    textureCoordinates: options.textureCoordinates,\n  };\n  return new PolygonGeometry(newOptions);\n};\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nPolygonGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n    value._polygonHierarchy,\n    array,\n    startingIndex,\n    Cartesian3,\n  );\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n  array[startingIndex++] = value._closeTop ? 1.0 : 0.0;\n  array[startingIndex++] = value._closeBottom ? 1.0 : 0.0;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex++] = value._offsetAttribute ?? -1;\n  array[startingIndex++] = value._arcType;\n  if (defined(value._textureCoordinates)) {\n    startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n      value._textureCoordinates,\n      array,\n      startingIndex,\n      Cartesian2,\n    );\n  } else {\n    array[startingIndex++] = -1.0;\n  }\n  array[startingIndex++] = value.packedLength;\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\n\n//Only used to avoid inability to default construct.\nconst dummyOptions = {\n  polygonHierarchy: {},\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonGeometry} [result] The object into which to store the result.\n * @returns {PolygonGeometry} The modified result parameter or a new PolygonGeometry instance if one was not provided.\n */\nPolygonGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\n    array,\n    startingIndex,\n    Cartesian3,\n  );\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const stRotation = array[startingIndex++];\n  const perPositionHeightExtrude = array[startingIndex++] === 1.0;\n  const perPositionHeight = array[startingIndex++] === 1.0;\n  const closeTop = array[startingIndex++] === 1.0;\n  const closeBottom = array[startingIndex++] === 1.0;\n  const shadowVolume = array[startingIndex++] === 1.0;\n  const offsetAttribute = array[startingIndex++];\n  const arcType = array[startingIndex++];\n  const textureCoordinates =\n    array[startingIndex] === -1.0\n      ? undefined\n      : PolygonGeometryLibrary.unpackPolygonHierarchy(\n          array,\n          startingIndex,\n          Cartesian2,\n        );\n  if (defined(textureCoordinates)) {\n    startingIndex = textureCoordinates.startingIndex;\n    delete textureCoordinates.startingIndex;\n  } else {\n    startingIndex++;\n  }\n  const packedLength = array[startingIndex++];\n\n  if (!defined(result)) {\n    result = new PolygonGeometry(dummyOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._granularity = granularity;\n  result._stRotation = stRotation;\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\n  result._perPositionHeight = perPositionHeight;\n  result._closeTop = closeTop;\n  result._closeBottom = closeBottom;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n  result._arcType = arcType;\n  result._textureCoordinates = textureCoordinates;\n  result.packedLength = packedLength;\n\n  return result;\n};\n\nconst scratchCartesian0 = new Cartesian2();\nconst scratchCartesian1 = new Cartesian2();\nconst scratchPolarClosest = new Stereographic();\nfunction expandRectangle(\n  polar,\n  lastPolar,\n  ellipsoid,\n  arcType,\n  polygon,\n  result,\n) {\n  const longitude = polar.longitude;\n  const lonAdjusted =\n    longitude >= 0.0 ? longitude : longitude + CesiumMath.TWO_PI;\n  polygon.westOverIdl = Math.min(polygon.westOverIdl, lonAdjusted);\n  polygon.eastOverIdl = Math.max(polygon.eastOverIdl, lonAdjusted);\n\n  result.west = Math.min(result.west, longitude);\n  result.east = Math.max(result.east, longitude);\n\n  const latitude = polar.getLatitude(ellipsoid);\n  let segmentLatitude = latitude;\n\n  result.south = Math.min(result.south, latitude);\n  result.north = Math.max(result.north, latitude);\n\n  if (arcType !== ArcType.RHUMB) {\n    // Geodesics will need to find the closest point on line. Rhumb lines will not have a latitude greater in magnitude than either of their endpoints.\n    const segment = Cartesian2.subtract(\n      lastPolar.position,\n      polar.position,\n      scratchCartesian0,\n    );\n    const t =\n      Cartesian2.dot(lastPolar.position, segment) /\n      Cartesian2.dot(segment, segment);\n    if (t > 0.0 && t < 1.0) {\n      const projected = Cartesian2.add(\n        lastPolar.position,\n        Cartesian2.multiplyByScalar(segment, -t, segment),\n        scratchCartesian1,\n      );\n      const closestPolar = Stereographic.clone(lastPolar, scratchPolarClosest);\n      closestPolar.position = projected;\n      const adjustedLatitude = closestPolar.getLatitude(ellipsoid);\n      result.south = Math.min(result.south, adjustedLatitude);\n      result.north = Math.max(result.north, adjustedLatitude);\n\n      if (Math.abs(latitude) > Math.abs(adjustedLatitude)) {\n        segmentLatitude = adjustedLatitude;\n      }\n    }\n  }\n  const direction = lastPolar.x * polar.y - polar.x * lastPolar.y;\n\n  // The total internal angle in either hemisphere determines if the pole is inside or outside the polygon\n  let angle = Math.sign(direction);\n  if (angle !== 0.0) {\n    angle *= Cartesian2.angleBetween(lastPolar.position, polar.position);\n  }\n\n  if (segmentLatitude >= 0.0) {\n    polygon.northAngle += angle;\n  }\n\n  if (segmentLatitude <= 0.0) {\n    polygon.southAngle += angle;\n  }\n}\n\nconst scratchPolar = new Stereographic();\nconst scratchPolarPrevious = new Stereographic();\nconst polygon = {\n  northAngle: 0.0,\n  southAngle: 0.0,\n  westOverIdl: 0.0,\n  eastOverIdl: 0.0,\n};\n\n/**\n * Computes a rectangle which encloses the polygon defined by the list of positions, including cases over the international date line and the poles.\n *\n * @param {Cartesian3[]} positions A linear ring defining the outer boundary of the polygon.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {ArcType} [arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle\n */\nPolygonGeometry.computeRectangleFromPositions = function (\n  positions,\n  ellipsoid,\n  arcType,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  if (positions.length < 3) {\n    return result;\n  }\n\n  result.west = Number.POSITIVE_INFINITY;\n  result.east = Number.NEGATIVE_INFINITY;\n  result.south = Number.POSITIVE_INFINITY;\n  result.north = Number.NEGATIVE_INFINITY;\n\n  polygon.northAngle = 0.0;\n  polygon.southAngle = 0.0;\n  polygon.westOverIdl = Number.POSITIVE_INFINITY;\n  polygon.eastOverIdl = Number.NEGATIVE_INFINITY;\n\n  const positionsLength = positions.length;\n  let lastPolarPosition = Stereographic.fromCartesian(\n    positions[0],\n    scratchPolarPrevious,\n  );\n  for (let i = 1; i < positionsLength; i++) {\n    const polarPosition = Stereographic.fromCartesian(\n      positions[i],\n      scratchPolar,\n    );\n    expandRectangle(\n      polarPosition,\n      lastPolarPosition,\n      ellipsoid,\n      arcType,\n      polygon,\n      result,\n    );\n\n    lastPolarPosition = Stereographic.clone(polarPosition, lastPolarPosition);\n  }\n\n  expandRectangle(\n    Stereographic.fromCartesian(positions[0], scratchPolar),\n    lastPolarPosition,\n    ellipsoid,\n    arcType,\n    polygon,\n    result,\n  );\n\n  if (result.east - result.west > polygon.eastOverIdl - polygon.westOverIdl) {\n    result.west = polygon.westOverIdl;\n    result.east = polygon.eastOverIdl;\n\n    if (result.east > CesiumMath.PI) {\n      result.east = result.east - CesiumMath.TWO_PI;\n    }\n    if (result.west > CesiumMath.PI) {\n      result.west = result.west - CesiumMath.TWO_PI;\n    }\n  }\n\n  // If either pole is inside the polygon, adjust the rectangle so the pole is included\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(polygon.northAngle),\n      CesiumMath.TWO_PI,\n      CesiumMath.EPSILON10,\n    )\n  ) {\n    result.north = CesiumMath.PI_OVER_TWO;\n    result.east = CesiumMath.PI;\n    result.west = -CesiumMath.PI;\n  }\n\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(polygon.southAngle),\n      CesiumMath.TWO_PI,\n      CesiumMath.EPSILON10,\n    )\n  ) {\n    result.south = -CesiumMath.PI_OVER_TWO;\n    result.east = CesiumMath.PI;\n    result.west = -CesiumMath.PI;\n  }\n\n  return result;\n};\n\nconst scratchPolarForPlane = new Stereographic();\nfunction getTangentPlane(rectangle, positions, ellipsoid) {\n  if (rectangle.height >= CesiumMath.PI || rectangle.width >= CesiumMath.PI) {\n    const polar = Stereographic.fromCartesian(\n      positions[0],\n      scratchPolarForPlane,\n    );\n    return polar.tangentPlane;\n  }\n\n  // Use a local tangent plane for smaller extents\n  return EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n}\n\nconst scratchCartographicCyllindrical = new Cartographic();\nfunction createProjectTo2d(rectangle, outerPositions, ellipsoid) {\n  return (positions, results) => {\n    // If the polygon positions span a large enough extent, use a specialized projection\n    if (rectangle.height >= CesiumMath.PI || rectangle.width >= CesiumMath.PI) {\n      // polygons that cross the equator must use cyllindrical coordinates to correctly compute winding order.\n      if (rectangle.south < 0 && rectangle.north > 0) {\n        if (!defined(results)) {\n          results = [];\n        }\n\n        for (let i = 0; i < positions.length; ++i) {\n          const cartographic = ellipsoid.cartesianToCartographic(\n            positions[i],\n            scratchCartographicCyllindrical,\n          );\n          results[i] = new Cartesian2(\n            cartographic.longitude / CesiumMath.PI,\n            cartographic.latitude / CesiumMath.PI_OVER_TWO,\n          );\n        }\n\n        results.length = positions.length;\n        return results;\n      }\n\n      return Stereographic.fromCartesianArray(positions, results);\n    }\n\n    // Use a local tangent plane for smaller extents\n    const tangentPlane = EllipsoidTangentPlane.fromPoints(\n      outerPositions,\n      ellipsoid,\n    );\n    return tangentPlane.projectPointsOntoPlane(positions, results);\n  };\n}\n\nfunction createProjectPositionTo2d(rectangle, outerRing, ellipsoid) {\n  // If the polygon positions span a large enough extent, use a specialized projection\n  if (rectangle.height >= CesiumMath.PI || rectangle.width >= CesiumMath.PI) {\n    return (position, result) => {\n      // polygons that cross the equator must use cyllindrical coordinates to correctly compute winding order.\n      if (rectangle.south < 0 && rectangle.north > 0) {\n        const cartographic = ellipsoid.cartesianToCartographic(\n          position,\n          scratchCartographicCyllindrical,\n        );\n        if (!defined(result)) {\n          result = new Cartesian2();\n        }\n        result.x = cartographic.longitude / CesiumMath.PI;\n        result.y = cartographic.latitude / CesiumMath.PI_OVER_TWO;\n\n        return result;\n      }\n\n      return Stereographic.fromCartesian(position, result);\n    };\n  }\n\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\n  return (position, result) => {\n    // Use a local tangent plane for smaller extents\n    return tangentPlane.projectPointsOntoPlane(position, result);\n  };\n}\n\nfunction createSplitPolygons(rectangle, ellipsoid, arcType, perPositionHeight) {\n  return (polygons, results) => {\n    if (\n      !perPositionHeight &&\n      (rectangle.height >= CesiumMath.PI_OVER_TWO ||\n        rectangle.width >= 2 * CesiumMath.PI_OVER_THREE)\n    ) {\n      return PolygonGeometryLibrary.splitPolygonsOnEquator(\n        polygons,\n        ellipsoid,\n        arcType,\n        results,\n      );\n    }\n\n    return polygons;\n  };\n}\n\nfunction computeBoundingRectangle(outerRing, rectangle, ellipsoid, stRotation) {\n  if (rectangle.height >= CesiumMath.PI || rectangle.width >= CesiumMath.PI) {\n    return BoundingRectangle.fromRectangle(\n      rectangle,\n      undefined,\n      scratchBoundingRectangle,\n    );\n  }\n\n  const outerPositions = outerRing;\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(\n    outerPositions,\n    ellipsoid,\n  );\n  return PolygonGeometryLibrary.computeBoundingRectangle(\n    tangentPlane.plane.normal,\n    tangentPlane.projectPointOntoPlane.bind(tangentPlane),\n    outerPositions,\n    stRotation,\n    scratchBoundingRectangle,\n  );\n}\n\n/**\n * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolygonGeometry} polygonGeometry A description of the polygon.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolygonGeometry.createGeometry = function (polygonGeometry) {\n  const vertexFormat = polygonGeometry._vertexFormat;\n  const ellipsoid = polygonGeometry._ellipsoid;\n  const granularity = polygonGeometry._granularity;\n  const stRotation = polygonGeometry._stRotation;\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\n  const perPositionHeight = polygonGeometry._perPositionHeight;\n  const closeTop = polygonGeometry._closeTop;\n  const closeBottom = polygonGeometry._closeBottom;\n  const arcType = polygonGeometry._arcType;\n  const textureCoordinates = polygonGeometry._textureCoordinates;\n\n  const hasTextureCoordinates = defined(textureCoordinates);\n\n  const outerPositions = polygonHierarchy.positions;\n  if (outerPositions.length < 3) {\n    return;\n  }\n\n  const rectangle = polygonGeometry.rectangle;\n  const results = PolygonGeometryLibrary.polygonsFromHierarchy(\n    polygonHierarchy,\n    hasTextureCoordinates,\n    createProjectTo2d(rectangle, outerPositions, ellipsoid),\n    !perPositionHeight,\n    ellipsoid,\n    createSplitPolygons(rectangle, ellipsoid, arcType, perPositionHeight),\n  );\n\n  const hierarchy = results.hierarchy;\n  const polygons = results.polygons;\n\n  const dummyFunction = function (identity) {\n    return identity;\n  };\n\n  const textureCoordinatePolygons = hasTextureCoordinates\n    ? PolygonGeometryLibrary.polygonsFromHierarchy(\n        textureCoordinates,\n        true,\n        dummyFunction,\n        false,\n        ellipsoid,\n      ).polygons\n    : undefined;\n\n  if (hierarchy.length === 0) {\n    return;\n  }\n\n  const outerRing = hierarchy[0].outerRing;\n  const boundingRectangle = computeBoundingRectangle(\n    outerRing,\n    rectangle,\n    ellipsoid,\n    stRotation,\n  );\n\n  const geometries = [];\n\n  const height = polygonGeometry._height;\n  const extrudedHeight = polygonGeometry._extrudedHeight;\n  const extrude =\n    polygonGeometry._perPositionHeightExtrude ||\n    !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n  const options = {\n    perPositionHeight: perPositionHeight,\n    vertexFormat: vertexFormat,\n    geometry: undefined,\n    rotationAxis: getTangentPlane(rectangle, outerRing, ellipsoid).plane.normal,\n    projectTo2d: createProjectPositionTo2d(rectangle, outerRing, ellipsoid),\n    boundingRectangle: boundingRectangle,\n    ellipsoid: ellipsoid,\n    stRotation: stRotation,\n    textureCoordinates: undefined,\n    bottom: false,\n    top: true,\n    wall: false,\n    extrude: false,\n    arcType: arcType,\n  };\n\n  let i;\n\n  if (extrude) {\n    options.extrude = true;\n    options.top = closeTop;\n    options.bottom = closeBottom;\n    options.shadowVolume = polygonGeometry._shadowVolume;\n    options.offsetAttribute = polygonGeometry._offsetAttribute;\n    for (i = 0; i < polygons.length; i++) {\n      const splitGeometry = createGeometryFromPositionsExtruded(\n        ellipsoid,\n        polygons[i],\n        hasTextureCoordinates ? textureCoordinatePolygons[i] : undefined,\n        granularity,\n        hierarchy[i],\n        perPositionHeight,\n        closeTop,\n        closeBottom,\n        vertexFormat,\n        arcType,\n      );\n\n      let topAndBottom;\n      if (closeTop && closeBottom) {\n        topAndBottom = splitGeometry.topAndBottom;\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\n          topAndBottom.geometry,\n          height,\n          extrudedHeight,\n          ellipsoid,\n          perPositionHeight,\n        );\n      } else if (closeTop) {\n        topAndBottom = splitGeometry.topAndBottom;\n        topAndBottom.geometry.attributes.position.values =\n          PolygonPipeline.scaleToGeodeticHeight(\n            topAndBottom.geometry.attributes.position.values,\n            height,\n            ellipsoid,\n            !perPositionHeight,\n          );\n        options.geometry = topAndBottom.geometry;\n      } else if (closeBottom) {\n        topAndBottom = splitGeometry.topAndBottom;\n        topAndBottom.geometry.attributes.position.values =\n          PolygonPipeline.scaleToGeodeticHeight(\n            topAndBottom.geometry.attributes.position.values,\n            extrudedHeight,\n            ellipsoid,\n            true,\n          );\n        options.geometry = topAndBottom.geometry;\n      }\n      if (closeTop || closeBottom) {\n        options.wall = false;\n        topAndBottom.geometry = computeAttributes(options);\n        geometries.push(topAndBottom);\n      }\n\n      const walls = splitGeometry.walls;\n      options.wall = true;\n      for (let k = 0; k < walls.length; k++) {\n        const wall = walls[k];\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\n          wall.geometry,\n          height,\n          extrudedHeight,\n          ellipsoid,\n          perPositionHeight,\n        );\n        wall.geometry = computeAttributes(options);\n        geometries.push(wall);\n      }\n    }\n  } else {\n    for (i = 0; i < polygons.length; i++) {\n      const geometryInstance = new GeometryInstance({\n        geometry: PolygonGeometryLibrary.createGeometryFromPositions(\n          ellipsoid,\n          polygons[i],\n          hasTextureCoordinates ? textureCoordinatePolygons[i] : undefined,\n          granularity,\n          perPositionHeight,\n          vertexFormat,\n          arcType,\n        ),\n      });\n      geometryInstance.geometry.attributes.position.values =\n        PolygonPipeline.scaleToGeodeticHeight(\n          geometryInstance.geometry.attributes.position.values,\n          height,\n          ellipsoid,\n          !perPositionHeight,\n        );\n      options.geometry = geometryInstance.geometry;\n\n      geometryInstance.geometry = computeAttributes(options);\n\n      if (defined(polygonGeometry._offsetAttribute)) {\n        const length =\n          geometryInstance.geometry.attributes.position.values.length;\n        const offsetValue =\n          polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n            ? 0\n            : 1;\n        const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n        geometryInstance.geometry.attributes.applyOffset =\n          new GeometryAttribute({\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute: 1,\n            values: applyOffset,\n          });\n      }\n\n      geometries.push(geometryInstance);\n    }\n  }\n\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\n  geometry.attributes.position.values = new Float64Array(\n    geometry.attributes.position.values,\n  );\n  geometry.indices = IndexDatatype.createTypedArray(\n    geometry.attributes.position.values.length / 3,\n    geometry.indices,\n  );\n\n  const attributes = geometry.attributes;\n  const boundingSphere = BoundingSphere.fromVertices(\n    attributes.position.values,\n  );\n\n  if (!vertexFormat.position) {\n    delete attributes.position;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: polygonGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nPolygonGeometry.createShadowVolume = function (\n  polygonGeometry,\n  minHeightFunc,\n  maxHeightFunc,\n) {\n  const granularity = polygonGeometry._granularity;\n  const ellipsoid = polygonGeometry._ellipsoid;\n\n  const minHeight = minHeightFunc(granularity, ellipsoid);\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new PolygonGeometry({\n    polygonHierarchy: polygonGeometry._polygonHierarchy,\n    ellipsoid: ellipsoid,\n    stRotation: polygonGeometry._stRotation,\n    granularity: granularity,\n    perPositionHeight: false,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n    arcType: polygonGeometry._arcType,\n  });\n};\n\nfunction textureCoordinateRotationPoints(polygonGeometry) {\n  const stRotation = -polygonGeometry._stRotation;\n  if (stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n  const ellipsoid = polygonGeometry._ellipsoid;\n  const positions = polygonGeometry._polygonHierarchy.positions;\n  const boundingRectangle = polygonGeometry.rectangle;\n  return Geometry._textureCoordinateRotationPoints(\n    positions,\n    stRotation,\n    ellipsoid,\n    boundingRectangle,\n  );\n}\n\nObject.defineProperties(PolygonGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        const positions = this._polygonHierarchy.positions;\n        this._rectangle = PolygonGeometry.computeRectangleFromPositions(\n          positions,\n          this._ellipsoid,\n          this._arcType,\n        );\n      }\n\n      return this._rectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering PolygonGeometries as GroundPrimitives.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints =\n          textureCoordinateRotationPoints(this);\n      }\n      return this._textureCoordinateRotationPoints;\n    },\n  },\n});\nexport default PolygonGeometry;\n"],"names":["scratchCarto1","scratchCarto2","adjustPosHeightsForNormal","position","p1","p2","ellipsoid","carto1","cartesianToCartographic","height","p1Carto","cartographicToCartesian","p2Carto","scratchBoundingRectangle","scratchPosition","scratchNormal","scratchTangent","scratchBitangent","p1Scratch","p2Scratch","scratchPerPosNormal","scratchPerPosTangent","scratchPerPosBitangent","appendTextureCoordinatesOrigin","appendTextureCoordinatesCartesian2","appendTextureCoordinatesCartesian3","appendTextureCoordinatesQuaternion","appendTextureCoordinatesMatrix3","tangentMatrixScratch","computeAttributes","options","vertexFormat","geometry","shadowVolume","flatPositions","attributes","values","flatTexcoords","st","undefined","length","wall","top","bottom","normal","tangent","bitangent","boundingRectangle","rotationAxis","projectTo2d","stRotation","perPositionHeight","origin","x","y","textureCoordinates","Float32Array","normals","tangents","bitangents","extrudeNormals","textureCoordIndex","attrIndex","recomputeNormal","textureMatrix","tangentRotationMatrix","rotation","fromAxisAngle","fromQuaternion","clone","IDENTITY","bottomOffset","bottomOffset2","i","fromArray","p","multiplyByVector","scaleToGeodeticSurface","subtract","stx","clamp","width","sty","attrIndex1","attrIndex2","normalize","cross","equalsEpsilon","EPSILON10","geodeticSurfaceNormal","UNIT_Z","z","componentDatatype","FLOAT","componentsPerAttribute","extrudeDirection","extrude","offsetAttribute","size","Uint8Array","TOP","fill","offsetValue","NONE","applyOffset","UNSIGNED_BYTE","createGeometryFromPositionsExtrudedPositions","createGeometryFromPositionsExtruded","polygon","granularity","hierarchy","closeTop","closeBottom","arcType","geos","walls","topGeo","createGeometryFromPositions","edgePoints","indices","numPositions","newIndices","topBottomPositions","concat","createTypedArray","set","ilength","i0","i1","i2","texcoords","topAndBottom","outerRing","tangentPlane","fromPoints","positions2D","projectPointsOntoPlane","windingOrder","computeWindingOrder2D","CLOCKWISE","slice","reverse","wallGeo","computeWallGeometry","push","holes","hole","COUNTER_CLOCKWISE","PolygonGeometry","typeOf","object","polygonHierarchy","GEODESIC","RHUMB","DEFAULT","default","RADIANS_PER_DEGREE","perPositionHeightExtrude","extrudedHeight","h","Math","max","min","_vertexFormat","_ellipsoid","_granularity","_stRotation","_height","_extrudedHeight","_closeTop","_closeBottom","_polygonHierarchy","_perPositionHeight","_perPositionHeightExtrude","_shadowVolume","_workerName","_offsetAttribute","_arcType","_rectangle","_textureCoordinateRotationPoints","_textureCoordinates","packedLength","computeHierarchyPackedLength","fromPositions","EMPTY_OBJECT","defined","positions","newOptions","pack","value","array","startingIndex","packPolygonHierarchy","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","dummyOptions","unpack","result","unpackPolygonHierarchy","scratchCartesian0","scratchCartesian1","scratchPolarClosest","expandRectangle","polar","lastPolar","longitude","lonAdjusted","TWO_PI","westOverIdl","eastOverIdl","west","east","latitude","getLatitude","segmentLatitude","south","north","segment","t","dot","projected","add","multiplyByScalar","closestPolar","adjustedLatitude","abs","direction","angle","sign","angleBetween","northAngle","southAngle","scratchPolar","scratchPolarPrevious","computeRectangleFromPositions","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","positionsLength","lastPolarPosition","fromCartesian","polarPosition","PI","PI_OVER_TWO","scratchPolarForPlane","getTangentPlane","rectangle","scratchCartographicCyllindrical","createProjectTo2d","outerPositions","results","cartographic","fromCartesianArray","createProjectPositionTo2d","createSplitPolygons","polygons","PI_OVER_THREE","splitPolygonsOnEquator","computeBoundingRectangle","fromRectangle","plane","projectPointOntoPlane","bind","createGeometry","polygonGeometry","hasTextureCoordinates","polygonsFromHierarchy","dummyFunction","identity","textureCoordinatePolygons","geometries","EPSILON2","splitGeometry","scaleToGeodeticHeightExtruded","scaleToGeodeticHeight","k","geometryInstance","combineInstances","Float64Array","boundingSphere","fromVertices","primitiveType","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","textureCoordinateRotationPoints","Object","defineProperties","prototype","get"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 44565, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PolygonOutlineGeometry.js"],"sourcesContent":["import ArcType from \"./ArcType.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WindingOrder from \"./WindingOrder.js\";\nconst createGeometryFromPositionsPositions = [];\nconst createGeometryFromPositionsSubdivided = [];\n\nfunction createGeometryFromPositions(\n  ellipsoid,\n  positions,\n  minDistance,\n  perPositionHeight,\n  arcType,\n) {\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n  const positions2D = tangentPlane.projectPointsOntoPlane(\n    positions,\n    createGeometryFromPositionsPositions,\n  );\n\n  const originalWindingOrder =\n    PolygonPipeline.computeWindingOrder2D(positions2D);\n  if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n    positions2D.reverse();\n    positions = positions.slice().reverse();\n  }\n\n  let subdividedPositions;\n  let i;\n\n  let length = positions.length;\n  let index = 0;\n\n  if (!perPositionHeight) {\n    let numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n        );\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n        );\n      }\n    }\n    subdividedPositions = new Float64Array(numVertices * 3);\n    for (i = 0; i < length; i++) {\n      let tempPositions;\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided,\n        );\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided,\n        );\n      }\n      const tempPositionsLength = tempPositions.length;\n      for (let j = 0; j < tempPositionsLength; ++j) {\n        subdividedPositions[index++] = tempPositions[j];\n      }\n    }\n  } else {\n    subdividedPositions = new Float64Array(length * 2 * 3);\n    for (i = 0; i < length; i++) {\n      const p0 = positions[i];\n      const p1 = positions[(i + 1) % length];\n      subdividedPositions[index++] = p0.x;\n      subdividedPositions[index++] = p0.y;\n      subdividedPositions[index++] = p0.z;\n      subdividedPositions[index++] = p1.x;\n      subdividedPositions[index++] = p1.y;\n      subdividedPositions[index++] = p1.z;\n    }\n  }\n\n  length = subdividedPositions.length / 3;\n  const indicesSize = length * 2;\n  const indices = IndexDatatype.createTypedArray(length, indicesSize);\n  index = 0;\n  for (i = 0; i < length - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n  indices[index++] = length - 1;\n  indices[index++] = 0;\n\n  return new GeometryInstance({\n    geometry: new Geometry({\n      attributes: new GeometryAttributes({\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: subdividedPositions,\n        }),\n      }),\n      indices: indices,\n      primitiveType: PrimitiveType.LINES,\n    }),\n  });\n}\n\nfunction createGeometryFromPositionsExtruded(\n  ellipsoid,\n  positions,\n  minDistance,\n  perPositionHeight,\n  arcType,\n) {\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n  const positions2D = tangentPlane.projectPointsOntoPlane(\n    positions,\n    createGeometryFromPositionsPositions,\n  );\n\n  const originalWindingOrder =\n    PolygonPipeline.computeWindingOrder2D(positions2D);\n  if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n    positions2D.reverse();\n    positions = positions.slice().reverse();\n  }\n\n  let subdividedPositions;\n  let i;\n\n  let length = positions.length;\n  const corners = new Array(length);\n  let index = 0;\n\n  if (!perPositionHeight) {\n    let numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n        );\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n        );\n      }\n    }\n\n    subdividedPositions = new Float64Array(numVertices * 3 * 2);\n    for (i = 0; i < length; ++i) {\n      corners[i] = index / 3;\n      let tempPositions;\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided,\n        );\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided,\n        );\n      }\n      const tempPositionsLength = tempPositions.length;\n      for (let j = 0; j < tempPositionsLength; ++j) {\n        subdividedPositions[index++] = tempPositions[j];\n      }\n    }\n  } else {\n    subdividedPositions = new Float64Array(length * 2 * 3 * 2);\n    for (i = 0; i < length; ++i) {\n      corners[i] = index / 3;\n      const p0 = positions[i];\n      const p1 = positions[(i + 1) % length];\n\n      subdividedPositions[index++] = p0.x;\n      subdividedPositions[index++] = p0.y;\n      subdividedPositions[index++] = p0.z;\n      subdividedPositions[index++] = p1.x;\n      subdividedPositions[index++] = p1.y;\n      subdividedPositions[index++] = p1.z;\n    }\n  }\n\n  length = subdividedPositions.length / (3 * 2);\n  const cornersLength = corners.length;\n\n  const indicesSize = (length * 2 + cornersLength) * 2;\n  const indices = IndexDatatype.createTypedArray(\n    length + cornersLength,\n    indicesSize,\n  );\n\n  index = 0;\n  for (i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n    indices[index++] = i + length;\n    indices[index++] = ((i + 1) % length) + length;\n  }\n\n  for (i = 0; i < cornersLength; i++) {\n    const corner = corners[i];\n    indices[index++] = corner;\n    indices[index++] = corner + length;\n  }\n\n  return new GeometryInstance({\n    geometry: new Geometry({\n      attributes: new GeometryAttributes({\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: subdividedPositions,\n        }),\n      }),\n      indices: indices,\n      primitiveType: PrimitiveType.LINES,\n    }),\n  });\n}\n\n/**\n * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.\n *\n * @alias PolygonOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n * @param {number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @see PolygonOutlineGeometry#createGeometry\n * @see PolygonOutlineGeometry#fromPositions\n *\n * @example\n * // 1. create a polygon outline from points\n * const polygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes outline\n * const polygonWithHole = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon outline\n * const extrudedPolygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);\n */\nfunction PolygonOutlineGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n\n  if (options.perPositionHeight && defined(options.height)) {\n    throw new DeveloperError(\n      \"Cannot use both options.perPositionHeight and options.height\",\n    );\n  }\n  if (\n    defined(options.arcType) &&\n    options.arcType !== ArcType.GEODESIC &&\n    options.arcType !== ArcType.RHUMB\n  ) {\n    throw new DeveloperError(\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const polygonHierarchy = options.polygonHierarchy;\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  const granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  const perPositionHeight = options.perPositionHeight ?? false;\n  const perPositionHeightExtrude =\n    perPositionHeight && defined(options.extrudedHeight);\n  const arcType = options.arcType ?? ArcType.GEODESIC;\n\n  let height = options.height ?? 0.0;\n  let extrudedHeight = options.extrudedHeight ?? height;\n\n  if (!perPositionHeightExtrude) {\n    const h = Math.max(height, extrudedHeight);\n    extrudedHeight = Math.min(height, extrudedHeight);\n    height = h;\n  }\n\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._granularity = granularity;\n  this._height = height;\n  this._extrudedHeight = extrudedHeight;\n  this._arcType = arcType;\n  this._polygonHierarchy = polygonHierarchy;\n  this._perPositionHeight = perPositionHeight;\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createPolygonOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    PolygonGeometryLibrary.computeHierarchyPackedLength(\n      polygonHierarchy,\n      Cartesian3,\n    ) +\n    Ellipsoid.packedLength +\n    8;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nPolygonOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n    value._polygonHierarchy,\n    array,\n    startingIndex,\n    Cartesian3,\n  );\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex++] = value._offsetAttribute ?? -1;\n  array[startingIndex] = value.packedLength;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst dummyOptions = {\n  polygonHierarchy: {},\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonOutlineGeometry} [result] The object into which to store the result.\n * @returns {PolygonOutlineGeometry} The modified result parameter or a new PolygonOutlineGeometry instance if one was not provided.\n */\nPolygonOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\n    array,\n    startingIndex,\n    Cartesian3,\n  );\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const perPositionHeightExtrude = array[startingIndex++] === 1.0;\n  const perPositionHeight = array[startingIndex++] === 1.0;\n  const arcType = array[startingIndex++];\n  const offsetAttribute = array[startingIndex++];\n  const packedLength = array[startingIndex];\n\n  if (!defined(result)) {\n    result = new PolygonOutlineGeometry(dummyOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._granularity = granularity;\n  result._perPositionHeight = perPositionHeight;\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\n  result._arcType = arcType;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n  result.packedLength = packedLength;\n\n  return result;\n};\n\n/**\n * A description of a polygon outline from an array of positions.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {number} [options.height=0.0] The height of the polygon.\n * @param {number} [options.extrudedHeight] The height of the polygon extrusion.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link LinkType.GEODESIC} and {@link ArcType.RHUMB}.\n * @returns {PolygonOutlineGeometry}\n *\n *\n * @example\n * // create a polygon from points\n * const polygon = Cesium.PolygonOutlineGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n * @see PolygonOutlineGeometry#createGeometry\n */\nPolygonOutlineGeometry.fromPositions = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  const newOptions = {\n    polygonHierarchy: {\n      positions: options.positions,\n    },\n    height: options.height,\n    extrudedHeight: options.extrudedHeight,\n    ellipsoid: options.ellipsoid,\n    granularity: options.granularity,\n    perPositionHeight: options.perPositionHeight,\n    arcType: options.arcType,\n    offsetAttribute: options.offsetAttribute,\n  };\n  return new PolygonOutlineGeometry(newOptions);\n};\n\n/**\n * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolygonOutlineGeometry} polygonGeometry A description of the polygon outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolygonOutlineGeometry.createGeometry = function (polygonGeometry) {\n  const ellipsoid = polygonGeometry._ellipsoid;\n  const granularity = polygonGeometry._granularity;\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\n  const perPositionHeight = polygonGeometry._perPositionHeight;\n  const arcType = polygonGeometry._arcType;\n\n  const polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(\n    polygonHierarchy,\n    !perPositionHeight,\n    ellipsoid,\n  );\n\n  if (polygons.length === 0) {\n    return undefined;\n  }\n\n  let geometryInstance;\n  const geometries = [];\n  const minDistance = CesiumMath.chordLength(\n    granularity,\n    ellipsoid.maximumRadius,\n  );\n\n  const height = polygonGeometry._height;\n  const extrudedHeight = polygonGeometry._extrudedHeight;\n  const extrude =\n    polygonGeometry._perPositionHeightExtrude ||\n    !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  let offsetValue;\n  let i;\n  if (extrude) {\n    for (i = 0; i < polygons.length; i++) {\n      geometryInstance = createGeometryFromPositionsExtruded(\n        ellipsoid,\n        polygons[i],\n        minDistance,\n        perPositionHeight,\n        arcType,\n      );\n      geometryInstance.geometry =\n        PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\n          geometryInstance.geometry,\n          height,\n          extrudedHeight,\n          ellipsoid,\n          perPositionHeight,\n        );\n      if (defined(polygonGeometry._offsetAttribute)) {\n        const size =\n          geometryInstance.geometry.attributes.position.values.length / 3;\n        let offsetAttribute = new Uint8Array(size);\n        if (polygonGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n          offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n        } else {\n          offsetValue =\n            polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n              ? 0\n              : 1;\n          offsetAttribute = offsetAttribute.fill(offsetValue);\n        }\n\n        geometryInstance.geometry.attributes.applyOffset =\n          new GeometryAttribute({\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute: 1,\n            values: offsetAttribute,\n          });\n      }\n      geometries.push(geometryInstance);\n    }\n  } else {\n    for (i = 0; i < polygons.length; i++) {\n      geometryInstance = createGeometryFromPositions(\n        ellipsoid,\n        polygons[i],\n        minDistance,\n        perPositionHeight,\n        arcType,\n      );\n      geometryInstance.geometry.attributes.position.values =\n        PolygonPipeline.scaleToGeodeticHeight(\n          geometryInstance.geometry.attributes.position.values,\n          height,\n          ellipsoid,\n          !perPositionHeight,\n        );\n\n      if (defined(polygonGeometry._offsetAttribute)) {\n        const length =\n          geometryInstance.geometry.attributes.position.values.length;\n        offsetValue =\n          polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n            ? 0\n            : 1;\n        const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n        geometryInstance.geometry.attributes.applyOffset =\n          new GeometryAttribute({\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute: 1,\n            values: applyOffset,\n          });\n      }\n\n      geometries.push(geometryInstance);\n    }\n  }\n\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\n  const boundingSphere = BoundingSphere.fromVertices(\n    geometry.attributes.position.values,\n  );\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: polygonGeometry._offsetAttribute,\n  });\n};\nexport default PolygonOutlineGeometry;\n"],"names":["createGeometryFromPositionsPositions","createGeometryFromPositionsSubdivided","createGeometryFromPositions","ellipsoid","positions","minDistance","perPositionHeight","arcType","tangentPlane","fromPoints","positions2D","projectPointsOntoPlane","originalWindingOrder","computeWindingOrder2D","CLOCKWISE","reverse","slice","subdividedPositions","i","length","index","numVertices","GEODESIC","subdivideLineCount","RHUMB","subdivideRhumbLineCount","Float64Array","tempPositions","subdivideLine","subdivideRhumbLine","tempPositionsLength","j","p0","p1","x","y","z","indicesSize","indices","createTypedArray","geometry","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","primitiveType","LINES","createGeometryFromPositionsExtruded","corners","Array","cornersLength","corner","PolygonOutlineGeometry","options","typeOf","object","polygonHierarchy","height","default","granularity","RADIANS_PER_DEGREE","perPositionHeightExtrude","extrudedHeight","h","Math","max","min","_ellipsoid","clone","_granularity","_height","_extrudedHeight","_arcType","_polygonHierarchy","_perPositionHeight","_perPositionHeightExtrude","_offsetAttribute","offsetAttribute","_workerName","packedLength","computeHierarchyPackedLength","pack","value","array","startingIndex","defined","packPolygonHierarchy","scratchEllipsoid","UNIT_SPHERE","dummyOptions","unpack","result","unpackPolygonHierarchy","undefined","fromPositions","EMPTY_OBJECT","newOptions","createGeometry","polygonGeometry","polygons","polygonOutlinesFromHierarchy","geometryInstance","geometries","chordLength","maximumRadius","extrude","equalsEpsilon","EPSILON2","offsetValue","scaleToGeodeticHeightExtruded","size","Uint8Array","TOP","fill","NONE","applyOffset","UNSIGNED_BYTE","push","scaleToGeodeticHeight","combineInstances","boundingSphere","fromVertices"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 45088, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PolylineVolumeGeometry.js"],"sourcesContent":["import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingRectangle from \"./BoundingRectangle.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport oneTimeWarning from \"./oneTimeWarning.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PolylineVolumeGeometryLibrary from \"./PolylineVolumeGeometryLibrary.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\nfunction computeAttributes(\n  combinedPositions,\n  shape,\n  boundingRectangle,\n  vertexFormat,\n) {\n  const attributes = new GeometryAttributes();\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: combinedPositions,\n    });\n  }\n  const shapeLength = shape.length;\n  const vertexCount = combinedPositions.length / 3;\n  const length = (vertexCount - shapeLength * 2) / (shapeLength * 2);\n  const firstEndIndices = PolygonPipeline.triangulate(shape);\n\n  const indicesCount =\n    (length - 1) * shapeLength * 6 + firstEndIndices.length * 2;\n  const indices = IndexDatatype.createTypedArray(vertexCount, indicesCount);\n  let i, j;\n  let ll, ul, ur, lr;\n  const offset = shapeLength * 2;\n  let index = 0;\n  for (i = 0; i < length - 1; i++) {\n    for (j = 0; j < shapeLength - 1; j++) {\n      ll = j * 2 + i * shapeLength * 2;\n      lr = ll + offset;\n      ul = ll + 1;\n      ur = ul + offset;\n\n      indices[index++] = ul;\n      indices[index++] = ll;\n      indices[index++] = ur;\n      indices[index++] = ur;\n      indices[index++] = ll;\n      indices[index++] = lr;\n    }\n    ll = shapeLength * 2 - 2 + i * shapeLength * 2;\n    ul = ll + 1;\n    ur = ul + offset;\n    lr = ll + offset;\n\n    indices[index++] = ul;\n    indices[index++] = ll;\n    indices[index++] = ur;\n    indices[index++] = ur;\n    indices[index++] = ll;\n    indices[index++] = lr;\n  }\n\n  if (vertexFormat.st || vertexFormat.tangent || vertexFormat.bitangent) {\n    // st required for tangent/bitangent calculation\n    const st = new Float32Array(vertexCount * 2);\n    const lengthSt = 1 / (length - 1);\n    const heightSt = 1 / boundingRectangle.height;\n    const heightOffset = boundingRectangle.height / 2;\n    let s, t;\n    let stindex = 0;\n    for (i = 0; i < length; i++) {\n      s = i * lengthSt;\n      t = heightSt * (shape[0].y + heightOffset);\n      st[stindex++] = s;\n      st[stindex++] = t;\n      for (j = 1; j < shapeLength; j++) {\n        t = heightSt * (shape[j].y + heightOffset);\n        st[stindex++] = s;\n        st[stindex++] = t;\n        st[stindex++] = s;\n        st[stindex++] = t;\n      }\n      t = heightSt * (shape[0].y + heightOffset);\n      st[stindex++] = s;\n      st[stindex++] = t;\n    }\n    for (j = 0; j < shapeLength; j++) {\n      s = 0;\n      t = heightSt * (shape[j].y + heightOffset);\n      st[stindex++] = s;\n      st[stindex++] = t;\n    }\n    for (j = 0; j < shapeLength; j++) {\n      s = (length - 1) * lengthSt;\n      t = heightSt * (shape[j].y + heightOffset);\n      st[stindex++] = s;\n      st[stindex++] = t;\n    }\n\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: new Float32Array(st),\n    });\n  }\n\n  const endOffset = vertexCount - shapeLength * 2;\n  for (i = 0; i < firstEndIndices.length; i += 3) {\n    const v0 = firstEndIndices[i] + endOffset;\n    const v1 = firstEndIndices[i + 1] + endOffset;\n    const v2 = firstEndIndices[i + 2] + endOffset;\n\n    indices[index++] = v0;\n    indices[index++] = v1;\n    indices[index++] = v2;\n    indices[index++] = v2 + shapeLength;\n    indices[index++] = v1 + shapeLength;\n    indices[index++] = v0 + shapeLength;\n  }\n\n  let geometry = new Geometry({\n    attributes: attributes,\n    indices: indices,\n    boundingSphere: BoundingSphere.fromVertices(combinedPositions),\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n\n  if (vertexFormat.normal) {\n    geometry = GeometryPipeline.computeNormal(geometry);\n  }\n\n  if (vertexFormat.tangent || vertexFormat.bitangent) {\n    try {\n      geometry = GeometryPipeline.computeTangentAndBitangent(geometry);\n    } catch (e) {\n      oneTimeWarning(\n        \"polyline-volume-tangent-bitangent\",\n        \"Unable to compute tangents and bitangents for polyline volume geometry\",\n      );\n      //TODO https://github.com/CesiumGS/cesium/issues/3609\n    }\n\n    if (!vertexFormat.tangent) {\n      geometry.attributes.tangent = undefined;\n    }\n    if (!vertexFormat.bitangent) {\n      geometry.attributes.bitangent = undefined;\n    }\n    if (!vertexFormat.st) {\n      geometry.attributes.st = undefined;\n    }\n  }\n\n  return geometry;\n}\n\n/**\n * A description of a polyline with a volume (a 2D shape extruded along a polyline).\n *\n * @alias PolylineVolumeGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.polylinePositions An array of {@link Cartesian3} positions that define the center of the polyline volume.\n * @param {Cartesian2[]} options.shapePositions An array of {@link Cartesian2} positions that define the shape to be extruded along the polyline\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see PolylineVolumeGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline%20Volume.html|Cesium Sandcastle Polyline Volume Demo}\n *\n * @example\n * function computeCircle(radius) {\n *   const positions = [];\n *   for (let i = 0; i < 360; i++) {\n *     const radians = Cesium.Math.toRadians(i);\n *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n *   }\n *   return positions;\n * }\n *\n * const volume = new Cesium.PolylineVolumeGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0\n *   ]),\n *   shapePositions : computeCircle(100000.0)\n * });\n */\nfunction PolylineVolumeGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const positions = options.polylinePositions;\n  const shape = options.shapePositions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.polylinePositions is required.\");\n  }\n  if (!defined(shape)) {\n    throw new DeveloperError(\"options.shapePositions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._positions = positions;\n  this._shape = shape;\n  this._ellipsoid = Ellipsoid.clone(options.ellipsoid ?? Ellipsoid.default);\n  this._cornerType = options.cornerType ?? CornerType.ROUNDED;\n  this._vertexFormat = VertexFormat.clone(\n    options.vertexFormat ?? VertexFormat.DEFAULT,\n  );\n  this._granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  this._workerName = \"createPolylineVolumeGeometry\";\n\n  let numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += 1 + shape.length * Cartesian2.packedLength;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 2;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolylineVolumeGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nPolylineVolumeGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  let i;\n\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  const shape = value._shape;\n  length = shape.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n    Cartesian2.pack(shape[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  polylinePositions: undefined,\n  shapePositions: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  cornerType: undefined,\n  granularity: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolylineVolumeGeometry} [result] The object into which to store the result.\n * @returns {PolylineVolumeGeometry} The modified result parameter or a new PolylineVolumeGeometry instance if one was not provided.\n */\nPolylineVolumeGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  let i;\n\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  const shape = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n    shape[i] = Cartesian2.unpack(array, startingIndex);\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const cornerType = array[startingIndex++];\n  const granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.polylinePositions = positions;\n    scratchOptions.shapePositions = shape;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    return new PolylineVolumeGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._shape = shape;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n\n  return result;\n};\n\nconst brScratch = new BoundingRectangle();\n\n/**\n * Computes the geometric representation of a polyline with a volume, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolylineVolumeGeometry} polylineVolumeGeometry A description of the polyline volume.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolylineVolumeGeometry.createGeometry = function (polylineVolumeGeometry) {\n  const positions = polylineVolumeGeometry._positions;\n  const cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon,\n  );\n  let shape2D = polylineVolumeGeometry._shape;\n  shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);\n\n  if (cleanPositions.length < 2 || shape2D.length < 3) {\n    return undefined;\n  }\n\n  if (\n    PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE\n  ) {\n    shape2D.reverse();\n  }\n  const boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);\n\n  const computedPositions = PolylineVolumeGeometryLibrary.computePositions(\n    cleanPositions,\n    shape2D,\n    boundingRectangle,\n    polylineVolumeGeometry,\n    true,\n  );\n  return computeAttributes(\n    computedPositions,\n    shape2D,\n    boundingRectangle,\n    polylineVolumeGeometry._vertexFormat,\n  );\n};\nexport default PolylineVolumeGeometry;\n"],"names":["computeAttributes","combinedPositions","shape","boundingRectangle","vertexFormat","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","shapeLength","length","vertexCount","firstEndIndices","triangulate","indicesCount","indices","createTypedArray","i","j","ll","ul","ur","lr","offset","index","st","tangent","bitangent","Float32Array","lengthSt","heightSt","height","heightOffset","s","t","stindex","y","FLOAT","endOffset","v0","v1","v2","geometry","boundingSphere","fromVertices","primitiveType","TRIANGLES","normal","computeNormal","computeTangentAndBitangent","e","undefined","PolylineVolumeGeometry","options","EMPTY_OBJECT","positions","polylinePositions","shapePositions","_positions","_shape","_ellipsoid","clone","ellipsoid","default","_cornerType","cornerType","ROUNDED","_vertexFormat","DEFAULT","_granularity","granularity","RADIANS_PER_DEGREE","_workerName","numComponents","packedLength","pack","value","array","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","unpack","result","Array","brScratch","createGeometry","polylineVolumeGeometry","cleanPositions","equalsEpsilon","shape2D","removeDuplicatesFromShape","computeWindingOrder2D","CLOCKWISE","reverse","fromPoints","computedPositions","computePositions"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 45446, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PolylineVolumeOutlineGeometry.js"],"sourcesContent":["import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingRectangle from \"./BoundingRectangle.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PolylineVolumeGeometryLibrary from \"./PolylineVolumeGeometryLibrary.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\nfunction computeAttributes(positions, shape) {\n  const attributes = new GeometryAttributes();\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n\n  const shapeLength = shape.length;\n  const vertexCount = attributes.position.values.length / 3;\n  const positionLength = positions.length / 3;\n  const shapeCount = positionLength / shapeLength;\n  const indices = IndexDatatype.createTypedArray(\n    vertexCount,\n    2 * shapeLength * (shapeCount + 1),\n  );\n  let i, j;\n  let index = 0;\n  i = 0;\n  let offset = i * shapeLength;\n  for (j = 0; j < shapeLength - 1; j++) {\n    indices[index++] = j + offset;\n    indices[index++] = j + offset + 1;\n  }\n  indices[index++] = shapeLength - 1 + offset;\n  indices[index++] = offset;\n\n  i = shapeCount - 1;\n  offset = i * shapeLength;\n  for (j = 0; j < shapeLength - 1; j++) {\n    indices[index++] = j + offset;\n    indices[index++] = j + offset + 1;\n  }\n  indices[index++] = shapeLength - 1 + offset;\n  indices[index++] = offset;\n\n  for (i = 0; i < shapeCount - 1; i++) {\n    const firstOffset = shapeLength * i;\n    const secondOffset = firstOffset + shapeLength;\n    for (j = 0; j < shapeLength; j++) {\n      indices[index++] = j + firstOffset;\n      indices[index++] = j + secondOffset;\n    }\n  }\n\n  const geometry = new Geometry({\n    attributes: attributes,\n    indices: IndexDatatype.createTypedArray(vertexCount, indices),\n    boundingSphere: BoundingSphere.fromVertices(positions),\n    primitiveType: PrimitiveType.LINES,\n  });\n\n  return geometry;\n}\n\n/**\n * A description of a polyline with a volume (a 2D shape extruded along a polyline).\n *\n * @alias PolylineVolumeOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.polylinePositions An array of positions that define the center of the polyline volume.\n * @param {Cartesian2[]} options.shapePositions An array of positions that define the shape to be extruded along the polyline\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see PolylineVolumeOutlineGeometry#createGeometry\n *\n * @example\n * function computeCircle(radius) {\n *   const positions = [];\n *   for (let i = 0; i < 360; i++) {\n *     const radians = Cesium.Math.toRadians(i);\n *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n *   }\n *   return positions;\n * }\n *\n * const volumeOutline = new Cesium.PolylineVolumeOutlineGeometry({\n *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0\n *   ]),\n *   shapePositions : computeCircle(100000.0)\n * });\n */\nfunction PolylineVolumeOutlineGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const positions = options.polylinePositions;\n  const shape = options.shapePositions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.polylinePositions is required.\");\n  }\n  if (!defined(shape)) {\n    throw new DeveloperError(\"options.shapePositions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._positions = positions;\n  this._shape = shape;\n  this._ellipsoid = Ellipsoid.clone(options.ellipsoid ?? Ellipsoid.default);\n  this._cornerType = options.cornerType ?? CornerType.ROUNDED;\n  this._granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  this._workerName = \"createPolylineVolumeOutlineGeometry\";\n\n  let numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += 1 + shape.length * Cartesian2.packedLength;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength = numComponents + Ellipsoid.packedLength + 2;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolylineVolumeOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nPolylineVolumeOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  let i;\n\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  const shape = value._shape;\n  length = shape.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n    Cartesian2.pack(shape[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchOptions = {\n  polylinePositions: undefined,\n  shapePositions: undefined,\n  ellipsoid: scratchEllipsoid,\n  height: undefined,\n  cornerType: undefined,\n  granularity: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolylineVolumeOutlineGeometry} [result] The object into which to store the result.\n * @returns {PolylineVolumeOutlineGeometry} The modified result parameter or a new PolylineVolumeOutlineGeometry instance if one was not provided.\n */\nPolylineVolumeOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  let i;\n\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  const shape = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n    shape[i] = Cartesian2.unpack(array, startingIndex);\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const cornerType = array[startingIndex++];\n  const granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.polylinePositions = positions;\n    scratchOptions.shapePositions = shape;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    return new PolylineVolumeOutlineGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._shape = shape;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n\n  return result;\n};\n\nconst brScratch = new BoundingRectangle();\n\n/**\n * Computes the geometric representation of the outline of a polyline with a volume, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolylineVolumeOutlineGeometry} polylineVolumeOutlineGeometry A description of the polyline volume outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolylineVolumeOutlineGeometry.createGeometry = function (\n  polylineVolumeOutlineGeometry,\n) {\n  const positions = polylineVolumeOutlineGeometry._positions;\n  const cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon,\n  );\n  let shape2D = polylineVolumeOutlineGeometry._shape;\n  shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);\n\n  if (cleanPositions.length < 2 || shape2D.length < 3) {\n    return undefined;\n  }\n\n  if (\n    PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE\n  ) {\n    shape2D.reverse();\n  }\n  const boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);\n\n  const computedPositions = PolylineVolumeGeometryLibrary.computePositions(\n    cleanPositions,\n    shape2D,\n    boundingRectangle,\n    polylineVolumeOutlineGeometry,\n    false,\n  );\n  return computeAttributes(computedPositions, shape2D);\n};\nexport default PolylineVolumeOutlineGeometry;\n"],"names":["computeAttributes","positions","shape","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","shapeLength","length","vertexCount","positionLength","shapeCount","indices","createTypedArray","i","j","index","offset","firstOffset","secondOffset","geometry","boundingSphere","fromVertices","primitiveType","LINES","PolylineVolumeOutlineGeometry","options","EMPTY_OBJECT","polylinePositions","shapePositions","_positions","_shape","_ellipsoid","clone","ellipsoid","default","_cornerType","cornerType","ROUNDED","_granularity","granularity","RADIANS_PER_DEGREE","_workerName","numComponents","packedLength","pack","value","array","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchOptions","undefined","height","unpack","result","Array","brScratch","createGeometry","polylineVolumeOutlineGeometry","cleanPositions","equalsEpsilon","shape2D","removeDuplicatesFromShape","computeWindingOrder2D","CLOCKWISE","reverse","boundingRectangle","fromPoints","computedPositions","computePositions"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 45708, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/RectangleGeometryLibrary.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix2 from \"./Matrix2.js\";\nimport Rectangle from \"./Rectangle.js\";\n\nconst cos = Math.cos;\nconst sin = Math.sin;\nconst sqrt = Math.sqrt;\n\n/**\n * @private\n */\nconst RectangleGeometryLibrary = {};\n\n/**\n * @private\n */\nRectangleGeometryLibrary.computePosition = function (\n  computedOptions,\n  ellipsoid,\n  computeST,\n  row,\n  col,\n  position,\n  st,\n) {\n  const radiiSquared = ellipsoid.radiiSquared;\n  const nwCorner = computedOptions.nwCorner;\n  const rectangle = computedOptions.boundingRectangle;\n\n  let stLatitude =\n    nwCorner.latitude -\n    computedOptions.granYCos * row +\n    col * computedOptions.granXSin;\n  const cosLatitude = cos(stLatitude);\n  const nZ = sin(stLatitude);\n  const kZ = radiiSquared.z * nZ;\n\n  let stLongitude =\n    nwCorner.longitude +\n    row * computedOptions.granYSin +\n    col * computedOptions.granXCos;\n  const nX = cosLatitude * cos(stLongitude);\n  const nY = cosLatitude * sin(stLongitude);\n\n  const kX = radiiSquared.x * nX;\n  const kY = radiiSquared.y * nY;\n\n  const gamma = sqrt(kX * nX + kY * nY + kZ * nZ);\n\n  position.x = kX / gamma;\n  position.y = kY / gamma;\n  position.z = kZ / gamma;\n\n  if (computeST) {\n    const stNwCorner = computedOptions.stNwCorner;\n    if (defined(stNwCorner)) {\n      stLatitude =\n        stNwCorner.latitude -\n        computedOptions.stGranYCos * row +\n        col * computedOptions.stGranXSin;\n      stLongitude =\n        stNwCorner.longitude +\n        row * computedOptions.stGranYSin +\n        col * computedOptions.stGranXCos;\n\n      st.x = (stLongitude - computedOptions.stWest) * computedOptions.lonScalar;\n      st.y = (stLatitude - computedOptions.stSouth) * computedOptions.latScalar;\n    } else {\n      st.x = (stLongitude - rectangle.west) * computedOptions.lonScalar;\n      st.y = (stLatitude - rectangle.south) * computedOptions.latScalar;\n    }\n  }\n};\n\nconst rotationMatrixScratch = new Matrix2();\nlet nwCartesian = new Cartesian3();\nconst centerScratch = new Cartographic();\nlet centerCartesian = new Cartesian3();\nconst proj = new GeographicProjection();\n\nfunction getRotationOptions(\n  nwCorner,\n  rotation,\n  granularityX,\n  granularityY,\n  center,\n  width,\n  height,\n) {\n  const cosRotation = Math.cos(rotation);\n  const granYCos = granularityY * cosRotation;\n  const granXCos = granularityX * cosRotation;\n\n  const sinRotation = Math.sin(rotation);\n  const granYSin = granularityY * sinRotation;\n  const granXSin = granularityX * sinRotation;\n\n  proj._ellipsoid = Ellipsoid.default;\n  nwCartesian = proj.project(nwCorner, nwCartesian);\n\n  nwCartesian = Cartesian3.subtract(nwCartesian, centerCartesian, nwCartesian);\n  const rotationMatrix = Matrix2.fromRotation(rotation, rotationMatrixScratch);\n  nwCartesian = Matrix2.multiplyByVector(\n    rotationMatrix,\n    nwCartesian,\n    nwCartesian,\n  );\n  nwCartesian = Cartesian3.add(nwCartesian, centerCartesian, nwCartesian);\n  nwCorner = proj.unproject(nwCartesian, nwCorner);\n\n  width -= 1;\n  height -= 1;\n\n  const latitude = nwCorner.latitude;\n  const latitude0 = latitude + width * granXSin;\n  const latitude1 = latitude - granYCos * height;\n  const latitude2 = latitude - granYCos * height + width * granXSin;\n\n  const north = Math.max(latitude, latitude0, latitude1, latitude2);\n  const south = Math.min(latitude, latitude0, latitude1, latitude2);\n\n  const longitude = nwCorner.longitude;\n  const longitude0 = longitude + width * granXCos;\n  const longitude1 = longitude + height * granYSin;\n  const longitude2 = longitude + height * granYSin + width * granXCos;\n\n  const east = Math.max(longitude, longitude0, longitude1, longitude2);\n  const west = Math.min(longitude, longitude0, longitude1, longitude2);\n\n  return {\n    north: north,\n    south: south,\n    east: east,\n    west: west,\n    granYCos: granYCos,\n    granYSin: granYSin,\n    granXCos: granXCos,\n    granXSin: granXSin,\n    nwCorner: nwCorner,\n  };\n}\n\n/**\n * @private\n */\nRectangleGeometryLibrary.computeOptions = function (\n  rectangle,\n  granularity,\n  rotation,\n  stRotation,\n  boundingRectangleScratch,\n  nwCornerResult,\n  stNwCornerResult,\n) {\n  let east = rectangle.east;\n  let west = rectangle.west;\n  let north = rectangle.north;\n  let south = rectangle.south;\n\n  let northCap = false;\n  let southCap = false;\n\n  if (north === CesiumMath.PI_OVER_TWO) {\n    northCap = true;\n  }\n  if (south === -CesiumMath.PI_OVER_TWO) {\n    southCap = true;\n  }\n\n  let dx;\n  const dy = north - south;\n  if (west > east) {\n    dx = CesiumMath.TWO_PI - west + east;\n  } else {\n    dx = east - west;\n  }\n\n  const width = Math.ceil(dx / granularity) + 1;\n  const height = Math.ceil(dy / granularity) + 1;\n  const granularityX = dx / (width - 1);\n  const granularityY = dy / (height - 1);\n\n  const nwCorner = Rectangle.northwest(rectangle, nwCornerResult);\n  const center = Rectangle.center(rectangle, centerScratch);\n  if (rotation !== 0 || stRotation !== 0) {\n    if (center.longitude < nwCorner.longitude) {\n      center.longitude += CesiumMath.TWO_PI;\n    }\n    proj._ellipsoid = Ellipsoid.default;\n    centerCartesian = proj.project(center, centerCartesian);\n  }\n\n  const granYCos = granularityY;\n  const granXCos = granularityX;\n  const granYSin = 0.0;\n  const granXSin = 0.0;\n\n  const boundingRectangle = Rectangle.clone(\n    rectangle,\n    boundingRectangleScratch,\n  );\n\n  const computedOptions = {\n    granYCos: granYCos,\n    granYSin: granYSin,\n    granXCos: granXCos,\n    granXSin: granXSin,\n    nwCorner: nwCorner,\n    boundingRectangle: boundingRectangle,\n    width: width,\n    height: height,\n    northCap: northCap,\n    southCap: southCap,\n  };\n\n  if (rotation !== 0) {\n    const rotationOptions = getRotationOptions(\n      nwCorner,\n      rotation,\n      granularityX,\n      granularityY,\n      center,\n      width,\n      height,\n    );\n    north = rotationOptions.north;\n    south = rotationOptions.south;\n    east = rotationOptions.east;\n    west = rotationOptions.west;\n\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      north < -CesiumMath.PI_OVER_TWO ||\n      north > CesiumMath.PI_OVER_TWO ||\n      south < -CesiumMath.PI_OVER_TWO ||\n      south > CesiumMath.PI_OVER_TWO\n    ) {\n      throw new DeveloperError(\n        \"Rotated rectangle is invalid.  It crosses over either the north or south pole.\",\n      );\n    }\n    //>>includeEnd('debug');\n\n    computedOptions.granYCos = rotationOptions.granYCos;\n    computedOptions.granYSin = rotationOptions.granYSin;\n    computedOptions.granXCos = rotationOptions.granXCos;\n    computedOptions.granXSin = rotationOptions.granXSin;\n\n    boundingRectangle.north = north;\n    boundingRectangle.south = south;\n    boundingRectangle.east = east;\n    boundingRectangle.west = west;\n  }\n\n  if (stRotation !== 0) {\n    rotation = rotation - stRotation;\n    const stNwCorner = Rectangle.northwest(boundingRectangle, stNwCornerResult);\n\n    const stRotationOptions = getRotationOptions(\n      stNwCorner,\n      rotation,\n      granularityX,\n      granularityY,\n      center,\n      width,\n      height,\n    );\n\n    computedOptions.stGranYCos = stRotationOptions.granYCos;\n    computedOptions.stGranXCos = stRotationOptions.granXCos;\n    computedOptions.stGranYSin = stRotationOptions.granYSin;\n    computedOptions.stGranXSin = stRotationOptions.granXSin;\n    computedOptions.stNwCorner = stNwCorner;\n    computedOptions.stWest = stRotationOptions.west;\n    computedOptions.stSouth = stRotationOptions.south;\n  }\n\n  return computedOptions;\n};\nexport default RectangleGeometryLibrary;\n"],"names":["cos","Math","sin","sqrt","RectangleGeometryLibrary","computePosition","computedOptions","ellipsoid","computeST","row","col","position","st","radiiSquared","nwCorner","rectangle","boundingRectangle","stLatitude","latitude","granYCos","granXSin","cosLatitude","nZ","kZ","z","stLongitude","longitude","granYSin","granXCos","nX","nY","kX","x","kY","y","gamma","stNwCorner","stGranYCos","stGranXSin","stGranYSin","stGranXCos","stWest","lonScalar","stSouth","latScalar","west","south","rotationMatrixScratch","nwCartesian","centerScratch","centerCartesian","proj","getRotationOptions","rotation","granularityX","granularityY","center","width","height","cosRotation","sinRotation","_ellipsoid","default","project","subtract","rotationMatrix","fromRotation","multiplyByVector","add","unproject","latitude0","latitude1","latitude2","north","max","min","longitude0","longitude1","longitude2","east","computeOptions","granularity","stRotation","boundingRectangleScratch","nwCornerResult","stNwCornerResult","northCap","southCap","PI_OVER_TWO","dx","dy","TWO_PI","ceil","northwest","clone","rotationOptions","stRotationOptions"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 45904, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/RectangleGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix2 from \"./Matrix2.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport RectangleGeometryLibrary from \"./RectangleGeometryLibrary.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst positionScratch = new Cartesian3();\nconst normalScratch = new Cartesian3();\nconst tangentScratch = new Cartesian3();\nconst bitangentScratch = new Cartesian3();\nconst rectangleScratch = new Rectangle();\nconst stScratch = new Cartesian2();\nconst bottomBoundingSphere = new BoundingSphere();\nconst topBoundingSphere = new BoundingSphere();\n\nfunction createAttributes(vertexFormat, attributes) {\n  const geo = new Geometry({\n    attributes: new GeometryAttributes(),\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n\n  geo.attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: attributes.positions,\n  });\n  if (vertexFormat.normal) {\n    geo.attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.normals,\n    });\n  }\n  if (vertexFormat.tangent) {\n    geo.attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.tangents,\n    });\n  }\n  if (vertexFormat.bitangent) {\n    geo.attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.bitangents,\n    });\n  }\n  return geo;\n}\n\nfunction calculateAttributes(\n  positions,\n  vertexFormat,\n  ellipsoid,\n  tangentRotationMatrix,\n) {\n  const length = positions.length;\n\n  const normals = vertexFormat.normal ? new Float32Array(length) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(length)\n    : undefined;\n\n  let attrIndex = 0;\n  const bitangent = bitangentScratch;\n  const tangent = tangentScratch;\n  let normal = normalScratch;\n  if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n    for (let i = 0; i < length; i += 3) {\n      const p = Cartesian3.fromArray(positions, i, positionScratch);\n      const attrIndex1 = attrIndex + 1;\n      const attrIndex2 = attrIndex + 2;\n\n      normal = ellipsoid.geodeticSurfaceNormal(p, normal);\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n        Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent);\n        Cartesian3.normalize(tangent, tangent);\n\n        if (vertexFormat.bitangent) {\n          Cartesian3.normalize(\n            Cartesian3.cross(normal, tangent, bitangent),\n            bitangent,\n          );\n        }\n      }\n\n      if (vertexFormat.normal) {\n        normals[attrIndex] = normal.x;\n        normals[attrIndex1] = normal.y;\n        normals[attrIndex2] = normal.z;\n      }\n      if (vertexFormat.tangent) {\n        tangents[attrIndex] = tangent.x;\n        tangents[attrIndex1] = tangent.y;\n        tangents[attrIndex2] = tangent.z;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[attrIndex] = bitangent.x;\n        bitangents[attrIndex1] = bitangent.y;\n        bitangents[attrIndex2] = bitangent.z;\n      }\n      attrIndex += 3;\n    }\n  }\n  return createAttributes(vertexFormat, {\n    positions: positions,\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents,\n  });\n}\n\nconst v1Scratch = new Cartesian3();\nconst v2Scratch = new Cartesian3();\n\nfunction calculateAttributesWall(positions, vertexFormat, ellipsoid) {\n  const length = positions.length;\n\n  const normals = vertexFormat.normal ? new Float32Array(length) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(length)\n    : undefined;\n\n  let normalIndex = 0;\n  let tangentIndex = 0;\n  let bitangentIndex = 0;\n  let recomputeNormal = true;\n\n  let bitangent = bitangentScratch;\n  let tangent = tangentScratch;\n  let normal = normalScratch;\n  if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n    for (let i = 0; i < length; i += 6) {\n      const p = Cartesian3.fromArray(positions, i, positionScratch);\n      const p1 = Cartesian3.fromArray(positions, (i + 6) % length, v1Scratch);\n      if (recomputeNormal) {\n        const p2 = Cartesian3.fromArray(positions, (i + 3) % length, v2Scratch);\n        Cartesian3.subtract(p1, p, p1);\n        Cartesian3.subtract(p2, p, p2);\n        normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\n        recomputeNormal = false;\n      }\n\n      if (Cartesian3.equalsEpsilon(p1, p, CesiumMath.EPSILON10)) {\n        // if we've reached a corner\n        recomputeNormal = true;\n      }\n\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        bitangent = ellipsoid.geodeticSurfaceNormal(p, bitangent);\n        if (vertexFormat.tangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(bitangent, normal, tangent),\n            tangent,\n          );\n        }\n      }\n\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n      }\n\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n      }\n\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n      }\n    }\n  }\n\n  return createAttributes(vertexFormat, {\n    positions: positions,\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents,\n  });\n}\n\nfunction constructRectangle(rectangleGeometry, computedOptions) {\n  const vertexFormat = rectangleGeometry._vertexFormat;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n  const northCap = computedOptions.northCap;\n  const southCap = computedOptions.southCap;\n\n  let rowStart = 0;\n  let rowEnd = height;\n  let rowHeight = height;\n  let size = 0;\n  if (northCap) {\n    rowStart = 1;\n    rowHeight -= 1;\n    size += 1;\n  }\n  if (southCap) {\n    rowEnd -= 1;\n    rowHeight -= 1;\n    size += 1;\n  }\n  size += width * rowHeight;\n\n  const positions = vertexFormat.position\n    ? new Float64Array(size * 3)\n    : undefined;\n  const textureCoordinates = vertexFormat.st\n    ? new Float32Array(size * 2)\n    : undefined;\n\n  let posIndex = 0;\n  let stIndex = 0;\n\n  const position = positionScratch;\n  const st = stScratch;\n\n  let minX = Number.MAX_VALUE;\n  let minY = Number.MAX_VALUE;\n  let maxX = -Number.MAX_VALUE;\n  let maxY = -Number.MAX_VALUE;\n\n  for (let row = rowStart; row < rowEnd; ++row) {\n    for (let col = 0; col < width; ++col) {\n      RectangleGeometryLibrary.computePosition(\n        computedOptions,\n        ellipsoid,\n        vertexFormat.st,\n        row,\n        col,\n        position,\n        st,\n      );\n\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n\n      if (vertexFormat.st) {\n        textureCoordinates[stIndex++] = st.x;\n        textureCoordinates[stIndex++] = st.y;\n\n        minX = Math.min(minX, st.x);\n        minY = Math.min(minY, st.y);\n        maxX = Math.max(maxX, st.x);\n        maxY = Math.max(maxY, st.y);\n      }\n    }\n  }\n  if (northCap) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      vertexFormat.st,\n      0,\n      0,\n      position,\n      st,\n    );\n\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n\n    if (vertexFormat.st) {\n      textureCoordinates[stIndex++] = st.x;\n      textureCoordinates[stIndex++] = st.y;\n\n      minX = st.x;\n      minY = st.y;\n      maxX = st.x;\n      maxY = st.y;\n    }\n  }\n  if (southCap) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      vertexFormat.st,\n      height - 1,\n      0,\n      position,\n      st,\n    );\n\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex] = position.z;\n\n    if (vertexFormat.st) {\n      textureCoordinates[stIndex++] = st.x;\n      textureCoordinates[stIndex] = st.y;\n\n      minX = Math.min(minX, st.x);\n      minY = Math.min(minY, st.y);\n      maxX = Math.max(maxX, st.x);\n      maxY = Math.max(maxY, st.y);\n    }\n  }\n\n  if (\n    vertexFormat.st &&\n    (minX < 0.0 || minY < 0.0 || maxX > 1.0 || maxY > 1.0)\n  ) {\n    for (let k = 0; k < textureCoordinates.length; k += 2) {\n      textureCoordinates[k] = (textureCoordinates[k] - minX) / (maxX - minX);\n      textureCoordinates[k + 1] =\n        (textureCoordinates[k + 1] - minY) / (maxY - minY);\n    }\n  }\n\n  const geo = calculateAttributes(\n    positions,\n    vertexFormat,\n    ellipsoid,\n    computedOptions.tangentRotationMatrix,\n  );\n\n  let indicesSize = 6 * (width - 1) * (rowHeight - 1);\n  if (northCap) {\n    indicesSize += 3 * (width - 1);\n  }\n  if (southCap) {\n    indicesSize += 3 * (width - 1);\n  }\n  const indices = IndexDatatype.createTypedArray(size, indicesSize);\n  let index = 0;\n  let indicesIndex = 0;\n  let i;\n  for (i = 0; i < rowHeight - 1; ++i) {\n    for (let j = 0; j < width - 1; ++j) {\n      const upperLeft = index;\n      const lowerLeft = upperLeft + width;\n      const lowerRight = lowerLeft + 1;\n      const upperRight = upperLeft + 1;\n      indices[indicesIndex++] = upperLeft;\n      indices[indicesIndex++] = lowerLeft;\n      indices[indicesIndex++] = upperRight;\n      indices[indicesIndex++] = upperRight;\n      indices[indicesIndex++] = lowerLeft;\n      indices[indicesIndex++] = lowerRight;\n      ++index;\n    }\n    ++index;\n  }\n  if (northCap || southCap) {\n    let northIndex = size - 1;\n    const southIndex = size - 1;\n    if (northCap && southCap) {\n      northIndex = size - 2;\n    }\n\n    let p1;\n    let p2;\n    index = 0;\n\n    if (northCap) {\n      for (i = 0; i < width - 1; i++) {\n        p1 = index;\n        p2 = p1 + 1;\n        indices[indicesIndex++] = northIndex;\n        indices[indicesIndex++] = p1;\n        indices[indicesIndex++] = p2;\n        ++index;\n      }\n    }\n    if (southCap) {\n      index = (rowHeight - 1) * width;\n      for (i = 0; i < width - 1; i++) {\n        p1 = index;\n        p2 = p1 + 1;\n        indices[indicesIndex++] = p1;\n        indices[indicesIndex++] = southIndex;\n        indices[indicesIndex++] = p2;\n        ++index;\n      }\n    }\n  }\n\n  geo.indices = indices;\n  if (vertexFormat.st) {\n    geo.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  return geo;\n}\n\nfunction addWallPositions(\n  wallPositions,\n  posIndex,\n  i,\n  topPositions,\n  bottomPositions,\n) {\n  wallPositions[posIndex++] = topPositions[i];\n  wallPositions[posIndex++] = topPositions[i + 1];\n  wallPositions[posIndex++] = topPositions[i + 2];\n  wallPositions[posIndex++] = bottomPositions[i];\n  wallPositions[posIndex++] = bottomPositions[i + 1];\n  wallPositions[posIndex] = bottomPositions[i + 2];\n  return wallPositions;\n}\n\nfunction addWallTextureCoordinates(wallTextures, stIndex, i, st) {\n  wallTextures[stIndex++] = st[i];\n  wallTextures[stIndex++] = st[i + 1];\n  wallTextures[stIndex++] = st[i];\n  wallTextures[stIndex] = st[i + 1];\n  return wallTextures;\n}\n\nconst scratchVertexFormat = new VertexFormat();\n\nfunction constructExtrudedRectangle(rectangleGeometry, computedOptions) {\n  const shadowVolume = rectangleGeometry._shadowVolume;\n  const offsetAttributeValue = rectangleGeometry._offsetAttribute;\n  const vertexFormat = rectangleGeometry._vertexFormat;\n  const minHeight = rectangleGeometry._extrudedHeight;\n  const maxHeight = rectangleGeometry._surfaceHeight;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n\n  let i;\n\n  if (shadowVolume) {\n    const newVertexFormat = VertexFormat.clone(\n      vertexFormat,\n      scratchVertexFormat,\n    );\n    newVertexFormat.normal = true;\n    rectangleGeometry._vertexFormat = newVertexFormat;\n  }\n\n  const topBottomGeo = constructRectangle(rectangleGeometry, computedOptions);\n\n  if (shadowVolume) {\n    rectangleGeometry._vertexFormat = vertexFormat;\n  }\n\n  let topPositions = PolygonPipeline.scaleToGeodeticHeight(\n    topBottomGeo.attributes.position.values,\n    maxHeight,\n    ellipsoid,\n    false,\n  );\n  topPositions = new Float64Array(topPositions);\n  let length = topPositions.length;\n  const newLength = length * 2;\n  const positions = new Float64Array(newLength);\n  positions.set(topPositions);\n  const bottomPositions = PolygonPipeline.scaleToGeodeticHeight(\n    topBottomGeo.attributes.position.values,\n    minHeight,\n    ellipsoid,\n  );\n  positions.set(bottomPositions, length);\n  topBottomGeo.attributes.position.values = positions;\n\n  const normals = vertexFormat.normal ? new Float32Array(newLength) : undefined;\n  const tangents = vertexFormat.tangent\n    ? new Float32Array(newLength)\n    : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(newLength)\n    : undefined;\n  const textures = vertexFormat.st\n    ? new Float32Array((newLength / 3) * 2)\n    : undefined;\n  let topSt;\n  let topNormals;\n  if (vertexFormat.normal) {\n    topNormals = topBottomGeo.attributes.normal.values;\n    normals.set(topNormals);\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n    normals.set(topNormals, length);\n    topBottomGeo.attributes.normal.values = normals;\n  }\n  if (shadowVolume) {\n    topNormals = topBottomGeo.attributes.normal.values;\n    if (!vertexFormat.normal) {\n      topBottomGeo.attributes.normal = undefined;\n    }\n    const extrudeNormals = new Float32Array(newLength);\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n    extrudeNormals.set(topNormals, length); //only get normals for bottom layer that's going to be pushed down\n    topBottomGeo.attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n  }\n\n  let offsetValue;\n  const hasOffsets = defined(offsetAttributeValue);\n  if (hasOffsets) {\n    const size = (length / 3) * 2;\n    let offsetAttribute = new Uint8Array(size);\n    if (offsetAttributeValue === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n    } else {\n      offsetValue =\n        offsetAttributeValue === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = offsetAttribute.fill(offsetValue);\n    }\n\n    topBottomGeo.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    const topTangents = topBottomGeo.attributes.tangent.values;\n    tangents.set(topTangents);\n    for (i = 0; i < length; i++) {\n      topTangents[i] = -topTangents[i];\n    }\n    tangents.set(topTangents, length);\n    topBottomGeo.attributes.tangent.values = tangents;\n  }\n  if (vertexFormat.bitangent) {\n    const topBitangents = topBottomGeo.attributes.bitangent.values;\n    bitangents.set(topBitangents);\n    bitangents.set(topBitangents, length);\n    topBottomGeo.attributes.bitangent.values = bitangents;\n  }\n  if (vertexFormat.st) {\n    topSt = topBottomGeo.attributes.st.values;\n    textures.set(topSt);\n    textures.set(topSt, (length / 3) * 2);\n    topBottomGeo.attributes.st.values = textures;\n  }\n\n  const indices = topBottomGeo.indices;\n  const indicesLength = indices.length;\n  const posLength = length / 3;\n  const newIndices = IndexDatatype.createTypedArray(\n    newLength / 3,\n    indicesLength * 2,\n  );\n  newIndices.set(indices);\n  for (i = 0; i < indicesLength; i += 3) {\n    newIndices[i + indicesLength] = indices[i + 2] + posLength;\n    newIndices[i + 1 + indicesLength] = indices[i + 1] + posLength;\n    newIndices[i + 2 + indicesLength] = indices[i] + posLength;\n  }\n  topBottomGeo.indices = newIndices;\n\n  const northCap = computedOptions.northCap;\n  const southCap = computedOptions.southCap;\n\n  let rowHeight = height;\n  let widthMultiplier = 2;\n  let perimeterPositions = 0;\n  let corners = 4;\n  let dupliateCorners = 4;\n  if (northCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    perimeterPositions += 1;\n    corners -= 2;\n    dupliateCorners -= 1;\n  }\n  if (southCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    perimeterPositions += 1;\n    corners -= 2;\n    dupliateCorners -= 1;\n  }\n  perimeterPositions += widthMultiplier * width + 2 * rowHeight - corners;\n\n  const wallCount = (perimeterPositions + dupliateCorners) * 2;\n\n  let wallPositions = new Float64Array(wallCount * 3);\n  const wallExtrudeNormals = shadowVolume\n    ? new Float32Array(wallCount * 3)\n    : undefined;\n  let wallOffsetAttribute = hasOffsets ? new Uint8Array(wallCount) : undefined;\n  let wallTextures = vertexFormat.st\n    ? new Float32Array(wallCount * 2)\n    : undefined;\n\n  const computeTopOffsets =\n    offsetAttributeValue === GeometryOffsetAttribute.TOP;\n  if (hasOffsets && !computeTopOffsets) {\n    offsetValue = offsetAttributeValue === GeometryOffsetAttribute.ALL ? 1 : 0;\n    wallOffsetAttribute = wallOffsetAttribute.fill(offsetValue);\n  }\n\n  let posIndex = 0;\n  let stIndex = 0;\n  let extrudeNormalIndex = 0;\n  let wallOffsetIndex = 0;\n  const area = width * rowHeight;\n  let threeI;\n  for (i = 0; i < area; i += width) {\n    threeI = i * 3;\n    wallPositions = addWallPositions(\n      wallPositions,\n      posIndex,\n      threeI,\n      topPositions,\n      bottomPositions,\n    );\n    posIndex += 6;\n    if (vertexFormat.st) {\n      wallTextures = addWallTextureCoordinates(\n        wallTextures,\n        stIndex,\n        i * 2,\n        topSt,\n      );\n      stIndex += 4;\n    }\n    if (shadowVolume) {\n      extrudeNormalIndex += 3;\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n    }\n    if (computeTopOffsets) {\n      wallOffsetAttribute[wallOffsetIndex++] = 1;\n      wallOffsetIndex += 1;\n    }\n  }\n\n  if (!southCap) {\n    for (i = area - width; i < area; i++) {\n      threeI = i * 3;\n      wallPositions = addWallPositions(\n        wallPositions,\n        posIndex,\n        threeI,\n        topPositions,\n        bottomPositions,\n      );\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(\n          wallTextures,\n          stIndex,\n          i * 2,\n          topSt,\n        );\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  } else {\n    const southIndex = northCap ? area + 1 : area;\n    threeI = southIndex * 3;\n\n    for (i = 0; i < 2; i++) {\n      // duplicate corner points\n      wallPositions = addWallPositions(\n        wallPositions,\n        posIndex,\n        threeI,\n        topPositions,\n        bottomPositions,\n      );\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(\n          wallTextures,\n          stIndex,\n          southIndex * 2,\n          topSt,\n        );\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  }\n\n  for (i = area - 1; i > 0; i -= width) {\n    threeI = i * 3;\n    wallPositions = addWallPositions(\n      wallPositions,\n      posIndex,\n      threeI,\n      topPositions,\n      bottomPositions,\n    );\n    posIndex += 6;\n    if (vertexFormat.st) {\n      wallTextures = addWallTextureCoordinates(\n        wallTextures,\n        stIndex,\n        i * 2,\n        topSt,\n      );\n      stIndex += 4;\n    }\n    if (shadowVolume) {\n      extrudeNormalIndex += 3;\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n    }\n    if (computeTopOffsets) {\n      wallOffsetAttribute[wallOffsetIndex++] = 1;\n      wallOffsetIndex += 1;\n    }\n  }\n\n  if (!northCap) {\n    for (i = width - 1; i >= 0; i--) {\n      threeI = i * 3;\n      wallPositions = addWallPositions(\n        wallPositions,\n        posIndex,\n        threeI,\n        topPositions,\n        bottomPositions,\n      );\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(\n          wallTextures,\n          stIndex,\n          i * 2,\n          topSt,\n        );\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  } else {\n    const northIndex = area;\n    threeI = northIndex * 3;\n\n    for (i = 0; i < 2; i++) {\n      // duplicate corner points\n      wallPositions = addWallPositions(\n        wallPositions,\n        posIndex,\n        threeI,\n        topPositions,\n        bottomPositions,\n      );\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(\n          wallTextures,\n          stIndex,\n          northIndex * 2,\n          topSt,\n        );\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  }\n\n  let geo = calculateAttributesWall(wallPositions, vertexFormat, ellipsoid);\n\n  if (vertexFormat.st) {\n    geo.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: wallTextures,\n    });\n  }\n  if (shadowVolume) {\n    geo.attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: wallExtrudeNormals,\n    });\n  }\n  if (hasOffsets) {\n    geo.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: wallOffsetAttribute,\n    });\n  }\n\n  const wallIndices = IndexDatatype.createTypedArray(\n    wallCount,\n    perimeterPositions * 6,\n  );\n\n  let upperLeft;\n  let lowerLeft;\n  let lowerRight;\n  let upperRight;\n  length = wallPositions.length / 3;\n  let index = 0;\n  for (i = 0; i < length - 1; i += 2) {\n    upperLeft = i;\n    upperRight = (upperLeft + 2) % length;\n    const p1 = Cartesian3.fromArray(wallPositions, upperLeft * 3, v1Scratch);\n    const p2 = Cartesian3.fromArray(wallPositions, upperRight * 3, v2Scratch);\n    if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON10)) {\n      continue;\n    }\n    lowerLeft = (upperLeft + 1) % length;\n    lowerRight = (lowerLeft + 2) % length;\n    wallIndices[index++] = upperLeft;\n    wallIndices[index++] = lowerLeft;\n    wallIndices[index++] = upperRight;\n    wallIndices[index++] = upperRight;\n    wallIndices[index++] = lowerLeft;\n    wallIndices[index++] = lowerRight;\n  }\n\n  geo.indices = wallIndices;\n\n  geo = GeometryPipeline.combineInstances([\n    new GeometryInstance({\n      geometry: topBottomGeo,\n    }),\n    new GeometryInstance({\n      geometry: geo,\n    }),\n  ]);\n\n  return geo[0];\n}\n\nconst scratchRectanglePoints = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\nconst nwScratch = new Cartographic();\nconst stNwScratch = new Cartographic();\nfunction computeRectangle(rectangle, granularity, rotation, ellipsoid, result) {\n  if (rotation === 0.0) {\n    return Rectangle.clone(rectangle, result);\n  }\n\n  const computedOptions = RectangleGeometryLibrary.computeOptions(\n    rectangle,\n    granularity,\n    rotation,\n    0,\n    rectangleScratch,\n    nwScratch,\n  );\n\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n\n  const positions = scratchRectanglePoints;\n  RectangleGeometryLibrary.computePosition(\n    computedOptions,\n    ellipsoid,\n    false,\n    0,\n    0,\n    positions[0],\n  );\n  RectangleGeometryLibrary.computePosition(\n    computedOptions,\n    ellipsoid,\n    false,\n    0,\n    width - 1,\n    positions[1],\n  );\n  RectangleGeometryLibrary.computePosition(\n    computedOptions,\n    ellipsoid,\n    false,\n    height - 1,\n    0,\n    positions[2],\n  );\n  RectangleGeometryLibrary.computePosition(\n    computedOptions,\n    ellipsoid,\n    false,\n    height - 1,\n    width - 1,\n    positions[3],\n  );\n\n  return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n}\n\n/**\n * A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias RectangleGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the rectangle lies.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\n * @param {number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\n *\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>options.rectangle.south</code>.\n *\n * @see RectangleGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Rectangle.html|Cesium Sandcastle Rectangle Demo}\n *\n * @example\n * // 1. create a rectangle\n * const rectangle = new Cesium.RectangleGeometry({\n *   ellipsoid : Cesium.Ellipsoid.default,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * const geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n *\n * // 2. create an extruded rectangle without a top\n * const rectangle = new Cesium.RectangleGeometry({\n *   ellipsoid : Cesium.Ellipsoid.default,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0,\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n */\nfunction RectangleGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const rectangle = options.rectangle;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Rectangle._validate(rectangle);\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\n      \"options.rectangle.north must be greater than or equal to options.rectangle.south\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const height = options.height ?? 0.0;\n  const extrudedHeight = options.extrudedHeight ?? height;\n\n  this._rectangle = Rectangle.clone(rectangle);\n  this._granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  this._ellipsoid = Ellipsoid.clone(options.ellipsoid ?? Ellipsoid.default);\n  this._surfaceHeight = Math.max(height, extrudedHeight);\n  this._rotation = options.rotation ?? 0.0;\n  this._stRotation = options.stRotation ?? 0.0;\n  this._vertexFormat = VertexFormat.clone(\n    options.vertexFormat ?? VertexFormat.DEFAULT,\n  );\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._shadowVolume = options.shadowVolume ?? false;\n  this._workerName = \"createRectangleGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._rotatedRectangle = undefined;\n\n  this._textureCoordinateRotationPoints = undefined;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nRectangleGeometry.packedLength =\n  Rectangle.packedLength +\n  Ellipsoid.packedLength +\n  VertexFormat.packedLength +\n  7;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {RectangleGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nRectangleGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  Rectangle.pack(value._rectangle, array, startingIndex);\n  startingIndex += Rectangle.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._surfaceHeight;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = value._offsetAttribute ?? -1;\n\n  return array;\n};\n\nconst scratchRectangle = new Rectangle();\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchOptions = {\n  rectangle: scratchRectangle,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  granularity: undefined,\n  height: undefined,\n  rotation: undefined,\n  stRotation: undefined,\n  extrudedHeight: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {RectangleGeometry} [result] The object into which to store the result.\n * @returns {RectangleGeometry} The modified result parameter or a new RectangleGeometry instance if one was not provided.\n */\nRectangleGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n  startingIndex += Rectangle.packedLength;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const granularity = array[startingIndex++];\n  const surfaceHeight = array[startingIndex++];\n  const rotation = array[startingIndex++];\n  const stRotation = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const shadowVolume = array[startingIndex++] === 1.0;\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.granularity = granularity;\n    scratchOptions.height = surfaceHeight;\n    scratchOptions.rotation = rotation;\n    scratchOptions.stRotation = stRotation;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new RectangleGeometry(scratchOptions);\n  }\n\n  result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._granularity = granularity;\n  result._surfaceHeight = surfaceHeight;\n  result._rotation = rotation;\n  result._stRotation = stRotation;\n  result._extrudedHeight = extrudedHeight;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the bounding rectangle based on the provided options\n *\n * @param {object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the rectangle lies.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle\n */\nRectangleGeometry.computeRectangle = function (options, result) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const rectangle = options.rectangle;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Rectangle._validate(rectangle);\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\n      \"options.rectangle.north must be greater than or equal to options.rectangle.south\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  const rotation = options.rotation ?? 0.0;\n\n  return computeRectangle(rectangle, granularity, rotation, ellipsoid, result);\n};\n\nconst tangentRotationMatrixScratch = new Matrix3();\nconst quaternionScratch = new Quaternion();\nconst centerScratch = new Cartographic();\n/**\n * Computes the geometric representation of a rectangle, including its vertices, indices, and a bounding sphere.\n *\n * @param {RectangleGeometry} rectangleGeometry A description of the rectangle.\n * @returns {Geometry|undefined} The computed vertices and indices.\n *\n * @exception {DeveloperError} Rotated rectangle is invalid.\n */\nRectangleGeometry.createGeometry = function (rectangleGeometry) {\n  if (\n    CesiumMath.equalsEpsilon(\n      rectangleGeometry._rectangle.north,\n      rectangleGeometry._rectangle.south,\n      CesiumMath.EPSILON10,\n    ) ||\n    CesiumMath.equalsEpsilon(\n      rectangleGeometry._rectangle.east,\n      rectangleGeometry._rectangle.west,\n      CesiumMath.EPSILON10,\n    )\n  ) {\n    return undefined;\n  }\n\n  let rectangle = rectangleGeometry._rectangle;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n  const rotation = rectangleGeometry._rotation;\n  const stRotation = rectangleGeometry._stRotation;\n  const vertexFormat = rectangleGeometry._vertexFormat;\n\n  const computedOptions = RectangleGeometryLibrary.computeOptions(\n    rectangle,\n    rectangleGeometry._granularity,\n    rotation,\n    stRotation,\n    rectangleScratch,\n    nwScratch,\n    stNwScratch,\n  );\n\n  const tangentRotationMatrix = tangentRotationMatrixScratch;\n  if (stRotation !== 0 || rotation !== 0) {\n    const center = Rectangle.center(rectangle, centerScratch);\n    const axis = ellipsoid.geodeticSurfaceNormalCartographic(center, v1Scratch);\n    Quaternion.fromAxisAngle(axis, -stRotation, quaternionScratch);\n    Matrix3.fromQuaternion(quaternionScratch, tangentRotationMatrix);\n  } else {\n    Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\n  }\n\n  const surfaceHeight = rectangleGeometry._surfaceHeight;\n  const extrudedHeight = rectangleGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    surfaceHeight,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2,\n  );\n\n  computedOptions.lonScalar = 1.0 / rectangleGeometry._rectangle.width;\n  computedOptions.latScalar = 1.0 / rectangleGeometry._rectangle.height;\n  computedOptions.tangentRotationMatrix = tangentRotationMatrix;\n\n  let geometry;\n  let boundingSphere;\n  rectangle = rectangleGeometry._rectangle;\n  if (extrude) {\n    geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\n    const topBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight,\n      topBoundingSphere,\n    );\n    const bottomBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      extrudedHeight,\n      bottomBoundingSphere,\n    );\n    boundingSphere = BoundingSphere.union(topBS, bottomBS);\n  } else {\n    geometry = constructRectangle(rectangleGeometry, computedOptions);\n    geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      geometry.attributes.position.values,\n      surfaceHeight,\n      ellipsoid,\n      false,\n    );\n\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      const length = geometry.attributes.position.values.length;\n      const offsetValue =\n        rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n\n    boundingSphere = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight,\n    );\n  }\n\n  if (!vertexFormat.position) {\n    delete geometry.attributes.position;\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: rectangleGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nRectangleGeometry.createShadowVolume = function (\n  rectangleGeometry,\n  minHeightFunc,\n  maxHeightFunc,\n) {\n  const granularity = rectangleGeometry._granularity;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n\n  const minHeight = minHeightFunc(granularity, ellipsoid);\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new RectangleGeometry({\n    rectangle: rectangleGeometry._rectangle,\n    rotation: rectangleGeometry._rotation,\n    ellipsoid: ellipsoid,\n    stRotation: rectangleGeometry._stRotation,\n    granularity: granularity,\n    extrudedHeight: maxHeight,\n    height: minHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n  });\n};\n\nconst unrotatedTextureRectangleScratch = new Rectangle();\nconst points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\nconst rotation2DScratch = new Matrix2();\nconst rectangleCenterScratch = new Cartographic();\n\nfunction textureCoordinateRotationPoints(rectangleGeometry) {\n  if (rectangleGeometry._stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n\n  const rectangle = Rectangle.clone(\n    rectangleGeometry._rectangle,\n    unrotatedTextureRectangleScratch,\n  );\n  const granularity = rectangleGeometry._granularity;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n\n  // Rotate to align the texture coordinates with ENU\n  const rotation = rectangleGeometry._rotation - rectangleGeometry._stRotation;\n\n  const unrotatedTextureRectangle = computeRectangle(\n    rectangle,\n    granularity,\n    rotation,\n    ellipsoid,\n    unrotatedTextureRectangleScratch,\n  );\n\n  // Assume a computed \"east-north\" texture coordinate system based on spherical or planar tricks, bounded by `boundingRectangle`.\n  // The \"desired\" texture coordinate system forms an oriented rectangle (un-oriented computed) around the geometry that completely and tightly bounds it.\n  // We want to map from the \"east-north\" texture coordinate system into the \"desired\" system using a pair of lines (analagous planes in 2D)\n  // Compute 3 corners of the \"desired\" texture coordinate system in \"east-north\" texture space by the following in cartographic space:\n  // - rotate 3 of the corners in unrotatedTextureRectangle by stRotation around the center of the bounding rectangle\n  // - apply the \"east-north\" system's normalization formula to the rotated cartographics, even though this is likely to produce values outside [0-1].\n  // This gives us a set of points in the \"east-north\" texture coordinate system that can be used to map \"east-north\" texture coordinates to \"desired.\"\n\n  const points2D = points2DScratch;\n  points2D[0].x = unrotatedTextureRectangle.west;\n  points2D[0].y = unrotatedTextureRectangle.south;\n\n  points2D[1].x = unrotatedTextureRectangle.west;\n  points2D[1].y = unrotatedTextureRectangle.north;\n\n  points2D[2].x = unrotatedTextureRectangle.east;\n  points2D[2].y = unrotatedTextureRectangle.south;\n\n  const boundingRectangle = rectangleGeometry.rectangle;\n  const toDesiredInComputed = Matrix2.fromRotation(\n    rectangleGeometry._stRotation,\n    rotation2DScratch,\n  );\n  const boundingRectangleCenter = Rectangle.center(\n    boundingRectangle,\n    rectangleCenterScratch,\n  );\n\n  for (let i = 0; i < 3; ++i) {\n    const point2D = points2D[i];\n    point2D.x -= boundingRectangleCenter.longitude;\n    point2D.y -= boundingRectangleCenter.latitude;\n    Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\n    point2D.x += boundingRectangleCenter.longitude;\n    point2D.y += boundingRectangleCenter.latitude;\n\n    // Convert point into east-north texture coordinate space\n    point2D.x = (point2D.x - boundingRectangle.west) / boundingRectangle.width;\n    point2D.y =\n      (point2D.y - boundingRectangle.south) / boundingRectangle.height;\n  }\n\n  const minXYCorner = points2D[0];\n  const maxYCorner = points2D[1];\n  const maxXCorner = points2D[2];\n  const result = new Array(6);\n  Cartesian2.pack(minXYCorner, result);\n  Cartesian2.pack(maxYCorner, result, 2);\n  Cartesian2.pack(maxXCorner, result, 4);\n  return result;\n}\n\nObject.defineProperties(RectangleGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rotatedRectangle)) {\n        this._rotatedRectangle = computeRectangle(\n          this._rectangle,\n          this._granularity,\n          this._rotation,\n          this._ellipsoid,\n        );\n      }\n      return this._rotatedRectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering RectangleGeometries as GroundPrimitives.\n   * This version permits skew in textures by computing offsets directly in cartographic space and\n   * more accurately approximates rendering RectangleGeometries with height as standard Primitives.\n   * @see Geometry#_textureCoordinateRotationPoints\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints =\n          textureCoordinateRotationPoints(this);\n      }\n      return this._textureCoordinateRotationPoints;\n    },\n  },\n});\nexport default RectangleGeometry;\n"],"names":["positionScratch","normalScratch","tangentScratch","bitangentScratch","rectangleScratch","stScratch","bottomBoundingSphere","topBoundingSphere","createAttributes","vertexFormat","attributes","geo","primitiveType","TRIANGLES","position","componentDatatype","DOUBLE","componentsPerAttribute","values","positions","normal","FLOAT","normals","tangent","tangents","bitangent","bitangents","calculateAttributes","ellipsoid","tangentRotationMatrix","length","Float32Array","undefined","attrIndex","i","p","fromArray","attrIndex1","attrIndex2","geodeticSurfaceNormal","cross","UNIT_Z","multiplyByVector","normalize","x","y","z","v1Scratch","v2Scratch","calculateAttributesWall","normalIndex","tangentIndex","bitangentIndex","recomputeNormal","p1","p2","subtract","equalsEpsilon","EPSILON10","constructRectangle","rectangleGeometry","computedOptions","_vertexFormat","_ellipsoid","height","width","northCap","southCap","rowStart","rowEnd","rowHeight","size","Float64Array","textureCoordinates","st","posIndex","stIndex","minX","Number","MAX_VALUE","minY","maxX","maxY","row","col","computePosition","Math","min","max","k","indicesSize","indices","createTypedArray","index","indicesIndex","j","upperLeft","lowerLeft","lowerRight","upperRight","northIndex","southIndex","addWallPositions","wallPositions","topPositions","bottomPositions","addWallTextureCoordinates","wallTextures","scratchVertexFormat","constructExtrudedRectangle","shadowVolume","_shadowVolume","offsetAttributeValue","_offsetAttribute","minHeight","_extrudedHeight","maxHeight","_surfaceHeight","newVertexFormat","clone","topBottomGeo","scaleToGeodeticHeight","newLength","set","textures","topSt","topNormals","extrudeNormals","extrudeDirection","offsetValue","hasOffsets","offsetAttribute","Uint8Array","TOP","fill","NONE","applyOffset","UNSIGNED_BYTE","topTangents","topBitangents","indicesLength","posLength","newIndices","widthMultiplier","perimeterPositions","corners","dupliateCorners","wallCount","wallExtrudeNormals","wallOffsetAttribute","computeTopOffsets","ALL","extrudeNormalIndex","wallOffsetIndex","area","threeI","wallIndices","combineInstances","geometry","scratchRectanglePoints","nwScratch","stNwScratch","computeRectangle","rectangle","granularity","rotation","result","computeOptions","fromCartesianArray","RectangleGeometry","options","EMPTY_OBJECT","typeOf","object","_validate","north","south","extrudedHeight","_rectangle","_granularity","RADIANS_PER_DEGREE","default","_rotation","_stRotation","stRotation","DEFAULT","_workerName","_rotatedRectangle","_textureCoordinateRotationPoints","packedLength","pack","value","array","startingIndex","defined","scratchRectangle","scratchEllipsoid","UNIT_SPHERE","scratchOptions","unpack","surfaceHeight","tangentRotationMatrixScratch","quaternionScratch","centerScratch","createGeometry","east","west","center","axis","geodeticSurfaceNormalCartographic","fromAxisAngle","fromQuaternion","IDENTITY","extrude","EPSILON2","lonScalar","latScalar","boundingSphere","topBS","fromRectangle3D","bottomBS","union","createShadowVolume","minHeightFunc","maxHeightFunc","POSITION_ONLY","unrotatedTextureRectangleScratch","points2DScratch","rotation2DScratch","rectangleCenterScratch","textureCoordinateRotationPoints","unrotatedTextureRectangle","points2D","boundingRectangle","toDesiredInComputed","fromRotation","boundingRectangleCenter","point2D","longitude","latitude","minXYCorner","maxYCorner","maxXCorner","Array","Object","defineProperties","prototype","get"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 47004, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/RectangleOutlineGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport RectangleGeometryLibrary from \"./RectangleGeometryLibrary.js\";\n\nconst bottomBoundingSphere = new BoundingSphere();\nconst topBoundingSphere = new BoundingSphere();\nconst positionScratch = new Cartesian3();\nconst rectangleScratch = new Rectangle();\n\nfunction constructRectangle(geometry, computedOptions) {\n  const ellipsoid = geometry._ellipsoid;\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n  const northCap = computedOptions.northCap;\n  const southCap = computedOptions.southCap;\n\n  let rowHeight = height;\n  let widthMultiplier = 2;\n  let size = 0;\n  let corners = 4;\n  if (northCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    size += 1;\n    corners -= 2;\n  }\n  if (southCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    size += 1;\n    corners -= 2;\n  }\n  size += widthMultiplier * width + 2 * rowHeight - corners;\n\n  const positions = new Float64Array(size * 3);\n\n  let posIndex = 0;\n  let row = 0;\n  let col;\n  const position = positionScratch;\n  if (northCap) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      false,\n      row,\n      0,\n      position,\n    );\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  } else {\n    for (col = 0; col < width; col++) {\n      RectangleGeometryLibrary.computePosition(\n        computedOptions,\n        ellipsoid,\n        false,\n        row,\n        col,\n        position,\n      );\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n    }\n  }\n\n  col = width - 1;\n  for (row = 1; row < height; row++) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      false,\n      row,\n      col,\n      position,\n    );\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  }\n\n  row = height - 1;\n  if (!southCap) {\n    // if southCap is true, we dont need to add any more points because the south pole point was added by the iteration above\n    for (col = width - 2; col >= 0; col--) {\n      RectangleGeometryLibrary.computePosition(\n        computedOptions,\n        ellipsoid,\n        false,\n        row,\n        col,\n        position,\n      );\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n    }\n  }\n\n  col = 0;\n  for (row = height - 2; row > 0; row--) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      false,\n      row,\n      col,\n      position,\n    );\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  }\n\n  const indicesSize = (positions.length / 3) * 2;\n  const indices = IndexDatatype.createTypedArray(\n    positions.length / 3,\n    indicesSize,\n  );\n\n  let index = 0;\n  for (let i = 0; i < positions.length / 3 - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n  indices[index++] = positions.length / 3 - 1;\n  indices[index++] = 0;\n\n  const geo = new Geometry({\n    attributes: new GeometryAttributes(),\n    primitiveType: PrimitiveType.LINES,\n  });\n\n  geo.attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n  geo.indices = indices;\n\n  return geo;\n}\n\nfunction constructExtrudedRectangle(rectangleGeometry, computedOptions) {\n  const maxHeight = rectangleGeometry._surfaceHeight;\n  const minHeight = rectangleGeometry._extrudedHeight;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n  const geo = constructRectangle(rectangleGeometry, computedOptions);\n\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n\n  const topPositions = PolygonPipeline.scaleToGeodeticHeight(\n    geo.attributes.position.values,\n    maxHeight,\n    ellipsoid,\n    false,\n  );\n  let length = topPositions.length;\n  const positions = new Float64Array(length * 2);\n  positions.set(topPositions);\n  const bottomPositions = PolygonPipeline.scaleToGeodeticHeight(\n    geo.attributes.position.values,\n    minHeight,\n    ellipsoid,\n  );\n  positions.set(bottomPositions, length);\n  geo.attributes.position.values = positions;\n\n  const northCap = computedOptions.northCap;\n  const southCap = computedOptions.southCap;\n  let corners = 4;\n  if (northCap) {\n    corners -= 1;\n  }\n  if (southCap) {\n    corners -= 1;\n  }\n\n  const indicesSize = (positions.length / 3 + corners) * 2;\n  const indices = IndexDatatype.createTypedArray(\n    positions.length / 3,\n    indicesSize,\n  );\n  length = positions.length / 6;\n  let index = 0;\n  for (let i = 0; i < length - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n    indices[index++] = i + length;\n    indices[index++] = i + length + 1;\n  }\n  indices[index++] = length - 1;\n  indices[index++] = 0;\n  indices[index++] = length + length - 1;\n  indices[index++] = length;\n\n  indices[index++] = 0;\n  indices[index++] = length;\n\n  let bottomCorner;\n  if (northCap) {\n    bottomCorner = height - 1;\n  } else {\n    const topRightCorner = width - 1;\n    indices[index++] = topRightCorner;\n    indices[index++] = topRightCorner + length;\n    bottomCorner = width + height - 2;\n  }\n\n  indices[index++] = bottomCorner;\n  indices[index++] = bottomCorner + length;\n\n  if (!southCap) {\n    const bottomLeftCorner = width + bottomCorner - 1;\n    indices[index++] = bottomLeftCorner;\n    indices[index] = bottomLeftCorner + length;\n  }\n\n  geo.indices = indices;\n\n  return geo;\n}\n\n/**\n * A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.\n *\n * @alias RectangleOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the rectangle lies.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\n * @param {number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\n *\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>rectangle.south</code>.\n *\n * @see RectangleOutlineGeometry#createGeometry\n *\n * @example\n * const rectangle = new Cesium.RectangleOutlineGeometry({\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * const geometry = Cesium.RectangleOutlineGeometry.createGeometry(rectangle);\n */\nfunction RectangleOutlineGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const rectangle = options.rectangle;\n  const granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  const rotation = options.rotation ?? 0.0;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required.\");\n  }\n  Rectangle._validate(rectangle);\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\n      \"options.rectangle.north must be greater than options.rectangle.south\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const height = options.height ?? 0.0;\n  const extrudedHeight = options.extrudedHeight ?? height;\n\n  this._rectangle = Rectangle.clone(rectangle);\n  this._granularity = granularity;\n  this._ellipsoid = ellipsoid;\n  this._surfaceHeight = Math.max(height, extrudedHeight);\n  this._rotation = rotation;\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createRectangleOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nRectangleOutlineGeometry.packedLength =\n  Rectangle.packedLength + Ellipsoid.packedLength + 5;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {RectangleOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nRectangleOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  Rectangle.pack(value._rectangle, array, startingIndex);\n  startingIndex += Rectangle.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._surfaceHeight;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex] = value._offsetAttribute ?? -1;\n\n  return array;\n};\n\nconst scratchRectangle = new Rectangle();\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchOptions = {\n  rectangle: scratchRectangle,\n  ellipsoid: scratchEllipsoid,\n  granularity: undefined,\n  height: undefined,\n  rotation: undefined,\n  extrudedHeight: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {RectangleOutlineGeometry} [result] The object into which to store the result.\n * @returns {RectangleOutlineGeometry} The modified result parameter or a new RectangleOutlineGeometry instance if one was not provided.\n */\nRectangleOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n  startingIndex += Rectangle.packedLength;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const granularity = array[startingIndex++];\n  const height = array[startingIndex++];\n  const rotation = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.granularity = granularity;\n    scratchOptions.height = height;\n    scratchOptions.rotation = rotation;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new RectangleOutlineGeometry(scratchOptions);\n  }\n\n  result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._surfaceHeight = height;\n  result._rotation = rotation;\n  result._extrudedHeight = extrudedHeight;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\nconst nwScratch = new Cartographic();\n/**\n * Computes the geometric representation of an outline of a rectangle, including its vertices, indices, and a bounding sphere.\n *\n * @param {RectangleOutlineGeometry} rectangleGeometry A description of the rectangle outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n *\n * @exception {DeveloperError} Rotated rectangle is invalid.\n */\nRectangleOutlineGeometry.createGeometry = function (rectangleGeometry) {\n  const rectangle = rectangleGeometry._rectangle;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n  const computedOptions = RectangleGeometryLibrary.computeOptions(\n    rectangle,\n    rectangleGeometry._granularity,\n    rectangleGeometry._rotation,\n    0,\n    rectangleScratch,\n    nwScratch,\n  );\n\n  let geometry;\n  let boundingSphere;\n\n  if (\n    CesiumMath.equalsEpsilon(\n      rectangle.north,\n      rectangle.south,\n      CesiumMath.EPSILON10,\n    ) ||\n    CesiumMath.equalsEpsilon(\n      rectangle.east,\n      rectangle.west,\n      CesiumMath.EPSILON10,\n    )\n  ) {\n    return undefined;\n  }\n\n  const surfaceHeight = rectangleGeometry._surfaceHeight;\n  const extrudedHeight = rectangleGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    surfaceHeight,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2,\n  );\n  let offsetValue;\n  if (extrude) {\n    geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      const size = geometry.attributes.position.values.length / 3;\n      let offsetAttribute = new Uint8Array(size);\n      if (rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n        offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n      } else {\n        offsetValue =\n          rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n            ? 0\n            : 1;\n        offsetAttribute = offsetAttribute.fill(offsetValue);\n      }\n\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: offsetAttribute,\n      });\n    }\n    const topBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight,\n      topBoundingSphere,\n    );\n    const bottomBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      extrudedHeight,\n      bottomBoundingSphere,\n    );\n    boundingSphere = BoundingSphere.union(topBS, bottomBS);\n  } else {\n    geometry = constructRectangle(rectangleGeometry, computedOptions);\n    geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      geometry.attributes.position.values,\n      surfaceHeight,\n      ellipsoid,\n      false,\n    );\n\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      const length = geometry.attributes.position.values.length;\n      offsetValue =\n        rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n\n    boundingSphere = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight,\n    );\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: rectangleGeometry._offsetAttribute,\n  });\n};\nexport default RectangleOutlineGeometry;\n"],"names":["bottomBoundingSphere","topBoundingSphere","positionScratch","rectangleScratch","constructRectangle","geometry","computedOptions","ellipsoid","_ellipsoid","height","width","northCap","southCap","rowHeight","widthMultiplier","size","corners","positions","Float64Array","posIndex","row","col","position","computePosition","x","y","z","indicesSize","length","indices","createTypedArray","index","i","geo","attributes","primitiveType","LINES","componentDatatype","DOUBLE","componentsPerAttribute","values","constructExtrudedRectangle","rectangleGeometry","maxHeight","_surfaceHeight","minHeight","_extrudedHeight","topPositions","scaleToGeodeticHeight","set","bottomPositions","bottomCorner","topRightCorner","bottomLeftCorner","RectangleOutlineGeometry","options","EMPTY_OBJECT","rectangle","granularity","RADIANS_PER_DEGREE","default","rotation","_validate","north","south","extrudedHeight","_rectangle","clone","_granularity","Math","max","_rotation","min","_offsetAttribute","offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchRectangle","scratchEllipsoid","UNIT_SPHERE","scratchOptions","undefined","unpack","result","nwScratch","createGeometry","computeOptions","boundingSphere","equalsEpsilon","EPSILON10","east","west","surfaceHeight","extrude","EPSILON2","offsetValue","Uint8Array","TOP","fill","NONE","applyOffset","UNSIGNED_BYTE","topBS","fromRectangle3D","bottomBS","union"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 47399, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/WallGeometryLibrary.js"],"sourcesContent":["import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\n\n/**\n * @private\n */\nconst WallGeometryLibrary = {};\n\nfunction latLonEquals(c0, c1) {\n  return (\n    CesiumMath.equalsEpsilon(c0.latitude, c1.latitude, CesiumMath.EPSILON10) &&\n    CesiumMath.equalsEpsilon(c0.longitude, c1.longitude, CesiumMath.EPSILON10)\n  );\n}\n\nconst scratchCartographic1 = new Cartographic();\nconst scratchCartographic2 = new Cartographic();\nfunction removeDuplicates(ellipsoid, positions, topHeights, bottomHeights) {\n  positions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n\n  const length = positions.length;\n  if (length < 2) {\n    return;\n  }\n\n  const hasBottomHeights = defined(bottomHeights);\n  const hasTopHeights = defined(topHeights);\n\n  const cleanedPositions = new Array(length);\n  const cleanedTopHeights = new Array(length);\n  const cleanedBottomHeights = new Array(length);\n\n  const v0 = positions[0];\n  cleanedPositions[0] = v0;\n\n  const c0 = ellipsoid.cartesianToCartographic(v0, scratchCartographic1);\n  if (hasTopHeights) {\n    c0.height = topHeights[0];\n  }\n\n  cleanedTopHeights[0] = c0.height;\n\n  if (hasBottomHeights) {\n    cleanedBottomHeights[0] = bottomHeights[0];\n  } else {\n    cleanedBottomHeights[0] = 0.0;\n  }\n\n  const startTopHeight = cleanedTopHeights[0];\n  const startBottomHeight = cleanedBottomHeights[0];\n  let hasAllSameHeights = startTopHeight === startBottomHeight;\n\n  let index = 1;\n  for (let i = 1; i < length; ++i) {\n    const v1 = positions[i];\n    const c1 = ellipsoid.cartesianToCartographic(v1, scratchCartographic2);\n    if (hasTopHeights) {\n      c1.height = topHeights[i];\n    }\n    hasAllSameHeights = hasAllSameHeights && c1.height === 0;\n\n    if (!latLonEquals(c0, c1)) {\n      cleanedPositions[index] = v1; // Shallow copy!\n      cleanedTopHeights[index] = c1.height;\n\n      if (hasBottomHeights) {\n        cleanedBottomHeights[index] = bottomHeights[i];\n      } else {\n        cleanedBottomHeights[index] = 0.0;\n      }\n      hasAllSameHeights =\n        hasAllSameHeights &&\n        cleanedTopHeights[index] === cleanedBottomHeights[index];\n\n      Cartographic.clone(c1, c0);\n      ++index;\n    } else if (c0.height < c1.height) {\n      // two adjacent positions are the same, so use whichever has the greater height\n      cleanedTopHeights[index - 1] = c1.height;\n    }\n  }\n\n  if (hasAllSameHeights || index < 2) {\n    return;\n  }\n\n  cleanedPositions.length = index;\n  cleanedTopHeights.length = index;\n  cleanedBottomHeights.length = index;\n\n  return {\n    positions: cleanedPositions,\n    topHeights: cleanedTopHeights,\n    bottomHeights: cleanedBottomHeights,\n  };\n}\n\nconst positionsArrayScratch = new Array(2);\nconst heightsArrayScratch = new Array(2);\nconst generateArcOptionsScratch = {\n  positions: undefined,\n  height: undefined,\n  granularity: undefined,\n  ellipsoid: undefined,\n};\n\n/**\n * @private\n */\nWallGeometryLibrary.computePositions = function (\n  ellipsoid,\n  wallPositions,\n  maximumHeights,\n  minimumHeights,\n  granularity,\n  duplicateCorners,\n) {\n  const o = removeDuplicates(\n    ellipsoid,\n    wallPositions,\n    maximumHeights,\n    minimumHeights,\n  );\n\n  if (!defined(o)) {\n    return;\n  }\n\n  wallPositions = o.positions;\n  maximumHeights = o.topHeights;\n  minimumHeights = o.bottomHeights;\n\n  const length = wallPositions.length;\n  const numCorners = length - 2;\n  let topPositions;\n  let bottomPositions;\n\n  const minDistance = CesiumMath.chordLength(\n    granularity,\n    ellipsoid.maximumRadius,\n  );\n\n  const generateArcOptions = generateArcOptionsScratch;\n  generateArcOptions.minDistance = minDistance;\n  generateArcOptions.ellipsoid = ellipsoid;\n\n  if (duplicateCorners) {\n    let count = 0;\n    let i;\n\n    for (i = 0; i < length - 1; i++) {\n      count +=\n        PolylinePipeline.numberOfPoints(\n          wallPositions[i],\n          wallPositions[i + 1],\n          minDistance,\n        ) + 1;\n    }\n\n    topPositions = new Float64Array(count * 3);\n    bottomPositions = new Float64Array(count * 3);\n\n    const generateArcPositions = positionsArrayScratch;\n    const generateArcHeights = heightsArrayScratch;\n    generateArcOptions.positions = generateArcPositions;\n    generateArcOptions.height = generateArcHeights;\n\n    let offset = 0;\n    for (i = 0; i < length - 1; i++) {\n      generateArcPositions[0] = wallPositions[i];\n      generateArcPositions[1] = wallPositions[i + 1];\n\n      generateArcHeights[0] = maximumHeights[i];\n      generateArcHeights[1] = maximumHeights[i + 1];\n\n      const pos = PolylinePipeline.generateArc(generateArcOptions);\n      topPositions.set(pos, offset);\n\n      generateArcHeights[0] = minimumHeights[i];\n      generateArcHeights[1] = minimumHeights[i + 1];\n\n      bottomPositions.set(\n        PolylinePipeline.generateArc(generateArcOptions),\n        offset,\n      );\n\n      offset += pos.length;\n    }\n  } else {\n    generateArcOptions.positions = wallPositions;\n    generateArcOptions.height = maximumHeights;\n    topPositions = new Float64Array(\n      PolylinePipeline.generateArc(generateArcOptions),\n    );\n\n    generateArcOptions.height = minimumHeights;\n    bottomPositions = new Float64Array(\n      PolylinePipeline.generateArc(generateArcOptions),\n    );\n  }\n\n  return {\n    bottomPositions: bottomPositions,\n    topPositions: topPositions,\n    numCorners: numCorners,\n  };\n};\nexport default WallGeometryLibrary;\n"],"names":["WallGeometryLibrary","latLonEquals","c0","c1","equalsEpsilon","latitude","EPSILON10","longitude","scratchCartographic1","scratchCartographic2","removeDuplicates","ellipsoid","positions","topHeights","bottomHeights","length","hasBottomHeights","hasTopHeights","cleanedPositions","Array","cleanedTopHeights","cleanedBottomHeights","v0","cartesianToCartographic","height","startTopHeight","startBottomHeight","hasAllSameHeights","index","i","v1","clone","positionsArrayScratch","heightsArrayScratch","generateArcOptionsScratch","undefined","granularity","computePositions","wallPositions","maximumHeights","minimumHeights","duplicateCorners","o","numCorners","topPositions","bottomPositions","minDistance","chordLength","maximumRadius","generateArcOptions","count","numberOfPoints","Float64Array","generateArcPositions","generateArcHeights","offset","pos","generateArc","set"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 47554, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/WallGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nimport WallGeometryLibrary from \"./WallGeometryLibrary.js\";\n\nconst scratchCartesian3Position1 = new Cartesian3();\nconst scratchCartesian3Position2 = new Cartesian3();\nconst scratchCartesian3Position4 = new Cartesian3();\nconst scratchCartesian3Position5 = new Cartesian3();\nconst scratchBitangent = new Cartesian3();\nconst scratchTangent = new Cartesian3();\nconst scratchNormal = new Cartesian3();\n\n/**\n * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,\n * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n *\n * @alias WallGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the\n *        wall at <code>positions</code>. If undefined, the height of each position in used.\n * @param {number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the\n *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid for coordinate manipulation\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} positions length must be greater than or equal to 2.\n * @exception {DeveloperError} positions and maximumHeights must have the same length.\n * @exception {DeveloperError} positions and minimumHeights must have the same length.\n *\n * @see WallGeometry#createGeometry\n * @see WallGeometry#fromConstantHeight\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Wall.html|Cesium Sandcastle Wall Demo}\n *\n * @example\n * // create a wall that spans from ground level to 10000 meters\n * const wall = new Cesium.WallGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *     19.0, 47.0, 10000.0,\n *     19.0, 48.0, 10000.0,\n *     20.0, 48.0, 10000.0,\n *     20.0, 47.0, 10000.0,\n *     19.0, 47.0, 10000.0\n *   ])\n * });\n * const geometry = Cesium.WallGeometry.createGeometry(wall);\n */\nfunction WallGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const wallPositions = options.positions;\n  const maximumHeights = options.maximumHeights;\n  const minimumHeights = options.minimumHeights;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(wallPositions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  if (\n    defined(maximumHeights) &&\n    maximumHeights.length !== wallPositions.length\n  ) {\n    throw new DeveloperError(\n      \"options.positions and options.maximumHeights must have the same length.\",\n    );\n  }\n  if (\n    defined(minimumHeights) &&\n    minimumHeights.length !== wallPositions.length\n  ) {\n    throw new DeveloperError(\n      \"options.positions and options.minimumHeights must have the same length.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const vertexFormat = options.vertexFormat ?? VertexFormat.DEFAULT;\n  const granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n\n  this._positions = wallPositions;\n  this._minimumHeights = minimumHeights;\n  this._maximumHeights = maximumHeights;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._granularity = granularity;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._workerName = \"createWallGeometry\";\n\n  let numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;\n  if (defined(minimumHeights)) {\n    numComponents += minimumHeights.length;\n  }\n  if (defined(maximumHeights)) {\n    numComponents += maximumHeights.length;\n  }\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 1;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {WallGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nWallGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  let i;\n\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  const minimumHeights = value._minimumHeights;\n  length = defined(minimumHeights) ? minimumHeights.length : 0;\n  array[startingIndex++] = length;\n\n  if (defined(minimumHeights)) {\n    for (i = 0; i < length; ++i) {\n      array[startingIndex++] = minimumHeights[i];\n    }\n  }\n\n  const maximumHeights = value._maximumHeights;\n  length = defined(maximumHeights) ? maximumHeights.length : 0;\n  array[startingIndex++] = length;\n\n  if (defined(maximumHeights)) {\n    for (i = 0; i < length; ++i) {\n      array[startingIndex++] = maximumHeights[i];\n    }\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  positions: undefined,\n  minimumHeights: undefined,\n  maximumHeights: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  granularity: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {WallGeometry} [result] The object into which to store the result.\n * @returns {WallGeometry} The modified result parameter or a new WallGeometry instance if one was not provided.\n */\nWallGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  let i;\n\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  let minimumHeights;\n\n  if (length > 0) {\n    minimumHeights = new Array(length);\n    for (i = 0; i < length; ++i) {\n      minimumHeights[i] = array[startingIndex++];\n    }\n  }\n\n  length = array[startingIndex++];\n  let maximumHeights;\n\n  if (length > 0) {\n    maximumHeights = new Array(length);\n    for (i = 0; i < length; ++i) {\n      maximumHeights[i] = array[startingIndex++];\n    }\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.minimumHeights = minimumHeights;\n    scratchOptions.maximumHeights = maximumHeights;\n    scratchOptions.granularity = granularity;\n    return new WallGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._minimumHeights = minimumHeights;\n  result._maximumHeights = maximumHeights;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._granularity = granularity;\n\n  return result;\n};\n\n/**\n * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,\n * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n * @param {number} [options.maximumHeight] A constant that defines the maximum height of the\n *        wall at <code>positions</code>. If undefined, the height of each position in used.\n * @param {number} [options.minimumHeight] A constant that defines the minimum height of the\n *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid for coordinate manipulation\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @returns {WallGeometry}\n *\n *\n * @example\n * // create a wall that spans from 10000 meters to 20000 meters\n * const wall = Cesium.WallGeometry.fromConstantHeights({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     19.0, 47.0,\n *     19.0, 48.0,\n *     20.0, 48.0,\n *     20.0, 47.0,\n *     19.0, 47.0,\n *   ]),\n *   minimumHeight : 20000.0,\n *   maximumHeight : 10000.0\n * });\n * const geometry = Cesium.WallGeometry.createGeometry(wall);\n *\n * @see WallGeometry#createGeometry\n */\nWallGeometry.fromConstantHeights = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const positions = options.positions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let minHeights;\n  let maxHeights;\n\n  const min = options.minimumHeight;\n  const max = options.maximumHeight;\n\n  const doMin = defined(min);\n  const doMax = defined(max);\n  if (doMin || doMax) {\n    const length = positions.length;\n    minHeights = doMin ? new Array(length) : undefined;\n    maxHeights = doMax ? new Array(length) : undefined;\n\n    for (let i = 0; i < length; ++i) {\n      if (doMin) {\n        minHeights[i] = min;\n      }\n\n      if (doMax) {\n        maxHeights[i] = max;\n      }\n    }\n  }\n\n  const newOptions = {\n    positions: positions,\n    maximumHeights: maxHeights,\n    minimumHeights: minHeights,\n    ellipsoid: options.ellipsoid,\n    vertexFormat: options.vertexFormat,\n  };\n  return new WallGeometry(newOptions);\n};\n\n/**\n * Computes the geometric representation of a wall, including its vertices, indices, and a bounding sphere.\n *\n * @param {WallGeometry} wallGeometry A description of the wall.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nWallGeometry.createGeometry = function (wallGeometry) {\n  const wallPositions = wallGeometry._positions;\n  const minimumHeights = wallGeometry._minimumHeights;\n  const maximumHeights = wallGeometry._maximumHeights;\n  const vertexFormat = wallGeometry._vertexFormat;\n  const granularity = wallGeometry._granularity;\n  const ellipsoid = wallGeometry._ellipsoid;\n\n  const pos = WallGeometryLibrary.computePositions(\n    ellipsoid,\n    wallPositions,\n    maximumHeights,\n    minimumHeights,\n    granularity,\n    true,\n  );\n  if (!defined(pos)) {\n    return;\n  }\n\n  const bottomPositions = pos.bottomPositions;\n  const topPositions = pos.topPositions;\n  const numCorners = pos.numCorners;\n\n  let length = topPositions.length;\n  let size = length * 2;\n\n  const positions = vertexFormat.position ? new Float64Array(size) : undefined;\n  const normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(size)\n    : undefined;\n  const textureCoordinates = vertexFormat.st\n    ? new Float32Array((size / 3) * 2)\n    : undefined;\n\n  let positionIndex = 0;\n  let normalIndex = 0;\n  let bitangentIndex = 0;\n  let tangentIndex = 0;\n  let stIndex = 0;\n\n  // add lower and upper points one after the other, lower\n  // points being even and upper points being odd\n  let normal = scratchNormal;\n  let tangent = scratchTangent;\n  let bitangent = scratchBitangent;\n  let recomputeNormal = true;\n  length /= 3;\n  let i;\n  let s = 0;\n  const ds = 1 / (length - numCorners - 1);\n  for (i = 0; i < length; ++i) {\n    const i3 = i * 3;\n    const topPosition = Cartesian3.fromArray(\n      topPositions,\n      i3,\n      scratchCartesian3Position1,\n    );\n    const bottomPosition = Cartesian3.fromArray(\n      bottomPositions,\n      i3,\n      scratchCartesian3Position2,\n    );\n    if (vertexFormat.position) {\n      // insert the lower point\n      positions[positionIndex++] = bottomPosition.x;\n      positions[positionIndex++] = bottomPosition.y;\n      positions[positionIndex++] = bottomPosition.z;\n\n      // insert the upper point\n      positions[positionIndex++] = topPosition.x;\n      positions[positionIndex++] = topPosition.y;\n      positions[positionIndex++] = topPosition.z;\n    }\n\n    if (vertexFormat.st) {\n      textureCoordinates[stIndex++] = s;\n      textureCoordinates[stIndex++] = 0.0;\n\n      textureCoordinates[stIndex++] = s;\n      textureCoordinates[stIndex++] = 1.0;\n    }\n\n    if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n      let nextTop = Cartesian3.clone(\n        Cartesian3.ZERO,\n        scratchCartesian3Position5,\n      );\n      const groundPosition = Cartesian3.subtract(\n        topPosition,\n        ellipsoid.geodeticSurfaceNormal(\n          topPosition,\n          scratchCartesian3Position2,\n        ),\n        scratchCartesian3Position2,\n      );\n      if (i + 1 < length) {\n        nextTop = Cartesian3.fromArray(\n          topPositions,\n          i3 + 3,\n          scratchCartesian3Position5,\n        );\n      }\n\n      if (recomputeNormal) {\n        const scalednextPosition = Cartesian3.subtract(\n          nextTop,\n          topPosition,\n          scratchCartesian3Position4,\n        );\n        const scaledGroundPosition = Cartesian3.subtract(\n          groundPosition,\n          topPosition,\n          scratchCartesian3Position1,\n        );\n        normal = Cartesian3.normalize(\n          Cartesian3.cross(scaledGroundPosition, scalednextPosition, normal),\n          normal,\n        );\n        recomputeNormal = false;\n      }\n\n      if (\n        Cartesian3.equalsEpsilon(topPosition, nextTop, CesiumMath.EPSILON10)\n      ) {\n        recomputeNormal = true;\n      } else {\n        s += ds;\n        if (vertexFormat.tangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.subtract(nextTop, topPosition, tangent),\n            tangent,\n          );\n        }\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(\n            Cartesian3.cross(normal, tangent, bitangent),\n            bitangent,\n          );\n        }\n      }\n\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n      }\n\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n      }\n\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n      }\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  // prepare the side walls, two triangles for each wall\n  //\n  //    A (i+1)  B (i+3) E\n  //    +--------+-------+\n  //    |      / |      /|    triangles:  A C B\n  //    |     /  |     / |                B C D\n  //    |    /   |    /  |\n  //    |   /    |   /   |\n  //    |  /     |  /    |\n  //    | /      | /     |\n  //    +--------+-------+\n  //    C (i)    D (i+2) F\n  //\n\n  const numVertices = size / 3;\n  size -= 6 * (numCorners + 1);\n  const indices = IndexDatatype.createTypedArray(numVertices, size);\n\n  let edgeIndex = 0;\n  for (i = 0; i < numVertices - 2; i += 2) {\n    const LL = i;\n    const LR = i + 2;\n    const pl = Cartesian3.fromArray(\n      positions,\n      LL * 3,\n      scratchCartesian3Position1,\n    );\n    const pr = Cartesian3.fromArray(\n      positions,\n      LR * 3,\n      scratchCartesian3Position2,\n    );\n    if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {\n      continue;\n    }\n    const UL = i + 1;\n    const UR = i + 3;\n\n    indices[edgeIndex++] = UL;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = LR;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: new BoundingSphere.fromVertices(positions),\n  });\n};\nexport default WallGeometry;\n"],"names":["scratchCartesian3Position1","scratchCartesian3Position2","scratchCartesian3Position4","scratchCartesian3Position5","scratchBitangent","scratchTangent","scratchNormal","WallGeometry","options","EMPTY_OBJECT","wallPositions","positions","maximumHeights","minimumHeights","length","vertexFormat","DEFAULT","granularity","RADIANS_PER_DEGREE","ellipsoid","default","_positions","_minimumHeights","_maximumHeights","_vertexFormat","clone","_granularity","_ellipsoid","_workerName","numComponents","packedLength","pack","value","array","startingIndex","i","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","undefined","unpack","result","Array","fromConstantHeights","minHeights","maxHeights","min","minimumHeight","max","maximumHeight","doMin","doMax","newOptions","createGeometry","wallGeometry","pos","computePositions","bottomPositions","topPositions","numCorners","size","position","Float64Array","normals","normal","Float32Array","tangents","tangent","bitangents","bitangent","textureCoordinates","st","positionIndex","normalIndex","bitangentIndex","tangentIndex","stIndex","recomputeNormal","s","ds","i3","topPosition","fromArray","bottomPosition","x","y","z","nextTop","ZERO","groundPosition","subtract","geodeticSurfaceNormal","scalednextPosition","scaledGroundPosition","normalize","cross","equalsEpsilon","EPSILON10","attributes","componentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","numVertices","indices","createTypedArray","edgeIndex","LL","LR","pl","pr","UL","UR","primitiveType","TRIANGLES","boundingSphere","fromVertices"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 48044, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/WallOutlineGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WallGeometryLibrary from \"./WallGeometryLibrary.js\";\n\nconst scratchCartesian3Position1 = new Cartesian3();\nconst scratchCartesian3Position2 = new Cartesian3();\n\n/**\n * A description of a wall outline. A wall is defined by a series of points,\n * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n *\n * @alias WallOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the\n *        wall at <code>positions</code>. If undefined, the height of each position in used.\n * @param {number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the\n *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid for coordinate manipulation\n *\n * @exception {DeveloperError} positions length must be greater than or equal to 2.\n * @exception {DeveloperError} positions and maximumHeights must have the same length.\n * @exception {DeveloperError} positions and minimumHeights must have the same length.\n *\n * @see WallGeometry#createGeometry\n * @see WallGeometry#fromConstantHeight\n *\n * @example\n * // create a wall outline that spans from ground level to 10000 meters\n * const wall = new Cesium.WallOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *     19.0, 47.0, 10000.0,\n *     19.0, 48.0, 10000.0,\n *     20.0, 48.0, 10000.0,\n *     20.0, 47.0, 10000.0,\n *     19.0, 47.0, 10000.0\n *   ])\n * });\n * const geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\n */\nfunction WallOutlineGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const wallPositions = options.positions;\n  const maximumHeights = options.maximumHeights;\n  const minimumHeights = options.minimumHeights;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(wallPositions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  if (\n    defined(maximumHeights) &&\n    maximumHeights.length !== wallPositions.length\n  ) {\n    throw new DeveloperError(\n      \"options.positions and options.maximumHeights must have the same length.\",\n    );\n  }\n  if (\n    defined(minimumHeights) &&\n    minimumHeights.length !== wallPositions.length\n  ) {\n    throw new DeveloperError(\n      \"options.positions and options.minimumHeights must have the same length.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n\n  this._positions = wallPositions;\n  this._minimumHeights = minimumHeights;\n  this._maximumHeights = maximumHeights;\n  this._granularity = granularity;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._workerName = \"createWallOutlineGeometry\";\n\n  let numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;\n  if (defined(minimumHeights)) {\n    numComponents += minimumHeights.length;\n  }\n  if (defined(maximumHeights)) {\n    numComponents += maximumHeights.length;\n  }\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength = numComponents + Ellipsoid.packedLength + 1;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {WallOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nWallOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  let i;\n\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  const minimumHeights = value._minimumHeights;\n  length = defined(minimumHeights) ? minimumHeights.length : 0;\n  array[startingIndex++] = length;\n\n  if (defined(minimumHeights)) {\n    for (i = 0; i < length; ++i) {\n      array[startingIndex++] = minimumHeights[i];\n    }\n  }\n\n  const maximumHeights = value._maximumHeights;\n  length = defined(maximumHeights) ? maximumHeights.length : 0;\n  array[startingIndex++] = length;\n\n  if (defined(maximumHeights)) {\n    for (i = 0; i < length; ++i) {\n      array[startingIndex++] = maximumHeights[i];\n    }\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchOptions = {\n  positions: undefined,\n  minimumHeights: undefined,\n  maximumHeights: undefined,\n  ellipsoid: scratchEllipsoid,\n  granularity: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {WallOutlineGeometry} [result] The object into which to store the result.\n * @returns {WallOutlineGeometry} The modified result parameter or a new WallOutlineGeometry instance if one was not provided.\n */\nWallOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  let i;\n\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  let minimumHeights;\n\n  if (length > 0) {\n    minimumHeights = new Array(length);\n    for (i = 0; i < length; ++i) {\n      minimumHeights[i] = array[startingIndex++];\n    }\n  }\n\n  length = array[startingIndex++];\n  let maximumHeights;\n\n  if (length > 0) {\n    maximumHeights = new Array(length);\n    for (i = 0; i < length; ++i) {\n      maximumHeights[i] = array[startingIndex++];\n    }\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.minimumHeights = minimumHeights;\n    scratchOptions.maximumHeights = maximumHeights;\n    scratchOptions.granularity = granularity;\n    return new WallOutlineGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._minimumHeights = minimumHeights;\n  result._maximumHeights = maximumHeights;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._granularity = granularity;\n\n  return result;\n};\n\n/**\n * A description of a walloutline. A wall is defined by a series of points,\n * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n * @param {number} [options.maximumHeight] A constant that defines the maximum height of the\n *        wall at <code>positions</code>. If undefined, the height of each position in used.\n * @param {number} [options.minimumHeight] A constant that defines the minimum height of the\n *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid for coordinate manipulation\n * @returns {WallOutlineGeometry}\n *\n *\n * @example\n * // create a wall that spans from 10000 meters to 20000 meters\n * const wall = Cesium.WallOutlineGeometry.fromConstantHeights({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     19.0, 47.0,\n *     19.0, 48.0,\n *     20.0, 48.0,\n *     20.0, 47.0,\n *     19.0, 47.0,\n *   ]),\n *   minimumHeight : 20000.0,\n *   maximumHeight : 10000.0\n * });\n * const geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\n *\n * @see WallOutlineGeometry#createGeometry\n */\nWallOutlineGeometry.fromConstantHeights = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const positions = options.positions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let minHeights;\n  let maxHeights;\n\n  const min = options.minimumHeight;\n  const max = options.maximumHeight;\n\n  const doMin = defined(min);\n  const doMax = defined(max);\n  if (doMin || doMax) {\n    const length = positions.length;\n    minHeights = doMin ? new Array(length) : undefined;\n    maxHeights = doMax ? new Array(length) : undefined;\n\n    for (let i = 0; i < length; ++i) {\n      if (doMin) {\n        minHeights[i] = min;\n      }\n\n      if (doMax) {\n        maxHeights[i] = max;\n      }\n    }\n  }\n\n  const newOptions = {\n    positions: positions,\n    maximumHeights: maxHeights,\n    minimumHeights: minHeights,\n    ellipsoid: options.ellipsoid,\n  };\n  return new WallOutlineGeometry(newOptions);\n};\n\n/**\n * Computes the geometric representation of a wall outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {WallOutlineGeometry} wallGeometry A description of the wall outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nWallOutlineGeometry.createGeometry = function (wallGeometry) {\n  const wallPositions = wallGeometry._positions;\n  const minimumHeights = wallGeometry._minimumHeights;\n  const maximumHeights = wallGeometry._maximumHeights;\n  const granularity = wallGeometry._granularity;\n  const ellipsoid = wallGeometry._ellipsoid;\n\n  const pos = WallGeometryLibrary.computePositions(\n    ellipsoid,\n    wallPositions,\n    maximumHeights,\n    minimumHeights,\n    granularity,\n    false,\n  );\n  if (!defined(pos)) {\n    return;\n  }\n\n  const bottomPositions = pos.bottomPositions;\n  const topPositions = pos.topPositions;\n\n  let length = topPositions.length;\n  let size = length * 2;\n\n  const positions = new Float64Array(size);\n  let positionIndex = 0;\n\n  // add lower and upper points one after the other, lower\n  // points being even and upper points being odd\n  length /= 3;\n  let i;\n  for (i = 0; i < length; ++i) {\n    const i3 = i * 3;\n    const topPosition = Cartesian3.fromArray(\n      topPositions,\n      i3,\n      scratchCartesian3Position1,\n    );\n    const bottomPosition = Cartesian3.fromArray(\n      bottomPositions,\n      i3,\n      scratchCartesian3Position2,\n    );\n\n    // insert the lower point\n    positions[positionIndex++] = bottomPosition.x;\n    positions[positionIndex++] = bottomPosition.y;\n    positions[positionIndex++] = bottomPosition.z;\n\n    // insert the upper point\n    positions[positionIndex++] = topPosition.x;\n    positions[positionIndex++] = topPosition.y;\n    positions[positionIndex++] = topPosition.z;\n  }\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  const numVertices = size / 3;\n  size = 2 * numVertices - 4 + numVertices;\n  const indices = IndexDatatype.createTypedArray(numVertices, size);\n\n  let edgeIndex = 0;\n  for (i = 0; i < numVertices - 2; i += 2) {\n    const LL = i;\n    const LR = i + 2;\n    const pl = Cartesian3.fromArray(\n      positions,\n      LL * 3,\n      scratchCartesian3Position1,\n    );\n    const pr = Cartesian3.fromArray(\n      positions,\n      LR * 3,\n      scratchCartesian3Position2,\n    );\n    if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {\n      continue;\n    }\n    const UL = i + 1;\n    const UR = i + 3;\n\n    indices[edgeIndex++] = UL;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = UL;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = LR;\n  }\n\n  indices[edgeIndex++] = numVertices - 2;\n  indices[edgeIndex++] = numVertices - 1;\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: new BoundingSphere.fromVertices(positions),\n  });\n};\nexport default WallOutlineGeometry;\n"],"names":["scratchCartesian3Position1","scratchCartesian3Position2","WallOutlineGeometry","options","EMPTY_OBJECT","wallPositions","positions","maximumHeights","minimumHeights","length","granularity","RADIANS_PER_DEGREE","ellipsoid","default","_positions","_minimumHeights","_maximumHeights","_granularity","_ellipsoid","clone","_workerName","numComponents","packedLength","pack","value","array","startingIndex","i","scratchEllipsoid","UNIT_SPHERE","scratchOptions","undefined","unpack","result","Array","fromConstantHeights","minHeights","maxHeights","min","minimumHeight","max","maximumHeight","doMin","doMax","newOptions","createGeometry","wallGeometry","pos","computePositions","bottomPositions","topPositions","size","Float64Array","positionIndex","i3","topPosition","fromArray","bottomPosition","x","y","z","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","numVertices","indices","createTypedArray","edgeIndex","LL","LR","pl","pr","equalsEpsilon","EPSILON10","UL","UR","primitiveType","LINES","boundingSphere","fromVertices"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 48401, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/RectangleCollisionChecker.js"],"sourcesContent":["import RBush from \"rbush\";\nimport Check from \"./Check.js\";\n\n/**\n * Wrapper around rbush for use with Rectangle types.\n * @private\n */\nfunction RectangleCollisionChecker() {\n  this._tree = new RBush();\n}\n\nfunction RectangleWithId() {\n  this.minX = 0.0;\n  this.minY = 0.0;\n  this.maxX = 0.0;\n  this.maxY = 0.0;\n  this.id = \"\";\n}\n\nRectangleWithId.fromRectangleAndId = function (id, rectangle, result) {\n  result.minX = rectangle.west;\n  result.minY = rectangle.south;\n  result.maxX = rectangle.east;\n  result.maxY = rectangle.north;\n  result.id = id;\n  return result;\n};\n\n/**\n * Insert a rectangle into the collision checker.\n *\n * @param {string} id Unique string ID for the rectangle being inserted.\n * @param {Rectangle} rectangle A Rectangle\n * @private\n */\nRectangleCollisionChecker.prototype.insert = function (id, rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"id\", id);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  const withId = RectangleWithId.fromRectangleAndId(\n    id,\n    rectangle,\n    new RectangleWithId(),\n  );\n  this._tree.insert(withId);\n};\n\nfunction idCompare(a, b) {\n  return a.id === b.id;\n}\n\nconst removalScratch = new RectangleWithId();\n/**\n * Remove a rectangle from the collision checker.\n *\n * @param {string} id Unique string ID for the rectangle being removed.\n * @param {Rectangle} rectangle A Rectangle\n * @private\n */\nRectangleCollisionChecker.prototype.remove = function (id, rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"id\", id);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  const withId = RectangleWithId.fromRectangleAndId(\n    id,\n    rectangle,\n    removalScratch,\n  );\n  this._tree.remove(withId, idCompare);\n};\n\nconst collisionScratch = new RectangleWithId();\n/**\n * Checks if a given rectangle collides with any of the rectangles in the collection.\n *\n * @param {Rectangle} rectangle A Rectangle that should be checked against the rectangles in the collision checker.\n * @returns {boolean} Whether the rectangle collides with any of the rectangles in the collision checker.\n */\nRectangleCollisionChecker.prototype.collides = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  const withId = RectangleWithId.fromRectangleAndId(\n    \"\",\n    rectangle,\n    collisionScratch,\n  );\n  return this._tree.collides(withId);\n};\nexport default RectangleCollisionChecker;\n"],"names":["RectangleCollisionChecker","_tree","RectangleWithId","minX","minY","maxX","maxY","id","fromRectangleAndId","rectangle","result","west","south","east","north","prototype","insert","typeOf","string","object","withId","idCompare","a","b","removalScratch","remove","collisionScratch","collides"],"mappings":";;;;AAAA;AACA;;;AAEA;;;CAGC,GACD,SAASA;IACP,IAAI,CAACC,KAAK,GAAG,IAAI,4IAAK;AACxB;AAEA,SAASC;IACP,IAAI,CAACC,IAAI,GAAG;IACZ,IAAI,CAACC,IAAI,GAAG;IACZ,IAAI,CAACC,IAAI,GAAG;IACZ,IAAI,CAACC,IAAI,GAAG;IACZ,IAAI,CAACC,EAAE,GAAG;AACZ;AAEAL,gBAAgBM,kBAAkB,GAAG,SAAUD,EAAE,EAAEE,SAAS,EAAEC,MAAM;IAClEA,OAAOP,IAAI,GAAGM,UAAUE,IAAI;IAC5BD,OAAON,IAAI,GAAGK,UAAUG,KAAK;IAC7BF,OAAOL,IAAI,GAAGI,UAAUI,IAAI;IAC5BH,OAAOJ,IAAI,GAAGG,UAAUK,KAAK;IAC7BJ,OAAOH,EAAE,GAAGA;IACZ,OAAOG;AACT;AAEA;;;;;;CAMC,GACDV,0BAA0Be,SAAS,CAACC,MAAM,GAAG,SAAUT,EAAE,EAAEE,SAAS;IAClE,yCAAyC;IACzC,2KAAK,CAACQ,MAAM,CAACC,MAAM,CAAC,MAAMX;IAC1B,2KAAK,CAACU,MAAM,CAACE,MAAM,CAAC,aAAaV;IACjC,wBAAwB;IAExB,MAAMW,SAASlB,gBAAgBM,kBAAkB,CAC/CD,IACAE,WACA,IAAIP;IAEN,IAAI,CAACD,KAAK,CAACe,MAAM,CAACI;AACpB;AAEA,SAASC,UAAUC,CAAC,EAAEC,CAAC;IACrB,OAAOD,EAAEf,EAAE,KAAKgB,EAAEhB,EAAE;AACtB;AAEA,MAAMiB,iBAAiB,IAAItB;AAC3B;;;;;;CAMC,GACDF,0BAA0Be,SAAS,CAACU,MAAM,GAAG,SAAUlB,EAAE,EAAEE,SAAS;IAClE,yCAAyC;IACzC,2KAAK,CAACQ,MAAM,CAACC,MAAM,CAAC,MAAMX;IAC1B,2KAAK,CAACU,MAAM,CAACE,MAAM,CAAC,aAAaV;IACjC,wBAAwB;IAExB,MAAMW,SAASlB,gBAAgBM,kBAAkB,CAC/CD,IACAE,WACAe;IAEF,IAAI,CAACvB,KAAK,CAACwB,MAAM,CAACL,QAAQC;AAC5B;AAEA,MAAMK,mBAAmB,IAAIxB;AAC7B;;;;;CAKC,GACDF,0BAA0Be,SAAS,CAACY,QAAQ,GAAG,SAAUlB,SAAS;IAChE,yCAAyC;IACzC,2KAAK,CAACQ,MAAM,CAACE,MAAM,CAAC,aAAaV;IACjC,wBAAwB;IAExB,MAAMW,SAASlB,gBAAgBM,kBAAkB,CAC/C,IACAC,WACAiB;IAEF,OAAO,IAAI,CAACzB,KAAK,CAAC0B,QAAQ,CAACP;AAC7B;uCACepB","ignoreList":[0]}},
    {"offset": {"line": 48480, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/ArticulationStageType.js"],"sourcesContent":["/**\n * An enum describing the type of motion that is defined by an articulation stage\n * in the AGI_articulations extension.\n *\n * @alias {ArticulationStageType}\n * @enum {string}\n *\n * @private\n */\nconst ArticulationStageType = {\n  XTRANSLATE: \"xTranslate\",\n  YTRANSLATE: \"yTranslate\",\n  ZTRANSLATE: \"zTranslate\",\n  XROTATE: \"xRotate\",\n  YROTATE: \"yRotate\",\n  ZROTATE: \"zRotate\",\n  XSCALE: \"xScale\",\n  YSCALE: \"yScale\",\n  ZSCALE: \"zScale\",\n  UNIFORMSCALE: \"uniformScale\",\n};\n\nexport default Object.freeze(ArticulationStageType);\n"],"names":["ArticulationStageType","XTRANSLATE","YTRANSLATE","ZTRANSLATE","XROTATE","YROTATE","ZROTATE","XSCALE","YSCALE","ZSCALE","UNIFORMSCALE","Object","freeze"],"mappings":";;;;AAAA;;;;;;;;CAQC,GACD,MAAMA,wBAAwB;IAC5BC,YAAY;IACZC,YAAY;IACZC,YAAY;IACZC,SAAS;IACTC,SAAS;IACTC,SAAS;IACTC,QAAQ;IACRC,QAAQ;IACRC,QAAQ;IACRC,cAAc;AAChB;uCAEeC,OAAOC,MAAM,CAACZ","ignoreList":[0]}},
    {"offset": {"line": 48509, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/InterpolationType.js"],"sourcesContent":["/**\n * An enum describing the type of interpolation used in a glTF animation.\n *\n * @enum {number}\n *\n * @private\n */\nconst InterpolationType = {\n  STEP: 0,\n  LINEAR: 1,\n  CUBICSPLINE: 2,\n};\n\nexport default Object.freeze(InterpolationType);\n"],"names":["InterpolationType","STEP","LINEAR","CUBICSPLINE","Object","freeze"],"mappings":";;;;AAAA;;;;;;CAMC,GACD,MAAMA,oBAAoB;IACxBC,MAAM;IACNC,QAAQ;IACRC,aAAa;AACf;uCAEeC,OAAOC,MAAM,CAACL","ignoreList":[0]}},
    {"offset": {"line": 48529, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/addAllToArray.js"],"sourcesContent":["import defined from \"./defined.js\";\n\n/**\n * Adds all elements from the given source array to the given target array.\n *\n * If the <code>source</code> is <code>null</code>, <code>undefined</code>,\n * or empty, then nothing will be done. Otherwise, this has the same\n * semantics as<br>\n * <code>for (const s of source) target.push(s);</code><br>\n * but is usually more efficient than a <code>for</code>-loop, and does not\n * put the elements of the source on the stack, as it would be done with the\n * spread operator or when using <code>target.push.apply(source)</code>.\n *\n * @function\n * @private\n *\n * @param {Array} target The target array\n * @param {Array|undefined} source The source array\n *\n * @example\n * const target = [ 0, 1, 2 ];\n * const source = [ 3, 4, 5 ];\n * Cesium.addAllToArray(target, source);\n * // The target is now [ 0, 1, 2, 3, 4, 5 ]\n */\nfunction addAllToArray(target, source) {\n  if (!defined(source)) {\n    return;\n  }\n  const sourceLength = source.length;\n  if (sourceLength === 0) {\n    return;\n  }\n  const targetLength = target.length;\n  target.length += sourceLength;\n  for (let i = 0; i < sourceLength; i++) {\n    target[targetLength + i] = source[i];\n  }\n}\nexport default addAllToArray;\n"],"names":["addAllToArray","target","source","sourceLength","length","targetLength","i"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;;CAsBC,GACD,SAASA,cAAcC,MAAM,EAAEC,MAAM;IACnC,IAAI,CAAC,IAAA,6KAAO,EAACA,SAAS;QACpB;IACF;IACA,MAAMC,eAAeD,OAAOE,MAAM;IAClC,IAAID,iBAAiB,GAAG;QACtB;IACF;IACA,MAAME,eAAeJ,OAAOG,MAAM;IAClCH,OAAOG,MAAM,IAAID;IACjB,IAAK,IAAIG,IAAI,GAAGA,IAAIH,cAAcG,IAAK;QACrCL,MAAM,CAACI,eAAeC,EAAE,GAAGJ,MAAM,CAACI,EAAE;IACtC;AACF;uCACeN","ignoreList":[0]}},
    {"offset": {"line": 48576, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/getStringFromTypedArray.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport RuntimeError from \"./RuntimeError.js\";\n\n/**\n * Reads a string from a Uint8Array.\n *\n * @function\n *\n * @param {Uint8Array} uint8Array The Uint8Array to read from.\n * @param {number} [byteOffset=0] The byte offset to start reading from.\n * @param {number} [byteLength] The byte length to read. If byteLength is omitted the remainder of the buffer is read.\n * @returns {string} The string.\n *\n * @private\n */\nfunction getStringFromTypedArray(uint8Array, byteOffset, byteLength) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(uint8Array)) {\n    throw new DeveloperError(\"uint8Array is required.\");\n  }\n  if (byteOffset < 0) {\n    throw new DeveloperError(\"byteOffset cannot be negative.\");\n  }\n  if (byteLength < 0) {\n    throw new DeveloperError(\"byteLength cannot be negative.\");\n  }\n  if (byteOffset + byteLength > uint8Array.byteLength) {\n    throw new DeveloperError(\"sub-region exceeds array bounds.\");\n  }\n  //>>includeEnd('debug');\n\n  byteOffset = byteOffset ?? 0;\n  byteLength = byteLength ?? uint8Array.byteLength - byteOffset;\n\n  uint8Array = uint8Array.subarray(byteOffset, byteOffset + byteLength);\n\n  return getStringFromTypedArray.decode(uint8Array);\n}\n\n// Exposed functions for testing\ngetStringFromTypedArray.decodeWithTextDecoder = function (view) {\n  const decoder = new TextDecoder(\"utf-8\");\n  return decoder.decode(view);\n};\n\ngetStringFromTypedArray.decodeWithFromCharCode = function (view) {\n  let result = \"\";\n  const codePoints = utf8Handler(view);\n  const length = codePoints.length;\n  for (let i = 0; i < length; ++i) {\n    let cp = codePoints[i];\n    if (cp <= 0xffff) {\n      result += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      result += String.fromCharCode((cp >> 10) + 0xd800, (cp & 0x3ff) + 0xdc00);\n    }\n  }\n  return result;\n};\n\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n\n// This code is inspired by public domain code found here: https://github.com/inexorabletash/text-encoding\nfunction utf8Handler(utfBytes) {\n  let codePoint = 0;\n  let bytesSeen = 0;\n  let bytesNeeded = 0;\n  let lowerBoundary = 0x80;\n  let upperBoundary = 0xbf;\n\n  const codePoints = [];\n  const length = utfBytes.length;\n  for (let i = 0; i < length; ++i) {\n    const currentByte = utfBytes[i];\n\n    // If bytesNeeded = 0, then we are starting a new character\n    if (bytesNeeded === 0) {\n      // 1 Byte Ascii character\n      if (inRange(currentByte, 0x00, 0x7f)) {\n        // Return a code point whose value is byte.\n        codePoints.push(currentByte);\n        continue;\n      }\n\n      // 2 Byte character\n      if (inRange(currentByte, 0xc2, 0xdf)) {\n        bytesNeeded = 1;\n        codePoint = currentByte & 0x1f;\n        continue;\n      }\n\n      // 3 Byte character\n      if (inRange(currentByte, 0xe0, 0xef)) {\n        // If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (currentByte === 0xe0) {\n          lowerBoundary = 0xa0;\n        }\n        // If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (currentByte === 0xed) {\n          upperBoundary = 0x9f;\n        }\n\n        bytesNeeded = 2;\n        codePoint = currentByte & 0xf;\n        continue;\n      }\n\n      // 4 Byte character\n      if (inRange(currentByte, 0xf0, 0xf4)) {\n        // If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (currentByte === 0xf0) {\n          lowerBoundary = 0x90;\n        }\n        // If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (currentByte === 0xf4) {\n          upperBoundary = 0x8f;\n        }\n\n        bytesNeeded = 3;\n        codePoint = currentByte & 0x7;\n        continue;\n      }\n\n      throw new RuntimeError(\"String decoding failed.\");\n    }\n\n    // Out of range, so ignore the first part(s) of the character and continue with this byte on its own\n    if (!inRange(currentByte, lowerBoundary, upperBoundary)) {\n      codePoint = bytesNeeded = bytesSeen = 0;\n      lowerBoundary = 0x80;\n      upperBoundary = 0xbf;\n      --i;\n      continue;\n    }\n\n    // Set appropriate boundaries, since we've now checked byte 2 of a potential longer character\n    lowerBoundary = 0x80;\n    upperBoundary = 0xbf;\n\n    // Add byte to code point\n    codePoint = (codePoint << 6) | (currentByte & 0x3f);\n\n    // We have the correct number of bytes, so push and reset for next character\n    ++bytesSeen;\n    if (bytesSeen === bytesNeeded) {\n      codePoints.push(codePoint);\n      codePoint = bytesNeeded = bytesSeen = 0;\n    }\n  }\n\n  return codePoints;\n}\n\nif (typeof TextDecoder !== \"undefined\") {\n  getStringFromTypedArray.decode =\n    getStringFromTypedArray.decodeWithTextDecoder;\n} else {\n  getStringFromTypedArray.decode =\n    getStringFromTypedArray.decodeWithFromCharCode;\n}\nexport default getStringFromTypedArray;\n"],"names":["getStringFromTypedArray","uint8Array","byteOffset","byteLength","subarray","decode","decodeWithTextDecoder","view","decoder","TextDecoder","decodeWithFromCharCode","result","codePoints","utf8Handler","length","i","cp","String","fromCharCode","inRange","a","min","max","utfBytes","codePoint","bytesSeen","bytesNeeded","lowerBoundary","upperBoundary","currentByte","push"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 48727, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/loadImageFromTypedArray.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport Resource from \"./Resource.js\";\n\n/**\n * Loads an image from a typed array.\n * @param {Object} options An object containing the following properties:\n * @param {Uint8Array} options.uint8Array The typed array containing the image data.\n * @param {string} options.format The MIME format of the image (e.g., \"image/png\").\n * @param {Request} [options.request] The request object to use to fetch the image.\n * @param {boolean} [options.flipY=false] Whether to flip the image vertically.\n * @param {boolean} [options.skipColorSpaceConversion=false] Whether to skip color space conversion.\n * @returns {Promise<HTMLImageElement|HTMLCanvasElement|ImageBitmap>|undefined} A promise that resolves to the loaded image. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.\n * @private\n */\nfunction loadImageFromTypedArray(options) {\n  const { uint8Array, format, request } = options;\n  const flipY = options.flipY ?? false;\n  const skipColorSpaceConversion = options.skipColorSpaceConversion ?? false;\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"uint8Array\", uint8Array);\n  Check.typeOf.string(\"format\", format);\n  //>>includeEnd('debug');\n\n  const blob = new Blob([uint8Array], {\n    type: format,\n  });\n\n  let blobUrl;\n  return Resource.supportsImageBitmapOptions()\n    .then(function (result) {\n      if (result) {\n        return Promise.resolve(\n          Resource.createImageBitmapFromBlob(blob, {\n            flipY: flipY,\n            premultiplyAlpha: false,\n            skipColorSpaceConversion: skipColorSpaceConversion,\n          }),\n        );\n      }\n\n      blobUrl = window.URL.createObjectURL(blob);\n      const resource = new Resource({\n        url: blobUrl,\n        request: request,\n      });\n\n      return resource.fetchImage({\n        flipY: flipY,\n        skipColorSpaceConversion: skipColorSpaceConversion,\n      });\n    })\n    .then(function (result) {\n      if (defined(blobUrl)) {\n        window.URL.revokeObjectURL(blobUrl);\n      }\n      return result;\n    })\n    .catch(function (error) {\n      if (defined(blobUrl)) {\n        window.URL.revokeObjectURL(blobUrl);\n      }\n      return Promise.reject(error);\n    });\n}\nexport default loadImageFromTypedArray;\n"],"names":["loadImageFromTypedArray","options","uint8Array","format","request","flipY","skipColorSpaceConversion","typeOf","object","string","blob","Blob","type","blobUrl","supportsImageBitmapOptions","then","result","Promise","resolve","createImageBitmapFromBlob","premultiplyAlpha","window","URL","createObjectURL","resource","url","fetchImage","revokeObjectURL","catch","error","reject"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;;;CAUC,GACD,SAASA,wBAAwBC,OAAO;IACtC,MAAM,EAAEC,UAAU,EAAEC,MAAM,EAAEC,OAAO,EAAE,GAAGH;IACxC,MAAMI,QAAQJ,QAAQI,KAAK,IAAI;IAC/B,MAAMC,2BAA2BL,QAAQK,wBAAwB,IAAI;IACrE,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,cAAcN;IAClC,2KAAK,CAACK,MAAM,CAACE,MAAM,CAAC,UAAUN;IAC9B,wBAAwB;IAExB,MAAMO,OAAO,IAAIC,KAAK;QAACT;KAAW,EAAE;QAClCU,MAAMT;IACR;IAEA,IAAIU;IACJ,OAAO,8KAAQ,CAACC,0BAA0B,GACvCC,IAAI,CAAC,SAAUC,MAAM;QACpB,IAAIA,QAAQ;YACV,OAAOC,QAAQC,OAAO,CACpB,8KAAQ,CAACC,yBAAyB,CAACT,MAAM;gBACvCL,OAAOA;gBACPe,kBAAkB;gBAClBd,0BAA0BA;YAC5B;QAEJ;QAEAO,UAAUQ,OAAOC,GAAG,CAACC,eAAe,CAACb;QACrC,MAAMc,WAAW,IAAI,8KAAQ,CAAC;YAC5BC,KAAKZ;YACLT,SAASA;QACX;QAEA,OAAOoB,SAASE,UAAU,CAAC;YACzBrB,OAAOA;YACPC,0BAA0BA;QAC5B;IACF,GACCS,IAAI,CAAC,SAAUC,MAAM;QACpB,IAAI,IAAA,6KAAO,EAACH,UAAU;YACpBQ,OAAOC,GAAG,CAACK,eAAe,CAACd;QAC7B;QACA,OAAOG;IACT,GACCY,KAAK,CAAC,SAAUC,KAAK;QACpB,IAAI,IAAA,6KAAO,EAAChB,UAAU;YACpBQ,OAAOC,GAAG,CAACK,eAAe,CAACd;QAC7B;QACA,OAAOI,QAAQa,MAAM,CAACD;IACxB;AACJ;uCACe7B","ignoreList":[0]}},
    {"offset": {"line": 48795, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/getJsonFromTypedArray.js"],"sourcesContent":["import getStringFromTypedArray from \"./getStringFromTypedArray.js\";\n\n/**\n * Parses JSON from a Uint8Array.\n *\n * @function\n *\n * @param {Uint8Array} uint8Array The Uint8Array to read from.\n * @param {number} [byteOffset=0] The byte offset to start reading from.\n * @param {number} [byteLength] The byte length to read. If byteLength is omitted the remainder of the buffer is read.\n * @returns {object} An object containing the parsed JSON.\n *\n * @private\n */\nfunction getJsonFromTypedArray(uint8Array, byteOffset, byteLength) {\n  return JSON.parse(\n    getStringFromTypedArray(uint8Array, byteOffset, byteLength),\n  );\n}\n\nexport default getJsonFromTypedArray;\n"],"names":["getJsonFromTypedArray","uint8Array","byteOffset","byteLength","JSON","parse"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;;;CAWC,GACD,SAASA,sBAAsBC,UAAU,EAAEC,UAAU,EAAEC,UAAU;IAC/D,OAAOC,KAAKC,KAAK,CACf,IAAA,6LAAuB,EAACJ,YAAYC,YAAYC;AAEpD;uCAEeH","ignoreList":[0]}},
    {"offset": {"line": 48820, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/getMagic.js"],"sourcesContent":["import getStringFromTypedArray from \"./getStringFromTypedArray.js\";\n\n/**\n * @private\n */\nfunction getMagic(uint8Array, byteOffset) {\n  byteOffset = byteOffset ?? 0;\n  return getStringFromTypedArray(\n    uint8Array,\n    byteOffset,\n    Math.min(4, uint8Array.length),\n  );\n}\nexport default getMagic;\n"],"names":["getMagic","uint8Array","byteOffset","Math","min","length"],"mappings":";;;;AAAA;;AAEA;;CAEC,GACD,SAASA,SAASC,UAAU,EAAEC,UAAU;IACtCA,aAAaA,cAAc;IAC3B,OAAO,IAAA,6LAAuB,EAC5BD,YACAC,YACAC,KAAKC,GAAG,CAAC,GAAGH,WAAWI,MAAM;AAEjC;uCACeL","ignoreList":[0]}},
    {"offset": {"line": 48837, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/resizeImageToNextPowerOfTwo.js"],"sourcesContent":["import CesiumMath from \"./Math.js\";\n\n/**\n * Resizes an image to ensure both width and height are powers of 2.\n * NOTE: The input image is resampled larger, rather than padded.\n * The aspect ratio of the image may change.\n *\n * @param {HTMLImageElement|HTMLCanvasElement} image The image to be resized\n * @returns {HTMLCanvasElement} A new canvas with the resized image drawn to it\n *\n * @private\n */\nfunction resizeImageToNextPowerOfTwo(image) {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = CesiumMath.nextPowerOfTwo(image.width);\n  canvas.height = CesiumMath.nextPowerOfTwo(image.height);\n  const canvasContext = canvas.getContext(\"2d\");\n  canvasContext.drawImage(\n    image,\n    0,\n    0,\n    image.width,\n    image.height,\n    0,\n    0,\n    canvas.width,\n    canvas.height,\n  );\n  return canvas;\n}\nexport default resizeImageToNextPowerOfTwo;\n"],"names":["resizeImageToNextPowerOfTwo","image","canvas","document","createElement","width","nextPowerOfTwo","height","canvasContext","getContext","drawImage"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;CASC,GACD,SAASA,4BAA4BC,KAAK;IACxC,MAAMC,SAASC,SAASC,aAAa,CAAC;IACtCF,OAAOG,KAAK,GAAG,0KAAU,CAACC,cAAc,CAACL,MAAMI,KAAK;IACpDH,OAAOK,MAAM,GAAG,0KAAU,CAACD,cAAc,CAACL,MAAMM,MAAM;IACtD,MAAMC,gBAAgBN,OAAOO,UAAU,CAAC;IACxCD,cAAcE,SAAS,CACrBT,OACA,GACA,GACAA,MAAMI,KAAK,EACXJ,MAAMM,MAAM,EACZ,GACA,GACAL,OAAOG,KAAK,EACZH,OAAOK,MAAM;IAEf,OAAOL;AACT;uCACeF","ignoreList":[0]}},
    {"offset": {"line": 48865, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Spline.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport CesiumMath from \"./Math.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Quaternion from \"./Quaternion.js\";\n\n/**\n * Creates a curve parameterized and evaluated by time. This type describes an interface\n * and is not intended to be instantiated directly.\n *\n * @alias Spline\n * @constructor\n *\n * @see CatmullRomSpline\n * @see LinearSpline\n * @see HermiteSpline\n * @see QuaternionSpline\n * @see MorphWeightSpline\n */\nfunction Spline() {\n  /**\n   * An array of times for the control points.\n   * @type {number[]}\n   * @default undefined\n   */\n  this.times = undefined;\n\n  /**\n   * An array of control points.\n   * @type {Cartesian3[]|Quaternion[]}\n   * @default undefined\n   */\n  this.points = undefined;\n\n  DeveloperError.throwInstantiationError();\n}\n\n/**\n * Gets the type of the point. This helps a spline determine how to interpolate\n * and return its values.\n *\n * @param {number|Cartesian3|Quaternion} point\n * @returns {*} The type of the point.\n *\n * @exception {DeveloperError} value must be a Cartesian3, Quaternion, or number.\n *\n * @private\n */\nSpline.getPointType = function (point) {\n  if (typeof point === \"number\") {\n    return Number;\n  }\n  if (point instanceof Cartesian3) {\n    return Cartesian3;\n  }\n  if (point instanceof Quaternion) {\n    return Quaternion;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    \"point must be a Cartesian3, Quaternion, or number.\",\n  );\n  //>>includeEnd('debug');\n};\n\n/**\n * Evaluates the curve at a given time.\n * @function\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {Cartesian3|Quaternion|number[]} [result] The object onto which to store the result.\n * @returns {Cartesian3|Quaternion|number[]} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nSpline.prototype.evaluate = DeveloperError.throwInstantiationError;\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n *\n * @param {number} time The time.\n * @param {number} startIndex The index from which to start the search.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nSpline.prototype.findTimeInterval = function (time, startIndex) {\n  const times = this.times;\n  const length = times.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"time\", time);\n  if (time < times[0] || time > times[length - 1]) {\n    throw new DeveloperError(\"time is out of range.\");\n  }\n  //>>includeEnd('debug');\n\n  // Take advantage of temporal coherence by checking current, next and previous intervals\n  // for containment of time.\n  startIndex = startIndex ?? 0;\n\n  if (time >= times[startIndex]) {\n    if (startIndex + 1 < length && time < times[startIndex + 1]) {\n      return startIndex;\n    } else if (startIndex + 2 < length && time < times[startIndex + 2]) {\n      return startIndex + 1;\n    }\n  } else if (startIndex - 1 >= 0 && time >= times[startIndex - 1]) {\n    return startIndex - 1;\n  }\n\n  // The above failed so do a linear search. For the use cases so far, the\n  // length of the list is less than 10. In the future, if there is a bottle neck,\n  // it might be here.\n\n  let i;\n  if (time > times[startIndex]) {\n    for (i = startIndex; i < length - 1; ++i) {\n      if (time >= times[i] && time < times[i + 1]) {\n        break;\n      }\n    }\n  } else {\n    for (i = startIndex - 1; i >= 0; --i) {\n      if (time >= times[i] && time < times[i + 1]) {\n        break;\n      }\n    }\n  }\n\n  if (i === length - 1) {\n    i = length - 2;\n  }\n\n  return i;\n};\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around the animation period.\n */\nSpline.prototype.wrapTime = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"time\", time);\n  //>>includeEnd('debug');\n\n  const times = this.times;\n  const timeEnd = times[times.length - 1];\n  const timeStart = times[0];\n  const timeStretch = timeEnd - timeStart;\n  let divs;\n  if (time < timeStart) {\n    divs = Math.floor((timeStart - time) / timeStretch) + 1;\n    time += divs * timeStretch;\n  }\n  if (time > timeEnd) {\n    divs = Math.floor((time - timeEnd) / timeStretch) + 1;\n    time -= divs * timeStretch;\n  }\n  return time;\n};\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nSpline.prototype.clampTime = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"time\", time);\n  //>>includeEnd('debug');\n\n  const times = this.times;\n  return CesiumMath.clamp(time, times[0], times[times.length - 1]);\n};\n\nexport default Spline;\n"],"names":["Spline","times","undefined","points","throwInstantiationError","getPointType","point","Number","prototype","evaluate","findTimeInterval","time","startIndex","length","typeOf","number","i","wrapTime","timeEnd","timeStart","timeStretch","divs","Math","floor","clampTime","clamp"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 49037, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/ConstantSpline.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Spline from \"./Spline.js\";\n\n/**\n * A spline that evaluates to a constant value. Although this follows the {@link Spline} interface,\n * it does not maintain an internal array of times since its value never changes.\n *\n * @alias ConstantSpline\n * @constructor\n *\n * @param {number|Cartesian3|Quaternion} value The constant value that the spline evaluates to.\n *\n * @example\n * const position = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const spline = new Cesium.ConstantSpline(position);\n *\n * const p0 = spline.evaluate(0.0);\n *\n * @see LinearSpline\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see QuaternionSpline\n * @see MorphWeightSpline\n */\nfunction ConstantSpline(value) {\n  this._value = value;\n  this._valueType = Spline.getPointType(value);\n}\n\nObject.defineProperties(ConstantSpline.prototype, {\n  /**\n   * The constant value that the spline evaluates to.\n   *\n   * @memberof ConstantSpline.prototype\n   *\n   * @type {number|Cartesian3|Quaternion}\n   * @readonly\n   */\n  value: {\n    get: function () {\n      return this._value;\n    },\n  },\n});\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n *\n * Since a constant spline has no internal times array, this will throw an error.\n * @function\n *\n * @param {number} time The time.\n *\n * @exception {DeveloperError} findTimeInterval cannot be called on a ConstantSpline.\n */\nConstantSpline.prototype.findTimeInterval = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    \"findTimeInterval cannot be called on a ConstantSpline.\",\n  );\n  //>>includeEnd('debug');\n};\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around to the updated animation.\n */\nConstantSpline.prototype.wrapTime = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"time\", time);\n  //>>includeEnd('debug');\n\n  return 0.0;\n};\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nConstantSpline.prototype.clampTime = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"time\", time);\n  //>>includeEnd('debug');\n\n  return 0.0;\n};\n\n/**\n * Evaluates the curve at a given time.\n * @function\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {Cartesian3|Quaternion} [result] The object onto which to store the result.\n * @returns {number|Cartesian3|Quaternion} The modified result parameter or the value that the constant spline represents.\n */\nConstantSpline.prototype.evaluate = function (time, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"time\", time);\n  //>>includeEnd('debug');\n\n  const value = this._value;\n  const ValueType = this._valueType;\n\n  if (ValueType === Number) {\n    return value;\n  }\n\n  return ValueType.clone(value, result);\n};\n\nexport default ConstantSpline;\n"],"names":["ConstantSpline","value","_value","_valueType","getPointType","Object","defineProperties","prototype","get","findTimeInterval","time","wrapTime","typeOf","number","clampTime","evaluate","result","ValueType","Number","clone"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;;;;;;;;;;;;;CAoBC,GACD,SAASA,eAAeC,KAAK;IAC3B,IAAI,CAACC,MAAM,GAAGD;IACd,IAAI,CAACE,UAAU,GAAG,4KAAM,CAACC,YAAY,CAACH;AACxC;AAEAI,OAAOC,gBAAgB,CAACN,eAAeO,SAAS,EAAE;IAChD;;;;;;;GAOC,GACDN,OAAO;QACLO,KAAK;YACH,OAAO,IAAI,CAACN,MAAM;QACpB;IACF;AACF;AAEA;;;;;;;;;;CAUC,GACDF,eAAeO,SAAS,CAACE,gBAAgB,GAAG,SAAUC,IAAI;IACxD,yCAAyC;IACzC,MAAM,IAAI,oLAAc,CACtB;AAEF,wBAAwB;AAC1B;AAEA;;;;;;CAMC,GACDV,eAAeO,SAAS,CAACI,QAAQ,GAAG,SAAUD,IAAI;IAChD,yCAAyC;IACzC,2KAAK,CAACE,MAAM,CAACC,MAAM,CAAC,QAAQH;IAC5B,wBAAwB;IAExB,OAAO;AACT;AAEA;;;;;;CAMC,GACDV,eAAeO,SAAS,CAACO,SAAS,GAAG,SAAUJ,IAAI;IACjD,yCAAyC;IACzC,2KAAK,CAACE,MAAM,CAACC,MAAM,CAAC,QAAQH;IAC5B,wBAAwB;IAExB,OAAO;AACT;AAEA;;;;;;;CAOC,GACDV,eAAeO,SAAS,CAACQ,QAAQ,GAAG,SAAUL,IAAI,EAAEM,MAAM;IACxD,yCAAyC;IACzC,2KAAK,CAACJ,MAAM,CAACC,MAAM,CAAC,QAAQH;IAC5B,wBAAwB;IAExB,MAAMT,QAAQ,IAAI,CAACC,MAAM;IACzB,MAAMe,YAAY,IAAI,CAACd,UAAU;IAEjC,IAAIc,cAAcC,QAAQ;QACxB,OAAOjB;IACT;IAEA,OAAOgB,UAAUE,KAAK,CAAClB,OAAOe;AAChC;uCAEehB","ignoreList":[0]}},
    {"offset": {"line": 49147, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/LinearSpline.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Spline from \"./Spline.js\";\n\n/**\n * A spline that uses piecewise linear interpolation to create a curve.\n *\n * @alias LinearSpline\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {number[]|Cartesian3[]} options.points The array of control points.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n *\n * @example\n * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const spline = new Cesium.LinearSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n * @see ConstantSpline\n * @see SteppedSpline\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see QuaternionSpline\n * @see MorphWeightSpline\n */\nfunction LinearSpline(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const points = options.points;\n  const times = options.times;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\",\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._points = points;\n  this._pointType = Spline.getPointType(points[0]);\n\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(LinearSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof LinearSpline.prototype\n   *\n   * @type {number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of {@link Cartesian3} control points.\n   *\n   * @memberof LinearSpline.prototype\n   *\n   * @type {number[]|Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n});\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {number} time The time.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nLinearSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around to the updated animation.\n */\nLinearSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nLinearSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {number|Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nLinearSpline.prototype.evaluate = function (time, result) {\n  const points = this.points;\n  const times = this.times;\n\n  const i = (this._lastTimeIndex = this.findTimeInterval(\n    time,\n    this._lastTimeIndex,\n  ));\n  const u = (time - times[i]) / (times[i + 1] - times[i]);\n\n  const PointType = this._pointType;\n  if (PointType === Number) {\n    return (1.0 - u) * points[i] + u * points[i + 1];\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.lerp(points[i], points[i + 1], u, result);\n};\n\nexport default LinearSpline;\n"],"names":["LinearSpline","options","EMPTY_OBJECT","points","times","length","_times","_points","_pointType","getPointType","_lastTimeIndex","Object","defineProperties","prototype","get","findTimeInterval","wrapTime","clampTime","evaluate","time","result","i","u","PointType","Number","lerp"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoCC,GACD,SAASA,aAAaC,OAAO;IAC3BA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC,MAAMC,SAASF,QAAQE,MAAM;IAC7B,MAAMC,QAAQH,QAAQG,KAAK;IAE3B,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACD,WAAW,CAAC,IAAA,6KAAO,EAACC,QAAQ;QACvC,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAID,OAAOE,MAAM,GAAG,GAAG;QACrB,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,IAAID,MAAMC,MAAM,KAAKF,OAAOE,MAAM,EAAE;QAClC,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,IAAI,CAACC,MAAM,GAAGF;IACd,IAAI,CAACG,OAAO,GAAGJ;IACf,IAAI,CAACK,UAAU,GAAG,4KAAM,CAACC,YAAY,CAACN,MAAM,CAAC,EAAE;IAE/C,IAAI,CAACO,cAAc,GAAG;AACxB;AAEAC,OAAOC,gBAAgB,CAACZ,aAAaa,SAAS,EAAE;IAC9C;;;;;;;GAOC,GACDT,OAAO;QACLU,KAAK;YACH,OAAO,IAAI,CAACR,MAAM;QACpB;IACF;IAEA;;;;;;;GAOC,GACDH,QAAQ;QACNW,KAAK;YACH,OAAO,IAAI,CAACP,OAAO;QACrB;IACF;AACF;AAEA;;;;;;;;;;;CAWC,GACDP,aAAaa,SAAS,CAACE,gBAAgB,GAAG,4KAAM,CAACF,SAAS,CAACE,gBAAgB;AAE3E;;;;;;CAMC,GACDf,aAAaa,SAAS,CAACG,QAAQ,GAAG,4KAAM,CAACH,SAAS,CAACG,QAAQ;AAE3D;;;;;;CAMC,GACDhB,aAAaa,SAAS,CAACI,SAAS,GAAG,4KAAM,CAACJ,SAAS,CAACI,SAAS;AAE7D;;;;;;;;;;CAUC,GACDjB,aAAaa,SAAS,CAACK,QAAQ,GAAG,SAAUC,IAAI,EAAEC,MAAM;IACtD,MAAMjB,SAAS,IAAI,CAACA,MAAM;IAC1B,MAAMC,QAAQ,IAAI,CAACA,KAAK;IAExB,MAAMiB,IAAK,IAAI,CAACX,cAAc,GAAG,IAAI,CAACK,gBAAgB,CACpDI,MACA,IAAI,CAACT,cAAc;IAErB,MAAMY,IAAI,CAACH,OAAOf,KAAK,CAACiB,EAAE,IAAI,CAACjB,KAAK,CAACiB,IAAI,EAAE,GAAGjB,KAAK,CAACiB,EAAE;IAEtD,MAAME,YAAY,IAAI,CAACf,UAAU;IACjC,IAAIe,cAAcC,QAAQ;QACxB,OAAO,CAAC,MAAMF,CAAC,IAAInB,MAAM,CAACkB,EAAE,GAAGC,IAAInB,MAAM,CAACkB,IAAI,EAAE;IAClD;IAEA,IAAI,CAAC,IAAA,6KAAO,EAACD,SAAS;QACpBA,SAAS,IAAI,gLAAU;IACzB;IAEA,OAAO,gLAAU,CAACK,IAAI,CAACtB,MAAM,CAACkB,EAAE,EAAElB,MAAM,CAACkB,IAAI,EAAE,EAAEC,GAAGF;AACtD;uCAEepB","ignoreList":[0]}},
    {"offset": {"line": 49298, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TridiagonalSystemSolver.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Uses the Tridiagonal Matrix Algorithm, also known as the Thomas Algorithm, to solve\n * a system of linear equations where the coefficient matrix is a tridiagonal matrix.\n *\n * @namespace TridiagonalSystemSolver\n */\nconst TridiagonalSystemSolver = {};\n\n/**\n * Solves a tridiagonal system of linear equations.\n *\n * @param {number[]} diagonal An array with length <code>n</code> that contains the diagonal of the coefficient matrix.\n * @param {number[]} lower An array with length <code>n - 1</code> that contains the lower diagonal of the coefficient matrix.\n * @param {number[]} upper An array with length <code>n - 1</code> that contains the upper diagonal of the coefficient matrix.\n * @param {Cartesian3[]} right An array of Cartesians with length <code>n</code> that is the right side of the system of equations.\n *\n * @exception {DeveloperError} diagonal and right must have the same lengths.\n * @exception {DeveloperError} lower and upper must have the same lengths.\n * @exception {DeveloperError} lower and upper must be one less than the length of diagonal.\n *\n * @performance Linear time.\n *\n * @example\n * const lowerDiagonal = [1.0, 1.0, 1.0, 1.0];\n * const diagonal = [2.0, 4.0, 4.0, 4.0, 2.0];\n * const upperDiagonal = [1.0, 1.0, 1.0, 1.0];\n * const rightHandSide = [\n *     new Cesium.Cartesian3(410757.0, -1595711.0, 1375302.0),\n *     new Cesium.Cartesian3(-5986705.0, -2190640.0, 1099600.0),\n *     new Cesium.Cartesian3(-12593180.0, 288588.0, -1755549.0),\n *     new Cesium.Cartesian3(-5349898.0, 2457005.0, -2685438.0),\n *     new Cesium.Cartesian3(845820.0, 1573488.0, -1205591.0)\n * ];\n *\n * const solution = Cesium.TridiagonalSystemSolver.solve(lowerDiagonal, diagonal, upperDiagonal, rightHandSide);\n *\n * @returns {Cartesian3[]} An array of Cartesians with length <code>n</code> that is the solution to the tridiagonal system of equations.\n */\nTridiagonalSystemSolver.solve = function (lower, diagonal, upper, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(lower) || !(lower instanceof Array)) {\n    throw new DeveloperError(\"The array lower is required.\");\n  }\n  if (!defined(diagonal) || !(diagonal instanceof Array)) {\n    throw new DeveloperError(\"The array diagonal is required.\");\n  }\n  if (!defined(upper) || !(upper instanceof Array)) {\n    throw new DeveloperError(\"The array upper is required.\");\n  }\n  if (!defined(right) || !(right instanceof Array)) {\n    throw new DeveloperError(\"The array right is required.\");\n  }\n  if (diagonal.length !== right.length) {\n    throw new DeveloperError(\"diagonal and right must have the same lengths.\");\n  }\n  if (lower.length !== upper.length) {\n    throw new DeveloperError(\"lower and upper must have the same lengths.\");\n  } else if (lower.length !== diagonal.length - 1) {\n    throw new DeveloperError(\n      \"lower and upper must be one less than the length of diagonal.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const c = new Array(upper.length);\n  const d = new Array(right.length);\n  const x = new Array(right.length);\n\n  let i;\n  for (i = 0; i < d.length; i++) {\n    d[i] = new Cartesian3();\n    x[i] = new Cartesian3();\n  }\n\n  c[0] = upper[0] / diagonal[0];\n  d[0] = Cartesian3.multiplyByScalar(right[0], 1.0 / diagonal[0], d[0]);\n\n  let scalar;\n  for (i = 1; i < c.length; ++i) {\n    scalar = 1.0 / (diagonal[i] - c[i - 1] * lower[i - 1]);\n    c[i] = upper[i] * scalar;\n    d[i] = Cartesian3.subtract(\n      right[i],\n      Cartesian3.multiplyByScalar(d[i - 1], lower[i - 1], d[i]),\n      d[i],\n    );\n    d[i] = Cartesian3.multiplyByScalar(d[i], scalar, d[i]);\n  }\n\n  scalar = 1.0 / (diagonal[i] - c[i - 1] * lower[i - 1]);\n  d[i] = Cartesian3.subtract(\n    right[i],\n    Cartesian3.multiplyByScalar(d[i - 1], lower[i - 1], d[i]),\n    d[i],\n  );\n  d[i] = Cartesian3.multiplyByScalar(d[i], scalar, d[i]);\n\n  x[x.length - 1] = d[d.length - 1];\n  for (i = x.length - 2; i >= 0; --i) {\n    x[i] = Cartesian3.subtract(\n      d[i],\n      Cartesian3.multiplyByScalar(x[i + 1], c[i], x[i]),\n      x[i],\n    );\n  }\n\n  return x;\n};\nexport default TridiagonalSystemSolver;\n"],"names":["TridiagonalSystemSolver","solve","lower","diagonal","upper","right","Array","length","c","d","x","i","multiplyByScalar","scalar","subtract"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 49397, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/HermiteSpline.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport LinearSpline from \"./LinearSpline.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Spline from \"./Spline.js\";\nimport TridiagonalSystemSolver from \"./TridiagonalSystemSolver.js\";\n\nconst scratchLower = [];\nconst scratchDiagonal = [];\nconst scratchUpper = [];\nconst scratchRight = [];\n\nfunction generateClamped(points, firstTangent, lastTangent) {\n  const l = scratchLower;\n  const u = scratchUpper;\n  const d = scratchDiagonal;\n  const r = scratchRight;\n\n  l.length = u.length = points.length - 1;\n  d.length = r.length = points.length;\n\n  let i;\n  l[0] = d[0] = 1.0;\n  u[0] = 0.0;\n\n  let right = r[0];\n  if (!defined(right)) {\n    right = r[0] = new Cartesian3();\n  }\n  Cartesian3.clone(firstTangent, right);\n\n  for (i = 1; i < l.length - 1; ++i) {\n    l[i] = u[i] = 1.0;\n    d[i] = 4.0;\n\n    right = r[i];\n    if (!defined(right)) {\n      right = r[i] = new Cartesian3();\n    }\n    Cartesian3.subtract(points[i + 1], points[i - 1], right);\n    Cartesian3.multiplyByScalar(right, 3.0, right);\n  }\n\n  l[i] = 0.0;\n  u[i] = 1.0;\n  d[i] = 4.0;\n\n  right = r[i];\n  if (!defined(right)) {\n    right = r[i] = new Cartesian3();\n  }\n  Cartesian3.subtract(points[i + 1], points[i - 1], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n\n  d[i + 1] = 1.0;\n  right = r[i + 1];\n  if (!defined(right)) {\n    right = r[i + 1] = new Cartesian3();\n  }\n  Cartesian3.clone(lastTangent, right);\n\n  return TridiagonalSystemSolver.solve(l, d, u, r);\n}\n\nfunction generateNatural(points) {\n  const l = scratchLower;\n  const u = scratchUpper;\n  const d = scratchDiagonal;\n  const r = scratchRight;\n\n  l.length = u.length = points.length - 1;\n  d.length = r.length = points.length;\n\n  let i;\n  l[0] = u[0] = 1.0;\n  d[0] = 2.0;\n\n  let right = r[0];\n  if (!defined(right)) {\n    right = r[0] = new Cartesian3();\n  }\n  Cartesian3.subtract(points[1], points[0], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n\n  for (i = 1; i < l.length; ++i) {\n    l[i] = u[i] = 1.0;\n    d[i] = 4.0;\n\n    right = r[i];\n    if (!defined(right)) {\n      right = r[i] = new Cartesian3();\n    }\n    Cartesian3.subtract(points[i + 1], points[i - 1], right);\n    Cartesian3.multiplyByScalar(right, 3.0, right);\n  }\n\n  d[i] = 2.0;\n\n  right = r[i];\n  if (!defined(right)) {\n    right = r[i] = new Cartesian3();\n  }\n  Cartesian3.subtract(points[i], points[i - 1], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n\n  return TridiagonalSystemSolver.solve(l, d, u, r);\n}\n\n/**\n * A Hermite spline is a cubic interpolating spline. Points, incoming tangents, outgoing tangents, and times\n * must be defined for each control point. The outgoing tangents are defined for points [0, n - 2] and the incoming\n * tangents are defined for points [1, n - 1]. For example, when interpolating a segment of the curve between <code>points[i]</code> and\n * <code>points[i + 1]</code>, the tangents at the points will be <code>outTangents[i]</code> and <code>inTangents[i]</code>,\n * respectively.\n *\n * @alias HermiteSpline\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3[]} options.inTangents The array of incoming tangents at each control point.\n * @param {Cartesian3[]} options.outTangents The array of outgoing tangents at each control point.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n * @exception {DeveloperError} inTangents and outTangents must have a length equal to points.length - 1.\n * @exception {DeveloperError} inTangents and outTangents must be of the same type as points.\n *\n * @example\n * // Create a G<sup>1</sup> continuous Hermite spline\n * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const spline = new Cesium.HermiteSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     outTangents : [\n *         new Cesium.Cartesian3(1125196, -161816, 270551),\n *         new Cesium.Cartesian3(-996690.5, -365906.5, 184028.5),\n *         new Cesium.Cartesian3(-2096917, 48379.5, -292683.5),\n *         new Cesium.Cartesian3(-890902.5, 408999.5, -447115)\n *     ],\n *     inTangents : [\n *         new Cesium.Cartesian3(-1993381, -731813, 368057),\n *         new Cesium.Cartesian3(-4193834, 96759, -585367),\n *         new Cesium.Cartesian3(-1781805, 817999, -894230),\n *         new Cesium.Cartesian3(1165345, 112641, 47281)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n * @see ConstantSpline\n * @see SteppedSpline\n * @see LinearSpline\n * @see CatmullRomSpline\n * @see QuaternionSpline\n * @see MorphWeightSpline\n */\nfunction HermiteSpline(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const points = options.points;\n  const times = options.times;\n  const inTangents = options.inTangents;\n  const outTangents = options.outTangents;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(points) ||\n    !defined(times) ||\n    !defined(inTangents) ||\n    !defined(outTangents)\n  ) {\n    throw new DeveloperError(\n      \"times, points, inTangents, and outTangents are required.\",\n    );\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\",\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  if (\n    inTangents.length !== outTangents.length ||\n    inTangents.length !== points.length - 1\n  ) {\n    throw new DeveloperError(\n      \"inTangents and outTangents must have a length equal to points.length - 1.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._points = points;\n  this._pointType = Spline.getPointType(points[0]);\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    this._pointType !== Spline.getPointType(inTangents[0]) ||\n    this._pointType !== Spline.getPointType(outTangents[0])\n  ) {\n    throw new DeveloperError(\n      \"inTangents and outTangents must be of the same type as points.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._inTangents = inTangents;\n  this._outTangents = outTangents;\n\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(HermiteSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of control points.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n\n  /**\n   * An array of incoming tangents at each control point.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  inTangents: {\n    get: function () {\n      return this._inTangents;\n    },\n  },\n\n  /**\n   * An array of outgoing tangents at each control point.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  outTangents: {\n    get: function () {\n      return this._outTangents;\n    },\n  },\n});\n\n/**\n * Creates a spline where the tangents at each control point are the same.\n * The curves are guaranteed to be at least in the class C<sup>1</sup>.\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3[]} options.tangents The array of tangents at the control points.\n * @returns {HermiteSpline} A hermite spline.\n *\n * @exception {DeveloperError} points, times and tangents are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times, points and tangents must have the same length.\n *\n * @example\n * const points = [\n *     new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *     new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *     new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *     new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *     new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n * ];\n *\n * // Add tangents\n * const tangents = new Array(points.length);\n * tangents[0] = new Cesium.Cartesian3(1125196, -161816, 270551);\n * const temp = new Cesium.Cartesian3();\n * for (let i = 1; i < tangents.length - 1; ++i) {\n *     tangents[i] = Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.subtract(points[i + 1], points[i - 1], temp), 0.5, new Cesium.Cartesian3());\n * }\n * tangents[tangents.length - 1] = new Cesium.Cartesian3(1165345, 112641, 47281);\n *\n * const spline = Cesium.HermiteSpline.createC1({\n *     times : times,\n *     points : points,\n *     tangents : tangents\n * });\n */\nHermiteSpline.createC1 = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const times = options.times;\n  const points = options.points;\n  const tangents = options.tangents;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times) || !defined(tangents)) {\n    throw new DeveloperError(\"points, times and tangents are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\",\n    );\n  }\n  if (times.length !== points.length || times.length !== tangents.length) {\n    throw new DeveloperError(\n      \"times, points and tangents must have the same length.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const outTangents = tangents.slice(0, tangents.length - 1);\n  const inTangents = tangents.slice(1, tangents.length);\n\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n};\n\n/**\n * Creates a natural cubic spline. The tangents at the control points are generated\n * to create a curve in the class C<sup>2</sup>.\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @returns {HermiteSpline|LinearSpline} A hermite spline, or a linear spline if less than 3 control points were given.\n *\n * @exception {DeveloperError} points and times are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n * @example\n * // Create a natural cubic spline above the earth from Philadelphia to Los Angeles.\n * const spline = Cesium.HermiteSpline.createNaturalCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n */\nHermiteSpline.createNaturalCubic = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const times = options.times;\n  const points = options.points;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\",\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  if (points.length < 3) {\n    return new LinearSpline({\n      points: points,\n      times: times,\n    });\n  }\n\n  const tangents = generateNatural(points);\n  const outTangents = tangents.slice(0, tangents.length - 1);\n  const inTangents = tangents.slice(1, tangents.length);\n\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n};\n\n/**\n * Creates a clamped cubic spline. The tangents at the interior control points are generated\n * to create a curve in the class C<sup>2</sup>.\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times The array of control point times.\n * @param {number[]|Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3} options.firstTangent The outgoing tangent of the first control point.\n * @param {Cartesian3} options.lastTangent The incoming tangent of the last control point.\n * @returns {HermiteSpline|LinearSpline} A hermite spline, or a linear spline if less than 3 control points were given.\n *\n * @exception {DeveloperError} points, times, firstTangent and lastTangent are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n * @exception {DeveloperError} firstTangent and lastTangent must be of the same type as points.\n *\n * @example\n * // Create a clamped cubic spline above the earth from Philadelphia to Los Angeles.\n * const spline = Cesium.HermiteSpline.createClampedCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     firstTangent : new Cesium.Cartesian3(1125196, -161816, 270551),\n *     lastTangent : new Cesium.Cartesian3(1165345, 112641, 47281)\n * });\n */\nHermiteSpline.createClampedCubic = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const times = options.times;\n  const points = options.points;\n  const firstTangent = options.firstTangent;\n  const lastTangent = options.lastTangent;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(points) ||\n    !defined(times) ||\n    !defined(firstTangent) ||\n    !defined(lastTangent)\n  ) {\n    throw new DeveloperError(\n      \"points, times, firstTangent and lastTangent are required.\",\n    );\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\",\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  const PointType = Spline.getPointType(points[0]);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    PointType !== Spline.getPointType(firstTangent) ||\n    PointType !== Spline.getPointType(lastTangent)\n  ) {\n    throw new DeveloperError(\n      \"firstTangent and lastTangent must be of the same type as points.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (points.length < 3) {\n    return new LinearSpline({\n      points: points,\n      times: times,\n    });\n  }\n\n  const tangents = generateClamped(points, firstTangent, lastTangent);\n  const outTangents = tangents.slice(0, tangents.length - 1);\n  const inTangents = tangents.slice(1, tangents.length);\n\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n};\n\n//prettier-ignore\nHermiteSpline.hermiteCoefficientMatrix = new Matrix4(\n  2.0, -3.0, 0.0, 1.0,\n  -2.0, 3.0, 0.0, 0.0,\n  1.0, -2.0, 1.0, 0.0,\n  1.0, -1.0, 0.0, 0.0\n);\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {number} time The time.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nHermiteSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\nconst scratchTimeVec = new Cartesian4();\nconst scratchTemp = new Cartesian3();\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around to the updated animation.\n */\nHermiteSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nHermiteSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nHermiteSpline.prototype.evaluate = function (time, result) {\n  const points = this.points;\n  const times = this.times;\n  const inTangents = this.inTangents;\n  const outTangents = this.outTangents;\n\n  this._lastTimeIndex = this.findTimeInterval(time, this._lastTimeIndex);\n  const i = this._lastTimeIndex;\n\n  const timesDelta = times[i + 1] - times[i];\n  const u = (time - times[i]) / timesDelta;\n\n  const timeVec = scratchTimeVec;\n  timeVec.z = u;\n  timeVec.y = u * u;\n  timeVec.x = timeVec.y * u;\n  timeVec.w = 1.0;\n\n  // Coefficients are returned in the following order:\n  // start, end, out-tangent, in-tangent\n  const coefs = Matrix4.multiplyByVector(\n    HermiteSpline.hermiteCoefficientMatrix,\n    timeVec,\n    timeVec,\n  );\n\n  // Multiply the out-tangent and in-tangent values by the time delta.\n  coefs.z *= timesDelta;\n  coefs.w *= timesDelta;\n\n  const PointType = this._pointType;\n\n  if (PointType === Number) {\n    return (\n      points[i] * coefs.x +\n      points[i + 1] * coefs.y +\n      outTangents[i] * coefs.z +\n      inTangents[i] * coefs.w\n    );\n  }\n\n  if (!defined(result)) {\n    result = new PointType();\n  }\n\n  result = PointType.multiplyByScalar(points[i], coefs.x, result);\n  PointType.multiplyByScalar(points[i + 1], coefs.y, scratchTemp);\n  PointType.add(result, scratchTemp, result);\n  PointType.multiplyByScalar(outTangents[i], coefs.z, scratchTemp);\n  PointType.add(result, scratchTemp, result);\n  PointType.multiplyByScalar(inTangents[i], coefs.w, scratchTemp);\n  return PointType.add(result, scratchTemp, result);\n};\nexport default HermiteSpline;\n"],"names":["scratchLower","scratchDiagonal","scratchUpper","scratchRight","generateClamped","points","firstTangent","lastTangent","l","u","d","r","length","i","right","clone","subtract","multiplyByScalar","solve","generateNatural","HermiteSpline","options","EMPTY_OBJECT","times","inTangents","outTangents","_times","_points","_pointType","getPointType","_inTangents","_outTangents","_lastTimeIndex","Object","defineProperties","prototype","get","createC1","tangents","slice","createNaturalCubic","createClampedCubic","PointType","hermiteCoefficientMatrix","findTimeInterval","scratchTimeVec","scratchTemp","wrapTime","clampTime","evaluate","time","result","timesDelta","timeVec","z","y","x","w","coefs","multiplyByVector","Number","add"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 49905, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/SteppedSpline.js"],"sourcesContent":["import Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Spline from \"./Spline.js\";\n\n/**\n * A spline that is composed of piecewise constants representing a step function.\n *\n * @alias SteppedSpline\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point. The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {number[]|Cartesian3[]|Quaternion[]} options.points The array of control points.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n * @example\n * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const spline = new Cesium.SteppedSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n * @see ConstantSpline\n * @see CatmullRomSpline\n * @see HermiteSpline\n * @see LinearSpline\n * @see QuaternionSpline\n * @see MorphWeightSpline\n */\nfunction SteppedSpline(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const points = options.points;\n  const times = options.times;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\",\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._points = points;\n  this._pointType = Spline.getPointType(points[0]);\n\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(SteppedSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof SteppedSpline.prototype\n   *\n   * @type {number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of control points.\n   *\n   * @memberof SteppedSpline.prototype\n   *\n   * @type {number[]|Cartesian3[]|Quaternion[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n});\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {number} time The time.\n * @param {number} startIndex The index from which to start the search.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nSteppedSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around to the updated animation.\n */\nSteppedSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nSteppedSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {Cartesian3|Quaternion} [result] The object onto which to store the result.\n * @returns {number|Cartesian3|Quaternion} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nSteppedSpline.prototype.evaluate = function (time, result) {\n  const points = this.points;\n\n  this._lastTimeIndex = this.findTimeInterval(time, this._lastTimeIndex);\n  const i = this._lastTimeIndex;\n\n  const PointType = this._pointType;\n  if (PointType === Number) {\n    return points[i];\n  }\n\n  if (!defined(result)) {\n    result = new PointType();\n  }\n\n  return PointType.clone(points[i], result);\n};\n\nexport default SteppedSpline;\n"],"names":["SteppedSpline","options","EMPTY_OBJECT","points","times","length","_times","_points","_pointType","getPointType","_lastTimeIndex","Object","defineProperties","prototype","get","findTimeInterval","wrapTime","clampTime","evaluate","time","result","i","PointType","Number","clone"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCC,GACD,SAASA,cAAcC,OAAO;IAC5BA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC,MAAMC,SAASF,QAAQE,MAAM;IAC7B,MAAMC,QAAQH,QAAQG,KAAK;IAE3B,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACD,WAAW,CAAC,IAAA,6KAAO,EAACC,QAAQ;QACvC,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAID,OAAOE,MAAM,GAAG,GAAG;QACrB,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,IAAID,MAAMC,MAAM,KAAKF,OAAOE,MAAM,EAAE;QAClC,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,IAAI,CAACC,MAAM,GAAGF;IACd,IAAI,CAACG,OAAO,GAAGJ;IACf,IAAI,CAACK,UAAU,GAAG,4KAAM,CAACC,YAAY,CAACN,MAAM,CAAC,EAAE;IAE/C,IAAI,CAACO,cAAc,GAAG;AACxB;AAEAC,OAAOC,gBAAgB,CAACZ,cAAca,SAAS,EAAE;IAC/C;;;;;;;GAOC,GACDT,OAAO;QACLU,KAAK;YACH,OAAO,IAAI,CAACR,MAAM;QACpB;IACF;IAEA;;;;;;;GAOC,GACDH,QAAQ;QACNW,KAAK;YACH,OAAO,IAAI,CAACP,OAAO;QACrB;IACF;AACF;AAEA;;;;;;;;;;;;CAYC,GACDP,cAAca,SAAS,CAACE,gBAAgB,GAAG,4KAAM,CAACF,SAAS,CAACE,gBAAgB;AAE5E;;;;;;CAMC,GACDf,cAAca,SAAS,CAACG,QAAQ,GAAG,4KAAM,CAACH,SAAS,CAACG,QAAQ;AAE5D;;;;;;CAMC,GACDhB,cAAca,SAAS,CAACI,SAAS,GAAG,4KAAM,CAACJ,SAAS,CAACI,SAAS;AAE9D;;;;;;;;;;CAUC,GACDjB,cAAca,SAAS,CAACK,QAAQ,GAAG,SAAUC,IAAI,EAAEC,MAAM;IACvD,MAAMjB,SAAS,IAAI,CAACA,MAAM;IAE1B,IAAI,CAACO,cAAc,GAAG,IAAI,CAACK,gBAAgB,CAACI,MAAM,IAAI,CAACT,cAAc;IACrE,MAAMW,IAAI,IAAI,CAACX,cAAc;IAE7B,MAAMY,YAAY,IAAI,CAACd,UAAU;IACjC,IAAIc,cAAcC,QAAQ;QACxB,OAAOpB,MAAM,CAACkB,EAAE;IAClB;IAEA,IAAI,CAAC,IAAA,6KAAO,EAACD,SAAS;QACpBA,SAAS,IAAIE;IACf;IAEA,OAAOA,UAAUE,KAAK,CAACrB,MAAM,CAACkB,EAAE,EAAED;AACpC;uCAEepB","ignoreList":[0]}},
    {"offset": {"line": 50052, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/QuaternionSpline.js"],"sourcesContent":["import Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Spline from \"./Spline.js\";\n\nfunction createEvaluateFunction(spline) {\n  const points = spline.points;\n  const times = spline.times;\n\n  // use slerp interpolation\n  return function (time, result) {\n    if (!defined(result)) {\n      result = new Quaternion();\n    }\n    const i = (spline._lastTimeIndex = spline.findTimeInterval(\n      time,\n      spline._lastTimeIndex,\n    ));\n    const u = (time - times[i]) / (times[i + 1] - times[i]);\n\n    const q0 = points[i];\n    const q1 = points[i + 1];\n\n    return Quaternion.fastSlerp(q0, q1, u, result);\n  };\n}\n\n/**\n * A spline that uses spherical linear (slerp) interpolation to create a quaternion curve.\n * The generated curve is in the class C<sup>1</sup>.\n *\n * @alias QuaternionSpline\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Quaternion[]} options.points The array of {@link Quaternion} control points.\n *\n * @exception {DeveloperError} points and times are required\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n\n * @see ConstantSpline\n * @see SteppedSpline\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see LinearSpline\n * @see MorphWeightSpline\n */\nfunction QuaternionSpline(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const points = options.points;\n  const times = options.times;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\",\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._points = points;\n\n  this._evaluateFunction = createEvaluateFunction(this);\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(QuaternionSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof QuaternionSpline.prototype\n   *\n   * @type {number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of {@link Quaternion} control points.\n   *\n   * @memberof QuaternionSpline.prototype\n   *\n   * @type {Quaternion[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n});\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {number} time The time.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nQuaternionSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around to the updated animation.\n */\nQuaternionSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nQuaternionSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nQuaternionSpline.prototype.evaluate = function (time, result) {\n  return this._evaluateFunction(time, result);\n};\nexport default QuaternionSpline;\n"],"names":["createEvaluateFunction","spline","points","times","time","result","i","_lastTimeIndex","findTimeInterval","u","q0","q1","fastSlerp","QuaternionSpline","options","EMPTY_OBJECT","length","_times","_points","_evaluateFunction","Object","defineProperties","prototype","get","wrapTime","clampTime","evaluate"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA,SAASA,uBAAuBC,MAAM;IACpC,MAAMC,SAASD,OAAOC,MAAM;IAC5B,MAAMC,QAAQF,OAAOE,KAAK;IAE1B,0BAA0B;IAC1B,OAAO,SAAUC,IAAI,EAAEC,MAAM;QAC3B,IAAI,CAAC,IAAA,6KAAO,EAACA,SAAS;YACpBA,SAAS,IAAI,gLAAU;QACzB;QACA,MAAMC,IAAKL,OAAOM,cAAc,GAAGN,OAAOO,gBAAgB,CACxDJ,MACAH,OAAOM,cAAc;QAEvB,MAAME,IAAI,CAACL,OAAOD,KAAK,CAACG,EAAE,IAAI,CAACH,KAAK,CAACG,IAAI,EAAE,GAAGH,KAAK,CAACG,EAAE;QAEtD,MAAMI,KAAKR,MAAM,CAACI,EAAE;QACpB,MAAMK,KAAKT,MAAM,CAACI,IAAI,EAAE;QAExB,OAAO,gLAAU,CAACM,SAAS,CAACF,IAAIC,IAAIF,GAAGJ;IACzC;AACF;AAEA;;;;;;;;;;;;;;;;;;;;;;CAsBC,GACD,SAASQ,iBAAiBC,OAAO;IAC/BA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC,MAAMb,SAASY,QAAQZ,MAAM;IAC7B,MAAMC,QAAQW,QAAQX,KAAK;IAE3B,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACD,WAAW,CAAC,IAAA,6KAAO,EAACC,QAAQ;QACvC,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAID,OAAOc,MAAM,GAAG,GAAG;QACrB,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,IAAIb,MAAMa,MAAM,KAAKd,OAAOc,MAAM,EAAE;QAClC,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,IAAI,CAACC,MAAM,GAAGd;IACd,IAAI,CAACe,OAAO,GAAGhB;IAEf,IAAI,CAACiB,iBAAiB,GAAGnB,uBAAuB,IAAI;IACpD,IAAI,CAACO,cAAc,GAAG;AACxB;AAEAa,OAAOC,gBAAgB,CAACR,iBAAiBS,SAAS,EAAE;IAClD;;;;;;;GAOC,GACDnB,OAAO;QACLoB,KAAK;YACH,OAAO,IAAI,CAACN,MAAM;QACpB;IACF;IAEA;;;;;;;GAOC,GACDf,QAAQ;QACNqB,KAAK;YACH,OAAO,IAAI,CAACL,OAAO;QACrB;IACF;AACF;AAEA;;;;;;;;;;;CAWC,GACDL,iBAAiBS,SAAS,CAACd,gBAAgB,GAAG,4KAAM,CAACc,SAAS,CAACd,gBAAgB;AAE/E;;;;;;CAMC,GACDK,iBAAiBS,SAAS,CAACE,QAAQ,GAAG,4KAAM,CAACF,SAAS,CAACE,QAAQ;AAE/D;;;;;;CAMC,GACDX,iBAAiBS,SAAS,CAACG,SAAS,GAAG,4KAAM,CAACH,SAAS,CAACG,SAAS;AAEjE;;;;;;;;;;CAUC,GACDZ,iBAAiBS,SAAS,CAACI,QAAQ,GAAG,SAAUtB,IAAI,EAAEC,MAAM;IAC1D,OAAO,IAAI,CAACc,iBAAiB,CAACf,MAAMC;AACtC;uCACeQ","ignoreList":[0]}},
    {"offset": {"line": 50193, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/IonResource.js"],"sourcesContent":["import Uri from \"urijs\";\nimport Check from \"./Check.js\";\nimport Credit from \"./Credit.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport Ion from \"./Ion.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\n\n/**\n * A function that will be invoked when the access token is refreshed.\n * @callback IonResourceRefreshCallback\n * @param {IonResource} ionResource The root IonResource being refreshed.\n * @param {object} endpoint The result of the Cesium ion asset endpoint service. This may be modified in place by the callback.\n * @private\n */\n\n/**\n * A {@link Resource} instance that encapsulates Cesium ion asset access.\n * This object is normally not instantiated directly, use {@link IonResource.fromAssetId}.\n *\n * @alias IonResource\n * @constructor\n * @augments Resource\n *\n * @param {object} endpoint The result of the Cesium ion asset endpoint service.\n * @param {Resource} endpointResource The original resource used to retrieve the endpoint.\n *\n * @see Ion\n * @see IonImageryProvider\n * @see createWorldTerrain\n * @see https://cesium.com\n */\nfunction IonResource(endpoint, endpointResource) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"endpoint\", endpoint);\n  Check.defined(\"endpointResource\", endpointResource);\n  //>>includeEnd('debug');\n\n  let options;\n  const externalType = endpoint.externalType;\n  const isExternal = defined(externalType);\n\n  if (!isExternal) {\n    options = {\n      url: endpoint.url,\n      retryAttempts: 1,\n      retryCallback: retryCallback,\n    };\n  } else if (\n    externalType === \"3DTILES\" ||\n    externalType === \"STK_TERRAIN_SERVER\"\n  ) {\n    // 3D Tiles and STK Terrain Server external assets can still be represented as an IonResource\n    options = { url: endpoint.options.url };\n  } else {\n    //External imagery assets have additional configuration that can't be represented as a Resource\n    throw new RuntimeError(\n      \"Ion.createResource does not support external imagery assets; use IonImageryProvider instead.\",\n    );\n  }\n\n  Resource.call(this, options);\n\n  // The asset endpoint data returned from ion.\n  this._ionEndpoint = endpoint;\n  this._ionEndpointDomain = isExternal\n    ? undefined\n    : new Uri(endpoint.url).authority();\n\n  // The endpoint resource to fetch when a new token is needed\n  this._ionEndpointResource = endpointResource;\n\n  // The primary IonResource from which an instance is derived\n  this._ionRoot = undefined;\n\n  // Shared promise for endpooint requests amd credits (only ever set on the root request)\n  this._pendingPromise = undefined;\n  this._credits = undefined;\n  this._isExternal = isExternal;\n\n  /**\n   * A function that, if defined, will be invoked when the access token is refreshed.\n   * @private\n   * @type {IonResourceRefreshCallback|undefined}\n   */\n  this.refreshCallback = undefined;\n}\n\nif (defined(Object.create)) {\n  IonResource.prototype = Object.create(Resource.prototype);\n  IonResource.prototype.constructor = IonResource;\n}\n\n/**\n * Asynchronously creates an instance.\n *\n * @param {number} assetId The Cesium ion asset id.\n * @param {object} [options] An object with the following properties:\n * @param {string} [options.accessToken=Ion.defaultAccessToken] The access token to use.\n * @param {string|Resource} [options.server=Ion.defaultServer] The resource to the Cesium ion API server.\n * @returns {Promise<IonResource>} A Promise to an instance representing the Cesium ion Asset.\n *\n * @example\n * // Load a Cesium3DTileset with asset ID of 124624234\n * try {\n *   const resource = await Cesium.IonResource.fromAssetId(124624234);\n *   const tileset = await Cesium.Cesium3DTileset.fromUrl(resource);\n *   scene.primitives.add(tileset);\n * } catch (error) {\n *   console.error(`Error creating tileset: ${error}`);\n * }\n *\n * @example\n * //Load a CZML file with asset ID of 10890\n * Cesium.IonResource.fromAssetId(10890)\n *   .then(function (resource) {\n *     viewer.dataSources.add(Cesium.CzmlDataSource.load(resource));\n *   });\n */\nIonResource.fromAssetId = function (assetId, options) {\n  const endpointResource = IonResource._createEndpointResource(\n    assetId,\n    options,\n  );\n\n  return endpointResource.fetchJson().then(function (endpoint) {\n    return new IonResource(endpoint, endpointResource);\n  });\n};\n\nObject.defineProperties(IonResource.prototype, {\n  /**\n   * Gets the credits required for attribution of the asset.\n   *\n   * @memberof IonResource.prototype\n   * @type {Credit[]}\n   * @readonly\n   */\n  credits: {\n    get: function () {\n      // Only we're not the root, return its credits;\n      if (defined(this._ionRoot)) {\n        return this._ionRoot.credits;\n      }\n\n      // We are the root\n      if (defined(this._credits)) {\n        return this._credits;\n      }\n\n      this._credits = IonResource.getCreditsFromEndpoint(\n        this._ionEndpoint,\n        this._ionEndpointResource,\n      );\n\n      return this._credits;\n    },\n  },\n});\n\n/** @private */\nIonResource.getCreditsFromEndpoint = function (endpoint, endpointResource) {\n  const credits = endpoint.attributions.map(Credit.getIonCredit);\n  const defaultTokenCredit = Ion.getDefaultTokenCredit(\n    endpointResource.queryParameters.access_token,\n  );\n  if (defined(defaultTokenCredit)) {\n    credits.push(Credit.clone(defaultTokenCredit));\n  }\n  return credits;\n};\n\n/** @inheritdoc */\nIonResource.prototype.clone = function (result) {\n  // We always want to use the root's information because it's the most up-to-date\n  const ionRoot = this._ionRoot ?? this;\n\n  if (!defined(result)) {\n    result = new IonResource(\n      ionRoot._ionEndpoint,\n      ionRoot._ionEndpointResource,\n    );\n  }\n\n  result = Resource.prototype.clone.call(this, result);\n  result._ionRoot = ionRoot;\n  result._isExternal = this._isExternal;\n\n  return result;\n};\n\nIonResource.prototype.fetchImage = function (options) {\n  if (!this._isExternal) {\n    const userOptions = options;\n    options = {\n      preferBlob: true,\n    };\n    if (defined(userOptions)) {\n      options.flipY = userOptions.flipY;\n      options.preferImageBitmap = userOptions.preferImageBitmap;\n    }\n  }\n\n  return Resource.prototype.fetchImage.call(this, options);\n};\n\nIonResource.prototype._makeRequest = function (options) {\n  // Don't send ion access token to non-ion servers.\n  if (\n    this._isExternal ||\n    new Uri(this.url).authority() !== this._ionEndpointDomain\n  ) {\n    return Resource.prototype._makeRequest.call(this, options);\n  }\n\n  options.headers = addClientHeaders(options.headers);\n  options.headers.Authorization = `Bearer ${this._ionEndpoint.accessToken}`;\n\n  return Resource.prototype._makeRequest.call(this, options);\n};\n\n/**\n * @private\n **/\nIonResource._createEndpointResource = function (assetId, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"assetId\", assetId);\n  //>>includeEnd('debug');\n\n  options = options ?? Frozen.EMPTY_OBJECT;\n  let server = options.server ?? Ion.defaultServer;\n  const accessToken = options.accessToken ?? Ion.defaultAccessToken;\n  server = Resource.createIfNeeded(server);\n\n  const resourceOptions = {\n    url: `v1/assets/${assetId}/endpoint`,\n  };\n\n  if (defined(accessToken)) {\n    resourceOptions.queryParameters = { access_token: accessToken };\n  }\n\n  if (defined(options.queryParameters)) {\n    resourceOptions.queryParameters = {\n      ...resourceOptions.queryParameters,\n      ...options.queryParameters,\n    };\n  }\n\n  resourceOptions.headers = addClientHeaders(resourceOptions.headers);\n\n  return server.getDerivedResource(resourceOptions);\n};\n\n/**\n * Adds CesiumJS client headers to the provided headers object.\n * @private\n * @param {object} [headers={}] The headers to modify.\n * @returns {object} The modified headers.\n */\nfunction addClientHeaders(headers = {}) {\n  headers[\"X-Cesium-Client\"] = \"CesiumJS\";\n\n  /* global CESIUM_VERSION */\n  if (typeof CESIUM_VERSION !== \"undefined\") {\n    headers[\"X-Cesium-Client-Version\"] = CESIUM_VERSION;\n  }\n\n  return headers;\n}\n\nfunction retryCallback(that, error) {\n  const ionRoot = that._ionRoot ?? that;\n  const endpointResource = ionRoot._ionEndpointResource;\n\n  // Image is not available in worker threads, so this avoids\n  // a ReferenceError\n  const imageDefined = typeof Image !== \"undefined\";\n\n  // We only want to retry in the case of invalid credentials (401) or image\n  // requests(since Image failures can not provide a status code)\n  if (\n    !defined(error) ||\n    (error.statusCode !== 401 &&\n      !(imageDefined && error.target instanceof Image))\n  ) {\n    return Promise.resolve(false);\n  }\n\n  // We use a shared pending promise for all derived assets, since they share\n  // a common access_token.  If we're already requesting a new token for this\n  // asset, we wait on the same promise.\n  if (!defined(ionRoot._pendingPromise)) {\n    ionRoot._pendingPromise = endpointResource\n      .fetchJson()\n      .then(function (newEndpoint) {\n        const refreshCallback = that.refreshCallback ?? ionRoot.refreshCallback;\n        if (defined(refreshCallback)) {\n          refreshCallback(ionRoot, newEndpoint);\n        }\n\n        // Set the token for root resource so new derived resources automatically pick it up\n        ionRoot._ionEndpoint = newEndpoint;\n        return ionRoot._ionEndpoint;\n      })\n      .finally(function (newEndpoint) {\n        // Pass or fail, we're done with this promise, the next failure should use a new one.\n        ionRoot._pendingPromise = undefined;\n        return newEndpoint;\n      });\n  }\n\n  return ionRoot._pendingPromise.then(function (newEndpoint) {\n    // Set the new token and endpoint for this resource\n    that._ionEndpoint = newEndpoint;\n    return true;\n  });\n}\n\nexport default IonResource;\n"],"names":["IonResource","endpoint","endpointResource","defined","options","externalType","isExternal","url","retryAttempts","retryCallback","call","_ionEndpoint","_ionEndpointDomain","undefined","authority","_ionEndpointResource","_ionRoot","_pendingPromise","_credits","_isExternal","refreshCallback","Object","create","prototype","fromAssetId","assetId","_createEndpointResource","fetchJson","then","defineProperties","credits","get","getCreditsFromEndpoint","attributions","map","getIonCredit","defaultTokenCredit","getDefaultTokenCredit","queryParameters","access_token","push","clone","result","ionRoot","fetchImage","userOptions","preferBlob","flipY","preferImageBitmap","_makeRequest","headers","addClientHeaders","Authorization","accessToken","EMPTY_OBJECT","server","defaultServer","defaultAccessToken","createIfNeeded","resourceOptions","getDerivedResource","CESIUM_VERSION","that","error","imageDefined","Image","statusCode","target","Promise","resolve","newEndpoint","finally"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 50452, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/WebMercatorTilingScheme.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\n\n/**\n * A tiling scheme for geometry referenced to a {@link WebMercatorProjection}, EPSG:3857.  This is\n * the tiling scheme used by Google Maps, Microsoft Bing Maps, and most of ESRI ArcGIS Online.\n *\n * @alias WebMercatorTilingScheme\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid whose surface is being tiled. Defaults to\n * the default ellipsoid.\n * @param {number} [options.numberOfLevelZeroTilesX=1] The number of tiles in the X direction at level zero of\n *        the tile tree.\n * @param {number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of\n *        the tile tree.\n * @param {Cartesian2} [options.rectangleSouthwestInMeters] The southwest corner of the rectangle covered by the\n *        tiling scheme, in meters.  If this parameter or rectangleNortheastInMeters is not specified, the entire\n *        globe is covered in the longitude direction and an equal distance is covered in the latitude\n *        direction, resulting in a square projection.\n * @param {Cartesian2} [options.rectangleNortheastInMeters] The northeast corner of the rectangle covered by the\n *        tiling scheme, in meters.  If this parameter or rectangleSouthwestInMeters is not specified, the entire\n *        globe is covered in the longitude direction and an equal distance is covered in the latitude\n *        direction, resulting in a square projection.\n */\nfunction WebMercatorTilingScheme(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  this._ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  this._numberOfLevelZeroTilesX = options.numberOfLevelZeroTilesX ?? 1;\n  this._numberOfLevelZeroTilesY = options.numberOfLevelZeroTilesY ?? 1;\n\n  this._projection = new WebMercatorProjection(this._ellipsoid);\n\n  if (\n    defined(options.rectangleSouthwestInMeters) &&\n    defined(options.rectangleNortheastInMeters)\n  ) {\n    this._rectangleSouthwestInMeters = options.rectangleSouthwestInMeters;\n    this._rectangleNortheastInMeters = options.rectangleNortheastInMeters;\n  } else {\n    const semimajorAxisTimesPi = this._ellipsoid.maximumRadius * Math.PI;\n    this._rectangleSouthwestInMeters = new Cartesian2(\n      -semimajorAxisTimesPi,\n      -semimajorAxisTimesPi,\n    );\n    this._rectangleNortheastInMeters = new Cartesian2(\n      semimajorAxisTimesPi,\n      semimajorAxisTimesPi,\n    );\n  }\n\n  const southwest = this._projection.unproject(\n    this._rectangleSouthwestInMeters,\n  );\n  const northeast = this._projection.unproject(\n    this._rectangleNortheastInMeters,\n  );\n  this._rectangle = new Rectangle(\n    southwest.longitude,\n    southwest.latitude,\n    northeast.longitude,\n    northeast.latitude,\n  );\n}\n\nObject.defineProperties(WebMercatorTilingScheme.prototype, {\n  /**\n   * Gets the ellipsoid that is tiled by this tiling scheme.\n   * @memberof WebMercatorTilingScheme.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, covered by this tiling scheme.\n   * @memberof WebMercatorTilingScheme.prototype\n   * @type {Rectangle}\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    },\n  },\n\n  /**\n   * Gets the map projection used by this tiling scheme.\n   * @memberof WebMercatorTilingScheme.prototype\n   * @type {MapProjection}\n   */\n  projection: {\n    get: function () {\n      return this._projection;\n    },\n  },\n});\n\n/**\n * Gets the total number of tiles in the X direction at a specified level-of-detail.\n *\n * @param {number} level The level-of-detail.\n * @returns {number} The number of tiles in the X direction at the given level.\n */\nWebMercatorTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesX << level;\n};\n\n/**\n * Gets the total number of tiles in the Y direction at a specified level-of-detail.\n *\n * @param {number} level The level-of-detail.\n * @returns {number} The number of tiles in the Y direction at the given level.\n */\nWebMercatorTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesY << level;\n};\n\n/**\n * Transforms a rectangle specified in geodetic radians to the native coordinate system\n * of this tiling scheme.\n *\n * @param {Rectangle} rectangle The rectangle to transform.\n * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'\n *          is undefined.\n */\nWebMercatorTilingScheme.prototype.rectangleToNativeRectangle = function (\n  rectangle,\n  result,\n) {\n  const projection = this._projection;\n  const southwest = projection.project(Rectangle.southwest(rectangle));\n  const northeast = projection.project(Rectangle.northeast(rectangle));\n\n  if (!defined(result)) {\n    return new Rectangle(southwest.x, southwest.y, northeast.x, northeast.y);\n  }\n\n  result.west = southwest.x;\n  result.south = southwest.y;\n  result.east = northeast.x;\n  result.north = northeast.y;\n  return result;\n};\n\n/**\n * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates\n * of the tiling scheme.\n *\n * @param {number} x The integer x coordinate of the tile.\n * @param {number} y The integer y coordinate of the tile.\n * @param {number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\nWebMercatorTilingScheme.prototype.tileXYToNativeRectangle = function (\n  x,\n  y,\n  level,\n  result,\n) {\n  const xTiles = this.getNumberOfXTilesAtLevel(level);\n  const yTiles = this.getNumberOfYTilesAtLevel(level);\n\n  const xTileWidth =\n    (this._rectangleNortheastInMeters.x - this._rectangleSouthwestInMeters.x) /\n    xTiles;\n  const west = this._rectangleSouthwestInMeters.x + x * xTileWidth;\n  const east = this._rectangleSouthwestInMeters.x + (x + 1) * xTileWidth;\n\n  const yTileHeight =\n    (this._rectangleNortheastInMeters.y - this._rectangleSouthwestInMeters.y) /\n    yTiles;\n  const north = this._rectangleNortheastInMeters.y - y * yTileHeight;\n  const south = this._rectangleNortheastInMeters.y - (y + 1) * yTileHeight;\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Converts tile x, y coordinates and level to a cartographic rectangle in radians.\n *\n * @param {number} x The integer x coordinate of the tile.\n * @param {number} y The integer y coordinate of the tile.\n * @param {number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\nWebMercatorTilingScheme.prototype.tileXYToRectangle = function (\n  x,\n  y,\n  level,\n  result,\n) {\n  const nativeRectangle = this.tileXYToNativeRectangle(x, y, level, result);\n\n  const projection = this._projection;\n  const southwest = projection.unproject(\n    new Cartesian2(nativeRectangle.west, nativeRectangle.south),\n  );\n  const northeast = projection.unproject(\n    new Cartesian2(nativeRectangle.east, nativeRectangle.north),\n  );\n\n  nativeRectangle.west = southwest.longitude;\n  nativeRectangle.south = southwest.latitude;\n  nativeRectangle.east = northeast.longitude;\n  nativeRectangle.north = northeast.latitude;\n  return nativeRectangle;\n};\n\n/**\n * Calculates the tile x, y coordinates of the tile containing\n * a given cartographic position.\n *\n * @param {Cartographic} position The position.\n * @param {number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates\n *          if 'result' is undefined.\n */\nWebMercatorTilingScheme.prototype.positionToTileXY = function (\n  position,\n  level,\n  result,\n) {\n  const rectangle = this._rectangle;\n  if (!Rectangle.contains(rectangle, position)) {\n    // outside the bounds of the tiling scheme\n    return undefined;\n  }\n\n  const xTiles = this.getNumberOfXTilesAtLevel(level);\n  const yTiles = this.getNumberOfYTilesAtLevel(level);\n\n  const overallWidth =\n    this._rectangleNortheastInMeters.x - this._rectangleSouthwestInMeters.x;\n  const xTileWidth = overallWidth / xTiles;\n  const overallHeight =\n    this._rectangleNortheastInMeters.y - this._rectangleSouthwestInMeters.y;\n  const yTileHeight = overallHeight / yTiles;\n\n  const projection = this._projection;\n\n  const webMercatorPosition = projection.project(position);\n  const distanceFromWest =\n    webMercatorPosition.x - this._rectangleSouthwestInMeters.x;\n  const distanceFromNorth =\n    this._rectangleNortheastInMeters.y - webMercatorPosition.y;\n\n  let xTileCoordinate = (distanceFromWest / xTileWidth) | 0;\n  if (xTileCoordinate >= xTiles) {\n    xTileCoordinate = xTiles - 1;\n  }\n  let yTileCoordinate = (distanceFromNorth / yTileHeight) | 0;\n  if (yTileCoordinate >= yTiles) {\n    yTileCoordinate = yTiles - 1;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian2(xTileCoordinate, yTileCoordinate);\n  }\n\n  result.x = xTileCoordinate;\n  result.y = yTileCoordinate;\n  return result;\n};\nexport default WebMercatorTilingScheme;\n"],"names":["WebMercatorTilingScheme","options","EMPTY_OBJECT","_ellipsoid","ellipsoid","default","_numberOfLevelZeroTilesX","numberOfLevelZeroTilesX","_numberOfLevelZeroTilesY","numberOfLevelZeroTilesY","_projection","rectangleSouthwestInMeters","rectangleNortheastInMeters","_rectangleSouthwestInMeters","_rectangleNortheastInMeters","semimajorAxisTimesPi","maximumRadius","Math","PI","southwest","unproject","northeast","_rectangle","longitude","latitude","Object","defineProperties","prototype","get","rectangle","projection","getNumberOfXTilesAtLevel","level","getNumberOfYTilesAtLevel","rectangleToNativeRectangle","result","project","x","y","west","south","east","north","tileXYToNativeRectangle","xTiles","yTiles","xTileWidth","yTileHeight","tileXYToRectangle","nativeRectangle","positionToTileXY","position","contains","undefined","overallWidth","overallHeight","webMercatorPosition","distanceFromWest","distanceFromNorth","xTileCoordinate","yTileCoordinate"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 50671, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TileProviderError.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport formatError from \"./formatError.js\";\n\n/**\n * Provides details about an error that occurred in an {@link ImageryProvider} or a {@link TerrainProvider}.\n *\n * @alias TileProviderError\n * @constructor\n *\n * @param {ImageryProvider|TerrainProvider} provider The imagery or terrain provider that experienced the error.\n * @param {string} message A message describing the error.\n * @param {number} [x] The X coordinate of the tile that experienced the error, or undefined if the error\n *        is not specific to a particular tile.\n * @param {number} [y] The Y coordinate of the tile that experienced the error, or undefined if the error\n *        is not specific to a particular tile.\n * @param {number} [level] The level of the tile that experienced the error, or undefined if the error\n *        is not specific to a particular tile.\n * @param {number} [timesRetried=0] The number of times this operation has been retried.\n * @param {Error} [error] The error or exception that occurred, if any.\n */\nfunction TileProviderError(\n  provider,\n  message,\n  x,\n  y,\n  level,\n  timesRetried,\n  error,\n) {\n  /**\n   * The {@link ImageryProvider} or {@link TerrainProvider} that experienced the error.\n   * @type {ImageryProvider|TerrainProvider}\n   */\n  this.provider = provider;\n\n  /**\n   * The message describing the error.\n   * @type {string}\n   */\n  this.message = message;\n\n  /**\n   * The X coordinate of the tile that experienced the error.  If the error is not specific\n   * to a particular tile, this property will be undefined.\n   * @type {number}\n   */\n  this.x = x;\n\n  /**\n   * The Y coordinate of the tile that experienced the error.  If the error is not specific\n   * to a particular tile, this property will be undefined.\n   * @type {number}\n   */\n  this.y = y;\n\n  /**\n   * The level-of-detail of the tile that experienced the error.  If the error is not specific\n   * to a particular tile, this property will be undefined.\n   * @type {number}\n   */\n  this.level = level;\n\n  /**\n   * The number of times this operation has been retried.\n   * @type {number}\n   * @default 0\n   */\n  this.timesRetried = timesRetried ?? 0;\n\n  /**\n   * True if the failed operation should be retried; otherwise, false.  The imagery or terrain provider\n   * will set the initial value of this property before raising the event, but any listeners\n   * can change it.  The value after the last listener is invoked will be acted upon.\n   * @type {boolean}\n   * @default false\n   */\n  this.retry = false;\n\n  /**\n   * The error or exception that occurred, if any.\n   * @type {Error}\n   */\n  this.error = error;\n}\n\n/**\n * Reports an error in an {@link ImageryProvider} or {@link TerrainProvider} by raising an event if it has any listeners, or by\n * logging the error to the console if the event has no listeners.  This method also tracks the number\n * of times the operation has been retried.\n *\n * @param {TileProviderError} previousError The error instance returned by this function the last\n *        time it was called for this error, or undefined if this is the first time this error has\n *        occurred.\n * @param {ImageryProvider|TerrainProvider} [provider] The imagery or terrain provider that encountered the error.\n * @param {Event} [event] The event to raise to inform listeners of the error.\n * @param {string} [message] The message describing the error.\n * @param {number} [x] The X coordinate of the tile that experienced the error, or undefined if the\n *        error is not specific to a particular tile.\n * @param {number} [y] The Y coordinate of the tile that experienced the error, or undefined if the\n *        error is not specific to a particular tile.\n * @param {number} [level] The level-of-detail of the tile that experienced the error, or undefined if the\n *        error is not specific to a particular tile.\n * @param {Error} [errorDetails] The error or exception that occurred, if any.\n * @returns {TileProviderError} The error instance that was passed to the event listeners and that\n *          should be passed to this function the next time it is called for the same error in order\n *          to track retry counts.\n */\nTileProviderError.reportError = function (\n  previousError,\n  provider,\n  event,\n  message,\n  x,\n  y,\n  level,\n  errorDetails,\n) {\n  let error = previousError;\n  if (!defined(previousError)) {\n    error = new TileProviderError(\n      provider,\n      message,\n      x,\n      y,\n      level,\n      0,\n      errorDetails,\n    );\n  } else {\n    error.provider = provider;\n    error.message = message;\n    error.x = x;\n    error.y = y;\n    error.level = level;\n    error.retry = false;\n    error.error = errorDetails;\n    ++error.timesRetried;\n  }\n\n  if (defined(event) && event.numberOfListeners > 0) {\n    event.raiseEvent(error);\n  } else if (defined(provider)) {\n    console.log(\n      `An error occurred in \"${provider.constructor.name}\": ${formatError(\n        message,\n      )}`,\n    );\n  }\n\n  return error;\n};\n\n/**\n * Reports success of an operation by resetting the retry count of a previous error, if any.  This way,\n * if the error occurs again in the future, the listeners will be informed that it has not yet been retried.\n *\n * @param {TileProviderError} previousError The previous error, or undefined if this operation has\n *        not previously resulted in an error.\n */\nTileProviderError.reportSuccess = function (previousError) {\n  if (defined(previousError)) {\n    previousError.timesRetried = -1;\n  }\n};\n\n/**\n * A function that will be called to retry the operation.\n * @callback TileProviderError.RetryFunction\n */\nexport default TileProviderError;\n"],"names":["TileProviderError","provider","message","x","y","level","timesRetried","error","retry","reportError","previousError","event","errorDetails","numberOfListeners","raiseEvent","console","log","name","reportSuccess"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;;;;;;;;;;CAgBC,GACD,SAASA,kBACPC,QAAQ,EACRC,OAAO,EACPC,CAAC,EACDC,CAAC,EACDC,KAAK,EACLC,YAAY,EACZC,KAAK;IAEL;;;GAGC,GACD,IAAI,CAACN,QAAQ,GAAGA;IAEhB;;;GAGC,GACD,IAAI,CAACC,OAAO,GAAGA;IAEf;;;;GAIC,GACD,IAAI,CAACC,CAAC,GAAGA;IAET;;;;GAIC,GACD,IAAI,CAACC,CAAC,GAAGA;IAET;;;;GAIC,GACD,IAAI,CAACC,KAAK,GAAGA;IAEb;;;;GAIC,GACD,IAAI,CAACC,YAAY,GAAGA,gBAAgB;IAEpC;;;;;;GAMC,GACD,IAAI,CAACE,KAAK,GAAG;IAEb;;;GAGC,GACD,IAAI,CAACD,KAAK,GAAGA;AACf;AAEA;;;;;;;;;;;;;;;;;;;;;CAqBC,GACDP,kBAAkBS,WAAW,GAAG,SAC9BC,aAAa,EACbT,QAAQ,EACRU,KAAK,EACLT,OAAO,EACPC,CAAC,EACDC,CAAC,EACDC,KAAK,EACLO,YAAY;IAEZ,IAAIL,QAAQG;IACZ,IAAI,CAAC,IAAA,6KAAO,EAACA,gBAAgB;QAC3BH,QAAQ,IAAIP,kBACVC,UACAC,SACAC,GACAC,GACAC,OACA,GACAO;IAEJ,OAAO;QACLL,MAAMN,QAAQ,GAAGA;QACjBM,MAAML,OAAO,GAAGA;QAChBK,MAAMJ,CAAC,GAAGA;QACVI,MAAMH,CAAC,GAAGA;QACVG,MAAMF,KAAK,GAAGA;QACdE,MAAMC,KAAK,GAAG;QACdD,MAAMA,KAAK,GAAGK;QACd,EAAEL,MAAMD,YAAY;IACtB;IAEA,IAAI,IAAA,6KAAO,EAACK,UAAUA,MAAME,iBAAiB,GAAG,GAAG;QACjDF,MAAMG,UAAU,CAACP;IACnB,OAAO,IAAI,IAAA,6KAAO,EAACN,WAAW;QAC5Bc,QAAQC,GAAG,CACT,CAAC,sBAAsB,EAAEf,SAAS,WAAW,CAACgB,IAAI,CAAC,GAAG,EAAE,IAAA,iLAAW,EACjEf,UACC;IAEP;IAEA,OAAOK;AACT;AAEA;;;;;;CAMC,GACDP,kBAAkBkB,aAAa,GAAG,SAAUR,aAAa;IACvD,IAAI,IAAA,6KAAO,EAACA,gBAAgB;QAC1BA,cAAcJ,YAAY,GAAG,CAAC;IAChC;AACF;uCAMeN","ignoreList":[0]}},
    {"offset": {"line": 50794, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/GoogleMaps.js"],"sourcesContent":["import Credit from \"./Credit.js\";\nimport Resource from \"./Resource.js\";\n\n/**\n * Default settings for accessing the Google Maps API.\n * <br/>\n * An API key is only required if you are directly using any Google Maps APIs, such as through {@link createGooglePhotorealistic3DTileset}.\n * Follow instructions for managing API keys for the Google Maps Platform at {@link https://developers.google.com/maps/documentation/embed/get-api-key}\n *\n * @see createGooglePhotorealistic3DTileset\n * @see https://developers.google.com/maps/documentation/embed/get-api-key\n *\n * @namespace GoogleMaps\n */\nconst GoogleMaps = {};\n\n/**\n * Gets or sets the default Google Maps API key.\n *\n * @type {undefined|string}\n */\nGoogleMaps.defaultApiKey = undefined;\n\n/**\n * Gets or sets the default Google Map Tiles API endpoint.\n *\n * @type {string|Resource}\n * @default https://tile.googleapis.com/\n */\nGoogleMaps.mapTilesApiEndpoint = new Resource({\n  url: \"https://tile.googleapis.com/\",\n});\n\nGoogleMaps.getDefaultCredit = function () {\n  return new Credit(\n    `<img src=\"https://assets.ion.cesium.com/google-credit.png\" style=\"vertical-align: -5px\" alt=\"Google\">`,\n    true,\n  );\n};\nexport default GoogleMaps;\n"],"names":["GoogleMaps","defaultApiKey","undefined","mapTilesApiEndpoint","url","getDefaultCredit"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;;;;CAUC,GACD,MAAMA,aAAa,CAAC;AAEpB;;;;CAIC,GACDA,WAAWC,aAAa,GAAGC;AAE3B;;;;;CAKC,GACDF,WAAWG,mBAAmB,GAAG,IAAI,8KAAQ,CAAC;IAC5CC,KAAK;AACP;AAEAJ,WAAWK,gBAAgB,GAAG;IAC5B,OAAO,IAAI,4KAAM,CACf,CAAC,qGAAqG,CAAC,EACvG;AAEJ;uCACeL","ignoreList":[0]}},
    {"offset": {"line": 50834, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TerrainProvider.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * Provides terrain or other geometry for the surface of an ellipsoid.  The surface geometry is\n * organized into a pyramid of tiles according to a {@link TilingScheme}.  This type describes an\n * interface and is not intended to be instantiated directly.\n *\n * @alias TerrainProvider\n * @constructor\n *\n * @see EllipsoidTerrainProvider\n * @see CesiumTerrainProvider\n * @see VRTheWorldTerrainProvider\n * @see GoogleEarthEnterpriseTerrainProvider\n * @see ArcGISTiledElevationTerrainProvider\n * @see Cesium3DTilesTerrainProvider\n */\nfunction TerrainProvider() {\n  DeveloperError.throwInstantiationError();\n}\n\nObject.defineProperties(TerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof TerrainProvider.prototype\n   * @type {Event<TerrainProvider.ErrorEvent>}\n   * @readonly\n   */\n  errorEvent: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.\n   * @memberof TerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.\n   * @memberof TerrainProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.\n   * @memberof TerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * @memberof TerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles. This property may be undefined if availability\n   * information is not available.\n   * @memberof TerrainProvider.prototype\n   * @type {TileAvailability|undefined}\n   * @readonly\n   */\n  availability: {\n    get: DeveloperError.throwInstantiationError,\n  },\n});\n\nconst regularGridIndicesCache = [];\n\n/**\n * Gets a list of indices for a triangle mesh representing a regular grid.  Calling\n * this function multiple times with the same grid width and height returns the\n * same list of indices.  The total number of vertices must be less than or equal\n * to 65536.\n *\n * @param {number} width The number of vertices in the regular grid in the horizontal direction.\n * @param {number} height The number of vertices in the regular grid in the vertical direction.\n * @returns {Uint16Array|Uint32Array} The list of indices. Uint16Array gets returned for 64KB or less and Uint32Array for 4GB or less.\n */\nTerrainProvider.getRegularGridIndices = function (width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\n      \"The total number of vertices (width * height) must be less than 4,294,967,296.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  let byWidth = regularGridIndicesCache[width];\n  if (!defined(byWidth)) {\n    regularGridIndicesCache[width] = byWidth = [];\n  }\n\n  let indices = byWidth[height];\n  if (!defined(indices)) {\n    if (width * height < CesiumMath.SIXTY_FOUR_KILOBYTES) {\n      indices = byWidth[height] = new Uint16Array(\n        (width - 1) * (height - 1) * 6,\n      );\n    } else {\n      indices = byWidth[height] = new Uint32Array(\n        (width - 1) * (height - 1) * 6,\n      );\n    }\n    addRegularGridIndices(width, height, indices, 0);\n  }\n\n  return indices;\n};\n\nconst regularGridAndEdgeIndicesCache = [];\n\n/**\n * @private\n */\nTerrainProvider.getRegularGridIndicesAndEdgeIndices = function (width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\n      \"The total number of vertices (width * height) must be less than 4,294,967,296.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  let byWidth = regularGridAndEdgeIndicesCache[width];\n  if (!defined(byWidth)) {\n    regularGridAndEdgeIndicesCache[width] = byWidth = [];\n  }\n\n  let indicesAndEdges = byWidth[height];\n  if (!defined(indicesAndEdges)) {\n    const indices = TerrainProvider.getRegularGridIndices(width, height);\n\n    const edgeIndices = getEdgeIndices(width, height);\n    const westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\n    const southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\n    const eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\n    const northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\n\n    indicesAndEdges = byWidth[height] = {\n      indices: indices,\n      westIndicesSouthToNorth: westIndicesSouthToNorth,\n      southIndicesEastToWest: southIndicesEastToWest,\n      eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n      northIndicesWestToEast: northIndicesWestToEast,\n    };\n  }\n\n  return indicesAndEdges;\n};\n\nconst regularGridAndSkirtAndEdgeIndicesCache = [];\n\n/**\n * @private\n */\nTerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices = function (\n  width,\n  height,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\n      \"The total number of vertices (width * height) must be less than 4,294,967,296.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  let byWidth = regularGridAndSkirtAndEdgeIndicesCache[width];\n  if (!defined(byWidth)) {\n    regularGridAndSkirtAndEdgeIndicesCache[width] = byWidth = [];\n  }\n\n  let indicesAndEdges = byWidth[height];\n  if (!defined(indicesAndEdges)) {\n    const gridVertexCount = width * height;\n    const gridIndexCount = (width - 1) * (height - 1) * 6;\n    const edgeVertexCount = width * 2 + height * 2;\n    const edgeIndexCount = Math.max(0, edgeVertexCount - 4) * 6;\n    const vertexCount = gridVertexCount + edgeVertexCount;\n    const indexCount = gridIndexCount + edgeIndexCount;\n\n    const edgeIndices = getEdgeIndices(width, height);\n    const westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\n    const southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\n    const eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\n    const northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\n\n    const indices = IndexDatatype.createTypedArray(vertexCount, indexCount);\n    addRegularGridIndices(width, height, indices, 0);\n    TerrainProvider.addSkirtIndices(\n      westIndicesSouthToNorth,\n      southIndicesEastToWest,\n      eastIndicesNorthToSouth,\n      northIndicesWestToEast,\n      gridVertexCount,\n      indices,\n      gridIndexCount,\n    );\n\n    indicesAndEdges = byWidth[height] = {\n      indices: indices,\n      westIndicesSouthToNorth: westIndicesSouthToNorth,\n      southIndicesEastToWest: southIndicesEastToWest,\n      eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n      northIndicesWestToEast: northIndicesWestToEast,\n      indexCountWithoutSkirts: gridIndexCount,\n    };\n  }\n\n  return indicesAndEdges;\n};\n\n/**\n * Calculates the number of skirt vertices given the edge indices.\n * @private\n * @param {number[]|Uint8Array|Uint16Array|Uint32Array} westIndicesSouthToNorth Edge indices along the west side of the tile.\n * @param {number[]|Uint8Array|Uint16Array|Uint32Array} southIndicesEastToWest Edge indices along the south side of the tile.\n * @param {number[]|Uint8Array|Uint16Array|Uint32Array} eastIndicesNorthToSouth Edge indices along the east side of the tile.\n * @param {number[]|Uint8Array|Uint16Array|Uint32Array} northIndicesWestToEast Edge indices along the north side of the tile.\n * @returns {number} The number of skirt vertices.\n */\nTerrainProvider.getSkirtVertexCount = function (\n  westIndicesSouthToNorth,\n  southIndicesEastToWest,\n  eastIndicesNorthToSouth,\n  northIndicesWestToEast,\n) {\n  return (\n    westIndicesSouthToNorth.length +\n    southIndicesEastToWest.length +\n    eastIndicesNorthToSouth.length +\n    northIndicesWestToEast.length\n  );\n};\n\n/**\n * Compute the number of skirt indices given the number of skirt vertices.\n * Consider a 3x3 grid of vertices. There will be 8 skirt vertices around the edge:\n * - 16 edge triangles\n * - 48 indices\n *\n *   |\\|\\|\n * |/|   |/|\n * |/|   |/|\n *   |\\|\\|\n *\n * @private\n * @param {number} skirtVertexCount\n * @returns {number}\n */\nTerrainProvider.getSkirtIndexCount = function (skirtVertexCount) {\n  return (skirtVertexCount - 4) * 2 * 3;\n};\n\n/**\n * Compute the number of skirt indices given the number of skirt vertices with filled corners.\n * Consider a 3x3 grid of vertices. There will be 8 skirt vertices around the edge:\n * - 16 edge triangles\n * - 4 cap triangles\n * - 60 indices\n *\n *  /|\\|\\|\\\n * |/|   |/|\n * |/|   |/|\n *  \\|\\|\\|/\n *\n * @private\n * @param {number} skirtVertexCount\n * @returns {number}\n */\nTerrainProvider.getSkirtIndexCountWithFilledCorners = function (\n  skirtVertexCount,\n) {\n  return ((skirtVertexCount - 4) * 2 + 4) * 3;\n};\n\n/**\n * Adds skirt indices.\n * This does not add filled corners. Use {@link TerrainProvider.addSkirtIndicesWithFilledCorners} to add skirt indices with filled corners.\n * @private\n * @param {number[]|Uint8Array|Uint16Array|Uint32Array} westIndicesSouthToNorth The indices of the vertices on the Western edge of the tile, ordered from South to North.\n * @param {number[]|Uint8Array|Uint16Array|Uint32Array} southIndicesEastToWest The indices of the vertices on the Southern edge of the tile, ordered from East to West.\n * @param {number[]|Uint8Array|Uint16Array|Uint32Array} eastIndicesNorthToSouth The indices of the vertices on the Eastern edge of the tile, ordered from North to South.\n * @param {number[]|Uint8Array|Uint16Array|Uint32Array} northIndicesWestToEast The indices of the vertices on the Northern edge of the tile, ordered from West to East.\n * @param {number} vertexCount The number of vertices in the tile before adding skirt vertices.\n * @param {Uint16Array|Uint32Array} indices The array of indices to which skirt indices are added.\n * @param {number} offset The offset into the indices array at which to start adding skirt indices.\n */\nTerrainProvider.addSkirtIndices = function (\n  westIndicesSouthToNorth,\n  southIndicesEastToWest,\n  eastIndicesNorthToSouth,\n  northIndicesWestToEast,\n  vertexCount,\n  indices,\n  offset,\n) {\n  let vertexIndex = vertexCount;\n  offset = addSkirtIndices(\n    westIndicesSouthToNorth,\n    vertexIndex,\n    indices,\n    offset,\n  );\n  vertexIndex += westIndicesSouthToNorth.length;\n  offset = addSkirtIndices(\n    southIndicesEastToWest,\n    vertexIndex,\n    indices,\n    offset,\n  );\n  vertexIndex += southIndicesEastToWest.length;\n  offset = addSkirtIndices(\n    eastIndicesNorthToSouth,\n    vertexIndex,\n    indices,\n    offset,\n  );\n  vertexIndex += eastIndicesNorthToSouth.length;\n  addSkirtIndices(northIndicesWestToEast, vertexIndex, indices, offset);\n};\n\n/**\n * Adds skirt indices with filled corners.\n * @private\n * @param {number[]|Uint8Array|Uint16Array|Uint32Array} westIndicesSouthToNorth The indices of the vertices on the Western edge of the tile, ordered from South to North.\n * @param {number[]|Uint8Array|Uint16Array|Uint32Array} southIndicesEastToWest The indices of the vertices on the Southern edge of the tile, ordered from East to West.\n * @param {number[]|Uint8Array|Uint16Array|Uint32Array} eastIndicesNorthToSouth The indices of the vertices on the Eastern edge of the tile, ordered from North to South.\n * @param {number[]|Uint8Array|Uint16Array|Uint32Array} northIndicesWestToEast The indices of the vertices on the Northern edge of the tile, ordered from West to East.\n * @param {number} vertexCount The number of vertices in the tile before adding skirt vertices.\n * @param {Uint16Array|Uint32Array} indices The array of indices to which skirt indices are added.\n * @param {number} offset The offset into the indices array at which to start adding skirt indices.\n */\nTerrainProvider.addSkirtIndicesWithFilledCorners = function (\n  westIndicesSouthToNorth,\n  southIndicesEastToWest,\n  eastIndicesNorthToSouth,\n  northIndicesWestToEast,\n  vertexCount,\n  indices,\n  offset,\n) {\n  // Add skirt indices without filled corners\n  TerrainProvider.addSkirtIndices(\n    westIndicesSouthToNorth,\n    southIndicesEastToWest,\n    eastIndicesNorthToSouth,\n    northIndicesWestToEast,\n    vertexCount,\n    indices,\n    offset,\n  );\n\n  const skirtVertexCount = TerrainProvider.getSkirtVertexCount(\n    westIndicesSouthToNorth,\n    southIndicesEastToWest,\n    eastIndicesNorthToSouth,\n    northIndicesWestToEast,\n  );\n  const skirtIndexCountWithoutCaps =\n    TerrainProvider.getSkirtIndexCount(skirtVertexCount);\n\n  const cornerStartIdx = offset + skirtIndexCountWithoutCaps;\n\n  const cornerSWIndex = westIndicesSouthToNorth[0];\n  const cornerNWIndex = northIndicesWestToEast[0];\n  const cornerNEIndex = eastIndicesNorthToSouth[0];\n  const cornerSEIndex = southIndicesEastToWest[0];\n\n  // Indices based on edge order in addSkirtIndices\n  const westSouthIndex = vertexCount;\n  const westNorthIndex = westSouthIndex + westIndicesSouthToNorth.length - 1;\n  const southEastIndex = westNorthIndex + 1;\n  const southWestIndex = southEastIndex + southIndicesEastToWest.length - 1;\n  const eastNorthIndex = southWestIndex + 1;\n  const eastSouthIndex = eastNorthIndex + eastIndicesNorthToSouth.length - 1;\n  const northWestIndex = eastSouthIndex + 1;\n  const northEastIndex = northWestIndex + northIndicesWestToEast.length - 1;\n\n  // Connect the corner vertices with the skirt vertices extending from the corner\n\n  indices[cornerStartIdx + 0] = cornerSWIndex;\n  indices[cornerStartIdx + 1] = westSouthIndex;\n  indices[cornerStartIdx + 2] = southWestIndex;\n\n  indices[cornerStartIdx + 3] = cornerSEIndex;\n  indices[cornerStartIdx + 4] = southEastIndex;\n  indices[cornerStartIdx + 5] = eastSouthIndex;\n\n  indices[cornerStartIdx + 6] = cornerNEIndex;\n  indices[cornerStartIdx + 7] = eastNorthIndex;\n  indices[cornerStartIdx + 8] = northEastIndex;\n\n  indices[cornerStartIdx + 9] = cornerNWIndex;\n  indices[cornerStartIdx + 10] = northWestIndex;\n  indices[cornerStartIdx + 11] = westNorthIndex;\n};\n\nfunction getEdgeIndices(width, height) {\n  const westIndicesSouthToNorth = new Array(height);\n  const southIndicesEastToWest = new Array(width);\n  const eastIndicesNorthToSouth = new Array(height);\n  const northIndicesWestToEast = new Array(width);\n\n  let i;\n  for (i = 0; i < width; ++i) {\n    northIndicesWestToEast[i] = i;\n    southIndicesEastToWest[i] = width * height - 1 - i;\n  }\n\n  for (i = 0; i < height; ++i) {\n    eastIndicesNorthToSouth[i] = (i + 1) * width - 1;\n    westIndicesSouthToNorth[i] = (height - i - 1) * width;\n  }\n\n  return {\n    westIndicesSouthToNorth: westIndicesSouthToNorth,\n    southIndicesEastToWest: southIndicesEastToWest,\n    eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n    northIndicesWestToEast: northIndicesWestToEast,\n  };\n}\n\nfunction addRegularGridIndices(width, height, indices, offset) {\n  let index = 0;\n  for (let j = 0; j < height - 1; ++j) {\n    for (let i = 0; i < width - 1; ++i) {\n      const upperLeft = index;\n      const lowerLeft = upperLeft + width;\n      const lowerRight = lowerLeft + 1;\n      const upperRight = upperLeft + 1;\n\n      indices[offset++] = upperLeft;\n      indices[offset++] = lowerLeft;\n      indices[offset++] = upperRight;\n      indices[offset++] = upperRight;\n      indices[offset++] = lowerLeft;\n      indices[offset++] = lowerRight;\n\n      ++index;\n    }\n    ++index;\n  }\n}\n\nfunction addSkirtIndices(edgeIndices, vertexIndex, indices, offset) {\n  let previousIndex = edgeIndices[0];\n\n  const length = edgeIndices.length;\n  for (let i = 1; i < length; ++i) {\n    const index = edgeIndices[i];\n\n    indices[offset++] = previousIndex;\n    indices[offset++] = index;\n    indices[offset++] = vertexIndex;\n\n    indices[offset++] = vertexIndex;\n    indices[offset++] = index;\n    indices[offset++] = vertexIndex + 1;\n\n    previousIndex = index;\n    ++vertexIndex;\n  }\n\n  return offset;\n}\n\n/**\n * Specifies the quality of terrain created from heightmaps.  A value of 1.0 will\n * ensure that adjacent heightmap vertices are separated by no more than\n * {@link Globe.maximumScreenSpaceError} screen pixels and will probably go very slowly.\n * A value of 0.5 will cut the estimated level zero geometric error in half, allowing twice the\n * screen pixels between adjacent heightmap vertices and thus rendering more quickly.\n * @type {number}\n */\nTerrainProvider.heightmapTerrainQuality = 0.25;\n\n/**\n * Determines an appropriate geometric error estimate when the geometry comes from a heightmap.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to which the terrain is attached.\n * @param {number} tileImageWidth The width, in pixels, of the heightmap associated with a single tile.\n * @param {number} numberOfTilesAtLevelZero The number of tiles in the horizontal direction at tile level zero.\n * @returns {number} An estimated geometric error.\n */\nTerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap = function (\n  ellipsoid,\n  tileImageWidth,\n  numberOfTilesAtLevelZero,\n) {\n  return (\n    (ellipsoid.maximumRadius *\n      2 *\n      Math.PI *\n      TerrainProvider.heightmapTerrainQuality) /\n    (tileImageWidth * numberOfTilesAtLevelZero)\n  );\n};\n\n/**\n * Requests the geometry for a given tile. The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n * @function\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nTerrainProvider.prototype.requestTileGeometry =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n * @function\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error.\n */\nTerrainProvider.prototype.getLevelMaximumGeometricError =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Determines whether data for a tile is available to be loaded.\n * @function\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {boolean|undefined} Undefined if not supported by the terrain provider, otherwise true or false.\n */\nTerrainProvider.prototype.getTileDataAvailable =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Makes sure we load availability data for a tile\n * @function\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise<void>} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nTerrainProvider.prototype.loadTileDataAvailability =\n  DeveloperError.throwInstantiationError;\nexport default TerrainProvider;\n\n/**\n * A function that is called when an error occurs.\n * @callback TerrainProvider.ErrorEvent\n *\n * @this TerrainProvider\n * @param {TileProviderError} err An object holding details about the error that occurred.\n */\n"],"names":["TerrainProvider","throwInstantiationError","Object","defineProperties","prototype","errorEvent","get","credit","tilingScheme","hasWaterMask","hasVertexNormals","availability","regularGridIndicesCache","getRegularGridIndices","width","height","FOUR_GIGABYTES","byWidth","indices","SIXTY_FOUR_KILOBYTES","Uint16Array","Uint32Array","addRegularGridIndices","regularGridAndEdgeIndicesCache","getRegularGridIndicesAndEdgeIndices","indicesAndEdges","edgeIndices","getEdgeIndices","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","regularGridAndSkirtAndEdgeIndicesCache","getRegularGridAndSkirtIndicesAndEdgeIndices","gridVertexCount","gridIndexCount","edgeVertexCount","edgeIndexCount","Math","max","vertexCount","indexCount","createTypedArray","addSkirtIndices","indexCountWithoutSkirts","getSkirtVertexCount","length","getSkirtIndexCount","skirtVertexCount","getSkirtIndexCountWithFilledCorners","offset","vertexIndex","addSkirtIndicesWithFilledCorners","skirtIndexCountWithoutCaps","cornerStartIdx","cornerSWIndex","cornerNWIndex","cornerNEIndex","cornerSEIndex","westSouthIndex","westNorthIndex","southEastIndex","southWestIndex","eastNorthIndex","eastSouthIndex","northWestIndex","northEastIndex","Array","i","index","j","upperLeft","lowerLeft","lowerRight","upperRight","previousIndex","heightmapTerrainQuality","getEstimatedLevelZeroGeometricErrorForAHeightmap","ellipsoid","tileImageWidth","numberOfTilesAtLevelZero","maximumRadius","PI","requestTileGeometry","getLevelMaximumGeometricError","getTileDataAvailable","loadTileDataAvailability"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 51252, "column": 4}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 51256, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/WireframeIndexGenerator.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\n/**\n * Functions for generating indices for model wireframes. The indices are\n * outputted as typed arrays, which can then be put into buffers for rendering.\n *\n * @namespace WireframeIndexGenerator\n * @private\n */\nconst WireframeIndexGenerator = {};\n\nfunction createWireframeFromTriangles(vertexCount) {\n  const wireframeIndices = IndexDatatype.createTypedArray(\n    vertexCount,\n    vertexCount * 2,\n  );\n  const length = vertexCount;\n  let index = 0;\n  for (let i = 0; i < length; i += 3) {\n    wireframeIndices[index++] = i;\n    wireframeIndices[index++] = i + 1;\n    wireframeIndices[index++] = i + 1;\n    wireframeIndices[index++] = i + 2;\n    wireframeIndices[index++] = i + 2;\n    wireframeIndices[index++] = i;\n  }\n\n  return wireframeIndices;\n}\n\nfunction createWireframeFromTriangleIndices(vertexCount, originalIndices) {\n  const originalIndicesCount = originalIndices.length;\n  const wireframeIndices = IndexDatatype.createTypedArray(\n    vertexCount,\n    originalIndicesCount * 2,\n  );\n  let index = 0;\n  for (let i = 0; i < originalIndicesCount; i += 3) {\n    const point0 = originalIndices[i];\n    const point1 = originalIndices[i + 1];\n    const point2 = originalIndices[i + 2];\n\n    wireframeIndices[index++] = point0;\n    wireframeIndices[index++] = point1;\n    wireframeIndices[index++] = point1;\n    wireframeIndices[index++] = point2;\n    wireframeIndices[index++] = point2;\n    wireframeIndices[index++] = point0;\n  }\n\n  return wireframeIndices;\n}\n\nfunction createWireframeFromTriangleStrip(vertexCount) {\n  const numberOfTriangles = vertexCount - 2;\n  const wireframeIndicesCount = 2 + numberOfTriangles * 4;\n  const wireframeIndices = IndexDatatype.createTypedArray(\n    vertexCount,\n    wireframeIndicesCount,\n  );\n  let index = 0;\n\n  // Handle the first edge\n  wireframeIndices[index++] = 0;\n  wireframeIndices[index++] = 1;\n\n  // Add two edges for every triangle in the strip\n  for (let i = 0; i < numberOfTriangles; i++) {\n    wireframeIndices[index++] = i + 1;\n    wireframeIndices[index++] = i + 2;\n    wireframeIndices[index++] = i + 2;\n    wireframeIndices[index++] = i;\n  }\n\n  return wireframeIndices;\n}\n\nfunction createWireframeFromTriangleStripIndices(vertexCount, originalIndices) {\n  const originalIndicesCount = originalIndices.length;\n  const numberOfTriangles = originalIndicesCount - 2;\n  const wireframeIndicesCount = 2 + numberOfTriangles * 4;\n  const wireframeIndices = IndexDatatype.createTypedArray(\n    vertexCount,\n    wireframeIndicesCount,\n  );\n  let index = 0;\n\n  // Handle the first edge\n  wireframeIndices[index++] = originalIndices[0];\n  wireframeIndices[index++] = originalIndices[1];\n\n  // Add two edges for every triangle in the strip\n  for (let i = 0; i < numberOfTriangles; i++) {\n    const point0 = originalIndices[i];\n    const point1 = originalIndices[i + 1];\n    const point2 = originalIndices[i + 2];\n\n    wireframeIndices[index++] = point1;\n    wireframeIndices[index++] = point2;\n    wireframeIndices[index++] = point2;\n    wireframeIndices[index++] = point0;\n  }\n\n  return wireframeIndices;\n}\n\nfunction createWireframeFromTriangleFan(vertexCount) {\n  const numberOfTriangles = vertexCount - 2;\n  const wireframeIndicesCount = 2 + numberOfTriangles * 4;\n  const wireframeIndices = IndexDatatype.createTypedArray(\n    vertexCount,\n    wireframeIndicesCount,\n  );\n  let index = 0;\n\n  // Handle the first edge\n  wireframeIndices[index++] = 0;\n  wireframeIndices[index++] = 1;\n\n  // Add two edges for every triangle in the fan\n  for (let i = 0; i < numberOfTriangles; i++) {\n    wireframeIndices[index++] = i + 1;\n    wireframeIndices[index++] = i + 2;\n    wireframeIndices[index++] = i + 2;\n    wireframeIndices[index++] = 0;\n  }\n\n  return wireframeIndices;\n}\n\nfunction createWireframeFromTriangleFanIndices(vertexCount, originalIndices) {\n  const originalIndicesCount = originalIndices.length;\n  const numberOfTriangles = originalIndicesCount - 2;\n  const wireframeIndicesCount = 2 + numberOfTriangles * 4;\n  const wireframeIndices = IndexDatatype.createTypedArray(\n    vertexCount,\n    wireframeIndicesCount,\n  );\n  let index = 0;\n\n  // Handle the first edge\n  const firstPoint = originalIndices[0];\n  wireframeIndices[index++] = firstPoint;\n  wireframeIndices[index++] = originalIndices[1];\n\n  // Add two edges for every triangle in the fan\n  for (let i = 0; i < numberOfTriangles; i++) {\n    const point1 = originalIndices[i + 1];\n    const point2 = originalIndices[i + 2];\n\n    wireframeIndices[index++] = point1;\n    wireframeIndices[index++] = point2;\n    wireframeIndices[index++] = point2;\n    wireframeIndices[index++] = firstPoint;\n  }\n\n  return wireframeIndices;\n}\n\n/**\n * Generates a wireframe index buffer for a primitive, either by reindexing the existing indices\n * or creating them from scratch if the model had none.\n *\n * @param {PrimitiveType} primitiveType The primitive type.\n * @param {number} vertexCount The number of vertices in the primitive.\n * @param {Uint8Array|Uint16Array|Uint32Array} [originalIndices] A typed array containing the original indices of the primitive.\n *\n * @return {Uint16Array|Uint32Array} A typed array with the wireframe indices, or undefined if the primitive type does not use triangles.\n *\n * @private\n */\nWireframeIndexGenerator.createWireframeIndices = function (\n  primitiveType,\n  vertexCount,\n  originalIndices,\n) {\n  const hasOriginalIndices = defined(originalIndices);\n  if (primitiveType === PrimitiveType.TRIANGLES) {\n    return hasOriginalIndices\n      ? createWireframeFromTriangleIndices(vertexCount, originalIndices)\n      : createWireframeFromTriangles(vertexCount);\n  }\n\n  if (primitiveType === PrimitiveType.TRIANGLE_STRIP) {\n    return hasOriginalIndices\n      ? createWireframeFromTriangleStripIndices(vertexCount, originalIndices)\n      : createWireframeFromTriangleStrip(vertexCount);\n  }\n\n  if (primitiveType === PrimitiveType.TRIANGLE_FAN) {\n    return hasOriginalIndices\n      ? createWireframeFromTriangleFanIndices(vertexCount, originalIndices)\n      : createWireframeFromTriangleFan(vertexCount);\n  }\n\n  return undefined;\n};\n\n/**\n * Gets the number of indices in the wireframe index buffer of a primitive type.\n *\n * @param {PrimitiveType} primitiveType The primitive type.\n * @param {number} originalCount The original number of vertices or indices in the primitive.\n * @return {number} The number of indices in the primitive's wireframe.\n *\n * @private\n */\nWireframeIndexGenerator.getWireframeIndicesCount = function (\n  primitiveType,\n  originalCount,\n) {\n  // For TRIANGLES, the wireframe takes every triangle (i.e. three of the original\n  // indices) and turns it into lines. Each triangle has three lines, and each line\n  // requires two indices, so the final count is twice the original.\n  if (primitiveType === PrimitiveType.TRIANGLES) {\n    return originalCount * 2;\n  }\n\n  // For TRIANGLE_STRIP and TRIANGLE_FAN, the number of triangles in the primitive\n  // is equal to the total number of vertices minus two. This is because after the\n  // first edge is specified by the first two indices, every point afterwards\n  // contributes two more edges with two of the previous points, forming a new triangle.\n  // Each of these edges requires two indices, so each triangle in the primitive\n  // results in four indices in addition to the first two.\n  if (\n    primitiveType === PrimitiveType.TRIANGLE_STRIP ||\n    primitiveType === PrimitiveType.TRIANGLE_FAN\n  ) {\n    const numberOfTriangles = originalCount - 2;\n    return 2 + numberOfTriangles * 4;\n  }\n\n  return originalCount;\n};\n\nexport default WireframeIndexGenerator;\n"],"names":["WireframeIndexGenerator","createWireframeFromTriangles","vertexCount","wireframeIndices","createTypedArray","length","index","i","createWireframeFromTriangleIndices","originalIndices","originalIndicesCount","point0","point1","point2","createWireframeFromTriangleStrip","numberOfTriangles","wireframeIndicesCount","createWireframeFromTriangleStripIndices","createWireframeFromTriangleFan","createWireframeFromTriangleFanIndices","firstPoint","createWireframeIndices","primitiveType","hasOriginalIndices","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","undefined","getWireframeIndicesCount","originalCount"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;CAMC,GACD,MAAMA,0BAA0B,CAAC;AAEjC,SAASC,6BAA6BC,WAAW;IAC/C,MAAMC,mBAAmB,mLAAa,CAACC,gBAAgB,CACrDF,aACAA,cAAc;IAEhB,MAAMG,SAASH;IACf,IAAII,QAAQ;IACZ,IAAK,IAAIC,IAAI,GAAGA,IAAIF,QAAQE,KAAK,EAAG;QAClCJ,gBAAgB,CAACG,QAAQ,GAAGC;QAC5BJ,gBAAgB,CAACG,QAAQ,GAAGC,IAAI;QAChCJ,gBAAgB,CAACG,QAAQ,GAAGC,IAAI;QAChCJ,gBAAgB,CAACG,QAAQ,GAAGC,IAAI;QAChCJ,gBAAgB,CAACG,QAAQ,GAAGC,IAAI;QAChCJ,gBAAgB,CAACG,QAAQ,GAAGC;IAC9B;IAEA,OAAOJ;AACT;AAEA,SAASK,mCAAmCN,WAAW,EAAEO,eAAe;IACtE,MAAMC,uBAAuBD,gBAAgBJ,MAAM;IACnD,MAAMF,mBAAmB,mLAAa,CAACC,gBAAgB,CACrDF,aACAQ,uBAAuB;IAEzB,IAAIJ,QAAQ;IACZ,IAAK,IAAIC,IAAI,GAAGA,IAAIG,sBAAsBH,KAAK,EAAG;QAChD,MAAMI,SAASF,eAAe,CAACF,EAAE;QACjC,MAAMK,SAASH,eAAe,CAACF,IAAI,EAAE;QACrC,MAAMM,SAASJ,eAAe,CAACF,IAAI,EAAE;QAErCJ,gBAAgB,CAACG,QAAQ,GAAGK;QAC5BR,gBAAgB,CAACG,QAAQ,GAAGM;QAC5BT,gBAAgB,CAACG,QAAQ,GAAGM;QAC5BT,gBAAgB,CAACG,QAAQ,GAAGO;QAC5BV,gBAAgB,CAACG,QAAQ,GAAGO;QAC5BV,gBAAgB,CAACG,QAAQ,GAAGK;IAC9B;IAEA,OAAOR;AACT;AAEA,SAASW,iCAAiCZ,WAAW;IACnD,MAAMa,oBAAoBb,cAAc;IACxC,MAAMc,wBAAwB,IAAID,oBAAoB;IACtD,MAAMZ,mBAAmB,mLAAa,CAACC,gBAAgB,CACrDF,aACAc;IAEF,IAAIV,QAAQ;IAEZ,wBAAwB;IACxBH,gBAAgB,CAACG,QAAQ,GAAG;IAC5BH,gBAAgB,CAACG,QAAQ,GAAG;IAE5B,gDAAgD;IAChD,IAAK,IAAIC,IAAI,GAAGA,IAAIQ,mBAAmBR,IAAK;QAC1CJ,gBAAgB,CAACG,QAAQ,GAAGC,IAAI;QAChCJ,gBAAgB,CAACG,QAAQ,GAAGC,IAAI;QAChCJ,gBAAgB,CAACG,QAAQ,GAAGC,IAAI;QAChCJ,gBAAgB,CAACG,QAAQ,GAAGC;IAC9B;IAEA,OAAOJ;AACT;AAEA,SAASc,wCAAwCf,WAAW,EAAEO,eAAe;IAC3E,MAAMC,uBAAuBD,gBAAgBJ,MAAM;IACnD,MAAMU,oBAAoBL,uBAAuB;IACjD,MAAMM,wBAAwB,IAAID,oBAAoB;IACtD,MAAMZ,mBAAmB,mLAAa,CAACC,gBAAgB,CACrDF,aACAc;IAEF,IAAIV,QAAQ;IAEZ,wBAAwB;IACxBH,gBAAgB,CAACG,QAAQ,GAAGG,eAAe,CAAC,EAAE;IAC9CN,gBAAgB,CAACG,QAAQ,GAAGG,eAAe,CAAC,EAAE;IAE9C,gDAAgD;IAChD,IAAK,IAAIF,IAAI,GAAGA,IAAIQ,mBAAmBR,IAAK;QAC1C,MAAMI,SAASF,eAAe,CAACF,EAAE;QACjC,MAAMK,SAASH,eAAe,CAACF,IAAI,EAAE;QACrC,MAAMM,SAASJ,eAAe,CAACF,IAAI,EAAE;QAErCJ,gBAAgB,CAACG,QAAQ,GAAGM;QAC5BT,gBAAgB,CAACG,QAAQ,GAAGO;QAC5BV,gBAAgB,CAACG,QAAQ,GAAGO;QAC5BV,gBAAgB,CAACG,QAAQ,GAAGK;IAC9B;IAEA,OAAOR;AACT;AAEA,SAASe,+BAA+BhB,WAAW;IACjD,MAAMa,oBAAoBb,cAAc;IACxC,MAAMc,wBAAwB,IAAID,oBAAoB;IACtD,MAAMZ,mBAAmB,mLAAa,CAACC,gBAAgB,CACrDF,aACAc;IAEF,IAAIV,QAAQ;IAEZ,wBAAwB;IACxBH,gBAAgB,CAACG,QAAQ,GAAG;IAC5BH,gBAAgB,CAACG,QAAQ,GAAG;IAE5B,8CAA8C;IAC9C,IAAK,IAAIC,IAAI,GAAGA,IAAIQ,mBAAmBR,IAAK;QAC1CJ,gBAAgB,CAACG,QAAQ,GAAGC,IAAI;QAChCJ,gBAAgB,CAACG,QAAQ,GAAGC,IAAI;QAChCJ,gBAAgB,CAACG,QAAQ,GAAGC,IAAI;QAChCJ,gBAAgB,CAACG,QAAQ,GAAG;IAC9B;IAEA,OAAOH;AACT;AAEA,SAASgB,sCAAsCjB,WAAW,EAAEO,eAAe;IACzE,MAAMC,uBAAuBD,gBAAgBJ,MAAM;IACnD,MAAMU,oBAAoBL,uBAAuB;IACjD,MAAMM,wBAAwB,IAAID,oBAAoB;IACtD,MAAMZ,mBAAmB,mLAAa,CAACC,gBAAgB,CACrDF,aACAc;IAEF,IAAIV,QAAQ;IAEZ,wBAAwB;IACxB,MAAMc,aAAaX,eAAe,CAAC,EAAE;IACrCN,gBAAgB,CAACG,QAAQ,GAAGc;IAC5BjB,gBAAgB,CAACG,QAAQ,GAAGG,eAAe,CAAC,EAAE;IAE9C,8CAA8C;IAC9C,IAAK,IAAIF,IAAI,GAAGA,IAAIQ,mBAAmBR,IAAK;QAC1C,MAAMK,SAASH,eAAe,CAACF,IAAI,EAAE;QACrC,MAAMM,SAASJ,eAAe,CAACF,IAAI,EAAE;QAErCJ,gBAAgB,CAACG,QAAQ,GAAGM;QAC5BT,gBAAgB,CAACG,QAAQ,GAAGO;QAC5BV,gBAAgB,CAACG,QAAQ,GAAGO;QAC5BV,gBAAgB,CAACG,QAAQ,GAAGc;IAC9B;IAEA,OAAOjB;AACT;AAEA;;;;;;;;;;;CAWC,GACDH,wBAAwBqB,sBAAsB,GAAG,SAC/CC,aAAa,EACbpB,WAAW,EACXO,eAAe;IAEf,MAAMc,qBAAqB,IAAA,6KAAO,EAACd;IACnC,IAAIa,kBAAkB,mLAAa,CAACE,SAAS,EAAE;QAC7C,OAAOD,qBACHf,mCAAmCN,aAAaO,mBAChDR,6BAA6BC;IACnC;IAEA,IAAIoB,kBAAkB,mLAAa,CAACG,cAAc,EAAE;QAClD,OAAOF,qBACHN,wCAAwCf,aAAaO,mBACrDK,iCAAiCZ;IACvC;IAEA,IAAIoB,kBAAkB,mLAAa,CAACI,YAAY,EAAE;QAChD,OAAOH,qBACHJ,sCAAsCjB,aAAaO,mBACnDS,+BAA+BhB;IACrC;IAEA,OAAOyB;AACT;AAEA;;;;;;;;CAQC,GACD3B,wBAAwB4B,wBAAwB,GAAG,SACjDN,aAAa,EACbO,aAAa;IAEb,gFAAgF;IAChF,iFAAiF;IACjF,kEAAkE;IAClE,IAAIP,kBAAkB,mLAAa,CAACE,SAAS,EAAE;QAC7C,OAAOK,gBAAgB;IACzB;IAEA,gFAAgF;IAChF,gFAAgF;IAChF,2EAA2E;IAC3E,sFAAsF;IACtF,8EAA8E;IAC9E,wDAAwD;IACxD,IACEP,kBAAkB,mLAAa,CAACG,cAAc,IAC9CH,kBAAkB,mLAAa,CAACI,YAAY,EAC5C;QACA,MAAMX,oBAAoBc,gBAAgB;QAC1C,OAAO,IAAId,oBAAoB;IACjC;IAEA,OAAOc;AACT;uCAEe7B","ignoreList":[0]}},
    {"offset": {"line": 51436, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/ManagedArray.js"],"sourcesContent":["import Check from \"./Check.js\";\n\n/**\n * A wrapper around arrays so that the internal length of the array can be manually managed.\n *\n * @alias ManagedArray\n * @constructor\n * @private\n *\n * @param {number} [length=0] The initial length of the array.\n */\nfunction ManagedArray(length) {\n  length = length ?? 0;\n  this._array = new Array(length);\n  this._length = length;\n}\n\nObject.defineProperties(ManagedArray.prototype, {\n  /**\n   * Gets or sets the length of the array.\n   * If the set length is greater than the length of the internal array, the internal array is resized.\n   *\n   * @memberof ManagedArray.prototype\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      return this._length;\n    },\n    set: function (length) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThanOrEquals(\"length\", length, 0);\n      //>>includeEnd('debug');\n      const array = this._array;\n      const originalLength = this._length;\n      if (length < originalLength) {\n        // Remove trailing references\n        for (let i = length; i < originalLength; ++i) {\n          array[i] = undefined;\n        }\n      } else if (length > array.length) {\n        array.length = length;\n      }\n      this._length = length;\n    },\n  },\n\n  /**\n   * Gets the internal array.\n   *\n   * @memberof ManagedArray.prototype\n   * @type {Array}\n   * @readonly\n   */\n  values: {\n    get: function () {\n      return this._array;\n    },\n  },\n});\n\n/**\n * Gets the element at an index.\n *\n * @param {number} index The index to get.\n */\nManagedArray.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.lessThan(\"index\", index, this._array.length);\n  //>>includeEnd('debug');\n\n  return this._array[index];\n};\n\n/**\n * Sets the element at an index. Resizes the array if index is greater than the length of the array.\n *\n * @param {number} index The index to set.\n * @param {*} element The element to set at index.\n */\nManagedArray.prototype.set = function (index, element) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  if (index >= this._length) {\n    this.length = index + 1;\n  }\n  this._array[index] = element;\n};\n\n/**\n * Returns the last element in the array without modifying the array.\n *\n * @returns {*} The last element in the array.\n */\nManagedArray.prototype.peek = function () {\n  return this._array[this._length - 1];\n};\n\n/**\n * Push an element into the array.\n *\n * @param {*} element The element to push.\n */\nManagedArray.prototype.push = function (element) {\n  const index = this.length++;\n  this._array[index] = element;\n};\n\n/**\n * Pop an element from the array.\n *\n * @returns {*} The last element in the array.\n */\nManagedArray.prototype.pop = function () {\n  if (this._length === 0) {\n    return undefined;\n  }\n  const element = this._array[this._length - 1];\n  --this.length;\n  return element;\n};\n\n/**\n * Resize the internal array if length > _array.length.\n *\n * @param {number} length The length.\n */\nManagedArray.prototype.reserve = function (length) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"length\", length, 0);\n  //>>includeEnd('debug');\n\n  if (length > this._array.length) {\n    this._array.length = length;\n  }\n};\n\n/**\n * Resize the array.\n *\n * @param {number} length The length.\n */\nManagedArray.prototype.resize = function (length) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"length\", length, 0);\n  //>>includeEnd('debug');\n\n  this.length = length;\n};\n\n/**\n * Trim the internal array to the specified length. Defaults to the current length.\n *\n * @param {number} [length] The length.\n */\nManagedArray.prototype.trim = function (length) {\n  length = length ?? this._length;\n  this._array.length = length;\n};\nexport default ManagedArray;\n"],"names":["ManagedArray","length","_array","Array","_length","Object","defineProperties","prototype","get","set","typeOf","number","greaterThanOrEquals","array","originalLength","i","undefined","values","index","lessThan","element","peek","push","pop","reserve","resize","trim"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 51581, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/HilbertOrder.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Hilbert Order helper functions.\n *\n * @namespace HilbertOrder\n */\nconst HilbertOrder = {};\n\n/**\n * Computes the Hilbert index at the given level from 2D coordinates.\n *\n * @param {number} level The level of the curve\n * @param {number} x The X coordinate\n * @param {number} y The Y coordinate\n * @returns {number} The Hilbert index.\n * @private\n */\nHilbertOrder.encode2D = function (level, x, y) {\n  const n = Math.pow(2, level);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"level\", level);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  if (level < 1) {\n    throw new DeveloperError(\"Hilbert level cannot be less than 1.\");\n  }\n  if (x < 0 || x >= n || y < 0 || y >= n) {\n    throw new DeveloperError(\"Invalid coordinates for given level.\");\n  }\n  //>>includeEnd('debug');\n\n  const p = {\n    x: x,\n    y: y,\n  };\n  let rx,\n    ry,\n    s,\n    index = BigInt(0);\n\n  for (s = n / 2; s > 0; s /= 2) {\n    rx = (p.x & s) > 0 ? 1 : 0;\n    ry = (p.y & s) > 0 ? 1 : 0;\n    index += BigInt(((3 * rx) ^ ry) * s * s);\n    rotate(n, p, rx, ry);\n  }\n\n  return index;\n};\n\n/**\n * Computes the 2D coordinates from the Hilbert index at the given level.\n *\n * @param {number} level The level of the curve\n * @param {bigint} index The Hilbert index\n * @returns {number[]} An array containing the 2D coordinates ([x, y]) corresponding to the Morton index.\n * @private\n */\nHilbertOrder.decode2D = function (level, index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"level\", level);\n  Check.typeOf.bigint(\"index\", index);\n  if (level < 1) {\n    throw new DeveloperError(\"Hilbert level cannot be less than 1.\");\n  }\n  if (index < BigInt(0) || index >= BigInt(Math.pow(4, level))) {\n    throw new DeveloperError(\n      \"Hilbert index exceeds valid maximum for given level.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const n = Math.pow(2, level);\n  const p = {\n    x: 0,\n    y: 0,\n  };\n  let rx, ry, s, t;\n\n  for (s = 1, t = index; s < n; s *= 2) {\n    rx = 1 & Number(t / BigInt(2));\n    ry = 1 & Number(t ^ BigInt(rx));\n    rotate(s, p, rx, ry);\n    p.x += s * rx;\n    p.y += s * ry;\n    t /= BigInt(4);\n  }\n\n  return [p.x, p.y];\n};\n\n/**\n * @private\n */\nfunction rotate(n, p, rx, ry) {\n  if (ry !== 0) {\n    return;\n  }\n\n  if (rx === 1) {\n    p.x = n - 1 - p.x;\n    p.y = n - 1 - p.y;\n  }\n\n  const t = p.x;\n  p.x = p.y;\n  p.y = t;\n}\n\nexport default HilbertOrder;\n"],"names":["HilbertOrder","encode2D","level","x","y","n","Math","pow","typeOf","number","p","rx","ry","s","index","BigInt","rotate","decode2D","bigint","t","Number"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;CAIC,GACD,MAAMA,eAAe,CAAC;AAEtB;;;;;;;;CAQC,GACDA,aAAaC,QAAQ,GAAG,SAAUC,KAAK,EAAEC,CAAC,EAAEC,CAAC;IAC3C,MAAMC,IAAIC,KAAKC,GAAG,CAAC,GAAGL;IACtB,yCAAyC;IACzC,2KAAK,CAACM,MAAM,CAACC,MAAM,CAAC,SAASP;IAC7B,2KAAK,CAACM,MAAM,CAACC,MAAM,CAAC,KAAKN;IACzB,2KAAK,CAACK,MAAM,CAACC,MAAM,CAAC,KAAKL;IACzB,IAAIF,QAAQ,GAAG;QACb,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAIC,IAAI,KAAKA,KAAKE,KAAKD,IAAI,KAAKA,KAAKC,GAAG;QACtC,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAMK,IAAI;QACRP,GAAGA;QACHC,GAAGA;IACL;IACA,IAAIO,IACFC,IACAC,GACAC,QAAQC,OAAO;IAEjB,IAAKF,IAAIR,IAAI,GAAGQ,IAAI,GAAGA,KAAK,EAAG;QAC7BF,KAAK,CAACD,EAAEP,CAAC,GAAGU,CAAC,IAAI,IAAI,IAAI;QACzBD,KAAK,CAACF,EAAEN,CAAC,GAAGS,CAAC,IAAI,IAAI,IAAI;QACzBC,SAASC,OAAO,CAAC,AAAC,IAAIJ,KAAMC,EAAE,IAAIC,IAAIA;QACtCG,OAAOX,GAAGK,GAAGC,IAAIC;IACnB;IAEA,OAAOE;AACT;AAEA;;;;;;;CAOC,GACDd,aAAaiB,QAAQ,GAAG,SAAUf,KAAK,EAAEY,KAAK;IAC5C,yCAAyC;IACzC,2KAAK,CAACN,MAAM,CAACC,MAAM,CAAC,SAASP;IAC7B,2KAAK,CAACM,MAAM,CAACU,MAAM,CAAC,SAASJ;IAC7B,IAAIZ,QAAQ,GAAG;QACb,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAIY,QAAQC,OAAO,MAAMD,SAASC,OAAOT,KAAKC,GAAG,CAAC,GAAGL,SAAS;QAC5D,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,wBAAwB;IAExB,MAAMG,IAAIC,KAAKC,GAAG,CAAC,GAAGL;IACtB,MAAMQ,IAAI;QACRP,GAAG;QACHC,GAAG;IACL;IACA,IAAIO,IAAIC,IAAIC,GAAGM;IAEf,IAAKN,IAAI,GAAGM,IAAIL,OAAOD,IAAIR,GAAGQ,KAAK,EAAG;QACpCF,KAAK,IAAIS,OAAOD,IAAIJ,OAAO;QAC3BH,KAAK,IAAIQ,OAAOD,IAAIJ,OAAOJ;QAC3BK,OAAOH,GAAGH,GAAGC,IAAIC;QACjBF,EAAEP,CAAC,IAAIU,IAAIF;QACXD,EAAEN,CAAC,IAAIS,IAAID;QACXO,KAAKJ,OAAO;IACd;IAEA,OAAO;QAACL,EAAEP,CAAC;QAAEO,EAAEN,CAAC;KAAC;AACnB;AAEA;;CAEC,GACD,SAASY,OAAOX,CAAC,EAAEK,CAAC,EAAEC,EAAE,EAAEC,EAAE;IAC1B,IAAIA,OAAO,GAAG;QACZ;IACF;IAEA,IAAID,OAAO,GAAG;QACZD,EAAEP,CAAC,GAAGE,IAAI,IAAIK,EAAEP,CAAC;QACjBO,EAAEN,CAAC,GAAGC,IAAI,IAAIK,EAAEN,CAAC;IACnB;IAEA,MAAMe,IAAIT,EAAEP,CAAC;IACbO,EAAEP,CAAC,GAAGO,EAAEN,CAAC;IACTM,EAAEN,CAAC,GAAGe;AACR;uCAEenB","ignoreList":[0]}},
    {"offset": {"line": 51684, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/S2Cell.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport FeatureDetection from \"./FeatureDetection.js\";\nimport RuntimeError from \"./RuntimeError.js\";\n\n/**\n * S2\n * --\n *\n * This implementation is based on the S2 C++ reference implementation: https://github.com/google/s2geometry\n *\n *\n * Overview:\n * ---------\n * The S2 library decomposes the unit sphere into a hierarchy of cells. A cell is a quadrilateral bounded by 4 geodesics.\n * The 6 root cells are obtained by projecting the six faces of a cube on a unit sphere. Each root cell follows a quadtree\n * subdivision scheme, i.e. each cell subdivides into 4 smaller cells that cover the same area as the parent cell. The S2 cell\n * hierarchy extends from level 0 (root cells) to level 30 (leaf cells). The root cells are rotated to enable a continuous Hilbert\n * curve to map all 6 faces of the cube.\n *\n *\n * Cell ID:\n * --------\n * Each cell in S2 can be uniquely identified using a 64-bit unsigned integer, its cell ID. The first 3 bits of the cell ID are the face bits, i.e.\n * they indicate which of the 6 faces of the cube a cell lies on. After the face bits are the position bits, i.e. they indicate the position\n * of the cell along the Hilbert curve. After the positions bits is the sentinel bit, which is always set to 1, and it indicates the level of the\n * cell. Again, the level can be between 0 and 30 in S2.\n *\n *   Note: In the illustration below, the face bits are marked with 'f', the position bits are marked with 'p', the zero bits are marked with '-'.\n *\n *   Cell ID (base 10): 3170534137668829184\n *   Cell ID (base 2) : 0010110000000000000000000000000000000000000000000000000000000000\n *\n *   001 0110000000000000000000000000000000000000000000000000000000000\n *   fff pps----------------------------------------------------------\n *\n * For the cell above, we can see that it lies on face 1 (01), with a Hilbert index of 1 (1).\n *\n *\n * Cell Subdivision:\n * ------------------\n * Cells in S2 subdivide recursively using quadtree subdivision. For each cell, you can get a child of index [0-3]. To compute the child at index i,\n * insert the base 2 representation of i to the right of the parent's position bits. Ensure that the sentinel bit is also shifted two places to the right.\n *\n *   Parent Cell ID (base 10) : 3170534137668829184\n *   Parent Cell ID (base 2)  : 0010110000000000000000000000000000000000000000000000000000000000\n *\n *   001 0110000000000000000000000000000000000000000000000000000000000\n *   fff pps----------------------------------------------------------\n *\n *   To get the 3rd child of the cell above, we insert the binary representation of 3 to the right of the parent's position bits:\n *\n *   Note: In the illustration below, the bits to be added are highlighted with '^'.\n *\n *   001 0111100000000000000000000000000000000000000000000000000000000\n *   fff pppps--------------------------------------------------------\n *         ^^\n *\n *   Child(3) Cell ID (base 10) : 3386706919782612992\n *   Child(3) Cell ID (base 2)  : 0010111100000000000000000000000000000000000000000000000000000000\n *\n * Cell Token:\n * -----------\n * To provide a more concise representation of the S2 cell ID, we can use their hexadecimal representation.\n *\n *   Cell ID (base 10): 3170534137668829184\n *   Cell ID (base 2) : 0010110000000000000000000000000000000000000000000000000000000000\n *\n *   We remove all trailing zero bits, until we reach the nybble (4 bits) that contains the sentinel bit.\n *\n *   Note: In the illustration below, the bits to be removed are highlighted with 'X'.\n *\n *   0010110000000000000000000000000000000000000000000000000000000000\n *   fffpps--XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n *\n *   We convert the remaining bits to their hexadecimal representation.\n *\n *   Base 2: 0010 1100\n *   Base 16: \"2\"  \"c\"\n *\n *   Cell Token: \"2c\"\n *\n * To compute the cell ID from the token, we simply add enough zeros to the right to make the ID span 64 bits.\n *\n * Coordinate Transforms:\n * ----------------------\n *\n * To go from a cell in S2 to a point on the ellipsoid, the following order of transforms is applied:\n *\n *   1. (Cell ID): S2 cell ID\n *   2. (Face, I, J): Leaf cell coordinates, where i and j are in range [0, 2^30 - 1]\n *   3. (Face, S, T): Cell space coordinates, where s and t are in range [0, 1].\n *   4. (Face, Si, Ti): Discrete cell space coordinates, where si and ti are in range [0, 2^31]\n *   5. (Face, U, V): Cube space coordinates, where u and v are in range [-1, 1]. We apply the non-linear quadratic transform here.\n *   6. (X, Y, Z): Direction vector, where vector may not be unit length. Can be normalized to obtain point on unit sphere\n *   7. (Latitude, Longitude): Direction vector, where latitude is in range [-90, 90] and longitude is in range [-180, 180]\n *\n * @ignore\n */\n\n// The maximum level supported within an S2 cell ID. Each level is represented by two bits in the final cell ID\nconst S2_MAX_LEVEL = 30;\n\n// The maximum index of a valid leaf cell plus one.  The range of valid leaf cell indices is [0..S2_LIMIT_IJ-1].\nconst S2_LIMIT_IJ = 1 << S2_MAX_LEVEL;\n\n// The maximum value of an si- or ti-coordinate.  The range of valid (si,ti) values is [0..S2_MAX_SITI].  Use `>>>` to convert to unsigned.\nconst S2_MAX_SITI = (1 << (S2_MAX_LEVEL + 1)) >>> 0;\n\n// The number of bits in a S2 cell ID used for specifying the position along the Hilbert curve\nconst S2_POSITION_BITS = 2 * S2_MAX_LEVEL + 1;\n\n// The number of bits per I and J in the lookup tables\nconst S2_LOOKUP_BITS = 4;\n\n// Lookup table for mapping 10 bits of IJ + orientation to 10 bits of Hilbert curve position + orientation.\nconst S2_LOOKUP_POSITIONS = [];\n\n// Lookup table for mapping 10 bits of IJ + orientation to 10 bits of Hilbert curve position + orientation.\nconst S2_LOOKUP_IJ = [];\n\n// Lookup table of two bits of IJ from two bits of curve position, based also on the current curve orientation from the swap and invert bits\nconst S2_POSITION_TO_IJ = [\n  [0, 1, 3, 2], // 0: Normal order, no swap or invert\n  [0, 2, 3, 1], // 1: Swap bit set, swap I and J bits\n  [3, 2, 0, 1], // 2: Invert bit set, invert bits\n  [3, 1, 0, 2], // 3: Swap and invert bits set\n];\n\n// Mask that specifies the swap orientation bit for the Hilbert curve\nconst S2_SWAP_MASK = 1;\n\n// Mask that specifies the invert orientation bit for the Hilbert curve\nconst S2_INVERT_MASK = 2;\n\n// Lookup for the orientation update mask of one of the four sub-cells within a higher level cell.\n// This mask is XOR'ed with the current orientation to get the sub-cell orientation.\nconst S2_POSITION_TO_ORIENTATION_MASK = [\n  S2_SWAP_MASK,\n  0,\n  0,\n  S2_SWAP_MASK | S2_INVERT_MASK,\n];\n\n/**\n * Represents a cell in the S2 geometry library.\n *\n * @alias S2Cell\n * @constructor\n *\n * @param {bigint} [cellId] The 64-bit S2CellId.\n * @private\n */\nfunction S2Cell(cellId) {\n  if (!FeatureDetection.supportsBigInt()) {\n    throw new RuntimeError(\"S2 required BigInt support\");\n  }\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cellId)) {\n    throw new DeveloperError(\"cell ID is required.\");\n  }\n  if (!S2Cell.isValidId(cellId)) {\n    throw new DeveloperError(\"cell ID is invalid.\");\n  }\n  //>>includeEnd('debug');\n\n  this._cellId = cellId;\n  this._level = S2Cell.getLevel(cellId);\n}\n\n/**\n * Creates a new S2Cell from a token. A token is a hexadecimal representation of the 64-bit S2CellId.\n *\n * @param {string} token The token for the S2 Cell.\n * @returns {S2Cell} Returns a new S2Cell.\n * @private\n */\nS2Cell.fromToken = function (token) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"token\", token);\n  if (!S2Cell.isValidToken(token)) {\n    throw new DeveloperError(\"token is invalid.\");\n  }\n  //>>includeEnd('debug');\n\n  return new S2Cell(S2Cell.getIdFromToken(token));\n};\n\n/**\n * Validates an S2 cell ID.\n *\n * @param {bigint} [cellId] The S2CellId.\n * @returns {boolean} Returns true if the cell ID is valid, returns false otherwise.\n * @private\n */\nS2Cell.isValidId = function (cellId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bigint(\"cellId\", cellId);\n  //>>includeEnd('debug');\n\n  // Check if sentinel bit is missing.\n  if (cellId <= 0) {\n    return false;\n  }\n\n  // Check if face bits indicate a valid value, in range [0-5].\n  if (cellId >> BigInt(S2_POSITION_BITS) > 5) {\n    return false;\n  }\n\n  // Check trailing 1 bit is in one of the even bit positions allowed for the 30 levels, using a bitmask.\n  const lowestSetBit = cellId & (~cellId + BigInt(1));\n  if (!(lowestSetBit & BigInt(\"0x1555555555555555\"))) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Validates an S2 cell token.\n *\n * @param {string} [token] The hexadecimal representation of an S2CellId.\n * @returns {boolean} Returns true if the token is valid, returns false otherwise.\n * @private\n */\nS2Cell.isValidToken = function (token) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"token\", token);\n  //>>includeEnd('debug');\n\n  if (!/^[0-9a-fA-F]{1,16}$/.test(token)) {\n    return false;\n  }\n\n  return S2Cell.isValidId(S2Cell.getIdFromToken(token));\n};\n\n/**\n * Converts an S2 cell token to a 64-bit S2 cell ID.\n *\n * @param {string} [token] The hexadecimal representation of an S2CellId. Expected to be a valid S2 token.\n * @returns {bigint} Returns the S2 cell ID.\n * @private\n */\nS2Cell.getIdFromToken = function (token) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"token\", token);\n  //>>includeEnd('debug');\n\n  return BigInt(\"0x\" + token + \"0\".repeat(16 - token.length)); // eslint-disable-line\n};\n\n/**\n * Converts a 64-bit S2 cell ID to an S2 cell token.\n *\n * @param {bigint} [cellId] The S2 cell ID.\n * @returns {string} Returns hexadecimal representation of an S2CellId.\n * @private\n */\nS2Cell.getTokenFromId = function (cellId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bigint(\"cellId\", cellId);\n  //>>includeEnd('debug');\n\n  const trailingZeroHexChars = Math.floor(countTrailingZeroBits(cellId) / 4);\n  const hexString = cellId.toString(16).replace(/0*$/, \"\");\n\n  const zeroString = Array(17 - trailingZeroHexChars - hexString.length).join(\n    \"0\",\n  );\n  return zeroString + hexString;\n};\n\n/**\n * Gets the level of the cell from the cell ID.\n *\n * @param {bigint} [cellId] The S2 cell ID.\n * @returns {number} Returns the level of the cell.\n * @private\n */\nS2Cell.getLevel = function (cellId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bigint(\"cellId\", cellId);\n  if (!S2Cell.isValidId(cellId)) {\n    throw new DeveloperError();\n  }\n  //>>includeEnd('debug');\n\n  let lsbPosition = 0;\n  while (cellId !== BigInt(0)) {\n    if (cellId & BigInt(1)) {\n      break;\n    }\n    lsbPosition++;\n    cellId = cellId >> BigInt(1);\n  }\n\n  // We use (>> 1) because there are 2 bits per level.\n  return S2_MAX_LEVEL - (lsbPosition >> 1);\n};\n\n/**\n * Gets the child cell of the cell at the given index.\n *\n * @param {number} index An integer index of the child.\n * @returns {S2Cell} The child of the S2Cell.\n * @private\n */\nS2Cell.prototype.getChild = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  if (index < 0 || index > 3) {\n    throw new DeveloperError(\"child index must be in the range [0-3].\");\n  }\n  if (this._level === 30) {\n    throw new DeveloperError(\"cannot get child of leaf cell.\");\n  }\n  //>>includeEnd('debug');\n\n  // Shift sentinel bit 2 positions to the right.\n  const newLsb = lsb(this._cellId) >> BigInt(2);\n  // Insert child index before the sentinel bit.\n  const childCellId = this._cellId + BigInt(2 * index + 1 - 4) * newLsb;\n  return new S2Cell(childCellId);\n};\n\n/**\n * Gets the parent cell of an S2Cell.\n *\n * @returns {S2Cell} Returns the parent of the S2Cell.\n * @private\n */\nS2Cell.prototype.getParent = function () {\n  //>>includeStart('debug', pragmas.debug);\n  if (this._level === 0) {\n    throw new DeveloperError(\"cannot get parent of root cell.\");\n  }\n  //>>includeEnd('debug');\n  // Shift the sentinel bit 2 positions to the left.\n  const newLsb = lsb(this._cellId) << BigInt(2);\n  // Erase the left over bits to the right of the sentinel bit.\n  return new S2Cell((this._cellId & (~newLsb + BigInt(1))) | newLsb);\n};\n\n/**\n * Gets the parent cell at the given level.\n *\n * @returns {S2Cell} Returns the parent of the S2Cell.\n * @private\n */\nS2Cell.prototype.getParentAtLevel = function (level) {\n  //>>includeStart('debug', pragmas.debug);\n  if (this._level === 0 || level < 0 || this._level < level) {\n    throw new DeveloperError(\"cannot get parent at invalid level.\");\n  }\n  //>>includeEnd('debug');\n  const newLsb = lsbForLevel(level);\n  return new S2Cell((this._cellId & -newLsb) | newLsb);\n};\n\n/**\n * Get center of the S2 cell.\n *\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n * @returns {Cartesian3} The position of center of the S2 cell.\n * @private\n */\nS2Cell.prototype.getCenter = function (ellipsoid) {\n  ellipsoid = ellipsoid ?? Ellipsoid.WGS84;\n\n  let center = getS2Center(this._cellId, this._level);\n  // Normalize XYZ.\n  center = Cartesian3.normalize(center, center);\n  const cartographic = new Cartographic.fromCartesian(\n    center,\n    Ellipsoid.UNIT_SPHERE,\n  );\n  // Interpret as geodetic coordinates on the ellipsoid.\n  return Cartographic.toCartesian(cartographic, ellipsoid, new Cartesian3());\n};\n\n/**\n * Get vertex of the S2 cell. Vertices are indexed in CCW order.\n *\n * @param {number} index An integer index of the vertex. Must be in the range [0-3].\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n * @returns {Cartesian3} The position of the vertex of the S2 cell.\n * @private\n */\nS2Cell.prototype.getVertex = function (index, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  if (index < 0 || index > 3) {\n    throw new DeveloperError(\"vertex index must be in the range [0-3].\");\n  }\n  //>>includeEnd('debug');\n\n  ellipsoid = ellipsoid ?? Ellipsoid.WGS84;\n\n  let vertex = getS2Vertex(this._cellId, this._level, index);\n  // Normalize XYZ.\n  vertex = Cartesian3.normalize(vertex, vertex);\n  const cartographic = new Cartographic.fromCartesian(\n    vertex,\n    Ellipsoid.UNIT_SPHERE,\n  );\n  // Interpret as geodetic coordinates on the ellipsoid.\n  return Cartographic.toCartesian(cartographic, ellipsoid, new Cartesian3());\n};\n\n/**\n * Creates an S2Cell from its face, position along the Hilbert curve for a given level.\n *\n * @param {number} face The root face of S2 this cell is on. Must be in the range [0-5].\n * @param {bigint} position The position along the Hilbert curve. Must be in the range [0-4**level).\n * @param {number} level The level of the S2 curve. Must be in the range [0-30].\n * @returns {S2Cell} A new S2Cell from the given parameters.\n * @private\n */\nS2Cell.fromFacePositionLevel = function (face, position, level) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bigint(\"position\", position);\n  if (face < 0 || face > 5) {\n    throw new DeveloperError(\"Invalid S2 Face (must be within 0-5)\");\n  }\n\n  if (level < 0 || level > S2_MAX_LEVEL) {\n    throw new DeveloperError(\"Invalid level (must be within 0-30)\");\n  }\n  if (position < 0 || position >= Math.pow(4, level)) {\n    throw new DeveloperError(\"Invalid Hilbert position for level\");\n  }\n  //>>includeEnd('debug');\n\n  const faceBitString =\n    (face < 4 ? \"0\" : \"\") + (face < 2 ? \"0\" : \"\") + face.toString(2);\n  const positionBitString = position.toString(2);\n  const positionPrefixPadding = Array(\n    2 * level - positionBitString.length + 1,\n  ).join(\"0\");\n  const positionSuffixPadding = Array(S2_POSITION_BITS - 2 * level).join(\"0\");\n\n  const cellId = BigInt(\n    `0b${faceBitString}${positionPrefixPadding}${positionBitString}1${\n      // Adding the sentinel bit that always follows the position bits.\n      positionSuffixPadding\n    }`,\n  );\n  return new S2Cell(cellId);\n};\n\n/**\n * @private\n */\nfunction getS2Center(cellId, level) {\n  const faceSiTi = convertCellIdToFaceSiTi(cellId, level);\n  return convertFaceSiTitoXYZ(faceSiTi[0], faceSiTi[1], faceSiTi[2]);\n}\n/**\n * @private\n */\nfunction getS2Vertex(cellId, level, index) {\n  const faceIJ = convertCellIdToFaceIJ(cellId, level);\n  const uv = convertIJLeveltoBoundUV([faceIJ[1], faceIJ[2]], level);\n  // Handles CCW ordering of the vertices.\n  const y = (index >> 1) & 1;\n  return convertFaceUVtoXYZ(faceIJ[0], uv[0][y ^ (index & 1)], uv[1][y]);\n}\n\n// S2 Coordinate Conversions\n\n/**\n * @private\n */\nfunction convertCellIdToFaceSiTi(cellId, level) {\n  const faceIJ = convertCellIdToFaceIJ(cellId);\n  const face = faceIJ[0];\n  const i = faceIJ[1];\n  const j = faceIJ[2];\n\n  // We're resolving the center when we do the coordinate transform here. For the leaf cells, we're adding half the cell size\n  // (remember that this space has 31 levels - which allows us to pick center and edges of the leaf cells). For non leaf cells,\n  // we get one of either two cells diagonal to the cell center. The correction is used to make sure we pick the leaf cell edges\n  // that represent the parent cell center.\n  const isLeaf = level === 30;\n  const shouldCorrect =\n    !isLeaf && (BigInt(i) ^ (cellId >> BigInt(2))) & BigInt(1);\n  const correction = isLeaf ? 1 : shouldCorrect ? 2 : 0;\n  const si = (i << 1) + correction;\n  const ti = (j << 1) + correction;\n  return [face, si, ti];\n}\n\n/**\n * @private\n */\nfunction convertCellIdToFaceIJ(cellId) {\n  if (S2_LOOKUP_POSITIONS.length === 0) {\n    generateLookupTable();\n  }\n\n  const face = Number(cellId >> BigInt(S2_POSITION_BITS));\n  let bits = face & S2_SWAP_MASK;\n  const lookupMask = (1 << S2_LOOKUP_BITS) - 1;\n\n  let i = 0;\n  let j = 0;\n\n  for (let k = 7; k >= 0; k--) {\n    const numberOfBits =\n      k === 7 ? S2_MAX_LEVEL - 7 * S2_LOOKUP_BITS : S2_LOOKUP_BITS;\n    const extractMask = (1 << (2 * numberOfBits)) - 1;\n    bits +=\n      Number(\n        (cellId >> BigInt(k * 2 * S2_LOOKUP_BITS + 1)) & BigInt(extractMask),\n      ) << 2;\n\n    bits = S2_LOOKUP_IJ[bits];\n\n    const offset = k * S2_LOOKUP_BITS;\n    i += (bits >> (S2_LOOKUP_BITS + 2)) << offset;\n    j += ((bits >> 2) & lookupMask) << offset;\n\n    bits &= S2_SWAP_MASK | S2_INVERT_MASK;\n  }\n\n  return [face, i, j];\n}\n\n/**\n * @private\n */\nfunction convertFaceSiTitoXYZ(face, si, ti) {\n  const s = convertSiTitoST(si);\n  const t = convertSiTitoST(ti);\n\n  const u = convertSTtoUV(s);\n  const v = convertSTtoUV(t);\n  return convertFaceUVtoXYZ(face, u, v);\n}\n\n/**\n * @private\n */\nfunction convertFaceUVtoXYZ(face, u, v) {\n  switch (face) {\n    case 0:\n      return new Cartesian3(1, u, v);\n    case 1:\n      return new Cartesian3(-u, 1, v);\n    case 2:\n      return new Cartesian3(-u, -v, 1);\n    case 3:\n      return new Cartesian3(-1, -v, -u);\n    case 4:\n      return new Cartesian3(v, -1, -u);\n    default:\n      return new Cartesian3(v, u, -1);\n  }\n}\n\n/**\n * S2 provides 3 methods for the non-linear transform: linear, quadratic and tangential.\n * This implementation uses the quadratic method because it provides a good balance of\n * accuracy and speed.\n *\n * For a more detailed comparison of these transform methods, see\n * {@link https://github.com/google/s2geometry/blob/0c4c460bdfe696da303641771f9def900b3e440f/src/s2/s2metrics.cc}\n * @private\n */\nfunction convertSTtoUV(s) {\n  if (s >= 0.5) {\n    return (1 / 3) * (4 * s * s - 1);\n  }\n  return (1 / 3) * (1 - 4 * (1 - s) * (1 - s));\n}\n\n/**\n * @private\n */\nfunction convertSiTitoST(si) {\n  return (1.0 / S2_MAX_SITI) * si;\n}\n\n/**\n * @private\n */\nfunction convertIJLeveltoBoundUV(ij, level) {\n  const result = [[], []];\n  const cellSize = getSizeIJ(level);\n  for (let d = 0; d < 2; ++d) {\n    const ijLow = ij[d] & -cellSize;\n    const ijHigh = ijLow + cellSize;\n    result[d][0] = convertSTtoUV(convertIJtoSTMinimum(ijLow));\n    result[d][1] = convertSTtoUV(convertIJtoSTMinimum(ijHigh));\n  }\n  return result;\n}\n\n/**\n * @private\n */\nfunction getSizeIJ(level) {\n  return (1 << (S2_MAX_LEVEL - level)) >>> 0;\n}\n\n/**\n * @private\n */\nfunction convertIJtoSTMinimum(i) {\n  return (1.0 / S2_LIMIT_IJ) * i;\n}\n\n// Utility Functions\n\n/**\n * This function generates 4 variations of a Hilbert curve of level 4, based on the S2_POSITION_TO_IJ table, for fast lookups of (i, j)\n * to position along Hilbert curve. The reference C++ implementation uses an iterative approach, however, this function is implemented\n * recursively.\n *\n * See {@link https://github.com/google/s2geometry/blob/c59d0ca01ae3976db7f8abdc83fcc871a3a95186/src/s2/s2cell_id.cc#L75-L109}\n * @private\n */\nfunction generateLookupCell(\n  level,\n  i,\n  j,\n  originalOrientation,\n  position,\n  orientation,\n) {\n  if (level === S2_LOOKUP_BITS) {\n    const ij = (i << S2_LOOKUP_BITS) + j;\n    S2_LOOKUP_POSITIONS[(ij << 2) + originalOrientation] =\n      (position << 2) + orientation;\n    S2_LOOKUP_IJ[(position << 2) + originalOrientation] =\n      (ij << 2) + orientation;\n  } else {\n    level++;\n    i <<= 1;\n    j <<= 1;\n    position <<= 2;\n    const r = S2_POSITION_TO_IJ[orientation];\n    generateLookupCell(\n      level,\n      i + (r[0] >> 1),\n      j + (r[0] & 1),\n      originalOrientation,\n      position,\n      orientation ^ S2_POSITION_TO_ORIENTATION_MASK[0],\n    );\n    generateLookupCell(\n      level,\n      i + (r[1] >> 1),\n      j + (r[1] & 1),\n      originalOrientation,\n      position + 1,\n      orientation ^ S2_POSITION_TO_ORIENTATION_MASK[1],\n    );\n    generateLookupCell(\n      level,\n      i + (r[2] >> 1),\n      j + (r[2] & 1),\n      originalOrientation,\n      position + 2,\n      orientation ^ S2_POSITION_TO_ORIENTATION_MASK[2],\n    );\n    generateLookupCell(\n      level,\n      i + (r[3] >> 1),\n      j + (r[3] & 1),\n      originalOrientation,\n      position + 3,\n      orientation ^ S2_POSITION_TO_ORIENTATION_MASK[3],\n    );\n  }\n}\n\n/**\n * @private\n */\nfunction generateLookupTable() {\n  generateLookupCell(0, 0, 0, 0, 0, 0);\n  generateLookupCell(0, 0, 0, S2_SWAP_MASK, 0, S2_SWAP_MASK);\n  generateLookupCell(0, 0, 0, S2_INVERT_MASK, 0, S2_INVERT_MASK);\n  generateLookupCell(\n    0,\n    0,\n    0,\n    S2_SWAP_MASK | S2_INVERT_MASK,\n    0,\n    S2_SWAP_MASK | S2_INVERT_MASK,\n  );\n}\n\n/**\n * Return the lowest-numbered bit that is on for this cell id\n * @private\n */\nfunction lsb(cellId) {\n  return cellId & (~cellId + BigInt(1));\n}\n\n/**\n * Return the lowest-numbered bit that is on for cells at the given level.\n * @private\n */\nfunction lsbForLevel(level) {\n  return BigInt(1) << BigInt(2 * (S2_MAX_LEVEL - level));\n}\n\n// Lookup table for getting trailing zero bits.\n// https://graphics.stanford.edu/~seander/bithacks.html\nconst Mod67BitPosition = [\n  64, 0, 1, 39, 2, 15, 40, 23, 3, 12, 16, 59, 41, 19, 24, 54, 4, 64, 13, 10, 17,\n  62, 60, 28, 42, 30, 20, 51, 25, 44, 55, 47, 5, 32, 65, 38, 14, 22, 11, 58, 18,\n  53, 63, 9, 61, 27, 29, 50, 43, 46, 31, 37, 21, 57, 52, 8, 26, 49, 45, 36, 56,\n  7, 48, 35, 6, 34, 33, 0,\n];\n\n/**\n * Return the number of trailing zeros in number.\n * @private\n */\nfunction countTrailingZeroBits(x) {\n  return Mod67BitPosition[(-x & x) % BigInt(67)];\n}\n\nexport default S2Cell;\n"],"names":["S2_MAX_LEVEL","S2_LIMIT_IJ","S2_MAX_SITI","S2_POSITION_BITS","S2_LOOKUP_BITS","S2_LOOKUP_POSITIONS","S2_LOOKUP_IJ","S2_POSITION_TO_IJ","S2_SWAP_MASK","S2_INVERT_MASK","S2_POSITION_TO_ORIENTATION_MASK","S2Cell","cellId","supportsBigInt","isValidId","_cellId","_level","getLevel","fromToken","token","typeOf","string","isValidToken","getIdFromToken","bigint","BigInt","lowestSetBit","test","repeat","length","getTokenFromId","trailingZeroHexChars","Math","floor","countTrailingZeroBits","hexString","toString","replace","zeroString","Array","join","lsbPosition","prototype","getChild","index","number","newLsb","lsb","childCellId","getParent","getParentAtLevel","level","lsbForLevel","getCenter","ellipsoid","WGS84","center","getS2Center","normalize","cartographic","fromCartesian","UNIT_SPHERE","toCartesian","getVertex","vertex","getS2Vertex","fromFacePositionLevel","face","position","pow","faceBitString","positionBitString","positionPrefixPadding","positionSuffixPadding","faceSiTi","convertCellIdToFaceSiTi","convertFaceSiTitoXYZ","faceIJ","convertCellIdToFaceIJ","uv","convertIJLeveltoBoundUV","y","convertFaceUVtoXYZ","i","j","isLeaf","shouldCorrect","correction","si","ti","generateLookupTable","Number","bits","lookupMask","k","numberOfBits","extractMask","offset","s","convertSiTitoST","t","u","convertSTtoUV","v","ij","result","cellSize","getSizeIJ","d","ijLow","ijHigh","convertIJtoSTMinimum","generateLookupCell","originalOrientation","orientation","r","Mod67BitPosition","x"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6FC,GAED,+GAA+G;AAC/G,MAAMA,eAAe;AAErB,gHAAgH;AAChH,MAAMC,cAAc,KAAKD;AAEzB,2IAA2I;AAC3I,MAAME,cAAc,AAAC,KAAMF,eAAe,MAAQ;AAElD,8FAA8F;AAC9F,MAAMG,mBAAmB,IAAIH,eAAe;AAE5C,sDAAsD;AACtD,MAAMI,iBAAiB;AAEvB,2GAA2G;AAC3G,MAAMC,sBAAsB,EAAE;AAE9B,2GAA2G;AAC3G,MAAMC,eAAe,EAAE;AAEvB,4IAA4I;AAC5I,MAAMC,oBAAoB;IACxB;QAAC;QAAG;QAAG;QAAG;KAAE;IACZ;QAAC;QAAG;QAAG;QAAG;KAAE;IACZ;QAAC;QAAG;QAAG;QAAG;KAAE;IACZ;QAAC;QAAG;QAAG;QAAG;KAAE;CACb;AAED,qEAAqE;AACrE,MAAMC,eAAe;AAErB,uEAAuE;AACvE,MAAMC,iBAAiB;AAEvB,kGAAkG;AAClG,oFAAoF;AACpF,MAAMC,kCAAkC;IACtCF;IACA;IACA;IACAA,eAAeC;CAChB;AAED;;;;;;;;CAQC,GACD,SAASE,OAAOC,MAAM;IACpB,IAAI,CAAC,sLAAgB,CAACC,cAAc,IAAI;QACtC,MAAM,IAAI,kLAAY,CAAC;IACzB;IACA,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACD,SAAS;QACpB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAACD,OAAOG,SAAS,CAACF,SAAS;QAC7B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,IAAI,CAACG,OAAO,GAAGH;IACf,IAAI,CAACI,MAAM,GAAGL,OAAOM,QAAQ,CAACL;AAChC;AAEA;;;;;;CAMC,GACDD,OAAOO,SAAS,GAAG,SAAUC,KAAK;IAChC,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,SAASF;IAC7B,IAAI,CAACR,OAAOW,YAAY,CAACH,QAAQ;QAC/B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,OAAO,IAAIR,OAAOA,OAAOY,cAAc,CAACJ;AAC1C;AAEA;;;;;;CAMC,GACDR,OAAOG,SAAS,GAAG,SAAUF,MAAM;IACjC,yCAAyC;IACzC,2KAAK,CAACQ,MAAM,CAACI,MAAM,CAAC,UAAUZ;IAC9B,wBAAwB;IAExB,oCAAoC;IACpC,IAAIA,UAAU,GAAG;QACf,OAAO;IACT;IAEA,6DAA6D;IAC7D,IAAIA,UAAUa,OAAOtB,oBAAoB,GAAG;QAC1C,OAAO;IACT;IAEA,uGAAuG;IACvG,MAAMuB,eAAed,SAAU,CAACA,SAASa,OAAO;IAChD,IAAI,CAAC,CAACC,eAAeD,OAAO,qBAAqB,GAAG;QAClD,OAAO;IACT;IAEA,OAAO;AACT;AAEA;;;;;;CAMC,GACDd,OAAOW,YAAY,GAAG,SAAUH,KAAK;IACnC,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,SAASF;IAC7B,wBAAwB;IAExB,IAAI,CAAC,sBAAsBQ,IAAI,CAACR,QAAQ;QACtC,OAAO;IACT;IAEA,OAAOR,OAAOG,SAAS,CAACH,OAAOY,cAAc,CAACJ;AAChD;AAEA;;;;;;CAMC,GACDR,OAAOY,cAAc,GAAG,SAAUJ,KAAK;IACrC,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,SAASF;IAC7B,wBAAwB;IAExB,OAAOM,OAAO,OAAON,QAAQ,IAAIS,MAAM,CAAC,KAAKT,MAAMU,MAAM,IAAI,sBAAsB;AACrF;AAEA;;;;;;CAMC,GACDlB,OAAOmB,cAAc,GAAG,SAAUlB,MAAM;IACtC,yCAAyC;IACzC,2KAAK,CAACQ,MAAM,CAACI,MAAM,CAAC,UAAUZ;IAC9B,wBAAwB;IAExB,MAAMmB,uBAAuBC,KAAKC,KAAK,CAACC,sBAAsBtB,UAAU;IACxE,MAAMuB,YAAYvB,OAAOwB,QAAQ,CAAC,IAAIC,OAAO,CAAC,OAAO;IAErD,MAAMC,aAAaC,MAAM,KAAKR,uBAAuBI,UAAUN,MAAM,EAAEW,IAAI,CACzE;IAEF,OAAOF,aAAaH;AACtB;AAEA;;;;;;CAMC,GACDxB,OAAOM,QAAQ,GAAG,SAAUL,MAAM;IAChC,yCAAyC;IACzC,2KAAK,CAACQ,MAAM,CAACI,MAAM,CAAC,UAAUZ;IAC9B,IAAI,CAACD,OAAOG,SAAS,CAACF,SAAS;QAC7B,MAAM,IAAI,oLAAc;IAC1B;IACA,wBAAwB;IAExB,IAAI6B,cAAc;IAClB,MAAO7B,WAAWa,OAAO,GAAI;QAC3B,IAAIb,SAASa,OAAO,IAAI;YACtB;QACF;QACAgB;QACA7B,SAASA,UAAUa,OAAO;IAC5B;IAEA,oDAAoD;IACpD,OAAOzB,eAAe,CAACyC,eAAe,CAAC;AACzC;AAEA;;;;;;CAMC,GACD9B,OAAO+B,SAAS,CAACC,QAAQ,GAAG,SAAUC,KAAK;IACzC,yCAAyC;IACzC,2KAAK,CAACxB,MAAM,CAACyB,MAAM,CAAC,SAASD;IAC7B,IAAIA,QAAQ,KAAKA,QAAQ,GAAG;QAC1B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,IAAI,CAAC5B,MAAM,KAAK,IAAI;QACtB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,+CAA+C;IAC/C,MAAM8B,SAASC,IAAI,IAAI,CAAChC,OAAO,KAAKU,OAAO;IAC3C,8CAA8C;IAC9C,MAAMuB,cAAc,IAAI,CAACjC,OAAO,GAAGU,OAAO,IAAImB,QAAQ,IAAI,KAAKE;IAC/D,OAAO,IAAInC,OAAOqC;AACpB;AAEA;;;;;CAKC,GACDrC,OAAO+B,SAAS,CAACO,SAAS,GAAG;IAC3B,yCAAyC;IACzC,IAAI,IAAI,CAACjC,MAAM,KAAK,GAAG;QACrB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IACxB,kDAAkD;IAClD,MAAM8B,SAASC,IAAI,IAAI,CAAChC,OAAO,KAAKU,OAAO;IAC3C,6DAA6D;IAC7D,OAAO,IAAId,OAAO,AAAC,IAAI,CAACI,OAAO,GAAI,CAAC+B,SAASrB,OAAO,KAAOqB;AAC7D;AAEA;;;;;CAKC,GACDnC,OAAO+B,SAAS,CAACQ,gBAAgB,GAAG,SAAUC,KAAK;IACjD,yCAAyC;IACzC,IAAI,IAAI,CAACnC,MAAM,KAAK,KAAKmC,QAAQ,KAAK,IAAI,CAACnC,MAAM,GAAGmC,OAAO;QACzD,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IACxB,MAAML,SAASM,YAAYD;IAC3B,OAAO,IAAIxC,OAAO,AAAC,IAAI,CAACI,OAAO,GAAG,CAAC+B,SAAUA;AAC/C;AAEA;;;;;;CAMC,GACDnC,OAAO+B,SAAS,CAACW,SAAS,GAAG,SAAUC,SAAS;IAC9CA,YAAYA,aAAa,+KAAS,CAACC,KAAK;IAExC,IAAIC,SAASC,YAAY,IAAI,CAAC1C,OAAO,EAAE,IAAI,CAACC,MAAM;IAClD,iBAAiB;IACjBwC,SAAS,gLAAU,CAACE,SAAS,CAACF,QAAQA;IACtC,MAAMG,eAAe,IAAI,kLAAY,CAACC,aAAa,CACjDJ,QACA,+KAAS,CAACK,WAAW;IAEvB,sDAAsD;IACtD,OAAO,kLAAY,CAACC,WAAW,CAACH,cAAcL,WAAW,IAAI,gLAAU;AACzE;AAEA;;;;;;;CAOC,GACD3C,OAAO+B,SAAS,CAACqB,SAAS,GAAG,SAAUnB,KAAK,EAAEU,SAAS;IACrD,yCAAyC;IACzC,2KAAK,CAAClC,MAAM,CAACyB,MAAM,CAAC,SAASD;IAC7B,IAAIA,QAAQ,KAAKA,QAAQ,GAAG;QAC1B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExBU,YAAYA,aAAa,+KAAS,CAACC,KAAK;IAExC,IAAIS,SAASC,YAAY,IAAI,CAAClD,OAAO,EAAE,IAAI,CAACC,MAAM,EAAE4B;IACpD,iBAAiB;IACjBoB,SAAS,gLAAU,CAACN,SAAS,CAACM,QAAQA;IACtC,MAAML,eAAe,IAAI,kLAAY,CAACC,aAAa,CACjDI,QACA,+KAAS,CAACH,WAAW;IAEvB,sDAAsD;IACtD,OAAO,kLAAY,CAACC,WAAW,CAACH,cAAcL,WAAW,IAAI,gLAAU;AACzE;AAEA;;;;;;;;CAQC,GACD3C,OAAOuD,qBAAqB,GAAG,SAAUC,IAAI,EAAEC,QAAQ,EAAEjB,KAAK;IAC5D,yCAAyC;IACzC,2KAAK,CAAC/B,MAAM,CAACI,MAAM,CAAC,YAAY4C;IAChC,IAAID,OAAO,KAAKA,OAAO,GAAG;QACxB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IAEA,IAAIhB,QAAQ,KAAKA,QAAQnD,cAAc;QACrC,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAIoE,WAAW,KAAKA,YAAYpC,KAAKqC,GAAG,CAAC,GAAGlB,QAAQ;QAClD,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAMmB,gBACJ,CAACH,OAAO,IAAI,MAAM,EAAE,IAAI,CAACA,OAAO,IAAI,MAAM,EAAE,IAAIA,KAAK/B,QAAQ,CAAC;IAChE,MAAMmC,oBAAoBH,SAAShC,QAAQ,CAAC;IAC5C,MAAMoC,wBAAwBjC,MAC5B,IAAIY,QAAQoB,kBAAkB1C,MAAM,GAAG,GACvCW,IAAI,CAAC;IACP,MAAMiC,wBAAwBlC,MAAMpC,mBAAmB,IAAIgD,OAAOX,IAAI,CAAC;IAEvE,MAAM5B,SAASa,OACb,CAAC,EAAE,EAAE6C,gBAAgBE,wBAAwBD,kBAAkB,CAAC,EAC9D,iEAAiE;IACjEE,uBACA;IAEJ,OAAO,IAAI9D,OAAOC;AACpB;AAEA;;CAEC,GACD,SAAS6C,YAAY7C,MAAM,EAAEuC,KAAK;IAChC,MAAMuB,WAAWC,wBAAwB/D,QAAQuC;IACjD,OAAOyB,qBAAqBF,QAAQ,CAAC,EAAE,EAAEA,QAAQ,CAAC,EAAE,EAAEA,QAAQ,CAAC,EAAE;AACnE;AACA;;CAEC,GACD,SAAST,YAAYrD,MAAM,EAAEuC,KAAK,EAAEP,KAAK;IACvC,MAAMiC,SAASC,sBAAsBlE,QAAQuC;IAC7C,MAAM4B,KAAKC,wBAAwB;QAACH,MAAM,CAAC,EAAE;QAAEA,MAAM,CAAC,EAAE;KAAC,EAAE1B;IAC3D,wCAAwC;IACxC,MAAM8B,IAAI,AAACrC,SAAS,IAAK;IACzB,OAAOsC,mBAAmBL,MAAM,CAAC,EAAE,EAAEE,EAAE,CAAC,EAAE,CAACE,IAAKrC,QAAQ,EAAG,EAAEmC,EAAE,CAAC,EAAE,CAACE,EAAE;AACvE;AAEA,4BAA4B;AAE5B;;CAEC,GACD,SAASN,wBAAwB/D,MAAM,EAAEuC,KAAK;IAC5C,MAAM0B,SAASC,sBAAsBlE;IACrC,MAAMuD,OAAOU,MAAM,CAAC,EAAE;IACtB,MAAMM,IAAIN,MAAM,CAAC,EAAE;IACnB,MAAMO,IAAIP,MAAM,CAAC,EAAE;IAEnB,2HAA2H;IAC3H,6HAA6H;IAC7H,8HAA8H;IAC9H,yCAAyC;IACzC,MAAMQ,SAASlC,UAAU;IACzB,MAAMmC,gBACJ,CAACD,UAAU,CAAC5D,OAAO0D,KAAMvE,UAAUa,OAAO,EAAG,IAAIA,OAAO;IAC1D,MAAM8D,aAAaF,SAAS,IAAIC,gBAAgB,IAAI;IACpD,MAAME,KAAK,CAACL,KAAK,CAAC,IAAII;IACtB,MAAME,KAAK,CAACL,KAAK,CAAC,IAAIG;IACtB,OAAO;QAACpB;QAAMqB;QAAIC;KAAG;AACvB;AAEA;;CAEC,GACD,SAASX,sBAAsBlE,MAAM;IACnC,IAAIP,oBAAoBwB,MAAM,KAAK,GAAG;QACpC6D;IACF;IAEA,MAAMvB,OAAOwB,OAAO/E,UAAUa,OAAOtB;IACrC,IAAIyF,OAAOzB,OAAO3D;IAClB,MAAMqF,aAAa,CAAC,KAAKzF,cAAc,IAAI;IAE3C,IAAI+E,IAAI;IACR,IAAIC,IAAI;IAER,IAAK,IAAIU,IAAI,GAAGA,KAAK,GAAGA,IAAK;QAC3B,MAAMC,eACJD,MAAM,IAAI9F,eAAe,IAAII,iBAAiBA;QAChD,MAAM4F,cAAc,CAAC,KAAM,IAAID,YAAa,IAAI;QAChDH,QACED,OACE,AAAC/E,UAAUa,OAAOqE,IAAI,IAAI1F,iBAAiB,KAAMqB,OAAOuE,iBACrD;QAEPJ,OAAOtF,YAAY,CAACsF,KAAK;QAEzB,MAAMK,SAASH,IAAI1F;QACnB+E,KAAK,AAACS,QAASxF,iBAAiB,KAAO6F;QACvCb,KAAK,CAAC,AAACQ,QAAQ,IAAKC,UAAU,KAAKI;QAEnCL,QAAQpF,eAAeC;IACzB;IAEA,OAAO;QAAC0D;QAAMgB;QAAGC;KAAE;AACrB;AAEA;;CAEC,GACD,SAASR,qBAAqBT,IAAI,EAAEqB,EAAE,EAAEC,EAAE;IACxC,MAAMS,IAAIC,gBAAgBX;IAC1B,MAAMY,IAAID,gBAAgBV;IAE1B,MAAMY,IAAIC,cAAcJ;IACxB,MAAMK,IAAID,cAAcF;IACxB,OAAOlB,mBAAmBf,MAAMkC,GAAGE;AACrC;AAEA;;CAEC,GACD,SAASrB,mBAAmBf,IAAI,EAAEkC,CAAC,EAAEE,CAAC;IACpC,OAAQpC;QACN,KAAK;YACH,OAAO,IAAI,gLAAU,CAAC,GAAGkC,GAAGE;QAC9B,KAAK;YACH,OAAO,IAAI,gLAAU,CAAC,CAACF,GAAG,GAAGE;QAC/B,KAAK;YACH,OAAO,IAAI,gLAAU,CAAC,CAACF,GAAG,CAACE,GAAG;QAChC,KAAK;YACH,OAAO,IAAI,gLAAU,CAAC,CAAC,GAAG,CAACA,GAAG,CAACF;QACjC,KAAK;YACH,OAAO,IAAI,gLAAU,CAACE,GAAG,CAAC,GAAG,CAACF;QAChC;YACE,OAAO,IAAI,gLAAU,CAACE,GAAGF,GAAG,CAAC;IACjC;AACF;AAEA;;;;;;;;CAQC,GACD,SAASC,cAAcJ,CAAC;IACtB,IAAIA,KAAK,KAAK;QACZ,OAAO,AAAC,IAAI,IAAK,CAAC,IAAIA,IAAIA,IAAI,CAAC;IACjC;IACA,OAAO,AAAC,IAAI,IAAK,CAAC,IAAI,IAAI,CAAC,IAAIA,CAAC,IAAI,CAAC,IAAIA,CAAC,CAAC;AAC7C;AAEA;;CAEC,GACD,SAASC,gBAAgBX,EAAE;IACzB,OAAO,AAAC,MAAMtF,cAAesF;AAC/B;AAEA;;CAEC,GACD,SAASR,wBAAwBwB,EAAE,EAAErD,KAAK;IACxC,MAAMsD,SAAS;QAAC,EAAE;QAAE,EAAE;KAAC;IACvB,MAAMC,WAAWC,UAAUxD;IAC3B,IAAK,IAAIyD,IAAI,GAAGA,IAAI,GAAG,EAAEA,EAAG;QAC1B,MAAMC,QAAQL,EAAE,CAACI,EAAE,GAAG,CAACF;QACvB,MAAMI,SAASD,QAAQH;QACvBD,MAAM,CAACG,EAAE,CAAC,EAAE,GAAGN,cAAcS,qBAAqBF;QAClDJ,MAAM,CAACG,EAAE,CAAC,EAAE,GAAGN,cAAcS,qBAAqBD;IACpD;IACA,OAAOL;AACT;AAEA;;CAEC,GACD,SAASE,UAAUxD,KAAK;IACtB,OAAO,AAAC,KAAMnD,eAAemD,UAAY;AAC3C;AAEA;;CAEC,GACD,SAAS4D,qBAAqB5B,CAAC;IAC7B,OAAO,AAAC,MAAMlF,cAAekF;AAC/B;AAEA,oBAAoB;AAEpB;;;;;;;CAOC,GACD,SAAS6B,mBACP7D,KAAK,EACLgC,CAAC,EACDC,CAAC,EACD6B,mBAAmB,EACnB7C,QAAQ,EACR8C,WAAW;IAEX,IAAI/D,UAAU/C,gBAAgB;QAC5B,MAAMoG,KAAK,CAACrB,KAAK/E,cAAc,IAAIgF;QACnC/E,mBAAmB,CAAC,CAACmG,MAAM,CAAC,IAAIS,oBAAoB,GAClD,CAAC7C,YAAY,CAAC,IAAI8C;QACpB5G,YAAY,CAAC,CAAC8D,YAAY,CAAC,IAAI6C,oBAAoB,GACjD,CAACT,MAAM,CAAC,IAAIU;IAChB,OAAO;QACL/D;QACAgC,MAAM;QACNC,MAAM;QACNhB,aAAa;QACb,MAAM+C,IAAI5G,iBAAiB,CAAC2G,YAAY;QACxCF,mBACE7D,OACAgC,IAAI,CAACgC,CAAC,CAAC,EAAE,IAAI,CAAC,GACd/B,IAAI,CAAC+B,CAAC,CAAC,EAAE,GAAG,CAAC,GACbF,qBACA7C,UACA8C,cAAcxG,+BAA+B,CAAC,EAAE;QAElDsG,mBACE7D,OACAgC,IAAI,CAACgC,CAAC,CAAC,EAAE,IAAI,CAAC,GACd/B,IAAI,CAAC+B,CAAC,CAAC,EAAE,GAAG,CAAC,GACbF,qBACA7C,WAAW,GACX8C,cAAcxG,+BAA+B,CAAC,EAAE;QAElDsG,mBACE7D,OACAgC,IAAI,CAACgC,CAAC,CAAC,EAAE,IAAI,CAAC,GACd/B,IAAI,CAAC+B,CAAC,CAAC,EAAE,GAAG,CAAC,GACbF,qBACA7C,WAAW,GACX8C,cAAcxG,+BAA+B,CAAC,EAAE;QAElDsG,mBACE7D,OACAgC,IAAI,CAACgC,CAAC,CAAC,EAAE,IAAI,CAAC,GACd/B,IAAI,CAAC+B,CAAC,CAAC,EAAE,GAAG,CAAC,GACbF,qBACA7C,WAAW,GACX8C,cAAcxG,+BAA+B,CAAC,EAAE;IAEpD;AACF;AAEA;;CAEC,GACD,SAASgF;IACPsB,mBAAmB,GAAG,GAAG,GAAG,GAAG,GAAG;IAClCA,mBAAmB,GAAG,GAAG,GAAGxG,cAAc,GAAGA;IAC7CwG,mBAAmB,GAAG,GAAG,GAAGvG,gBAAgB,GAAGA;IAC/CuG,mBACE,GACA,GACA,GACAxG,eAAeC,gBACf,GACAD,eAAeC;AAEnB;AAEA;;;CAGC,GACD,SAASsC,IAAInC,MAAM;IACjB,OAAOA,SAAU,CAACA,SAASa,OAAO;AACpC;AAEA;;;CAGC,GACD,SAAS2B,YAAYD,KAAK;IACxB,OAAO1B,OAAO,MAAMA,OAAO,IAAI,CAACzB,eAAemD,KAAK;AACtD;AAEA,+CAA+C;AAC/C,uDAAuD;AACvD,MAAMiE,mBAAmB;IACvB;IAAI;IAAG;IAAG;IAAI;IAAG;IAAI;IAAI;IAAI;IAAG;IAAI;IAAI;IAAI;IAAI;IAAI;IAAI;IAAI;IAAG;IAAI;IAAI;IAAI;IAC3E;IAAI;IAAI;IAAI;IAAI;IAAI;IAAI;IAAI;IAAI;IAAI;IAAI;IAAI;IAAG;IAAI;IAAI;IAAI;IAAI;IAAI;IAAI;IAAI;IAC3E;IAAI;IAAI;IAAG;IAAI;IAAI;IAAI;IAAI;IAAI;IAAI;IAAI;IAAI;IAAI;IAAI;IAAI;IAAG;IAAI;IAAI;IAAI;IAAI;IAC1E;IAAG;IAAI;IAAI;IAAG;IAAI;IAAI;CACvB;AAED;;;CAGC,GACD,SAASlF,sBAAsBmF,CAAC;IAC9B,OAAOD,gBAAgB,CAAC,CAAC,CAACC,IAAIA,CAAC,IAAI5F,OAAO,IAAI;AAChD;uCAEed","ignoreList":[0]}},
    {"offset": {"line": 52365, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/decodeVectorPolylinePositions.js"],"sourcesContent":["import AttributeCompression from \"./AttributeCompression.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport CesiumMath from \"./Math.js\";\n\nconst maxShort = 32767;\n\nconst scratchBVCartographic = new Cartographic();\nconst scratchEncodedPosition = new Cartesian3();\n\nfunction decodeVectorPolylinePositions(\n  positions,\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  ellipsoid,\n) {\n  const positionsLength = positions.length / 3;\n  const uBuffer = positions.subarray(0, positionsLength);\n  const vBuffer = positions.subarray(positionsLength, 2 * positionsLength);\n  const heightBuffer = positions.subarray(\n    2 * positionsLength,\n    3 * positionsLength,\n  );\n  AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer);\n\n  const decoded = new Float64Array(positions.length);\n  for (let i = 0; i < positionsLength; ++i) {\n    const u = uBuffer[i];\n    const v = vBuffer[i];\n    const h = heightBuffer[i];\n\n    const lon = CesiumMath.lerp(rectangle.west, rectangle.east, u / maxShort);\n    const lat = CesiumMath.lerp(rectangle.south, rectangle.north, v / maxShort);\n    const alt = CesiumMath.lerp(minimumHeight, maximumHeight, h / maxShort);\n\n    const cartographic = Cartographic.fromRadians(\n      lon,\n      lat,\n      alt,\n      scratchBVCartographic,\n    );\n    const decodedPosition = ellipsoid.cartographicToCartesian(\n      cartographic,\n      scratchEncodedPosition,\n    );\n    Cartesian3.pack(decodedPosition, decoded, i * 3);\n  }\n  return decoded;\n}\nexport default decodeVectorPolylinePositions;\n"],"names":["maxShort","scratchBVCartographic","scratchEncodedPosition","decodeVectorPolylinePositions","positions","rectangle","minimumHeight","maximumHeight","ellipsoid","positionsLength","length","uBuffer","subarray","vBuffer","heightBuffer","zigZagDeltaDecode","decoded","Float64Array","i","u","v","h","lon","lerp","west","east","lat","south","north","alt","cartographic","fromRadians","decodedPosition","cartographicToCartesian","pack"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAMA,WAAW;AAEjB,MAAMC,wBAAwB,IAAI,kLAAY;AAC9C,MAAMC,yBAAyB,IAAI,gLAAU;AAE7C,SAASC,8BACPC,SAAS,EACTC,SAAS,EACTC,aAAa,EACbC,aAAa,EACbC,SAAS;IAET,MAAMC,kBAAkBL,UAAUM,MAAM,GAAG;IAC3C,MAAMC,UAAUP,UAAUQ,QAAQ,CAAC,GAAGH;IACtC,MAAMI,UAAUT,UAAUQ,QAAQ,CAACH,iBAAiB,IAAIA;IACxD,MAAMK,eAAeV,UAAUQ,QAAQ,CACrC,IAAIH,iBACJ,IAAIA;IAEN,0LAAoB,CAACM,iBAAiB,CAACJ,SAASE,SAASC;IAEzD,MAAME,UAAU,IAAIC,aAAab,UAAUM,MAAM;IACjD,IAAK,IAAIQ,IAAI,GAAGA,IAAIT,iBAAiB,EAAES,EAAG;QACxC,MAAMC,IAAIR,OAAO,CAACO,EAAE;QACpB,MAAME,IAAIP,OAAO,CAACK,EAAE;QACpB,MAAMG,IAAIP,YAAY,CAACI,EAAE;QAEzB,MAAMI,MAAM,0KAAU,CAACC,IAAI,CAAClB,UAAUmB,IAAI,EAAEnB,UAAUoB,IAAI,EAAEN,IAAInB;QAChE,MAAM0B,MAAM,0KAAU,CAACH,IAAI,CAAClB,UAAUsB,KAAK,EAAEtB,UAAUuB,KAAK,EAAER,IAAIpB;QAClE,MAAM6B,MAAM,0KAAU,CAACN,IAAI,CAACjB,eAAeC,eAAec,IAAIrB;QAE9D,MAAM8B,eAAe,kLAAY,CAACC,WAAW,CAC3CT,KACAI,KACAG,KACA5B;QAEF,MAAM+B,kBAAkBxB,UAAUyB,uBAAuB,CACvDH,cACA5B;QAEF,gLAAU,CAACgC,IAAI,CAACF,iBAAiBhB,SAASE,IAAI;IAChD;IACA,OAAOF;AACT;uCACeb","ignoreList":[0]}},
    {"offset": {"line": 52405, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/SphereOutlineGeometry.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport EllipsoidOutlineGeometry from \"./EllipsoidOutlineGeometry.js\";\n\n/**\n * A description of the outline of a sphere.\n *\n * @alias SphereOutlineGeometry\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {number} [options.radius=1.0] The radius of the sphere.\n * @param {number} [options.stackPartitions=10] The count of stacks for the sphere (1 greater than the number of parallel lines).\n * @param {number} [options.slicePartitions=8] The count of slices for the sphere (Equal to the number of radial lines).\n * @param {number} [options.subdivisions=200] The number of points per line, determining the granularity of the curvature .\n *\n * @exception {DeveloperError} options.stackPartitions must be greater than or equal to one.\n * @exception {DeveloperError} options.slicePartitions must be greater than or equal to zero.\n * @exception {DeveloperError} options.subdivisions must be greater than or equal to zero.\n *\n * @example\n * const sphere = new Cesium.SphereOutlineGeometry({\n *   radius : 100.0,\n *   stackPartitions : 6,\n *   slicePartitions: 5\n * });\n * const geometry = Cesium.SphereOutlineGeometry.createGeometry(sphere);\n */\nfunction SphereOutlineGeometry(options) {\n  const radius = options.radius ?? 1.0;\n  const radii = new Cartesian3(radius, radius, radius);\n  const ellipsoidOptions = {\n    radii: radii,\n    stackPartitions: options.stackPartitions,\n    slicePartitions: options.slicePartitions,\n    subdivisions: options.subdivisions,\n  };\n\n  this._ellipsoidGeometry = new EllipsoidOutlineGeometry(ellipsoidOptions);\n  this._workerName = \"createSphereOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nSphereOutlineGeometry.packedLength = EllipsoidOutlineGeometry.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {SphereOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nSphereOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  //>>includeEnd('debug');\n\n  return EllipsoidOutlineGeometry.pack(\n    value._ellipsoidGeometry,\n    array,\n    startingIndex,\n  );\n};\n\nconst scratchEllipsoidGeometry = new EllipsoidOutlineGeometry();\nconst scratchOptions = {\n  radius: undefined,\n  radii: new Cartesian3(),\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  subdivisions: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {SphereOutlineGeometry} [result] The object into which to store the result.\n * @returns {SphereOutlineGeometry} The modified result parameter or a new SphereOutlineGeometry instance if one was not provided.\n */\nSphereOutlineGeometry.unpack = function (array, startingIndex, result) {\n  const ellipsoidGeometry = EllipsoidOutlineGeometry.unpack(\n    array,\n    startingIndex,\n    scratchEllipsoidGeometry,\n  );\n  scratchOptions.stackPartitions = ellipsoidGeometry._stackPartitions;\n  scratchOptions.slicePartitions = ellipsoidGeometry._slicePartitions;\n  scratchOptions.subdivisions = ellipsoidGeometry._subdivisions;\n\n  if (!defined(result)) {\n    scratchOptions.radius = ellipsoidGeometry._radii.x;\n    return new SphereOutlineGeometry(scratchOptions);\n  }\n\n  Cartesian3.clone(ellipsoidGeometry._radii, scratchOptions.radii);\n  result._ellipsoidGeometry = new EllipsoidOutlineGeometry(scratchOptions);\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of a sphere, including its vertices, indices, and a bounding sphere.\n *\n * @param {SphereOutlineGeometry} sphereGeometry A description of the sphere outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nSphereOutlineGeometry.createGeometry = function (sphereGeometry) {\n  return EllipsoidOutlineGeometry.createGeometry(\n    sphereGeometry._ellipsoidGeometry,\n  );\n};\nexport default SphereOutlineGeometry;\n"],"names":["SphereOutlineGeometry","options","radius","radii","ellipsoidOptions","stackPartitions","slicePartitions","subdivisions","_ellipsoidGeometry","_workerName","packedLength","pack","value","array","startingIndex","typeOf","object","scratchEllipsoidGeometry","scratchOptions","undefined","unpack","result","ellipsoidGeometry","_stackPartitions","_slicePartitions","_subdivisions","_radii","x","clone","createGeometry","sphereGeometry"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;CAuBC,GACD,SAASA,sBAAsBC,OAAO;IACpC,MAAMC,SAASD,QAAQC,MAAM,IAAI;IACjC,MAAMC,QAAQ,IAAI,gLAAU,CAACD,QAAQA,QAAQA;IAC7C,MAAME,mBAAmB;QACvBD,OAAOA;QACPE,iBAAiBJ,QAAQI,eAAe;QACxCC,iBAAiBL,QAAQK,eAAe;QACxCC,cAAcN,QAAQM,YAAY;IACpC;IAEA,IAAI,CAACC,kBAAkB,GAAG,IAAI,8LAAwB,CAACJ;IACvD,IAAI,CAACK,WAAW,GAAG;AACrB;AAEA;;;CAGC,GACDT,sBAAsBU,YAAY,GAAG,8LAAwB,CAACA,YAAY;AAE1E;;;;;;;;CAQC,GACDV,sBAAsBW,IAAI,GAAG,SAAUC,KAAK,EAAEC,KAAK,EAAEC,aAAa;IAChE,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,SAASJ;IAC7B,wBAAwB;IAExB,OAAO,8LAAwB,CAACD,IAAI,CAClCC,MAAMJ,kBAAkB,EACxBK,OACAC;AAEJ;AAEA,MAAMG,2BAA2B,IAAI,8LAAwB;AAC7D,MAAMC,iBAAiB;IACrBhB,QAAQiB;IACRhB,OAAO,IAAI,gLAAU;IACrBE,iBAAiBc;IACjBb,iBAAiBa;IACjBZ,cAAcY;AAChB;AAEA;;;;;;;CAOC,GACDnB,sBAAsBoB,MAAM,GAAG,SAAUP,KAAK,EAAEC,aAAa,EAAEO,MAAM;IACnE,MAAMC,oBAAoB,8LAAwB,CAACF,MAAM,CACvDP,OACAC,eACAG;IAEFC,eAAeb,eAAe,GAAGiB,kBAAkBC,gBAAgB;IACnEL,eAAeZ,eAAe,GAAGgB,kBAAkBE,gBAAgB;IACnEN,eAAeX,YAAY,GAAGe,kBAAkBG,aAAa;IAE7D,IAAI,CAAC,IAAA,6KAAO,EAACJ,SAAS;QACpBH,eAAehB,MAAM,GAAGoB,kBAAkBI,MAAM,CAACC,CAAC;QAClD,OAAO,IAAI3B,sBAAsBkB;IACnC;IAEA,gLAAU,CAACU,KAAK,CAACN,kBAAkBI,MAAM,EAAER,eAAef,KAAK;IAC/DkB,OAAOb,kBAAkB,GAAG,IAAI,8LAAwB,CAACU;IACzD,OAAOG;AACT;AAEA;;;;;CAKC,GACDrB,sBAAsB6B,cAAc,GAAG,SAAUC,cAAc;IAC7D,OAAO,8LAAwB,CAACD,cAAc,CAC5CC,eAAetB,kBAAkB;AAErC;uCACeR","ignoreList":[0]}},
    {"offset": {"line": 52511, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/DoublyLinkedList.js"],"sourcesContent":["import defined from \"./defined.js\";\n\n/**\n * @private\n */\nfunction DoublyLinkedList() {\n  this.head = undefined;\n  this.tail = undefined;\n  this._length = 0;\n}\n\nObject.defineProperties(DoublyLinkedList.prototype, {\n  length: {\n    get: function () {\n      return this._length;\n    },\n  },\n});\n\n/**\n * @private\n */\nfunction DoublyLinkedListNode(item, previous, next) {\n  this.item = item;\n  this.previous = previous;\n  this.next = next;\n}\n\n/**\n * Adds the item to the end of the list\n * @param {*} [item]\n * @return {DoublyLinkedListNode}\n */\nDoublyLinkedList.prototype.add = function (item) {\n  const node = new DoublyLinkedListNode(item, this.tail, undefined);\n\n  if (defined(this.tail)) {\n    this.tail.next = node;\n    this.tail = node;\n  } else {\n    this.head = node;\n    this.tail = node;\n  }\n\n  ++this._length;\n\n  return node;\n};\n\nfunction remove(list, node) {\n  if (defined(node.previous) && defined(node.next)) {\n    node.previous.next = node.next;\n    node.next.previous = node.previous;\n  } else if (defined(node.previous)) {\n    // Remove last node\n    node.previous.next = undefined;\n    list.tail = node.previous;\n  } else if (defined(node.next)) {\n    // Remove first node\n    node.next.previous = undefined;\n    list.head = node.next;\n  } else {\n    // Remove last node in the linked list\n    list.head = undefined;\n    list.tail = undefined;\n  }\n\n  node.next = undefined;\n  node.previous = undefined;\n}\n\n/**\n * Removes the given node from the list\n * @param {DoublyLinkedListNode} node\n */\nDoublyLinkedList.prototype.remove = function (node) {\n  if (!defined(node)) {\n    return;\n  }\n\n  remove(this, node);\n\n  --this._length;\n};\n\n/**\n * Moves nextNode after node\n * @param {DoublyLinkedListNode} node\n * @param {DoublyLinkedListNode} nextNode\n */\nDoublyLinkedList.prototype.splice = function (node, nextNode) {\n  if (node === nextNode) {\n    return;\n  }\n\n  // Remove nextNode, then insert after node\n  remove(this, nextNode);\n\n  const oldNodeNext = node.next;\n  node.next = nextNode;\n\n  // nextNode is the new tail\n  if (this.tail === node) {\n    this.tail = nextNode;\n  } else {\n    oldNodeNext.previous = nextNode;\n  }\n\n  nextNode.next = oldNodeNext;\n  nextNode.previous = node;\n};\nexport default DoublyLinkedList;\n"],"names":["DoublyLinkedList","head","undefined","tail","_length","Object","defineProperties","prototype","length","get","DoublyLinkedListNode","item","previous","next","add","node","remove","list","splice","nextNode","oldNodeNext"],"mappings":";;;;AAAA;;AAEA;;CAEC,GACD,SAASA;IACP,IAAI,CAACC,IAAI,GAAGC;IACZ,IAAI,CAACC,IAAI,GAAGD;IACZ,IAAI,CAACE,OAAO,GAAG;AACjB;AAEAC,OAAOC,gBAAgB,CAACN,iBAAiBO,SAAS,EAAE;IAClDC,QAAQ;QACNC,KAAK;YACH,OAAO,IAAI,CAACL,OAAO;QACrB;IACF;AACF;AAEA;;CAEC,GACD,SAASM,qBAAqBC,IAAI,EAAEC,QAAQ,EAAEC,IAAI;IAChD,IAAI,CAACF,IAAI,GAAGA;IACZ,IAAI,CAACC,QAAQ,GAAGA;IAChB,IAAI,CAACC,IAAI,GAAGA;AACd;AAEA;;;;CAIC,GACDb,iBAAiBO,SAAS,CAACO,GAAG,GAAG,SAAUH,IAAI;IAC7C,MAAMI,OAAO,IAAIL,qBAAqBC,MAAM,IAAI,CAACR,IAAI,EAAED;IAEvD,IAAI,IAAA,6KAAO,EAAC,IAAI,CAACC,IAAI,GAAG;QACtB,IAAI,CAACA,IAAI,CAACU,IAAI,GAAGE;QACjB,IAAI,CAACZ,IAAI,GAAGY;IACd,OAAO;QACL,IAAI,CAACd,IAAI,GAAGc;QACZ,IAAI,CAACZ,IAAI,GAAGY;IACd;IAEA,EAAE,IAAI,CAACX,OAAO;IAEd,OAAOW;AACT;AAEA,SAASC,OAAOC,IAAI,EAAEF,IAAI;IACxB,IAAI,IAAA,6KAAO,EAACA,KAAKH,QAAQ,KAAK,IAAA,6KAAO,EAACG,KAAKF,IAAI,GAAG;QAChDE,KAAKH,QAAQ,CAACC,IAAI,GAAGE,KAAKF,IAAI;QAC9BE,KAAKF,IAAI,CAACD,QAAQ,GAAGG,KAAKH,QAAQ;IACpC,OAAO,IAAI,IAAA,6KAAO,EAACG,KAAKH,QAAQ,GAAG;QACjC,mBAAmB;QACnBG,KAAKH,QAAQ,CAACC,IAAI,GAAGX;QACrBe,KAAKd,IAAI,GAAGY,KAAKH,QAAQ;IAC3B,OAAO,IAAI,IAAA,6KAAO,EAACG,KAAKF,IAAI,GAAG;QAC7B,oBAAoB;QACpBE,KAAKF,IAAI,CAACD,QAAQ,GAAGV;QACrBe,KAAKhB,IAAI,GAAGc,KAAKF,IAAI;IACvB,OAAO;QACL,sCAAsC;QACtCI,KAAKhB,IAAI,GAAGC;QACZe,KAAKd,IAAI,GAAGD;IACd;IAEAa,KAAKF,IAAI,GAAGX;IACZa,KAAKH,QAAQ,GAAGV;AAClB;AAEA;;;CAGC,GACDF,iBAAiBO,SAAS,CAACS,MAAM,GAAG,SAAUD,IAAI;IAChD,IAAI,CAAC,IAAA,6KAAO,EAACA,OAAO;QAClB;IACF;IAEAC,OAAO,IAAI,EAAED;IAEb,EAAE,IAAI,CAACX,OAAO;AAChB;AAEA;;;;CAIC,GACDJ,iBAAiBO,SAAS,CAACW,MAAM,GAAG,SAAUH,IAAI,EAAEI,QAAQ;IAC1D,IAAIJ,SAASI,UAAU;QACrB;IACF;IAEA,0CAA0C;IAC1CH,OAAO,IAAI,EAAEG;IAEb,MAAMC,cAAcL,KAAKF,IAAI;IAC7BE,KAAKF,IAAI,GAAGM;IAEZ,2BAA2B;IAC3B,IAAI,IAAI,CAAChB,IAAI,KAAKY,MAAM;QACtB,IAAI,CAACZ,IAAI,GAAGgB;IACd,OAAO;QACLC,YAAYR,QAAQ,GAAGO;IACzB;IAEAA,SAASN,IAAI,GAAGO;IAChBD,SAASP,QAAQ,GAAGG;AACtB;uCACef","ignoreList":[0]}},
    {"offset": {"line": 52610, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/MortonOrder.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Morton Order (aka Z-Order Curve) helper functions.\n * @see {@link https://en.wikipedia.org/wiki/Z-order_curve}\n *\n * @namespace MortonOrder\n * @private\n */\nconst MortonOrder = {};\n\n/**\n * Inserts one 0 bit of spacing between a number's bits. This is the opposite of removeOneSpacing.\n *\n * Example:\n *  input: 6\n *  input (binary):  110\n *  output (binary): 10100\n *                    ^ ^ (added)\n *  output: 20\n *\n * @private\n * @param {number} v A 16-bit unsigned integer.\n * @returns {number} A 32-bit unsigned integer.\n * @see {@link https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/}\n * @private\n */\nfunction insertOneSpacing(v) {\n  v = (v ^ (v << 8)) & 0x00ff00ff;\n  v = (v ^ (v << 4)) & 0x0f0f0f0f;\n  v = (v ^ (v << 2)) & 0x33333333;\n  v = (v ^ (v << 1)) & 0x55555555;\n  return v;\n}\n\n/**\n * Inserts two 0 bits of spacing between a number's bits. This is the opposite of removeTwoSpacing.\n *\n * Example:\n *  input: 6\n *  input (binary):  110\n *  output (binary): 1001000\n *                    ^^ ^^ (added)\n *  output: 72\n *\n * @private\n * @param {number} v A 10-bit unsigned integer.\n * @returns {number} A 30-bit unsigned integer.\n * @see {@link https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/}\n */\nfunction insertTwoSpacing(v) {\n  v = (v ^ (v << 16)) & 0x030000ff;\n  v = (v ^ (v << 8)) & 0x0300f00f;\n  v = (v ^ (v << 4)) & 0x030c30c3;\n  v = (v ^ (v << 2)) & 0x09249249;\n  return v;\n}\n\n/**\n * Removes one bit of spacing between bits. This is the opposite of insertOneSpacing.\n *\n * Example:\n *  input: 20\n *  input (binary):  10100\n *                    ^ ^ (removed)\n *  output (binary): 110\n *  output: 6\n *\n * @private\n * @param {number} v A 32-bit unsigned integer.\n * @returns {number} A 16-bit unsigned integer.\n * @see {@link https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/}\n */\nfunction removeOneSpacing(v) {\n  v &= 0x55555555;\n  v = (v ^ (v >> 1)) & 0x33333333;\n  v = (v ^ (v >> 2)) & 0x0f0f0f0f;\n  v = (v ^ (v >> 4)) & 0x00ff00ff;\n  v = (v ^ (v >> 8)) & 0x0000ffff;\n  return v;\n}\n\n/**\n * Removes two bits of spacing between bits. This is the opposite of insertTwoSpacing.\n *\n * Example:\n *  input: 72\n *  input (binary):  1001000\n *                    ^^ ^^ (removed)\n *  output (binary): 110\n *  output: 6\n *\n * @private\n * @param {number} v A 30-bit unsigned integer.\n * @returns {number} A 10-bit unsigned integer.\n * @see {@link https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/}\n */\nfunction removeTwoSpacing(v) {\n  v &= 0x09249249;\n  v = (v ^ (v >> 2)) & 0x030c30c3;\n  v = (v ^ (v >> 4)) & 0x0300f00f;\n  v = (v ^ (v >> 8)) & 0xff0000ff;\n  v = (v ^ (v >> 16)) & 0x000003ff;\n  return v;\n}\n\n/**\n * Computes the Morton index from 2D coordinates. This is equivalent to interleaving their bits.\n * The inputs must be 16-bit unsigned integers (resulting in 32-bit Morton index) due to 32-bit bitwise operator limitation in JavaScript.\n *\n * @param {number} x The X coordinate in the range [0, (2^16)-1].\n * @param {number} y The Y coordinate in the range [0, (2^16)-1].\n * @returns {number} The Morton index.\n * @private\n */\nMortonOrder.encode2D = function (x, y) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  if (x < 0 || x > 65535 || y < 0 || y > 65535) {\n    throw new DeveloperError(\"inputs must be 16-bit unsigned integers\");\n  }\n  //>>includeEnd('debug');\n\n  // Note: JavaScript bitwise operations return signed 32-bit integers, so the\n  // final result needs to be reintepreted as an unsigned integer using >>> 0.\n  // This is not needed for encode3D because the result is guaranteed to be at most\n  // 30 bits and thus will always be interpreted as an unsigned value.\n  return (insertOneSpacing(x) | (insertOneSpacing(y) << 1)) >>> 0;\n};\n\n/**\n * Computes the 2D coordinates from a Morton index. This is equivalent to deinterleaving their bits.\n * The input must be a 32-bit unsigned integer (resulting in 16 bits per coordinate) due to 32-bit bitwise operator limitation in JavaScript.\n *\n * @param {number} mortonIndex The Morton index in the range [0, (2^32)-1].\n * @param {number[]} [result] The array onto which to store the result.\n * @returns {number[]} An array containing the 2D coordinates correspoding to the Morton index.\n * @private\n */\nMortonOrder.decode2D = function (mortonIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"mortonIndex\", mortonIndex);\n  if (mortonIndex < 0 || mortonIndex > 4294967295) {\n    throw new DeveloperError(\"input must be a 32-bit unsigned integer\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Array(2);\n  }\n\n  result[0] = removeOneSpacing(mortonIndex);\n  result[1] = removeOneSpacing(mortonIndex >> 1);\n  return result;\n};\n\n/**\n * Computes the Morton index from 3D coordinates. This is equivalent to interleaving their bits.\n * The inputs must be 10-bit unsigned integers (resulting in 30-bit Morton index) due to 32-bit bitwise operator limitation in JavaScript.\n *\n * @param {number} x The X coordinate in the range [0, (2^10)-1].\n * @param {number} y The Y coordinate in the range [0, (2^10)-1].\n * @param {number} z The Z coordinate in the range [0, (2^10)-1].\n * @returns {number} The Morton index.\n * @private\n */\nMortonOrder.encode3D = function (x, y, z) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  Check.typeOf.number(\"z\", z);\n  if (x < 0 || x > 1023 || y < 0 || y > 1023 || z < 0 || z > 1023) {\n    throw new DeveloperError(\"inputs must be 10-bit unsigned integers\");\n  }\n  //>>includeEnd('debug');\n\n  return (\n    insertTwoSpacing(x) |\n    (insertTwoSpacing(y) << 1) |\n    (insertTwoSpacing(z) << 2)\n  );\n};\n\n/**\n * Computes the 3D coordinates from a Morton index. This is equivalent to deinterleaving their bits.\n * The input must be a 30-bit unsigned integer (resulting in 10 bits per coordinate) due to 32-bit bitwise operator limitation in JavaScript.\n *\n * @param {number} mortonIndex The Morton index in the range [0, (2^30)-1].\n * @param {number[]} [result] The array onto which to store the result.\n * @returns {number[]} An array containing the 3D coordinates corresponding to the Morton index.\n * @private\n */\nMortonOrder.decode3D = function (mortonIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"mortonIndex\", mortonIndex);\n  if (mortonIndex < 0 || mortonIndex > 1073741823) {\n    throw new DeveloperError(\"input must be a 30-bit unsigned integer\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Array(3);\n  }\n\n  result[0] = removeTwoSpacing(mortonIndex);\n  result[1] = removeTwoSpacing(mortonIndex >> 1);\n  result[2] = removeTwoSpacing(mortonIndex >> 2);\n  return result;\n};\n\nexport default MortonOrder;\n"],"names":["MortonOrder","insertOneSpacing","v","insertTwoSpacing","removeOneSpacing","removeTwoSpacing","encode2D","x","y","typeOf","number","decode2D","mortonIndex","result","Array","encode3D","z","decode3D"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 52806, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TimeIntervalCollection.js"],"sourcesContent":["import binarySearch from \"./binarySearch.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Event from \"./Event.js\";\nimport GregorianDate from \"./GregorianDate.js\";\nimport isLeapYear from \"./isLeapYear.js\";\nimport Iso8601 from \"./Iso8601.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport TimeInterval from \"./TimeInterval.js\";\n\nfunction compareIntervalStartTimes(left, right) {\n  return JulianDate.compare(left.start, right.start);\n}\n\n/**\n * A non-overlapping collection of {@link TimeInterval} instances sorted by start time.\n * @alias TimeIntervalCollection\n * @constructor\n *\n * @param {TimeInterval[]} [intervals] An array of intervals to add to the collection.\n */\nfunction TimeIntervalCollection(intervals) {\n  this._intervals = [];\n  this._changedEvent = new Event();\n\n  if (defined(intervals)) {\n    const length = intervals.length;\n    for (let i = 0; i < length; i++) {\n      this.addInterval(intervals[i]);\n    }\n  }\n}\n\nObject.defineProperties(TimeIntervalCollection.prototype, {\n  /**\n   * Gets an event that is raised whenever the collection of intervals change.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {Event}\n   * @readonly\n   */\n  changedEvent: {\n    get: function () {\n      return this._changedEvent;\n    },\n  },\n\n  /**\n   * Gets the start time of the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {JulianDate}\n   * @readonly\n   */\n  start: {\n    get: function () {\n      const intervals = this._intervals;\n      return intervals.length === 0 ? undefined : intervals[0].start;\n    },\n  },\n\n  /**\n   * Gets whether or not the start time is included in the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isStartIncluded: {\n    get: function () {\n      const intervals = this._intervals;\n      return intervals.length === 0 ? false : intervals[0].isStartIncluded;\n    },\n  },\n\n  /**\n   * Gets the stop time of the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {JulianDate}\n   * @readonly\n   */\n  stop: {\n    get: function () {\n      const intervals = this._intervals;\n      const length = intervals.length;\n      return length === 0 ? undefined : intervals[length - 1].stop;\n    },\n  },\n\n  /**\n   * Gets whether or not the stop time is included in the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isStopIncluded: {\n    get: function () {\n      const intervals = this._intervals;\n      const length = intervals.length;\n      return length === 0 ? false : intervals[length - 1].isStopIncluded;\n    },\n  },\n\n  /**\n   * Gets the number of intervals in the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._intervals.length;\n    },\n  },\n\n  /**\n   * Gets whether or not the collection is empty.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isEmpty: {\n    get: function () {\n      return this._intervals.length === 0;\n    },\n  },\n});\n\n/**\n * Compares this instance against the provided instance componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TimeIntervalCollection} [right] The right hand side collection.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nTimeIntervalCollection.prototype.equals = function (right, dataComparer) {\n  if (this === right) {\n    return true;\n  }\n  if (!(right instanceof TimeIntervalCollection)) {\n    return false;\n  }\n  const intervals = this._intervals;\n  const rightIntervals = right._intervals;\n  const length = intervals.length;\n  if (length !== rightIntervals.length) {\n    return false;\n  }\n  for (let i = 0; i < length; i++) {\n    if (!TimeInterval.equals(intervals[i], rightIntervals[i], dataComparer)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Gets the interval at the specified index.\n *\n * @param {number} index The index of the interval to retrieve.\n * @returns {TimeInterval|undefined} The interval at the specified index, or <code>undefined</code> if no interval exists as that index.\n */\nTimeIntervalCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._intervals[index];\n};\n\n/**\n * Removes all intervals from the collection.\n */\nTimeIntervalCollection.prototype.removeAll = function () {\n  if (this._intervals.length > 0) {\n    this._intervals.length = 0;\n    this._changedEvent.raiseEvent(this);\n  }\n};\n\n/**\n * Finds and returns the interval that contains the specified date.\n *\n * @param {JulianDate} date The date to search for.\n * @returns {TimeInterval|undefined} The interval containing the specified date, <code>undefined</code> if no such interval exists.\n */\nTimeIntervalCollection.prototype.findIntervalContainingDate = function (date) {\n  const index = this.indexOf(date);\n  return index >= 0 ? this._intervals[index] : undefined;\n};\n\n/**\n * Finds and returns the data for the interval that contains the specified date.\n *\n * @param {JulianDate} date The date to search for.\n * @returns {object} The data for the interval containing the specified date, or <code>undefined</code> if no such interval exists.\n */\nTimeIntervalCollection.prototype.findDataForIntervalContainingDate = function (\n  date,\n) {\n  const index = this.indexOf(date);\n  return index >= 0 ? this._intervals[index].data : undefined;\n};\n\n/**\n * Checks if the specified date is inside this collection.\n *\n * @param {JulianDate} julianDate The date to check.\n * @returns {boolean} <code>true</code> if the collection contains the specified date, <code>false</code> otherwise.\n */\nTimeIntervalCollection.prototype.contains = function (julianDate) {\n  return this.indexOf(julianDate) >= 0;\n};\n\nconst indexOfScratch = new TimeInterval();\n\n/**\n * Finds and returns the index of the interval in the collection that contains the specified date.\n *\n * @param {JulianDate} date The date to search for.\n * @returns {number} The index of the interval that contains the specified date, if no such interval exists,\n * it returns a negative number which is the bitwise complement of the index of the next interval that\n * starts after the date, or if no interval starts after the specified date, the bitwise complement of\n * the length of the collection.\n */\nTimeIntervalCollection.prototype.indexOf = function (date) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required\");\n  }\n  //>>includeEnd('debug');\n\n  const intervals = this._intervals;\n  indexOfScratch.start = date;\n  indexOfScratch.stop = date;\n  let index = binarySearch(\n    intervals,\n    indexOfScratch,\n    compareIntervalStartTimes,\n  );\n  if (index >= 0) {\n    if (intervals[index].isStartIncluded) {\n      return index;\n    }\n\n    if (\n      index > 0 &&\n      intervals[index - 1].stop.equals(date) &&\n      intervals[index - 1].isStopIncluded\n    ) {\n      return index - 1;\n    }\n    return ~index;\n  }\n\n  index = ~index;\n  if (\n    index > 0 &&\n    index - 1 < intervals.length &&\n    TimeInterval.contains(intervals[index - 1], date)\n  ) {\n    return index - 1;\n  }\n  return ~index;\n};\n\n/**\n * Returns the first interval in the collection that matches the specified parameters.\n * All parameters are optional and <code>undefined</code> parameters are treated as a don't care condition.\n *\n * @param {object} [options] Object with the following properties:\n * @param {JulianDate} [options.start] The start time of the interval.\n * @param {JulianDate} [options.stop] The stop time of the interval.\n * @param {boolean} [options.isStartIncluded] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.\n * @returns {TimeInterval|undefined} The first interval in the collection that matches the specified parameters.\n */\nTimeIntervalCollection.prototype.findInterval = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const start = options.start;\n  const stop = options.stop;\n  const isStartIncluded = options.isStartIncluded;\n  const isStopIncluded = options.isStopIncluded;\n\n  const intervals = this._intervals;\n  for (let i = 0, len = intervals.length; i < len; i++) {\n    const interval = intervals[i];\n    if (\n      (!defined(start) || interval.start.equals(start)) &&\n      (!defined(stop) || interval.stop.equals(stop)) &&\n      (!defined(isStartIncluded) ||\n        interval.isStartIncluded === isStartIncluded) &&\n      (!defined(isStopIncluded) || interval.isStopIncluded === isStopIncluded)\n    ) {\n      return intervals[i];\n    }\n  }\n  return undefined;\n};\n\n/**\n * Adds an interval to the collection, merging intervals that contain the same data and\n * splitting intervals of different data as needed in order to maintain a non-overlapping collection.\n * The data in the new interval takes precedence over any existing intervals in the collection.\n *\n * @param {TimeInterval} interval The interval to add.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n */\nTimeIntervalCollection.prototype.addInterval = function (\n  interval,\n  dataComparer,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(interval)) {\n    throw new DeveloperError(\"interval is required\");\n  }\n  //>>includeEnd('debug');\n\n  if (interval.isEmpty) {\n    return;\n  }\n\n  const intervals = this._intervals;\n\n  // Handle the common case quickly: we're adding a new interval which is after all existing intervals.\n  if (\n    intervals.length === 0 ||\n    JulianDate.greaterThan(interval.start, intervals[intervals.length - 1].stop)\n  ) {\n    intervals.push(interval);\n    this._changedEvent.raiseEvent(this);\n    return;\n  }\n\n  // Keep the list sorted by the start date\n  let index = binarySearch(intervals, interval, compareIntervalStartTimes);\n  if (index < 0) {\n    index = ~index;\n  } else {\n    // interval's start date exactly equals the start date of at least one interval in the collection.\n    // It could actually equal the start date of two intervals if one of them does not actually\n    // include the date.  In that case, the binary search could have found either.  We need to\n    // look at the surrounding intervals and their IsStartIncluded properties in order to make sure\n    // we're working with the correct interval.\n\n    // eslint-disable-next-line no-lonely-if\n    if (\n      index > 0 &&\n      interval.isStartIncluded &&\n      intervals[index - 1].isStartIncluded &&\n      intervals[index - 1].start.equals(interval.start)\n    ) {\n      --index;\n    } else if (\n      index < intervals.length &&\n      !interval.isStartIncluded &&\n      intervals[index].isStartIncluded &&\n      intervals[index].start.equals(interval.start)\n    ) {\n      ++index;\n    }\n  }\n\n  let comparison;\n  if (index > 0) {\n    // Not the first thing in the list, so see if the interval before this one\n    // overlaps this one.\n\n    comparison = JulianDate.compare(intervals[index - 1].stop, interval.start);\n    if (\n      comparison > 0 ||\n      (comparison === 0 &&\n        (intervals[index - 1].isStopIncluded || interval.isStartIncluded))\n    ) {\n      // There is an overlap\n      if (\n        defined(dataComparer)\n          ? dataComparer(intervals[index - 1].data, interval.data)\n          : intervals[index - 1].data === interval.data\n      ) {\n        // Overlapping intervals have the same data, so combine them\n        if (JulianDate.greaterThan(interval.stop, intervals[index - 1].stop)) {\n          interval = new TimeInterval({\n            start: intervals[index - 1].start,\n            stop: interval.stop,\n            isStartIncluded: intervals[index - 1].isStartIncluded,\n            isStopIncluded: interval.isStopIncluded,\n            data: interval.data,\n          });\n        } else {\n          interval = new TimeInterval({\n            start: intervals[index - 1].start,\n            stop: intervals[index - 1].stop,\n            isStartIncluded: intervals[index - 1].isStartIncluded,\n            isStopIncluded:\n              intervals[index - 1].isStopIncluded ||\n              (interval.stop.equals(intervals[index - 1].stop) &&\n                interval.isStopIncluded),\n            data: interval.data,\n          });\n        }\n        intervals.splice(index - 1, 1);\n        --index;\n      } else {\n        // Overlapping intervals have different data.  The new interval\n        // being added 'wins' so truncate the previous interval.\n        // If the existing interval extends past the end of the new one,\n        // split the existing interval into two intervals.\n        comparison = JulianDate.compare(\n          intervals[index - 1].stop,\n          interval.stop,\n        );\n        if (\n          comparison > 0 ||\n          (comparison === 0 &&\n            intervals[index - 1].isStopIncluded &&\n            !interval.isStopIncluded)\n        ) {\n          intervals.splice(\n            index,\n            0,\n            new TimeInterval({\n              start: interval.stop,\n              stop: intervals[index - 1].stop,\n              isStartIncluded: !interval.isStopIncluded,\n              isStopIncluded: intervals[index - 1].isStopIncluded,\n              data: intervals[index - 1].data,\n            }),\n          );\n        }\n        intervals[index - 1] = new TimeInterval({\n          start: intervals[index - 1].start,\n          stop: interval.start,\n          isStartIncluded: intervals[index - 1].isStartIncluded,\n          isStopIncluded: !interval.isStartIncluded,\n          data: intervals[index - 1].data,\n        });\n      }\n    }\n  }\n\n  while (index < intervals.length) {\n    // Not the last thing in the list, so see if the intervals after this one overlap this one.\n    comparison = JulianDate.compare(interval.stop, intervals[index].start);\n    if (\n      comparison > 0 ||\n      (comparison === 0 &&\n        (interval.isStopIncluded || intervals[index].isStartIncluded))\n    ) {\n      // There is an overlap\n      if (\n        defined(dataComparer)\n          ? dataComparer(intervals[index].data, interval.data)\n          : intervals[index].data === interval.data\n      ) {\n        // Overlapping intervals have the same data, so combine them\n        interval = new TimeInterval({\n          start: interval.start,\n          stop: JulianDate.greaterThan(intervals[index].stop, interval.stop)\n            ? intervals[index].stop\n            : interval.stop,\n          isStartIncluded: interval.isStartIncluded,\n          isStopIncluded: JulianDate.greaterThan(\n            intervals[index].stop,\n            interval.stop,\n          )\n            ? intervals[index].isStopIncluded\n            : interval.isStopIncluded,\n          data: interval.data,\n        });\n        intervals.splice(index, 1);\n      } else {\n        // Overlapping intervals have different data.  The new interval\n        // being added 'wins' so truncate the next interval.\n        intervals[index] = new TimeInterval({\n          start: interval.stop,\n          stop: intervals[index].stop,\n          isStartIncluded: !interval.isStopIncluded,\n          isStopIncluded: intervals[index].isStopIncluded,\n          data: intervals[index].data,\n        });\n\n        if (intervals[index].isEmpty) {\n          intervals.splice(index, 1);\n        } else {\n          // Found a partial span, so it is not possible for the next\n          // interval to be spanned at all.  Stop looking.\n          break;\n        }\n      }\n    } else {\n      // Found the last one we're spanning, so stop looking.\n      break;\n    }\n  }\n\n  // Add the new interval\n  intervals.splice(index, 0, interval);\n  this._changedEvent.raiseEvent(this);\n};\n\n/**\n * Removes the specified interval from this interval collection, creating a hole over the specified interval.\n * The data property of the input interval is ignored.\n *\n * @param {TimeInterval} interval The interval to remove.\n * @returns {boolean} <code>true</code> if the interval was removed, <code>false</code> if no part of the interval was in the collection.\n */\nTimeIntervalCollection.prototype.removeInterval = function (interval) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(interval)) {\n    throw new DeveloperError(\"interval is required\");\n  }\n  //>>includeEnd('debug');\n\n  if (interval.isEmpty) {\n    return false;\n  }\n\n  const intervals = this._intervals;\n\n  let index = binarySearch(intervals, interval, compareIntervalStartTimes);\n  if (index < 0) {\n    index = ~index;\n  }\n\n  let result = false;\n\n  // Check for truncation of the end of the previous interval.\n  if (\n    index > 0 &&\n    (JulianDate.greaterThan(intervals[index - 1].stop, interval.start) ||\n      (intervals[index - 1].stop.equals(interval.start) &&\n        intervals[index - 1].isStopIncluded &&\n        interval.isStartIncluded))\n  ) {\n    result = true;\n\n    if (\n      JulianDate.greaterThan(intervals[index - 1].stop, interval.stop) ||\n      (intervals[index - 1].isStopIncluded &&\n        !interval.isStopIncluded &&\n        intervals[index - 1].stop.equals(interval.stop))\n    ) {\n      // Break the existing interval into two pieces\n      intervals.splice(\n        index,\n        0,\n        new TimeInterval({\n          start: interval.stop,\n          stop: intervals[index - 1].stop,\n          isStartIncluded: !interval.isStopIncluded,\n          isStopIncluded: intervals[index - 1].isStopIncluded,\n          data: intervals[index - 1].data,\n        }),\n      );\n    }\n    intervals[index - 1] = new TimeInterval({\n      start: intervals[index - 1].start,\n      stop: interval.start,\n      isStartIncluded: intervals[index - 1].isStartIncluded,\n      isStopIncluded: !interval.isStartIncluded,\n      data: intervals[index - 1].data,\n    });\n  }\n\n  // Check if the Start of the current interval should remain because interval.start is the same but\n  // it is not included.\n  if (\n    index < intervals.length &&\n    !interval.isStartIncluded &&\n    intervals[index].isStartIncluded &&\n    interval.start.equals(intervals[index].start)\n  ) {\n    result = true;\n\n    intervals.splice(\n      index,\n      0,\n      new TimeInterval({\n        start: intervals[index].start,\n        stop: intervals[index].start,\n        isStartIncluded: true,\n        isStopIncluded: true,\n        data: intervals[index].data,\n      }),\n    );\n    ++index;\n  }\n\n  // Remove any intervals that are completely overlapped by the input interval.\n  while (\n    index < intervals.length &&\n    JulianDate.greaterThan(interval.stop, intervals[index].stop)\n  ) {\n    result = true;\n    intervals.splice(index, 1);\n  }\n\n  // Check for the case where the input interval ends on the same date\n  // as an existing interval.\n  if (index < intervals.length && interval.stop.equals(intervals[index].stop)) {\n    result = true;\n\n    if (!interval.isStopIncluded && intervals[index].isStopIncluded) {\n      // Last point of interval should remain because the stop date is included in\n      // the existing interval but is not included in the input interval.\n      if (\n        index + 1 < intervals.length &&\n        intervals[index + 1].start.equals(interval.stop) &&\n        intervals[index].data === intervals[index + 1].data\n      ) {\n        // Combine single point with the next interval\n        intervals.splice(index, 1);\n        intervals[index] = new TimeInterval({\n          start: intervals[index].start,\n          stop: intervals[index].stop,\n          isStartIncluded: true,\n          isStopIncluded: intervals[index].isStopIncluded,\n          data: intervals[index].data,\n        });\n      } else {\n        intervals[index] = new TimeInterval({\n          start: interval.stop,\n          stop: interval.stop,\n          isStartIncluded: true,\n          isStopIncluded: true,\n          data: intervals[index].data,\n        });\n      }\n    } else {\n      // Interval is completely overlapped\n      intervals.splice(index, 1);\n    }\n  }\n\n  // Truncate any partially-overlapped intervals.\n  if (\n    index < intervals.length &&\n    (JulianDate.greaterThan(interval.stop, intervals[index].start) ||\n      (interval.stop.equals(intervals[index].start) &&\n        interval.isStopIncluded &&\n        intervals[index].isStartIncluded))\n  ) {\n    result = true;\n    intervals[index] = new TimeInterval({\n      start: interval.stop,\n      stop: intervals[index].stop,\n      isStartIncluded: !interval.isStopIncluded,\n      isStopIncluded: intervals[index].isStopIncluded,\n      data: intervals[index].data,\n    });\n  }\n\n  if (result) {\n    this._changedEvent.raiseEvent(this);\n  }\n\n  return result;\n};\n\n/**\n * Creates a new instance that is the intersection of this collection and the provided collection.\n *\n * @param {TimeIntervalCollection} other The collection to intersect with.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @param {TimeInterval.MergeCallback} [mergeCallback] A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.\n * @returns {TimeIntervalCollection} A new TimeIntervalCollection which is the intersection of this collection and the provided collection.\n */\nTimeIntervalCollection.prototype.intersect = function (\n  other,\n  dataComparer,\n  mergeCallback,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(other)) {\n    throw new DeveloperError(\"other is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const result = new TimeIntervalCollection();\n  let left = 0;\n  let right = 0;\n  const intervals = this._intervals;\n  const otherIntervals = other._intervals;\n\n  while (left < intervals.length && right < otherIntervals.length) {\n    const leftInterval = intervals[left];\n    const rightInterval = otherIntervals[right];\n    if (JulianDate.lessThan(leftInterval.stop, rightInterval.start)) {\n      ++left;\n    } else if (JulianDate.lessThan(rightInterval.stop, leftInterval.start)) {\n      ++right;\n    } else {\n      // The following will return an intersection whose data is 'merged' if the callback is defined\n      if (\n        defined(mergeCallback) ||\n        (defined(dataComparer) &&\n          dataComparer(leftInterval.data, rightInterval.data)) ||\n        (!defined(dataComparer) && rightInterval.data === leftInterval.data)\n      ) {\n        const intersection = TimeInterval.intersect(\n          leftInterval,\n          rightInterval,\n          new TimeInterval(),\n          mergeCallback,\n        );\n        if (!intersection.isEmpty) {\n          // Since we start with an empty collection for 'result', and there are no overlapping intervals in 'this' (as a rule),\n          // the 'intersection' will never overlap with a previous interval in 'result'.  So, no need to do any additional 'merging'.\n          result.addInterval(intersection, dataComparer);\n        }\n      }\n\n      if (\n        JulianDate.lessThan(leftInterval.stop, rightInterval.stop) ||\n        (leftInterval.stop.equals(rightInterval.stop) &&\n          !leftInterval.isStopIncluded &&\n          rightInterval.isStopIncluded)\n      ) {\n        ++left;\n      } else {\n        ++right;\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Creates a new instance from a JulianDate array.\n *\n * @param {object} options Object with the following properties:\n * @param {JulianDate[]} options.julianDates An array of ISO 8601 dates.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.\n * @param {boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.\n * @param {Function} [options.dataCallback] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.\n * @param {TimeIntervalCollection} [result] An existing instance to use for the result.\n * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.\n */\nTimeIntervalCollection.fromJulianDateArray = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.julianDates)) {\n    throw new DeveloperError(\"options.iso8601Array is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new TimeIntervalCollection();\n  }\n\n  const julianDates = options.julianDates;\n  const length = julianDates.length;\n  const dataCallback = options.dataCallback;\n\n  const isStartIncluded = options.isStartIncluded ?? true;\n  const isStopIncluded = options.isStopIncluded ?? true;\n  const leadingInterval = options.leadingInterval ?? false;\n  const trailingInterval = options.trailingInterval ?? false;\n  let interval;\n\n  // Add a default interval, which will only end up being used up to first interval\n  let startIndex = 0;\n  if (leadingInterval) {\n    ++startIndex;\n    interval = new TimeInterval({\n      start: Iso8601.MINIMUM_VALUE,\n      stop: julianDates[0],\n      isStartIncluded: true,\n      isStopIncluded: !isStartIncluded,\n    });\n    interval.data = defined(dataCallback)\n      ? dataCallback(interval, result.length)\n      : result.length;\n    result.addInterval(interval);\n  }\n\n  for (let i = 0; i < length - 1; ++i) {\n    let startDate = julianDates[i];\n    const endDate = julianDates[i + 1];\n\n    interval = new TimeInterval({\n      start: startDate,\n      stop: endDate,\n      isStartIncluded: result.length === startIndex ? isStartIncluded : true,\n      isStopIncluded: i === length - 2 ? isStopIncluded : false,\n    });\n    interval.data = defined(dataCallback)\n      ? dataCallback(interval, result.length)\n      : result.length;\n    result.addInterval(interval);\n\n    startDate = endDate;\n  }\n\n  if (trailingInterval) {\n    interval = new TimeInterval({\n      start: julianDates[length - 1],\n      stop: Iso8601.MAXIMUM_VALUE,\n      isStartIncluded: !isStopIncluded,\n      isStopIncluded: true,\n    });\n    interval.data = defined(dataCallback)\n      ? dataCallback(interval, result.length)\n      : result.length;\n    result.addInterval(interval);\n  }\n\n  return result;\n};\n\nconst scratchGregorianDate = new GregorianDate();\nconst monthLengths = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n/**\n * Adds duration represented as a GregorianDate to a JulianDate\n *\n * @param {JulianDate} julianDate The date.\n * @param {GregorianDate} duration An duration represented as a GregorianDate.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n *\n * @private\n */\nfunction addToDate(julianDate, duration, result) {\n  if (!defined(result)) {\n    result = new JulianDate();\n  }\n  JulianDate.toGregorianDate(julianDate, scratchGregorianDate);\n\n  let millisecond = scratchGregorianDate.millisecond + duration.millisecond;\n  let second = scratchGregorianDate.second + duration.second;\n  let minute = scratchGregorianDate.minute + duration.minute;\n  let hour = scratchGregorianDate.hour + duration.hour;\n  let day = scratchGregorianDate.day + duration.day;\n  let month = scratchGregorianDate.month + duration.month;\n  let year = scratchGregorianDate.year + duration.year;\n\n  if (millisecond >= 1000) {\n    second += Math.floor(millisecond / 1000);\n    millisecond = millisecond % 1000;\n  }\n\n  if (second >= 60) {\n    minute += Math.floor(second / 60);\n    second = second % 60;\n  }\n\n  if (minute >= 60) {\n    hour += Math.floor(minute / 60);\n    minute = minute % 60;\n  }\n\n  if (hour >= 24) {\n    day += Math.floor(hour / 24);\n    hour = hour % 24;\n  }\n\n  // If days is greater than the month's length we need to remove those number of days,\n  //  readjust month and year and repeat until days is less than the month's length.\n  monthLengths[2] = isLeapYear(year) ? 29 : 28;\n  while (day > monthLengths[month] || month >= 13) {\n    if (day > monthLengths[month]) {\n      day -= monthLengths[month];\n      ++month;\n    }\n\n    if (month >= 13) {\n      --month;\n      year += Math.floor(month / 12);\n      month = month % 12;\n      ++month;\n    }\n\n    monthLengths[2] = isLeapYear(year) ? 29 : 28;\n  }\n\n  scratchGregorianDate.millisecond = millisecond;\n  scratchGregorianDate.second = second;\n  scratchGregorianDate.minute = minute;\n  scratchGregorianDate.hour = hour;\n  scratchGregorianDate.day = day;\n  scratchGregorianDate.month = month;\n  scratchGregorianDate.year = year;\n\n  return JulianDate.fromGregorianDate(scratchGregorianDate, result);\n}\n\nconst scratchJulianDate = new JulianDate();\nconst durationRegex =\n  /P(?:([\\d.,]+)Y)?(?:([\\d.,]+)M)?(?:([\\d.,]+)W)?(?:([\\d.,]+)D)?(?:T(?:([\\d.,]+)H)?(?:([\\d.,]+)M)?(?:([\\d.,]+)S)?)?/;\n\n/**\n * Parses ISO8601 duration string\n *\n * @param {string} iso8601 An ISO 8601 duration.\n * @param {GregorianDate} result An existing instance to use for the result.\n * @returns {boolean} True is parsing succeeded, false otherwise\n *\n * @private\n */\nfunction parseDuration(iso8601, result) {\n  if (!defined(iso8601) || iso8601.length === 0) {\n    return false;\n  }\n\n  // Reset object\n  result.year = 0;\n  result.month = 0;\n  result.day = 0;\n  result.hour = 0;\n  result.minute = 0;\n  result.second = 0;\n  result.millisecond = 0;\n\n  if (iso8601[0] === \"P\") {\n    const matches = iso8601.match(durationRegex);\n    if (!defined(matches)) {\n      return false;\n    }\n    if (defined(matches[1])) {\n      // Years\n      result.year = Number(matches[1].replace(\",\", \".\"));\n    }\n    if (defined(matches[2])) {\n      // Months\n      result.month = Number(matches[2].replace(\",\", \".\"));\n    }\n    if (defined(matches[3])) {\n      // Weeks\n      result.day = Number(matches[3].replace(\",\", \".\")) * 7;\n    }\n    if (defined(matches[4])) {\n      // Days\n      result.day += Number(matches[4].replace(\",\", \".\"));\n    }\n    if (defined(matches[5])) {\n      // Hours\n      result.hour = Number(matches[5].replace(\",\", \".\"));\n    }\n    if (defined(matches[6])) {\n      // Weeks\n      result.minute = Number(matches[6].replace(\",\", \".\"));\n    }\n    if (defined(matches[7])) {\n      // Seconds\n      const seconds = Number(matches[7].replace(\",\", \".\"));\n      result.second = Math.floor(seconds);\n      result.millisecond = (seconds % 1) * 1000;\n    }\n  } else {\n    // They can technically specify the duration as a normal date with some caveats. Try our best to load it.\n    if (iso8601[iso8601.length - 1] !== \"Z\") {\n      // It's not a date, its a duration, so it always has to be UTC\n      iso8601 += \"Z\";\n    }\n    JulianDate.toGregorianDate(\n      JulianDate.fromIso8601(iso8601, scratchJulianDate),\n      result,\n    );\n  }\n\n  // A duration of 0 will cause an infinite loop, so just make sure something is non-zero\n  return (\n    result.year ||\n    result.month ||\n    result.day ||\n    result.hour ||\n    result.minute ||\n    result.second ||\n    result.millisecond\n  );\n}\n\nconst scratchDuration = new GregorianDate();\n/**\n * Creates a new instance from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} time interval (start/end/duration).\n *\n * @param {object} options Object with the following properties:\n * @param {string} options.iso8601 An ISO 8601 interval.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.\n * @param {boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.\n * @param {Function} [options.dataCallback] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.\n * @param {TimeIntervalCollection} [result] An existing instance to use for the result.\n * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.\n */\nTimeIntervalCollection.fromIso8601 = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.iso8601)) {\n    throw new DeveloperError(\"options.iso8601 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const dates = options.iso8601.split(\"/\");\n  const start = JulianDate.fromIso8601(dates[0]);\n  const stop = JulianDate.fromIso8601(dates[1]);\n  const julianDates = [];\n\n  if (!parseDuration(dates[2], scratchDuration)) {\n    julianDates.push(start, stop);\n  } else {\n    let date = JulianDate.clone(start);\n    julianDates.push(date);\n    while (JulianDate.compare(date, stop) < 0) {\n      date = addToDate(date, scratchDuration);\n      const afterStop = JulianDate.compare(stop, date) <= 0;\n      if (afterStop) {\n        JulianDate.clone(stop, date);\n      }\n\n      julianDates.push(date);\n    }\n  }\n\n  return TimeIntervalCollection.fromJulianDateArray(\n    {\n      julianDates: julianDates,\n      isStartIncluded: options.isStartIncluded,\n      isStopIncluded: options.isStopIncluded,\n      leadingInterval: options.leadingInterval,\n      trailingInterval: options.trailingInterval,\n      dataCallback: options.dataCallback,\n    },\n    result,\n  );\n};\n\n/**\n * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date array.\n *\n * @param {object} options Object with the following properties:\n * @param {string[]} options.iso8601Dates An array of ISO 8601 dates.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.\n * @param {boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.\n * @param {Function} [options.dataCallback] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.\n * @param {TimeIntervalCollection} [result] An existing instance to use for the result.\n * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.\n */\nTimeIntervalCollection.fromIso8601DateArray = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.iso8601Dates)) {\n    throw new DeveloperError(\"options.iso8601Dates is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return TimeIntervalCollection.fromJulianDateArray(\n    {\n      julianDates: options.iso8601Dates.map(function (date) {\n        return JulianDate.fromIso8601(date);\n      }),\n      isStartIncluded: options.isStartIncluded,\n      isStopIncluded: options.isStopIncluded,\n      leadingInterval: options.leadingInterval,\n      trailingInterval: options.trailingInterval,\n      dataCallback: options.dataCallback,\n    },\n    result,\n  );\n};\n\n/**\n * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} duration array.\n *\n * @param {object} options Object with the following properties:\n * @param {JulianDate} options.epoch An date that the durations are relative to.\n * @param {string} options.iso8601Durations An array of ISO 8601 durations.\n * @param {boolean} [options.relativeToPrevious=false] <code>true</code> if durations are relative to previous date, <code>false</code> if always relative to the epoch.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.\n * @param {boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.\n * @param {Function} [options.dataCallback] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.\n * @param {TimeIntervalCollection} [result] An existing instance to use for the result.\n * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.\n */\nTimeIntervalCollection.fromIso8601DurationArray = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.epoch)) {\n    throw new DeveloperError(\"options.epoch is required.\");\n  }\n  if (!defined(options.iso8601Durations)) {\n    throw new DeveloperError(\"options.iso8601Durations is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const epoch = options.epoch;\n  const iso8601Durations = options.iso8601Durations;\n  const relativeToPrevious = options.relativeToPrevious ?? false;\n  const julianDates = [];\n  let date, previousDate;\n\n  const length = iso8601Durations.length;\n  for (let i = 0; i < length; ++i) {\n    // Allow a duration of 0 on the first iteration, because then it is just the epoch\n    if (parseDuration(iso8601Durations[i], scratchDuration) || i === 0) {\n      if (relativeToPrevious && defined(previousDate)) {\n        date = addToDate(previousDate, scratchDuration);\n      } else {\n        date = addToDate(epoch, scratchDuration);\n      }\n      julianDates.push(date);\n      previousDate = date;\n    }\n  }\n\n  return TimeIntervalCollection.fromJulianDateArray(\n    {\n      julianDates: julianDates,\n      isStartIncluded: options.isStartIncluded,\n      isStopIncluded: options.isStopIncluded,\n      leadingInterval: options.leadingInterval,\n      trailingInterval: options.trailingInterval,\n      dataCallback: options.dataCallback,\n    },\n    result,\n  );\n};\nexport default TimeIntervalCollection;\n"],"names":["compareIntervalStartTimes","left","right","compare","start","TimeIntervalCollection","intervals","_intervals","_changedEvent","length","i","addInterval","Object","defineProperties","prototype","changedEvent","get","undefined","isStartIncluded","stop","isStopIncluded","isEmpty","equals","dataComparer","rightIntervals","index","removeAll","raiseEvent","findIntervalContainingDate","date","indexOf","findDataForIntervalContainingDate","data","contains","julianDate","indexOfScratch","findInterval","options","EMPTY_OBJECT","len","interval","greaterThan","push","comparison","splice","removeInterval","result","intersect","other","mergeCallback","otherIntervals","leftInterval","rightInterval","lessThan","intersection","fromJulianDateArray","julianDates","dataCallback","leadingInterval","trailingInterval","startIndex","MINIMUM_VALUE","startDate","endDate","MAXIMUM_VALUE","scratchGregorianDate","monthLengths","addToDate","duration","toGregorianDate","millisecond","second","minute","hour","day","month","year","Math","floor","fromGregorianDate","scratchJulianDate","durationRegex","parseDuration","iso8601","matches","match","Number","replace","seconds","fromIso8601","scratchDuration","dates","split","clone","afterStop","fromIso8601DateArray","iso8601Dates","map","fromIso8601DurationArray","epoch","iso8601Durations","relativeToPrevious","previousDate"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 53698, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/ExtrapolationType.js"],"sourcesContent":["/**\n * Constants to determine how an interpolated value is extrapolated\n * when querying outside the bounds of available data.\n *\n * @enum {number}\n *\n * @see SampledProperty\n */\nconst ExtrapolationType = {\n  /**\n   * No extrapolation occurs.\n   *\n   * @type {number}\n   * @constant\n   */\n  NONE: 0,\n\n  /**\n   * The first or last value is used when outside the range of sample data.\n   *\n   * @type {number}\n   * @constant\n   */\n  HOLD: 1,\n\n  /**\n   * The value is extrapolated.\n   *\n   * @type {number}\n   * @constant\n   */\n  EXTRAPOLATE: 2,\n};\nexport default Object.freeze(ExtrapolationType);\n"],"names":["ExtrapolationType","NONE","HOLD","EXTRAPOLATE","Object","freeze"],"mappings":";;;;AAAA;;;;;;;CAOC,GACD,MAAMA,oBAAoB;IACxB;;;;;GAKC,GACDC,MAAM;IAEN;;;;;GAKC,GACDC,MAAM;IAEN;;;;;GAKC,GACDC,aAAa;AACf;uCACeC,OAAOC,MAAM,CAACL","ignoreList":[0]}},
    {"offset": {"line": 53734, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/LinearApproximation.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * An {@link InterpolationAlgorithm} for performing linear interpolation.\n *\n * @namespace LinearApproximation\n */\nconst LinearApproximation = {\n  type: \"Linear\",\n};\n\n/**\n * Given the desired degree, returns the number of data points required for interpolation.\n * Since linear interpolation can only generate a first degree polynomial, this function\n * always returns 2.\n * @param {number} degree The desired degree of interpolation.\n * @returns {number} This function always returns 2.\n *\n */\nLinearApproximation.getRequiredDataPoints = function (degree) {\n  return 2;\n};\n\n/**\n * Interpolates values using linear approximation.\n *\n * @param {number} x The independent variable for which the dependent variables will be interpolated.\n * @param {number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {number[]} [result] An existing array into which to store the result.\n * @returns {number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nLinearApproximation.interpolateOrderZero = function (\n  x,\n  xTable,\n  yTable,\n  yStride,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (xTable.length !== 2) {\n    throw new DeveloperError(\n      \"The xTable provided to the linear interpolator must have exactly two elements.\",\n    );\n  } else if (yStride <= 0) {\n    throw new DeveloperError(\n      \"There must be at least 1 dependent variable for each independent variable.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Array(yStride);\n  }\n\n  let i;\n  let y0;\n  let y1;\n  const x0 = xTable[0];\n  const x1 = xTable[1];\n\n  //>>includeStart('debug', pragmas.debug);\n  if (x0 === x1) {\n    throw new DeveloperError(\n      \"Divide by zero error: xTable[0] and xTable[1] are equal\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  for (i = 0; i < yStride; i++) {\n    y0 = yTable[i];\n    y1 = yTable[i + yStride];\n    result[i] = ((y1 - y0) * x + x1 * y0 - x0 * y1) / (x1 - x0);\n  }\n\n  return result;\n};\nexport default LinearApproximation;\n"],"names":["LinearApproximation","type","getRequiredDataPoints","degree","interpolateOrderZero","x","xTable","yTable","yStride","result","length","Array","i","y0","y1","x0","x1"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;CAIC,GACD,MAAMA,sBAAsB;IAC1BC,MAAM;AACR;AAEA;;;;;;;CAOC,GACDD,oBAAoBE,qBAAqB,GAAG,SAAUC,MAAM;IAC1D,OAAO;AACT;AAEA;;;;;;;;;;;;CAYC,GACDH,oBAAoBI,oBAAoB,GAAG,SACzCC,CAAC,EACDC,MAAM,EACNC,MAAM,EACNC,OAAO,EACPC,MAAM;IAEN,yCAAyC;IACzC,IAAIH,OAAOI,MAAM,KAAK,GAAG;QACvB,MAAM,IAAI,oLAAc,CACtB;IAEJ,OAAO,IAAIF,WAAW,GAAG;QACvB,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,wBAAwB;IAExB,IAAI,CAAC,IAAA,6KAAO,EAACC,SAAS;QACpBA,SAAS,IAAIE,MAAMH;IACrB;IAEA,IAAII;IACJ,IAAIC;IACJ,IAAIC;IACJ,MAAMC,KAAKT,MAAM,CAAC,EAAE;IACpB,MAAMU,KAAKV,MAAM,CAAC,EAAE;IAEpB,yCAAyC;IACzC,IAAIS,OAAOC,IAAI;QACb,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,wBAAwB;IAExB,IAAKJ,IAAI,GAAGA,IAAIJ,SAASI,IAAK;QAC5BC,KAAKN,MAAM,CAACK,EAAE;QACdE,KAAKP,MAAM,CAACK,IAAIJ,QAAQ;QACxBC,MAAM,CAACG,EAAE,GAAG,CAAC,CAACE,KAAKD,EAAE,IAAIR,IAAIW,KAAKH,KAAKE,KAAKD,EAAE,IAAI,CAACE,KAAKD,EAAE;IAC5D;IAEA,OAAON;AACT;uCACeT","ignoreList":[0]}},
    {"offset": {"line": 53804, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PolylineGeometry.js"],"sourcesContent":["import ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Color from \"./Color.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst scratchInterpolateColorsArray = [];\n\nfunction interpolateColors(p0, p1, color0, color1, numPoints) {\n  const colors = scratchInterpolateColorsArray;\n  colors.length = numPoints;\n  let i;\n\n  const r0 = color0.red;\n  const g0 = color0.green;\n  const b0 = color0.blue;\n  const a0 = color0.alpha;\n\n  const r1 = color1.red;\n  const g1 = color1.green;\n  const b1 = color1.blue;\n  const a1 = color1.alpha;\n\n  if (Color.equals(color0, color1)) {\n    for (i = 0; i < numPoints; i++) {\n      colors[i] = Color.clone(color0);\n    }\n    return colors;\n  }\n\n  const redPerVertex = (r1 - r0) / numPoints;\n  const greenPerVertex = (g1 - g0) / numPoints;\n  const bluePerVertex = (b1 - b0) / numPoints;\n  const alphaPerVertex = (a1 - a0) / numPoints;\n\n  for (i = 0; i < numPoints; i++) {\n    colors[i] = new Color(\n      r0 + i * redPerVertex,\n      g0 + i * greenPerVertex,\n      b0 + i * bluePerVertex,\n      a0 + i * alphaPerVertex,\n    );\n  }\n\n  return colors;\n}\n\n/**\n * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n * and each additional position defines a line segment from the previous position. The polyline is capable of\n * displaying with a material.\n *\n * @alias PolylineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n * @param {number} [options.width=1.0] The width in pixels.\n * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n * @param {boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n *\n * @exception {DeveloperError} At least two positions are required.\n * @exception {DeveloperError} width must be greater than or equal to one.\n * @exception {DeveloperError} colors has an invalid length.\n *\n * @see PolylineGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline.html|Cesium Sandcastle Polyline Demo}\n *\n * @example\n * // A polyline with two connected line segments\n * const polyline = new Cesium.PolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ]),\n *   width : 10.0\n * });\n * const geometry = Cesium.PolylineGeometry.createGeometry(polyline);\n */\nfunction PolylineGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const positions = options.positions;\n  const colors = options.colors;\n  const width = options.width ?? 1.0;\n  const colorsPerVertex = options.colorsPerVertex ?? false;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (typeof width !== \"number\") {\n    throw new DeveloperError(\"width must be a number\");\n  }\n  if (\n    defined(colors) &&\n    ((colorsPerVertex && colors.length < positions.length) ||\n      (!colorsPerVertex && colors.length < positions.length - 1))\n  ) {\n    throw new DeveloperError(\"colors has an invalid length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._positions = positions;\n  this._colors = colors;\n  this._width = width;\n  this._colorsPerVertex = colorsPerVertex;\n  this._vertexFormat = VertexFormat.clone(\n    options.vertexFormat ?? VertexFormat.DEFAULT,\n  );\n\n  this._arcType = options.arcType ?? ArcType.GEODESIC;\n  this._granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  this._ellipsoid = Ellipsoid.clone(options.ellipsoid ?? Ellipsoid.default);\n  this._workerName = \"createPolylineGeometry\";\n\n  let numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 4;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolylineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nPolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  let i;\n\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  const colors = value._colors;\n  length = defined(colors) ? colors.length : 0.0;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    Color.pack(colors[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  positions: undefined,\n  colors: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  width: undefined,\n  colorsPerVertex: undefined,\n  arcType: undefined,\n  granularity: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolylineGeometry} [result] The object into which to store the result.\n * @returns {PolylineGeometry} The modified result parameter or a new PolylineGeometry instance if one was not provided.\n */\nPolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  let i;\n\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  const colors = length > 0 ? new Array(length) : undefined;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    colors[i] = Color.unpack(array, startingIndex);\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const width = array[startingIndex++];\n  const colorsPerVertex = array[startingIndex++] === 1.0;\n  const arcType = array[startingIndex++];\n  const granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.colors = colors;\n    scratchOptions.width = width;\n    scratchOptions.colorsPerVertex = colorsPerVertex;\n    scratchOptions.arcType = arcType;\n    scratchOptions.granularity = granularity;\n    return new PolylineGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._colors = colors;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._width = width;\n  result._colorsPerVertex = colorsPerVertex;\n  result._arcType = arcType;\n  result._granularity = granularity;\n\n  return result;\n};\n\nconst scratchCartesian3 = new Cartesian3();\nconst scratchPosition = new Cartesian3();\nconst scratchPrevPosition = new Cartesian3();\nconst scratchNextPosition = new Cartesian3();\n\n/**\n * Computes the geometric representation of a polyline, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolylineGeometry} polylineGeometry A description of the polyline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolylineGeometry.createGeometry = function (polylineGeometry) {\n  const width = polylineGeometry._width;\n  const vertexFormat = polylineGeometry._vertexFormat;\n  let colors = polylineGeometry._colors;\n  const colorsPerVertex = polylineGeometry._colorsPerVertex;\n  const arcType = polylineGeometry._arcType;\n  const granularity = polylineGeometry._granularity;\n  const ellipsoid = polylineGeometry._ellipsoid;\n\n  let i;\n  let j;\n  let k;\n\n  const removedIndices = [];\n  let positions = arrayRemoveDuplicates(\n    polylineGeometry._positions,\n    Cartesian3.equalsEpsilon,\n    false,\n    removedIndices,\n  );\n\n  if (defined(colors) && removedIndices.length > 0) {\n    let removedArrayIndex = 0;\n    let nextRemovedIndex = removedIndices[0];\n    colors = colors.filter(function (color, index) {\n      let remove = false;\n      if (colorsPerVertex) {\n        remove =\n          index === nextRemovedIndex || (index === 0 && nextRemovedIndex === 1);\n      } else {\n        remove = index + 1 === nextRemovedIndex;\n      }\n\n      if (remove) {\n        removedArrayIndex++;\n        nextRemovedIndex = removedIndices[removedArrayIndex];\n        return false;\n      }\n      return true;\n    });\n  }\n\n  let positionsLength = positions.length;\n\n  // A width of a pixel or less is not a valid geometry, but in order to support external data\n  // that may have errors we treat this as an empty geometry.\n  if (positionsLength < 2 || width <= 0.0) {\n    return undefined;\n  }\n\n  if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\n    let subdivisionSize;\n    let numberOfPointsFunction;\n    if (arcType === ArcType.GEODESIC) {\n      subdivisionSize = CesiumMath.chordLength(\n        granularity,\n        ellipsoid.maximumRadius,\n      );\n      numberOfPointsFunction = PolylinePipeline.numberOfPoints;\n    } else {\n      subdivisionSize = granularity;\n      numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\n    }\n\n    const heights = PolylinePipeline.extractHeights(positions, ellipsoid);\n\n    if (defined(colors)) {\n      let colorLength = 1;\n      for (i = 0; i < positionsLength - 1; ++i) {\n        colorLength += numberOfPointsFunction(\n          positions[i],\n          positions[i + 1],\n          subdivisionSize,\n        );\n      }\n\n      const newColors = new Array(colorLength);\n      let newColorIndex = 0;\n\n      for (i = 0; i < positionsLength - 1; ++i) {\n        const p0 = positions[i];\n        const p1 = positions[i + 1];\n        const c0 = colors[i];\n\n        const numColors = numberOfPointsFunction(p0, p1, subdivisionSize);\n        if (colorsPerVertex && i < colorLength) {\n          const c1 = colors[i + 1];\n          const interpolatedColors = interpolateColors(\n            p0,\n            p1,\n            c0,\n            c1,\n            numColors,\n          );\n          const interpolatedColorsLength = interpolatedColors.length;\n          for (j = 0; j < interpolatedColorsLength; ++j) {\n            newColors[newColorIndex++] = interpolatedColors[j];\n          }\n        } else {\n          for (j = 0; j < numColors; ++j) {\n            newColors[newColorIndex++] = Color.clone(c0);\n          }\n        }\n      }\n\n      newColors[newColorIndex] = Color.clone(colors[colors.length - 1]);\n      colors = newColors;\n\n      scratchInterpolateColorsArray.length = 0;\n    }\n\n    if (arcType === ArcType.GEODESIC) {\n      positions = PolylinePipeline.generateCartesianArc({\n        positions: positions,\n        minDistance: subdivisionSize,\n        ellipsoid: ellipsoid,\n        height: heights,\n      });\n    } else {\n      positions = PolylinePipeline.generateCartesianRhumbArc({\n        positions: positions,\n        granularity: subdivisionSize,\n        ellipsoid: ellipsoid,\n        height: heights,\n      });\n    }\n  }\n\n  positionsLength = positions.length;\n  const size = positionsLength * 4.0 - 4.0;\n\n  const finalPositions = new Float64Array(size * 3);\n  const prevPositions = new Float64Array(size * 3);\n  const nextPositions = new Float64Array(size * 3);\n  const expandAndWidth = new Float32Array(size * 2);\n  const st = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n  const finalColors = defined(colors) ? new Uint8Array(size * 4) : undefined;\n\n  let positionIndex = 0;\n  let expandAndWidthIndex = 0;\n  let stIndex = 0;\n  let colorIndex = 0;\n  let position;\n\n  for (j = 0; j < positionsLength; ++j) {\n    if (j === 0) {\n      position = scratchCartesian3;\n      Cartesian3.subtract(positions[0], positions[1], position);\n      Cartesian3.add(positions[0], position, position);\n    } else {\n      position = positions[j - 1];\n    }\n\n    Cartesian3.clone(position, scratchPrevPosition);\n    Cartesian3.clone(positions[j], scratchPosition);\n\n    if (j === positionsLength - 1) {\n      position = scratchCartesian3;\n      Cartesian3.subtract(\n        positions[positionsLength - 1],\n        positions[positionsLength - 2],\n        position,\n      );\n      Cartesian3.add(positions[positionsLength - 1], position, position);\n    } else {\n      position = positions[j + 1];\n    }\n\n    Cartesian3.clone(position, scratchNextPosition);\n\n    let color0, color1;\n    if (defined(finalColors)) {\n      if (j !== 0 && !colorsPerVertex) {\n        color0 = colors[j - 1];\n      } else {\n        color0 = colors[j];\n      }\n\n      if (j !== positionsLength - 1) {\n        color1 = colors[j];\n      }\n    }\n\n    const startK = j === 0 ? 2 : 0;\n    const endK = j === positionsLength - 1 ? 2 : 4;\n\n    for (k = startK; k < endK; ++k) {\n      Cartesian3.pack(scratchPosition, finalPositions, positionIndex);\n      Cartesian3.pack(scratchPrevPosition, prevPositions, positionIndex);\n      Cartesian3.pack(scratchNextPosition, nextPositions, positionIndex);\n      positionIndex += 3;\n\n      const direction = k - 2 < 0 ? -1.0 : 1.0;\n      expandAndWidth[expandAndWidthIndex++] = 2 * (k % 2) - 1; // expand direction\n      expandAndWidth[expandAndWidthIndex++] = direction * width;\n\n      if (vertexFormat.st) {\n        st[stIndex++] = j / (positionsLength - 1);\n        st[stIndex++] = Math.max(expandAndWidth[expandAndWidthIndex - 2], 0.0);\n      }\n\n      if (defined(finalColors)) {\n        const color = k < 2 ? color0 : color1;\n\n        finalColors[colorIndex++] = Color.floatToByte(color.red);\n        finalColors[colorIndex++] = Color.floatToByte(color.green);\n        finalColors[colorIndex++] = Color.floatToByte(color.blue);\n        finalColors[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions,\n  });\n\n  attributes.prevPosition = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: prevPositions,\n  });\n\n  attributes.nextPosition = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: nextPositions,\n  });\n\n  attributes.expandAndWidth = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 2,\n    values: expandAndWidth,\n  });\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st,\n    });\n  }\n\n  if (defined(finalColors)) {\n    attributes.color = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 4,\n      values: finalColors,\n      normalize: true,\n    });\n  }\n\n  const indices = IndexDatatype.createTypedArray(size, positionsLength * 6 - 6);\n  let index = 0;\n  let indicesIndex = 0;\n  const length = positionsLength - 1.0;\n  for (j = 0; j < length; ++j) {\n    indices[indicesIndex++] = index;\n    indices[indicesIndex++] = index + 2;\n    indices[indicesIndex++] = index + 1;\n\n    indices[indicesIndex++] = index + 1;\n    indices[indicesIndex++] = index + 2;\n    indices[indicesIndex++] = index + 3;\n\n    index += 4;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromPoints(positions),\n    geometryType: GeometryType.POLYLINES,\n  });\n};\nexport default PolylineGeometry;\n"],"names":["scratchInterpolateColorsArray","interpolateColors","p0","p1","color0","color1","numPoints","colors","length","i","r0","red","g0","green","b0","blue","a0","alpha","r1","g1","b1","a1","equals","clone","redPerVertex","greenPerVertex","bluePerVertex","alphaPerVertex","PolylineGeometry","options","EMPTY_OBJECT","positions","width","colorsPerVertex","_positions","_colors","_width","_colorsPerVertex","_vertexFormat","vertexFormat","DEFAULT","_arcType","arcType","GEODESIC","_granularity","granularity","RADIANS_PER_DEGREE","_ellipsoid","ellipsoid","default","_workerName","numComponents","packedLength","pack","value","array","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","undefined","unpack","result","Array","scratchCartesian3","scratchPosition","scratchPrevPosition","scratchNextPosition","createGeometry","polylineGeometry","j","k","removedIndices","equalsEpsilon","removedArrayIndex","nextRemovedIndex","filter","color","index","remove","positionsLength","RHUMB","subdivisionSize","numberOfPointsFunction","chordLength","maximumRadius","numberOfPoints","numberOfPointsRhumbLine","heights","extractHeights","colorLength","newColors","newColorIndex","c0","numColors","c1","interpolatedColors","interpolatedColorsLength","generateCartesianArc","minDistance","height","generateCartesianRhumbArc","size","finalPositions","Float64Array","prevPositions","nextPositions","expandAndWidth","Float32Array","st","finalColors","Uint8Array","positionIndex","expandAndWidthIndex","stIndex","colorIndex","position","subtract","add","startK","endK","direction","Math","max","floatToByte","attributes","componentDatatype","DOUBLE","componentsPerAttribute","values","prevPosition","nextPosition","FLOAT","UNSIGNED_BYTE","normalize","indices","createTypedArray","indicesIndex","primitiveType","TRIANGLES","boundingSphere","fromPoints","geometryType","POLYLINES"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AAEA,MAAMA,gCAAgC,EAAE;AAExC,SAASC,kBAAkBC,EAAE,EAAEC,EAAE,EAAEC,MAAM,EAAEC,MAAM,EAAEC,SAAS;IAC1D,MAAMC,SAASP;IACfO,OAAOC,MAAM,GAAGF;IAChB,IAAIG;IAEJ,MAAMC,KAAKN,OAAOO,GAAG;IACrB,MAAMC,KAAKR,OAAOS,KAAK;IACvB,MAAMC,KAAKV,OAAOW,IAAI;IACtB,MAAMC,KAAKZ,OAAOa,KAAK;IAEvB,MAAMC,KAAKb,OAAOM,GAAG;IACrB,MAAMQ,KAAKd,OAAOQ,KAAK;IACvB,MAAMO,KAAKf,OAAOU,IAAI;IACtB,MAAMM,KAAKhB,OAAOY,KAAK;IAEvB,IAAI,2KAAK,CAACK,MAAM,CAAClB,QAAQC,SAAS;QAChC,IAAKI,IAAI,GAAGA,IAAIH,WAAWG,IAAK;YAC9BF,MAAM,CAACE,EAAE,GAAG,2KAAK,CAACc,KAAK,CAACnB;QAC1B;QACA,OAAOG;IACT;IAEA,MAAMiB,eAAe,CAACN,KAAKR,EAAE,IAAIJ;IACjC,MAAMmB,iBAAiB,CAACN,KAAKP,EAAE,IAAIN;IACnC,MAAMoB,gBAAgB,CAACN,KAAKN,EAAE,IAAIR;IAClC,MAAMqB,iBAAiB,CAACN,KAAKL,EAAE,IAAIV;IAEnC,IAAKG,IAAI,GAAGA,IAAIH,WAAWG,IAAK;QAC9BF,MAAM,CAACE,EAAE,GAAG,IAAI,2KAAK,CACnBC,KAAKD,IAAIe,cACTZ,KAAKH,IAAIgB,gBACTX,KAAKL,IAAIiB,eACTV,KAAKP,IAAIkB;IAEb;IAEA,OAAOpB;AACT;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqCC,GACD,SAASqB,iBAAiBC,OAAO;IAC/BA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IACxC,MAAMC,YAAYF,QAAQE,SAAS;IACnC,MAAMxB,SAASsB,QAAQtB,MAAM;IAC7B,MAAMyB,QAAQH,QAAQG,KAAK,IAAI;IAC/B,MAAMC,kBAAkBJ,QAAQI,eAAe,IAAI;IAEnD,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACF,cAAcA,UAAUvB,MAAM,GAAG,GAAG;QAC/C,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,OAAOwB,UAAU,UAAU;QAC7B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IACE,IAAA,6KAAO,EAACzB,WACR,CAAC,AAAC0B,mBAAmB1B,OAAOC,MAAM,GAAGuB,UAAUvB,MAAM,IAClD,CAACyB,mBAAmB1B,OAAOC,MAAM,GAAGuB,UAAUvB,MAAM,GAAG,CAAE,GAC5D;QACA,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,IAAI,CAAC0B,UAAU,GAAGH;IAClB,IAAI,CAACI,OAAO,GAAG5B;IACf,IAAI,CAAC6B,MAAM,GAAGJ;IACd,IAAI,CAACK,gBAAgB,GAAGJ;IACxB,IAAI,CAACK,aAAa,GAAG,kLAAY,CAACf,KAAK,CACrCM,QAAQU,YAAY,IAAI,kLAAY,CAACC,OAAO;IAG9C,IAAI,CAACC,QAAQ,GAAGZ,QAAQa,OAAO,IAAI,6KAAO,CAACC,QAAQ;IACnD,IAAI,CAACC,YAAY,GAAGf,QAAQgB,WAAW,IAAI,0KAAU,CAACC,kBAAkB;IACxE,IAAI,CAACC,UAAU,GAAG,+KAAS,CAACxB,KAAK,CAACM,QAAQmB,SAAS,IAAI,+KAAS,CAACC,OAAO;IACxE,IAAI,CAACC,WAAW,GAAG;IAEnB,IAAIC,gBAAgB,IAAIpB,UAAUvB,MAAM,GAAG,gLAAU,CAAC4C,YAAY;IAClED,iBAAiB,IAAA,6KAAO,EAAC5C,UAAU,IAAIA,OAAOC,MAAM,GAAG,2KAAK,CAAC4C,YAAY,GAAG;IAE5E;;;GAGC,GACD,IAAI,CAACA,YAAY,GACfD,gBAAgB,+KAAS,CAACC,YAAY,GAAG,kLAAY,CAACA,YAAY,GAAG;AACzE;AAEA;;;;;;;;CAQC,GACDxB,iBAAiByB,IAAI,GAAG,SAAUC,KAAK,EAAEC,KAAK,EAAEC,aAAa;IAC3D,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACF,QAAQ;QACnB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACC,QAAQ;QACnB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjC,IAAI/C;IAEJ,MAAMsB,YAAYuB,MAAMpB,UAAU;IAClC,IAAI1B,SAASuB,UAAUvB,MAAM;IAC7B+C,KAAK,CAACC,gBAAgB,GAAGhD;IAEzB,IAAKC,IAAI,GAAGA,IAAID,QAAQ,EAAEC,GAAG+C,iBAAiB,gLAAU,CAACJ,YAAY,CAAE;QACrE,gLAAU,CAACC,IAAI,CAACtB,SAAS,CAACtB,EAAE,EAAE8C,OAAOC;IACvC;IAEA,MAAMjD,SAAS+C,MAAMnB,OAAO;IAC5B3B,SAAS,IAAA,6KAAO,EAACD,UAAUA,OAAOC,MAAM,GAAG;IAC3C+C,KAAK,CAACC,gBAAgB,GAAGhD;IAEzB,IAAKC,IAAI,GAAGA,IAAID,QAAQ,EAAEC,GAAG+C,iBAAiB,2KAAK,CAACJ,YAAY,CAAE;QAChE,2KAAK,CAACC,IAAI,CAAC9C,MAAM,CAACE,EAAE,EAAE8C,OAAOC;IAC/B;IAEA,+KAAS,CAACH,IAAI,CAACC,MAAMP,UAAU,EAAEQ,OAAOC;IACxCA,iBAAiB,+KAAS,CAACJ,YAAY;IAEvC,kLAAY,CAACC,IAAI,CAACC,MAAMhB,aAAa,EAAEiB,OAAOC;IAC9CA,iBAAiB,kLAAY,CAACJ,YAAY;IAE1CG,KAAK,CAACC,gBAAgB,GAAGF,MAAMlB,MAAM;IACrCmB,KAAK,CAACC,gBAAgB,GAAGF,MAAMjB,gBAAgB,GAAG,MAAM;IACxDkB,KAAK,CAACC,gBAAgB,GAAGF,MAAMb,QAAQ;IACvCc,KAAK,CAACC,cAAc,GAAGF,MAAMV,YAAY;IAEzC,OAAOW;AACT;AAEA,MAAME,mBAAmB,+KAAS,CAAClC,KAAK,CAAC,+KAAS,CAACmC,WAAW;AAC9D,MAAMC,sBAAsB,IAAI,kLAAY;AAC5C,MAAMC,iBAAiB;IACrB7B,WAAW8B;IACXtD,QAAQsD;IACRb,WAAWS;IACXlB,cAAcoB;IACd3B,OAAO6B;IACP5B,iBAAiB4B;IACjBnB,SAASmB;IACThB,aAAagB;AACf;AAEA;;;;;;;CAOC,GACDjC,iBAAiBkC,MAAM,GAAG,SAAUP,KAAK,EAAEC,aAAa,EAAEO,MAAM;IAC9D,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACR,QAAQ;QACnB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjC,IAAI/C;IAEJ,IAAID,SAAS+C,KAAK,CAACC,gBAAgB;IACnC,MAAMzB,YAAY,IAAIiC,MAAMxD;IAE5B,IAAKC,IAAI,GAAGA,IAAID,QAAQ,EAAEC,GAAG+C,iBAAiB,gLAAU,CAACJ,YAAY,CAAE;QACrErB,SAAS,CAACtB,EAAE,GAAG,gLAAU,CAACqD,MAAM,CAACP,OAAOC;IAC1C;IAEAhD,SAAS+C,KAAK,CAACC,gBAAgB;IAC/B,MAAMjD,SAASC,SAAS,IAAI,IAAIwD,MAAMxD,UAAUqD;IAEhD,IAAKpD,IAAI,GAAGA,IAAID,QAAQ,EAAEC,GAAG+C,iBAAiB,2KAAK,CAACJ,YAAY,CAAE;QAChE7C,MAAM,CAACE,EAAE,GAAG,2KAAK,CAACqD,MAAM,CAACP,OAAOC;IAClC;IAEA,MAAMR,YAAY,+KAAS,CAACc,MAAM,CAACP,OAAOC,eAAeC;IACzDD,iBAAiB,+KAAS,CAACJ,YAAY;IAEvC,MAAMb,eAAe,kLAAY,CAACuB,MAAM,CACtCP,OACAC,eACAG;IAEFH,iBAAiB,kLAAY,CAACJ,YAAY;IAE1C,MAAMpB,QAAQuB,KAAK,CAACC,gBAAgB;IACpC,MAAMvB,kBAAkBsB,KAAK,CAACC,gBAAgB,KAAK;IACnD,MAAMd,UAAUa,KAAK,CAACC,gBAAgB;IACtC,MAAMX,cAAcU,KAAK,CAACC,cAAc;IAExC,IAAI,CAAC,IAAA,6KAAO,EAACO,SAAS;QACpBH,eAAe7B,SAAS,GAAGA;QAC3B6B,eAAerD,MAAM,GAAGA;QACxBqD,eAAe5B,KAAK,GAAGA;QACvB4B,eAAe3B,eAAe,GAAGA;QACjC2B,eAAelB,OAAO,GAAGA;QACzBkB,eAAef,WAAW,GAAGA;QAC7B,OAAO,IAAIjB,iBAAiBgC;IAC9B;IAEAG,OAAO7B,UAAU,GAAGH;IACpBgC,OAAO5B,OAAO,GAAG5B;IACjBwD,OAAOhB,UAAU,GAAG,+KAAS,CAACxB,KAAK,CAACyB,WAAWe,OAAOhB,UAAU;IAChEgB,OAAOzB,aAAa,GAAG,kLAAY,CAACf,KAAK,CAACgB,cAAcwB,OAAOzB,aAAa;IAC5EyB,OAAO3B,MAAM,GAAGJ;IAChB+B,OAAO1B,gBAAgB,GAAGJ;IAC1B8B,OAAOtB,QAAQ,GAAGC;IAClBqB,OAAOnB,YAAY,GAAGC;IAEtB,OAAOkB;AACT;AAEA,MAAME,oBAAoB,IAAI,gLAAU;AACxC,MAAMC,kBAAkB,IAAI,gLAAU;AACtC,MAAMC,sBAAsB,IAAI,gLAAU;AAC1C,MAAMC,sBAAsB,IAAI,gLAAU;AAE1C;;;;;CAKC,GACDxC,iBAAiByC,cAAc,GAAG,SAAUC,gBAAgB;IAC1D,MAAMtC,QAAQsC,iBAAiBlC,MAAM;IACrC,MAAMG,eAAe+B,iBAAiBhC,aAAa;IACnD,IAAI/B,SAAS+D,iBAAiBnC,OAAO;IACrC,MAAMF,kBAAkBqC,iBAAiBjC,gBAAgB;IACzD,MAAMK,UAAU4B,iBAAiB7B,QAAQ;IACzC,MAAMI,cAAcyB,iBAAiB1B,YAAY;IACjD,MAAMI,YAAYsB,iBAAiBvB,UAAU;IAE7C,IAAItC;IACJ,IAAI8D;IACJ,IAAIC;IAEJ,MAAMC,iBAAiB,EAAE;IACzB,IAAI1C,YAAY,IAAA,2LAAqB,EACnCuC,iBAAiBpC,UAAU,EAC3B,gLAAU,CAACwC,aAAa,EACxB,OACAD;IAGF,IAAI,IAAA,6KAAO,EAAClE,WAAWkE,eAAejE,MAAM,GAAG,GAAG;QAChD,IAAImE,oBAAoB;QACxB,IAAIC,mBAAmBH,cAAc,CAAC,EAAE;QACxClE,SAASA,OAAOsE,MAAM,CAAC,SAAUC,KAAK,EAAEC,KAAK;YAC3C,IAAIC,SAAS;YACb,IAAI/C,iBAAiB;gBACnB+C,SACED,UAAUH,oBAAqBG,UAAU,KAAKH,qBAAqB;YACvE,OAAO;gBACLI,SAASD,QAAQ,MAAMH;YACzB;YAEA,IAAII,QAAQ;gBACVL;gBACAC,mBAAmBH,cAAc,CAACE,kBAAkB;gBACpD,OAAO;YACT;YACA,OAAO;QACT;IACF;IAEA,IAAIM,kBAAkBlD,UAAUvB,MAAM;IAEtC,4FAA4F;IAC5F,2DAA2D;IAC3D,IAAIyE,kBAAkB,KAAKjD,SAAS,KAAK;QACvC,OAAO6B;IACT;IAEA,IAAInB,YAAY,6KAAO,CAACC,QAAQ,IAAID,YAAY,6KAAO,CAACwC,KAAK,EAAE;QAC7D,IAAIC;QACJ,IAAIC;QACJ,IAAI1C,YAAY,6KAAO,CAACC,QAAQ,EAAE;YAChCwC,kBAAkB,0KAAU,CAACE,WAAW,CACtCxC,aACAG,UAAUsC,aAAa;YAEzBF,yBAAyB,sLAAgB,CAACG,cAAc;QAC1D,OAAO;YACLJ,kBAAkBtC;YAClBuC,yBAAyB,sLAAgB,CAACI,uBAAuB;QACnE;QAEA,MAAMC,UAAU,sLAAgB,CAACC,cAAc,CAAC3D,WAAWiB;QAE3D,IAAI,IAAA,6KAAO,EAACzC,SAAS;YACnB,IAAIoF,cAAc;YAClB,IAAKlF,IAAI,GAAGA,IAAIwE,kBAAkB,GAAG,EAAExE,EAAG;gBACxCkF,eAAeP,uBACbrD,SAAS,CAACtB,EAAE,EACZsB,SAAS,CAACtB,IAAI,EAAE,EAChB0E;YAEJ;YAEA,MAAMS,YAAY,IAAI5B,MAAM2B;YAC5B,IAAIE,gBAAgB;YAEpB,IAAKpF,IAAI,GAAGA,IAAIwE,kBAAkB,GAAG,EAAExE,EAAG;gBACxC,MAAMP,KAAK6B,SAAS,CAACtB,EAAE;gBACvB,MAAMN,KAAK4B,SAAS,CAACtB,IAAI,EAAE;gBAC3B,MAAMqF,KAAKvF,MAAM,CAACE,EAAE;gBAEpB,MAAMsF,YAAYX,uBAAuBlF,IAAIC,IAAIgF;gBACjD,IAAIlD,mBAAmBxB,IAAIkF,aAAa;oBACtC,MAAMK,KAAKzF,MAAM,CAACE,IAAI,EAAE;oBACxB,MAAMwF,qBAAqBhG,kBACzBC,IACAC,IACA2F,IACAE,IACAD;oBAEF,MAAMG,2BAA2BD,mBAAmBzF,MAAM;oBAC1D,IAAK+D,IAAI,GAAGA,IAAI2B,0BAA0B,EAAE3B,EAAG;wBAC7CqB,SAAS,CAACC,gBAAgB,GAAGI,kBAAkB,CAAC1B,EAAE;oBACpD;gBACF,OAAO;oBACL,IAAKA,IAAI,GAAGA,IAAIwB,WAAW,EAAExB,EAAG;wBAC9BqB,SAAS,CAACC,gBAAgB,GAAG,2KAAK,CAACtE,KAAK,CAACuE;oBAC3C;gBACF;YACF;YAEAF,SAAS,CAACC,cAAc,GAAG,2KAAK,CAACtE,KAAK,CAAChB,MAAM,CAACA,OAAOC,MAAM,GAAG,EAAE;YAChED,SAASqF;YAET5F,8BAA8BQ,MAAM,GAAG;QACzC;QAEA,IAAIkC,YAAY,6KAAO,CAACC,QAAQ,EAAE;YAChCZ,YAAY,sLAAgB,CAACoE,oBAAoB,CAAC;gBAChDpE,WAAWA;gBACXqE,aAAajB;gBACbnC,WAAWA;gBACXqD,QAAQZ;YACV;QACF,OAAO;YACL1D,YAAY,sLAAgB,CAACuE,yBAAyB,CAAC;gBACrDvE,WAAWA;gBACXc,aAAasC;gBACbnC,WAAWA;gBACXqD,QAAQZ;YACV;QACF;IACF;IAEAR,kBAAkBlD,UAAUvB,MAAM;IAClC,MAAM+F,OAAOtB,kBAAkB,MAAM;IAErC,MAAMuB,iBAAiB,IAAIC,aAAaF,OAAO;IAC/C,MAAMG,gBAAgB,IAAID,aAAaF,OAAO;IAC9C,MAAMI,gBAAgB,IAAIF,aAAaF,OAAO;IAC9C,MAAMK,iBAAiB,IAAIC,aAAaN,OAAO;IAC/C,MAAMO,KAAKvE,aAAauE,EAAE,GAAG,IAAID,aAAaN,OAAO,KAAK1C;IAC1D,MAAMkD,cAAc,IAAA,6KAAO,EAACxG,UAAU,IAAIyG,WAAWT,OAAO,KAAK1C;IAEjE,IAAIoD,gBAAgB;IACpB,IAAIC,sBAAsB;IAC1B,IAAIC,UAAU;IACd,IAAIC,aAAa;IACjB,IAAIC;IAEJ,IAAK9C,IAAI,GAAGA,IAAIU,iBAAiB,EAAEV,EAAG;QACpC,IAAIA,MAAM,GAAG;YACX8C,WAAWpD;YACX,gLAAU,CAACqD,QAAQ,CAACvF,SAAS,CAAC,EAAE,EAAEA,SAAS,CAAC,EAAE,EAAEsF;YAChD,gLAAU,CAACE,GAAG,CAACxF,SAAS,CAAC,EAAE,EAAEsF,UAAUA;QACzC,OAAO;YACLA,WAAWtF,SAAS,CAACwC,IAAI,EAAE;QAC7B;QAEA,gLAAU,CAAChD,KAAK,CAAC8F,UAAUlD;QAC3B,gLAAU,CAAC5C,KAAK,CAACQ,SAAS,CAACwC,EAAE,EAAEL;QAE/B,IAAIK,MAAMU,kBAAkB,GAAG;YAC7BoC,WAAWpD;YACX,gLAAU,CAACqD,QAAQ,CACjBvF,SAAS,CAACkD,kBAAkB,EAAE,EAC9BlD,SAAS,CAACkD,kBAAkB,EAAE,EAC9BoC;YAEF,gLAAU,CAACE,GAAG,CAACxF,SAAS,CAACkD,kBAAkB,EAAE,EAAEoC,UAAUA;QAC3D,OAAO;YACLA,WAAWtF,SAAS,CAACwC,IAAI,EAAE;QAC7B;QAEA,gLAAU,CAAChD,KAAK,CAAC8F,UAAUjD;QAE3B,IAAIhE,QAAQC;QACZ,IAAI,IAAA,6KAAO,EAAC0G,cAAc;YACxB,IAAIxC,MAAM,KAAK,CAACtC,iBAAiB;gBAC/B7B,SAASG,MAAM,CAACgE,IAAI,EAAE;YACxB,OAAO;gBACLnE,SAASG,MAAM,CAACgE,EAAE;YACpB;YAEA,IAAIA,MAAMU,kBAAkB,GAAG;gBAC7B5E,SAASE,MAAM,CAACgE,EAAE;YACpB;QACF;QAEA,MAAMiD,SAASjD,MAAM,IAAI,IAAI;QAC7B,MAAMkD,OAAOlD,MAAMU,kBAAkB,IAAI,IAAI;QAE7C,IAAKT,IAAIgD,QAAQhD,IAAIiD,MAAM,EAAEjD,EAAG;YAC9B,gLAAU,CAACnB,IAAI,CAACa,iBAAiBsC,gBAAgBS;YACjD,gLAAU,CAAC5D,IAAI,CAACc,qBAAqBuC,eAAeO;YACpD,gLAAU,CAAC5D,IAAI,CAACe,qBAAqBuC,eAAeM;YACpDA,iBAAiB;YAEjB,MAAMS,YAAYlD,IAAI,IAAI,IAAI,CAAC,MAAM;YACrCoC,cAAc,CAACM,sBAAsB,GAAG,IAAI,CAAC1C,IAAI,CAAC,IAAI,GAAG,mBAAmB;YAC5EoC,cAAc,CAACM,sBAAsB,GAAGQ,YAAY1F;YAEpD,IAAIO,aAAauE,EAAE,EAAE;gBACnBA,EAAE,CAACK,UAAU,GAAG5C,IAAI,CAACU,kBAAkB,CAAC;gBACxC6B,EAAE,CAACK,UAAU,GAAGQ,KAAKC,GAAG,CAAChB,cAAc,CAACM,sBAAsB,EAAE,EAAE;YACpE;YAEA,IAAI,IAAA,6KAAO,EAACH,cAAc;gBACxB,MAAMjC,QAAQN,IAAI,IAAIpE,SAASC;gBAE/B0G,WAAW,CAACK,aAAa,GAAG,2KAAK,CAACS,WAAW,CAAC/C,MAAMnE,GAAG;gBACvDoG,WAAW,CAACK,aAAa,GAAG,2KAAK,CAACS,WAAW,CAAC/C,MAAMjE,KAAK;gBACzDkG,WAAW,CAACK,aAAa,GAAG,2KAAK,CAACS,WAAW,CAAC/C,MAAM/D,IAAI;gBACxDgG,WAAW,CAACK,aAAa,GAAG,2KAAK,CAACS,WAAW,CAAC/C,MAAM7D,KAAK;YAC3D;QACF;IACF;IAEA,MAAM6G,aAAa,IAAI,wLAAkB;IAEzCA,WAAWT,QAAQ,GAAG,IAAI,uLAAiB,CAAC;QAC1CU,mBAAmB,uLAAiB,CAACC,MAAM;QAC3CC,wBAAwB;QACxBC,QAAQ1B;IACV;IAEAsB,WAAWK,YAAY,GAAG,IAAI,uLAAiB,CAAC;QAC9CJ,mBAAmB,uLAAiB,CAACC,MAAM;QAC3CC,wBAAwB;QACxBC,QAAQxB;IACV;IAEAoB,WAAWM,YAAY,GAAG,IAAI,uLAAiB,CAAC;QAC9CL,mBAAmB,uLAAiB,CAACC,MAAM;QAC3CC,wBAAwB;QACxBC,QAAQvB;IACV;IAEAmB,WAAWlB,cAAc,GAAG,IAAI,uLAAiB,CAAC;QAChDmB,mBAAmB,uLAAiB,CAACM,KAAK;QAC1CJ,wBAAwB;QACxBC,QAAQtB;IACV;IAEA,IAAIrE,aAAauE,EAAE,EAAE;QACnBgB,WAAWhB,EAAE,GAAG,IAAI,uLAAiB,CAAC;YACpCiB,mBAAmB,uLAAiB,CAACM,KAAK;YAC1CJ,wBAAwB;YACxBC,QAAQpB;QACV;IACF;IAEA,IAAI,IAAA,6KAAO,EAACC,cAAc;QACxBe,WAAWhD,KAAK,GAAG,IAAI,uLAAiB,CAAC;YACvCiD,mBAAmB,uLAAiB,CAACO,aAAa;YAClDL,wBAAwB;YACxBC,QAAQnB;YACRwB,WAAW;QACb;IACF;IAEA,MAAMC,UAAU,mLAAa,CAACC,gBAAgB,CAAClC,MAAMtB,kBAAkB,IAAI;IAC3E,IAAIF,QAAQ;IACZ,IAAI2D,eAAe;IACnB,MAAMlI,SAASyE,kBAAkB;IACjC,IAAKV,IAAI,GAAGA,IAAI/D,QAAQ,EAAE+D,EAAG;QAC3BiE,OAAO,CAACE,eAAe,GAAG3D;QAC1ByD,OAAO,CAACE,eAAe,GAAG3D,QAAQ;QAClCyD,OAAO,CAACE,eAAe,GAAG3D,QAAQ;QAElCyD,OAAO,CAACE,eAAe,GAAG3D,QAAQ;QAClCyD,OAAO,CAACE,eAAe,GAAG3D,QAAQ;QAClCyD,OAAO,CAACE,eAAe,GAAG3D,QAAQ;QAElCA,SAAS;IACX;IAEA,OAAO,IAAI,8KAAQ,CAAC;QAClB+C,YAAYA;QACZU,SAASA;QACTG,eAAe,mLAAa,CAACC,SAAS;QACtCC,gBAAgB,oLAAc,CAACC,UAAU,CAAC/G;QAC1CgH,cAAc,kLAAY,CAACC,SAAS;IACtC;AACF;uCACepH","ignoreList":[0]}},
    {"offset": {"line": 54278, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/sampleTerrain.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Initiates a terrain height query for an array of {@link Cartographic} positions by\n * requesting tiles from a terrain provider, sampling, and interpolating.  The interpolation\n * matches the triangles used to render the terrain at the specified level.  The query\n * happens asynchronously, so this function returns a promise that is resolved when\n * the query completes.  Each point height is modified in place.  If a height can not be\n * determined because no terrain data is available for the specified level at that location,\n * or another error occurs, the height is set to undefined.  As is typical of the\n * {@link Cartographic} type, the supplied height is a height above the reference ellipsoid\n * (such as {@link Ellipsoid.WGS84}) rather than an altitude above mean sea level.  In other\n * words, it will not necessarily be 0.0 if sampled in the ocean. This function needs the\n * terrain level of detail as input, if you need to get the altitude of the terrain as precisely\n * as possible (i.e. with maximum level of detail) use {@link sampleTerrainMostDetailed}.\n *\n * @function sampleTerrain\n *\n * @param {TerrainProvider} terrainProvider The terrain provider from which to query heights.\n * @param {number} level The terrain level-of-detail from which to query terrain heights.\n * @param {Cartographic[]} positions The positions to update with terrain heights.\n * @param {boolean} [rejectOnTileFail=false] If true, for any failed terrain tile requests, the promise will be rejected. If false, returned heights will be undefined.\n * @returns {Promise<Cartographic[]>} A promise that resolves to the provided list of positions when terrain the query has completed.\n *\n * @see sampleTerrainMostDetailed\n *\n * @example\n * // Query the terrain height of two Cartographic positions\n * const terrainProvider = await Cesium.createWorldTerrainAsync();\n * const positions = [\n *     Cesium.Cartographic.fromDegrees(86.925145, 27.988257),\n *     Cesium.Cartographic.fromDegrees(87.0, 28.0)\n * ];\n * const updatedPositions = await Cesium.sampleTerrain(terrainProvider, 11, positions);\n * // positions[0].height and positions[1].height have been updated.\n * // updatedPositions is just a reference to positions.\n *\n * // To handle tile errors, pass true for the rejectOnTileFail parameter.\n * try {\n *    const updatedPositions = await Cesium.sampleTerrain(terrainProvider, 11, positions, true);\n * } catch (error) {\n *   // A tile request error occurred.\n * }\n */\nasync function sampleTerrain(\n  terrainProvider,\n  level,\n  positions,\n  rejectOnTileFail,\n) {\n  if (!defined(rejectOnTileFail)) {\n    rejectOnTileFail = false;\n  }\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"terrainProvider\", terrainProvider);\n  Check.typeOf.number(\"level\", level);\n  Check.typeOf.bool(\"rejectOnTileFail\", rejectOnTileFail);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  return doSampling(terrainProvider, level, positions, rejectOnTileFail);\n}\n\n/**\n * @param {object[]} tileRequests The mutated list of requests, the first one will be attempted\n * @param {Array<Promise<void>>} results The list to put the result promises into\n * @param {boolean} rejectOnTileFail If true, the promise will be rejected.  If false, returned heights will be undefined.\n * @returns {boolean} true if the request was made, and we are okay to attempt the next item immediately,\n *  or false if we were throttled and should wait awhile before retrying.\n *\n * @private\n */\nfunction attemptConsumeNextQueueItem(tileRequests, results, rejectOnTileFail) {\n  const tileRequest = tileRequests[0];\n  const requestPromise = tileRequest.terrainProvider.requestTileGeometry(\n    tileRequest.x,\n    tileRequest.y,\n    tileRequest.level,\n  );\n\n  if (!requestPromise) {\n    // getting back undefined instead of a promise indicates we should retry a bit later\n    return false;\n  }\n\n  let promise;\n\n  if (rejectOnTileFail) {\n    promise = requestPromise.then(createInterpolateFunction(tileRequest));\n  } else {\n    promise = requestPromise\n      .then(createInterpolateFunction(tileRequest))\n      .catch(createMarkFailedFunction(tileRequest));\n  }\n\n  // remove the request we've just done from the queue\n  //  and add its promise result to the result list\n  tileRequests.shift();\n  results.push(promise);\n\n  // indicate we should synchronously attempt the next request as well\n  return true;\n}\n\n/**\n * Wrap window.setTimeout in a Promise\n * @param {number} ms\n * @private\n */\nfunction delay(ms) {\n  return new Promise(function (res) {\n    setTimeout(res, ms);\n  });\n}\n\n/**\n * Recursively consumes all the tileRequests until the list has been emptied\n *  and a Promise of each result has been put into the results list\n * @param {object[]} tileRequests The list of requests desired to be made\n * @param {Array<Promise<void>>} results The list to put all the result promises into\n * @param {boolean} rejectOnTileFail If true, the promise will be rejected.  If false, returned heights will be undefined.\n * @returns {Promise<void>} A promise which resolves once all requests have been started\n *\n * @private\n */\nfunction drainTileRequestQueue(tileRequests, results, rejectOnTileFail) {\n  // nothing left to do\n  if (!tileRequests.length) {\n    return Promise.resolve();\n  }\n\n  // consume an item from the queue, which will\n  //  mutate the request and result lists, and return true if we should\n  //  immediately attempt to consume the next item as well\n  const success = attemptConsumeNextQueueItem(\n    tileRequests,\n    results,\n    rejectOnTileFail,\n  );\n  if (success) {\n    return drainTileRequestQueue(tileRequests, results, rejectOnTileFail);\n  }\n\n  // wait a small fixed amount of time first, before retrying the same request again\n  return delay(100).then(() => {\n    return drainTileRequestQueue(tileRequests, results, rejectOnTileFail);\n  });\n}\n\nfunction doSampling(terrainProvider, level, positions, rejectOnTileFail) {\n  const tilingScheme = terrainProvider.tilingScheme;\n\n  let i;\n\n  // Sort points into a set of tiles\n  const tileRequests = []; // Result will be an Array as it's easier to work with\n  const tileRequestSet = {}; // A unique set\n  for (i = 0; i < positions.length; ++i) {\n    const xy = tilingScheme.positionToTileXY(positions[i], level);\n    if (!defined(xy)) {\n      continue;\n    }\n\n    const key = xy.toString();\n\n    if (!tileRequestSet.hasOwnProperty(key)) {\n      // When tile is requested for the first time\n      const value = {\n        x: xy.x,\n        y: xy.y,\n        level: level,\n        tilingScheme: tilingScheme,\n        terrainProvider: terrainProvider,\n        positions: [],\n      };\n      tileRequestSet[key] = value;\n      tileRequests.push(value);\n    }\n\n    // Now append to array of points for the tile\n    tileRequestSet[key].positions.push(positions[i]);\n  }\n\n  // create our list of result promises to be filled\n  const tilePromises = [];\n  return drainTileRequestQueue(\n    tileRequests,\n    tilePromises,\n    rejectOnTileFail,\n  ).then(function () {\n    // now all the required requests have been started\n    //  we just wait for them all to finish\n    return Promise.all(tilePromises).then(function () {\n      return positions;\n    });\n  });\n}\n\n/**\n * Calls {@link TerrainData#interpolateHeight} on a given {@link TerrainData} for a given {@link Cartographic} and\n *  will assign the height property if the return value is not undefined.\n *\n * If the return value is false; it's suggesting that you should call {@link TerrainData#createMesh} first.\n * @param {Cartographic} position The position to interpolate for and assign the height value to\n * @param {TerrainData} terrainData\n * @param {Rectangle} rectangle\n * @returns {boolean} If the height was actually interpolated and assigned\n * @private\n */\nfunction interpolateAndAssignHeight(position, terrainData, rectangle) {\n  const height = terrainData.interpolateHeight(\n    rectangle,\n    position.longitude,\n    position.latitude,\n  );\n  if (height === undefined) {\n    // if height comes back as undefined, it may implicitly mean the terrain data\n    //  requires us to call TerrainData.createMesh() first (ArcGIS requires this in particular)\n    //  so we'll return false and do that next!\n    return false;\n  }\n  position.height = height;\n  return true;\n}\n\nfunction createInterpolateFunction(tileRequest) {\n  const tilePositions = tileRequest.positions;\n  const rectangle = tileRequest.tilingScheme.tileXYToRectangle(\n    tileRequest.x,\n    tileRequest.y,\n    tileRequest.level,\n  );\n  return function (terrainData) {\n    let isMeshRequired = false;\n    for (let i = 0; i < tilePositions.length; ++i) {\n      const position = tilePositions[i];\n      const isHeightAssigned = interpolateAndAssignHeight(\n        position,\n        terrainData,\n        rectangle,\n      );\n      // we've found a position which returned undefined - hinting to us\n      //  that we probably need to create a mesh for this terrain data.\n      // so break out of this loop and create the mesh - then we'll interpolate all the heights again\n      if (!isHeightAssigned) {\n        isMeshRequired = true;\n        break;\n      }\n    }\n\n    if (!isMeshRequired) {\n      // all position heights were interpolated - we don't need the mesh\n      return Promise.resolve();\n    }\n\n    // create the mesh - and interpolate all the positions again\n    // note: terrain exaggeration is not passed in - we are only interested in the raw data\n    return terrainData\n      .createMesh({\n        tilingScheme: tileRequest.tilingScheme,\n        x: tileRequest.x,\n        y: tileRequest.y,\n        level: tileRequest.level,\n        // don't throttle this mesh creation because we've asked to sample these points;\n        //  so sample them! We don't care how many tiles that is!\n        throttle: false,\n      })\n      .then(function () {\n        // mesh has been created - so go through every position (maybe again)\n        //  and re-interpolate the heights - presumably using the mesh this time\n        for (let i = 0; i < tilePositions.length; ++i) {\n          const position = tilePositions[i];\n          // if it doesn't work this time - that's fine, we tried.\n          interpolateAndAssignHeight(position, terrainData, rectangle);\n        }\n      });\n  };\n}\n\nfunction createMarkFailedFunction(tileRequest) {\n  const tilePositions = tileRequest.positions;\n  return function () {\n    for (let i = 0; i < tilePositions.length; ++i) {\n      const position = tilePositions[i];\n      position.height = undefined;\n    }\n  };\n}\n\nexport default sampleTerrain;\n"],"names":["sampleTerrain","terrainProvider","level","positions","rejectOnTileFail","typeOf","object","number","bool","defined","doSampling","attemptConsumeNextQueueItem","tileRequests","results","tileRequest","requestPromise","requestTileGeometry","x","y","promise","then","createInterpolateFunction","catch","createMarkFailedFunction","shift","push","delay","ms","Promise","res","setTimeout","drainTileRequestQueue","length","resolve","success","tilingScheme","i","tileRequestSet","xy","positionToTileXY","key","toString","hasOwnProperty","value","tilePromises","all","interpolateAndAssignHeight","position","terrainData","rectangle","height","interpolateHeight","longitude","latitude","undefined","tilePositions","tileXYToRectangle","isMeshRequired","isHeightAssigned","createMesh","throttle"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 54516, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/sampleTerrainMostDetailed.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport sampleTerrain from \"./sampleTerrain.js\";\n\nconst scratchCartesian2 = new Cartesian2();\n\n/**\n * Initiates a sampleTerrain() request at the maximum available tile level for a terrain dataset.\n *\n * @function sampleTerrainMostDetailed\n *\n * @param {TerrainProvider} terrainProvider The terrain provider from which to query heights.\n * @param {Cartographic[]} positions The positions to update with terrain heights.\n * @param {boolean} [rejectOnTileFail=false] If true, for a failed terrain tile request the promise will be rejected. If false, returned heights will be undefined.\n * @returns {Promise<Cartographic[]>} A promise that resolves to the provided list of positions when terrain the query has completed.  This\n *                                     promise will reject if the terrain provider's `availability` property is undefined.\n *\n * @example\n * // Query the terrain height of two Cartographic positions\n * const terrainProvider = await Cesium.createWorldTerrainAsync();\n * const positions = [\n *     Cesium.Cartographic.fromDegrees(86.925145, 27.988257),\n *     Cesium.Cartographic.fromDegrees(87.0, 28.0)\n * ];\n * const updatedPositions = await Cesium.sampleTerrainMostDetailed(terrainProvider, positions);\n * // positions[0].height and positions[1].height have been updated.\n * // updatedPositions is just a reference to positions.\n *\n * // To handle tile errors, pass true for the rejectOnTileFail parameter.\n * try {\n *    const updatedPositions = await Cesium.sampleTerrainMostDetailed(terrainProvider, positions, true);\n * } catch (error) {\n *   // A tile request error occurred.\n * }\n */\nasync function sampleTerrainMostDetailed(\n  terrainProvider,\n  positions,\n  rejectOnTileFail,\n) {\n  if (!defined(rejectOnTileFail)) {\n    rejectOnTileFail = false;\n  }\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(terrainProvider)) {\n    throw new DeveloperError(\"terrainProvider is required.\");\n  }\n  if (!defined(positions)) {\n    throw new DeveloperError(\"positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const byLevel = [];\n  const maxLevels = [];\n\n  const availability = terrainProvider.availability;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(availability)) {\n    throw new DeveloperError(\n      \"sampleTerrainMostDetailed requires a terrain provider that has tile availability.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const promises = [];\n  for (let i = 0; i < positions.length; ++i) {\n    const position = positions[i];\n    const maxLevel = availability.computeMaximumLevelAtPosition(position);\n    maxLevels[i] = maxLevel;\n    if (maxLevel === 0) {\n      // This is a special case where we have a parent terrain and we are requesting\n      // heights from an area that isn't covered by the top level terrain at all.\n      // This will essentially trigger the loading of the parent terrains root tile\n      terrainProvider.tilingScheme.positionToTileXY(\n        position,\n        1,\n        scratchCartesian2,\n      );\n      const promise = terrainProvider.loadTileDataAvailability(\n        scratchCartesian2.x,\n        scratchCartesian2.y,\n        1,\n      );\n      if (defined(promise)) {\n        promises.push(promise);\n      }\n    }\n\n    let atLevel = byLevel[maxLevel];\n    if (!defined(atLevel)) {\n      byLevel[maxLevel] = atLevel = [];\n    }\n    atLevel.push(position);\n  }\n\n  await Promise.all(promises);\n  await Promise.all(\n    byLevel.map(function (positionsAtLevel, index) {\n      if (defined(positionsAtLevel)) {\n        return sampleTerrain(\n          terrainProvider,\n          index,\n          positionsAtLevel,\n          rejectOnTileFail,\n        );\n      }\n    }),\n  );\n  const changedPositions = [];\n  for (let i = 0; i < positions.length; ++i) {\n    const position = positions[i];\n    const maxLevel = availability.computeMaximumLevelAtPosition(position);\n\n    if (maxLevel !== maxLevels[i]) {\n      // Now that we loaded the max availability, a higher level has become available\n      changedPositions.push(position);\n    }\n  }\n\n  if (changedPositions.length > 0) {\n    await sampleTerrainMostDetailed(\n      terrainProvider,\n      changedPositions,\n      rejectOnTileFail,\n    );\n  }\n\n  return positions;\n}\nexport default sampleTerrainMostDetailed;\n"],"names":["scratchCartesian2","sampleTerrainMostDetailed","terrainProvider","positions","rejectOnTileFail","byLevel","maxLevels","availability","promises","i","length","position","maxLevel","computeMaximumLevelAtPosition","tilingScheme","positionToTileXY","promise","loadTileDataAvailability","x","y","push","atLevel","Promise","all","map","positionsAtLevel","index","changedPositions"],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAMA,oBAAoB,IAAI,gLAAU;AAExC;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BC,GACD,eAAeC,0BACbC,eAAe,EACfC,SAAS,EACTC,gBAAgB;IAEhB,IAAI,CAAC,IAAA,6KAAO,EAACA,mBAAmB;QAC9BA,mBAAmB;IACrB;IACA,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACF,kBAAkB;QAC7B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACC,YAAY;QACvB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAME,UAAU,EAAE;IAClB,MAAMC,YAAY,EAAE;IAEpB,MAAMC,eAAeL,gBAAgBK,YAAY;IAEjD,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACA,eAAe;QAC1B,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,wBAAwB;IAExB,MAAMC,WAAW,EAAE;IACnB,IAAK,IAAIC,IAAI,GAAGA,IAAIN,UAAUO,MAAM,EAAE,EAAED,EAAG;QACzC,MAAME,WAAWR,SAAS,CAACM,EAAE;QAC7B,MAAMG,WAAWL,aAAaM,6BAA6B,CAACF;QAC5DL,SAAS,CAACG,EAAE,GAAGG;QACf,IAAIA,aAAa,GAAG;YAClB,8EAA8E;YAC9E,2EAA2E;YAC3E,6EAA6E;YAC7EV,gBAAgBY,YAAY,CAACC,gBAAgB,CAC3CJ,UACA,GACAX;YAEF,MAAMgB,UAAUd,gBAAgBe,wBAAwB,CACtDjB,kBAAkBkB,CAAC,EACnBlB,kBAAkBmB,CAAC,EACnB;YAEF,IAAI,IAAA,6KAAO,EAACH,UAAU;gBACpBR,SAASY,IAAI,CAACJ;YAChB;QACF;QAEA,IAAIK,UAAUhB,OAAO,CAACO,SAAS;QAC/B,IAAI,CAAC,IAAA,6KAAO,EAACS,UAAU;YACrBhB,OAAO,CAACO,SAAS,GAAGS,UAAU,EAAE;QAClC;QACAA,QAAQD,IAAI,CAACT;IACf;IAEA,MAAMW,QAAQC,GAAG,CAACf;IAClB,MAAMc,QAAQC,GAAG,CACflB,QAAQmB,GAAG,CAAC,SAAUC,gBAAgB,EAAEC,KAAK;QAC3C,IAAI,IAAA,6KAAO,EAACD,mBAAmB;YAC7B,OAAO,IAAA,mLAAa,EAClBvB,iBACAwB,OACAD,kBACArB;QAEJ;IACF;IAEF,MAAMuB,mBAAmB,EAAE;IAC3B,IAAK,IAAIlB,IAAI,GAAGA,IAAIN,UAAUO,MAAM,EAAE,EAAED,EAAG;QACzC,MAAME,WAAWR,SAAS,CAACM,EAAE;QAC7B,MAAMG,WAAWL,aAAaM,6BAA6B,CAACF;QAE5D,IAAIC,aAAaN,SAAS,CAACG,EAAE,EAAE;YAC7B,+EAA+E;YAC/EkB,iBAAiBP,IAAI,CAACT;QACxB;IACF;IAEA,IAAIgB,iBAAiBjB,MAAM,GAAG,GAAG;QAC/B,MAAMT,0BACJC,iBACAyB,kBACAvB;IAEJ;IAEA,OAAOD;AACT;uCACeF","ignoreList":[0]}},
    {"offset": {"line": 54623, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/HeightmapEncoding.js"],"sourcesContent":["/**\n * The encoding that is used for a heightmap\n *\n * @enum {number}\n */\nconst HeightmapEncoding = {\n  /**\n   * No encoding\n   *\n   * @type {number}\n   * @constant\n   */\n  NONE: 0,\n\n  /**\n   * LERC encoding\n   *\n   * @type {number}\n   * @constant\n   *\n   * @see {@link https://github.com/Esri/lerc|The LERC specification}\n   */\n  LERC: 1,\n};\nexport default Object.freeze(HeightmapEncoding);\n"],"names":["HeightmapEncoding","NONE","LERC","Object","freeze"],"mappings":";;;;AAAA;;;;CAIC,GACD,MAAMA,oBAAoB;IACxB;;;;;GAKC,GACDC,MAAM;IAEN;;;;;;;GAOC,GACDC,MAAM;AACR;uCACeC,OAAOC,MAAM,CAACJ","ignoreList":[0]}},
    {"offset": {"line": 54652, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TerrainQuantization.js"],"sourcesContent":["/**\n * This enumerated type is used to determine how the vertices of the terrain mesh are compressed.\n *\n * @enum {number}\n *\n * @private\n */\nconst TerrainQuantization = {\n  /**\n   * The vertices are not compressed.\n   *\n   * @type {number}\n   * @constant\n   */\n  NONE: 0,\n\n  /**\n   * The vertices are compressed to 12 bits.\n   *\n   * @type {number}\n   * @constant\n   */\n  BITS12: 1,\n};\nexport default Object.freeze(TerrainQuantization);\n"],"names":["TerrainQuantization","NONE","BITS12","Object","freeze"],"mappings":";;;;AAAA;;;;;;CAMC,GACD,MAAMA,sBAAsB;IAC1B;;;;;GAKC,GACDC,MAAM;IAEN;;;;;GAKC,GACDC,QAAQ;AACV;uCACeC,OAAOC,MAAM,CAACJ","ignoreList":[0]}},
    {"offset": {"line": 54681, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TerrainEncoding.js"],"sourcesContent":["import AttributeCompression from \"./AttributeCompression.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport VerticalExaggeration from \"./VerticalExaggeration.js\";\nimport TerrainQuantization from \"./TerrainQuantization.js\";\n\nconst cartesian3Scratch = new Cartesian3();\nconst cartesian3DimScratch = new Cartesian3();\nconst cartesian2Scratch = new Cartesian2();\nconst matrix4Scratch = new Matrix4();\nconst matrix4Scratch2 = new Matrix4();\n\nconst SHIFT_LEFT_12 = Math.pow(2.0, 12.0);\n\n/**\n * Data used to quantize and pack the terrain mesh. The position can be unpacked for picking and all attributes\n * are unpacked in the vertex shader.\n *\n * @alias TerrainEncoding\n * @constructor\n *\n * @param {Cartesian3} center The center point of the vertices.\n * @param {AxisAlignedBoundingBox} [axisAlignedBoundingBox] The bounds of the tile in the east-north-up coordinates at the tiles center.\n * @param {number} [minimumHeight] The minimum height.\n * @param {number} [maximumHeight] The maximum height.\n * @param {Matrix4} [fromENU] The east-north-up to fixed frame matrix at the center of the terrain mesh.\n * @param {boolean} [hasVertexNormals=false] If the mesh has vertex normals.\n * @param {boolean} [hasWebMercatorT=false] true if the terrain data includes a Web Mercator texture coordinate; otherwise, false.\n * @param {boolean} [hasGeodeticSurfaceNormals=false] true if the terrain data includes geodetic surface normals; otherwise, false.\n * @param {number} [exaggeration=1.0] A scalar used to exaggerate terrain.\n * @param {number} [exaggerationRelativeHeight=0.0] The relative height from which terrain is exaggerated.\n *\n * @private\n */\nfunction TerrainEncoding(\n  center,\n  axisAlignedBoundingBox,\n  minimumHeight,\n  maximumHeight,\n  fromENU,\n  hasVertexNormals,\n  hasWebMercatorT,\n  hasGeodeticSurfaceNormals,\n  exaggeration,\n  exaggerationRelativeHeight,\n) {\n  let quantization = TerrainQuantization.NONE;\n  let toENU;\n  let matrix;\n\n  if (\n    defined(axisAlignedBoundingBox) &&\n    defined(minimumHeight) &&\n    defined(maximumHeight) &&\n    defined(fromENU)\n  ) {\n    const minimum = axisAlignedBoundingBox.minimum;\n    const maximum = axisAlignedBoundingBox.maximum;\n\n    const dimensions = Cartesian3.subtract(\n      maximum,\n      minimum,\n      cartesian3DimScratch,\n    );\n    const hDim = maximumHeight - minimumHeight;\n    const maxDim = Math.max(Cartesian3.maximumComponent(dimensions), hDim);\n\n    if (maxDim < SHIFT_LEFT_12 - 1.0) {\n      quantization = TerrainQuantization.BITS12;\n    } else {\n      quantization = TerrainQuantization.NONE;\n    }\n\n    // Scale and bias from [0,1] to [ENU min, ENU max]\n    // Also compute the inverse of the scale and bias\n    let st = Matrix4.fromScale(dimensions, matrix4Scratch);\n    st = Matrix4.setTranslation(st, minimum, st);\n\n    let invSt = Matrix4.fromScale(\n      Cartesian3.fromElements(\n        1.0 / dimensions.x,\n        1.0 / dimensions.y,\n        1.0 / dimensions.z,\n        cartesian3Scratch,\n      ),\n      matrix4Scratch2,\n    );\n    invSt = Matrix4.multiplyByTranslation(\n      invSt,\n      Cartesian3.negate(minimum, cartesian3Scratch),\n      invSt,\n    );\n\n    matrix = Matrix4.clone(fromENU, new Matrix4());\n    let rtcOffset = Matrix4.getTranslation(fromENU, cartesian3Scratch);\n    rtcOffset = Cartesian3.subtract(rtcOffset, center, cartesian3Scratch);\n    matrix = Matrix4.setTranslation(matrix, rtcOffset, matrix);\n    matrix = Matrix4.multiply(matrix, st, matrix);\n\n    toENU = Matrix4.inverseTransformation(fromENU, new Matrix4());\n    toENU = Matrix4.multiply(invSt, toENU, toENU);\n\n    fromENU = Matrix4.multiply(fromENU, st, new Matrix4());\n  }\n\n  /**\n   * How the vertices of the mesh were compressed.\n   * @type {TerrainQuantization}\n   */\n  this.quantization = quantization;\n\n  /**\n   * The minimum height of the tile including the skirts.\n   * @type {number|undefined}\n   */\n  this.minimumHeight = minimumHeight;\n\n  /**\n   * The maximum height of the tile.\n   * @type {number|undefined}\n   */\n  this.maximumHeight = maximumHeight;\n\n  /**\n   * The center of the tile.\n   * @type {Cartesian3}\n   */\n  this.center = Cartesian3.clone(center);\n\n  /**\n   * A matrix that takes a vertex from the tile, transforms it to east-north-up at the center and scales\n   * it so each component is in the [0, 1] range.\n   * @type {Matrix4|undefined}\n   */\n  this.toScaledENU = toENU;\n\n  /**\n   * A matrix that restores a vertex transformed with toScaledENU back to the earth fixed reference frame\n   * @type {Matrix4|undefined}\n   */\n  this.fromScaledENU = fromENU;\n\n  /**\n   * The matrix used to decompress the terrain vertices in the shader for RTE rendering.\n   * @type {Matrix4|undefined}\n   */\n  this.matrix = matrix;\n\n  /**\n   * The terrain mesh contains normals.\n   * @type {boolean}\n   */\n  this.hasVertexNormals = hasVertexNormals ?? false;\n\n  /**\n   * The terrain mesh contains a vertical texture coordinate following the Web Mercator projection.\n   * @type {boolean}\n   */\n  this.hasWebMercatorT = hasWebMercatorT ?? false;\n\n  /**\n   * The terrain mesh contains geodetic surface normals, used for terrain exaggeration.\n   * @type {boolean}\n   */\n  this.hasGeodeticSurfaceNormals = hasGeodeticSurfaceNormals ?? false;\n\n  /**\n   * A scalar used to exaggerate terrain.\n   * @type {number}\n   */\n  this.exaggeration = exaggeration ?? 1.0;\n\n  /**\n   * The relative height from which terrain is exaggerated.\n   */\n  this.exaggerationRelativeHeight = exaggerationRelativeHeight ?? 0.0;\n\n  /**\n   * The number of components in each vertex. This value can differ with different quantizations.\n   * @type {number}\n   */\n  this.stride = 0;\n\n  this._offsetGeodeticSurfaceNormal = 0;\n  this._offsetVertexNormal = 0;\n\n  // Calculate the stride and offsets declared above\n  this._calculateStrideAndOffsets();\n}\n\n/**\n * Encode information about the terrain at a given position into the vertex buffer.\n * Position, texture coordinates, height, and (optionally) normal, projection information,\n * and geodetic surface normal are all packed into the same buffer.\n *\n * @param {Float32Array} vertexBuffer The buffer to write to.\n * @param {number} bufferIndex The index into the buffer to start writing at.\n * @param {Cartesian3} position The position of the vertex.\n * @param {Cartesian2} uv The texture coordinates of the vertex.\n * @param {number} height The height of the vertex.\n * @param {Cartesian2} [normalToPack] The normal vector of the vertex.\n * @param {number} [webMercatorT] The Web Mercator texture coordinate of the vertex.\n * @param {Cartesian3} [geodeticSurfaceNormal] The geodetic surface normal of the vertex.\n */\nTerrainEncoding.prototype.encode = function (\n  vertexBuffer,\n  bufferIndex,\n  position,\n  uv,\n  height,\n  normalToPack,\n  webMercatorT,\n  geodeticSurfaceNormal,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"vertexBuffer\", vertexBuffer);\n  Check.typeOf.number(\"bufferIndex\", bufferIndex);\n  Check.typeOf.object(\"position\", position);\n  Check.typeOf.object(\"uv\", uv);\n  Check.typeOf.number(\"height\", height);\n  //>>includeEnd('debug');\n\n  const u = uv.x;\n  const v = uv.y;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    position = Matrix4.multiplyByPoint(\n      this.toScaledENU,\n      position,\n      cartesian3Scratch,\n    );\n\n    position.x = CesiumMath.clamp(position.x, 0.0, 1.0);\n    position.y = CesiumMath.clamp(position.y, 0.0, 1.0);\n    position.z = CesiumMath.clamp(position.z, 0.0, 1.0);\n\n    const hDim = this.maximumHeight - this.minimumHeight;\n    const h = CesiumMath.clamp((height - this.minimumHeight) / hDim, 0.0, 1.0);\n\n    Cartesian2.fromElements(position.x, position.y, cartesian2Scratch);\n    const compressed0 =\n      AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n\n    Cartesian2.fromElements(position.z, h, cartesian2Scratch);\n    const compressed1 =\n      AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n\n    Cartesian2.fromElements(u, v, cartesian2Scratch);\n    const compressed2 =\n      AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n\n    vertexBuffer[bufferIndex++] = compressed0;\n    vertexBuffer[bufferIndex++] = compressed1;\n    vertexBuffer[bufferIndex++] = compressed2;\n\n    if (this.hasWebMercatorT) {\n      Cartesian2.fromElements(webMercatorT, 0.0, cartesian2Scratch);\n      const compressed3 =\n        AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n      vertexBuffer[bufferIndex++] = compressed3;\n    }\n  } else {\n    vertexBuffer[bufferIndex++] = position.x - this.center.x;\n    vertexBuffer[bufferIndex++] = position.y - this.center.y;\n    vertexBuffer[bufferIndex++] = position.z - this.center.z;\n    vertexBuffer[bufferIndex++] = height;\n    vertexBuffer[bufferIndex++] = u;\n    vertexBuffer[bufferIndex++] = v;\n\n    if (this.hasWebMercatorT) {\n      vertexBuffer[bufferIndex++] = webMercatorT;\n    }\n  }\n\n  if (this.hasVertexNormals) {\n    vertexBuffer[bufferIndex++] =\n      AttributeCompression.octPackFloat(normalToPack);\n  }\n\n  if (this.hasGeodeticSurfaceNormals) {\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.x;\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.y;\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.z;\n  }\n\n  return bufferIndex;\n};\n\nconst scratchPosition = new Cartesian3();\nconst scratchGeodeticSurfaceNormal = new Cartesian3();\n\n/**\n * Add geodetic surface normals to a terrain vertex buffer.\n * The new buffer will be larger than the old buffer.\n *\n * @param {Float32Array} oldBuffer The buffer without geodetic surface normals.\n * @param {Float32Array} newBuffer The buffer with geodetic surface normals.\n * @param {Ellipsoid} ellipsoid The ellipsoid to use to compute the geodetic surface normals.\n */\nTerrainEncoding.prototype.addGeodeticSurfaceNormals = function (\n  oldBuffer,\n  newBuffer,\n  ellipsoid,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"oldBuffer\", oldBuffer);\n  Check.typeOf.object(\"newBuffer\", newBuffer);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  //>>includeEnd('debug');\n\n  if (this.hasGeodeticSurfaceNormals) {\n    return;\n  }\n\n  const oldStride = this.stride;\n  const vertexCount = oldBuffer.length / oldStride;\n  this.hasGeodeticSurfaceNormals = true;\n  this._calculateStrideAndOffsets();\n  const newStride = this.stride;\n\n  for (let index = 0; index < vertexCount; index++) {\n    for (let offset = 0; offset < oldStride; offset++) {\n      const oldIndex = index * oldStride + offset;\n      const newIndex = index * newStride + offset;\n      newBuffer[newIndex] = oldBuffer[oldIndex];\n    }\n    const position = this.decodePosition(newBuffer, index, scratchPosition);\n    const geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n      position,\n      scratchGeodeticSurfaceNormal,\n    );\n\n    const bufferIndex = index * newStride + this._offsetGeodeticSurfaceNormal;\n    newBuffer[bufferIndex] = geodeticSurfaceNormal.x;\n    newBuffer[bufferIndex + 1] = geodeticSurfaceNormal.y;\n    newBuffer[bufferIndex + 2] = geodeticSurfaceNormal.z;\n  }\n};\n\n/**\n * Remove geodetic surface normals from a terrain vertex buffer.\n *\n * @param {Float32Array} oldBuffer The buffer with geodetic surface normals.\n * @param {Float32Array} newBuffer The buffer without geodetic surface normals.\n */\nTerrainEncoding.prototype.removeGeodeticSurfaceNormals = function (\n  oldBuffer,\n  newBuffer,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"oldBuffer\", oldBuffer);\n  Check.typeOf.object(\"newBuffer\", newBuffer);\n  //>>includeEnd('debug');\n\n  if (!this.hasGeodeticSurfaceNormals) {\n    return;\n  }\n\n  const oldStride = this.stride;\n  const vertexCount = oldBuffer.length / oldStride;\n  this.hasGeodeticSurfaceNormals = false;\n  this._calculateStrideAndOffsets();\n  const newStride = this.stride;\n\n  for (let index = 0; index < vertexCount; index++) {\n    for (let offset = 0; offset < newStride; offset++) {\n      const oldIndex = index * oldStride + offset;\n      const newIndex = index * newStride + offset;\n      newBuffer[newIndex] = oldBuffer[oldIndex];\n    }\n  }\n};\n\n/**\n * Decode a position from the vertex buffer.\n *\n * @param {Float32Array} buffer The buffer to decode from.\n * @param {number} index The index of the vertex to decode.\n * @param {Cartesian3} [result] The object to store the result in.\n * @returns {Cartesian3} The decoded position.\n */\nTerrainEncoding.prototype.decodePosition = function (buffer, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"buffer\", buffer);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  index *= this.stride;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    const xy = AttributeCompression.decompressTextureCoordinates(\n      buffer[index],\n      cartesian2Scratch,\n    );\n    result.x = xy.x;\n    result.y = xy.y;\n\n    const zh = AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 1],\n      cartesian2Scratch,\n    );\n    result.z = zh.x;\n\n    return Matrix4.multiplyByPoint(this.fromScaledENU, result, result);\n  }\n\n  result.x = buffer[index];\n  result.y = buffer[index + 1];\n  result.z = buffer[index + 2];\n  return Cartesian3.add(result, this.center, result);\n};\n\n/**\n * Decode a position from the vertex buffer and apply vertical exaggeration.\n *\n * @param {Float32Array} buffer\n * @param {number} index\n * @param {Cartesian3} [result]\n * @returns {Cartesian3} The exaggerated position.\n */\nTerrainEncoding.prototype.getExaggeratedPosition = function (\n  buffer,\n  index,\n  result,\n) {\n  result = this.decodePosition(buffer, index, result);\n\n  const exaggeration = this.exaggeration;\n  const exaggerationRelativeHeight = this.exaggerationRelativeHeight;\n  const hasExaggeration = exaggeration !== 1.0;\n  if (hasExaggeration && this.hasGeodeticSurfaceNormals) {\n    const geodeticSurfaceNormal = this.decodeGeodeticSurfaceNormal(\n      buffer,\n      index,\n      scratchGeodeticSurfaceNormal,\n    );\n    const rawHeight = this.decodeHeight(buffer, index);\n    const heightDifference =\n      VerticalExaggeration.getHeight(\n        rawHeight,\n        exaggeration,\n        exaggerationRelativeHeight,\n      ) - rawHeight;\n\n    // some math is unrolled for better performance\n    result.x += geodeticSurfaceNormal.x * heightDifference;\n    result.y += geodeticSurfaceNormal.y * heightDifference;\n    result.z += geodeticSurfaceNormal.z * heightDifference;\n  }\n\n  return result;\n};\n\n/**\n * Decode texture coordinates from the vertex buffer.\n *\n * @param {Float32Array} buffer The buffer to decode from.\n * @param {number} index The index of the vertex to decode.\n * @param {Cartesian2} [result] The object to store the result in.\n * @returns {Cartesian2} The decoded texture coordinates.\n */\nTerrainEncoding.prototype.decodeTextureCoordinates = function (\n  buffer,\n  index,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"buffer\", buffer);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  index *= this.stride;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    return AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 2],\n      result,\n    );\n  }\n\n  return Cartesian2.fromElements(buffer[index + 4], buffer[index + 5], result);\n};\n\n/**\n * Decode a height from the vertex buffer.\n *\n * @param {Float32Array} buffer The buffer to decode from.\n * @param {number} index The index of the vertex to decode.\n * @returns {number} The decoded height.\n */\nTerrainEncoding.prototype.decodeHeight = function (buffer, index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"buffer\", buffer);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  index *= this.stride;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    const zh = AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 1],\n      cartesian2Scratch,\n    );\n    return (\n      zh.y * (this.maximumHeight - this.minimumHeight) + this.minimumHeight\n    );\n  }\n\n  return buffer[index + 3];\n};\n\n/**\n * Decode a web mercator T coordinate from the vertex buffer.\n *\n * @param {Float32Array} buffer The buffer to decode from.\n * @param {number} index The index of the vertex to decode.\n * @returns {number} The decoded web mercator T coordinate.\n */\nTerrainEncoding.prototype.decodeWebMercatorT = function (buffer, index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"buffer\", buffer);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  index *= this.stride;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    return AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 3],\n      cartesian2Scratch,\n    ).x;\n  }\n\n  return buffer[index + 6];\n};\n\n/**\n * Decode an oct-encoded normal from the vertex buffer.\n *\n * @param {Float32Array} buffer The buffer to decode from.\n * @param {number} index The index of the vertex to decode.\n * @param {Cartesian2} [result] The object to store the result in.\n * @returns {Cartesian2} The decoded oct-encoded normal.\n */\nTerrainEncoding.prototype.getOctEncodedNormal = function (\n  buffer,\n  index,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"buffer\", buffer);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  index = index * this.stride + this._offsetVertexNormal;\n\n  const temp = buffer[index] / 256.0;\n  const x = Math.floor(temp);\n  const y = (temp - x) * 256.0;\n\n  return Cartesian2.fromElements(x, y, result);\n};\n\n/**\n * @param {Float32Array} buffer\n * @param {number} index\n * @param {Cartesian3} result\n * @returns {Cartesian3}\n */\nTerrainEncoding.prototype.decodeNormal = function (buffer, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"buffer\", buffer);\n  Check.typeOf.number(\"index\", index);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const bufferIndex = (index = index * this.stride + this._offsetVertexNormal);\n  return AttributeCompression.octDecodeFloat(buffer[bufferIndex], result);\n};\n\n/**\n * Decode a geodetic surface normal from the vertex buffer.\n *\n * @param {Float32Array} buffer The buffer to decode from.\n * @param {number} index The index of the vertex to decode.\n * @param {Cartesian3} result The object to store the result in.\n * @returns {Cartesian3} The decoded geodetic surface normal.\n */\nTerrainEncoding.prototype.decodeGeodeticSurfaceNormal = function (\n  buffer,\n  index,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"buffer\", buffer);\n  Check.typeOf.number(\"index\", index);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  index = index * this.stride + this._offsetGeodeticSurfaceNormal;\n\n  result.x = buffer[index];\n  result.y = buffer[index + 1];\n  result.z = buffer[index + 2];\n  return result;\n};\n\n/**\n * Calculate the stride and offsets for sampling the vertex buffer.\n */\nTerrainEncoding.prototype._calculateStrideAndOffsets = function () {\n  let vertexStride = 0;\n\n  switch (this.quantization) {\n    case TerrainQuantization.BITS12:\n      vertexStride += 3;\n      break;\n    default:\n      vertexStride += 6;\n  }\n  if (this.hasWebMercatorT) {\n    vertexStride += 1;\n  }\n  if (this.hasVertexNormals) {\n    this._offsetVertexNormal = vertexStride;\n    vertexStride += 1;\n  }\n  if (this.hasGeodeticSurfaceNormals) {\n    this._offsetGeodeticSurfaceNormal = vertexStride;\n    vertexStride += 3;\n  }\n\n  this.stride = vertexStride;\n};\n\nconst attributesIndicesNone = {\n  position3DAndHeight: 0,\n  textureCoordAndEncodedNormals: 1,\n  geodeticSurfaceNormal: 2,\n};\nconst attributesIndicesBits12 = {\n  compressed0: 0,\n  compressed1: 1,\n  geodeticSurfaceNormal: 2,\n};\n\n/**\n * Get descriptors of the attributes stored in the vertex buffer.\n *\n * @param {Float32Array} buffer The vertex buffer.\n * @returns {object[]} The attributes.\n */\nTerrainEncoding.prototype.getAttributes = function (buffer) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"buffer\", buffer);\n  //>>includeEnd('debug');\n\n  const datatype = ComponentDatatype.FLOAT;\n  const sizeInBytes = ComponentDatatype.getSizeInBytes(datatype);\n  const strideInBytes = this.stride * sizeInBytes;\n  let offsetInBytes = 0;\n\n  const attributes = [];\n  function addAttribute(index, componentsPerAttribute) {\n    attributes.push({\n      index: index,\n      vertexBuffer: buffer,\n      componentDatatype: datatype,\n      componentsPerAttribute: componentsPerAttribute,\n      offsetInBytes: offsetInBytes,\n      strideInBytes: strideInBytes,\n    });\n    offsetInBytes += componentsPerAttribute * sizeInBytes;\n  }\n\n  if (this.quantization === TerrainQuantization.NONE) {\n    addAttribute(attributesIndicesNone.position3DAndHeight, 4);\n\n    let componentsTexCoordAndNormals = 2;\n    componentsTexCoordAndNormals += this.hasWebMercatorT ? 1 : 0;\n    componentsTexCoordAndNormals += this.hasVertexNormals ? 1 : 0;\n    addAttribute(\n      attributesIndicesNone.textureCoordAndEncodedNormals,\n      componentsTexCoordAndNormals,\n    );\n\n    if (this.hasGeodeticSurfaceNormals) {\n      addAttribute(attributesIndicesNone.geodeticSurfaceNormal, 3);\n    }\n  } else {\n    // When there is no webMercatorT or vertex normals, the attribute only needs 3 components: x/y, z/h, u/v.\n    // WebMercatorT and vertex normals each take up one component, so if only one of them is present the first\n    // attribute gets a 4th component. If both are present, we need an additional attribute that has 1 component.\n    const usingAttribute0Component4 =\n      this.hasWebMercatorT || this.hasVertexNormals;\n    const usingAttribute1Component1 =\n      this.hasWebMercatorT && this.hasVertexNormals;\n    addAttribute(\n      attributesIndicesBits12.compressed0,\n      usingAttribute0Component4 ? 4 : 3,\n    );\n\n    if (usingAttribute1Component1) {\n      addAttribute(attributesIndicesBits12.compressed1, 1);\n    }\n\n    if (this.hasGeodeticSurfaceNormals) {\n      addAttribute(attributesIndicesBits12.geodeticSurfaceNormal, 3);\n    }\n  }\n\n  return attributes;\n};\n\n/**\n * Get indices pointing to the attribute locations in the vertex buffer.\n *\n * @returns {object} The attribute indices.\n */\nTerrainEncoding.prototype.getAttributeLocations = function () {\n  if (this.quantization === TerrainQuantization.NONE) {\n    return attributesIndicesNone;\n  }\n  return attributesIndicesBits12;\n};\n\n/**\n * Clones a TerrainEncoding object.\n *\n * @param {TerrainEncoding} [encoding] The encoding to clone.\n * @param {TerrainEncoding} [result] The object to store the cloned encoding.\n * @returns {TerrainEncoding|undefined} The cloned encoding.\n */\nTerrainEncoding.clone = function (encoding, result) {\n  if (!defined(encoding)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new TerrainEncoding();\n  }\n\n  result.quantization = encoding.quantization;\n  result.minimumHeight = encoding.minimumHeight;\n  result.maximumHeight = encoding.maximumHeight;\n  result.center = Cartesian3.clone(encoding.center);\n  result.toScaledENU = Matrix4.clone(encoding.toScaledENU);\n  result.fromScaledENU = Matrix4.clone(encoding.fromScaledENU);\n  result.matrix = Matrix4.clone(encoding.matrix);\n  result.hasVertexNormals = encoding.hasVertexNormals;\n  result.hasWebMercatorT = encoding.hasWebMercatorT;\n  result.hasGeodeticSurfaceNormals = encoding.hasGeodeticSurfaceNormals;\n  result.exaggeration = encoding.exaggeration;\n  result.exaggerationRelativeHeight = encoding.exaggerationRelativeHeight;\n\n  result._calculateStrideAndOffsets();\n\n  return result;\n};\nexport default TerrainEncoding;\n"],"names":["cartesian3Scratch","cartesian3DimScratch","cartesian2Scratch","matrix4Scratch","matrix4Scratch2","SHIFT_LEFT_12","Math","pow","TerrainEncoding","center","axisAlignedBoundingBox","minimumHeight","maximumHeight","fromENU","hasVertexNormals","hasWebMercatorT","hasGeodeticSurfaceNormals","exaggeration","exaggerationRelativeHeight","quantization","NONE","toENU","matrix","minimum","maximum","dimensions","subtract","hDim","maxDim","max","maximumComponent","BITS12","st","fromScale","setTranslation","invSt","fromElements","x","y","z","multiplyByTranslation","negate","clone","rtcOffset","getTranslation","multiply","inverseTransformation","toScaledENU","fromScaledENU","stride","_offsetGeodeticSurfaceNormal","_offsetVertexNormal","_calculateStrideAndOffsets","prototype","encode","vertexBuffer","bufferIndex","position","uv","height","normalToPack","webMercatorT","geodeticSurfaceNormal","typeOf","object","number","u","v","multiplyByPoint","clamp","h","compressed0","compressTextureCoordinates","compressed1","compressed2","compressed3","octPackFloat","scratchPosition","scratchGeodeticSurfaceNormal","addGeodeticSurfaceNormals","oldBuffer","newBuffer","ellipsoid","oldStride","vertexCount","length","newStride","index","offset","oldIndex","newIndex","decodePosition","removeGeodeticSurfaceNormals","buffer","result","xy","decompressTextureCoordinates","zh","add","getExaggeratedPosition","hasExaggeration","decodeGeodeticSurfaceNormal","rawHeight","decodeHeight","heightDifference","getHeight","decodeTextureCoordinates","decodeWebMercatorT","getOctEncodedNormal","temp","floor","decodeNormal","octDecodeFloat","vertexStride","attributesIndicesNone","position3DAndHeight","textureCoordAndEncodedNormals","attributesIndicesBits12","getAttributes","datatype","FLOAT","sizeInBytes","getSizeInBytes","strideInBytes","offsetInBytes","attributes","addAttribute","componentsPerAttribute","push","componentDatatype","componentsTexCoordAndNormals","usingAttribute0Component4","usingAttribute1Component1","getAttributeLocations","encoding","undefined"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 55231, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/HeightmapTessellator.js"],"sourcesContent":["import AxisAlignedBoundingBox from \"./AxisAlignedBoundingBox.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidalOccluder from \"./EllipsoidalOccluder.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport Transforms from \"./Transforms.js\";\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\n\n/**\n * Contains functions to create a mesh from a heightmap image.\n *\n * @namespace HeightmapTessellator\n *\n * @private\n */\nconst HeightmapTessellator = {};\n\n/**\n * The default structure of a heightmap, as given to {@link HeightmapTessellator.computeVertices}.\n *\n * @constant\n */\nHeightmapTessellator.DEFAULT_STRUCTURE = Object.freeze({\n  heightScale: 1.0,\n  heightOffset: 0.0,\n  elementsPerHeight: 1,\n  stride: 1,\n  elementMultiplier: 256.0,\n  isBigEndian: false,\n});\n\nconst cartesian3Scratch = new Cartesian3();\nconst matrix4Scratch = new Matrix4();\nconst minimumScratch = new Cartesian3();\nconst maximumScratch = new Cartesian3();\n\n/**\n * Fills an array of vertices from a heightmap image.\n *\n * @param {object} options Object with the following properties:\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} options.heightmap The heightmap to tessellate.\n * @param {number} options.width The width of the heightmap, in height samples.\n * @param {number} options.height The height of the heightmap, in height samples.\n * @param {number} options.skirtHeight The height of skirts to drape at the edges of the heightmap.\n * @param {Rectangle} options.nativeRectangle A rectangle in the native coordinates of the heightmap's projection.  For\n *                 a heightmap with a geographic projection, this is degrees.  For the web mercator\n *                 projection, this is meters.\n * @param {number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {number} [options.exaggerationRelativeHeight=0.0] The height from which terrain is exaggerated.\n * @param {Rectangle} [options.rectangle] The rectangle covered by the heightmap, in geodetic coordinates with north, south, east and\n *                 west properties in radians.  Either rectangle or nativeRectangle must be provided.  If both\n *                 are provided, they're assumed to be consistent.\n * @param {boolean} [options.isGeographic=true] True if the heightmap uses a {@link GeographicProjection}, or false if it uses\n *                  a {@link WebMercatorProjection}.\n * @param {Cartesian3} [options.relativeToCenter=Cartesian3.ZERO] The positions will be computed as <code>Cartesian3.subtract(worldPosition, relativeToCenter)</code>.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to which the heightmap applies.\n * @param {object} [options.structure] An object describing the structure of the height data.\n * @param {number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\n *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\n *                 height after multiplying by the scale.\n * @param {number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\n *                 height in meters.  The offset is added after the height sample is multiplied by the\n *                 heightScale.\n * @param {number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\n *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\n *                 it is greater than 1, that number of elements together form the height sample, which is\n *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\n * @param {number} [options.structure.stride=1] The number of elements to skip to get from the first element of\n *                 one height to the first element of the next height.\n * @param {number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\n *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\n *                 is 256, the height is computed as follows:\n *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\n *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\n *                 elements is reversed.\n * @param {number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\n *                 not specified, no minimum value is enforced.\n * @param {number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\n *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\n * @param {boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\n *                  stride property is greater than 1.  If this property is false, the first element is the\n *                  low-order element.  If it is true, the first element is the high-order element.\n *\n * @example\n * const width = 5;\n * const height = 5;\n * const statistics = Cesium.HeightmapTessellator.computeVertices({\n *     heightmap : [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0],\n *     width : width,\n *     height : height,\n *     skirtHeight : 0.0,\n *     nativeRectangle : {\n *         west : 10.0,\n *         east : 20.0,\n *         south : 30.0,\n *         north : 40.0\n *     }\n * });\n *\n * const encoding = statistics.encoding;\n * const position = encoding.decodePosition(statistics.vertices, index);\n */\nHeightmapTessellator.computeVertices = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.heightmap)) {\n    throw new DeveloperError(\"options.heightmap is required.\");\n  }\n  if (!defined(options.width) || !defined(options.height)) {\n    throw new DeveloperError(\"options.width and options.height are required.\");\n  }\n  if (!defined(options.nativeRectangle)) {\n    throw new DeveloperError(\"options.nativeRectangle is required.\");\n  }\n  if (!defined(options.skirtHeight)) {\n    throw new DeveloperError(\"options.skirtHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // This function tends to be a performance hotspot for terrain rendering,\n  // so it employs a lot of inlining and unrolling as an optimization.\n  // In particular, the functionality of Ellipsoid.cartographicToCartesian\n  // is inlined.\n\n  const cos = Math.cos;\n  const sin = Math.sin;\n  const sqrt = Math.sqrt;\n  const atan = Math.atan;\n  const exp = Math.exp;\n  const piOverTwo = CesiumMath.PI_OVER_TWO;\n  const toRadians = CesiumMath.toRadians;\n\n  const heightmap = options.heightmap;\n  const width = options.width;\n  const height = options.height;\n  const skirtHeight = options.skirtHeight;\n  const hasSkirts = skirtHeight > 0.0;\n\n  const isGeographic = options.isGeographic ?? true;\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n\n  const oneOverGlobeSemimajorAxis = 1.0 / ellipsoid.maximumRadius;\n\n  const nativeRectangle = Rectangle.clone(options.nativeRectangle);\n  const rectangle = Rectangle.clone(options.rectangle);\n\n  let geographicWest;\n  let geographicSouth;\n  let geographicEast;\n  let geographicNorth;\n\n  if (!defined(rectangle)) {\n    if (isGeographic) {\n      geographicWest = toRadians(nativeRectangle.west);\n      geographicSouth = toRadians(nativeRectangle.south);\n      geographicEast = toRadians(nativeRectangle.east);\n      geographicNorth = toRadians(nativeRectangle.north);\n    } else {\n      geographicWest = nativeRectangle.west * oneOverGlobeSemimajorAxis;\n      geographicSouth =\n        piOverTwo -\n        2.0 * atan(exp(-nativeRectangle.south * oneOverGlobeSemimajorAxis));\n      geographicEast = nativeRectangle.east * oneOverGlobeSemimajorAxis;\n      geographicNorth =\n        piOverTwo -\n        2.0 * atan(exp(-nativeRectangle.north * oneOverGlobeSemimajorAxis));\n    }\n  } else {\n    geographicWest = rectangle.west;\n    geographicSouth = rectangle.south;\n    geographicEast = rectangle.east;\n    geographicNorth = rectangle.north;\n  }\n\n  let relativeToCenter = options.relativeToCenter;\n  const hasRelativeToCenter = defined(relativeToCenter);\n  relativeToCenter = hasRelativeToCenter ? relativeToCenter : Cartesian3.ZERO;\n  const includeWebMercatorT = options.includeWebMercatorT ?? false;\n\n  const exaggeration = options.exaggeration ?? 1.0;\n  const exaggerationRelativeHeight = options.exaggerationRelativeHeight ?? 0.0;\n  const hasExaggeration = exaggeration !== 1.0;\n  const includeGeodeticSurfaceNormals = hasExaggeration;\n\n  const structure = options.structure ?? HeightmapTessellator.DEFAULT_STRUCTURE;\n  const heightScale =\n    structure.heightScale ?? HeightmapTessellator.DEFAULT_STRUCTURE.heightScale;\n  const heightOffset =\n    structure.heightOffset ??\n    HeightmapTessellator.DEFAULT_STRUCTURE.heightOffset;\n  const elementsPerHeight =\n    structure.elementsPerHeight ??\n    HeightmapTessellator.DEFAULT_STRUCTURE.elementsPerHeight;\n  const stride =\n    structure.stride ?? HeightmapTessellator.DEFAULT_STRUCTURE.stride;\n  const elementMultiplier =\n    structure.elementMultiplier ??\n    HeightmapTessellator.DEFAULT_STRUCTURE.elementMultiplier;\n  const isBigEndian =\n    structure.isBigEndian ?? HeightmapTessellator.DEFAULT_STRUCTURE.isBigEndian;\n\n  let rectangleWidth = Rectangle.computeWidth(nativeRectangle);\n  let rectangleHeight = Rectangle.computeHeight(nativeRectangle);\n\n  const granularityX = rectangleWidth / (width - 1);\n  const granularityY = rectangleHeight / (height - 1);\n\n  if (!isGeographic) {\n    rectangleWidth *= oneOverGlobeSemimajorAxis;\n    rectangleHeight *= oneOverGlobeSemimajorAxis;\n  }\n\n  const radiiSquared = ellipsoid.radiiSquared;\n  const radiiSquaredX = radiiSquared.x;\n  const radiiSquaredY = radiiSquared.y;\n  const radiiSquaredZ = radiiSquared.z;\n\n  let minimumHeight = 65536.0;\n  let maximumHeight = -65536.0;\n\n  const fromENU = Transforms.eastNorthUpToFixedFrame(\n    relativeToCenter,\n    ellipsoid,\n  );\n  const toENU = Matrix4.inverseTransformation(fromENU, matrix4Scratch);\n\n  let southMercatorY;\n  let oneOverMercatorHeight;\n  if (includeWebMercatorT) {\n    southMercatorY =\n      WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicSouth);\n    oneOverMercatorHeight =\n      1.0 /\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicNorth) -\n        southMercatorY);\n  }\n\n  const minimum = minimumScratch;\n  minimum.x = Number.POSITIVE_INFINITY;\n  minimum.y = Number.POSITIVE_INFINITY;\n  minimum.z = Number.POSITIVE_INFINITY;\n\n  const maximum = maximumScratch;\n  maximum.x = Number.NEGATIVE_INFINITY;\n  maximum.y = Number.NEGATIVE_INFINITY;\n  maximum.z = Number.NEGATIVE_INFINITY;\n\n  let hMin = Number.POSITIVE_INFINITY;\n\n  const gridVertexCount = width * height;\n  const edgeVertexCount = skirtHeight > 0.0 ? width * 2 + height * 2 : 0;\n  const vertexCount = gridVertexCount + edgeVertexCount;\n\n  const positions = new Array(vertexCount);\n  const heights = new Array(vertexCount);\n  const uvs = new Array(vertexCount);\n  const webMercatorTs = includeWebMercatorT ? new Array(vertexCount) : [];\n  const geodeticSurfaceNormals = includeGeodeticSurfaceNormals\n    ? new Array(vertexCount)\n    : [];\n\n  let startRow = 0;\n  let endRow = height;\n  let startCol = 0;\n  let endCol = width;\n\n  if (hasSkirts) {\n    --startRow;\n    ++endRow;\n    --startCol;\n    ++endCol;\n  }\n\n  const skirtOffsetPercentage = 0.00001;\n\n  for (let rowIndex = startRow; rowIndex < endRow; ++rowIndex) {\n    let row = rowIndex;\n    if (row < 0) {\n      row = 0;\n    }\n    if (row >= height) {\n      row = height - 1;\n    }\n\n    let latitude = nativeRectangle.north - granularityY * row;\n\n    if (!isGeographic) {\n      latitude =\n        piOverTwo - 2.0 * atan(exp(-latitude * oneOverGlobeSemimajorAxis));\n    } else {\n      latitude = toRadians(latitude);\n    }\n\n    let v = (latitude - geographicSouth) / (geographicNorth - geographicSouth);\n    v = CesiumMath.clamp(v, 0.0, 1.0);\n\n    const isNorthEdge = rowIndex === startRow;\n    const isSouthEdge = rowIndex === endRow - 1;\n    if (skirtHeight > 0.0) {\n      if (isNorthEdge) {\n        latitude += skirtOffsetPercentage * rectangleHeight;\n      } else if (isSouthEdge) {\n        latitude -= skirtOffsetPercentage * rectangleHeight;\n      }\n    }\n\n    const cosLatitude = cos(latitude);\n    const nZ = sin(latitude);\n    const kZ = radiiSquaredZ * nZ;\n\n    let webMercatorT;\n    if (includeWebMercatorT) {\n      webMercatorT =\n        (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) -\n          southMercatorY) *\n        oneOverMercatorHeight;\n    }\n\n    for (let colIndex = startCol; colIndex < endCol; ++colIndex) {\n      let col = colIndex;\n      if (col < 0) {\n        col = 0;\n      }\n      if (col >= width) {\n        col = width - 1;\n      }\n\n      const terrainOffset = row * (width * stride) + col * stride;\n\n      let heightSample;\n      if (elementsPerHeight === 1) {\n        heightSample = heightmap[terrainOffset];\n      } else {\n        heightSample = 0;\n\n        let elementOffset;\n        if (isBigEndian) {\n          for (\n            elementOffset = 0;\n            elementOffset < elementsPerHeight;\n            ++elementOffset\n          ) {\n            heightSample =\n              heightSample * elementMultiplier +\n              heightmap[terrainOffset + elementOffset];\n          }\n        } else {\n          for (\n            elementOffset = elementsPerHeight - 1;\n            elementOffset >= 0;\n            --elementOffset\n          ) {\n            heightSample =\n              heightSample * elementMultiplier +\n              heightmap[terrainOffset + elementOffset];\n          }\n        }\n      }\n\n      heightSample = heightSample * heightScale + heightOffset;\n\n      maximumHeight = Math.max(maximumHeight, heightSample);\n      minimumHeight = Math.min(minimumHeight, heightSample);\n\n      let longitude = nativeRectangle.west + granularityX * col;\n\n      if (!isGeographic) {\n        longitude = longitude * oneOverGlobeSemimajorAxis;\n      } else {\n        longitude = toRadians(longitude);\n      }\n\n      let u = (longitude - geographicWest) / (geographicEast - geographicWest);\n      u = CesiumMath.clamp(u, 0.0, 1.0);\n\n      let index = row * width + col;\n\n      if (skirtHeight > 0.0) {\n        const isWestEdge = colIndex === startCol;\n        const isEastEdge = colIndex === endCol - 1;\n        const isEdge = isNorthEdge || isSouthEdge || isWestEdge || isEastEdge;\n        const isCorner =\n          (isNorthEdge || isSouthEdge) && (isWestEdge || isEastEdge);\n        if (isCorner) {\n          // Don't generate skirts on the corners.\n          continue;\n        } else if (isEdge) {\n          heightSample -= skirtHeight;\n\n          if (isWestEdge) {\n            // The outer loop iterates north to south but the indices are ordered south to north, hence the index flip below\n            index = gridVertexCount + (height - row - 1);\n            longitude -= skirtOffsetPercentage * rectangleWidth;\n          } else if (isSouthEdge) {\n            // Add after west indices. South indices are ordered east to west.\n            index = gridVertexCount + height + (width - col - 1);\n          } else if (isEastEdge) {\n            // Add after west and south indices. East indices are ordered north to south. The index is flipped like above.\n            index = gridVertexCount + height + width + row;\n            longitude += skirtOffsetPercentage * rectangleWidth;\n          } else if (isNorthEdge) {\n            // Add after west, south, and east indices. North indices are ordered west to east.\n            index = gridVertexCount + height + width + height + col;\n          }\n        }\n      }\n\n      const nX = cosLatitude * cos(longitude);\n      const nY = cosLatitude * sin(longitude);\n\n      const kX = radiiSquaredX * nX;\n      const kY = radiiSquaredY * nY;\n\n      const gamma = sqrt(kX * nX + kY * nY + kZ * nZ);\n      const oneOverGamma = 1.0 / gamma;\n\n      const rSurfaceX = kX * oneOverGamma;\n      const rSurfaceY = kY * oneOverGamma;\n      const rSurfaceZ = kZ * oneOverGamma;\n\n      const position = new Cartesian3();\n      position.x = rSurfaceX + nX * heightSample;\n      position.y = rSurfaceY + nY * heightSample;\n      position.z = rSurfaceZ + nZ * heightSample;\n\n      Matrix4.multiplyByPoint(toENU, position, cartesian3Scratch);\n      Cartesian3.minimumByComponent(cartesian3Scratch, minimum, minimum);\n      Cartesian3.maximumByComponent(cartesian3Scratch, maximum, maximum);\n      hMin = Math.min(hMin, heightSample);\n\n      positions[index] = position;\n      uvs[index] = new Cartesian2(u, v);\n      heights[index] = heightSample;\n\n      if (includeWebMercatorT) {\n        webMercatorTs[index] = webMercatorT;\n      }\n\n      if (includeGeodeticSurfaceNormals) {\n        geodeticSurfaceNormals[index] =\n          ellipsoid.geodeticSurfaceNormal(position);\n      }\n    }\n  }\n\n  const boundingSphere3D = BoundingSphere.fromPoints(positions);\n  let orientedBoundingBox;\n  if (defined(rectangle)) {\n    orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n      rectangle,\n      minimumHeight,\n      maximumHeight,\n      ellipsoid,\n    );\n  }\n\n  let occludeePointInScaledSpace;\n  if (hasRelativeToCenter) {\n    const occluder = new EllipsoidalOccluder(ellipsoid);\n    occludeePointInScaledSpace =\n      occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n        relativeToCenter,\n        positions,\n        minimumHeight,\n      );\n  }\n\n  const aaBox = new AxisAlignedBoundingBox(minimum, maximum, relativeToCenter);\n  const encoding = new TerrainEncoding(\n    relativeToCenter,\n    aaBox,\n    hMin,\n    maximumHeight,\n    fromENU,\n    false,\n    includeWebMercatorT,\n    includeGeodeticSurfaceNormals,\n    exaggeration,\n    exaggerationRelativeHeight,\n  );\n  const vertices = new Float32Array(vertexCount * encoding.stride);\n\n  let bufferIndex = 0;\n  for (let j = 0; j < vertexCount; ++j) {\n    bufferIndex = encoding.encode(\n      vertices,\n      bufferIndex,\n      positions[j],\n      uvs[j],\n      heights[j],\n      undefined,\n      webMercatorTs[j],\n      geodeticSurfaceNormals[j],\n    );\n  }\n\n  return {\n    vertices: vertices,\n    maximumHeight: maximumHeight,\n    minimumHeight: minimumHeight,\n    encoding: encoding,\n    boundingSphere3D: boundingSphere3D,\n    orientedBoundingBox: orientedBoundingBox,\n    occludeePointInScaledSpace: occludeePointInScaledSpace,\n  };\n};\nexport default HeightmapTessellator;\n"],"names":["HeightmapTessellator","DEFAULT_STRUCTURE","Object","freeze","heightScale","heightOffset","elementsPerHeight","stride","elementMultiplier","isBigEndian","cartesian3Scratch","matrix4Scratch","minimumScratch","maximumScratch","computeVertices","options","heightmap","width","height","nativeRectangle","skirtHeight","cos","Math","sin","sqrt","atan","exp","piOverTwo","PI_OVER_TWO","toRadians","hasSkirts","isGeographic","ellipsoid","default","oneOverGlobeSemimajorAxis","maximumRadius","clone","rectangle","geographicWest","geographicSouth","geographicEast","geographicNorth","west","south","east","north","relativeToCenter","hasRelativeToCenter","ZERO","includeWebMercatorT","exaggeration","exaggerationRelativeHeight","hasExaggeration","includeGeodeticSurfaceNormals","structure","rectangleWidth","computeWidth","rectangleHeight","computeHeight","granularityX","granularityY","radiiSquared","radiiSquaredX","x","radiiSquaredY","y","radiiSquaredZ","z","minimumHeight","maximumHeight","fromENU","eastNorthUpToFixedFrame","toENU","inverseTransformation","southMercatorY","oneOverMercatorHeight","geodeticLatitudeToMercatorAngle","minimum","Number","POSITIVE_INFINITY","maximum","NEGATIVE_INFINITY","hMin","gridVertexCount","edgeVertexCount","vertexCount","positions","Array","heights","uvs","webMercatorTs","geodeticSurfaceNormals","startRow","endRow","startCol","endCol","skirtOffsetPercentage","rowIndex","row","latitude","v","clamp","isNorthEdge","isSouthEdge","cosLatitude","nZ","kZ","webMercatorT","colIndex","col","terrainOffset","heightSample","elementOffset","max","min","longitude","u","index","isWestEdge","isEastEdge","isEdge","isCorner","nX","nY","kX","kY","gamma","oneOverGamma","rSurfaceX","rSurfaceY","rSurfaceZ","position","multiplyByPoint","minimumByComponent","maximumByComponent","geodeticSurfaceNormal","boundingSphere3D","fromPoints","orientedBoundingBox","fromRectangle","occludeePointInScaledSpace","occluder","computeHorizonCullingPointPossiblyUnderEllipsoid","aaBox","encoding","vertices","Float32Array","bufferIndex","j","encode","undefined"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 55635, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TerrainData.js"],"sourcesContent":["import DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Terrain data for a single tile.  This type describes an\n * interface and is not intended to be instantiated directly.\n *\n * @alias TerrainData\n * @constructor\n *\n * @see HeightmapTerrainData\n * @see QuantizedMeshTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n * @see Cesium3DTilesTerrainData\n */\nfunction TerrainData() {\n  DeveloperError.throwInstantiationError();\n}\n\nObject.defineProperties(TerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof TerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: DeveloperError.throwInstantiationError,\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof TerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement|ImageBitmap|undefined}\n   */\n  waterMask: {\n    get: DeveloperError.throwInstantiationError,\n  },\n});\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n * @function\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {number} longitude The longitude in radians.\n * @param {number} latitude The latitude in radians.\n * @returns {number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\nTerrainData.prototype.interpolateHeight =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link TerrainData#childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n * @function\n *\n * @param {number} thisX The tile X coordinate of this (the parent) tile.\n * @param {number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {number} childX The tile X coordinate of the child tile to check for availability.\n * @param {number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {boolean} True if the child tile is available; otherwise, false.\n */\nTerrainData.prototype.isChildAvailable = DeveloperError.throwInstantiationError;\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n * @function\n *\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {number} options.level The level of the tile for which to create the terrain data.\n * @param {number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {number} [options.exaggerationRelativeHeight=0.0] The height relative to which terrain is exaggerated.\n * @param {boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nTerrainData.prototype.createMesh = DeveloperError.throwInstantiationError;\n\n/**\n * Upsamples this terrain data for use by a descendant tile.\n * @function\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {number} thisLevel The level of this tile in the tiling scheme.\n * @param {number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise<TerrainData>|undefined} A promise for upsampled terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\nTerrainData.prototype.upsample = DeveloperError.throwInstantiationError;\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link TerrainData#upsample}.\n * @function\n *\n * @returns {boolean} True if this instance was created by upsampling; otherwise, false.\n */\nTerrainData.prototype.wasCreatedByUpsampling =\n  DeveloperError.throwInstantiationError;\n\n/**\n * The maximum number of asynchronous tasks used for terrain processing.\n *\n * @type {number}\n * @private\n */\nTerrainData.maximumAsynchronousTasks = 5;\n\nexport default TerrainData;\n"],"names":["TerrainData","throwInstantiationError","Object","defineProperties","prototype","credits","get","waterMask","interpolateHeight","isChildAvailable","createMesh","upsample","wasCreatedByUpsampling","maximumAsynchronousTasks"],"mappings":";;;;AAAA;;AAEA;;;;;;;;;;;CAWC,GACD,SAASA;IACP,oLAAc,CAACC,uBAAuB;AACxC;AAEAC,OAAOC,gBAAgB,CAACH,YAAYI,SAAS,EAAE;IAC7C;;;;GAIC,GACDC,SAAS;QACPC,KAAK,oLAAc,CAACL,uBAAuB;IAC7C;IACA;;;;;;GAMC,GACDM,WAAW;QACTD,KAAK,oLAAc,CAACL,uBAAuB;IAC7C;AACF;AAEA;;;;;;;;;;CAUC,GACDD,YAAYI,SAAS,CAACI,iBAAiB,GACrC,oLAAc,CAACP,uBAAuB;AAExC;;;;;;;;;;;;CAYC,GACDD,YAAYI,SAAS,CAACK,gBAAgB,GAAG,oLAAc,CAACR,uBAAuB;AAE/E;;;;;;;;;;;;;;;;;CAiBC,GACDD,YAAYI,SAAS,CAACM,UAAU,GAAG,oLAAc,CAACT,uBAAuB;AAEzE;;;;;;;;;;;;;;CAcC,GACDD,YAAYI,SAAS,CAACO,QAAQ,GAAG,oLAAc,CAACV,uBAAuB;AAEvE;;;;;;;;CAQC,GACDD,YAAYI,SAAS,CAACQ,sBAAsB,GAC1C,oLAAc,CAACX,uBAAuB;AAExC;;;;;CAKC,GACDD,YAAYa,wBAAwB,GAAG;uCAExBb","ignoreList":[0]}},
    {"offset": {"line": 55750, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TerrainPicker.js"],"sourcesContent":["import AxisAlignedBoundingBox from \"./AxisAlignedBoundingBox.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Ray from \"./Ray.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport Interval from \"./Interval.js\";\nimport Check from \"./Check.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n// Terrain picker can be 4 levels deep (0-3)\nconst MAXIMUM_TERRAIN_PICKER_LEVEL = 3;\n\n/**\n * Creates an object that handles arbitrary ray intersections with a terrain mesh using a spatial acceleration structure.\n *\n * @alias TerrainPicker\n * @constructor\n *\n * @param {Float32Array} vertices The terrain mesh's vertex buffer.\n * @param {Uint8Array|Uint16Array|Uint32Array} indices The terrain mesh's index buffer.\n * @param {TerrainEncoding} encoding The terrain mesh's vertex encoding.\n *\n * @private\n */\nfunction TerrainPicker(vertices, indices, encoding) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"vertices\", vertices);\n  Check.defined(\"indices\", indices);\n  Check.defined(\"encoding\", encoding);\n  //>>includeEnd('debug');\n\n  /**\n   * The terrain mesh's vertex buffer.\n   * @type {Float32Array}\n   */\n  this._vertices = vertices;\n  /**\n   * The terrain mesh's index buffer.\n   * @type {Uint32Array}\n   */\n  this._indices = indices;\n  /**\n   * The terrain mesh's vertex encoding.\n   * @type {TerrainEncoding}\n   */\n  this._encoding = encoding;\n  /**\n   * The inverse of the terrain mesh tile's transform from world space to local space.\n   * @type {Matrix4}\n   */\n  this._inverseTransform = new Matrix4(); // Compute as-needed on rebuild\n  /**\n   * Whether or not to reset this terrain mesh's picker on the next ray intersection.\n   * @type {Boolean}\n   */\n  this._needsRebuild = true;\n  /**\n   * The root node of the terrain picker's quadtree.\n   * @type {TerrainPickerNode}\n   */\n  this._rootNode = new TerrainPickerNode();\n}\n\nconst incrementallyBuildTerrainPickerTaskProcessor = new TaskProcessor(\n  \"incrementallyBuildTerrainPicker\",\n);\n\nObject.defineProperties(TerrainPicker.prototype, {\n  /**\n   * Indicates whether the terrain picker needs to be rebuilt due to changes in the underlying terrain mesh's vertices or indices.\n   * @type {boolean}\n   */\n  needsRebuild: {\n    get: function () {\n      return this._needsRebuild;\n    },\n    set: function (value) {\n      this._needsRebuild = value;\n    },\n  },\n});\n\n/**\n * A node in the terrain picker quadtree.\n * @constructor\n * @private\n */\nfunction TerrainPickerNode() {\n  /**\n   * The tree-space x-coordinate of this node.\n   * @type {Number}\n   */\n  this.x = 0;\n  /**\n   * The tree-space y-coordinate of this node.\n   * @type {Number}\n   */\n  this.y = 0;\n  /**\n   * The level of this node in the quadtree.\n   * @type {Number}\n   */\n  this.level = 0;\n  /**\n   * The axis-aligned bounding box of this node (in the tree's local space).\n   * @type {AxisAlignedBoundingBox}\n   */\n  this.aabb = createAABBForNode(this.x, this.y, this.level);\n  /**\n   * The indices of the triangles that intersect this node.\n   * @type {Uint32Array}\n   */\n  this.intersectingTriangles = new Uint32Array(0);\n  /**\n   * The child terrain picker nodes of this node.\n   * @type {TerrainPickerNode[]}\n   */\n  this.children = [];\n  /**\n   * Whether or not this node is currently building its children on a worker.\n   * @type {Boolean}\n   */\n  this.buildingChildren = false;\n}\n\n/**\n * Adds a child node to this node.\n *\n * @param {number} childIdx The index of the child to add (0-3).\n * @memberof TerrainPickerNode\n */\nTerrainPickerNode.prototype.addChild = function (childIdx) {\n  //>>includeStart('debug', pragmas.debug);\n  if (childIdx < 0 || childIdx > 3) {\n    throw new DeveloperError(\n      \"TerrainPickerNode child index must be between 0 and 3, inclusive.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const childNode = new TerrainPickerNode();\n  // Use bitwise operations to get child x,y from child index and parent x,y\n  childNode.x = this.x * 2 + (childIdx & 1);\n  childNode.y = this.y * 2 + ((childIdx >> 1) & 1);\n  childNode.level = this.level + 1;\n  childNode.aabb = createAABBForNode(childNode.x, childNode.y, childNode.level);\n\n  this.children[childIdx] = childNode;\n};\n\nconst scratchTransformedRay = new Ray();\nconst scratchTrianglePoints = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\n\n/**\n * Determines the point on the mesh where the given ray intersects.\n * @param {Ray} ray The ray to test.\n * @param {Matrix4} tileTransform The terrain mesh tile's transform from local space to world space.\n * @param {Boolean} cullBackFaces Whether to consider back-facing triangles as intersections.\n * @param {SceneMode} mode The scene mode (2D/3D/Columbus View).\n * @param {MapProjection} projection The map projection.\n * @returns {Cartesian3 | undefined} result The intersection point, or undefined if there is no intersection.\n * @memberof TerrainPicker\n * @private\n */\nTerrainPicker.prototype.rayIntersect = function (\n  ray,\n  tileTransform,\n  cullBackFaces,\n  mode,\n  projection,\n) {\n  // Lazily (re)create the terrain picker\n  if (this._needsRebuild) {\n    reset(this, tileTransform);\n  }\n\n  const invTransform = this._inverseTransform;\n\n  const transformedRay = scratchTransformedRay;\n\n  transformedRay.origin = Matrix4.multiplyByPoint(\n    invTransform,\n    ray.origin,\n    transformedRay.origin,\n  );\n  transformedRay.direction = Matrix4.multiplyByPointAsVector(\n    invTransform,\n    ray.direction,\n    transformedRay.direction,\n  );\n\n  const intersections = [];\n  getNodesIntersectingRay(this._rootNode, transformedRay, intersections);\n\n  return findClosestPointInClosestNode(\n    this,\n    intersections,\n    ray,\n    cullBackFaces,\n    mode,\n    projection,\n  );\n};\n\n/**\n * Resets the terrain picker's quadtree structure to just the root node. Done whenever the underlying terrain mesh changes.\n * @param terrainPicker The terrain picker to reset.\n * @private\n */\nfunction reset(terrainPicker, tileTransform) {\n  // PERFORMANCE_IDEA: warm-start the terrain picker by building a level on a worker.\n  // This currently isn't feasible because you can only copy the vertex buffer to a worker (slow) or transfer ownership (can't do picking on main thread in meantime).\n  // SharedArrayBuffers could be used, but most environments do not support them.\n  Matrix4.inverse(tileTransform, terrainPicker._inverseTransform);\n\n  terrainPicker._needsRebuild = false;\n  const triangleCount = terrainPicker._indices.length / 3;\n  const intersectingTriangles = new Uint32Array(triangleCount);\n\n  for (let i = 0; i < triangleCount; ++i) {\n    intersectingTriangles[i] = i;\n  }\n\n  terrainPicker._rootNode.intersectingTriangles = intersectingTriangles;\n  terrainPicker._rootNode.children.length = 0;\n}\n\nconst scratchAABBMin = new Cartesian3();\nconst scratchAABBMax = new Cartesian3();\n\n/**\n * Creates an axis-aligned bounding box for a quadtree node at the given tree-space coordinates and level.\n * This AABB is in the tree's local space (where the root node of the tree is a unit cube in its own local space).\n *\n * @param {number} x The x coordinate of the node.\n * @param {number} y The y coordinate of the node.\n * @param {number} level The level of the node.\n * @returns {AxisAlignedBoundingBox} The axis-aligned bounding box for the node.\n */\nfunction createAABBForNode(x, y, level) {\n  const sizeAtLevel = 1.0 / Math.pow(2, level);\n\n  const aabbMin = Cartesian3.fromElements(\n    x * sizeAtLevel - 0.5,\n    y * sizeAtLevel - 0.5,\n    -0.5,\n    scratchAABBMin,\n  );\n\n  const aabbMax = Cartesian3.fromElements(\n    (x + 1) * sizeAtLevel - 0.5,\n    (y + 1) * sizeAtLevel - 0.5,\n    0.5,\n    scratchAABBMax,\n  );\n\n  return AxisAlignedBoundingBox.fromCorners(aabbMin, aabbMax);\n}\n\n/**\n * Packs triangle vertex positions and index into provided buffers, for the worker to process.\n * (The worker does tests to organize triangles into child nodes of the quadtree.)\n * @param {Float32Array} trianglePositionsBuffer The buffer to pack triangle vertex positions into.\n * @param {Uint32Array} triangleIndicesBuffer The buffer to pack triangle indices into.\n * @param {Cartesian3[]} trianglePositions The triangle's vertex positions.\n * @param {number} triangleIndex The triangle's index in the overall tile's index buffer.\n * @param {number} bufferIndex The index to use to pack into the buffers.\n * @private\n */\nfunction packTriangleBuffers(\n  trianglePositionsBuffer,\n  triangleIndicesBuffer,\n  trianglePositions,\n  triangleIndex,\n  bufferIndex,\n) {\n  Cartesian3.pack(\n    trianglePositions[0],\n    trianglePositionsBuffer,\n    9 * bufferIndex,\n  );\n  Cartesian3.pack(\n    trianglePositions[1],\n    trianglePositionsBuffer,\n    9 * bufferIndex + 3,\n  );\n  Cartesian3.pack(\n    trianglePositions[2],\n    trianglePositionsBuffer,\n    9 * bufferIndex + 6,\n  );\n  triangleIndicesBuffer[bufferIndex] = triangleIndex;\n}\n\n/**\n * @typedef {Object} IntersectingNode\n * @property {TerrainPickerNode} node - The intersecting quadtree node.\n * @property {Interval} interval - The interval along the ray where the intersection occurs.\n * @private\n */\n\nconst scratchInterval = new Interval();\n\n/**\n * Recursively gathers all nodes in the quadtree that intersect the ray.\n *\n * @param {TerrainPickerNode} currentNode The current node being tested.\n * @param {Ray} ray The ray to test.\n * @param {IntersectingNode[]} intersectingNodes The array to store intersecting nodes in.\n * @private\n */\nfunction getNodesIntersectingRay(currentNode, ray, intersectingNodes) {\n  const interval = IntersectionTests.rayAxisAlignedBoundingBox(\n    ray,\n    currentNode.aabb,\n    scratchInterval,\n  );\n\n  if (!defined(interval)) {\n    return;\n  }\n\n  const isLeaf = !currentNode.children.length || currentNode.buildingChildren;\n  if (isLeaf) {\n    intersectingNodes.push({\n      node: currentNode,\n      interval: new Interval(interval.start, interval.stop),\n    });\n    return;\n  }\n\n  for (let i = 0; i < currentNode.children.length; i++) {\n    getNodesIntersectingRay(currentNode.children[i], ray, intersectingNodes);\n  }\n}\n\n/**\n * Finds the closest intersecting node along the ray, in world space, and the closest point in that node,\n * by testing all triangles in the closest node against the ray.\n *\n * @param {TerrainPicker} terrainPicker The terrain picker.\n * @param {IntersectingNode[]} intersections The nodes that intersect the ray, along with the intersection intervals along said ray.\n * @param {Ray} ray The ray to test.\n * @param {boolean} cullBackFaces Whether to cull back faces.\n * @param {SceneMode} mode The scene mode (2D/3D/Columbus View).\n * @param {MapProjection} projection The map projection.\n * @returns The closest point in world space, or undefined if no intersection.\n * @private\n */\nfunction findClosestPointInClosestNode(\n  terrainPicker,\n  intersections,\n  ray,\n  cullBackFaces,\n  mode,\n  projection,\n) {\n  const sortedIntersections = intersections.sort(function (a, b) {\n    return a.interval.start - b.interval.start;\n  });\n\n  let minT = Number.MAX_VALUE;\n  for (let i = 0; i < sortedIntersections.length; i++) {\n    const intersection = sortedIntersections[i];\n    const intersectionResult = getClosestTriangleInNode(\n      terrainPicker,\n      ray,\n      intersection.node,\n      cullBackFaces,\n      mode,\n      projection,\n    );\n    minT = Math.min(intersectionResult, minT);\n    if (minT !== Number.MAX_VALUE) {\n      break;\n    }\n  }\n\n  if (minT !== Number.MAX_VALUE) {\n    return Ray.getPoint(ray, minT);\n  }\n\n  return undefined;\n}\n\n/**\n * Test all triangles in the given node against the ray, returning the closest intersection t value along the ray.\n * Additionally, collect the triangles' positions and indices along the way to launch worker process that uses them to build out child nodes.\n *\n * @param {TerrainPicker} terrainPicker The terrain picker.\n * @param {Ray} ray The ray to test.\n * @param {TerrainPickerNode} node The node to test.\n * @param {boolean} cullBackFaces Whether to cull back faces.\n * @param {SceneMode} mode The scene mode (2D/3D/Columbus View).\n * @param {MapProjection} projection The map projection.\n * @returns {number} The closest intersection t value along the ray, or Number.MAX_VALUE if no intersection.\n * @private\n */\nfunction getClosestTriangleInNode(\n  terrainPicker,\n  ray,\n  node,\n  cullBackFaces,\n  mode,\n  projection,\n) {\n  let result = Number.MAX_VALUE;\n  const encoding = terrainPicker._encoding;\n  const indices = terrainPicker._indices;\n  const vertices = terrainPicker._vertices;\n  const triangleCount = node.intersectingTriangles.length;\n  const isMaxLevel = node.level >= MAXIMUM_TERRAIN_PICKER_LEVEL;\n  const shouldBuildChildren = !isMaxLevel && !node.buildingChildren;\n\n  let trianglePositions;\n  let triangleIndices;\n  if (shouldBuildChildren) {\n    // If the tree can be built deeper, prepare buffers to store triangle data for child nodes\n    trianglePositions = new Float32Array(triangleCount * 9); // 3 vertices per triangle * 3 floats per vertex\n    triangleIndices = new Uint32Array(triangleCount);\n  }\n\n  for (let i = 0; i < triangleCount; i++) {\n    const triIndex = node.intersectingTriangles[i];\n    const v0 = getVertexPosition(\n      encoding,\n      mode,\n      projection,\n      vertices,\n      indices[3 * triIndex],\n      scratchTrianglePoints[0],\n    );\n    const v1 = getVertexPosition(\n      encoding,\n      mode,\n      projection,\n      vertices,\n      indices[3 * triIndex + 1],\n      scratchTrianglePoints[1],\n    );\n    const v2 = getVertexPosition(\n      encoding,\n      mode,\n      projection,\n      vertices,\n      indices[3 * triIndex + 2],\n      scratchTrianglePoints[2],\n    );\n\n    const triT = IntersectionTests.rayTriangleParametric(\n      ray,\n      v0,\n      v1,\n      v2,\n      cullBackFaces,\n    );\n\n    if (defined(triT) && triT < result && triT >= 0) {\n      result = triT;\n    }\n\n    if (shouldBuildChildren) {\n      packTriangleBuffers(\n        trianglePositions,\n        triangleIndices,\n        scratchTrianglePoints,\n        triIndex,\n        i,\n      );\n    }\n  }\n\n  if (shouldBuildChildren) {\n    for (let childIdx = 0; childIdx < 4; childIdx++) {\n      node.addChild(childIdx);\n    }\n\n    addTrianglesToChildrenNodes(\n      terrainPicker._inverseTransform,\n      node,\n      triangleIndices,\n      trianglePositions,\n    );\n  }\n\n  return result;\n}\n\nconst scratchCartographic = new Cartographic();\n\n/**\n * Gets a vertex position from the buffer, taking into account the exaggeration and scene mode of the terrain.\n *\n * @param {TerrainEncoding} encoding The terrain encoding.\n * @param {SceneMode} mode The scene mode (2D/3D/Columbus View).\n * @param {MapProjection} projection The map projection.\n * @param {Float32Array} vertices The vertex buffer of the terrain mesh.\n * @param {Number} index The index of the vertex to get.\n * @param {Cartesian3} result The decoded, exaggerated, and possibly projected vertex position.\n * @returns {Cartesian3} The result vertex position.\n * @private\n */\nfunction getVertexPosition(\n  encoding,\n  mode,\n  projection,\n  vertices,\n  index,\n  result,\n) {\n  let position = encoding.getExaggeratedPosition(vertices, index, result);\n  if (mode === SceneMode.SCENE3D) {\n    return position;\n  }\n\n  const ellipsoid = projection.ellipsoid;\n  const positionCartographic = ellipsoid.cartesianToCartographic(\n    position,\n    scratchCartographic,\n  );\n  position = projection.project(positionCartographic, result);\n  // Swizzle because coordinate basis are different in 2D/Columbus View\n  position = Cartesian3.fromElements(\n    position.z,\n    position.x,\n    position.y,\n    result,\n  );\n\n  return position;\n}\n\n/**\n * Adds triangles to the child nodes of the given node by launching a worker process to do AABB-triangle testing.\n *\n * @param {Matrix4} inverseTransform\n * @param {TerrainNode} node\n * @param {Uint32Array} triangleIndices\n * @param {Float32Array} trianglePositions\n * @returns {Promise<void>} A promise that resolves when the triangles have been added to the child nodes.\n * @private\n */\nasync function addTrianglesToChildrenNodes(\n  inverseTransform,\n  node,\n  triangleIndices,\n  trianglePositions,\n) {\n  node.buildingChildren = true;\n\n  // Prepare data to be sent to a worker\n  const inverseTransformPacked = new Float64Array(16);\n  Matrix4.pack(inverseTransform, inverseTransformPacked, 0);\n\n  const aabbArray = new Float64Array(6 * 4); // 6 elements per AABB, 4 children\n  for (let i = 0; i < 4; i++) {\n    Cartesian3.pack(node.children[i].aabb.minimum, aabbArray, i * 6);\n    Cartesian3.pack(node.children[i].aabb.maximum, aabbArray, i * 6 + 3);\n  }\n\n  const parameters = {\n    aabbs: aabbArray,\n    inverseTransform: inverseTransformPacked,\n    triangleIndices: triangleIndices,\n    trianglePositions: trianglePositions,\n  };\n\n  const transferableObjects = [\n    aabbArray.buffer,\n    inverseTransformPacked.buffer,\n    triangleIndices.buffer,\n    trianglePositions.buffer,\n  ];\n\n  const incrementallyBuildTerrainPickerPromise =\n    incrementallyBuildTerrainPickerTaskProcessor.scheduleTask(\n      parameters,\n      transferableObjects,\n    );\n\n  if (!defined(incrementallyBuildTerrainPickerPromise)) {\n    // Failed to schedule task, retry on next pick\n    node.buildingChildren = false;\n    return;\n  }\n\n  // After worker completes, it transfers back a buffer of intersecting triangles for each child node\n  // Assign these to the child nodes\n  const result = await incrementallyBuildTerrainPickerPromise;\n  result.intersectingTrianglesArrays.forEach((buffer, index) => {\n    node.children[index].intersectingTriangles = new Uint32Array(buffer);\n  });\n\n  // The node's triangles have been distributed to its children\n  node.intersectingTriangles = new Uint32Array(0);\n  node.buildingChildren = false;\n}\n\nexport default TerrainPicker;\n"],"names":["MAXIMUM_TERRAIN_PICKER_LEVEL","TerrainPicker","vertices","indices","encoding","defined","_vertices","_indices","_encoding","_inverseTransform","_needsRebuild","_rootNode","TerrainPickerNode","incrementallyBuildTerrainPickerTaskProcessor","Object","defineProperties","prototype","needsRebuild","get","set","value","x","y","level","aabb","createAABBForNode","intersectingTriangles","Uint32Array","children","buildingChildren","addChild","childIdx","childNode","scratchTransformedRay","scratchTrianglePoints","rayIntersect","ray","tileTransform","cullBackFaces","mode","projection","reset","invTransform","transformedRay","origin","multiplyByPoint","direction","multiplyByPointAsVector","intersections","getNodesIntersectingRay","findClosestPointInClosestNode","terrainPicker","inverse","triangleCount","length","i","scratchAABBMin","scratchAABBMax","sizeAtLevel","Math","pow","aabbMin","fromElements","aabbMax","fromCorners","packTriangleBuffers","trianglePositionsBuffer","triangleIndicesBuffer","trianglePositions","triangleIndex","bufferIndex","pack","scratchInterval","currentNode","intersectingNodes","interval","rayAxisAlignedBoundingBox","isLeaf","push","node","start","stop","sortedIntersections","sort","a","b","minT","Number","MAX_VALUE","intersection","intersectionResult","getClosestTriangleInNode","min","getPoint","undefined","result","isMaxLevel","shouldBuildChildren","triangleIndices","Float32Array","triIndex","v0","getVertexPosition","v1","v2","triT","rayTriangleParametric","addTrianglesToChildrenNodes","scratchCartographic","index","position","getExaggeratedPosition","SCENE3D","ellipsoid","positionCartographic","cartesianToCartographic","project","z","inverseTransform","inverseTransformPacked","Float64Array","aabbArray","minimum","maximum","parameters","aabbs","transferableObjects","buffer","incrementallyBuildTerrainPickerPromise","scheduleTask","intersectingTrianglesArrays","forEach"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 56151, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TerrainMesh.js"],"sourcesContent":["import SceneMode from \"../Scene/SceneMode.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport TerrainPicker from \"./TerrainPicker.js\";\nimport Transforms from \"./Transforms.js\";\nimport VerticalExaggeration from \"./VerticalExaggeration.js\";\n\n/**\n * A mesh plus related metadata for a single tile of terrain.  Instances of this type are\n * usually created from raw {@link TerrainData}.\n *\n * @alias TerrainMesh\n * @constructor\n *\n * @param {Cartesian3} center The center of the tile.  Vertex positions are specified relative to this center.\n * @param {Float32Array} vertices The vertex data, including positions, texture coordinates, and heights.\n *                       The vertex data is in the order [X, Y, Z, H, U, V], where X, Y, and Z represent\n *                       the Cartesian position of the vertex, H is the height above the ellipsoid, and\n *                       U and V are the texture coordinates.\n * @param {Uint8Array|Uint16Array|Uint32Array} indices The indices describing how the vertices are connected to form triangles.\n * @param {number} indexCountWithoutSkirts The index count of the mesh not including skirts.\n * @param {number} vertexCountWithoutSkirts The vertex count of the mesh not including skirts.\n * @param {number} minimumHeight The lowest height in the tile, in meters above the ellipsoid.\n * @param {number} maximumHeight The highest height in the tile, in meters above the ellipsoid.\n * @param {Rectangle} rectangle The rectangle, in radians, covered by this tile.\n * @param {BoundingSphere} boundingSphere3D A bounding sphere that completely contains the tile.\n * @param {Cartesian3} occludeePointInScaledSpace The occludee point of the tile, represented in ellipsoid-\n *                     scaled space, and used for horizon culling.  If this point is below the horizon,\n *                     the tile is considered to be entirely below the horizon.\n * @param {number} [vertexStride=6] The number of components in each vertex.\n * @param {OrientedBoundingBox} [orientedBoundingBox] A bounding box that completely contains the tile.\n * @param {TerrainEncoding} encoding Information used to decode the mesh.\n * @param {number[]|Uint8Array|Uint16Array|Uint32Array} westIndicesSouthToNorth The indices of the vertices on the Western edge of the tile, ordered from South to North (clockwise).\n * @param {number[]|Uint8Array|Uint16Array|Uint32Array} southIndicesEastToWest The indices of the vertices on the Southern edge of the tile, ordered from East to West (clockwise).\n * @param {number[]|Uint8Array|Uint16Array|Uint32Array} eastIndicesNorthToSouth The indices of the vertices on the Eastern edge of the tile, ordered from North to South (clockwise).\n * @param {number[]|Uint8Array|Uint16Array|Uint32Array} northIndicesWestToEast The indices of the vertices on the Northern edge of the tile, ordered from West to East (clockwise).\n *\n * @private\n */\nfunction TerrainMesh(\n  center,\n  vertices,\n  indices,\n  indexCountWithoutSkirts,\n  vertexCountWithoutSkirts,\n  minimumHeight,\n  maximumHeight,\n  rectangle,\n  boundingSphere3D,\n  occludeePointInScaledSpace,\n  vertexStride,\n  orientedBoundingBox,\n  encoding,\n  westIndicesSouthToNorth,\n  southIndicesEastToWest,\n  eastIndicesNorthToSouth,\n  northIndicesWestToEast,\n) {\n  /**\n   * The center of the tile.  Vertex positions are specified relative to this center.\n   * @type {Cartesian3}\n   */\n  this.center = center;\n\n  /**\n   * The vertex data, including positions, texture coordinates, and heights.\n   * The vertex data is in the order [X, Y, Z, H, U, V], where X, Y, and Z represent\n   * the Cartesian position of the vertex, H is the height above the ellipsoid, and\n   * U and V are the texture coordinates.  The vertex data may have additional attributes after those\n   * mentioned above when the {@link TerrainMesh#stride} is greater than 6.\n   * @type {Float32Array}\n   */\n  this.vertices = vertices;\n\n  /**\n   * The number of components in each vertex.  Typically this is 6 for the 6 components\n   * [X, Y, Z, H, U, V], but if each vertex has additional data (such as a vertex normal), this value\n   * may be higher.\n   * @type {number}\n   */\n  this.stride = vertexStride ?? 6;\n\n  /**\n   * The indices describing how the vertices are connected to form triangles.\n   * @type {Uint8Array|Uint16Array|Uint32Array}\n   */\n  this.indices = indices;\n\n  /**\n   * The index count of the mesh not including skirts.\n   * @type {number}\n   */\n  this.indexCountWithoutSkirts = indexCountWithoutSkirts;\n\n  /**\n   * The vertex count of the mesh not including skirts.\n   * @type {number}\n   */\n  this.vertexCountWithoutSkirts = vertexCountWithoutSkirts;\n\n  /**\n   * The lowest height in the tile, in meters above the ellipsoid.\n   * @type {number}\n   */\n  this.minimumHeight = minimumHeight;\n\n  /**\n   * The highest height in the tile, in meters above the ellipsoid.\n   * @type {number}\n   */\n  this.maximumHeight = maximumHeight;\n\n  /**\n   * The rectangle, in radians, covered by this tile.\n   * @type {Rectangle}\n   */\n  this.rectangle = rectangle;\n\n  /**\n   * A bounding sphere that completely contains the tile.\n   * @type {BoundingSphere}\n   */\n  this.boundingSphere3D = boundingSphere3D;\n\n  /**\n   * The occludee point of the tile, represented in ellipsoid-\n   * scaled space, and used for horizon culling.  If this point is below the horizon,\n   * the tile is considered to be entirely below the horizon.\n   * @type {Cartesian3}\n   */\n  this.occludeePointInScaledSpace = occludeePointInScaledSpace;\n\n  /**\n   * A bounding box that completely contains the tile.\n   * @type {OrientedBoundingBox}\n   */\n  this.orientedBoundingBox = orientedBoundingBox;\n\n  /**\n   * Information for decoding the mesh vertices.\n   * @type {TerrainEncoding}\n   */\n  this.encoding = encoding;\n\n  /**\n   * The indices of the vertices on the Western edge of the tile, ordered from South to North (clockwise).\n   * @type {number[]|Uint8Array|Uint16Array|Uint32Array}\n   */\n  this.westIndicesSouthToNorth = westIndicesSouthToNorth;\n\n  /**\n   * The indices of the vertices on the Southern edge of the tile, ordered from East to West (clockwise).\n   * @type {number[]|Uint8Array|Uint16Array|Uint32Array}\n   */\n  this.southIndicesEastToWest = southIndicesEastToWest;\n\n  /**\n   * The indices of the vertices on the Eastern edge of the tile, ordered from North to South (clockwise).\n   * @type {number[]|Uint8Array|Uint16Array|Uint32Array}\n   */\n  this.eastIndicesNorthToSouth = eastIndicesNorthToSouth;\n\n  /**\n   * The indices of the vertices on the Northern edge of the tile, ordered from West to East (clockwise).\n   * @type {number[]|Uint8Array|Uint16Array|Uint32Array}\n   */\n  this.northIndicesWestToEast = northIndicesWestToEast;\n\n  /**\n   * The transform from model to world coordinates based on the terrain mesh's oriented bounding box.\n   * In 3D mode, this is computed from the oriented bounding box.  In 2D and Columbus View modes,\n   * this is computed from the tile's rectangle's projected coordinates.\n   * @type {Matrix4}\n   */\n  this._transform = new Matrix4();\n\n  /**\n   * True if the transform needs to be recomputed (due to changes in exaggeration or scene mode).\n   * @type {boolean}\n   */\n  this._recomputeTransform = true;\n\n  /**\n   * The terrain picker for this mesh, used for ray intersection tests.\n   * @type {TerrainPicker}\n   */\n  this._terrainPicker = new TerrainPicker(vertices, indices, encoding);\n}\n\n/**\n * Get the terrain tile's model-to-world transform matrix for the given scene mode and projection.\n * @param {SceneMode} mode The scene mode (3D, 2D, or Columbus View).\n * @param {MapProjection} projection The map projection.\n * @returns {Matrix4} The transform matrix.\n * @private\n */\nTerrainMesh.prototype.getTransform = function (mode, projection) {\n  if (!this._recomputeTransform) {\n    return this._transform;\n  }\n  this._recomputeTransform = false;\n\n  if (!defined(mode) || mode === SceneMode.SCENE3D) {\n    return computeTransform(this, this._transform);\n  }\n\n  return computeTransform2D(this, projection, this._transform);\n};\n\nfunction computeTransform(mesh, result) {\n  const exaggeration = mesh.encoding.exaggeration;\n  const exaggerationRelativeHeight = mesh.encoding.exaggerationRelativeHeight;\n\n  const exaggeratedMinHeight = VerticalExaggeration.getHeight(\n    mesh.minimumHeight,\n    exaggeration,\n    exaggerationRelativeHeight,\n  );\n\n  const exaggeratedMaxHeight = VerticalExaggeration.getHeight(\n    mesh.maximumHeight,\n    exaggeration,\n    exaggerationRelativeHeight,\n  );\n\n  const obb = OrientedBoundingBox.fromRectangle(\n    mesh.rectangle,\n    exaggeratedMinHeight,\n    exaggeratedMaxHeight,\n    Ellipsoid.default,\n    mesh.orientedBoundingBox,\n  );\n\n  return OrientedBoundingBox.computeTransformation(obb, result);\n}\n\nconst scratchSWCartesian = new Cartesian3();\nconst scratchNECartesian = new Cartesian3();\nconst scratchSWCartographic = new Cartographic();\nconst scratchNECartographic = new Cartographic();\nconst scratchScale2D = new Cartesian3();\nconst scratchCenter2D = new Cartesian3();\n\n/**\n * Get the terrain tile's model-to-world transform matrix for 2D or Columbus View modes.\n * Assumes tiles in 2D are axis-aligned and still rectangular. (This is true for Web Mercator and Geographic projections.)\n * @param {TerrainMesh} mesh The terrain mesh.\n * @param {MapProjection} projection The map projection.\n * @param {Matrix4} result The object in which to store the result.\n * @returns {Matrix4} The transform matrix.\n * @private\n */\nfunction computeTransform2D(mesh, projection, result) {\n  const exaggeration = mesh.encoding.exaggeration;\n  const exaggerationRelativeHeight = mesh.encoding.exaggerationRelativeHeight;\n\n  const exaggeratedMinHeight = VerticalExaggeration.getHeight(\n    mesh.minimumHeight,\n    exaggeration,\n    exaggerationRelativeHeight,\n  );\n\n  const exaggeratedMaxHeight = VerticalExaggeration.getHeight(\n    mesh.maximumHeight,\n    exaggeration,\n    exaggerationRelativeHeight,\n  );\n\n  const southwest = projection.project(\n    Cartographic.fromRadians(\n      mesh.rectangle.west,\n      mesh.rectangle.south,\n      0,\n      scratchSWCartographic,\n    ),\n    scratchSWCartesian,\n  );\n\n  const northeast = projection.project(\n    Cartographic.fromRadians(\n      mesh.rectangle.east,\n      mesh.rectangle.north,\n      0,\n      scratchNECartographic,\n    ),\n    scratchNECartesian,\n  );\n\n  const heightRange = exaggeratedMaxHeight - exaggeratedMinHeight;\n  const scale = Cartesian3.fromElements(\n    northeast.x - southwest.x,\n    northeast.y - southwest.y,\n    heightRange > 0 ? heightRange : 1.0, // Avoid zero scale\n    scratchScale2D,\n  );\n\n  const center = Cartesian3.fromElements(\n    southwest.x + scale.x * 0.5,\n    southwest.y + scale.y * 0.5,\n    exaggeratedMinHeight + scale.z * 0.5,\n    scratchCenter2D,\n  );\n\n  Matrix4.fromTranslation(center, result);\n  Matrix4.setScale(result, scale, result);\n  Matrix4.multiply(Transforms.SWIZZLE_3D_TO_2D_MATRIX, result, result);\n\n  return result;\n}\n\n/**\n * Gives the point on this terrain tile where the given ray intersects\n * @param {Ray} ray The ray to test for intersection.\n * @param {boolean} cullBackFaces Whether to consider back-facing triangles as intersections.\n * @param {SceneMode} mode The scene mode (3D, 2D, or Columbus View).\n * @param {MapProjection} projection The map projection.\n * @returns {Cartesian3} The point on the mesh where the ray intersects, or undefined if there is no intersection.\n * @private\n */\nTerrainMesh.prototype.pick = function (ray, cullBackFaces, mode, projection) {\n  return this._terrainPicker.rayIntersect(\n    ray,\n    this.getTransform(mode, projection),\n    cullBackFaces,\n    mode,\n    projection,\n  );\n};\n\n/**\n * Updates the terrain mesh to account for changes in vertical exaggeration.\n * @param {Number} exaggeration A scalar used to exaggerate terrain.\n * @param {Number} exaggerationRelativeHeight The relative height from which terrain is exaggerated.\n * @private\n */\nTerrainMesh.prototype.updateExaggeration = function (\n  exaggeration,\n  exaggerationRelativeHeight,\n) {\n  // The encoding stored on the TerrainMesh references the updated exaggeration values already. This is just used\n  // to trigger a rebuild on the terrain picker.\n  this._terrainPicker._vertices = this.vertices;\n  this._terrainPicker.needsRebuild = true;\n  this._recomputeTransform = true;\n};\n\n/**\n * Updates the terrain mesh to account for changes in scene mode.\n * @param {SceneMode} mode The scene mode (3D, 2D, or Columbus View).\n * @private\n */\nTerrainMesh.prototype.updateSceneMode = function (mode) {\n  this._terrainPicker.needsRebuild = true;\n  this._recomputeTransform = true;\n};\n\nexport default TerrainMesh;\n"],"names":["TerrainMesh","center","vertices","indices","indexCountWithoutSkirts","vertexCountWithoutSkirts","minimumHeight","maximumHeight","rectangle","boundingSphere3D","occludeePointInScaledSpace","vertexStride","orientedBoundingBox","encoding","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","stride","_transform","_recomputeTransform","_terrainPicker","prototype","getTransform","mode","projection","SCENE3D","computeTransform","computeTransform2D","mesh","result","exaggeration","exaggerationRelativeHeight","exaggeratedMinHeight","getHeight","exaggeratedMaxHeight","obb","fromRectangle","default","computeTransformation","scratchSWCartesian","scratchNECartesian","scratchSWCartographic","scratchNECartographic","scratchScale2D","scratchCenter2D","southwest","project","fromRadians","west","south","northeast","east","north","heightRange","scale","fromElements","x","y","z","fromTranslation","setScale","multiply","SWIZZLE_3D_TO_2D_MATRIX","pick","ray","cullBackFaces","rayIntersect","updateExaggeration","_vertices","needsRebuild","updateSceneMode"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 56387, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/HeightmapTerrainData.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport HeightmapEncoding from \"./HeightmapEncoding.js\";\nimport HeightmapTessellator from \"./HeightmapTessellator.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\n\n/**\n * Terrain data for a single tile where the terrain data is represented as a heightmap.  A heightmap\n * is a rectangular array of heights in row-major order from north to south and west to east.\n *\n * @alias HeightmapTerrainData\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} options.buffer The buffer containing height data.\n * @param {number} options.width The width (longitude direction) of the heightmap, in samples.\n * @param {number} options.height The height (latitude direction) of the heightmap, in samples.\n * @param {number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {Uint8Array} [options.waterMask] The water mask included in this terrain data, if any.  A water mask is a square\n *                     Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n *                     Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n * @param {object} [options.structure] An object describing the structure of the height data.\n * @param {number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\n *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\n *                 height after multiplying by the scale.\n * @param {number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\n *                 height in meters.  The offset is added after the height sample is multiplied by the\n *                 heightScale.\n * @param {number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\n *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\n *                 it is greater than 1, that number of elements together form the height sample, which is\n *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\n * @param {number} [options.structure.stride=1] The number of elements to skip to get from the first element of\n *                 one height to the first element of the next height.\n * @param {number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\n *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\n *                 is 256, the height is computed as follows:\n *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\n *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\n *                 elements is reversed.\n * @param {boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\n *                  stride property is greater than 1.  If this property is false, the first element is the\n *                  low-order element.  If it is true, the first element is the high-order element.\n * @param {number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\n *                 not specified, no minimum value is enforced.\n * @param {number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\n *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\n * @param {HeightmapEncoding} [options.encoding=HeightmapEncoding.NONE] The encoding that is used on the buffer.\n * @param {boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n *\n *\n * @example\n * const buffer = ...\n * const heightBuffer = new Uint16Array(buffer, 0, that._heightmapWidth * that._heightmapWidth);\n * const childTileMask = new Uint8Array(buffer, heightBuffer.byteLength, 1)[0];\n * const waterMask = new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1);\n * const terrainData = new Cesium.HeightmapTerrainData({\n *   buffer : heightBuffer,\n *   width : 65,\n *   height : 65,\n *   childTileMask : childTileMask,\n *   waterMask : waterMask\n * });\n *\n * @see TerrainData\n * @see QuantizedMeshTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\nfunction HeightmapTerrainData(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.buffer\", options.buffer);\n  Check.typeOf.number(\"options.width\", options.width);\n  Check.typeOf.number(\"options.height\", options.height);\n  //>>includeEnd('debug');\n\n  this._buffer = options.buffer;\n  this._width = options.width;\n  this._height = options.height;\n  this._childTileMask = options.childTileMask ?? 15;\n  this._encoding = options.encoding ?? HeightmapEncoding.NONE;\n\n  const defaultStructure = HeightmapTessellator.DEFAULT_STRUCTURE;\n  let structure = options.structure;\n  if (!defined(structure)) {\n    structure = defaultStructure;\n  } else if (structure !== defaultStructure) {\n    structure.heightScale =\n      structure.heightScale ?? defaultStructure.heightScale;\n    structure.heightOffset =\n      structure.heightOffset ?? defaultStructure.heightOffset;\n    structure.elementsPerHeight =\n      structure.elementsPerHeight ?? defaultStructure.elementsPerHeight;\n    structure.stride = structure.stride ?? defaultStructure.stride;\n    structure.elementMultiplier =\n      structure.elementMultiplier ?? defaultStructure.elementMultiplier;\n    structure.isBigEndian =\n      structure.isBigEndian ?? defaultStructure.isBigEndian;\n  }\n\n  this._structure = structure;\n  this._createdByUpsampling = options.createdByUpsampling ?? false;\n  this._waterMask = options.waterMask;\n\n  this._skirtHeight = undefined;\n  this._bufferType =\n    this._encoding === HeightmapEncoding.LERC\n      ? Float32Array\n      : this._buffer.constructor;\n  this._mesh = undefined;\n}\n\nObject.defineProperties(HeightmapTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return undefined;\n    },\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a square\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement|ImageBitmap|undefined}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    },\n  },\n\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    },\n  },\n});\n\nconst createMeshTaskName = \"createVerticesFromHeightmap\";\nconst createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nconst createMeshTaskProcessorThrottle = new TaskProcessor(\n  createMeshTaskName,\n  TerrainData.maximumAsynchronousTasks,\n);\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {number} options.level The level of the tile for which to create the terrain data.\n * @param {number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {number} [options.exaggerationRelativeHeight=0.0] The height relative to which terrain is exaggerated.\n * @param {boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nHeightmapTerrainData.prototype.createMesh = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  const tilingScheme = options.tilingScheme;\n  const x = options.x;\n  const y = options.y;\n  const level = options.level;\n  const exaggeration = options.exaggeration ?? 1.0;\n  const exaggerationRelativeHeight = options.exaggerationRelativeHeight ?? 0.0;\n  const throttle = options.throttle ?? true;\n\n  const ellipsoid = tilingScheme.ellipsoid;\n  const nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  const rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  // Compute the center of the tile for RTC rendering.\n  const center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));\n\n  const structure = this._structure;\n\n  const levelZeroMaxError =\n    TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n      ellipsoid,\n      this._width,\n      tilingScheme.getNumberOfXTilesAtLevel(0),\n    );\n  const thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n\n  const createMeshTaskProcessor = throttle\n    ? createMeshTaskProcessorThrottle\n    : createMeshTaskProcessorNoThrottle;\n\n  const verticesPromise = createMeshTaskProcessor.scheduleTask({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof GeographicProjection,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight,\n    encoding: this._encoding,\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  const that = this;\n  return Promise.resolve(verticesPromise).then(function (result) {\n    let indicesAndEdges;\n    if (that._skirtHeight > 0.0) {\n      indicesAndEdges =\n        TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(\n          result.gridWidth,\n          result.gridHeight,\n        );\n    } else {\n      indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(\n        result.gridWidth,\n        result.gridHeight,\n      );\n    }\n\n    const vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;\n\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(\n      center,\n      new Float32Array(result.vertices),\n      indicesAndEdges.indices,\n      indicesAndEdges.indexCountWithoutSkirts,\n      vertexCountWithoutSkirts,\n      result.minimumHeight,\n      result.maximumHeight,\n      rectangle,\n      BoundingSphere.clone(result.boundingSphere3D),\n      Cartesian3.clone(result.occludeePointInScaledSpace),\n      result.numberOfAttributes,\n      OrientedBoundingBox.clone(result.orientedBoundingBox),\n      TerrainEncoding.clone(result.encoding),\n      indicesAndEdges.westIndicesSouthToNorth,\n      indicesAndEdges.southIndicesEastToWest,\n      indicesAndEdges.eastIndicesNorthToSouth,\n      indicesAndEdges.northIndicesWestToEast,\n    );\n\n    // Free memory received from server after mesh is created.\n    that._buffer = undefined;\n    return that._mesh;\n  });\n};\n\n/**\n * @param {object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {number} options.level The level of the tile for which to create the terrain data.\n * @param {number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {number} [options.exaggerationRelativeHeight=0.0] The height relative to which terrain is exaggerated.\n *\n * @private\n */\nHeightmapTerrainData.prototype._createMeshSync = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  const tilingScheme = options.tilingScheme;\n  const x = options.x;\n  const y = options.y;\n  const level = options.level;\n  const exaggeration = options.exaggeration ?? 1.0;\n  const exaggerationRelativeHeight = options.exaggerationRelativeHeight ?? 0.0;\n\n  const ellipsoid = tilingScheme.ellipsoid;\n  const nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  const rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  // Compute the center of the tile for RTC rendering.\n  const center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));\n\n  const structure = this._structure;\n\n  const levelZeroMaxError =\n    TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n      ellipsoid,\n      this._width,\n      tilingScheme.getNumberOfXTilesAtLevel(0),\n    );\n  const thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n\n  const result = HeightmapTessellator.computeVertices({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof GeographicProjection,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight,\n  });\n\n  // Free memory received from server after mesh is created.\n  this._buffer = undefined;\n\n  let indicesAndEdges;\n  if (this._skirtHeight > 0.0) {\n    indicesAndEdges =\n      TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(\n        this._width,\n        this._height,\n      );\n  } else {\n    indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(\n      this._width,\n      this._height,\n    );\n  }\n\n  const vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;\n\n  // No need to clone here (as we do in the async version) because the result\n  // is not coming from a web worker.\n  this._mesh = new TerrainMesh(\n    center,\n    result.vertices,\n    indicesAndEdges.indices,\n    indicesAndEdges.indexCountWithoutSkirts,\n    vertexCountWithoutSkirts,\n    result.minimumHeight,\n    result.maximumHeight,\n    rectangle,\n    result.boundingSphere3D,\n    result.occludeePointInScaledSpace,\n    result.encoding.stride,\n    result.orientedBoundingBox,\n    result.encoding,\n    indicesAndEdges.westIndicesSouthToNorth,\n    indicesAndEdges.southIndicesEastToWest,\n    indicesAndEdges.eastIndicesNorthToSouth,\n    indicesAndEdges.northIndicesWestToEast,\n  );\n\n  return this._mesh;\n};\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {number} longitude The longitude in radians.\n * @param {number} latitude The latitude in radians.\n * @returns {number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\nHeightmapTerrainData.prototype.interpolateHeight = function (\n  rectangle,\n  longitude,\n  latitude,\n) {\n  const width = this._width;\n  const height = this._height;\n\n  const structure = this._structure;\n  const stride = structure.stride;\n  const elementsPerHeight = structure.elementsPerHeight;\n  const elementMultiplier = structure.elementMultiplier;\n  const isBigEndian = structure.isBigEndian;\n  const heightOffset = structure.heightOffset;\n  const heightScale = structure.heightScale;\n\n  const isMeshCreated = defined(this._mesh);\n  const isLERCEncoding = this._encoding === HeightmapEncoding.LERC;\n  const isInterpolationImpossible = !isMeshCreated && isLERCEncoding;\n  if (isInterpolationImpossible) {\n    // We can't interpolate using the buffer because it's LERC encoded\n    //  so please call createMesh() first and interpolate using the mesh;\n    //  as mesh creation will decode the LERC buffer\n    return undefined;\n  }\n\n  let heightSample;\n  if (isMeshCreated) {\n    const buffer = this._mesh.vertices;\n    const encoding = this._mesh.encoding;\n    heightSample = interpolateMeshHeight(\n      buffer,\n      encoding,\n      heightOffset,\n      heightScale,\n      rectangle,\n      width,\n      height,\n      longitude,\n      latitude,\n    );\n  } else {\n    heightSample = interpolateHeight(\n      this._buffer,\n      elementsPerHeight,\n      elementMultiplier,\n      stride,\n      isBigEndian,\n      rectangle,\n      width,\n      height,\n      longitude,\n      latitude,\n    );\n    heightSample = heightSample * heightScale + heightOffset;\n  }\n\n  return heightSample;\n};\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * height samples in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {number} thisLevel The level of this tile in the tiling scheme.\n * @param {number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if the mesh is unavailable.\n */\nHeightmapTerrainData.prototype.upsample = function (\n  tilingScheme,\n  thisX,\n  thisY,\n  thisLevel,\n  descendantX,\n  descendantY,\n  descendantLevel,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(thisLevel)) {\n    throw new DeveloperError(\"thisLevel is required.\");\n  }\n  if (!defined(descendantX)) {\n    throw new DeveloperError(\"descendantX is required.\");\n  }\n  if (!defined(descendantY)) {\n    throw new DeveloperError(\"descendantY is required.\");\n  }\n  if (!defined(descendantLevel)) {\n    throw new DeveloperError(\"descendantLevel is required.\");\n  }\n  const levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\n      \"Upsampling through more than one level at a time is not currently supported.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const meshData = this._mesh;\n  if (!defined(meshData)) {\n    return undefined;\n  }\n\n  const width = this._width;\n  const height = this._height;\n  const structure = this._structure;\n  const stride = structure.stride;\n\n  const heights = new this._bufferType(width * height * stride);\n\n  const buffer = meshData.vertices;\n  const encoding = meshData.encoding;\n\n  // PERFORMANCE_IDEA: don't recompute these rectangles - the caller already knows them.\n  const sourceRectangle = tilingScheme.tileXYToRectangle(\n    thisX,\n    thisY,\n    thisLevel,\n  );\n  const destinationRectangle = tilingScheme.tileXYToRectangle(\n    descendantX,\n    descendantY,\n    descendantLevel,\n  );\n\n  const heightOffset = structure.heightOffset;\n  const heightScale = structure.heightScale;\n\n  const elementsPerHeight = structure.elementsPerHeight;\n  const elementMultiplier = structure.elementMultiplier;\n  const isBigEndian = structure.isBigEndian;\n\n  const divisor = Math.pow(elementMultiplier, elementsPerHeight - 1);\n\n  for (let j = 0; j < height; ++j) {\n    const latitude = CesiumMath.lerp(\n      destinationRectangle.north,\n      destinationRectangle.south,\n      j / (height - 1),\n    );\n    for (let i = 0; i < width; ++i) {\n      const longitude = CesiumMath.lerp(\n        destinationRectangle.west,\n        destinationRectangle.east,\n        i / (width - 1),\n      );\n      let heightSample = interpolateMeshHeight(\n        buffer,\n        encoding,\n        heightOffset,\n        heightScale,\n        sourceRectangle,\n        width,\n        height,\n        longitude,\n        latitude,\n      );\n\n      // Use conditionals here instead of Math.min and Math.max so that an undefined\n      // lowestEncodedHeight or highestEncodedHeight has no effect.\n      heightSample =\n        heightSample < structure.lowestEncodedHeight\n          ? structure.lowestEncodedHeight\n          : heightSample;\n      heightSample =\n        heightSample > structure.highestEncodedHeight\n          ? structure.highestEncodedHeight\n          : heightSample;\n\n      setHeight(\n        heights,\n        elementsPerHeight,\n        elementMultiplier,\n        divisor,\n        stride,\n        isBigEndian,\n        j * width + i,\n        heightSample,\n      );\n    }\n  }\n\n  return Promise.resolve(\n    new HeightmapTerrainData({\n      buffer: heights,\n      width: width,\n      height: height,\n      childTileMask: 0,\n      structure: this._structure,\n      createdByUpsampling: true,\n    }),\n  );\n};\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {number} thisX The tile X coordinate of this (the parent) tile.\n * @param {number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {number} childX The tile X coordinate of the child tile to check for availability.\n * @param {number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {boolean} True if the child tile is available; otherwise, false.\n */\nHeightmapTerrainData.prototype.isChildAvailable = function (\n  thisX,\n  thisY,\n  childX,\n  childY,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"thisX\", thisX);\n  Check.typeOf.number(\"thisY\", thisY);\n  Check.typeOf.number(\"childX\", childX);\n  Check.typeOf.number(\"childY\", childY);\n  //>>includeEnd('debug');\n\n  let bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & (1 << bitNumber)) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {boolean} True if this instance was created by upsampling; otherwise, false.\n */\nHeightmapTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\n\nfunction interpolateHeight(\n  sourceHeights,\n  elementsPerHeight,\n  elementMultiplier,\n  stride,\n  isBigEndian,\n  sourceRectangle,\n  width,\n  height,\n  longitude,\n  latitude,\n) {\n  const fromWest =\n    ((longitude - sourceRectangle.west) * (width - 1)) /\n    (sourceRectangle.east - sourceRectangle.west);\n  const fromSouth =\n    ((latitude - sourceRectangle.south) * (height - 1)) /\n    (sourceRectangle.north - sourceRectangle.south);\n\n  let westInteger = fromWest | 0;\n  let eastInteger = westInteger + 1;\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n\n  let southInteger = fromSouth | 0;\n  let northInteger = southInteger + 1;\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n\n  const dx = fromWest - westInteger;\n  const dy = fromSouth - southInteger;\n\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n\n  const southwestHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    southInteger * width + westInteger,\n  );\n  const southeastHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    southInteger * width + eastInteger,\n  );\n  const northwestHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    northInteger * width + westInteger,\n  );\n  const northeastHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    northInteger * width + eastInteger,\n  );\n\n  return triangleInterpolateHeight(\n    dx,\n    dy,\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight,\n  );\n}\n\nfunction interpolateMeshHeight(\n  buffer,\n  encoding,\n  heightOffset,\n  heightScale,\n  sourceRectangle,\n  width,\n  height,\n  longitude,\n  latitude,\n) {\n  // returns a height encoded according to the structure's heightScale and heightOffset.\n  const fromWest =\n    ((longitude - sourceRectangle.west) * (width - 1)) /\n    (sourceRectangle.east - sourceRectangle.west);\n  const fromSouth =\n    ((latitude - sourceRectangle.south) * (height - 1)) /\n    (sourceRectangle.north - sourceRectangle.south);\n\n  let westInteger = fromWest | 0;\n  let eastInteger = westInteger + 1;\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n\n  let southInteger = fromSouth | 0;\n  let northInteger = southInteger + 1;\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n\n  const dx = fromWest - westInteger;\n  const dy = fromSouth - southInteger;\n\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n\n  const southwestHeight =\n    (encoding.decodeHeight(buffer, southInteger * width + westInteger) -\n      heightOffset) /\n    heightScale;\n  const southeastHeight =\n    (encoding.decodeHeight(buffer, southInteger * width + eastInteger) -\n      heightOffset) /\n    heightScale;\n  const northwestHeight =\n    (encoding.decodeHeight(buffer, northInteger * width + westInteger) -\n      heightOffset) /\n    heightScale;\n  const northeastHeight =\n    (encoding.decodeHeight(buffer, northInteger * width + eastInteger) -\n      heightOffset) /\n    heightScale;\n\n  return triangleInterpolateHeight(\n    dx,\n    dy,\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight,\n  );\n}\n\nfunction triangleInterpolateHeight(\n  dX,\n  dY,\n  southwestHeight,\n  southeastHeight,\n  northwestHeight,\n  northeastHeight,\n) {\n  // The HeightmapTessellator bisects the quad from southwest to northeast.\n  if (dY < dX) {\n    // Lower right triangle\n    return (\n      southwestHeight +\n      dX * (southeastHeight - southwestHeight) +\n      dY * (northeastHeight - southeastHeight)\n    );\n  }\n\n  // Upper left triangle\n  return (\n    southwestHeight +\n    dX * (northeastHeight - northwestHeight) +\n    dY * (northwestHeight - southwestHeight)\n  );\n}\n\nfunction getHeight(\n  heights,\n  elementsPerHeight,\n  elementMultiplier,\n  stride,\n  isBigEndian,\n  index,\n) {\n  index *= stride;\n\n  let height = 0;\n  let i;\n\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight; ++i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i >= 0; --i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  }\n\n  return height;\n}\n\nfunction setHeight(\n  heights,\n  elementsPerHeight,\n  elementMultiplier,\n  divisor,\n  stride,\n  isBigEndian,\n  index,\n  height,\n) {\n  index *= stride;\n\n  let i;\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight - 1; ++i) {\n      heights[index + i] = (height / divisor) | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i > 0; --i) {\n      heights[index + i] = (height / divisor) | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  }\n  heights[index + i] = height;\n}\nexport default HeightmapTerrainData;\n"],"names":["HeightmapTerrainData","options","EMPTY_OBJECT","typeOf","object","buffer","number","width","height","_buffer","_width","_height","_childTileMask","childTileMask","_encoding","encoding","NONE","defaultStructure","DEFAULT_STRUCTURE","structure","heightScale","heightOffset","elementsPerHeight","stride","elementMultiplier","isBigEndian","_structure","_createdByUpsampling","createdByUpsampling","_waterMask","waterMask","_skirtHeight","undefined","_bufferType","LERC","Float32Array","_mesh","Object","defineProperties","prototype","credits","get","createMeshTaskName","createMeshTaskProcessorNoThrottle","createMeshTaskProcessorThrottle","maximumAsynchronousTasks","createMesh","tilingScheme","x","y","level","exaggeration","exaggerationRelativeHeight","throttle","ellipsoid","nativeRectangle","tileXYToNativeRectangle","rectangle","tileXYToRectangle","center","cartographicToCartesian","levelZeroMaxError","getEstimatedLevelZeroGeometricErrorForAHeightmap","getNumberOfXTilesAtLevel","thisLevelMaxError","Math","min","createMeshTaskProcessor","verticesPromise","scheduleTask","heightmap","includeWebMercatorT","relativeToCenter","skirtHeight","isGeographic","projection","that","Promise","resolve","then","result","indicesAndEdges","getRegularGridAndSkirtIndicesAndEdgeIndices","gridWidth","gridHeight","getRegularGridIndicesAndEdgeIndices","vertexCountWithoutSkirts","vertices","indices","indexCountWithoutSkirts","minimumHeight","maximumHeight","clone","boundingSphere3D","occludeePointInScaledSpace","numberOfAttributes","orientedBoundingBox","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","_createMeshSync","computeVertices","interpolateHeight","longitude","latitude","isMeshCreated","isLERCEncoding","isInterpolationImpossible","heightSample","interpolateMeshHeight","upsample","thisX","thisY","thisLevel","descendantX","descendantY","descendantLevel","levelDifference","meshData","heights","sourceRectangle","destinationRectangle","divisor","pow","j","lerp","north","south","i","west","east","lowestEncodedHeight","highestEncodedHeight","setHeight","isChildAvailable","childX","childY","bitNumber","wasCreatedByUpsampling","sourceHeights","fromWest","fromSouth","westInteger","eastInteger","southInteger","northInteger","dx","dy","southwestHeight","getHeight","southeastHeight","northwestHeight","northeastHeight","triangleInterpolateHeight","decodeHeight","dX","dY","index"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 56957, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/EllipsoidTerrainProvider.js"],"sourcesContent":["import Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\n\n/**\n * A very simple {@link TerrainProvider} that produces geometry by tessellating an ellipsoidal\n * surface.\n *\n * @alias EllipsoidTerrainProvider\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {TilingScheme} [options.tilingScheme] The tiling scheme specifying how the ellipsoidal\n * surface is broken into tiles.  If this parameter is not provided, a {@link GeographicTilingScheme}\n * is used.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid.  If the tilingScheme is specified,\n * this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither\n * parameter is specified, the default ellipsoid is used.\n *\n * @see TerrainProvider\n */\nfunction EllipsoidTerrainProvider(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  this._tilingScheme = options.tilingScheme;\n  if (!defined(this._tilingScheme)) {\n    this._tilingScheme = new GeographicTilingScheme({\n      ellipsoid: options.ellipsoid ?? Ellipsoid.default,\n    });\n  }\n\n  // Note: the 64 below does NOT need to match the actual vertex dimensions, because\n  // the ellipsoid is significantly smoother than actual terrain.\n  this._levelZeroMaximumGeometricError =\n    TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n      this._tilingScheme.ellipsoid,\n      64,\n      this._tilingScheme.getNumberOfXTilesAtLevel(0),\n    );\n\n  this._errorEvent = new Event();\n}\n\nObject.defineProperties(EllipsoidTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    },\n  },\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles. This property may be undefined if availability\n   * information is not available.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {TileAvailability|undefined}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      return undefined;\n    },\n  },\n});\n\n/**\n * Requests the geometry for a given tile. The result includes terrain\n * data and indicates that all child tiles are available.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nEllipsoidTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request,\n) {\n  const width = 16;\n  const height = 16;\n  return Promise.resolve(\n    new HeightmapTerrainData({\n      buffer: new Uint8Array(width * height),\n      width: width,\n      height: height,\n    }),\n  );\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error.\n */\nEllipsoidTerrainProvider.prototype.getLevelMaximumGeometricError = function (\n  level,\n) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {boolean|undefined} Undefined if not supported, otherwise true or false.\n */\nEllipsoidTerrainProvider.prototype.getTileDataAvailable = function (\n  x,\n  y,\n  level,\n) {\n  return undefined;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {undefined} This provider does not support loading availability.\n */\nEllipsoidTerrainProvider.prototype.loadTileDataAvailability = function (\n  x,\n  y,\n  level,\n) {\n  return undefined;\n};\nexport default EllipsoidTerrainProvider;\n"],"names":["EllipsoidTerrainProvider","options","EMPTY_OBJECT","_tilingScheme","tilingScheme","ellipsoid","default","_levelZeroMaximumGeometricError","getEstimatedLevelZeroGeometricErrorForAHeightmap","getNumberOfXTilesAtLevel","_errorEvent","Object","defineProperties","prototype","errorEvent","get","credit","undefined","hasWaterMask","hasVertexNormals","availability","requestTileGeometry","x","y","level","request","width","height","Promise","resolve","buffer","Uint8Array","getLevelMaximumGeometricError","getTileDataAvailable","loadTileDataAvailability"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAEA;;;;;;;;;;;;;;;;CAgBC,GACD,SAASA,yBAAyBC,OAAO;IACvCA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC,IAAI,CAACC,aAAa,GAAGF,QAAQG,YAAY;IACzC,IAAI,CAAC,IAAA,6KAAO,EAAC,IAAI,CAACD,aAAa,GAAG;QAChC,IAAI,CAACA,aAAa,GAAG,IAAI,4LAAsB,CAAC;YAC9CE,WAAWJ,QAAQI,SAAS,IAAI,+KAAS,CAACC,OAAO;QACnD;IACF;IAEA,kFAAkF;IAClF,+DAA+D;IAC/D,IAAI,CAACC,+BAA+B,GAClC,qLAAe,CAACC,gDAAgD,CAC9D,IAAI,CAACL,aAAa,CAACE,SAAS,EAC5B,IACA,IAAI,CAACF,aAAa,CAACM,wBAAwB,CAAC;IAGhD,IAAI,CAACC,WAAW,GAAG,IAAI,2KAAK;AAC9B;AAEAC,OAAOC,gBAAgB,CAACZ,yBAAyBa,SAAS,EAAE;IAC1D;;;;;;;GAOC,GACDC,YAAY;QACVC,KAAK;YACH,OAAO,IAAI,CAACL,WAAW;QACzB;IACF;IAEA;;;;;;GAMC,GACDM,QAAQ;QACND,KAAK;YACH,OAAOE;QACT;IACF;IAEA;;;;;GAKC,GACDb,cAAc;QACZW,KAAK;YACH,OAAO,IAAI,CAACZ,aAAa;QAC3B;IACF;IAEA;;;;;;;GAOC,GACDe,cAAc;QACZH,KAAK;YACH,OAAO;QACT;IACF;IAEA;;;;;GAKC,GACDI,kBAAkB;QAChBJ,KAAK;YACH,OAAO;QACT;IACF;IACA;;;;;;;GAOC,GACDK,cAAc;QACZL,KAAK;YACH,OAAOE;QACT;IACF;AACF;AAEA;;;;;;;;;;;;CAYC,GACDjB,yBAAyBa,SAAS,CAACQ,mBAAmB,GAAG,SACvDC,CAAC,EACDC,CAAC,EACDC,KAAK,EACLC,OAAO;IAEP,MAAMC,QAAQ;IACd,MAAMC,SAAS;IACf,OAAOC,QAAQC,OAAO,CACpB,IAAI,0LAAoB,CAAC;QACvBC,QAAQ,IAAIC,WAAWL,QAAQC;QAC/BD,OAAOA;QACPC,QAAQA;IACV;AAEJ;AAEA;;;;;CAKC,GACD3B,yBAAyBa,SAAS,CAACmB,6BAA6B,GAAG,SACjER,KAAK;IAEL,OAAO,IAAI,CAACjB,+BAA+B,GAAG,CAAC,KAAKiB,KAAK;AAC3D;AAEA;;;;;;;CAOC,GACDxB,yBAAyBa,SAAS,CAACoB,oBAAoB,GAAG,SACxDX,CAAC,EACDC,CAAC,EACDC,KAAK;IAEL,OAAOP;AACT;AAEA;;;;;;;CAOC,GACDjB,yBAAyBa,SAAS,CAACqB,wBAAwB,GAAG,SAC5DZ,CAAC,EACDC,CAAC,EACDC,KAAK;IAEL,OAAOP;AACT;uCACejB","ignoreList":[0]}},
    {"offset": {"line": 57127, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Visibility.js"],"sourcesContent":["/**\n * This enumerated type is used in determining to what extent an object, the occludee,\n * is visible during horizon culling. An occluder may fully block an occludee, in which case\n * it has no visibility, may partially block an occludee from view, or may not block it at all,\n * leading to full visibility.\n *\n * @enum {number}\n */\nconst Visibility = {\n  /**\n   * Represents that no part of an object is visible.\n   *\n   * @type {number}\n   * @constant\n   */\n  NONE: -1,\n\n  /**\n   * Represents that part, but not all, of an object is visible\n   *\n   * @type {number}\n   * @constant\n   */\n  PARTIAL: 0,\n\n  /**\n   * Represents that an object is visible in its entirety.\n   *\n   * @type {number}\n   * @constant\n   */\n  FULL: 1,\n};\nexport default Object.freeze(Visibility);\n"],"names":["Visibility","NONE","PARTIAL","FULL","Object","freeze"],"mappings":";;;;AAAA;;;;;;;CAOC,GACD,MAAMA,aAAa;IACjB;;;;;GAKC,GACDC,MAAM,CAAC;IAEP;;;;;GAKC,GACDC,SAAS;IAET;;;;;GAKC,GACDC,MAAM;AACR;uCACeC,OAAOC,MAAM,CAACL","ignoreList":[0]}},
    {"offset": {"line": 57163, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TileEdge.js"],"sourcesContent":["/**\n * @private\n */\nconst TileEdge = {\n  WEST: 0,\n  NORTH: 1,\n  EAST: 2,\n  SOUTH: 3,\n  NORTHWEST: 4,\n  NORTHEAST: 5,\n  SOUTHWEST: 6,\n  SOUTHEAST: 7,\n};\nexport default TileEdge;\n"],"names":["TileEdge","WEST","NORTH","EAST","SOUTH","NORTHWEST","NORTHEAST","SOUTHWEST","SOUTHEAST"],"mappings":";;;;AAAA;;CAEC,GACD,MAAMA,WAAW;IACfC,MAAM;IACNC,OAAO;IACPC,MAAM;IACNC,OAAO;IACPC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;AACb;uCACeR","ignoreList":[0]}},
    {"offset": {"line": 57184, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/IauOrientationParameters.js"],"sourcesContent":["/**\n * A structure containing the orientation data computed at a particular time. The data\n * represents the direction of the pole of rotation and the rotation about that pole.\n * <p>\n * These parameters correspond to the parameters in the Report from the IAU/IAG Working Group\n * except that they are expressed in radians.\n * </p>\n *\n * @namespace IauOrientationParameters\n *\n * @private\n */\nfunction IauOrientationParameters(\n  rightAscension,\n  declination,\n  rotation,\n  rotationRate,\n) {\n  /**\n   * The right ascension of the north pole of the body with respect to\n   * the International Celestial Reference Frame, in radians.\n   * @type {number}\n   *\n   * @private\n   */\n  this.rightAscension = rightAscension;\n\n  /**\n   * The declination of the north pole of the body with respect to\n   * the International Celestial Reference Frame, in radians.\n   * @type {number}\n   *\n   * @private\n   */\n  this.declination = declination;\n\n  /**\n   * The rotation about the north pole used to align a set of axes with\n   * the meridian defined by the IAU report, in radians.\n   * @type {number}\n   *\n   * @private\n   */\n  this.rotation = rotation;\n\n  /**\n   * The instantaneous rotation rate about the north pole, in radians per second.\n   * @type {number}\n   *\n   * @private\n   */\n  this.rotationRate = rotationRate;\n}\nexport default IauOrientationParameters;\n"],"names":["IauOrientationParameters","rightAscension","declination","rotation","rotationRate"],"mappings":";;;;AAAA;;;;;;;;;;;CAWC,GACD,SAASA,yBACPC,cAAc,EACdC,WAAW,EACXC,QAAQ,EACRC,YAAY;IAEZ;;;;;;GAMC,GACD,IAAI,CAACH,cAAc,GAAGA;IAEtB;;;;;;GAMC,GACD,IAAI,CAACC,WAAW,GAAGA;IAEnB;;;;;;GAMC,GACD,IAAI,CAACC,QAAQ,GAAGA;IAEhB;;;;;GAKC,GACD,IAAI,CAACC,YAAY,GAAGA;AACtB;uCACeJ","ignoreList":[0]}},
    {"offset": {"line": 57233, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Iau2000Orientation.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport IauOrientationParameters from \"./IauOrientationParameters.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport TimeConstants from \"./TimeConstants.js\";\n\n/**\n * This is a collection of the orientation information available for central bodies.\n * The data comes from the Report of the IAU/IAG Working Group on Cartographic\n * Coordinates and Rotational Elements: 2000.\n *\n * @namespace Iau2000Orientation\n *\n * @private\n */\nconst Iau2000Orientation = {};\n\nconst TdtMinusTai = 32.184;\nconst J2000d = 2451545.0;\n\nconst c1 = -0.0529921;\nconst c2 = -0.1059842;\nconst c3 = 13.0120009;\nconst c4 = 13.3407154;\nconst c5 = 0.9856003;\nconst c6 = 26.4057084;\nconst c7 = 13.064993;\nconst c8 = 0.3287146;\nconst c9 = 1.7484877;\nconst c10 = -0.1589763;\nconst c11 = 0.0036096;\nconst c12 = 0.1643573;\nconst c13 = 12.9590088;\nlet dateTT = new JulianDate();\n\n/**\n * Compute the orientation parameters for the Moon.\n *\n * @param {JulianDate} [date=JulianDate.now()] The date to evaluate the parameters.\n * @param {IauOrientationParameters} [result] The object onto which to store the result.\n * @returns {IauOrientationParameters} The modified result parameter or a new instance representing the orientation of the Earth's Moon.\n * @private\n */\nIau2000Orientation.ComputeMoon = function (date, result) {\n  if (!defined(date)) {\n    date = JulianDate.now();\n  }\n\n  dateTT = JulianDate.addSeconds(date, TdtMinusTai, dateTT);\n  const d = JulianDate.totalDays(dateTT) - J2000d;\n  const T = d / TimeConstants.DAYS_PER_JULIAN_CENTURY;\n\n  const E1 = (125.045 + c1 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E2 = (250.089 + c2 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E3 = (260.008 + c3 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E4 = (176.625 + c4 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E5 = (357.529 + c5 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E6 = (311.589 + c6 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E7 = (134.963 + c7 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E8 = (276.617 + c8 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E9 = (34.226 + c9 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E10 = (15.134 + c10 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E11 = (119.743 + c11 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E12 = (239.961 + c12 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E13 = (25.053 + c13 * d) * CesiumMath.RADIANS_PER_DEGREE;\n\n  const sinE1 = Math.sin(E1);\n  const sinE2 = Math.sin(E2);\n  const sinE3 = Math.sin(E3);\n  const sinE4 = Math.sin(E4);\n  const sinE5 = Math.sin(E5);\n  const sinE6 = Math.sin(E6);\n  const sinE7 = Math.sin(E7);\n  const sinE8 = Math.sin(E8);\n  const sinE9 = Math.sin(E9);\n  const sinE10 = Math.sin(E10);\n  const sinE11 = Math.sin(E11);\n  const sinE12 = Math.sin(E12);\n  const sinE13 = Math.sin(E13);\n\n  const cosE1 = Math.cos(E1);\n  const cosE2 = Math.cos(E2);\n  const cosE3 = Math.cos(E3);\n  const cosE4 = Math.cos(E4);\n  const cosE5 = Math.cos(E5);\n  const cosE6 = Math.cos(E6);\n  const cosE7 = Math.cos(E7);\n  const cosE8 = Math.cos(E8);\n  const cosE9 = Math.cos(E9);\n  const cosE10 = Math.cos(E10);\n  const cosE11 = Math.cos(E11);\n  const cosE12 = Math.cos(E12);\n  const cosE13 = Math.cos(E13);\n\n  const rightAscension =\n    (269.9949 +\n      0.0031 * T -\n      3.8787 * sinE1 -\n      0.1204 * sinE2 +\n      0.07 * sinE3 -\n      0.0172 * sinE4 +\n      0.0072 * sinE6 -\n      0.0052 * sinE10 +\n      0.0043 * sinE13) *\n    CesiumMath.RADIANS_PER_DEGREE;\n  const declination =\n    (66.5392 +\n      0.013 * T +\n      1.5419 * cosE1 +\n      0.0239 * cosE2 -\n      0.0278 * cosE3 +\n      0.0068 * cosE4 -\n      0.0029 * cosE6 +\n      0.0009 * cosE7 +\n      0.0008 * cosE10 -\n      0.0009 * cosE13) *\n    CesiumMath.RADIANS_PER_DEGREE;\n  const rotation =\n    (38.3213 +\n      13.17635815 * d -\n      1.4e-12 * d * d +\n      3.561 * sinE1 +\n      0.1208 * sinE2 -\n      0.0642 * sinE3 +\n      0.0158 * sinE4 +\n      0.0252 * sinE5 -\n      0.0066 * sinE6 -\n      0.0047 * sinE7 -\n      0.0046 * sinE8 +\n      0.0028 * sinE9 +\n      0.0052 * sinE10 +\n      0.004 * sinE11 +\n      0.0019 * sinE12 -\n      0.0044 * sinE13) *\n    CesiumMath.RADIANS_PER_DEGREE;\n\n  const rotationRate =\n    ((13.17635815 -\n      1.4e-12 * (2.0 * d) +\n      3.561 * cosE1 * c1 +\n      0.1208 * cosE2 * c2 -\n      0.0642 * cosE3 * c3 +\n      0.0158 * cosE4 * c4 +\n      0.0252 * cosE5 * c5 -\n      0.0066 * cosE6 * c6 -\n      0.0047 * cosE7 * c7 -\n      0.0046 * cosE8 * c8 +\n      0.0028 * cosE9 * c9 +\n      0.0052 * cosE10 * c10 +\n      0.004 * cosE11 * c11 +\n      0.0019 * cosE12 * c12 -\n      0.0044 * cosE13 * c13) /\n      86400.0) *\n    CesiumMath.RADIANS_PER_DEGREE;\n\n  if (!defined(result)) {\n    result = new IauOrientationParameters();\n  }\n\n  result.rightAscension = rightAscension;\n  result.declination = declination;\n  result.rotation = rotation;\n  result.rotationRate = rotationRate;\n\n  return result;\n};\nexport default Iau2000Orientation;\n"],"names":["Iau2000Orientation","TdtMinusTai","J2000d","c1","c2","c3","c4","c5","c6","c7","c8","c9","c10","c11","c12","c13","dateTT","ComputeMoon","date","result","now","addSeconds","d","totalDays","T","DAYS_PER_JULIAN_CENTURY","E1","RADIANS_PER_DEGREE","E2","E3","E4","E5","E6","E7","E8","E9","E10","E11","E12","E13","sinE1","Math","sin","sinE2","sinE3","sinE4","sinE5","sinE6","sinE7","sinE8","sinE9","sinE10","sinE11","sinE12","sinE13","cosE1","cos","cosE2","cosE3","cosE4","cosE5","cosE6","cosE7","cosE8","cosE9","cosE10","cosE11","cosE12","cosE13","rightAscension","declination","rotation","rotationRate"],"mappings":"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M8B,SAAS3B,KAAKe,GAAG,CAACjB;IAExB,MAAM8B,iBACJ,CAAC,WACC,SAAS7C,IACT,SAASgB,QACT,SAASG,QACT,OAAOC,QACP,SAASC,QACT,SAASE,QACT,SAASI,SACT,SAASG,MAAM,IACjB,0KAAU,CAAC3B,kBAAkB;IAC/B,MAAM2C,cACJ,CAAC,UACC,QAAQ9C,IACR,SAAS+B,QACT,SAASE,QACT,SAASC,QACT,SAASC,QACT,SAASE,QACT,SAASC,QACT,SAASG,SACT,SAASG,MAAM,IACjB,0KAAU,CAACzC,kBAAkB;IAC/B,MAAM4C,WACJ,CAAC,UACC,cAAcjD,IACd,UAAUA,IAAIA,IACd,QAAQkB,QACR,SAASG,QACT,SAASC,QACT,SAASC,QACT,SAASC,QACT,SAASC,QACT,SAASC,QACT,SAASC,QACT,SAASC,QACT,SAASC,SACT,QAAQC,SACR,SAASC,SACT,SAASC,MAAM,IACjB,0KAAU,CAAC3B,kBAAkB;IAE/B,MAAM6C,eACJ,AAAC,CAAC,cACA,UAAU,CAAC,MAAMlD,CAAC,IAClB,QAAQiC,QAAQpD,KAChB,SAASsD,QAAQrD,KACjB,SAASsD,QAAQrD,KACjB,SAASsD,QAAQrD,KACjB,SAASsD,QAAQrD,KACjB,SAASsD,QAAQrD,KACjB,SAASsD,QAAQrD,KACjB,SAASsD,QAAQrD,KACjB,SAASsD,QAAQrD,KACjB,SAASsD,SAASrD,MAClB,QAAQsD,SAASrD,MACjB,SAASsD,SAASrD,MAClB,SAASsD,SAASrD,GAAG,IACrB,UACF,0KAAU,CAACY,kBAAkB;IAE/B,IAAI,CAAC,IAAA,6KAAO,EAACR,SAAS;QACpBA,SAAS,IAAI,8LAAwB;IACvC;IAEAA,OAAOkD,cAAc,GAAGA;IACxBlD,OAAOmD,WAAW,GAAGA;IACrBnD,OAAOoD,QAAQ,GAAGA;IAClBpD,OAAOqD,YAAY,GAAGA;IAEtB,OAAOrD;AACT;uCACenB","ignoreList":[0]}},
    {"offset": {"line": 57343, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/IauOrientationAxes.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport Iau2000Orientation from \"./Iau2000Orientation.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Quaternion from \"./Quaternion.js\";\n\n/**\n * The Axes representing the orientation of a Globe as represented by the data\n * from the IAU/IAG Working Group reports on rotational elements.\n * @alias IauOrientationAxes\n * @constructor\n *\n * @param {IauOrientationAxes.ComputeFunction} [computeFunction] The function that computes the {@link IauOrientationParameters} given a {@link JulianDate}.\n *\n * @see Iau2000Orientation\n *\n * @private\n */\nfunction IauOrientationAxes(computeFunction) {\n  if (!defined(computeFunction) || typeof computeFunction !== \"function\") {\n    computeFunction = Iau2000Orientation.ComputeMoon;\n  }\n\n  this._computeFunction = computeFunction;\n}\n\nconst xAxisScratch = new Cartesian3();\nconst yAxisScratch = new Cartesian3();\nconst zAxisScratch = new Cartesian3();\n\nfunction computeRotationMatrix(alpha, delta, result) {\n  const xAxis = xAxisScratch;\n  xAxis.x = Math.cos(alpha + CesiumMath.PI_OVER_TWO);\n  xAxis.y = Math.sin(alpha + CesiumMath.PI_OVER_TWO);\n  xAxis.z = 0.0;\n\n  const cosDec = Math.cos(delta);\n\n  const zAxis = zAxisScratch;\n  zAxis.x = cosDec * Math.cos(alpha);\n  zAxis.y = cosDec * Math.sin(alpha);\n  zAxis.z = Math.sin(delta);\n\n  const yAxis = Cartesian3.cross(zAxis, xAxis, yAxisScratch);\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = xAxis.x;\n  result[1] = yAxis.x;\n  result[2] = zAxis.x;\n  result[3] = xAxis.y;\n  result[4] = yAxis.y;\n  result[5] = zAxis.y;\n  result[6] = xAxis.z;\n  result[7] = yAxis.z;\n  result[8] = zAxis.z;\n\n  return result;\n}\n\nconst rotMtxScratch = new Matrix3();\nconst quatScratch = new Quaternion();\n\n/**\n * Computes a rotation from ICRF to a Globe's Fixed axes.\n *\n * @param {JulianDate} date The date to evaluate the matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new instance of the rotation from ICRF to Fixed.\n */\nIauOrientationAxes.prototype.evaluate = function (date, result) {\n  if (!defined(date)) {\n    date = JulianDate.now();\n  }\n\n  const alphaDeltaW = this._computeFunction(date);\n  const precMtx = computeRotationMatrix(\n    alphaDeltaW.rightAscension,\n    alphaDeltaW.declination,\n    result,\n  );\n\n  const rot = CesiumMath.zeroToTwoPi(alphaDeltaW.rotation);\n  const quat = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, rot, quatScratch);\n  const rotMtx = Matrix3.fromQuaternion(\n    Quaternion.conjugate(quat, quat),\n    rotMtxScratch,\n  );\n\n  const cbi2cbf = Matrix3.multiply(rotMtx, precMtx, precMtx);\n  return cbi2cbf;\n};\n\n/**\n * A function that computes the {@link IauOrientationParameters} for a {@link JulianDate}.\n * @callback IauOrientationAxes.ComputeFunction\n * @param {JulianDate} date The date to evaluate the parameters.\n * @returns {IauOrientationParameters} The orientation parameters.\n * @private\n */\nexport default IauOrientationAxes;\n"],"names":["IauOrientationAxes","computeFunction","ComputeMoon","_computeFunction","xAxisScratch","yAxisScratch","zAxisScratch","computeRotationMatrix","alpha","delta","result","xAxis","x","Math","cos","PI_OVER_TWO","y","sin","z","cosDec","zAxis","yAxis","cross","rotMtxScratch","quatScratch","prototype","evaluate","date","now","alphaDeltaW","precMtx","rightAscension","declination","rot","zeroToTwoPi","rotation","quat","fromAxisAngle","UNIT_Z","rotMtx","fromQuaternion","conjugate","cbi2cbf","multiply"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAEA;;;;;;;;;;;CAWC,GACD,SAASA,mBAAmBC,eAAe;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACA,oBAAoB,OAAOA,oBAAoB,YAAY;QACtEA,kBAAkB,wLAAkB,CAACC,WAAW;IAClD;IAEA,IAAI,CAACC,gBAAgB,GAAGF;AAC1B;AAEA,MAAMG,eAAe,IAAI,gLAAU;AACnC,MAAMC,eAAe,IAAI,gLAAU;AACnC,MAAMC,eAAe,IAAI,gLAAU;AAEnC,SAASC,sBAAsBC,KAAK,EAAEC,KAAK,EAAEC,MAAM;IACjD,MAAMC,QAAQP;IACdO,MAAMC,CAAC,GAAGC,KAAKC,GAAG,CAACN,QAAQ,0KAAU,CAACO,WAAW;IACjDJ,MAAMK,CAAC,GAAGH,KAAKI,GAAG,CAACT,QAAQ,0KAAU,CAACO,WAAW;IACjDJ,MAAMO,CAAC,GAAG;IAEV,MAAMC,SAASN,KAAKC,GAAG,CAACL;IAExB,MAAMW,QAAQd;IACdc,MAAMR,CAAC,GAAGO,SAASN,KAAKC,GAAG,CAACN;IAC5BY,MAAMJ,CAAC,GAAGG,SAASN,KAAKI,GAAG,CAACT;IAC5BY,MAAMF,CAAC,GAAGL,KAAKI,GAAG,CAACR;IAEnB,MAAMY,QAAQ,gLAAU,CAACC,KAAK,CAACF,OAAOT,OAAON;IAE7C,IAAI,CAAC,IAAA,6KAAO,EAACK,SAAS;QACpBA,SAAS,IAAI,6KAAO;IACtB;IAEAA,MAAM,CAAC,EAAE,GAAGC,MAAMC,CAAC;IACnBF,MAAM,CAAC,EAAE,GAAGW,MAAMT,CAAC;IACnBF,MAAM,CAAC,EAAE,GAAGU,MAAMR,CAAC;IACnBF,MAAM,CAAC,EAAE,GAAGC,MAAMK,CAAC;IACnBN,MAAM,CAAC,EAAE,GAAGW,MAAML,CAAC;IACnBN,MAAM,CAAC,EAAE,GAAGU,MAAMJ,CAAC;IACnBN,MAAM,CAAC,EAAE,GAAGC,MAAMO,CAAC;IACnBR,MAAM,CAAC,EAAE,GAAGW,MAAMH,CAAC;IACnBR,MAAM,CAAC,EAAE,GAAGU,MAAMF,CAAC;IAEnB,OAAOR;AACT;AAEA,MAAMa,gBAAgB,IAAI,6KAAO;AACjC,MAAMC,cAAc,IAAI,gLAAU;AAElC;;;;;;CAMC,GACDxB,mBAAmByB,SAAS,CAACC,QAAQ,GAAG,SAAUC,IAAI,EAAEjB,MAAM;IAC5D,IAAI,CAAC,IAAA,6KAAO,EAACiB,OAAO;QAClBA,OAAO,gLAAU,CAACC,GAAG;IACvB;IAEA,MAAMC,cAAc,IAAI,CAAC1B,gBAAgB,CAACwB;IAC1C,MAAMG,UAAUvB,sBACdsB,YAAYE,cAAc,EAC1BF,YAAYG,WAAW,EACvBtB;IAGF,MAAMuB,MAAM,0KAAU,CAACC,WAAW,CAACL,YAAYM,QAAQ;IACvD,MAAMC,OAAO,gLAAU,CAACC,aAAa,CAAC,gLAAU,CAACC,MAAM,EAAEL,KAAKT;IAC9D,MAAMe,SAAS,6KAAO,CAACC,cAAc,CACnC,gLAAU,CAACC,SAAS,CAACL,MAAMA,OAC3Bb;IAGF,MAAMmB,UAAU,6KAAO,CAACC,QAAQ,CAACJ,QAAQT,SAASA;IAClD,OAAOY;AACT;uCASe1C","ignoreList":[0]}},
    {"offset": {"line": 57431, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Simon1994PlanetaryPositions.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport TimeConstants from \"./TimeConstants.js\";\nimport TimeStandard from \"./TimeStandard.js\";\n\n/**\n * Contains functions for finding the Cartesian coordinates of the sun and the moon in the\n * Earth-centered inertial frame.\n *\n * @namespace Simon1994PlanetaryPositions\n */\nconst Simon1994PlanetaryPositions = {};\n\nfunction computeTdbMinusTtSpice(daysSinceJ2000InTerrestrialTime) {\n  /* STK Comments ------------------------------------------------------\n   * This function uses constants designed to be consistent with\n   * the SPICE Toolkit from JPL version N0051 (unitim.c)\n   * M0 = 6.239996\n   * M0Dot = 1.99096871e-7 rad/s = 0.01720197 rad/d\n   * EARTH_ECC = 1.671e-2\n   * TDB_AMPL = 1.657e-3 secs\n   *--------------------------------------------------------------------*/\n\n  //* Values taken as specified in STK Comments except: 0.01720197 rad/day = 1.99096871e-7 rad/sec\n  //* Here we use the more precise value taken from the SPICE value 1.99096871e-7 rad/sec converted to rad/day\n  //* All other constants are consistent with the SPICE implementation of the TDB conversion\n  //* except where we treat the independent time parameter to be in TT instead of TDB.\n  //* This is an approximation made to facilitate performance due to the higher prevalance of\n  //* the TT2TDB conversion over TDB2TT in order to avoid having to iterate when converting to TDB for the JPL ephemeris.\n  //* Days are used instead of seconds to provide a slight improvement in numerical precision.\n\n  //* For more information see:\n  //* http://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB\n  //* ftp://ssd.jpl.nasa.gov/pub/eph/planets/ioms/ExplSupplChap8.pdf\n\n  const g = 6.239996 + 0.0172019696544 * daysSinceJ2000InTerrestrialTime;\n  return 1.657e-3 * Math.sin(g + 1.671e-2 * Math.sin(g));\n}\n\nconst TdtMinusTai = 32.184;\nconst J2000d = 2451545;\nfunction taiToTdb(date, result) {\n  //Converts TAI to TT\n  result = JulianDate.addSeconds(date, TdtMinusTai, result);\n\n  //Converts TT to TDB\n  const days = JulianDate.totalDays(result) - J2000d;\n  result = JulianDate.addSeconds(result, computeTdbMinusTtSpice(days), result);\n\n  return result;\n}\n\nconst epoch = new JulianDate(2451545, 0, TimeStandard.TAI); //Actually TDB (not TAI)\nconst MetersPerKilometer = 1000.0;\nconst RadiansPerDegree = CesiumMath.RADIANS_PER_DEGREE;\nconst RadiansPerArcSecond = CesiumMath.RADIANS_PER_ARCSECOND;\nconst MetersPerAstronomicalUnit = 1.4959787e11; // IAU 1976 value\n\nconst perifocalToEquatorial = new Matrix3();\nfunction elementsToCartesian(\n  semimajorAxis,\n  eccentricity,\n  inclination,\n  longitudeOfPerigee,\n  longitudeOfNode,\n  meanLongitude,\n  result,\n) {\n  if (inclination < 0.0) {\n    inclination = -inclination;\n    longitudeOfNode += CesiumMath.PI;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (inclination < 0 || inclination > CesiumMath.PI) {\n    throw new DeveloperError(\n      \"The inclination is out of range. Inclination must be greater than or equal to zero and less than or equal to Pi radians.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const radiusOfPeriapsis = semimajorAxis * (1.0 - eccentricity);\n  const argumentOfPeriapsis = longitudeOfPerigee - longitudeOfNode;\n  const rightAscensionOfAscendingNode = longitudeOfNode;\n  const trueAnomaly = meanAnomalyToTrueAnomaly(\n    meanLongitude - longitudeOfPerigee,\n    eccentricity,\n  );\n  const type = chooseOrbit(eccentricity, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    type === \"Hyperbolic\" &&\n    Math.abs(CesiumMath.negativePiToPi(trueAnomaly)) >=\n      Math.acos(-1.0 / eccentricity)\n  ) {\n    throw new DeveloperError(\n      \"The true anomaly of the hyperbolic orbit lies outside of the bounds of the hyperbola.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  perifocalToCartesianMatrix(\n    argumentOfPeriapsis,\n    inclination,\n    rightAscensionOfAscendingNode,\n    perifocalToEquatorial,\n  );\n  const semilatus = radiusOfPeriapsis * (1.0 + eccentricity);\n  const costheta = Math.cos(trueAnomaly);\n  const sintheta = Math.sin(trueAnomaly);\n\n  const denom = 1.0 + eccentricity * costheta;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (denom <= CesiumMath.Epsilon10) {\n    throw new DeveloperError(\"elements cannot be converted to cartesian\");\n  }\n  //>>includeEnd('debug');\n\n  const radius = semilatus / denom;\n  if (!defined(result)) {\n    result = new Cartesian3(radius * costheta, radius * sintheta, 0.0);\n  } else {\n    result.x = radius * costheta;\n    result.y = radius * sintheta;\n    result.z = 0.0;\n  }\n\n  return Matrix3.multiplyByVector(perifocalToEquatorial, result, result);\n}\n\nfunction chooseOrbit(eccentricity, tolerance) {\n  //>>includeStart('debug', pragmas.debug);\n  if (eccentricity < 0) {\n    throw new DeveloperError(\"eccentricity cannot be negative.\");\n  }\n  //>>includeEnd('debug');\n\n  if (eccentricity <= tolerance) {\n    return \"Circular\";\n  } else if (eccentricity < 1.0 - tolerance) {\n    return \"Elliptical\";\n  } else if (eccentricity <= 1.0 + tolerance) {\n    return \"Parabolic\";\n  }\n  return \"Hyperbolic\";\n}\n\n// Calculates the true anomaly given the mean anomaly and the eccentricity.\nfunction meanAnomalyToTrueAnomaly(meanAnomaly, eccentricity) {\n  //>>includeStart('debug', pragmas.debug);\n  if (eccentricity < 0.0 || eccentricity >= 1.0) {\n    throw new DeveloperError(\"eccentricity out of range.\");\n  }\n  //>>includeEnd('debug');\n\n  const eccentricAnomaly = meanAnomalyToEccentricAnomaly(\n    meanAnomaly,\n    eccentricity,\n  );\n  return eccentricAnomalyToTrueAnomaly(eccentricAnomaly, eccentricity);\n}\n\nconst maxIterationCount = 50;\nconst keplerEqConvergence = CesiumMath.EPSILON8;\n// Calculates the eccentric anomaly given the mean anomaly and the eccentricity.\nfunction meanAnomalyToEccentricAnomaly(meanAnomaly, eccentricity) {\n  //>>includeStart('debug', pragmas.debug);\n  if (eccentricity < 0.0 || eccentricity >= 1.0) {\n    throw new DeveloperError(\"eccentricity out of range.\");\n  }\n  //>>includeEnd('debug');\n\n  const revs = Math.floor(meanAnomaly / CesiumMath.TWO_PI);\n\n  // Find angle in current revolution\n  meanAnomaly -= revs * CesiumMath.TWO_PI;\n\n  // calculate starting value for iteration sequence\n  let iterationValue =\n    meanAnomaly +\n    (eccentricity * Math.sin(meanAnomaly)) /\n      (1.0 - Math.sin(meanAnomaly + eccentricity) + Math.sin(meanAnomaly));\n\n  // Perform Newton-Raphson iteration on Kepler's equation\n  let eccentricAnomaly = Number.MAX_VALUE;\n\n  let count;\n  for (\n    count = 0;\n    count < maxIterationCount &&\n    Math.abs(eccentricAnomaly - iterationValue) > keplerEqConvergence;\n    ++count\n  ) {\n    eccentricAnomaly = iterationValue;\n    const NRfunction =\n      eccentricAnomaly -\n      eccentricity * Math.sin(eccentricAnomaly) -\n      meanAnomaly;\n    const dNRfunction = 1 - eccentricity * Math.cos(eccentricAnomaly);\n    iterationValue = eccentricAnomaly - NRfunction / dNRfunction;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (count >= maxIterationCount) {\n    throw new DeveloperError(\"Kepler equation did not converge\");\n    // STK Components uses a numerical method to find the eccentric anomaly in the case that Kepler's\n    // equation does not converge. We don't expect that to ever be necessary for the reasonable orbits used here.\n  }\n  //>>includeEnd('debug');\n\n  eccentricAnomaly = iterationValue + revs * CesiumMath.TWO_PI;\n  return eccentricAnomaly;\n}\n\n// Calculates the true anomaly given the eccentric anomaly and the eccentricity.\nfunction eccentricAnomalyToTrueAnomaly(eccentricAnomaly, eccentricity) {\n  //>>includeStart('debug', pragmas.debug);\n  if (eccentricity < 0.0 || eccentricity >= 1.0) {\n    throw new DeveloperError(\"eccentricity out of range.\");\n  }\n  //>>includeEnd('debug');\n\n  // Calculate the number of previous revolutions\n  const revs = Math.floor(eccentricAnomaly / CesiumMath.TWO_PI);\n\n  // Find angle in current revolution\n  eccentricAnomaly -= revs * CesiumMath.TWO_PI;\n\n  // Calculate true anomaly from eccentric anomaly\n  const trueAnomalyX = Math.cos(eccentricAnomaly) - eccentricity;\n  const trueAnomalyY =\n    Math.sin(eccentricAnomaly) * Math.sqrt(1 - eccentricity * eccentricity);\n\n  let trueAnomaly = Math.atan2(trueAnomalyY, trueAnomalyX);\n\n  // Ensure the correct quadrant\n  trueAnomaly = CesiumMath.zeroToTwoPi(trueAnomaly);\n  if (eccentricAnomaly < 0) {\n    trueAnomaly -= CesiumMath.TWO_PI;\n  }\n\n  // Add on previous revolutions\n  trueAnomaly += revs * CesiumMath.TWO_PI;\n\n  return trueAnomaly;\n}\n\n// Calculates the transformation matrix to convert from the perifocal (PQW) coordinate\n// system to inertial cartesian coordinates.\nfunction perifocalToCartesianMatrix(\n  argumentOfPeriapsis,\n  inclination,\n  rightAscension,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (inclination < 0 || inclination > CesiumMath.PI) {\n    throw new DeveloperError(\"inclination out of range\");\n  }\n  //>>includeEnd('debug');\n\n  const cosap = Math.cos(argumentOfPeriapsis);\n  const sinap = Math.sin(argumentOfPeriapsis);\n\n  const cosi = Math.cos(inclination);\n  const sini = Math.sin(inclination);\n\n  const cosraan = Math.cos(rightAscension);\n  const sinraan = Math.sin(rightAscension);\n  if (!defined(result)) {\n    result = new Matrix3(\n      cosraan * cosap - sinraan * sinap * cosi,\n      -cosraan * sinap - sinraan * cosap * cosi,\n      sinraan * sini,\n\n      sinraan * cosap + cosraan * sinap * cosi,\n      -sinraan * sinap + cosraan * cosap * cosi,\n      -cosraan * sini,\n\n      sinap * sini,\n      cosap * sini,\n      cosi,\n    );\n  } else {\n    result[0] = cosraan * cosap - sinraan * sinap * cosi;\n    result[1] = sinraan * cosap + cosraan * sinap * cosi;\n    result[2] = sinap * sini;\n    result[3] = -cosraan * sinap - sinraan * cosap * cosi;\n    result[4] = -sinraan * sinap + cosraan * cosap * cosi;\n    result[5] = cosap * sini;\n    result[6] = sinraan * sini;\n    result[7] = -cosraan * sini;\n    result[8] = cosi;\n  }\n  return result;\n}\n\n// From section 5.8\nconst semiMajorAxis0 = 1.0000010178 * MetersPerAstronomicalUnit;\nconst meanLongitude0 = 100.46645683 * RadiansPerDegree;\nconst meanLongitude1 = 1295977422.83429 * RadiansPerArcSecond;\n\n// From table 6\nconst p1u = 16002;\nconst p2u = 21863;\nconst p3u = 32004;\nconst p4u = 10931;\nconst p5u = 14529;\nconst p6u = 16368;\nconst p7u = 15318;\nconst p8u = 32794;\n\nconst Ca1 = 64 * 1e-7 * MetersPerAstronomicalUnit;\nconst Ca2 = -152 * 1e-7 * MetersPerAstronomicalUnit;\nconst Ca3 = 62 * 1e-7 * MetersPerAstronomicalUnit;\nconst Ca4 = -8 * 1e-7 * MetersPerAstronomicalUnit;\nconst Ca5 = 32 * 1e-7 * MetersPerAstronomicalUnit;\nconst Ca6 = -41 * 1e-7 * MetersPerAstronomicalUnit;\nconst Ca7 = 19 * 1e-7 * MetersPerAstronomicalUnit;\nconst Ca8 = -11 * 1e-7 * MetersPerAstronomicalUnit;\n\nconst Sa1 = -150 * 1e-7 * MetersPerAstronomicalUnit;\nconst Sa2 = -46 * 1e-7 * MetersPerAstronomicalUnit;\nconst Sa3 = 68 * 1e-7 * MetersPerAstronomicalUnit;\nconst Sa4 = 54 * 1e-7 * MetersPerAstronomicalUnit;\nconst Sa5 = 14 * 1e-7 * MetersPerAstronomicalUnit;\nconst Sa6 = 24 * 1e-7 * MetersPerAstronomicalUnit;\nconst Sa7 = -28 * 1e-7 * MetersPerAstronomicalUnit;\nconst Sa8 = 22 * 1e-7 * MetersPerAstronomicalUnit;\n\nconst q1u = 10;\nconst q2u = 16002;\nconst q3u = 21863;\nconst q4u = 10931;\nconst q5u = 1473;\nconst q6u = 32004;\nconst q7u = 4387;\nconst q8u = 73;\n\nconst Cl1 = -325 * 1e-7;\nconst Cl2 = -322 * 1e-7;\nconst Cl3 = -79 * 1e-7;\nconst Cl4 = 232 * 1e-7;\nconst Cl5 = -52 * 1e-7;\nconst Cl6 = 97 * 1e-7;\nconst Cl7 = 55 * 1e-7;\nconst Cl8 = -41 * 1e-7;\n\nconst Sl1 = -105 * 1e-7;\nconst Sl2 = -137 * 1e-7;\nconst Sl3 = 258 * 1e-7;\nconst Sl4 = 35 * 1e-7;\nconst Sl5 = -116 * 1e-7;\nconst Sl6 = -88 * 1e-7;\nconst Sl7 = -112 * 1e-7;\nconst Sl8 = -80 * 1e-7;\n\nconst scratchDate = new JulianDate(0, 0.0, TimeStandard.TAI);\n// Gets a point describing the motion of the Earth-Moon barycenter according to the equations described in section 6.\nfunction computeSimonEarthMoonBarycenter(date, result) {\n  // t is thousands of years from J2000 TDB\n  taiToTdb(date, scratchDate);\n  const x =\n    scratchDate.dayNumber -\n    epoch.dayNumber +\n    (scratchDate.secondsOfDay - epoch.secondsOfDay) /\n      TimeConstants.SECONDS_PER_DAY;\n  const t = x / (TimeConstants.DAYS_PER_JULIAN_CENTURY * 10.0);\n\n  const u = 0.3595362 * t;\n  const semimajorAxis =\n    semiMajorAxis0 +\n    Ca1 * Math.cos(p1u * u) +\n    Sa1 * Math.sin(p1u * u) +\n    Ca2 * Math.cos(p2u * u) +\n    Sa2 * Math.sin(p2u * u) +\n    Ca3 * Math.cos(p3u * u) +\n    Sa3 * Math.sin(p3u * u) +\n    Ca4 * Math.cos(p4u * u) +\n    Sa4 * Math.sin(p4u * u) +\n    Ca5 * Math.cos(p5u * u) +\n    Sa5 * Math.sin(p5u * u) +\n    Ca6 * Math.cos(p6u * u) +\n    Sa6 * Math.sin(p6u * u) +\n    Ca7 * Math.cos(p7u * u) +\n    Sa7 * Math.sin(p7u * u) +\n    Ca8 * Math.cos(p8u * u) +\n    Sa8 * Math.sin(p8u * u);\n  const meanLongitude =\n    meanLongitude0 +\n    meanLongitude1 * t +\n    Cl1 * Math.cos(q1u * u) +\n    Sl1 * Math.sin(q1u * u) +\n    Cl2 * Math.cos(q2u * u) +\n    Sl2 * Math.sin(q2u * u) +\n    Cl3 * Math.cos(q3u * u) +\n    Sl3 * Math.sin(q3u * u) +\n    Cl4 * Math.cos(q4u * u) +\n    Sl4 * Math.sin(q4u * u) +\n    Cl5 * Math.cos(q5u * u) +\n    Sl5 * Math.sin(q5u * u) +\n    Cl6 * Math.cos(q6u * u) +\n    Sl6 * Math.sin(q6u * u) +\n    Cl7 * Math.cos(q7u * u) +\n    Sl7 * Math.sin(q7u * u) +\n    Cl8 * Math.cos(q8u * u) +\n    Sl8 * Math.sin(q8u * u);\n\n  // All constants in this part are from section 5.8\n  const eccentricity = 0.0167086342 - 0.0004203654 * t;\n  const longitudeOfPerigee =\n    102.93734808 * RadiansPerDegree + 11612.3529 * RadiansPerArcSecond * t;\n  const inclination = 469.97289 * RadiansPerArcSecond * t;\n  const longitudeOfNode =\n    174.87317577 * RadiansPerDegree - 8679.27034 * RadiansPerArcSecond * t;\n\n  return elementsToCartesian(\n    semimajorAxis,\n    eccentricity,\n    inclination,\n    longitudeOfPerigee,\n    longitudeOfNode,\n    meanLongitude,\n    result,\n  );\n}\n\n// Gets a point describing the position of the moon according to the equations described in section 4.\nfunction computeSimonMoon(date, result) {\n  taiToTdb(date, scratchDate);\n  const x =\n    scratchDate.dayNumber -\n    epoch.dayNumber +\n    (scratchDate.secondsOfDay - epoch.secondsOfDay) /\n      TimeConstants.SECONDS_PER_DAY;\n  const t = x / TimeConstants.DAYS_PER_JULIAN_CENTURY;\n  const t2 = t * t;\n  const t3 = t2 * t;\n  const t4 = t3 * t;\n\n  // Terms from section 3.4 (b.1)\n  let semimajorAxis = 383397.7725 + 0.004 * t;\n  let eccentricity = 0.055545526 - 0.000000016 * t;\n  const inclinationConstant = 5.15668983 * RadiansPerDegree;\n  let inclinationSecPart =\n    -0.00008 * t + 0.02966 * t2 - 0.000042 * t3 - 0.00000013 * t4;\n  const longitudeOfPerigeeConstant = 83.35324312 * RadiansPerDegree;\n  let longitudeOfPerigeeSecPart =\n    14643420.2669 * t - 38.2702 * t2 - 0.045047 * t3 + 0.00021301 * t4;\n  const longitudeOfNodeConstant = 125.04455501 * RadiansPerDegree;\n  let longitudeOfNodeSecPart =\n    -6967919.3631 * t + 6.3602 * t2 + 0.007625 * t3 - 0.00003586 * t4;\n  const meanLongitudeConstant = 218.31664563 * RadiansPerDegree;\n  let meanLongitudeSecPart =\n    1732559343.4847 * t - 6.391 * t2 + 0.006588 * t3 - 0.00003169 * t4;\n\n  // Delaunay arguments from section 3.5 b\n  const D =\n    297.85019547 * RadiansPerDegree +\n    RadiansPerArcSecond *\n      (1602961601.209 * t - 6.3706 * t2 + 0.006593 * t3 - 0.00003169 * t4);\n  const F =\n    93.27209062 * RadiansPerDegree +\n    RadiansPerArcSecond *\n      (1739527262.8478 * t - 12.7512 * t2 - 0.001037 * t3 + 0.00000417 * t4);\n  const l =\n    134.96340251 * RadiansPerDegree +\n    RadiansPerArcSecond *\n      (1717915923.2178 * t + 31.8792 * t2 + 0.051635 * t3 - 0.0002447 * t4);\n  const lprime =\n    357.52910918 * RadiansPerDegree +\n    RadiansPerArcSecond *\n      (129596581.0481 * t - 0.5532 * t2 + 0.000136 * t3 - 0.00001149 * t4);\n  const psi =\n    310.17137918 * RadiansPerDegree -\n    RadiansPerArcSecond *\n      (6967051.436 * t + 6.2068 * t2 + 0.007618 * t3 - 0.00003219 * t4);\n\n  // Add terms from Table 4\n  const twoD = 2.0 * D;\n  const fourD = 4.0 * D;\n  const sixD = 6.0 * D;\n  const twol = 2.0 * l;\n  const threel = 3.0 * l;\n  const fourl = 4.0 * l;\n  const twoF = 2.0 * F;\n  semimajorAxis +=\n    3400.4 * Math.cos(twoD) -\n    635.6 * Math.cos(twoD - l) -\n    235.6 * Math.cos(l) +\n    218.1 * Math.cos(twoD - lprime) +\n    181.0 * Math.cos(twoD + l);\n  eccentricity +=\n    0.014216 * Math.cos(twoD - l) +\n    0.008551 * Math.cos(twoD - twol) -\n    0.001383 * Math.cos(l) +\n    0.001356 * Math.cos(twoD + l) -\n    0.001147 * Math.cos(fourD - threel) -\n    0.000914 * Math.cos(fourD - twol) +\n    0.000869 * Math.cos(twoD - lprime - l) -\n    0.000627 * Math.cos(twoD) -\n    0.000394 * Math.cos(fourD - fourl) +\n    0.000282 * Math.cos(twoD - lprime - twol) -\n    0.000279 * Math.cos(D - l) -\n    0.000236 * Math.cos(twol) +\n    0.000231 * Math.cos(fourD) +\n    0.000229 * Math.cos(sixD - fourl) -\n    0.000201 * Math.cos(twol - twoF);\n  inclinationSecPart +=\n    486.26 * Math.cos(twoD - twoF) -\n    40.13 * Math.cos(twoD) +\n    37.51 * Math.cos(twoF) +\n    25.73 * Math.cos(twol - twoF) +\n    19.97 * Math.cos(twoD - lprime - twoF);\n  longitudeOfPerigeeSecPart +=\n    -55609 * Math.sin(twoD - l) -\n    34711 * Math.sin(twoD - twol) -\n    9792 * Math.sin(l) +\n    9385 * Math.sin(fourD - threel) +\n    7505 * Math.sin(fourD - twol) +\n    5318 * Math.sin(twoD + l) +\n    3484 * Math.sin(fourD - fourl) -\n    3417 * Math.sin(twoD - lprime - l) -\n    2530 * Math.sin(sixD - fourl) -\n    2376 * Math.sin(twoD) -\n    2075 * Math.sin(twoD - threel) -\n    1883 * Math.sin(twol) -\n    1736 * Math.sin(sixD - 5.0 * l) +\n    1626 * Math.sin(lprime) -\n    1370 * Math.sin(sixD - threel);\n  longitudeOfNodeSecPart +=\n    -5392 * Math.sin(twoD - twoF) -\n    540 * Math.sin(lprime) -\n    441 * Math.sin(twoD) +\n    423 * Math.sin(twoF) -\n    288 * Math.sin(twol - twoF);\n  meanLongitudeSecPart +=\n    -3332.9 * Math.sin(twoD) +\n    1197.4 * Math.sin(twoD - l) -\n    662.5 * Math.sin(lprime) +\n    396.3 * Math.sin(l) -\n    218.0 * Math.sin(twoD - lprime);\n\n  // Add terms from Table 5\n  const twoPsi = 2.0 * psi;\n  const threePsi = 3.0 * psi;\n  inclinationSecPart +=\n    46.997 * Math.cos(psi) * t -\n    0.614 * Math.cos(twoD - twoF + psi) * t +\n    0.614 * Math.cos(twoD - twoF - psi) * t -\n    0.0297 * Math.cos(twoPsi) * t2 -\n    0.0335 * Math.cos(psi) * t2 +\n    0.0012 * Math.cos(twoD - twoF + twoPsi) * t2 -\n    0.00016 * Math.cos(psi) * t3 +\n    0.00004 * Math.cos(threePsi) * t3 +\n    0.00004 * Math.cos(twoPsi) * t3;\n  const perigeeAndMean =\n    2.116 * Math.sin(psi) * t -\n    0.111 * Math.sin(twoD - twoF - psi) * t -\n    0.0015 * Math.sin(psi) * t2;\n  longitudeOfPerigeeSecPart += perigeeAndMean;\n  meanLongitudeSecPart += perigeeAndMean;\n  longitudeOfNodeSecPart +=\n    -520.77 * Math.sin(psi) * t +\n    13.66 * Math.sin(twoD - twoF + psi) * t +\n    1.12 * Math.sin(twoD - psi) * t -\n    1.06 * Math.sin(twoF - psi) * t +\n    0.66 * Math.sin(twoPsi) * t2 +\n    0.371 * Math.sin(psi) * t2 -\n    0.035 * Math.sin(twoD - twoF + twoPsi) * t2 -\n    0.015 * Math.sin(twoD - twoF + psi) * t2 +\n    0.0014 * Math.sin(psi) * t3 -\n    0.0011 * Math.sin(threePsi) * t3 -\n    0.0009 * Math.sin(twoPsi) * t3;\n\n  // Add constants and convert units\n  semimajorAxis *= MetersPerKilometer;\n  const inclination =\n    inclinationConstant + inclinationSecPart * RadiansPerArcSecond;\n  const longitudeOfPerigee =\n    longitudeOfPerigeeConstant +\n    longitudeOfPerigeeSecPart * RadiansPerArcSecond;\n  const meanLongitude =\n    meanLongitudeConstant + meanLongitudeSecPart * RadiansPerArcSecond;\n  const longitudeOfNode =\n    longitudeOfNodeConstant + longitudeOfNodeSecPart * RadiansPerArcSecond;\n\n  return elementsToCartesian(\n    semimajorAxis,\n    eccentricity,\n    inclination,\n    longitudeOfPerigee,\n    longitudeOfNode,\n    meanLongitude,\n    result,\n  );\n}\n\n// Gets a point describing the motion of the Earth.  This point uses the Moon point and\n// the 1992 mu value (ratio between Moon and Earth masses) in Table 2 of the paper in order\n// to determine the position of the Earth relative to the Earth-Moon barycenter.\nconst moonEarthMassRatio = 0.012300034; // From 1992 mu value in Table 2\nconst factor = (moonEarthMassRatio / (moonEarthMassRatio + 1.0)) * -1;\nfunction computeSimonEarth(date, result) {\n  result = computeSimonMoon(date, result);\n  return Cartesian3.multiplyByScalar(result, factor, result);\n}\n\n// Values for the <code>axesTransformation</code> needed for the rotation were found using the STK Components\n// GeographicTransformer on the position of the sun center of mass point and the earth J2000 frame.\n\nconst axesTransformation = new Matrix3(\n  1.0000000000000002,\n  5.619723173785822e-16,\n  4.690511510146299e-19,\n  -5.154129427414611e-16,\n  0.9174820620691819,\n  -0.39777715593191376,\n  -2.23970096136568e-16,\n  0.39777715593191376,\n  0.9174820620691819,\n);\nlet translation = new Cartesian3();\n\n/**\n * Computes the position of the Sun in the Earth-centered inertial frame\n *\n * @param {JulianDate} [julianDate] The time at which to compute the Sun's position, if not provided the current system time is used.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} Calculated sun position\n */\nSimon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame = function (\n  julianDate,\n  result,\n) {\n  if (!defined(julianDate)) {\n    julianDate = JulianDate.now();\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  //first forward transformation\n  translation = computeSimonEarthMoonBarycenter(julianDate, translation);\n  result = Cartesian3.negate(translation, result);\n\n  //second forward transformation\n  computeSimonEarth(julianDate, translation);\n\n  Cartesian3.subtract(result, translation, result);\n  Matrix3.multiplyByVector(axesTransformation, result, result);\n\n  return result;\n};\n\n/**\n * Computes the position of the Moon in the Earth-centered inertial frame\n *\n * @param {JulianDate} [julianDate] The time at which to compute the Moon's position, if not provided the current system time is used.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} Calculated moon position\n */\nSimon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame = function (\n  julianDate,\n  result,\n) {\n  if (!defined(julianDate)) {\n    julianDate = JulianDate.now();\n  }\n\n  result = computeSimonMoon(julianDate, result);\n  Matrix3.multiplyByVector(axesTransformation, result, result);\n\n  return result;\n};\n\nexport default Simon1994PlanetaryPositions;\n"],"names":["Simon1994PlanetaryPositions","computeTdbMinusTtSpice","daysSinceJ2000InTerrestrialTime","g","Math","sin","TdtMinusTai","J2000d","taiToTdb","date","result","addSeconds","days","totalDays","epoch","TAI","MetersPerKilometer","RadiansPerDegree","RADIANS_PER_DEGREE","RadiansPerArcSecond","RADIANS_PER_ARCSECOND","MetersPerAstronomicalUnit","perifocalToEquatorial","elementsToCartesian","semimajorAxis","eccentricity","inclination","longitudeOfPerigee","longitudeOfNode","meanLongitude","PI","radiusOfPeriapsis","argumentOfPeriapsis","rightAscensionOfAscendingNode","trueAnomaly","meanAnomalyToTrueAnomaly","type","chooseOrbit","abs","negativePiToPi","acos","perifocalToCartesianMatrix","semilatus","costheta","cos","sintheta","denom","Epsilon10","radius","x","y","z","multiplyByVector","tolerance","meanAnomaly","eccentricAnomaly","meanAnomalyToEccentricAnomaly","eccentricAnomalyToTrueAnomaly","maxIterationCount","keplerEqConvergence","EPSILON8","revs","floor","TWO_PI","iterationValue","Number","MAX_VALUE","count","NRfunction","dNRfunction","trueAnomalyX","trueAnomalyY","sqrt","atan2","zeroToTwoPi","rightAscension","cosap","sinap","cosi","sini","cosraan","sinraan","semiMajorAxis0","meanLongitude0","meanLongitude1","p1u","p2u","p3u","p4u","p5u","p6u","p7u","p8u","Ca1","Ca2","Ca3","Ca4","Ca5","Ca6","Ca7","Ca8","Sa1","Sa2","Sa3","Sa4","Sa5","Sa6","Sa7","Sa8","q1u","q2u","q3u","q4u","q5u","q6u","q7u","q8u","Cl1","Cl2","Cl3","Cl4","Cl5","Cl6","Cl7","Cl8","Sl1","Sl2","Sl3","Sl4","Sl5","Sl6","Sl7","Sl8","scratchDate","computeSimonEarthMoonBarycenter","dayNumber","secondsOfDay","SECONDS_PER_DAY","t","DAYS_PER_JULIAN_CENTURY","u","computeSimonMoon","t2","t3","t4","inclinationConstant","inclinationSecPart","longitudeOfPerigeeConstant","longitudeOfPerigeeSecPart","longitudeOfNodeConstant","longitudeOfNodeSecPart","meanLongitudeConstant","meanLongitudeSecPart","D","F","l","lprime","psi","twoD","fourD","sixD","twol","threel","fourl","twoF","twoPsi","threePsi","perigeeAndMean","moonEarthMassRatio","factor","computeSimonEarth","multiplyByScalar","axesTransformation","translation","computeSunPositionInEarthInertialFrame","julianDate","now","negate","subtract","computeMoonPositionInEarthInertialFrame"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 57824, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/mergeSort.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\nconst leftScratchArray = [];\nconst rightScratchArray = [];\n\nfunction merge(array, compare, userDefinedObject, start, middle, end) {\n  const leftLength = middle - start + 1;\n  const rightLength = end - middle;\n\n  const left = leftScratchArray;\n  const right = rightScratchArray;\n\n  let i;\n  let j;\n\n  for (i = 0; i < leftLength; ++i) {\n    left[i] = array[start + i];\n  }\n\n  for (j = 0; j < rightLength; ++j) {\n    right[j] = array[middle + j + 1];\n  }\n\n  i = 0;\n  j = 0;\n  for (let k = start; k <= end; ++k) {\n    const leftElement = left[i];\n    const rightElement = right[j];\n    if (\n      i < leftLength &&\n      (j >= rightLength ||\n        compare(leftElement, rightElement, userDefinedObject) <= 0)\n    ) {\n      array[k] = leftElement;\n      ++i;\n    } else if (j < rightLength) {\n      array[k] = rightElement;\n      ++j;\n    }\n  }\n}\n\nfunction sort(array, compare, userDefinedObject, start, end) {\n  if (start >= end) {\n    return;\n  }\n\n  const middle = Math.floor((start + end) * 0.5);\n  sort(array, compare, userDefinedObject, start, middle);\n  sort(array, compare, userDefinedObject, middle + 1, end);\n  merge(array, compare, userDefinedObject, start, middle, end);\n}\n\n/**\n * A stable merge sort.\n *\n * @function mergeSort\n * @param {Array|Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} array The array to sort.\n * @param {mergeSortComparator} comparator The function to use to compare elements in the array.\n * @param {*} [userDefinedObject] Any item to pass as the third parameter to <code>comparator</code>.\n *\n * @example\n * // Assume array contains BoundingSpheres in world coordinates.\n * // Sort them in ascending order of distance from the camera.\n * const position = camera.positionWC;\n * Cesium.mergeSort(array, function(a, b, position) {\n *     return Cesium.BoundingSphere.distanceSquaredTo(b, position) - Cesium.BoundingSphere.distanceSquaredTo(a, position);\n * }, position);\n */\nfunction mergeSort(array, comparator, userDefinedObject) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required.\");\n  }\n  if (!defined(comparator)) {\n    throw new DeveloperError(\"comparator is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const scratchLength = Math.ceil(length * 0.5);\n\n  // preallocate space in scratch arrays\n  leftScratchArray.length = scratchLength;\n  rightScratchArray.length = scratchLength;\n\n  sort(array, comparator, userDefinedObject, 0, length - 1);\n\n  // trim scratch arrays\n  leftScratchArray.length = 0;\n  rightScratchArray.length = 0;\n}\n\n/**\n * A function used to compare two items while performing a merge sort.\n * @callback mergeSortComparator\n *\n * @param {*} a An item in the array.\n * @param {*} b An item in the array.\n * @param {*} [userDefinedObject] An object that was passed to {@link mergeSort}.\n * @returns {number} Returns a negative value if <code>a</code> is less than <code>b</code>,\n *          a positive value if <code>a</code> is greater than <code>b</code>, or\n *          0 if <code>a</code> is equal to <code>b</code>.\n *\n * @example\n * function compareNumbers(a, b, userDefinedObject) {\n *     return a - b;\n * }\n */\nexport default mergeSort;\n"],"names":["leftScratchArray","rightScratchArray","merge","array","compare","userDefinedObject","start","middle","end","leftLength","rightLength","left","right","i","j","k","leftElement","rightElement","sort","Math","floor","mergeSort","comparator","length","scratchLength","ceil"],"mappings":";;;;AAAA;AACA;;;AAEA,MAAMA,mBAAmB,EAAE;AAC3B,MAAMC,oBAAoB,EAAE;AAE5B,SAASC,MAAMC,KAAK,EAAEC,OAAO,EAAEC,iBAAiB,EAAEC,KAAK,EAAEC,MAAM,EAAEC,GAAG;IAClE,MAAMC,aAAaF,SAASD,QAAQ;IACpC,MAAMI,cAAcF,MAAMD;IAE1B,MAAMI,OAAOX;IACb,MAAMY,QAAQX;IAEd,IAAIY;IACJ,IAAIC;IAEJ,IAAKD,IAAI,GAAGA,IAAIJ,YAAY,EAAEI,EAAG;QAC/BF,IAAI,CAACE,EAAE,GAAGV,KAAK,CAACG,QAAQO,EAAE;IAC5B;IAEA,IAAKC,IAAI,GAAGA,IAAIJ,aAAa,EAAEI,EAAG;QAChCF,KAAK,CAACE,EAAE,GAAGX,KAAK,CAACI,SAASO,IAAI,EAAE;IAClC;IAEAD,IAAI;IACJC,IAAI;IACJ,IAAK,IAAIC,IAAIT,OAAOS,KAAKP,KAAK,EAAEO,EAAG;QACjC,MAAMC,cAAcL,IAAI,CAACE,EAAE;QAC3B,MAAMI,eAAeL,KAAK,CAACE,EAAE;QAC7B,IACED,IAAIJ,cACJ,CAACK,KAAKJ,eACJN,QAAQY,aAAaC,cAAcZ,sBAAsB,CAAC,GAC5D;YACAF,KAAK,CAACY,EAAE,GAAGC;YACX,EAAEH;QACJ,OAAO,IAAIC,IAAIJ,aAAa;YAC1BP,KAAK,CAACY,EAAE,GAAGE;YACX,EAAEH;QACJ;IACF;AACF;AAEA,SAASI,KAAKf,KAAK,EAAEC,OAAO,EAAEC,iBAAiB,EAAEC,KAAK,EAAEE,GAAG;IACzD,IAAIF,SAASE,KAAK;QAChB;IACF;IAEA,MAAMD,SAASY,KAAKC,KAAK,CAAC,CAACd,QAAQE,GAAG,IAAI;IAC1CU,KAAKf,OAAOC,SAASC,mBAAmBC,OAAOC;IAC/CW,KAAKf,OAAOC,SAASC,mBAAmBE,SAAS,GAAGC;IACpDN,MAAMC,OAAOC,SAASC,mBAAmBC,OAAOC,QAAQC;AAC1D;AAEA;;;;;;;;;;;;;;;CAeC,GACD,SAASa,UAAUlB,KAAK,EAAEmB,UAAU,EAAEjB,iBAAiB;IACrD,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAACF,QAAQ;QACnB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACmB,aAAa;QACxB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,wBAAwB;IAExB,MAAMC,SAASpB,MAAMoB,MAAM;IAC3B,MAAMC,gBAAgBL,KAAKM,IAAI,CAACF,SAAS;IAEzC,sCAAsC;IACtCvB,iBAAiBuB,MAAM,GAAGC;IAC1BvB,kBAAkBsB,MAAM,GAAGC;IAE3BN,KAAKf,OAAOmB,YAAYjB,mBAAmB,GAAGkB,SAAS;IAEvD,sBAAsB;IACtBvB,iBAAiBuB,MAAM,GAAG;IAC1BtB,kBAAkBsB,MAAM,GAAG;AAC7B;uCAkBeF","ignoreList":[0]}},
    {"offset": {"line": 57909, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Occluder.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Visibility from \"./Visibility.js\";\n\n/**\n * Creates an Occluder derived from an object's position and radius, as well as the camera position.\n * The occluder can be used to determine whether or not other objects are visible or hidden behind the\n * visible horizon defined by the occluder and camera position.\n *\n * @alias Occluder\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.\n *\n * @constructor\n *\n * @example\n * // Construct an occluder one unit away from the origin with a radius of one.\n * const cameraPosition = Cesium.Cartesian3.ZERO;\n * const occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 1);\n * const occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);\n */\nfunction Occluder(occluderBoundingSphere, cameraPosition) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n  if (!defined(cameraPosition)) {\n    throw new DeveloperError(\"camera position is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._occluderPosition = Cartesian3.clone(occluderBoundingSphere.center);\n  this._occluderRadius = occluderBoundingSphere.radius;\n\n  this._horizonDistance = 0.0;\n  this._horizonPlaneNormal = undefined;\n  this._horizonPlanePosition = undefined;\n  this._cameraPosition = undefined;\n\n  // cameraPosition fills in the above values\n  this.cameraPosition = cameraPosition;\n}\n\nconst scratchCartesian3 = new Cartesian3();\n\nObject.defineProperties(Occluder.prototype, {\n  /**\n   * The position of the occluder.\n   * @memberof Occluder.prototype\n   * @type {Cartesian3}\n   */\n  position: {\n    get: function () {\n      return this._occluderPosition;\n    },\n  },\n\n  /**\n   * The radius of the occluder.\n   * @memberof Occluder.prototype\n   * @type {number}\n   */\n  radius: {\n    get: function () {\n      return this._occluderRadius;\n    },\n  },\n\n  /**\n   * The position of the camera.\n   * @memberof Occluder.prototype\n   * @type {Cartesian3}\n   */\n  cameraPosition: {\n    set: function (cameraPosition) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(cameraPosition)) {\n        throw new DeveloperError(\"cameraPosition is required.\");\n      }\n      //>>includeEnd('debug');\n\n      cameraPosition = Cartesian3.clone(cameraPosition, this._cameraPosition);\n\n      const cameraToOccluderVec = Cartesian3.subtract(\n        this._occluderPosition,\n        cameraPosition,\n        scratchCartesian3,\n      );\n      let invCameraToOccluderDistance =\n        Cartesian3.magnitudeSquared(cameraToOccluderVec);\n      const occluderRadiusSqrd = this._occluderRadius * this._occluderRadius;\n\n      let horizonDistance;\n      let horizonPlaneNormal;\n      let horizonPlanePosition;\n      if (invCameraToOccluderDistance > occluderRadiusSqrd) {\n        horizonDistance = Math.sqrt(\n          invCameraToOccluderDistance - occluderRadiusSqrd,\n        );\n        invCameraToOccluderDistance =\n          1.0 / Math.sqrt(invCameraToOccluderDistance);\n        horizonPlaneNormal = Cartesian3.multiplyByScalar(\n          cameraToOccluderVec,\n          invCameraToOccluderDistance,\n          scratchCartesian3,\n        );\n        const nearPlaneDistance =\n          horizonDistance * horizonDistance * invCameraToOccluderDistance;\n        horizonPlanePosition = Cartesian3.add(\n          cameraPosition,\n          Cartesian3.multiplyByScalar(\n            horizonPlaneNormal,\n            nearPlaneDistance,\n            scratchCartesian3,\n          ),\n          scratchCartesian3,\n        );\n      } else {\n        horizonDistance = Number.MAX_VALUE;\n      }\n\n      this._horizonDistance = horizonDistance;\n      this._horizonPlaneNormal = horizonPlaneNormal;\n      this._horizonPlanePosition = horizonPlanePosition;\n      this._cameraPosition = cameraPosition;\n    },\n  },\n});\n\n/**\n * Creates an occluder from a bounding sphere and the camera position.\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.\n * @param {Occluder} [result] The object onto which to store the result.\n * @returns {Occluder} The occluder derived from an object's position and radius, as well as the camera position.\n */\nOccluder.fromBoundingSphere = function (\n  occluderBoundingSphere,\n  cameraPosition,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n\n  if (!defined(cameraPosition)) {\n    throw new DeveloperError(\"camera position is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Occluder(occluderBoundingSphere, cameraPosition);\n  }\n\n  Cartesian3.clone(occluderBoundingSphere.center, result._occluderPosition);\n  result._occluderRadius = occluderBoundingSphere.radius;\n  result.cameraPosition = cameraPosition;\n\n  return result;\n};\n\nconst tempVecScratch = new Cartesian3();\n\n/**\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {Cartesian3} occludee The point surrounding the occludee object.\n * @returns {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);\n * const occluder = new Cesium.Occluder(littleSphere, cameraPosition);\n * const point = new Cesium.Cartesian3(0, 0, -3);\n * occluder.isPointVisible(point); //returns true\n *\n * @see Occluder#computeVisibility\n */\nOccluder.prototype.isPointVisible = function (occludee) {\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    let tempVec = Cartesian3.subtract(\n      occludee,\n      this._occluderPosition,\n      tempVecScratch,\n    );\n    let temp = this._occluderRadius;\n    temp = Cartesian3.magnitudeSquared(tempVec) - temp * temp;\n    if (temp > 0.0) {\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      tempVec = Cartesian3.subtract(occludee, this._cameraPosition, tempVec);\n      return temp * temp > Cartesian3.magnitudeSquared(tempVec);\n    }\n  }\n  return false;\n};\n\nconst occludeePositionScratch = new Cartesian3();\n\n/**\n * Determines whether or not a sphere, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {BoundingSphere} occludee The bounding sphere surrounding the occludee object.\n * @returns {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);\n * const occluder = new Cesium.Occluder(littleSphere, cameraPosition);\n * const bigSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -3), 1);\n * occluder.isBoundingSphereVisible(bigSphere); //returns true\n *\n * @see Occluder#computeVisibility\n */\nOccluder.prototype.isBoundingSphereVisible = function (occludee) {\n  const occludeePosition = Cartesian3.clone(\n    occludee.center,\n    occludeePositionScratch,\n  );\n  const occludeeRadius = occludee.radius;\n\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    let tempVec = Cartesian3.subtract(\n      occludeePosition,\n      this._occluderPosition,\n      tempVecScratch,\n    );\n    let temp = this._occluderRadius - occludeeRadius;\n    temp = Cartesian3.magnitudeSquared(tempVec) - temp * temp;\n    if (occludeeRadius < this._occluderRadius) {\n      if (temp > 0.0) {\n        temp = Math.sqrt(temp) + this._horizonDistance;\n        tempVec = Cartesian3.subtract(\n          occludeePosition,\n          this._cameraPosition,\n          tempVec,\n        );\n        return (\n          temp * temp + occludeeRadius * occludeeRadius >\n          Cartesian3.magnitudeSquared(tempVec)\n        );\n      }\n      return false;\n    }\n\n    // Prevent against the case where the occludee radius is larger than the occluder's; since this is\n    // an uncommon case, the following code should rarely execute.\n    if (temp > 0.0) {\n      tempVec = Cartesian3.subtract(\n        occludeePosition,\n        this._cameraPosition,\n        tempVec,\n      );\n      const tempVecMagnitudeSquared = Cartesian3.magnitudeSquared(tempVec);\n      const occluderRadiusSquared = this._occluderRadius * this._occluderRadius;\n      const occludeeRadiusSquared = occludeeRadius * occludeeRadius;\n      if (\n        (this._horizonDistance * this._horizonDistance +\n          occluderRadiusSquared) *\n          occludeeRadiusSquared >\n        tempVecMagnitudeSquared * occluderRadiusSquared\n      ) {\n        // The occludee is close enough that the occluder cannot possible occlude the occludee\n        return true;\n      }\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      return temp * temp + occludeeRadiusSquared > tempVecMagnitudeSquared;\n    }\n\n    // The occludee completely encompasses the occluder\n    return true;\n  }\n\n  return false;\n};\n\nconst tempScratch = new Cartesian3();\n/**\n * Determine to what extent an occludee is visible (not visible, partially visible,  or fully visible).\n *\n * @param {BoundingSphere} occludeeBS The bounding sphere of the occludee.\n * @returns {Visibility} Visibility.NONE if the occludee is not visible,\n *                       Visibility.PARTIAL if the occludee is partially visible, or\n *                       Visibility.FULL if the occludee is fully visible.\n *\n *\n * @example\n * const sphere1 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1.5), 0.5);\n * const sphere2 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -2.5), 0.5);\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const occluder = new Cesium.Occluder(sphere1, cameraPosition);\n * occluder.computeVisibility(sphere2); //returns Visibility.NONE\n */\nOccluder.prototype.computeVisibility = function (occludeeBS) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occludeeBS)) {\n    throw new DeveloperError(\"occludeeBS is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // If the occludee radius is larger than the occluders, this will return that\n  // the entire ocludee is visible, even though that may not be the case, though this should\n  // not occur too often.\n  const occludeePosition = Cartesian3.clone(occludeeBS.center);\n  const occludeeRadius = occludeeBS.radius;\n\n  if (occludeeRadius > this._occluderRadius) {\n    return Visibility.FULL;\n  }\n\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    // The camera is outside the occluder\n    let tempVec = Cartesian3.subtract(\n      occludeePosition,\n      this._occluderPosition,\n      tempScratch,\n    );\n    let temp = this._occluderRadius - occludeeRadius;\n    const occluderToOccludeeDistSqrd = Cartesian3.magnitudeSquared(tempVec);\n    temp = occluderToOccludeeDistSqrd - temp * temp;\n    if (temp > 0.0) {\n      // The occludee is not completely inside the occluder\n      // Check to see if the occluder completely hides the occludee\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      tempVec = Cartesian3.subtract(\n        occludeePosition,\n        this._cameraPosition,\n        tempVec,\n      );\n      const cameraToOccludeeDistSqrd = Cartesian3.magnitudeSquared(tempVec);\n      if (\n        temp * temp + occludeeRadius * occludeeRadius <\n        cameraToOccludeeDistSqrd\n      ) {\n        return Visibility.NONE;\n      }\n\n      // Check to see whether the occluder is fully or partially visible\n      // when the occludee does not intersect the occluder\n      temp = this._occluderRadius + occludeeRadius;\n      temp = occluderToOccludeeDistSqrd - temp * temp;\n      if (temp > 0.0) {\n        // The occludee does not intersect the occluder.\n        temp = Math.sqrt(temp) + this._horizonDistance;\n        return cameraToOccludeeDistSqrd <\n          temp * temp + occludeeRadius * occludeeRadius\n          ? Visibility.FULL\n          : Visibility.PARTIAL;\n      }\n\n      //Check to see if the occluder is fully or partially visible when the occludee DOES\n      //intersect the occluder\n      tempVec = Cartesian3.subtract(\n        occludeePosition,\n        this._horizonPlanePosition,\n        tempVec,\n      );\n      return Cartesian3.dot(tempVec, this._horizonPlaneNormal) > -occludeeRadius\n        ? Visibility.PARTIAL\n        : Visibility.FULL;\n    }\n  }\n  return Visibility.NONE;\n};\n\nconst occludeePointScratch = new Cartesian3();\n/**\n * Computes a point that can be used as the occludee position to the visibility functions.\n * Use a radius of zero for the occludee radius.  Typically, a user computes a bounding sphere around\n * an object that is used for visibility; however it is also possible to compute a point that if\n * seen/not seen would also indicate if an object is visible/not visible.  This function is better\n * called for objects that do not move relative to the occluder and is large, such as a chunk of\n * terrain.  You are better off not calling this and using the object's bounding sphere for objects\n * such as a satellite or ground vehicle.\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} occludeePosition The point where the occludee (bounding sphere of radius 0) is located.\n * @param {Cartesian3[]} positions List of altitude points on the horizon near the surface of the occluder.\n * @returns {object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>\n * which is a boolean value.\n *\n * @exception {DeveloperError} <code>positions</code> must contain at least one element.\n * @exception {DeveloperError} <code>occludeePosition</code> must have a value other than <code>occluderBoundingSphere.center</code>.\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -8), 2);\n * const occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);\n * const positions = [new Cesium.Cartesian3(-0.25, 0, -5.3), new Cesium.Cartesian3(0.25, 0, -5.3)];\n * const tileOccluderSphere = Cesium.BoundingSphere.fromPoints(positions);\n * const occludeePosition = tileOccluderSphere.center;\n * const occludeePt = Cesium.Occluder.computeOccludeePoint(occluderBoundingSphere, occludeePosition, positions);\n */\nOccluder.computeOccludeePoint = function (\n  occluderBoundingSphere,\n  occludeePosition,\n  positions,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n  if (!defined(positions)) {\n    throw new DeveloperError(\"positions is required.\");\n  }\n  if (positions.length === 0) {\n    throw new DeveloperError(\"positions must contain at least one element\");\n  }\n  //>>includeEnd('debug');\n\n  const occludeePos = Cartesian3.clone(occludeePosition);\n  const occluderPosition = Cartesian3.clone(occluderBoundingSphere.center);\n  const occluderRadius = occluderBoundingSphere.radius;\n  const numPositions = positions.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (Cartesian3.equals(occluderPosition, occludeePosition)) {\n    throw new DeveloperError(\n      \"occludeePosition must be different than occluderBoundingSphere.center\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  // Compute a plane with a normal from the occluder to the occludee position.\n  const occluderPlaneNormal = Cartesian3.normalize(\n    Cartesian3.subtract(occludeePos, occluderPosition, occludeePointScratch),\n    occludeePointScratch,\n  );\n  const occluderPlaneD = -Cartesian3.dot(occluderPlaneNormal, occluderPosition);\n\n  //For each position, determine the horizon intersection. Choose the position and intersection\n  //that results in the greatest angle with the occcluder plane.\n  const aRotationVector = Occluder._anyRotationVector(\n    occluderPosition,\n    occluderPlaneNormal,\n    occluderPlaneD,\n  );\n  let dot = Occluder._horizonToPlaneNormalDotProduct(\n    occluderBoundingSphere,\n    occluderPlaneNormal,\n    occluderPlaneD,\n    aRotationVector,\n    positions[0],\n  );\n  if (!dot) {\n    //The position is inside the mimimum radius, which is invalid\n    return undefined;\n  }\n  let tempDot;\n  for (let i = 1; i < numPositions; ++i) {\n    tempDot = Occluder._horizonToPlaneNormalDotProduct(\n      occluderBoundingSphere,\n      occluderPlaneNormal,\n      occluderPlaneD,\n      aRotationVector,\n      positions[i],\n    );\n    if (!tempDot) {\n      //The position is inside the minimum radius, which is invalid\n      return undefined;\n    }\n    if (tempDot < dot) {\n      dot = tempDot;\n    }\n  }\n  //Verify that the dot is not near 90 degress\n  // eslint-disable-next-line no-loss-of-precision\n  if (dot < 0.00174532836589830883577820272085) {\n    return undefined;\n  }\n\n  const distance = occluderRadius / dot;\n  return Cartesian3.add(\n    occluderPosition,\n    Cartesian3.multiplyByScalar(\n      occluderPlaneNormal,\n      distance,\n      occludeePointScratch,\n    ),\n    occludeePointScratch,\n  );\n};\n\nconst computeOccludeePointFromRectangleScratch = [];\n/**\n * Computes a point that can be used as the occludee position to the visibility functions from a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle used to create a bounding sphere.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid used to determine positions of the rectangle.\n * @returns {object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>\n * which is a boolean value.\n */\nOccluder.computeOccludeePointFromRectangle = function (rectangle, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required.\");\n  }\n  //>>includeEnd('debug');\n\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n  const positions = Rectangle.subsample(\n    rectangle,\n    ellipsoid,\n    0.0,\n    computeOccludeePointFromRectangleScratch,\n  );\n  const bs = BoundingSphere.fromPoints(positions);\n\n  // Assumes the ellipsoid is centered at the origin\n  const ellipsoidCenter = Cartesian3.ZERO;\n  if (!Cartesian3.equals(ellipsoidCenter, bs.center)) {\n    return Occluder.computeOccludeePoint(\n      new BoundingSphere(ellipsoidCenter, ellipsoid.minimumRadius),\n      bs.center,\n      positions,\n    );\n  }\n\n  return undefined;\n};\n\nconst tempVec0Scratch = new Cartesian3();\nOccluder._anyRotationVector = function (\n  occluderPosition,\n  occluderPlaneNormal,\n  occluderPlaneD,\n) {\n  const tempVec0 = Cartesian3.abs(occluderPlaneNormal, tempVec0Scratch);\n  let majorAxis = tempVec0.x > tempVec0.y ? 0 : 1;\n  if (\n    (majorAxis === 0 && tempVec0.z > tempVec0.x) ||\n    (majorAxis === 1 && tempVec0.z > tempVec0.y)\n  ) {\n    majorAxis = 2;\n  }\n  const tempVec = new Cartesian3();\n  let tempVec1;\n  if (majorAxis === 0) {\n    tempVec0.x = occluderPosition.x;\n    tempVec0.y = occluderPosition.y + 1.0;\n    tempVec0.z = occluderPosition.z + 1.0;\n    tempVec1 = Cartesian3.UNIT_X;\n  } else if (majorAxis === 1) {\n    tempVec0.x = occluderPosition.x + 1.0;\n    tempVec0.y = occluderPosition.y;\n    tempVec0.z = occluderPosition.z + 1.0;\n    tempVec1 = Cartesian3.UNIT_Y;\n  } else {\n    tempVec0.x = occluderPosition.x + 1.0;\n    tempVec0.y = occluderPosition.y + 1.0;\n    tempVec0.z = occluderPosition.z;\n    tempVec1 = Cartesian3.UNIT_Z;\n  }\n  const u =\n    (Cartesian3.dot(occluderPlaneNormal, tempVec0) + occluderPlaneD) /\n    -Cartesian3.dot(occluderPlaneNormal, tempVec1);\n  return Cartesian3.normalize(\n    Cartesian3.subtract(\n      Cartesian3.add(\n        tempVec0,\n        Cartesian3.multiplyByScalar(tempVec1, u, tempVec),\n        tempVec0,\n      ),\n      occluderPosition,\n      tempVec0,\n    ),\n    tempVec0,\n  );\n};\n\nconst posDirectionScratch = new Cartesian3();\nOccluder._rotationVector = function (\n  occluderPosition,\n  occluderPlaneNormal,\n  occluderPlaneD,\n  position,\n  anyRotationVector,\n) {\n  //Determine the angle between the occluder plane normal and the position direction\n  let positionDirection = Cartesian3.subtract(\n    position,\n    occluderPosition,\n    posDirectionScratch,\n  );\n  positionDirection = Cartesian3.normalize(\n    positionDirection,\n    positionDirection,\n  );\n  if (\n    Cartesian3.dot(occluderPlaneNormal, positionDirection) <\n    // eslint-disable-next-line no-loss-of-precision\n    0.99999998476912904932780850903444\n  ) {\n    const crossProduct = Cartesian3.cross(\n      occluderPlaneNormal,\n      positionDirection,\n      positionDirection,\n    );\n    const length = Cartesian3.magnitude(crossProduct);\n    if (length > CesiumMath.EPSILON13) {\n      return Cartesian3.normalize(crossProduct, new Cartesian3());\n    }\n  }\n  //The occluder plane normal and the position direction are colinear. Use any\n  //vector in the occluder plane as the rotation vector\n  return anyRotationVector;\n};\n\nconst posScratch1 = new Cartesian3();\nconst occluerPosScratch = new Cartesian3();\nconst posScratch2 = new Cartesian3();\nconst horizonPlanePosScratch = new Cartesian3();\nOccluder._horizonToPlaneNormalDotProduct = function (\n  occluderBS,\n  occluderPlaneNormal,\n  occluderPlaneD,\n  anyRotationVector,\n  position,\n) {\n  const pos = Cartesian3.clone(position, posScratch1);\n  const occluderPosition = Cartesian3.clone(\n    occluderBS.center,\n    occluerPosScratch,\n  );\n  const occluderRadius = occluderBS.radius;\n\n  //Verify that the position is outside the occluder\n  let positionToOccluder = Cartesian3.subtract(\n    occluderPosition,\n    pos,\n    posScratch2,\n  );\n  const occluderToPositionDistanceSquared =\n    Cartesian3.magnitudeSquared(positionToOccluder);\n  const occluderRadiusSquared = occluderRadius * occluderRadius;\n  if (occluderToPositionDistanceSquared < occluderRadiusSquared) {\n    return false;\n  }\n\n  //Horizon parameters\n  const horizonDistanceSquared =\n    occluderToPositionDistanceSquared - occluderRadiusSquared;\n  const horizonDistance = Math.sqrt(horizonDistanceSquared);\n  const occluderToPositionDistance = Math.sqrt(\n    occluderToPositionDistanceSquared,\n  );\n  const invOccluderToPositionDistance = 1.0 / occluderToPositionDistance;\n  const cosTheta = horizonDistance * invOccluderToPositionDistance;\n  const horizonPlaneDistance = cosTheta * horizonDistance;\n  positionToOccluder = Cartesian3.normalize(\n    positionToOccluder,\n    positionToOccluder,\n  );\n  const horizonPlanePosition = Cartesian3.add(\n    pos,\n    Cartesian3.multiplyByScalar(\n      positionToOccluder,\n      horizonPlaneDistance,\n      horizonPlanePosScratch,\n    ),\n    horizonPlanePosScratch,\n  );\n  const horizonCrossDistance = Math.sqrt(\n    horizonDistanceSquared - horizonPlaneDistance * horizonPlaneDistance,\n  );\n\n  //Rotate the position to occluder vector 90 degrees\n  let tempVec = this._rotationVector(\n    occluderPosition,\n    occluderPlaneNormal,\n    occluderPlaneD,\n    pos,\n    anyRotationVector,\n  );\n  let horizonCrossDirection = Cartesian3.fromElements(\n    tempVec.x * tempVec.x * positionToOccluder.x +\n      (tempVec.x * tempVec.y - tempVec.z) * positionToOccluder.y +\n      (tempVec.x * tempVec.z + tempVec.y) * positionToOccluder.z,\n    (tempVec.x * tempVec.y + tempVec.z) * positionToOccluder.x +\n      tempVec.y * tempVec.y * positionToOccluder.y +\n      (tempVec.y * tempVec.z - tempVec.x) * positionToOccluder.z,\n    (tempVec.x * tempVec.z - tempVec.y) * positionToOccluder.x +\n      (tempVec.y * tempVec.z + tempVec.x) * positionToOccluder.y +\n      tempVec.z * tempVec.z * positionToOccluder.z,\n    posScratch1,\n  );\n  horizonCrossDirection = Cartesian3.normalize(\n    horizonCrossDirection,\n    horizonCrossDirection,\n  );\n\n  //Horizon positions\n  const offset = Cartesian3.multiplyByScalar(\n    horizonCrossDirection,\n    horizonCrossDistance,\n    posScratch1,\n  );\n  tempVec = Cartesian3.normalize(\n    Cartesian3.subtract(\n      Cartesian3.add(horizonPlanePosition, offset, posScratch2),\n      occluderPosition,\n      posScratch2,\n    ),\n    posScratch2,\n  );\n  const dot0 = Cartesian3.dot(occluderPlaneNormal, tempVec);\n  tempVec = Cartesian3.normalize(\n    Cartesian3.subtract(\n      Cartesian3.subtract(horizonPlanePosition, offset, tempVec),\n      occluderPosition,\n      tempVec,\n    ),\n    tempVec,\n  );\n  const dot1 = Cartesian3.dot(occluderPlaneNormal, tempVec);\n  return dot0 < dot1 ? dot0 : dot1;\n};\nexport default Occluder;\n"],"names":["Occluder","occluderBoundingSphere","cameraPosition","_occluderPosition","clone","center","_occluderRadius","radius","_horizonDistance","_horizonPlaneNormal","undefined","_horizonPlanePosition","_cameraPosition","scratchCartesian3","Object","defineProperties","prototype","position","get","set","cameraToOccluderVec","subtract","invCameraToOccluderDistance","magnitudeSquared","occluderRadiusSqrd","horizonDistance","horizonPlaneNormal","horizonPlanePosition","Math","sqrt","multiplyByScalar","nearPlaneDistance","add","Number","MAX_VALUE","fromBoundingSphere","result","tempVecScratch","isPointVisible","occludee","tempVec","temp","occludeePositionScratch","isBoundingSphereVisible","occludeePosition","occludeeRadius","tempVecMagnitudeSquared","occluderRadiusSquared","occludeeRadiusSquared","tempScratch","computeVisibility","occludeeBS","FULL","occluderToOccludeeDistSqrd","cameraToOccludeeDistSqrd","NONE","PARTIAL","dot","occludeePointScratch","computeOccludeePoint","positions","length","occludeePos","occluderPosition","occluderRadius","numPositions","equals","occluderPlaneNormal","normalize","occluderPlaneD","aRotationVector","_anyRotationVector","_horizonToPlaneNormalDotProduct","tempDot","i","distance","computeOccludeePointFromRectangleScratch","computeOccludeePointFromRectangle","rectangle","ellipsoid","default","subsample","bs","fromPoints","ellipsoidCenter","ZERO","minimumRadius","tempVec0Scratch","tempVec0","abs","majorAxis","x","y","z","tempVec1","UNIT_X","UNIT_Y","UNIT_Z","u","posDirectionScratch","_rotationVector","anyRotationVector","positionDirection","crossProduct","cross","magnitude","EPSILON13","posScratch1","occluerPosScratch","posScratch2","horizonPlanePosScratch","occluderBS","pos","positionToOccluder","occluderToPositionDistanceSquared","horizonDistanceSquared","occluderToPositionDistance","invOccluderToPositionDistance","cosTheta","horizonPlaneDistance","horizonCrossDistance","horizonCrossDirection","fromElements","offset","dot0","dot1"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 58372, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PerspectiveOffCenterFrustum.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport CullingVolume from \"./CullingVolume.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias PerspectiveOffCenterFrustum\n * @constructor\n *\n * @param {object} [options] An object with the following properties:\n * @param {number} [options.left] The left clipping plane distance.\n * @param {number} [options.right] The right clipping plane distance.\n * @param {number} [options.top] The top clipping plane distance.\n * @param {number} [options.bottom] The bottom clipping plane distance.\n * @param {number} [options.near=1.0] The near clipping plane distance.\n * @param {number} [options.far=500000000.0] The far clipping plane distance.\n *\n * @example\n * const frustum = new Cesium.PerspectiveOffCenterFrustum({\n *     left : -1.0,\n *     right : 1.0,\n *     top : 1.0,\n *     bottom : -1.0,\n *     near : 1.0,\n *     far : 100.0\n * });\n *\n * @see PerspectiveFrustum\n */\nfunction PerspectiveOffCenterFrustum(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  /**\n   * Defines the left clipping plane.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.left = options.left;\n  this._left = undefined;\n\n  /**\n   * Defines the right clipping plane.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.right = options.right;\n  this._right = undefined;\n\n  /**\n   * Defines the top clipping plane.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.top = options.top;\n  this._top = undefined;\n\n  /**\n   * Defines the bottom clipping plane.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.bottom = options.bottom;\n  this._bottom = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {number}\n   * @default 1.0\n   */\n  this.near = options.near ?? 1.0;\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {number}\n   * @default 500000000.0\n   */\n  this.far = options.far ?? 500000000.0;\n  this._far = this.far;\n\n  this._cullingVolume = new CullingVolume();\n  this._perspectiveMatrix = new Matrix4();\n  this._infinitePerspective = new Matrix4();\n}\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(frustum.right) ||\n    !defined(frustum.left) ||\n    !defined(frustum.top) ||\n    !defined(frustum.bottom) ||\n    !defined(frustum.near) ||\n    !defined(frustum.far)\n  ) {\n    throw new DeveloperError(\n      \"right, left, top, bottom, near, or far parameters are not set.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const { top, bottom, right, left, near, far } = frustum;\n\n  const changed =\n    top !== frustum._top ||\n    bottom !== frustum._bottom ||\n    left !== frustum._left ||\n    right !== frustum._right ||\n    near !== frustum._near ||\n    far !== frustum._far;\n  if (!changed) {\n    return;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (frustum.near <= 0 || frustum.near > frustum.far) {\n    throw new DeveloperError(\n      \"near must be greater than zero and less than far.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  frustum._left = left;\n  frustum._right = right;\n  frustum._top = top;\n  frustum._bottom = bottom;\n  frustum._near = near;\n  frustum._far = far;\n  frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(\n    left,\n    right,\n    bottom,\n    top,\n    near,\n    far,\n    frustum._perspectiveMatrix,\n  );\n  frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(\n    left,\n    right,\n    bottom,\n    top,\n    near,\n    frustum._infinitePerspective,\n  );\n}\n\nObject.defineProperties(PerspectiveOffCenterFrustum.prototype, {\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * The projection matrix will be recomputed if any frustum parameters have changed.\n   *\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._perspectiveMatrix;\n    },\n  },\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#projectionMatrix\n   */\n  infiniteProjectionMatrix: {\n    get: function () {\n      update(this);\n      return this._infinitePerspective;\n    },\n  },\n});\n\nconst getPlanesRight = new Cartesian3();\nconst getPlanesNearCenter = new Cartesian3();\nconst getPlanesFarCenter = new Cartesian3();\nconst getPlanesNormal = new Cartesian3();\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nPerspectiveOffCenterFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n\n  if (!defined(up)) {\n    throw new DeveloperError(\"up is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planes = this._cullingVolume.planes;\n\n  const t = this.top;\n  const b = this.bottom;\n  const r = this.right;\n  const l = this.left;\n  const n = this.near;\n  const f = this.far;\n\n  const right = Cartesian3.cross(direction, up, getPlanesRight);\n\n  const nearCenter = getPlanesNearCenter;\n  Cartesian3.multiplyByScalar(direction, n, nearCenter);\n  Cartesian3.add(position, nearCenter, nearCenter);\n\n  const farCenter = getPlanesFarCenter;\n  Cartesian3.multiplyByScalar(direction, f, farCenter);\n  Cartesian3.add(position, farCenter, farCenter);\n\n  const normal = getPlanesNormal;\n\n  //Left plane computation\n  Cartesian3.multiplyByScalar(right, l, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.normalize(normal, normal);\n  Cartesian3.cross(normal, up, normal);\n  Cartesian3.normalize(normal, normal);\n\n  let plane = planes[0];\n  if (!defined(plane)) {\n    plane = planes[0] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Right plane computation\n  Cartesian3.multiplyByScalar(right, r, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(up, normal, normal);\n  Cartesian3.normalize(normal, normal);\n\n  plane = planes[1];\n  if (!defined(plane)) {\n    plane = planes[1] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Bottom plane computation\n  Cartesian3.multiplyByScalar(up, b, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(right, normal, normal);\n  Cartesian3.normalize(normal, normal);\n\n  plane = planes[2];\n  if (!defined(plane)) {\n    plane = planes[2] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Top plane computation\n  Cartesian3.multiplyByScalar(up, t, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(normal, right, normal);\n  Cartesian3.normalize(normal, normal);\n\n  plane = planes[3];\n  if (!defined(plane)) {\n    plane = planes[3] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Near plane computation\n  plane = planes[4];\n  if (!defined(plane)) {\n    plane = planes[4] = new Cartesian4();\n  }\n  plane.x = direction.x;\n  plane.y = direction.y;\n  plane.z = direction.z;\n  plane.w = -Cartesian3.dot(direction, nearCenter);\n\n  //Far plane computation\n  Cartesian3.negate(direction, normal);\n\n  plane = planes[5];\n  if (!defined(plane)) {\n    plane = planes[5] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, farCenter);\n\n  return this._cullingVolume;\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {number} drawingBufferWidth The width of the drawing buffer.\n * @param {number} drawingBufferHeight The height of the drawing buffer.\n * @param {number} distance The distance to the near plane in meters.\n * @param {number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n * @example\n * // Example 2\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\n * // For example, get the size of a pixel of an image on a billboard.\n * const position = camera.position;\n * const direction = camera.direction;\n * const toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\n * const toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\n * const distance = Cesium.Cartesian3.magnitude(toCenterProj);\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\n */\nPerspectiveOffCenterFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result,\n) {\n  update(this);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {\n    throw new DeveloperError(\n      \"Both drawingBufferWidth and drawingBufferHeight are required.\",\n    );\n  }\n  if (drawingBufferWidth <= 0) {\n    throw new DeveloperError(\"drawingBufferWidth must be greater than zero.\");\n  }\n  if (drawingBufferHeight <= 0) {\n    throw new DeveloperError(\"drawingBufferHeight must be greater than zero.\");\n  }\n  if (!defined(distance)) {\n    throw new DeveloperError(\"distance is required.\");\n  }\n  if (!defined(pixelRatio)) {\n    throw new DeveloperError(\"pixelRatio is required\");\n  }\n  if (pixelRatio <= 0) {\n    throw new DeveloperError(\"pixelRatio must be greater than zero.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"A result object is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const inverseNear = 1.0 / this.near;\n  let tanTheta = this.top * inverseNear;\n  const pixelHeight =\n    (2.0 * pixelRatio * distance * tanTheta) / drawingBufferHeight;\n  tanTheta = this.right * inverseNear;\n  const pixelWidth =\n    (2.0 * pixelRatio * distance * tanTheta) / drawingBufferWidth;\n\n  result.x = pixelWidth;\n  result.y = pixelHeight;\n  return result;\n};\n\n/**\n * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\n *\n * @param {PerspectiveOffCenterFrustum} [result] The object onto which to store the result.\n * @returns {PerspectiveOffCenterFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveOffCenterFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new PerspectiveOffCenterFrustum();\n  }\n\n  result.right = this.right;\n  result.left = this.left;\n  result.top = this.top;\n  result.bottom = this.bottom;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._left = undefined;\n  result._right = undefined;\n  result._top = undefined;\n  result._bottom = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  return result;\n};\n\n/**\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nPerspectiveOffCenterFrustum.prototype.equals = function (other) {\n  return (\n    defined(other) &&\n    other instanceof PerspectiveOffCenterFrustum &&\n    this.right === other.right &&\n    this.left === other.left &&\n    this.top === other.top &&\n    this.bottom === other.bottom &&\n    this.near === other.near &&\n    this.far === other.far\n  );\n};\n\n/**\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {PerspectiveOffCenterFrustum} other The right hand side PerspectiveOffCenterFrustum.\n * @param {number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nPerspectiveOffCenterFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return (\n    other === this ||\n    (defined(other) &&\n      other instanceof PerspectiveOffCenterFrustum &&\n      CesiumMath.equalsEpsilon(\n        this.right,\n        other.right,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.left,\n        other.left,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.top,\n        other.top,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.bottom,\n        other.bottom,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.near,\n        other.near,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.far,\n        other.far,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ))\n  );\n};\nexport default PerspectiveOffCenterFrustum;\n"],"names":["PerspectiveOffCenterFrustum","options","EMPTY_OBJECT","left","_left","undefined","right","_right","top","_top","bottom","_bottom","near","_near","far","_far","_cullingVolume","_perspectiveMatrix","_infinitePerspective","update","frustum","changed","computePerspectiveOffCenter","computeInfinitePerspectiveOffCenter","Object","defineProperties","prototype","projectionMatrix","get","infiniteProjectionMatrix","getPlanesRight","getPlanesNearCenter","getPlanesFarCenter","getPlanesNormal","computeCullingVolume","position","direction","up","planes","t","b","r","l","n","f","cross","nearCenter","multiplyByScalar","add","farCenter","normal","subtract","normalize","plane","x","y","z","w","dot","negate","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","distance","pixelRatio","result","inverseNear","tanTheta","pixelHeight","pixelWidth","clone","equals","other","equalsEpsilon","relativeEpsilon","absoluteEpsilon"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 58751, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PerspectiveFrustum.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport PerspectiveOffCenterFrustum from \"./PerspectiveOffCenterFrustum.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias PerspectiveFrustum\n * @constructor\n *\n * @param {object} [options] An object with the following properties:\n * @param {number} [options.fov] The angle of the field of view (FOV), in radians.\n * @param {number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\n * @param {number} [options.near=1.0] The distance of the near plane.\n * @param {number} [options.far=500000000.0] The distance of the far plane.\n * @param {number} [options.xOffset=0.0] The offset in the x direction.\n * @param {number} [options.yOffset=0.0] The offset in the y direction.\n *\n * @example\n * const frustum = new Cesium.PerspectiveFrustum({\n *     fov : Cesium.Math.PI_OVER_THREE,\n *     aspectRatio : canvas.clientWidth / canvas.clientHeight\n *     near : 1.0,\n *     far : 1000.0\n * });\n *\n * @see PerspectiveOffCenterFrustum\n */\nfunction PerspectiveFrustum(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  this._offCenterFrustum = new PerspectiveOffCenterFrustum();\n\n  /**\n   * The angle of the field of view (FOV), in radians.  This angle will be used\n   * as the horizontal FOV if the width is greater than the height, otherwise\n   * it will be the vertical FOV.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.fov = options.fov;\n  this._fov = undefined;\n  this._fovy = undefined;\n\n  this._sseDenominator = undefined;\n\n  /**\n   * The aspect ratio of the frustum's width to it's height.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.aspectRatio = options.aspectRatio;\n  this._aspectRatio = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {number}\n   * @default 1.0\n   */\n  this.near = options.near ?? 1.0;\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {number}\n   * @default 500000000.0\n   */\n  this.far = options.far ?? 500000000.0;\n  this._far = this.far;\n\n  /**\n   * Offsets the frustum in the x direction.\n   * @type {number}\n   * @default 0.0\n   */\n  this.xOffset = options.xOffset ?? 0.0;\n  this._xOffset = this.xOffset;\n\n  /**\n   * Offsets the frustum in the y direction.\n   * @type {number}\n   * @default 0.0\n   */\n  this.yOffset = options.yOffset ?? 0.0;\n  this._yOffset = this.yOffset;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nPerspectiveFrustum.packedLength = 6;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PerspectiveFrustum} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nPerspectiveFrustum.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value.fov;\n  array[startingIndex++] = value.aspectRatio;\n  array[startingIndex++] = value.near;\n  array[startingIndex++] = value.far;\n  array[startingIndex++] = value.xOffset;\n  array[startingIndex] = value.yOffset;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PerspectiveFrustum} [result] The object into which to store the result.\n * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveFrustum.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new PerspectiveFrustum();\n  }\n\n  result.fov = array[startingIndex++];\n  result.aspectRatio = array[startingIndex++];\n  result.near = array[startingIndex++];\n  result.far = array[startingIndex++];\n  result.xOffset = array[startingIndex++];\n  result.yOffset = array[startingIndex];\n\n  return result;\n};\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(frustum.fov) ||\n    !defined(frustum.aspectRatio) ||\n    !defined(frustum.near) ||\n    !defined(frustum.far)\n  ) {\n    throw new DeveloperError(\n      \"fov, aspectRatio, near, or far parameters are not set.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const changed =\n    frustum.fov !== frustum._fov ||\n    frustum.aspectRatio !== frustum._aspectRatio ||\n    frustum.near !== frustum._near ||\n    frustum.far !== frustum._far ||\n    frustum.xOffset !== frustum._xOffset ||\n    frustum.yOffset !== frustum._yOffset;\n\n  if (!changed) {\n    return;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"fov\", frustum.fov, 0.0);\n  Check.typeOf.number.lessThan(\"fov\", frustum.fov, Math.PI);\n\n  Check.typeOf.number.greaterThanOrEquals(\n    \"aspectRatio\",\n    frustum.aspectRatio,\n    0.0,\n  );\n\n  Check.typeOf.number.greaterThanOrEquals(\"near\", frustum.near, 0.0);\n  if (frustum.near > frustum.far) {\n    throw new DeveloperError(\"near must be less than far.\");\n  }\n  //>>includeEnd('debug');\n\n  frustum._aspectRatio = frustum.aspectRatio;\n  frustum._fov = frustum.fov;\n  frustum._fovy =\n    frustum.aspectRatio <= 1\n      ? frustum.fov\n      : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;\n  frustum._near = frustum.near;\n  frustum._far = frustum.far;\n  frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);\n  frustum._xOffset = frustum.xOffset;\n  frustum._yOffset = frustum.yOffset;\n\n  const f = frustum._offCenterFrustum;\n\n  f.top = frustum.near * Math.tan(0.5 * frustum._fovy);\n  f.bottom = -f.top;\n  f.right = frustum.aspectRatio * f.top;\n  f.left = -f.right;\n  f.near = frustum.near;\n  f.far = frustum.far;\n\n  f.right += frustum.xOffset;\n  f.left += frustum.xOffset;\n  f.top += frustum.yOffset;\n  f.bottom += frustum.yOffset;\n}\n\nObject.defineProperties(PerspectiveFrustum.prototype, {\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * If necessary, the projection matrix will be recomputed.\n   *\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#projectionMatrix.\n   * @see PerspectiveFrustum#infiniteProjectionMatrix\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum.projectionMatrix;\n    },\n  },\n\n  /**\n   * The perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveFrustum#projectionMatrix\n   */\n  infiniteProjectionMatrix: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum.infiniteProjectionMatrix;\n    },\n  },\n\n  /**\n   * Gets the angle of the vertical field of view, in radians.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {number|undefined}\n   * @readonly\n   * @default undefined\n   */\n  fovy: {\n    get: function () {\n      update(this);\n      return this._fovy;\n    },\n  },\n\n  /**\n   * @readonly\n   * @private\n   */\n  sseDenominator: {\n    get: function () {\n      update(this);\n      return this._sseDenominator;\n    },\n  },\n\n  /**\n   * Gets the orthographic projection matrix computed from the view frustum.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {PerspectiveOffCenterFrustum}\n   * @readonly\n   * @private\n   */\n  offCenterFrustum: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum;\n    },\n  },\n});\n\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nPerspectiveFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up,\n) {\n  update(this);\n  return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {number} drawingBufferWidth The width of the drawing buffer.\n * @param {number} drawingBufferHeight The height of the drawing buffer.\n * @param {number} distance The distance to the near plane in meters.\n * @param {number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n * @example\n * // Example 2\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\n * // For example, get the size of a pixel of an image on a billboard.\n * const position = camera.position;\n * const direction = camera.direction;\n * const toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\n * const toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\n * const distance = Cesium.Cartesian3.magnitude(toCenterProj);\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\n */\nPerspectiveFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result,\n) {\n  update(this);\n  return this._offCenterFrustum.getPixelDimensions(\n    drawingBufferWidth,\n    drawingBufferHeight,\n    distance,\n    pixelRatio,\n    result,\n  );\n};\n\n/**\n * Returns a duplicate of a PerspectiveFrustum instance.\n *\n * @param {PerspectiveFrustum} [result] The object onto which to store the result.\n * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new PerspectiveFrustum();\n  }\n\n  result.aspectRatio = this.aspectRatio;\n  result.fov = this.fov;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._aspectRatio = undefined;\n  result._fov = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  this._offCenterFrustum.clone(result._offCenterFrustum);\n\n  return result;\n};\n\n/**\n * Compares the provided PerspectiveFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {PerspectiveFrustum} [other] The right hand side PerspectiveFrustum.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nPerspectiveFrustum.prototype.equals = function (other) {\n  if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n\n  return (\n    this.fov === other.fov &&\n    this.aspectRatio === other.aspectRatio &&\n    this._offCenterFrustum.equals(other._offCenterFrustum)\n  );\n};\n\n/**\n * Compares the provided PerspectiveFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {PerspectiveFrustum} other The right hand side PerspectiveFrustum.\n * @param {number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nPerspectiveFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n\n  return (\n    CesiumMath.equalsEpsilon(\n      this.fov,\n      other.fov,\n      relativeEpsilon,\n      absoluteEpsilon,\n    ) &&\n    CesiumMath.equalsEpsilon(\n      this.aspectRatio,\n      other.aspectRatio,\n      relativeEpsilon,\n      absoluteEpsilon,\n    ) &&\n    this._offCenterFrustum.equalsEpsilon(\n      other._offCenterFrustum,\n      relativeEpsilon,\n      absoluteEpsilon,\n    )\n  );\n};\nexport default PerspectiveFrustum;\n"],"names":["PerspectiveFrustum","options","EMPTY_OBJECT","_offCenterFrustum","fov","_fov","undefined","_fovy","_sseDenominator","aspectRatio","_aspectRatio","near","_near","far","_far","xOffset","_xOffset","yOffset","_yOffset","packedLength","pack","value","array","startingIndex","typeOf","object","defined","unpack","result","update","frustum","changed","number","greaterThanOrEquals","lessThan","Math","PI","atan","tan","f","top","bottom","right","left","Object","defineProperties","prototype","projectionMatrix","get","infiniteProjectionMatrix","fovy","sseDenominator","offCenterFrustum","computeCullingVolume","position","direction","up","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","distance","pixelRatio","clone","equals","other","equalsEpsilon","relativeEpsilon","absoluteEpsilon"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 59095, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/EasingFunction.js"],"sourcesContent":["import { Easing } from \"@tweenjs/tween.js\";\n\n/**\n * Easing functions for use with TweenCollection.  These function are from\n * {@link https://github.com/sole/tween.js/|Tween.js} and Robert Penner.  See the\n * {@link http://sole.github.io/tween.js/examples/03_graphs.html|Tween.js graphs for each function}.\n *\n * @namespace\n */\nconst EasingFunction = {\n  /**\n   * Linear easing.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  LINEAR_NONE: Easing.Linear.None,\n\n  /**\n   * Quadratic in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUADRATIC_IN: Easing.Quadratic.In,\n  /**\n   * Quadratic out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUADRATIC_OUT: Easing.Quadratic.Out,\n  /**\n   * Quadratic in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUADRATIC_IN_OUT: Easing.Quadratic.InOut,\n\n  /**\n   * Cubic in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CUBIC_IN: Easing.Cubic.In,\n  /**\n   * Cubic out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CUBIC_OUT: Easing.Cubic.Out,\n  /**\n   * Cubic in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CUBIC_IN_OUT: Easing.Cubic.InOut,\n\n  /**\n   * Quartic in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUARTIC_IN: Easing.Quartic.In,\n  /**\n   * Quartic out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUARTIC_OUT: Easing.Quartic.Out,\n  /**\n   * Quartic in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUARTIC_IN_OUT: Easing.Quartic.InOut,\n\n  /**\n   * Quintic in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUINTIC_IN: Easing.Quintic.In,\n  /**\n   * Quintic out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUINTIC_OUT: Easing.Quintic.Out,\n  /**\n   * Quintic in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUINTIC_IN_OUT: Easing.Quintic.InOut,\n\n  /**\n   * Sinusoidal in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  SINUSOIDAL_IN: Easing.Sinusoidal.In,\n  /**\n   * Sinusoidal out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  SINUSOIDAL_OUT: Easing.Sinusoidal.Out,\n  /**\n   * Sinusoidal in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  SINUSOIDAL_IN_OUT: Easing.Sinusoidal.InOut,\n\n  /**\n   * Exponential in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  EXPONENTIAL_IN: Easing.Exponential.In,\n  /**\n   * Exponential out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  EXPONENTIAL_OUT: Easing.Exponential.Out,\n  /**\n   * Exponential in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  EXPONENTIAL_IN_OUT: Easing.Exponential.InOut,\n\n  /**\n   * Circular in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CIRCULAR_IN: Easing.Circular.In,\n  /**\n   * Circular out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CIRCULAR_OUT: Easing.Circular.Out,\n  /**\n   * Circular in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CIRCULAR_IN_OUT: Easing.Circular.InOut,\n\n  /**\n   * Elastic in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  ELASTIC_IN: Easing.Elastic.In,\n  /**\n   * Elastic out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  ELASTIC_OUT: Easing.Elastic.Out,\n  /**\n   * Elastic in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  ELASTIC_IN_OUT: Easing.Elastic.InOut,\n\n  /**\n   * Back in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BACK_IN: Easing.Back.In,\n  /**\n   * Back out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BACK_OUT: Easing.Back.Out,\n  /**\n   * Back in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BACK_IN_OUT: Easing.Back.InOut,\n\n  /**\n   * Bounce in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BOUNCE_IN: Easing.Bounce.In,\n  /**\n   * Bounce out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BOUNCE_OUT: Easing.Bounce.Out,\n  /**\n   * Bounce in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BOUNCE_IN_OUT: Easing.Bounce.InOut,\n};\n\n/**\n * Function interface for implementing a custom easing function.\n * @callback EasingFunction.Callback\n * @param {number} time The time in the range <code>[0, 1]</code>.\n * @returns {number} The value of the function at the given time.\n *\n * @example\n * function quadraticIn(time) {\n *     return time * time;\n * }\n *\n * @example\n * function quadraticOut(time) {\n *     return time * (2.0 - time);\n * }\n */\n\nexport default Object.freeze(EasingFunction);\n"],"names":["EasingFunction","LINEAR_NONE","Linear","None","QUADRATIC_IN","Quadratic","In","QUADRATIC_OUT","Out","QUADRATIC_IN_OUT","InOut","CUBIC_IN","Cubic","CUBIC_OUT","CUBIC_IN_OUT","QUARTIC_IN","Quartic","QUARTIC_OUT","QUARTIC_IN_OUT","QUINTIC_IN","Quintic","QUINTIC_OUT","QUINTIC_IN_OUT","SINUSOIDAL_IN","Sinusoidal","SINUSOIDAL_OUT","SINUSOIDAL_IN_OUT","EXPONENTIAL_IN","Exponential","EXPONENTIAL_OUT","EXPONENTIAL_IN_OUT","CIRCULAR_IN","Circular","CIRCULAR_OUT","CIRCULAR_IN_OUT","ELASTIC_IN","Elastic","ELASTIC_OUT","ELASTIC_IN_OUT","BACK_IN","Back","BACK_OUT","BACK_IN_OUT","BOUNCE_IN","Bounce","BOUNCE_OUT","BOUNCE_IN_OUT","Object","freeze"],"mappings":";;;;AAAA;;AAEA;;;;;;CAMC,GACD,MAAMA,iBAAiB;IACrB;;;;;GAKC,GACDC,aAAa,mNAAM,CAACC,MAAM,CAACC,IAAI;IAE/B;;;;;GAKC,GACDC,cAAc,mNAAM,CAACC,SAAS,CAACC,EAAE;IACjC;;;;;GAKC,GACDC,eAAe,mNAAM,CAACF,SAAS,CAACG,GAAG;IACnC;;;;;GAKC,GACDC,kBAAkB,mNAAM,CAACJ,SAAS,CAACK,KAAK;IAExC;;;;;GAKC,GACDC,UAAU,mNAAM,CAACC,KAAK,CAACN,EAAE;IACzB;;;;;GAKC,GACDO,WAAW,mNAAM,CAACD,KAAK,CAACJ,GAAG;IAC3B;;;;;GAKC,GACDM,cAAc,mNAAM,CAACF,KAAK,CAACF,KAAK;IAEhC;;;;;GAKC,GACDK,YAAY,mNAAM,CAACC,OAAO,CAACV,EAAE;IAC7B;;;;;GAKC,GACDW,aAAa,mNAAM,CAACD,OAAO,CAACR,GAAG;IAC/B;;;;;GAKC,GACDU,gBAAgB,mNAAM,CAACF,OAAO,CAACN,KAAK;IAEpC;;;;;GAKC,GACDS,YAAY,mNAAM,CAACC,OAAO,CAACd,EAAE;IAC7B;;;;;GAKC,GACDe,aAAa,mNAAM,CAACD,OAAO,CAACZ,GAAG;IAC/B;;;;;GAKC,GACDc,gBAAgB,mNAAM,CAACF,OAAO,CAACV,KAAK;IAEpC;;;;;GAKC,GACDa,eAAe,mNAAM,CAACC,UAAU,CAAClB,EAAE;IACnC;;;;;GAKC,GACDmB,gBAAgB,mNAAM,CAACD,UAAU,CAAChB,GAAG;IACrC;;;;;GAKC,GACDkB,mBAAmB,mNAAM,CAACF,UAAU,CAACd,KAAK;IAE1C;;;;;GAKC,GACDiB,gBAAgB,mNAAM,CAACC,WAAW,CAACtB,EAAE;IACrC;;;;;GAKC,GACDuB,iBAAiB,mNAAM,CAACD,WAAW,CAACpB,GAAG;IACvC;;;;;GAKC,GACDsB,oBAAoB,mNAAM,CAACF,WAAW,CAAClB,KAAK;IAE5C;;;;;GAKC,GACDqB,aAAa,mNAAM,CAACC,QAAQ,CAAC1B,EAAE;IAC/B;;;;;GAKC,GACD2B,cAAc,mNAAM,CAACD,QAAQ,CAACxB,GAAG;IACjC;;;;;GAKC,GACD0B,iBAAiB,mNAAM,CAACF,QAAQ,CAACtB,KAAK;IAEtC;;;;;GAKC,GACDyB,YAAY,mNAAM,CAACC,OAAO,CAAC9B,EAAE;IAC7B;;;;;GAKC,GACD+B,aAAa,mNAAM,CAACD,OAAO,CAAC5B,GAAG;IAC/B;;;;;GAKC,GACD8B,gBAAgB,mNAAM,CAACF,OAAO,CAAC1B,KAAK;IAEpC;;;;;GAKC,GACD6B,SAAS,mNAAM,CAACC,IAAI,CAAClC,EAAE;IACvB;;;;;GAKC,GACDmC,UAAU,mNAAM,CAACD,IAAI,CAAChC,GAAG;IACzB;;;;;GAKC,GACDkC,aAAa,mNAAM,CAACF,IAAI,CAAC9B,KAAK;IAE9B;;;;;GAKC,GACDiC,WAAW,mNAAM,CAACC,MAAM,CAACtC,EAAE;IAC3B;;;;;GAKC,GACDuC,YAAY,mNAAM,CAACD,MAAM,CAACpC,GAAG;IAC7B;;;;;GAKC,GACDsC,eAAe,mNAAM,CAACF,MAAM,CAAClC,KAAK;AACpC;uCAmBeqC,OAAOC,MAAM,CAAChD","ignoreList":[0]}},
    {"offset": {"line": 59300, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/FrustumGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defined from \"./defined.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport OrthographicFrustum from \"./OrthographicFrustum.js\";\nimport PerspectiveFrustum from \"./PerspectiveFrustum.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst PERSPECTIVE = 0;\nconst ORTHOGRAPHIC = 1;\n\n/**\n * Describes a frustum at the given the origin and orientation.\n *\n * @alias FrustumGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\n * @param {Cartesian3} options.origin The origin of the frustum.\n * @param {Quaternion} options.orientation The orientation of the frustum.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n */\nfunction FrustumGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.frustum\", options.frustum);\n  Check.typeOf.object(\"options.origin\", options.origin);\n  Check.typeOf.object(\"options.orientation\", options.orientation);\n  //>>includeEnd('debug');\n\n  const frustum = options.frustum;\n  const orientation = options.orientation;\n  const origin = options.origin;\n  const vertexFormat = options.vertexFormat ?? VertexFormat.DEFAULT;\n\n  // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\n  // creating multiple FrustumGeometry objects. This way the near plane of one frustum doesn't overlap\n  // the far plane of another.\n  const drawNearPlane = options._drawNearPlane ?? true;\n\n  let frustumType;\n  let frustumPackedLength;\n  if (frustum instanceof PerspectiveFrustum) {\n    frustumType = PERSPECTIVE;\n    frustumPackedLength = PerspectiveFrustum.packedLength;\n  } else if (frustum instanceof OrthographicFrustum) {\n    frustumType = ORTHOGRAPHIC;\n    frustumPackedLength = OrthographicFrustum.packedLength;\n  }\n\n  this._frustumType = frustumType;\n  this._frustum = frustum.clone();\n  this._origin = Cartesian3.clone(origin);\n  this._orientation = Quaternion.clone(orientation);\n  this._drawNearPlane = drawNearPlane;\n  this._vertexFormat = vertexFormat;\n  this._workerName = \"createFrustumGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    2 +\n    frustumPackedLength +\n    Cartesian3.packedLength +\n    Quaternion.packedLength +\n    VertexFormat.packedLength;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {FrustumGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nFrustumGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const frustumType = value._frustumType;\n  const frustum = value._frustum;\n\n  array[startingIndex++] = frustumType;\n\n  if (frustumType === PERSPECTIVE) {\n    PerspectiveFrustum.pack(frustum, array, startingIndex);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    OrthographicFrustum.pack(frustum, array, startingIndex);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  Cartesian3.pack(value._origin, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Quaternion.pack(value._orientation, array, startingIndex);\n  startingIndex += Quaternion.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\n\n  return array;\n};\n\nconst scratchPackPerspective = new PerspectiveFrustum();\nconst scratchPackOrthographic = new OrthographicFrustum();\nconst scratchPackQuaternion = new Quaternion();\nconst scratchPackorigin = new Cartesian3();\nconst scratchVertexFormat = new VertexFormat();\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {FrustumGeometry} [result] The object into which to store the result.\n */\nFrustumGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const frustumType = array[startingIndex++];\n\n  let frustum;\n  if (frustumType === PERSPECTIVE) {\n    frustum = PerspectiveFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackPerspective,\n    );\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    frustum = OrthographicFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackOrthographic,\n    );\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  const origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\n  startingIndex += Cartesian3.packedLength;\n  const orientation = Quaternion.unpack(\n    array,\n    startingIndex,\n    scratchPackQuaternion,\n  );\n  startingIndex += Quaternion.packedLength;\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n  const drawNearPlane = array[startingIndex] === 1.0;\n\n  if (!defined(result)) {\n    return new FrustumGeometry({\n      frustum: frustum,\n      origin: origin,\n      orientation: orientation,\n      vertexFormat: vertexFormat,\n      _drawNearPlane: drawNearPlane,\n    });\n  }\n\n  const frustumResult =\n    frustumType === result._frustumType ? result._frustum : undefined;\n  result._frustum = frustum.clone(frustumResult);\n\n  result._frustumType = frustumType;\n  result._origin = Cartesian3.clone(origin, result._origin);\n  result._orientation = Quaternion.clone(orientation, result._orientation);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._drawNearPlane = drawNearPlane;\n\n  return result;\n};\n\nfunction getAttributes(\n  offset,\n  normals,\n  tangents,\n  bitangents,\n  st,\n  normal,\n  tangent,\n  bitangent,\n) {\n  const stOffset = (offset / 3) * 2;\n\n  for (let i = 0; i < 4; ++i) {\n    if (defined(normals)) {\n      normals[offset] = normal.x;\n      normals[offset + 1] = normal.y;\n      normals[offset + 2] = normal.z;\n    }\n    if (defined(tangents)) {\n      tangents[offset] = tangent.x;\n      tangents[offset + 1] = tangent.y;\n      tangents[offset + 2] = tangent.z;\n    }\n    if (defined(bitangents)) {\n      bitangents[offset] = bitangent.x;\n      bitangents[offset + 1] = bitangent.y;\n      bitangents[offset + 2] = bitangent.z;\n    }\n    offset += 3;\n  }\n\n  st[stOffset] = 0.0;\n  st[stOffset + 1] = 0.0;\n  st[stOffset + 2] = 1.0;\n  st[stOffset + 3] = 0.0;\n  st[stOffset + 4] = 1.0;\n  st[stOffset + 5] = 1.0;\n  st[stOffset + 6] = 0.0;\n  st[stOffset + 7] = 1.0;\n}\n\nconst scratchRotationMatrix = new Matrix3();\nconst scratchViewMatrix = new Matrix4();\nconst scratchInverseMatrix = new Matrix4();\n\nconst scratchXDirection = new Cartesian3();\nconst scratchYDirection = new Cartesian3();\nconst scratchZDirection = new Cartesian3();\nconst scratchNegativeX = new Cartesian3();\nconst scratchNegativeY = new Cartesian3();\nconst scratchNegativeZ = new Cartesian3();\n\nconst frustumSplits = new Array(3);\n\nconst frustumCornersNDC = new Array(4);\nfrustumCornersNDC[0] = new Cartesian4(-1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[1] = new Cartesian4(1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[2] = new Cartesian4(1.0, 1.0, 1.0, 1.0);\nfrustumCornersNDC[3] = new Cartesian4(-1.0, 1.0, 1.0, 1.0);\n\nconst scratchFrustumCorners = new Array(4);\nfor (let i = 0; i < 4; ++i) {\n  scratchFrustumCorners[i] = new Cartesian4();\n}\n\nFrustumGeometry._computeNearFarPlanes = function (\n  origin,\n  orientation,\n  frustumType,\n  frustum,\n  positions,\n  xDirection,\n  yDirection,\n  zDirection,\n) {\n  const rotationMatrix = Matrix3.fromQuaternion(\n    orientation,\n    scratchRotationMatrix,\n  );\n  let x = xDirection ?? scratchXDirection;\n  let y = yDirection ?? scratchYDirection;\n  let z = zDirection ?? scratchZDirection;\n\n  x = Matrix3.getColumn(rotationMatrix, 0, x);\n  y = Matrix3.getColumn(rotationMatrix, 1, y);\n  z = Matrix3.getColumn(rotationMatrix, 2, z);\n\n  Cartesian3.normalize(x, x);\n  Cartesian3.normalize(y, y);\n  Cartesian3.normalize(z, z);\n\n  Cartesian3.negate(x, x);\n\n  const view = Matrix4.computeView(origin, z, y, x, scratchViewMatrix);\n\n  let inverseView;\n  let inverseViewProjection;\n  const projection = frustum.projectionMatrix;\n  if (frustumType === PERSPECTIVE) {\n    const viewProjection = Matrix4.multiply(\n      projection,\n      view,\n      scratchInverseMatrix,\n    );\n    inverseViewProjection = Matrix4.inverse(\n      viewProjection,\n      scratchInverseMatrix,\n    );\n  } else {\n    inverseView = Matrix4.inverseTransformation(view, scratchInverseMatrix);\n  }\n\n  if (defined(inverseViewProjection)) {\n    frustumSplits[0] = frustum.near;\n    frustumSplits[1] = frustum.far;\n  } else {\n    frustumSplits[0] = 0.0;\n    frustumSplits[1] = frustum.near;\n    frustumSplits[2] = frustum.far;\n  }\n\n  for (let i = 0; i < 2; ++i) {\n    for (let j = 0; j < 4; ++j) {\n      let corner = Cartesian4.clone(\n        frustumCornersNDC[j],\n        scratchFrustumCorners[j],\n      );\n\n      if (!defined(inverseViewProjection)) {\n        const offCenterFrustum = frustum.offCenterFrustum;\n        if (defined(offCenterFrustum)) {\n          frustum = offCenterFrustum;\n        }\n\n        const near = frustumSplits[i];\n        const far = frustumSplits[i + 1];\n\n        corner.x =\n          (corner.x * (frustum.right - frustum.left) +\n            frustum.left +\n            frustum.right) *\n          0.5;\n        corner.y =\n          (corner.y * (frustum.top - frustum.bottom) +\n            frustum.bottom +\n            frustum.top) *\n          0.5;\n        corner.z = (corner.z * (near - far) - near - far) * 0.5;\n        corner.w = 1.0;\n\n        Matrix4.multiplyByVector(inverseView, corner, corner);\n      } else {\n        corner = Matrix4.multiplyByVector(\n          inverseViewProjection,\n          corner,\n          corner,\n        );\n\n        // Reverse perspective divide\n        const w = 1.0 / corner.w;\n        Cartesian3.multiplyByScalar(corner, w, corner);\n\n        Cartesian3.subtract(corner, origin, corner);\n        Cartesian3.normalize(corner, corner);\n\n        const fac = Cartesian3.dot(z, corner);\n        Cartesian3.multiplyByScalar(corner, frustumSplits[i] / fac, corner);\n        Cartesian3.add(corner, origin, corner);\n      }\n\n      positions[12 * i + j * 3] = corner.x;\n      positions[12 * i + j * 3 + 1] = corner.y;\n      positions[12 * i + j * 3 + 2] = corner.z;\n    }\n  }\n};\n\n/**\n * Computes the geometric representation of a frustum, including its vertices, indices, and a bounding sphere.\n *\n * @param {FrustumGeometry} frustumGeometry A description of the frustum.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nFrustumGeometry.createGeometry = function (frustumGeometry) {\n  const frustumType = frustumGeometry._frustumType;\n  const frustum = frustumGeometry._frustum;\n  const origin = frustumGeometry._origin;\n  const orientation = frustumGeometry._orientation;\n  const drawNearPlane = frustumGeometry._drawNearPlane;\n  const vertexFormat = frustumGeometry._vertexFormat;\n\n  const numberOfPlanes = drawNearPlane ? 6 : 5;\n  let positions = new Float64Array(3 * 4 * 6);\n  FrustumGeometry._computeNearFarPlanes(\n    origin,\n    orientation,\n    frustumType,\n    frustum,\n    positions,\n  );\n\n  // -x plane\n  let offset = 3 * 4 * 2;\n  positions[offset] = positions[3 * 4];\n  positions[offset + 1] = positions[3 * 4 + 1];\n  positions[offset + 2] = positions[3 * 4 + 2];\n  positions[offset + 3] = positions[0];\n  positions[offset + 4] = positions[1];\n  positions[offset + 5] = positions[2];\n  positions[offset + 6] = positions[3 * 3];\n  positions[offset + 7] = positions[3 * 3 + 1];\n  positions[offset + 8] = positions[3 * 3 + 2];\n  positions[offset + 9] = positions[3 * 7];\n  positions[offset + 10] = positions[3 * 7 + 1];\n  positions[offset + 11] = positions[3 * 7 + 2];\n\n  // -y plane\n  offset += 3 * 4;\n  positions[offset] = positions[3 * 5];\n  positions[offset + 1] = positions[3 * 5 + 1];\n  positions[offset + 2] = positions[3 * 5 + 2];\n  positions[offset + 3] = positions[3];\n  positions[offset + 4] = positions[3 + 1];\n  positions[offset + 5] = positions[3 + 2];\n  positions[offset + 6] = positions[0];\n  positions[offset + 7] = positions[1];\n  positions[offset + 8] = positions[2];\n  positions[offset + 9] = positions[3 * 4];\n  positions[offset + 10] = positions[3 * 4 + 1];\n  positions[offset + 11] = positions[3 * 4 + 2];\n\n  // +x plane\n  offset += 3 * 4;\n  positions[offset] = positions[3];\n  positions[offset + 1] = positions[3 + 1];\n  positions[offset + 2] = positions[3 + 2];\n  positions[offset + 3] = positions[3 * 5];\n  positions[offset + 4] = positions[3 * 5 + 1];\n  positions[offset + 5] = positions[3 * 5 + 2];\n  positions[offset + 6] = positions[3 * 6];\n  positions[offset + 7] = positions[3 * 6 + 1];\n  positions[offset + 8] = positions[3 * 6 + 2];\n  positions[offset + 9] = positions[3 * 2];\n  positions[offset + 10] = positions[3 * 2 + 1];\n  positions[offset + 11] = positions[3 * 2 + 2];\n\n  // +y plane\n  offset += 3 * 4;\n  positions[offset] = positions[3 * 2];\n  positions[offset + 1] = positions[3 * 2 + 1];\n  positions[offset + 2] = positions[3 * 2 + 2];\n  positions[offset + 3] = positions[3 * 6];\n  positions[offset + 4] = positions[3 * 6 + 1];\n  positions[offset + 5] = positions[3 * 6 + 2];\n  positions[offset + 6] = positions[3 * 7];\n  positions[offset + 7] = positions[3 * 7 + 1];\n  positions[offset + 8] = positions[3 * 7 + 2];\n  positions[offset + 9] = positions[3 * 3];\n  positions[offset + 10] = positions[3 * 3 + 1];\n  positions[offset + 11] = positions[3 * 3 + 2];\n\n  if (!drawNearPlane) {\n    positions = positions.subarray(3 * 4);\n  }\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  if (\n    defined(vertexFormat.normal) ||\n    defined(vertexFormat.tangent) ||\n    defined(vertexFormat.bitangent) ||\n    defined(vertexFormat.st)\n  ) {\n    const normals = defined(vertexFormat.normal)\n      ? new Float32Array(3 * 4 * numberOfPlanes)\n      : undefined;\n    const tangents = defined(vertexFormat.tangent)\n      ? new Float32Array(3 * 4 * numberOfPlanes)\n      : undefined;\n    const bitangents = defined(vertexFormat.bitangent)\n      ? new Float32Array(3 * 4 * numberOfPlanes)\n      : undefined;\n    const st = defined(vertexFormat.st)\n      ? new Float32Array(2 * 4 * numberOfPlanes)\n      : undefined;\n\n    const x = scratchXDirection;\n    const y = scratchYDirection;\n    const z = scratchZDirection;\n\n    const negativeX = Cartesian3.negate(x, scratchNegativeX);\n    const negativeY = Cartesian3.negate(y, scratchNegativeY);\n    const negativeZ = Cartesian3.negate(z, scratchNegativeZ);\n\n    offset = 0;\n    if (drawNearPlane) {\n      getAttributes(offset, normals, tangents, bitangents, st, negativeZ, x, y); // near\n      offset += 3 * 4;\n    }\n    getAttributes(offset, normals, tangents, bitangents, st, z, negativeX, y); // far\n    offset += 3 * 4;\n    getAttributes(\n      offset,\n      normals,\n      tangents,\n      bitangents,\n      st,\n      negativeX,\n      negativeZ,\n      y,\n    ); // -x\n    offset += 3 * 4;\n    getAttributes(\n      offset,\n      normals,\n      tangents,\n      bitangents,\n      st,\n      negativeY,\n      negativeZ,\n      negativeX,\n    ); // -y\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, x, z, y); // +x\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, y, z, negativeX); // +y\n\n    if (defined(normals)) {\n      attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n    if (defined(tangents)) {\n      attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n    if (defined(bitangents)) {\n      attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n    if (defined(st)) {\n      attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: st,\n      });\n    }\n  }\n\n  const indices = new Uint16Array(6 * numberOfPlanes);\n  for (let i = 0; i < numberOfPlanes; ++i) {\n    const indexOffset = i * 6;\n    const index = i * 4;\n\n    indices[indexOffset] = index;\n    indices[indexOffset + 1] = index + 1;\n    indices[indexOffset + 2] = index + 2;\n    indices[indexOffset + 3] = index;\n    indices[indexOffset + 4] = index + 2;\n    indices[indexOffset + 5] = index + 3;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromVertices(positions),\n  });\n};\nexport default FrustumGeometry;\n"],"names":["PERSPECTIVE","ORTHOGRAPHIC","FrustumGeometry","options","typeOf","object","frustum","origin","orientation","vertexFormat","DEFAULT","drawNearPlane","_drawNearPlane","frustumType","frustumPackedLength","packedLength","_frustumType","_frustum","clone","_origin","_orientation","_vertexFormat","_workerName","pack","value","array","startingIndex","defined","scratchPackPerspective","scratchPackOrthographic","scratchPackQuaternion","scratchPackorigin","scratchVertexFormat","unpack","result","frustumResult","undefined","getAttributes","offset","normals","tangents","bitangents","st","normal","tangent","bitangent","stOffset","i","x","y","z","scratchRotationMatrix","scratchViewMatrix","scratchInverseMatrix","scratchXDirection","scratchYDirection","scratchZDirection","scratchNegativeX","scratchNegativeY","scratchNegativeZ","frustumSplits","Array","frustumCornersNDC","scratchFrustumCorners","_computeNearFarPlanes","positions","xDirection","yDirection","zDirection","rotationMatrix","fromQuaternion","getColumn","normalize","negate","view","computeView","inverseView","inverseViewProjection","projection","projectionMatrix","viewProjection","multiply","inverse","inverseTransformation","near","far","j","corner","offCenterFrustum","right","left","top","bottom","w","multiplyByVector","multiplyByScalar","subtract","fac","dot","add","createGeometry","frustumGeometry","numberOfPlanes","Float64Array","subarray","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","Float32Array","negativeX","negativeY","negativeZ","FLOAT","indices","Uint16Array","indexOffset","index","primitiveType","TRIANGLES","boundingSphere","fromVertices"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AAEA,MAAMA,cAAc;AACpB,MAAMC,eAAe;AAErB;;;;;;;;;;;CAWC,GACD,SAASC,gBAAgBC,OAAO;IAC9B,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,WAAWF;IAC/B,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,mBAAmBF,QAAQG,OAAO;IACtD,2KAAK,CAACF,MAAM,CAACC,MAAM,CAAC,kBAAkBF,QAAQI,MAAM;IACpD,2KAAK,CAACH,MAAM,CAACC,MAAM,CAAC,uBAAuBF,QAAQK,WAAW;IAC9D,wBAAwB;IAExB,MAAMF,UAAUH,QAAQG,OAAO;IAC/B,MAAME,cAAcL,QAAQK,WAAW;IACvC,MAAMD,SAASJ,QAAQI,MAAM;IAC7B,MAAME,eAAeN,QAAQM,YAAY,IAAI,kLAAY,CAACC,OAAO;IAEjE,wFAAwF;IACxF,oGAAoG;IACpG,4BAA4B;IAC5B,MAAMC,gBAAgBR,QAAQS,cAAc,IAAI;IAEhD,IAAIC;IACJ,IAAIC;IACJ,IAAIR,mBAAmB,wLAAkB,EAAE;QACzCO,cAAcb;QACdc,sBAAsB,wLAAkB,CAACC,YAAY;IACvD,OAAO,IAAIT,mBAAmB,yLAAmB,EAAE;QACjDO,cAAcZ;QACda,sBAAsB,yLAAmB,CAACC,YAAY;IACxD;IAEA,IAAI,CAACC,YAAY,GAAGH;IACpB,IAAI,CAACI,QAAQ,GAAGX,QAAQY,KAAK;IAC7B,IAAI,CAACC,OAAO,GAAG,gLAAU,CAACD,KAAK,CAACX;IAChC,IAAI,CAACa,YAAY,GAAG,gLAAU,CAACF,KAAK,CAACV;IACrC,IAAI,CAACI,cAAc,GAAGD;IACtB,IAAI,CAACU,aAAa,GAAGZ;IACrB,IAAI,CAACa,WAAW,GAAG;IAEnB;;;GAGC,GACD,IAAI,CAACP,YAAY,GACf,IACAD,sBACA,gLAAU,CAACC,YAAY,GACvB,gLAAU,CAACA,YAAY,GACvB,kLAAY,CAACA,YAAY;AAC7B;AAEA;;;;;;;;CAQC,GACDb,gBAAgBqB,IAAI,GAAG,SAAUC,KAAK,EAAEC,KAAK,EAAEC,aAAa;IAC1D,yCAAyC;IACzC,2KAAK,CAACtB,MAAM,CAACC,MAAM,CAAC,SAASmB;IAC7B,2KAAK,CAACG,OAAO,CAAC,SAASF;IACvB,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjC,MAAMb,cAAcW,MAAMR,YAAY;IACtC,MAAMV,UAAUkB,MAAMP,QAAQ;IAE9BQ,KAAK,CAACC,gBAAgB,GAAGb;IAEzB,IAAIA,gBAAgBb,aAAa;QAC/B,wLAAkB,CAACuB,IAAI,CAACjB,SAASmB,OAAOC;QACxCA,iBAAiB,wLAAkB,CAACX,YAAY;IAClD,OAAO;QACL,yLAAmB,CAACQ,IAAI,CAACjB,SAASmB,OAAOC;QACzCA,iBAAiB,yLAAmB,CAACX,YAAY;IACnD;IAEA,gLAAU,CAACQ,IAAI,CAACC,MAAML,OAAO,EAAEM,OAAOC;IACtCA,iBAAiB,gLAAU,CAACX,YAAY;IACxC,gLAAU,CAACQ,IAAI,CAACC,MAAMJ,YAAY,EAAEK,OAAOC;IAC3CA,iBAAiB,gLAAU,CAACX,YAAY;IACxC,kLAAY,CAACQ,IAAI,CAACC,MAAMH,aAAa,EAAEI,OAAOC;IAC9CA,iBAAiB,kLAAY,CAACX,YAAY;IAC1CU,KAAK,CAACC,cAAc,GAAGF,MAAMZ,cAAc,GAAG,MAAM;IAEpD,OAAOa;AACT;AAEA,MAAMG,yBAAyB,IAAI,wLAAkB;AACrD,MAAMC,0BAA0B,IAAI,yLAAmB;AACvD,MAAMC,wBAAwB,IAAI,gLAAU;AAC5C,MAAMC,oBAAoB,IAAI,gLAAU;AACxC,MAAMC,sBAAsB,IAAI,kLAAY;AAE5C;;;;;;CAMC,GACD9B,gBAAgB+B,MAAM,GAAG,SAAUR,KAAK,EAAEC,aAAa,EAAEQ,MAAM;IAC7D,yCAAyC;IACzC,2KAAK,CAACP,OAAO,CAAC,SAASF;IACvB,wBAAwB;IAExBC,gBAAgBA,iBAAiB;IAEjC,MAAMb,cAAcY,KAAK,CAACC,gBAAgB;IAE1C,IAAIpB;IACJ,IAAIO,gBAAgBb,aAAa;QAC/BM,UAAU,wLAAkB,CAAC2B,MAAM,CACjCR,OACAC,eACAE;QAEFF,iBAAiB,wLAAkB,CAACX,YAAY;IAClD,OAAO;QACLT,UAAU,yLAAmB,CAAC2B,MAAM,CAClCR,OACAC,eACAG;QAEFH,iBAAiB,yLAAmB,CAACX,YAAY;IACnD;IAEA,MAAMR,SAAS,gLAAU,CAAC0B,MAAM,CAACR,OAAOC,eAAeK;IACvDL,iBAAiB,gLAAU,CAACX,YAAY;IACxC,MAAMP,cAAc,gLAAU,CAACyB,MAAM,CACnCR,OACAC,eACAI;IAEFJ,iBAAiB,gLAAU,CAACX,YAAY;IACxC,MAAMN,eAAe,kLAAY,CAACwB,MAAM,CACtCR,OACAC,eACAM;IAEFN,iBAAiB,kLAAY,CAACX,YAAY;IAC1C,MAAMJ,gBAAgBc,KAAK,CAACC,cAAc,KAAK;IAE/C,IAAI,CAAC,IAAA,6KAAO,EAACQ,SAAS;QACpB,OAAO,IAAIhC,gBAAgB;YACzBI,SAASA;YACTC,QAAQA;YACRC,aAAaA;YACbC,cAAcA;YACdG,gBAAgBD;QAClB;IACF;IAEA,MAAMwB,gBACJtB,gBAAgBqB,OAAOlB,YAAY,GAAGkB,OAAOjB,QAAQ,GAAGmB;IAC1DF,OAAOjB,QAAQ,GAAGX,QAAQY,KAAK,CAACiB;IAEhCD,OAAOlB,YAAY,GAAGH;IACtBqB,OAAOf,OAAO,GAAG,gLAAU,CAACD,KAAK,CAACX,QAAQ2B,OAAOf,OAAO;IACxDe,OAAOd,YAAY,GAAG,gLAAU,CAACF,KAAK,CAACV,aAAa0B,OAAOd,YAAY;IACvEc,OAAOb,aAAa,GAAG,kLAAY,CAACH,KAAK,CAACT,cAAcyB,OAAOb,aAAa;IAC5Ea,OAAOtB,cAAc,GAAGD;IAExB,OAAOuB;AACT;AAEA,SAASG,cACPC,MAAM,EACNC,OAAO,EACPC,QAAQ,EACRC,UAAU,EACVC,EAAE,EACFC,MAAM,EACNC,OAAO,EACPC,SAAS;IAET,MAAMC,WAAW,AAACR,SAAS,IAAK;IAEhC,IAAK,IAAIS,IAAI,GAAGA,IAAI,GAAG,EAAEA,EAAG;QAC1B,IAAI,IAAA,6KAAO,EAACR,UAAU;YACpBA,OAAO,CAACD,OAAO,GAAGK,OAAOK,CAAC;YAC1BT,OAAO,CAACD,SAAS,EAAE,GAAGK,OAAOM,CAAC;YAC9BV,OAAO,CAACD,SAAS,EAAE,GAAGK,OAAOO,CAAC;QAChC;QACA,IAAI,IAAA,6KAAO,EAACV,WAAW;YACrBA,QAAQ,CAACF,OAAO,GAAGM,QAAQI,CAAC;YAC5BR,QAAQ,CAACF,SAAS,EAAE,GAAGM,QAAQK,CAAC;YAChCT,QAAQ,CAACF,SAAS,EAAE,GAAGM,QAAQM,CAAC;QAClC;QACA,IAAI,IAAA,6KAAO,EAACT,aAAa;YACvBA,UAAU,CAACH,OAAO,GAAGO,UAAUG,CAAC;YAChCP,UAAU,CAACH,SAAS,EAAE,GAAGO,UAAUI,CAAC;YACpCR,UAAU,CAACH,SAAS,EAAE,GAAGO,UAAUK,CAAC;QACtC;QACAZ,UAAU;IACZ;IAEAI,EAAE,CAACI,SAAS,GAAG;IACfJ,EAAE,CAACI,WAAW,EAAE,GAAG;IACnBJ,EAAE,CAACI,WAAW,EAAE,GAAG;IACnBJ,EAAE,CAACI,WAAW,EAAE,GAAG;IACnBJ,EAAE,CAACI,WAAW,EAAE,GAAG;IACnBJ,EAAE,CAACI,WAAW,EAAE,GAAG;IACnBJ,EAAE,CAACI,WAAW,EAAE,GAAG;IACnBJ,EAAE,CAACI,WAAW,EAAE,GAAG;AACrB;AAEA,MAAMK,wBAAwB,IAAI,6KAAO;AACzC,MAAMC,oBAAoB,IAAI,6KAAO;AACrC,MAAMC,uBAAuB,IAAI,6KAAO;AAExC,MAAMC,oBAAoB,IAAI,gLAAU;AACxC,MAAMC,oBAAoB,IAAI,gLAAU;AACxC,MAAMC,oBAAoB,IAAI,gLAAU;AACxC,MAAMC,mBAAmB,IAAI,gLAAU;AACvC,MAAMC,mBAAmB,IAAI,gLAAU;AACvC,MAAMC,mBAAmB,IAAI,gLAAU;AAEvC,MAAMC,gBAAgB,IAAIC,MAAM;AAEhC,MAAMC,oBAAoB,IAAID,MAAM;AACpCC,iBAAiB,CAAC,EAAE,GAAG,IAAI,gLAAU,CAAC,CAAC,KAAK,CAAC,KAAK,KAAK;AACvDA,iBAAiB,CAAC,EAAE,GAAG,IAAI,gLAAU,CAAC,KAAK,CAAC,KAAK,KAAK;AACtDA,iBAAiB,CAAC,EAAE,GAAG,IAAI,gLAAU,CAAC,KAAK,KAAK,KAAK;AACrDA,iBAAiB,CAAC,EAAE,GAAG,IAAI,gLAAU,CAAC,CAAC,KAAK,KAAK,KAAK;AAEtD,MAAMC,wBAAwB,IAAIF,MAAM;AACxC,IAAK,IAAId,IAAI,GAAGA,IAAI,GAAG,EAAEA,EAAG;IAC1BgB,qBAAqB,CAAChB,EAAE,GAAG,IAAI,gLAAU;AAC3C;AAEA7C,gBAAgB8D,qBAAqB,GAAG,SACtCzD,MAAM,EACNC,WAAW,EACXK,WAAW,EACXP,OAAO,EACP2D,SAAS,EACTC,UAAU,EACVC,UAAU,EACVC,UAAU;IAEV,MAAMC,iBAAiB,6KAAO,CAACC,cAAc,CAC3C9D,aACA2C;IAEF,IAAIH,IAAIkB,cAAcZ;IACtB,IAAIL,IAAIkB,cAAcZ;IACtB,IAAIL,IAAIkB,cAAcZ;IAEtBR,IAAI,6KAAO,CAACuB,SAAS,CAACF,gBAAgB,GAAGrB;IACzCC,IAAI,6KAAO,CAACsB,SAAS,CAACF,gBAAgB,GAAGpB;IACzCC,IAAI,6KAAO,CAACqB,SAAS,CAACF,gBAAgB,GAAGnB;IAEzC,gLAAU,CAACsB,SAAS,CAACxB,GAAGA;IACxB,gLAAU,CAACwB,SAAS,CAACvB,GAAGA;IACxB,gLAAU,CAACuB,SAAS,CAACtB,GAAGA;IAExB,gLAAU,CAACuB,MAAM,CAACzB,GAAGA;IAErB,MAAM0B,OAAO,6KAAO,CAACC,WAAW,CAACpE,QAAQ2C,GAAGD,GAAGD,GAAGI;IAElD,IAAIwB;IACJ,IAAIC;IACJ,MAAMC,aAAaxE,QAAQyE,gBAAgB;IAC3C,IAAIlE,gBAAgBb,aAAa;QAC/B,MAAMgF,iBAAiB,6KAAO,CAACC,QAAQ,CACrCH,YACAJ,MACArB;QAEFwB,wBAAwB,6KAAO,CAACK,OAAO,CACrCF,gBACA3B;IAEJ,OAAO;QACLuB,cAAc,6KAAO,CAACO,qBAAqB,CAACT,MAAMrB;IACpD;IAEA,IAAI,IAAA,6KAAO,EAACwB,wBAAwB;QAClCjB,aAAa,CAAC,EAAE,GAAGtD,QAAQ8E,IAAI;QAC/BxB,aAAa,CAAC,EAAE,GAAGtD,QAAQ+E,GAAG;IAChC,OAAO;QACLzB,aAAa,CAAC,EAAE,GAAG;QACnBA,aAAa,CAAC,EAAE,GAAGtD,QAAQ8E,IAAI;QAC/BxB,aAAa,CAAC,EAAE,GAAGtD,QAAQ+E,GAAG;IAChC;IAEA,IAAK,IAAItC,IAAI,GAAGA,IAAI,GAAG,EAAEA,EAAG;QAC1B,IAAK,IAAIuC,IAAI,GAAGA,IAAI,GAAG,EAAEA,EAAG;YAC1B,IAAIC,SAAS,gLAAU,CAACrE,KAAK,CAC3B4C,iBAAiB,CAACwB,EAAE,EACpBvB,qBAAqB,CAACuB,EAAE;YAG1B,IAAI,CAAC,IAAA,6KAAO,EAACT,wBAAwB;gBACnC,MAAMW,mBAAmBlF,QAAQkF,gBAAgB;gBACjD,IAAI,IAAA,6KAAO,EAACA,mBAAmB;oBAC7BlF,UAAUkF;gBACZ;gBAEA,MAAMJ,OAAOxB,aAAa,CAACb,EAAE;gBAC7B,MAAMsC,MAAMzB,aAAa,CAACb,IAAI,EAAE;gBAEhCwC,OAAOvC,CAAC,GACN,CAACuC,OAAOvC,CAAC,GAAG,CAAC1C,QAAQmF,KAAK,GAAGnF,QAAQoF,IAAI,IACvCpF,QAAQoF,IAAI,GACZpF,QAAQmF,KAAK,IACf;gBACFF,OAAOtC,CAAC,GACN,CAACsC,OAAOtC,CAAC,GAAG,CAAC3C,QAAQqF,GAAG,GAAGrF,QAAQsF,MAAM,IACvCtF,QAAQsF,MAAM,GACdtF,QAAQqF,GAAG,IACb;gBACFJ,OAAOrC,CAAC,GAAG,CAACqC,OAAOrC,CAAC,GAAG,CAACkC,OAAOC,GAAG,IAAID,OAAOC,GAAG,IAAI;gBACpDE,OAAOM,CAAC,GAAG;gBAEX,6KAAO,CAACC,gBAAgB,CAAClB,aAAaW,QAAQA;YAChD,OAAO;gBACLA,SAAS,6KAAO,CAACO,gBAAgB,CAC/BjB,uBACAU,QACAA;gBAGF,6BAA6B;gBAC7B,MAAMM,IAAI,MAAMN,OAAOM,CAAC;gBACxB,gLAAU,CAACE,gBAAgB,CAACR,QAAQM,GAAGN;gBAEvC,gLAAU,CAACS,QAAQ,CAACT,QAAQhF,QAAQgF;gBACpC,gLAAU,CAACf,SAAS,CAACe,QAAQA;gBAE7B,MAAMU,MAAM,gLAAU,CAACC,GAAG,CAAChD,GAAGqC;gBAC9B,gLAAU,CAACQ,gBAAgB,CAACR,QAAQ3B,aAAa,CAACb,EAAE,GAAGkD,KAAKV;gBAC5D,gLAAU,CAACY,GAAG,CAACZ,QAAQhF,QAAQgF;YACjC;YAEAtB,SAAS,CAAC,KAAKlB,IAAIuC,IAAI,EAAE,GAAGC,OAAOvC,CAAC;YACpCiB,SAAS,CAAC,KAAKlB,IAAIuC,IAAI,IAAI,EAAE,GAAGC,OAAOtC,CAAC;YACxCgB,SAAS,CAAC,KAAKlB,IAAIuC,IAAI,IAAI,EAAE,GAAGC,OAAOrC,CAAC;QAC1C;IACF;AACF;AAEA;;;;;CAKC,GACDhD,gBAAgBkG,cAAc,GAAG,SAAUC,eAAe;IACxD,MAAMxF,cAAcwF,gBAAgBrF,YAAY;IAChD,MAAMV,UAAU+F,gBAAgBpF,QAAQ;IACxC,MAAMV,SAAS8F,gBAAgBlF,OAAO;IACtC,MAAMX,cAAc6F,gBAAgBjF,YAAY;IAChD,MAAMT,gBAAgB0F,gBAAgBzF,cAAc;IACpD,MAAMH,eAAe4F,gBAAgBhF,aAAa;IAElD,MAAMiF,iBAAiB3F,gBAAgB,IAAI;IAC3C,IAAIsD,YAAY,IAAIsC,aAAa,IAAI,IAAI;IACzCrG,gBAAgB8D,qBAAqB,CACnCzD,QACAC,aACAK,aACAP,SACA2D;IAGF,WAAW;IACX,IAAI3B,SAAS,IAAI,IAAI;IACrB2B,SAAS,CAAC3B,OAAO,GAAG2B,SAAS,CAAC,IAAI,EAAE;IACpCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC5CA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC5CA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,EAAE;IACpCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,EAAE;IACpCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,EAAE;IACpCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,EAAE;IACxCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC5CA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC5CA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,EAAE;IACxCA,SAAS,CAAC3B,SAAS,GAAG,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC7CA,SAAS,CAAC3B,SAAS,GAAG,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAE7C,WAAW;IACX3B,UAAU,IAAI;IACd2B,SAAS,CAAC3B,OAAO,GAAG2B,SAAS,CAAC,IAAI,EAAE;IACpCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC5CA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC5CA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,EAAE;IACpCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,EAAE;IACxCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,EAAE;IACxCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,EAAE;IACpCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,EAAE;IACpCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,EAAE;IACpCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,EAAE;IACxCA,SAAS,CAAC3B,SAAS,GAAG,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC7CA,SAAS,CAAC3B,SAAS,GAAG,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAE7C,WAAW;IACX3B,UAAU,IAAI;IACd2B,SAAS,CAAC3B,OAAO,GAAG2B,SAAS,CAAC,EAAE;IAChCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,EAAE;IACxCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,EAAE;IACxCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,EAAE;IACxCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC5CA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC5CA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,EAAE;IACxCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC5CA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC5CA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,EAAE;IACxCA,SAAS,CAAC3B,SAAS,GAAG,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC7CA,SAAS,CAAC3B,SAAS,GAAG,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAE7C,WAAW;IACX3B,UAAU,IAAI;IACd2B,SAAS,CAAC3B,OAAO,GAAG2B,SAAS,CAAC,IAAI,EAAE;IACpCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC5CA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC5CA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,EAAE;IACxCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC5CA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC5CA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,EAAE;IACxCA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC5CA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC5CA,SAAS,CAAC3B,SAAS,EAAE,GAAG2B,SAAS,CAAC,IAAI,EAAE;IACxCA,SAAS,CAAC3B,SAAS,GAAG,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAC7CA,SAAS,CAAC3B,SAAS,GAAG,GAAG2B,SAAS,CAAC,IAAI,IAAI,EAAE;IAE7C,IAAI,CAACtD,eAAe;QAClBsD,YAAYA,UAAUuC,QAAQ,CAAC,IAAI;IACrC;IAEA,MAAMC,aAAa,IAAI,wLAAkB,CAAC;QACxCC,UAAU,IAAI,uLAAiB,CAAC;YAC9BC,mBAAmB,uLAAiB,CAACC,MAAM;YAC3CC,wBAAwB;YACxBC,QAAQ7C;QACV;IACF;IAEA,IACE,IAAA,6KAAO,EAACxD,aAAakC,MAAM,KAC3B,IAAA,6KAAO,EAAClC,aAAamC,OAAO,KAC5B,IAAA,6KAAO,EAACnC,aAAaoC,SAAS,KAC9B,IAAA,6KAAO,EAACpC,aAAaiC,EAAE,GACvB;QACA,MAAMH,UAAU,IAAA,6KAAO,EAAC9B,aAAakC,MAAM,IACvC,IAAIoE,aAAa,IAAI,IAAIT,kBACzBlE;QACJ,MAAMI,WAAW,IAAA,6KAAO,EAAC/B,aAAamC,OAAO,IACzC,IAAImE,aAAa,IAAI,IAAIT,kBACzBlE;QACJ,MAAMK,aAAa,IAAA,6KAAO,EAAChC,aAAaoC,SAAS,IAC7C,IAAIkE,aAAa,IAAI,IAAIT,kBACzBlE;QACJ,MAAMM,KAAK,IAAA,6KAAO,EAACjC,aAAaiC,EAAE,IAC9B,IAAIqE,aAAa,IAAI,IAAIT,kBACzBlE;QAEJ,MAAMY,IAAIM;QACV,MAAML,IAAIM;QACV,MAAML,IAAIM;QAEV,MAAMwD,YAAY,gLAAU,CAACvC,MAAM,CAACzB,GAAGS;QACvC,MAAMwD,YAAY,gLAAU,CAACxC,MAAM,CAACxB,GAAGS;QACvC,MAAMwD,YAAY,gLAAU,CAACzC,MAAM,CAACvB,GAAGS;QAEvCrB,SAAS;QACT,IAAI3B,eAAe;YACjB0B,cAAcC,QAAQC,SAASC,UAAUC,YAAYC,IAAIwE,WAAWlE,GAAGC,IAAI,OAAO;YAClFX,UAAU,IAAI;QAChB;QACAD,cAAcC,QAAQC,SAASC,UAAUC,YAAYC,IAAIQ,GAAG8D,WAAW/D,IAAI,MAAM;QACjFX,UAAU,IAAI;QACdD,cACEC,QACAC,SACAC,UACAC,YACAC,IACAsE,WACAE,WACAjE,IACC,KAAK;QACRX,UAAU,IAAI;QACdD,cACEC,QACAC,SACAC,UACAC,YACAC,IACAuE,WACAC,WACAF,YACC,KAAK;QACR1E,UAAU,IAAI;QACdD,cAAcC,QAAQC,SAASC,UAAUC,YAAYC,IAAIM,GAAGE,GAAGD,IAAI,KAAK;QACxEX,UAAU,IAAI;QACdD,cAAcC,QAAQC,SAASC,UAAUC,YAAYC,IAAIO,GAAGC,GAAG8D,YAAY,KAAK;QAEhF,IAAI,IAAA,6KAAO,EAACzE,UAAU;YACpBkE,WAAW9D,MAAM,GAAG,IAAI,uLAAiB,CAAC;gBACxCgE,mBAAmB,uLAAiB,CAACQ,KAAK;gBAC1CN,wBAAwB;gBACxBC,QAAQvE;YACV;QACF;QACA,IAAI,IAAA,6KAAO,EAACC,WAAW;YACrBiE,WAAW7D,OAAO,GAAG,IAAI,uLAAiB,CAAC;gBACzC+D,mBAAmB,uLAAiB,CAACQ,KAAK;gBAC1CN,wBAAwB;gBACxBC,QAAQtE;YACV;QACF;QACA,IAAI,IAAA,6KAAO,EAACC,aAAa;YACvBgE,WAAW5D,SAAS,GAAG,IAAI,uLAAiB,CAAC;gBAC3C8D,mBAAmB,uLAAiB,CAACQ,KAAK;gBAC1CN,wBAAwB;gBACxBC,QAAQrE;YACV;QACF;QACA,IAAI,IAAA,6KAAO,EAACC,KAAK;YACf+D,WAAW/D,EAAE,GAAG,IAAI,uLAAiB,CAAC;gBACpCiE,mBAAmB,uLAAiB,CAACQ,KAAK;gBAC1CN,wBAAwB;gBACxBC,QAAQpE;YACV;QACF;IACF;IAEA,MAAM0E,UAAU,IAAIC,YAAY,IAAIf;IACpC,IAAK,IAAIvD,IAAI,GAAGA,IAAIuD,gBAAgB,EAAEvD,EAAG;QACvC,MAAMuE,cAAcvE,IAAI;QACxB,MAAMwE,QAAQxE,IAAI;QAElBqE,OAAO,CAACE,YAAY,GAAGC;QACvBH,OAAO,CAACE,cAAc,EAAE,GAAGC,QAAQ;QACnCH,OAAO,CAACE,cAAc,EAAE,GAAGC,QAAQ;QACnCH,OAAO,CAACE,cAAc,EAAE,GAAGC;QAC3BH,OAAO,CAACE,cAAc,EAAE,GAAGC,QAAQ;QACnCH,OAAO,CAACE,cAAc,EAAE,GAAGC,QAAQ;IACrC;IAEA,OAAO,IAAI,8KAAQ,CAAC;QAClBd,YAAYA;QACZW,SAASA;QACTI,eAAe,mLAAa,CAACC,SAAS;QACtCC,gBAAgB,oLAAc,CAACC,YAAY,CAAC1D;IAC9C;AACF;uCACe/D","ignoreList":[0]}},
    {"offset": {"line": 59736, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/FrustumOutlineGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defined from \"./defined.js\";\nimport FrustumGeometry from \"./FrustumGeometry.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport OrthographicFrustum from \"./OrthographicFrustum.js\";\nimport PerspectiveFrustum from \"./PerspectiveFrustum.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\n\nconst PERSPECTIVE = 0;\nconst ORTHOGRAPHIC = 1;\n\n/**\n * A description of the outline of a frustum with the given the origin and orientation.\n *\n * @alias FrustumOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\n * @param {Cartesian3} options.origin The origin of the frustum.\n * @param {Quaternion} options.orientation The orientation of the frustum.\n */\nfunction FrustumOutlineGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.frustum\", options.frustum);\n  Check.typeOf.object(\"options.origin\", options.origin);\n  Check.typeOf.object(\"options.orientation\", options.orientation);\n  //>>includeEnd('debug');\n\n  const frustum = options.frustum;\n  const orientation = options.orientation;\n  const origin = options.origin;\n\n  // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\n  // creating multiple FrustumOutlineGeometrys. This way the near plane of one frustum doesn't overlap\n  // the far plane of another.\n  const drawNearPlane = options._drawNearPlane ?? true;\n\n  let frustumType;\n  let frustumPackedLength;\n  if (frustum instanceof PerspectiveFrustum) {\n    frustumType = PERSPECTIVE;\n    frustumPackedLength = PerspectiveFrustum.packedLength;\n  } else if (frustum instanceof OrthographicFrustum) {\n    frustumType = ORTHOGRAPHIC;\n    frustumPackedLength = OrthographicFrustum.packedLength;\n  }\n\n  this._frustumType = frustumType;\n  this._frustum = frustum.clone();\n  this._origin = Cartesian3.clone(origin);\n  this._orientation = Quaternion.clone(orientation);\n  this._drawNearPlane = drawNearPlane;\n  this._workerName = \"createFrustumOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    2 + frustumPackedLength + Cartesian3.packedLength + Quaternion.packedLength;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {FrustumOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nFrustumOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const frustumType = value._frustumType;\n  const frustum = value._frustum;\n\n  array[startingIndex++] = frustumType;\n\n  if (frustumType === PERSPECTIVE) {\n    PerspectiveFrustum.pack(frustum, array, startingIndex);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    OrthographicFrustum.pack(frustum, array, startingIndex);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  Cartesian3.pack(value._origin, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Quaternion.pack(value._orientation, array, startingIndex);\n  startingIndex += Quaternion.packedLength;\n  array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\n\n  return array;\n};\n\nconst scratchPackPerspective = new PerspectiveFrustum();\nconst scratchPackOrthographic = new OrthographicFrustum();\nconst scratchPackQuaternion = new Quaternion();\nconst scratchPackorigin = new Cartesian3();\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {FrustumOutlineGeometry} [result] The object into which to store the result.\n */\nFrustumOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  const frustumType = array[startingIndex++];\n\n  let frustum;\n  if (frustumType === PERSPECTIVE) {\n    frustum = PerspectiveFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackPerspective,\n    );\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    frustum = OrthographicFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackOrthographic,\n    );\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  const origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\n  startingIndex += Cartesian3.packedLength;\n  const orientation = Quaternion.unpack(\n    array,\n    startingIndex,\n    scratchPackQuaternion,\n  );\n  startingIndex += Quaternion.packedLength;\n  const drawNearPlane = array[startingIndex] === 1.0;\n\n  if (!defined(result)) {\n    return new FrustumOutlineGeometry({\n      frustum: frustum,\n      origin: origin,\n      orientation: orientation,\n      _drawNearPlane: drawNearPlane,\n    });\n  }\n\n  const frustumResult =\n    frustumType === result._frustumType ? result._frustum : undefined;\n  result._frustum = frustum.clone(frustumResult);\n\n  result._frustumType = frustumType;\n  result._origin = Cartesian3.clone(origin, result._origin);\n  result._orientation = Quaternion.clone(orientation, result._orientation);\n  result._drawNearPlane = drawNearPlane;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of a frustum outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {FrustumOutlineGeometry} frustumGeometry A description of the frustum.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nFrustumOutlineGeometry.createGeometry = function (frustumGeometry) {\n  const frustumType = frustumGeometry._frustumType;\n  const frustum = frustumGeometry._frustum;\n  const origin = frustumGeometry._origin;\n  const orientation = frustumGeometry._orientation;\n  const drawNearPlane = frustumGeometry._drawNearPlane;\n\n  const positions = new Float64Array(3 * 4 * 2);\n  FrustumGeometry._computeNearFarPlanes(\n    origin,\n    orientation,\n    frustumType,\n    frustum,\n    positions,\n  );\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  let offset;\n  let index;\n\n  const numberOfPlanes = drawNearPlane ? 2 : 1;\n  const indices = new Uint16Array(8 * (numberOfPlanes + 1));\n\n  // Build the near/far planes\n  let i = drawNearPlane ? 0 : 1;\n  for (; i < 2; ++i) {\n    offset = drawNearPlane ? i * 8 : 0;\n    index = i * 4;\n\n    indices[offset] = index;\n    indices[offset + 1] = index + 1;\n    indices[offset + 2] = index + 1;\n    indices[offset + 3] = index + 2;\n    indices[offset + 4] = index + 2;\n    indices[offset + 5] = index + 3;\n    indices[offset + 6] = index + 3;\n    indices[offset + 7] = index;\n  }\n\n  // Build the sides of the frustums\n  for (i = 0; i < 2; ++i) {\n    offset = (numberOfPlanes + i) * 8;\n    index = i * 4;\n\n    indices[offset] = index;\n    indices[offset + 1] = index + 4;\n    indices[offset + 2] = index + 1;\n    indices[offset + 3] = index + 5;\n    indices[offset + 4] = index + 2;\n    indices[offset + 5] = index + 6;\n    indices[offset + 6] = index + 3;\n    indices[offset + 7] = index + 7;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromVertices(positions),\n  });\n};\nexport default FrustumOutlineGeometry;\n"],"names":["PERSPECTIVE","ORTHOGRAPHIC","FrustumOutlineGeometry","options","typeOf","object","frustum","origin","orientation","drawNearPlane","_drawNearPlane","frustumType","frustumPackedLength","packedLength","_frustumType","_frustum","clone","_origin","_orientation","_workerName","pack","value","array","startingIndex","defined","scratchPackPerspective","scratchPackOrthographic","scratchPackQuaternion","scratchPackorigin","unpack","result","frustumResult","undefined","createGeometry","frustumGeometry","positions","Float64Array","_computeNearFarPlanes","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","offset","index","numberOfPlanes","indices","Uint16Array","i","primitiveType","LINES","boundingSphere","fromVertices"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 59951, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/KeyboardEventModifier.js"],"sourcesContent":["/**\n * This enumerated type is for representing keyboard modifiers. These are keys\n * that are held down in addition to other event types.\n *\n * @enum {number}\n */\nconst KeyboardEventModifier = {\n  /**\n   * Represents the shift key being held down.\n   *\n   * @type {number}\n   * @constant\n   */\n  SHIFT: 0,\n\n  /**\n   * Represents the control key being held down.\n   *\n   * @type {number}\n   * @constant\n   */\n  CTRL: 1,\n\n  /**\n   * Represents the alt key being held down.\n   *\n   * @type {number}\n   * @constant\n   */\n  ALT: 2,\n};\nexport default Object.freeze(KeyboardEventModifier);\n"],"names":["KeyboardEventModifier","SHIFT","CTRL","ALT","Object","freeze"],"mappings":";;;;AAAA;;;;;CAKC,GACD,MAAMA,wBAAwB;IAC5B;;;;;GAKC,GACDC,OAAO;IAEP;;;;;GAKC,GACDC,MAAM;IAEN;;;;;GAKC,GACDC,KAAK;AACP;uCACeC,OAAOC,MAAM,CAACL","ignoreList":[0]}},
    {"offset": {"line": 59985, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/ScreenSpaceEventType.js"],"sourcesContent":["/**\n * This enumerated type is for classifying mouse events: down, up, click, double click, move and move while a button is held down.\n *\n * @enum {number}\n */\nconst ScreenSpaceEventType = {\n  /**\n   * Represents a mouse left button down event.\n   *\n   * @type {number}\n   * @constant\n   */\n  LEFT_DOWN: 0,\n\n  /**\n   * Represents a mouse left button up event.\n   *\n   * @type {number}\n   * @constant\n   */\n  LEFT_UP: 1,\n\n  /**\n   * Represents a mouse left click event.\n   *\n   * @type {number}\n   * @constant\n   */\n  LEFT_CLICK: 2,\n\n  /**\n   * Represents a mouse left double click event.\n   *\n   * @type {number}\n   * @constant\n   */\n  LEFT_DOUBLE_CLICK: 3,\n\n  /**\n   * Represents a mouse left button down event.\n   *\n   * @type {number}\n   * @constant\n   */\n  RIGHT_DOWN: 5,\n\n  /**\n   * Represents a mouse right button up event.\n   *\n   * @type {number}\n   * @constant\n   */\n  RIGHT_UP: 6,\n\n  /**\n   * Represents a mouse right click event.\n   *\n   * @type {number}\n   * @constant\n   */\n  RIGHT_CLICK: 7,\n\n  /**\n   * Represents a mouse middle button down event.\n   *\n   * @type {number}\n   * @constant\n   */\n  MIDDLE_DOWN: 10,\n\n  /**\n   * Represents a mouse middle button up event.\n   *\n   * @type {number}\n   * @constant\n   */\n  MIDDLE_UP: 11,\n\n  /**\n   * Represents a mouse middle click event.\n   *\n   * @type {number}\n   * @constant\n   */\n  MIDDLE_CLICK: 12,\n\n  /**\n   * Represents a mouse move event.\n   *\n   * @type {number}\n   * @constant\n   */\n  MOUSE_MOVE: 15,\n\n  /**\n   * Represents a mouse wheel event.\n   *\n   * @type {number}\n   * @constant\n   */\n  WHEEL: 16,\n\n  /**\n   * Represents the start of a two-finger event on a touch surface.\n   *\n   * @type {number}\n   * @constant\n   */\n  PINCH_START: 17,\n\n  /**\n   * Represents the end of a two-finger event on a touch surface.\n   *\n   * @type {number}\n   * @constant\n   */\n  PINCH_END: 18,\n\n  /**\n   * Represents a change of a two-finger event on a touch surface.\n   *\n   * @type {number}\n   * @constant\n   */\n  PINCH_MOVE: 19,\n};\nexport default Object.freeze(ScreenSpaceEventType);\n"],"names":["ScreenSpaceEventType","LEFT_DOWN","LEFT_UP","LEFT_CLICK","LEFT_DOUBLE_CLICK","RIGHT_DOWN","RIGHT_UP","RIGHT_CLICK","MIDDLE_DOWN","MIDDLE_UP","MIDDLE_CLICK","MOUSE_MOVE","WHEEL","PINCH_START","PINCH_END","PINCH_MOVE","Object","freeze"],"mappings":";;;;AAAA;;;;CAIC,GACD,MAAMA,uBAAuB;IAC3B;;;;;GAKC,GACDC,WAAW;IAEX;;;;;GAKC,GACDC,SAAS;IAET;;;;;GAKC,GACDC,YAAY;IAEZ;;;;;GAKC,GACDC,mBAAmB;IAEnB;;;;;GAKC,GACDC,YAAY;IAEZ;;;;;GAKC,GACDC,UAAU;IAEV;;;;;GAKC,GACDC,aAAa;IAEb;;;;;GAKC,GACDC,aAAa;IAEb;;;;;GAKC,GACDC,WAAW;IAEX;;;;;GAKC,GACDC,cAAc;IAEd;;;;;GAKC,GACDC,YAAY;IAEZ;;;;;GAKC,GACDC,OAAO;IAEP;;;;;GAKC,GACDC,aAAa;IAEb;;;;;GAKC,GACDC,WAAW;IAEX;;;;;GAKC,GACDC,YAAY;AACd;uCACeC,OAAOC,MAAM,CAACjB","ignoreList":[0]}},
    {"offset": {"line": 60090, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/ScreenSpaceEventHandler.js"],"sourcesContent":["import AssociativeArray from \"./AssociativeArray.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport defined from \"./defined.js\";\nimport destroyObject from \"./destroyObject.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport FeatureDetection from \"./FeatureDetection.js\";\nimport getTimestamp from \"./getTimestamp.js\";\nimport KeyboardEventModifier from \"./KeyboardEventModifier.js\";\nimport ScreenSpaceEventType from \"./ScreenSpaceEventType.js\";\n\nfunction getPosition(screenSpaceEventHandler, event, result) {\n  const element = screenSpaceEventHandler._element;\n  if (element === document) {\n    result.x = event.clientX;\n    result.y = event.clientY;\n    return result;\n  }\n\n  const rect = element.getBoundingClientRect();\n  result.x = event.clientX - rect.left;\n  result.y = event.clientY - rect.top;\n  return result;\n}\n\nfunction getInputEventKey(type, modifier) {\n  let key = type;\n  if (defined(modifier)) {\n    key += `+${modifier}`;\n  }\n  return key;\n}\n\nfunction getModifier(event) {\n  if (event.shiftKey) {\n    return KeyboardEventModifier.SHIFT;\n  } else if (event.ctrlKey) {\n    return KeyboardEventModifier.CTRL;\n  } else if (event.altKey) {\n    return KeyboardEventModifier.ALT;\n  }\n\n  return undefined;\n}\n\nconst MouseButton = {\n  LEFT: 0,\n  MIDDLE: 1,\n  RIGHT: 2,\n};\n\nfunction registerListener(screenSpaceEventHandler, domType, element, callback) {\n  function listener(e) {\n    callback(screenSpaceEventHandler, e);\n  }\n\n  if (FeatureDetection.isInternetExplorer()) {\n    element.addEventListener(domType, listener, false);\n  } else {\n    element.addEventListener(domType, listener, {\n      capture: false,\n      passive: false,\n    });\n  }\n\n  screenSpaceEventHandler._removalFunctions.push(function () {\n    element.removeEventListener(domType, listener, false);\n  });\n}\n\nfunction registerListeners(screenSpaceEventHandler) {\n  const element = screenSpaceEventHandler._element;\n\n  // some listeners may be registered on the document, so we still get events even after\n  // leaving the bounds of element.\n  // this is affected by the existence of an undocumented disableRootEvents property on element.\n  const alternateElement = !defined(element.disableRootEvents)\n    ? document\n    : element;\n\n  if (FeatureDetection.supportsPointerEvents()) {\n    registerListener(\n      screenSpaceEventHandler,\n      \"pointerdown\",\n      element,\n      handlePointerDown,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"pointerup\",\n      element,\n      handlePointerUp,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"pointermove\",\n      element,\n      handlePointerMove,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"pointercancel\",\n      element,\n      handlePointerUp,\n    );\n  } else {\n    registerListener(\n      screenSpaceEventHandler,\n      \"mousedown\",\n      element,\n      handleMouseDown,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"mouseup\",\n      alternateElement,\n      handleMouseUp,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"mousemove\",\n      alternateElement,\n      handleMouseMove,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"touchstart\",\n      element,\n      handleTouchStart,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"touchend\",\n      alternateElement,\n      handleTouchEnd,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"touchmove\",\n      alternateElement,\n      handleTouchMove,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"touchcancel\",\n      alternateElement,\n      handleTouchEnd,\n    );\n  }\n\n  registerListener(\n    screenSpaceEventHandler,\n    \"dblclick\",\n    element,\n    handleDblClick,\n  );\n\n  // detect available wheel event\n  let wheelEvent;\n  if (\"onwheel\" in element) {\n    // spec event type\n    wheelEvent = \"wheel\";\n  } else if (document.onmousewheel !== undefined) {\n    // legacy event type\n    wheelEvent = \"mousewheel\";\n  } else {\n    // older Firefox\n    wheelEvent = \"DOMMouseScroll\";\n  }\n\n  registerListener(screenSpaceEventHandler, wheelEvent, element, handleWheel);\n}\n\nfunction unregisterListeners(screenSpaceEventHandler) {\n  const removalFunctions = screenSpaceEventHandler._removalFunctions;\n  for (let i = 0; i < removalFunctions.length; ++i) {\n    removalFunctions[i]();\n  }\n}\n\nconst mouseDownEvent = {\n  position: new Cartesian2(),\n};\n\nfunction gotTouchEvent(screenSpaceEventHandler) {\n  screenSpaceEventHandler._lastSeenTouchEvent = getTimestamp();\n}\n\nfunction canProcessMouseEvent(screenSpaceEventHandler) {\n  return (\n    getTimestamp() - screenSpaceEventHandler._lastSeenTouchEvent >\n    ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds\n  );\n}\n\nfunction checkPixelTolerance(startPosition, endPosition, pixelTolerance) {\n  const xDiff = startPosition.x - endPosition.x;\n  const yDiff = startPosition.y - endPosition.y;\n  const totalPixels = Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n\n  return totalPixels < pixelTolerance;\n}\n\nfunction handleMouseDown(screenSpaceEventHandler, event) {\n  if (!canProcessMouseEvent(screenSpaceEventHandler)) {\n    return;\n  }\n\n  const button = event.button;\n  screenSpaceEventHandler._buttonDown[button] = true;\n\n  let screenSpaceEventType;\n  if (button === MouseButton.LEFT) {\n    screenSpaceEventType = ScreenSpaceEventType.LEFT_DOWN;\n  } else if (button === MouseButton.MIDDLE) {\n    screenSpaceEventType = ScreenSpaceEventType.MIDDLE_DOWN;\n  } else if (button === MouseButton.RIGHT) {\n    screenSpaceEventType = ScreenSpaceEventType.RIGHT_DOWN;\n  } else {\n    return;\n  }\n\n  const position = getPosition(\n    screenSpaceEventHandler,\n    event,\n    screenSpaceEventHandler._primaryPosition,\n  );\n  Cartesian2.clone(position, screenSpaceEventHandler._primaryStartPosition);\n  Cartesian2.clone(position, screenSpaceEventHandler._primaryPreviousPosition);\n\n  const modifier = getModifier(event);\n\n  const action = screenSpaceEventHandler.getInputAction(\n    screenSpaceEventType,\n    modifier,\n  );\n\n  if (defined(action)) {\n    Cartesian2.clone(position, mouseDownEvent.position);\n\n    action(mouseDownEvent);\n\n    event.preventDefault();\n  }\n}\n\nconst mouseUpEvent = {\n  position: new Cartesian2(),\n};\nconst mouseClickEvent = {\n  position: new Cartesian2(),\n};\n\nfunction cancelMouseEvent(\n  screenSpaceEventHandler,\n  screenSpaceEventType,\n  clickScreenSpaceEventType,\n  event,\n) {\n  const modifier = getModifier(event);\n\n  const action = screenSpaceEventHandler.getInputAction(\n    screenSpaceEventType,\n    modifier,\n  );\n  const clickAction = screenSpaceEventHandler.getInputAction(\n    clickScreenSpaceEventType,\n    modifier,\n  );\n\n  if (defined(action) || defined(clickAction)) {\n    const position = getPosition(\n      screenSpaceEventHandler,\n      event,\n      screenSpaceEventHandler._primaryPosition,\n    );\n\n    if (defined(action)) {\n      Cartesian2.clone(position, mouseUpEvent.position);\n\n      action(mouseUpEvent);\n    }\n\n    if (defined(clickAction)) {\n      const startPosition = screenSpaceEventHandler._primaryStartPosition;\n      if (\n        checkPixelTolerance(\n          startPosition,\n          position,\n          screenSpaceEventHandler._clickPixelTolerance,\n        )\n      ) {\n        Cartesian2.clone(position, mouseClickEvent.position);\n\n        clickAction(mouseClickEvent);\n      }\n    }\n  }\n}\n\nfunction handleMouseUp(screenSpaceEventHandler, event) {\n  if (!canProcessMouseEvent(screenSpaceEventHandler)) {\n    return;\n  }\n\n  const button = event.button;\n\n  if (\n    button !== MouseButton.LEFT &&\n    button !== MouseButton.MIDDLE &&\n    button !== MouseButton.RIGHT\n  ) {\n    return;\n  }\n\n  if (screenSpaceEventHandler._buttonDown[MouseButton.LEFT]) {\n    cancelMouseEvent(\n      screenSpaceEventHandler,\n      ScreenSpaceEventType.LEFT_UP,\n      ScreenSpaceEventType.LEFT_CLICK,\n      event,\n    );\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = false;\n  }\n  if (screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE]) {\n    cancelMouseEvent(\n      screenSpaceEventHandler,\n      ScreenSpaceEventType.MIDDLE_UP,\n      ScreenSpaceEventType.MIDDLE_CLICK,\n      event,\n    );\n    screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE] = false;\n  }\n  if (screenSpaceEventHandler._buttonDown[MouseButton.RIGHT]) {\n    cancelMouseEvent(\n      screenSpaceEventHandler,\n      ScreenSpaceEventType.RIGHT_UP,\n      ScreenSpaceEventType.RIGHT_CLICK,\n      event,\n    );\n    screenSpaceEventHandler._buttonDown[MouseButton.RIGHT] = false;\n  }\n}\n\nconst mouseMoveEvent = {\n  startPosition: new Cartesian2(),\n  endPosition: new Cartesian2(),\n};\n\nfunction handleMouseMove(screenSpaceEventHandler, event) {\n  if (!canProcessMouseEvent(screenSpaceEventHandler)) {\n    return;\n  }\n\n  const modifier = getModifier(event);\n\n  const position = getPosition(\n    screenSpaceEventHandler,\n    event,\n    screenSpaceEventHandler._primaryPosition,\n  );\n  const previousPosition = screenSpaceEventHandler._primaryPreviousPosition;\n\n  const action = screenSpaceEventHandler.getInputAction(\n    ScreenSpaceEventType.MOUSE_MOVE,\n    modifier,\n  );\n\n  if (defined(action)) {\n    Cartesian2.clone(previousPosition, mouseMoveEvent.startPosition);\n    Cartesian2.clone(position, mouseMoveEvent.endPosition);\n\n    action(mouseMoveEvent);\n  }\n\n  Cartesian2.clone(position, previousPosition);\n\n  if (\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] ||\n    screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE] ||\n    screenSpaceEventHandler._buttonDown[MouseButton.RIGHT]\n  ) {\n    event.preventDefault();\n  }\n}\n\nconst mouseDblClickEvent = {\n  position: new Cartesian2(),\n};\n\nfunction handleDblClick(screenSpaceEventHandler, event) {\n  const button = event.button;\n\n  let screenSpaceEventType;\n  if (button === MouseButton.LEFT) {\n    screenSpaceEventType = ScreenSpaceEventType.LEFT_DOUBLE_CLICK;\n  } else {\n    return;\n  }\n\n  const modifier = getModifier(event);\n\n  const action = screenSpaceEventHandler.getInputAction(\n    screenSpaceEventType,\n    modifier,\n  );\n\n  if (defined(action)) {\n    getPosition(screenSpaceEventHandler, event, mouseDblClickEvent.position);\n\n    action(mouseDblClickEvent);\n  }\n}\n\nfunction handleWheel(screenSpaceEventHandler, event) {\n  // currently this event exposes the delta value in terms of\n  // the obsolete mousewheel event type.  so, for now, we adapt the other\n  // values to that scheme.\n  let delta;\n\n  // standard wheel event uses deltaY.  sign is opposite wheelDelta.\n  // deltaMode indicates what unit it is in.\n  if (defined(event.deltaY)) {\n    const deltaMode = event.deltaMode;\n    if (deltaMode === event.DOM_DELTA_PIXEL) {\n      delta = -event.deltaY;\n    } else if (deltaMode === event.DOM_DELTA_LINE) {\n      delta = -event.deltaY * 40;\n    } else {\n      // DOM_DELTA_PAGE\n      delta = -event.deltaY * 120;\n    }\n  } else if (event.detail > 0) {\n    // old Firefox versions use event.detail to count the number of clicks. The sign\n    // of the integer is the direction the wheel is scrolled.\n    delta = event.detail * -120;\n  } else {\n    delta = event.wheelDelta;\n  }\n\n  if (!defined(delta)) {\n    return;\n  }\n\n  const modifier = getModifier(event);\n  const action = screenSpaceEventHandler.getInputAction(\n    ScreenSpaceEventType.WHEEL,\n    modifier,\n  );\n\n  if (defined(action)) {\n    action(delta);\n\n    event.preventDefault();\n  }\n}\n\nfunction handleTouchStart(screenSpaceEventHandler, event) {\n  gotTouchEvent(screenSpaceEventHandler);\n\n  const changedTouches = event.changedTouches;\n\n  let i;\n  const length = changedTouches.length;\n  let touch;\n  let identifier;\n  const positions = screenSpaceEventHandler._positions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    positions.set(\n      identifier,\n      getPosition(screenSpaceEventHandler, touch, new Cartesian2()),\n    );\n  }\n\n  fireTouchEvents(screenSpaceEventHandler, event);\n\n  const previousPositions = screenSpaceEventHandler._previousPositions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    previousPositions.set(\n      identifier,\n      Cartesian2.clone(positions.get(identifier)),\n    );\n  }\n}\n\nfunction handleTouchEnd(screenSpaceEventHandler, event) {\n  gotTouchEvent(screenSpaceEventHandler);\n\n  const changedTouches = event.changedTouches;\n\n  let i;\n  const length = changedTouches.length;\n  let touch;\n  let identifier;\n  const positions = screenSpaceEventHandler._positions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    positions.remove(identifier);\n  }\n\n  fireTouchEvents(screenSpaceEventHandler, event);\n\n  const previousPositions = screenSpaceEventHandler._previousPositions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    previousPositions.remove(identifier);\n  }\n}\n\nconst touchStartEvent = {\n  position: new Cartesian2(),\n};\nconst touch2StartEvent = {\n  position1: new Cartesian2(),\n  position2: new Cartesian2(),\n};\nconst touchEndEvent = {\n  position: new Cartesian2(),\n};\nconst touchClickEvent = {\n  position: new Cartesian2(),\n};\nconst touchHoldEvent = {\n  position: new Cartesian2(),\n};\n\nfunction fireTouchEvents(screenSpaceEventHandler, event) {\n  const modifier = getModifier(event);\n  const positions = screenSpaceEventHandler._positions;\n  const numberOfTouches = positions.length;\n  let action;\n  let clickAction;\n  const pinching = screenSpaceEventHandler._isPinching;\n\n  if (\n    numberOfTouches !== 1 &&\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT]\n  ) {\n    // transitioning from single touch, trigger UP and might trigger CLICK\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = false;\n\n    if (defined(screenSpaceEventHandler._touchHoldTimer)) {\n      clearTimeout(screenSpaceEventHandler._touchHoldTimer);\n      screenSpaceEventHandler._touchHoldTimer = undefined;\n    }\n\n    action = screenSpaceEventHandler.getInputAction(\n      ScreenSpaceEventType.LEFT_UP,\n      modifier,\n    );\n\n    if (defined(action)) {\n      Cartesian2.clone(\n        screenSpaceEventHandler._primaryPosition,\n        touchEndEvent.position,\n      );\n\n      action(touchEndEvent);\n    }\n\n    if (numberOfTouches === 0 && !screenSpaceEventHandler._isTouchHolding) {\n      // releasing single touch, check for CLICK\n      clickAction = screenSpaceEventHandler.getInputAction(\n        ScreenSpaceEventType.LEFT_CLICK,\n        modifier,\n      );\n\n      if (defined(clickAction)) {\n        const startPosition = screenSpaceEventHandler._primaryStartPosition;\n        const endPosition =\n          screenSpaceEventHandler._previousPositions.values[0];\n        if (\n          checkPixelTolerance(\n            startPosition,\n            endPosition,\n            screenSpaceEventHandler._clickPixelTolerance,\n          )\n        ) {\n          Cartesian2.clone(\n            screenSpaceEventHandler._primaryPosition,\n            touchClickEvent.position,\n          );\n\n          clickAction(touchClickEvent);\n        }\n      }\n    }\n\n    screenSpaceEventHandler._isTouchHolding = false;\n\n    // Otherwise don't trigger CLICK, because we are adding more touches.\n  }\n\n  if (numberOfTouches === 0 && pinching) {\n    // transitioning from pinch, trigger PINCH_END\n    screenSpaceEventHandler._isPinching = false;\n\n    action = screenSpaceEventHandler.getInputAction(\n      ScreenSpaceEventType.PINCH_END,\n      modifier,\n    );\n\n    if (defined(action)) {\n      action();\n    }\n  }\n\n  if (numberOfTouches === 1 && !pinching) {\n    // transitioning to single touch, trigger DOWN\n    const position = positions.values[0];\n    Cartesian2.clone(position, screenSpaceEventHandler._primaryPosition);\n    Cartesian2.clone(position, screenSpaceEventHandler._primaryStartPosition);\n    Cartesian2.clone(\n      position,\n      screenSpaceEventHandler._primaryPreviousPosition,\n    );\n\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = true;\n\n    action = screenSpaceEventHandler.getInputAction(\n      ScreenSpaceEventType.LEFT_DOWN,\n      modifier,\n    );\n\n    if (defined(action)) {\n      Cartesian2.clone(position, touchStartEvent.position);\n\n      action(touchStartEvent);\n    }\n\n    screenSpaceEventHandler._touchHoldTimer = setTimeout(function () {\n      if (!screenSpaceEventHandler.isDestroyed()) {\n        screenSpaceEventHandler._touchHoldTimer = undefined;\n        screenSpaceEventHandler._isTouchHolding = true;\n\n        clickAction = screenSpaceEventHandler.getInputAction(\n          ScreenSpaceEventType.RIGHT_CLICK,\n          modifier,\n        );\n\n        if (defined(clickAction)) {\n          const startPosition = screenSpaceEventHandler._primaryStartPosition;\n          const endPosition =\n            screenSpaceEventHandler._previousPositions.values[0];\n          if (\n            checkPixelTolerance(\n              startPosition,\n              endPosition,\n              screenSpaceEventHandler._holdPixelTolerance,\n            )\n          ) {\n            Cartesian2.clone(\n              screenSpaceEventHandler._primaryPosition,\n              touchHoldEvent.position,\n            );\n\n            clickAction(touchHoldEvent);\n          }\n        }\n      }\n    }, ScreenSpaceEventHandler.touchHoldDelayMilliseconds);\n\n    event.preventDefault();\n  }\n\n  if (numberOfTouches === 2 && !pinching) {\n    // transitioning to pinch, trigger PINCH_START\n    screenSpaceEventHandler._isPinching = true;\n\n    action = screenSpaceEventHandler.getInputAction(\n      ScreenSpaceEventType.PINCH_START,\n      modifier,\n    );\n\n    if (defined(action)) {\n      Cartesian2.clone(positions.values[0], touch2StartEvent.position1);\n      Cartesian2.clone(positions.values[1], touch2StartEvent.position2);\n\n      action(touch2StartEvent);\n\n      // Touch-enabled devices, in particular iOS can have many default behaviours for\n      // \"pinch\" events, which can still be executed unless we prevent them here.\n      event.preventDefault();\n    }\n  }\n}\n\nfunction handleTouchMove(screenSpaceEventHandler, event) {\n  gotTouchEvent(screenSpaceEventHandler);\n\n  const changedTouches = event.changedTouches;\n\n  let i;\n  const length = changedTouches.length;\n  let touch;\n  let identifier;\n  const positions = screenSpaceEventHandler._positions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    const position = positions.get(identifier);\n    if (defined(position)) {\n      getPosition(screenSpaceEventHandler, touch, position);\n    }\n  }\n\n  fireTouchMoveEvents(screenSpaceEventHandler, event);\n\n  const previousPositions = screenSpaceEventHandler._previousPositions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    Cartesian2.clone(\n      positions.get(identifier),\n      previousPositions.get(identifier),\n    );\n  }\n}\n\nconst touchMoveEvent = {\n  startPosition: new Cartesian2(),\n  endPosition: new Cartesian2(),\n};\nconst touchPinchMovementEvent = {\n  distance: {\n    startPosition: new Cartesian2(),\n    endPosition: new Cartesian2(),\n  },\n  angleAndHeight: {\n    startPosition: new Cartesian2(),\n    endPosition: new Cartesian2(),\n  },\n};\n\nfunction fireTouchMoveEvents(screenSpaceEventHandler, event) {\n  const modifier = getModifier(event);\n  const positions = screenSpaceEventHandler._positions;\n  const previousPositions = screenSpaceEventHandler._previousPositions;\n  const numberOfTouches = positions.length;\n  let action;\n\n  if (\n    numberOfTouches === 1 &&\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT]\n  ) {\n    // moving single touch\n    const position = positions.values[0];\n    Cartesian2.clone(position, screenSpaceEventHandler._primaryPosition);\n\n    const previousPosition = screenSpaceEventHandler._primaryPreviousPosition;\n\n    action = screenSpaceEventHandler.getInputAction(\n      ScreenSpaceEventType.MOUSE_MOVE,\n      modifier,\n    );\n\n    if (defined(action)) {\n      Cartesian2.clone(previousPosition, touchMoveEvent.startPosition);\n      Cartesian2.clone(position, touchMoveEvent.endPosition);\n\n      action(touchMoveEvent);\n    }\n\n    Cartesian2.clone(position, previousPosition);\n\n    event.preventDefault();\n  } else if (numberOfTouches === 2 && screenSpaceEventHandler._isPinching) {\n    // moving pinch\n\n    action = screenSpaceEventHandler.getInputAction(\n      ScreenSpaceEventType.PINCH_MOVE,\n      modifier,\n    );\n    if (defined(action)) {\n      const position1 = positions.values[0];\n      const position2 = positions.values[1];\n      const previousPosition1 = previousPositions.values[0];\n      const previousPosition2 = previousPositions.values[1];\n\n      const dX = position2.x - position1.x;\n      const dY = position2.y - position1.y;\n      const dist = Math.sqrt(dX * dX + dY * dY) * 0.25;\n\n      const prevDX = previousPosition2.x - previousPosition1.x;\n      const prevDY = previousPosition2.y - previousPosition1.y;\n      const prevDist = Math.sqrt(prevDX * prevDX + prevDY * prevDY) * 0.25;\n\n      const cY = (position2.y + position1.y) * 0.125;\n      const prevCY = (previousPosition2.y + previousPosition1.y) * 0.125;\n      const angle = Math.atan2(dY, dX);\n      const prevAngle = Math.atan2(prevDY, prevDX);\n\n      Cartesian2.fromElements(\n        0.0,\n        prevDist,\n        touchPinchMovementEvent.distance.startPosition,\n      );\n      Cartesian2.fromElements(\n        0.0,\n        dist,\n        touchPinchMovementEvent.distance.endPosition,\n      );\n\n      Cartesian2.fromElements(\n        prevAngle,\n        prevCY,\n        touchPinchMovementEvent.angleAndHeight.startPosition,\n      );\n      Cartesian2.fromElements(\n        angle,\n        cY,\n        touchPinchMovementEvent.angleAndHeight.endPosition,\n      );\n\n      action(touchPinchMovementEvent);\n    }\n  }\n}\n\nfunction handlePointerDown(screenSpaceEventHandler, event) {\n  event.target.setPointerCapture(event.pointerId);\n\n  if (event.pointerType === \"touch\") {\n    const positions = screenSpaceEventHandler._positions;\n\n    const identifier = event.pointerId;\n    positions.set(\n      identifier,\n      getPosition(screenSpaceEventHandler, event, new Cartesian2()),\n    );\n\n    fireTouchEvents(screenSpaceEventHandler, event);\n\n    const previousPositions = screenSpaceEventHandler._previousPositions;\n    previousPositions.set(\n      identifier,\n      Cartesian2.clone(positions.get(identifier)),\n    );\n  } else {\n    handleMouseDown(screenSpaceEventHandler, event);\n  }\n}\n\nfunction handlePointerUp(screenSpaceEventHandler, event) {\n  if (event.pointerType === \"touch\") {\n    const positions = screenSpaceEventHandler._positions;\n\n    const identifier = event.pointerId;\n    positions.remove(identifier);\n\n    fireTouchEvents(screenSpaceEventHandler, event);\n\n    const previousPositions = screenSpaceEventHandler._previousPositions;\n    previousPositions.remove(identifier);\n  } else {\n    handleMouseUp(screenSpaceEventHandler, event);\n  }\n}\n\nfunction handlePointerMove(screenSpaceEventHandler, event) {\n  if (event.pointerType === \"touch\") {\n    const positions = screenSpaceEventHandler._positions;\n\n    const identifier = event.pointerId;\n    const position = positions.get(identifier);\n    if (!defined(position)) {\n      return;\n    }\n\n    getPosition(screenSpaceEventHandler, event, position);\n    fireTouchMoveEvents(screenSpaceEventHandler, event);\n\n    const previousPositions = screenSpaceEventHandler._previousPositions;\n    Cartesian2.clone(\n      positions.get(identifier),\n      previousPositions.get(identifier),\n    );\n  } else {\n    handleMouseMove(screenSpaceEventHandler, event);\n  }\n}\n\n/**\n * @typedef {object} ScreenSpaceEventHandler.PositionedEvent\n *\n * An Event that occurs at a single position on screen.\n *\n * @property {Cartesian2} position\n */\n\n/**\n * @callback ScreenSpaceEventHandler.PositionedEventCallback\n *\n * The callback invoked when a positioned event triggers an event listener.\n *\n * @param {ScreenSpaceEventHandler.PositionedEvent} event The event which triggered the listener\n */\n\n/**\n * @typedef {object} ScreenSpaceEventHandler.MotionEvent\n *\n * An Event that starts at one position and ends at another.\n *\n * @property {Cartesian2} startPosition\n * @property {Cartesian2} endPosition\n */\n\n/**\n * @callback ScreenSpaceEventHandler.MotionEventCallback\n *\n * The callback invoked when a motion event triggers an event listener.\n *\n * @param {ScreenSpaceEventHandler.MotionEvent} event The event which triggered the listener\n */\n\n/**\n * @typedef {object} ScreenSpaceEventHandler.TwoPointEvent\n *\n * An Event that occurs at a two positions on screen.\n *\n * @property {Cartesian2} position1\n * @property {Cartesian2} position2\n */\n\n/**\n * @callback ScreenSpaceEventHandler.TwoPointEventCallback\n *\n * The callback invoked when a two-point event triggers an event listener.\n *\n * @param {ScreenSpaceEventHandler.TwoPointEvent} event The event which triggered the listener\n */\n\n/**\n * @typedef {object} ScreenSpaceEventHandler.TwoPointMotionEvent\n *\n * An Event that starts at a two positions on screen and moves to two other positions.\n *\n * @property {Cartesian2} position1\n * @property {Cartesian2} position2\n * @property {Cartesian2} previousPosition1\n * @property {Cartesian2} previousPosition2\n */\n\n/**\n * @callback ScreenSpaceEventHandler.TwoPointMotionEventCallback\n *\n * The callback invoked when a two-point motion event triggers an event listener.\n *\n * @param {ScreenSpaceEventHandler.TwoPointMotionEvent} event The event which triggered the listener\n */\n\n/**\n * @callback ScreenSpaceEventHandler.WheelEventCallback\n *\n * The callback invoked when a mouse-wheel event triggers an event listener.\n *\n * @param {number} delta The amount that the mouse wheel moved\n */\n\n/**\n * Handles user input events. Custom functions can be added to be executed on\n * when the user enters input.\n *\n * @alias ScreenSpaceEventHandler\n *\n * @param {HTMLCanvasElement} [element=document] The element to add events to.\n *\n * @constructor\n */\nfunction ScreenSpaceEventHandler(element) {\n  this._inputEvents = {};\n  this._buttonDown = {\n    [MouseButton.LEFT]: false,\n    [MouseButton.MIDDLE]: false,\n    [MouseButton.RIGHT]: false,\n  };\n  this._isPinching = false;\n  this._isTouchHolding = false;\n  this._lastSeenTouchEvent =\n    -ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds;\n\n  this._primaryStartPosition = new Cartesian2();\n  this._primaryPosition = new Cartesian2();\n  this._primaryPreviousPosition = new Cartesian2();\n\n  this._positions = new AssociativeArray();\n  this._previousPositions = new AssociativeArray();\n\n  this._removalFunctions = [];\n\n  this._touchHoldTimer = undefined;\n\n  // TODO: Revisit when doing mobile development. May need to be configurable\n  // or determined based on the platform?\n  this._clickPixelTolerance = 5;\n  this._holdPixelTolerance = 25;\n\n  this._element = element ?? document;\n\n  registerListeners(this);\n}\n\n/**\n * Set a function to be executed on an input event.\n *\n * @param {ScreenSpaceEventHandler.PositionedEventCallback|ScreenSpaceEventHandler.MotionEventCallback|ScreenSpaceEventHandler.WheelEventCallback|ScreenSpaceEventHandler.TwoPointEventCallback|ScreenSpaceEventHandler.TwoPointMotionEventCallback} action Function to be executed when the input event occurs.\n * @param {ScreenSpaceEventType} type The ScreenSpaceEventType of input event.\n * @param {KeyboardEventModifier} [modifier] A KeyboardEventModifier key that is held when a <code>type</code>\n * event occurs.\n *\n * @see ScreenSpaceEventHandler#getInputAction\n * @see ScreenSpaceEventHandler#removeInputAction\n */\nScreenSpaceEventHandler.prototype.setInputAction = function (\n  action,\n  type,\n  modifier,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(action)) {\n    throw new DeveloperError(\"action is required.\");\n  }\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getInputEventKey(type, modifier);\n  this._inputEvents[key] = action;\n};\n\n/**\n * Returns the function to be executed on an input event.\n *\n * @param {ScreenSpaceEventType} type The ScreenSpaceEventType of input event.\n * @param {KeyboardEventModifier} [modifier] A KeyboardEventModifier key that is held when a <code>type</code>\n * event occurs.\n *\n * @returns {ScreenSpaceEventHandler.PositionedEventCallback|ScreenSpaceEventHandler.MotionEventCallback|ScreenSpaceEventHandler.WheelEventCallback|ScreenSpaceEventHandler.TwoPointEventCallback|ScreenSpaceEventHandler.TwoPointMotionEventCallback} The function to be executed on an input event.\n *\n * @see ScreenSpaceEventHandler#setInputAction\n * @see ScreenSpaceEventHandler#removeInputAction\n */\nScreenSpaceEventHandler.prototype.getInputAction = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getInputEventKey(type, modifier);\n  return this._inputEvents[key];\n};\n\n/**\n * Removes the function to be executed on an input event.\n *\n * @param {ScreenSpaceEventType} type The ScreenSpaceEventType of input event.\n * @param {KeyboardEventModifier} [modifier] A KeyboardEventModifier key that is held when a <code>type</code>\n * event occurs.\n *\n * @see ScreenSpaceEventHandler#getInputAction\n * @see ScreenSpaceEventHandler#setInputAction\n */\nScreenSpaceEventHandler.prototype.removeInputAction = function (\n  type,\n  modifier,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getInputEventKey(type, modifier);\n  delete this._inputEvents[key];\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ScreenSpaceEventHandler#destroy\n */\nScreenSpaceEventHandler.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * handler = handler && handler.destroy();\n *\n * @see ScreenSpaceEventHandler#isDestroyed\n */\nScreenSpaceEventHandler.prototype.destroy = function () {\n  unregisterListeners(this);\n\n  return destroyObject(this);\n};\n\n/**\n * The amount of time, in milliseconds, that mouse events will be disabled after\n * receiving any touch events, such that any emulated mouse events will be ignored.\n * @type {number}\n * @default 800\n */\nScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds = 800;\n\n/**\n * The amount of time, in milliseconds, before a touch on the screen becomes a\n * touch and hold.\n * @type {number}\n * @default 1500\n */\nScreenSpaceEventHandler.touchHoldDelayMilliseconds = 1500;\nexport default ScreenSpaceEventHandler;\n"],"names":["getPosition","screenSpaceEventHandler","event","result","element","_element","document","x","clientX","y","clientY","rect","getBoundingClientRect","left","top","getInputEventKey","type","modifier","key","getModifier","shiftKey","SHIFT","ctrlKey","CTRL","altKey","ALT","undefined","MouseButton","LEFT","MIDDLE","RIGHT","registerListener","domType","callback","listener","e","isInternetExplorer","addEventListener","capture","passive","_removalFunctions","push","removeEventListener","registerListeners","alternateElement","disableRootEvents","supportsPointerEvents","handlePointerDown","handlePointerUp","handlePointerMove","handleMouseDown","handleMouseUp","handleMouseMove","handleTouchStart","handleTouchEnd","handleTouchMove","handleDblClick","wheelEvent","onmousewheel","handleWheel","unregisterListeners","removalFunctions","i","length","mouseDownEvent","position","gotTouchEvent","_lastSeenTouchEvent","canProcessMouseEvent","ScreenSpaceEventHandler","mouseEmulationIgnoreMilliseconds","checkPixelTolerance","startPosition","endPosition","pixelTolerance","xDiff","yDiff","totalPixels","Math","sqrt","button","_buttonDown","screenSpaceEventType","LEFT_DOWN","MIDDLE_DOWN","RIGHT_DOWN","_primaryPosition","clone","_primaryStartPosition","_primaryPreviousPosition","action","getInputAction","preventDefault","mouseUpEvent","mouseClickEvent","cancelMouseEvent","clickScreenSpaceEventType","clickAction","_clickPixelTolerance","LEFT_UP","LEFT_CLICK","MIDDLE_UP","MIDDLE_CLICK","RIGHT_UP","RIGHT_CLICK","mouseMoveEvent","previousPosition","MOUSE_MOVE","mouseDblClickEvent","LEFT_DOUBLE_CLICK","delta","deltaY","deltaMode","DOM_DELTA_PIXEL","DOM_DELTA_LINE","detail","wheelDelta","WHEEL","changedTouches","touch","identifier","positions","_positions","set","fireTouchEvents","previousPositions","_previousPositions","get","remove","touchStartEvent","touch2StartEvent","position1","position2","touchEndEvent","touchClickEvent","touchHoldEvent","numberOfTouches","pinching","_isPinching","_touchHoldTimer","clearTimeout","_isTouchHolding","values","PINCH_END","setTimeout","isDestroyed","_holdPixelTolerance","touchHoldDelayMilliseconds","PINCH_START","fireTouchMoveEvents","touchMoveEvent","touchPinchMovementEvent","distance","angleAndHeight","PINCH_MOVE","previousPosition1","previousPosition2","dX","dY","dist","prevDX","prevDY","prevDist","cY","prevCY","angle","atan2","prevAngle","fromElements","target","setPointerCapture","pointerId","pointerType","_inputEvents","prototype","setInputAction","removeInputAction","destroy"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 60831, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/getImageFromTypedArray.js"],"sourcesContent":["/**\n * Constructs an image from a TypedArray of pixel values\n *\n * @param {Uint8Array} typedArray The array of pixel values\n * @param {number} width The width of the image to create\n * @param {number} height The height of the image to create\n * @returns {HTMLCanvasElement} A new canvas containing the constructed image\n *\n * @private\n */\nfunction getImageFromTypedArray(typedArray, width, height) {\n  // Input typedArray is Uint8Array, ImageData needs Uint8ClampedArray\n  // To avoid copying, make a new DataView of the same buffer\n  const dataArray = new Uint8ClampedArray(typedArray.buffer);\n  const imageData = new ImageData(dataArray, width, height);\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n  canvas.getContext(\"2d\").putImageData(imageData, 0, 0);\n\n  return canvas;\n}\nexport default getImageFromTypedArray;\n"],"names":["getImageFromTypedArray","typedArray","width","height","dataArray","Uint8ClampedArray","buffer","imageData","ImageData","canvas","document","createElement","getContext","putImageData"],"mappings":";;;;AAAA;;;;;;;;;CASC,GACD,SAASA,uBAAuBC,UAAU,EAAEC,KAAK,EAAEC,MAAM;IACvD,oEAAoE;IACpE,2DAA2D;IAC3D,MAAMC,YAAY,IAAIC,kBAAkBJ,WAAWK,MAAM;IACzD,MAAMC,YAAY,IAAIC,UAAUJ,WAAWF,OAAOC;IAElD,MAAMM,SAASC,SAASC,aAAa,CAAC;IACtCF,OAAOP,KAAK,GAAGA;IACfO,OAAON,MAAM,GAAGA;IAChBM,OAAOG,UAAU,CAAC,MAAMC,YAAY,CAACN,WAAW,GAAG;IAEnD,OAAOE;AACT;uCACeT","ignoreList":[0]}},
    {"offset": {"line": 60869, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/DoubleEndedPriorityQueue.js"],"sourcesContent":["import CesiumMath from \"./Math.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Array-backed min-max heap implementation of a double-ended priority queue.\n * This data structure allows for efficient removal of minimum and maximum elements.\n *\n * @alias DoubleEndedPriorityQueue\n * @constructor\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {DoubleEndedPriorityQueue.ComparatorCallback} options.comparator The comparator to use for the queue. If comparator(a, b) is less than 0, a is lower priority than b.\n * @param {number} [options.maximumLength] The maximum length of the queue. If an element is inserted when the queue is at full capacity, the minimum element is removed. By default, the size of the queue is unlimited.\n */\nfunction DoubleEndedPriorityQueue(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.defined(\"options.comparator\", options.comparator);\n  if (defined(options.maximumLength)) {\n    Check.typeOf.number.greaterThanOrEquals(\n      \"options.maximumLength\",\n      options.maximumLength,\n      0,\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._comparator = options.comparator;\n  this._maximumLength = options.maximumLength;\n  this._array = defined(options.maximumLength)\n    ? new Array(options.maximumLength)\n    : [];\n  this._length = 0;\n}\n\nObject.defineProperties(DoubleEndedPriorityQueue.prototype, {\n  /**\n   * Gets the number of elements in the queue.\n   *\n   * @memberof DoubleEndedPriorityQueue.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._length;\n    },\n  },\n\n  /**\n   * Gets or sets the maximum number of elements in the queue.\n   * If set to a smaller value than the current length of the queue, the lowest priority elements are removed.\n   * If an element is inserted when the queue is at full capacity, the minimum element is removed.\n   * If set to undefined, the size of the queue is unlimited.\n   *\n   * @memberof DoubleEndedPriorityQueue.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  maximumLength: {\n    get: function () {\n      return this._maximumLength;\n    },\n    set: function (value) {\n      if (defined(value)) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.number.greaterThanOrEquals(\"maximumLength\", value, 0);\n        //>>includeEnd('debug');\n\n        // Remove elements until the maximum length is met.\n        while (this._length > value) {\n          this.removeMinimum();\n        }\n\n        // The array size is fixed to the maximum length\n        this._array.length = value;\n      }\n      this._maximumLength = value;\n    },\n  },\n\n  /**\n   * Gets the internal array.\n   *\n   * @memberof DoubleEndedPriorityQueue.prototype\n   *\n   * @type {Array}\n   * @readonly\n   */\n  internalArray: {\n    get: function () {\n      return this._array;\n    },\n  },\n\n  /**\n   * The comparator used by the queue.\n   * If comparator(a, b) is less than 0, a is lower priority than b.\n   *\n   * @memberof DoubleEndedPriorityQueue.prototype\n   *\n   * @type {DoubleEndedPriorityQueue.ComparatorCallback}\n   * @readonly\n   */\n  comparator: {\n    get: function () {\n      return this._comparator;\n    },\n  },\n});\n\n/**\n * Clones the double ended priority queue.\n *\n * @returns {DoubleEndedPriorityQueue} The cloned double ended priority queue.\n */\nDoubleEndedPriorityQueue.prototype.clone = function () {\n  const maximumLength = this._maximumLength;\n  const comparator = this._comparator;\n  const array = this._array;\n  const length = this._length;\n\n  const result = new DoubleEndedPriorityQueue({\n    comparator: comparator,\n    maximumLength: maximumLength,\n  });\n\n  result._length = length;\n  for (let i = 0; i < length; i++) {\n    result._array[i] = array[i];\n  }\n\n  return result;\n};\n\n/**\n * Removes all elements from the queue.\n */\nDoubleEndedPriorityQueue.prototype.reset = function () {\n  this._length = 0;\n\n  // Dereference elements\n  const maximumLength = this._maximumLength;\n  if (defined(maximumLength)) {\n    // Dereference all elements but keep the array the same size\n    for (let i = 0; i < maximumLength; i++) {\n      this._array[i] = undefined;\n    }\n  } else {\n    // Dereference all elements by clearing the array\n    this._array.length = 0;\n  }\n};\n\n/**\n * Resort the queue.\n */\nDoubleEndedPriorityQueue.prototype.resort = function () {\n  const length = this._length;\n\n  // Fix the queue from the top-down\n  for (let i = 0; i < length; i++) {\n    pushUp(this, i);\n  }\n};\n\n/**\n * Inserts an element into the queue.\n * If the queue is at full capacity, the minimum element is removed.\n * The new element is returned (and not added) if it is less than or equal priority to the minimum element.\n *\n * @param {*} element\n * @returns {*|undefined} The minimum element if the queue is at full capacity. Returns undefined if there is no maximum length.\n */\nDoubleEndedPriorityQueue.prototype.insert = function (element) {\n  let removedElement;\n\n  const maximumLength = this._maximumLength;\n  if (defined(maximumLength)) {\n    if (maximumLength === 0) {\n      return undefined;\n    } else if (this._length === maximumLength) {\n      // It's faster to access the minimum directly instead of calling the getter\n      // because it avoids the length === 0 check.\n      const minimumElement = this._array[0];\n      if (this._comparator(element, minimumElement) <= 0.0) {\n        // The element that is being inserted is less than or equal to\n        // the minimum element, so don't insert anything and exit early.\n        return element;\n      }\n      removedElement = this.removeMinimum();\n    }\n  }\n\n  const index = this._length;\n  this._array[index] = element;\n  this._length++;\n  pushUp(this, index);\n\n  return removedElement;\n};\n\n/**\n * Removes the minimum element from the queue and returns it.\n * If the queue is empty, the return value is undefined.\n *\n * @returns {*|undefined} The minimum element, or undefined if the queue is empty.\n */\nDoubleEndedPriorityQueue.prototype.removeMinimum = function () {\n  const length = this._length;\n  if (length === 0) {\n    return undefined;\n  }\n\n  this._length--;\n\n  // The minimum element is always the root\n  const minimumElement = this._array[0];\n\n  if (length >= 2) {\n    this._array[0] = this._array[length - 1];\n    pushDown(this, 0);\n  }\n\n  // Dereference removed element\n  this._array[length - 1] = undefined;\n\n  return minimumElement;\n};\n\n/**\n * Removes the maximum element from the queue and returns it.\n * If the queue is empty, the return value is undefined.\n *\n * @returns {*|undefined} The maximum element, or undefined if the queue is empty.\n */\nDoubleEndedPriorityQueue.prototype.removeMaximum = function () {\n  const length = this._length;\n  if (length === 0) {\n    return undefined;\n  }\n\n  this._length--;\n  let maximumElement;\n\n  // If the root has no children, the maximum is the root.\n  // If the root has one child, the maximum is the child.\n  if (length <= 2) {\n    maximumElement = this._array[length - 1];\n  } else {\n    // Otherwise, the maximum is the larger of the root's two children.\n    const maximumElementIndex = greaterThan(this, 1, 2) ? 1 : 2;\n    maximumElement = this._array[maximumElementIndex];\n\n    // Re-balance the heap\n    this._array[maximumElementIndex] = this._array[length - 1];\n    if (length >= 4) {\n      pushDown(this, maximumElementIndex);\n    }\n  }\n\n  // Dereference removed element\n  this._array[length - 1] = undefined;\n\n  return maximumElement;\n};\n\n/**\n * Gets the minimum element in the queue.\n * If the queue is empty, the result is undefined.\n *\n * @returns {*|undefined} element\n */\n\nDoubleEndedPriorityQueue.prototype.getMinimum = function () {\n  const length = this._length;\n  if (length === 0) {\n    return undefined;\n  }\n\n  // The minimum element is always the root\n  return this._array[0];\n};\n\n/**\n * Gets the maximum element in the queue.\n * If the queue is empty, the result is undefined.\n *\n * @returns {*|undefined} element\n */\nDoubleEndedPriorityQueue.prototype.getMaximum = function () {\n  const length = this._length;\n  if (length === 0) {\n    return undefined;\n  }\n\n  // If the root has no children, the maximum is the root.\n  // If the root has one child, the maximum is the child.\n  if (length <= 2) {\n    return this._array[length - 1];\n  }\n\n  // Otherwise, the maximum is the larger of the root's two children.\n  return this._array[greaterThan(this, 1, 2) ? 1 : 2];\n};\n\n// Helper functions\n\nfunction swap(that, indexA, indexB) {\n  const array = that._array;\n  const temp = array[indexA];\n  array[indexA] = array[indexB];\n  array[indexB] = temp;\n}\n\nfunction lessThan(that, indexA, indexB) {\n  return that._comparator(that._array[indexA], that._array[indexB]) < 0.0;\n}\n\nfunction greaterThan(that, indexA, indexB) {\n  return that._comparator(that._array[indexA], that._array[indexB]) > 0.0;\n}\n\nfunction pushUp(that, index) {\n  if (index === 0) {\n    return;\n  }\n  const onMinLevel = Math.floor(CesiumMath.log2(index + 1)) % 2 === 0;\n  const parentIndex = Math.floor((index - 1) / 2);\n  const lessThanParent = lessThan(that, index, parentIndex);\n\n  // Get the element onto the correct level if it's not already\n  if (lessThanParent !== onMinLevel) {\n    swap(that, index, parentIndex);\n    index = parentIndex;\n  }\n\n  // Swap element with grandparent as long as it:\n  // 1) has a grandparent\n  // 2A) is less than the grandparent when on a min level\n  // 2B) is greater than the grandparent when on a max level\n  while (index >= 3) {\n    const grandparentIndex = Math.floor((index - 3) / 4);\n    if (lessThan(that, index, grandparentIndex) !== lessThanParent) {\n      break;\n    }\n    swap(that, index, grandparentIndex);\n    index = grandparentIndex;\n  }\n}\n\nfunction pushDown(that, index) {\n  const length = that._length;\n  const onMinLevel = Math.floor(CesiumMath.log2(index + 1)) % 2 === 0;\n\n  // Loop as long as there is a left child.\n  let leftChildIndex;\n  while ((leftChildIndex = 2 * index + 1) < length) {\n    // Find the minimum (or maximum) child or grandchild\n    let target = leftChildIndex;\n    const rightChildIndex = leftChildIndex + 1;\n    if (rightChildIndex < length) {\n      if (lessThan(that, rightChildIndex, target) === onMinLevel) {\n        target = rightChildIndex;\n      }\n      const grandChildStart = 2 * leftChildIndex + 1;\n      const grandChildCount = Math.max(\n        Math.min(length - grandChildStart, 4),\n        0,\n      );\n      for (let i = 0; i < grandChildCount; i++) {\n        const grandChildIndex = grandChildStart + i;\n        if (lessThan(that, grandChildIndex, target) === onMinLevel) {\n          target = grandChildIndex;\n        }\n      }\n    }\n\n    // Swap the element into the correct spot\n    if (lessThan(that, target, index) === onMinLevel) {\n      swap(that, target, index);\n      if (target !== leftChildIndex && target !== rightChildIndex) {\n        const parentOfGrandchildIndex = Math.floor((target - 1) / 2);\n        if (greaterThan(that, target, parentOfGrandchildIndex) === onMinLevel) {\n          swap(that, target, parentOfGrandchildIndex);\n        }\n      }\n    }\n\n    index = target;\n  }\n}\n\n/**\n * The comparator to use for the queue.\n * @callback DoubleEndedPriorityQueue.ComparatorCallback\n * @param {*} a An element in the queue.\n * @param {*} b An element in the queue.\n * @returns {number} If the result of the comparison is less than 0, a is lower priority than b.\n */\nexport default DoubleEndedPriorityQueue;\n"],"names":["DoubleEndedPriorityQueue","options","typeOf","object","defined","comparator","maximumLength","number","greaterThanOrEquals","_comparator","_maximumLength","_array","Array","_length","Object","defineProperties","prototype","length","get","set","value","removeMinimum","internalArray","clone","array","result","i","reset","undefined","resort","pushUp","insert","element","removedElement","minimumElement","index","pushDown","removeMaximum","maximumElement","maximumElementIndex","greaterThan","getMinimum","getMaximum","swap","that","indexA","indexB","temp","lessThan","onMinLevel","Math","floor","log2","parentIndex","lessThanParent","grandparentIndex","leftChildIndex","target","rightChildIndex","grandChildStart","grandChildCount","max","min","grandChildIndex","parentOfGrandchildIndex"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 61287, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/IonGeocodeProviderType.js"],"sourcesContent":["/**\n * Underlying geocoding services that can be used via Cesium ion.\n *\n * @enum {string}\n */\nconst IonGeocodeProviderType = {\n  /**\n   * Google geocoder, for use with Google data.\n   *\n   * @type {string}\n   * @constant\n   */\n  GOOGLE: \"GOOGLE\",\n\n  /**\n   * Bing geocoder, for use with Bing data.\n   *\n   * @type {string}\n   * @constant\n   */\n  BING: \"BING\",\n\n  /**\n   * Use the default geocoder as set on the server.  Used when neither Bing or\n   * Google data is used.\n   *\n   * @type {string}\n   * @constant\n   */\n  DEFAULT: \"DEFAULT\",\n};\n\nexport default Object.freeze(IonGeocodeProviderType);\n"],"names":["IonGeocodeProviderType","GOOGLE","BING","DEFAULT","Object","freeze"],"mappings":";;;;AAAA;;;;CAIC,GACD,MAAMA,yBAAyB;IAC7B;;;;;GAKC,GACDC,QAAQ;IAER;;;;;GAKC,GACDC,MAAM;IAEN;;;;;;GAMC,GACDC,SAAS;AACX;uCAEeC,OAAOC,MAAM,CAACL","ignoreList":[0]}},
    {"offset": {"line": 61321, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/GeocodeType.js"],"sourcesContent":["/**\n * The type of geocoding to be performed by a {@link GeocoderService}.\n * @enum {number}\n * @see Geocoder\n */\nconst GeocodeType = {\n  /**\n   * Perform a search where the input is considered complete.\n   *\n   * @type {number}\n   * @constant\n   */\n  SEARCH: 0,\n\n  /**\n   * Perform an auto-complete using partial input, typically\n   * reserved for providing possible results as a user is typing.\n   *\n   * @type {number}\n   * @constant\n   */\n  AUTOCOMPLETE: 1,\n};\nexport default Object.freeze(GeocodeType);\n"],"names":["GeocodeType","SEARCH","AUTOCOMPLETE","Object","freeze"],"mappings":";;;;AAAA;;;;CAIC,GACD,MAAMA,cAAc;IAClB;;;;;GAKC,GACDC,QAAQ;IAER;;;;;;GAMC,GACDC,cAAc;AAChB;uCACeC,OAAOC,MAAM,CAACJ","ignoreList":[0]}},
    {"offset": {"line": 61349, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/PeliasGeocoderService.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport GeocodeType from \"./GeocodeType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Resource from \"./Resource.js\";\n\n/**\n * Provides geocoding via a {@link https://pelias.io/|Pelias} server.\n * @alias PeliasGeocoderService\n * @constructor\n *\n * @param {Resource|string} url The endpoint to the Pelias server.\n *\n * @example\n * // Configure a Viewer to use the Pelias server hosted by https://geocode.earth/\n * const viewer = new Cesium.Viewer('cesiumContainer', {\n *   geocoder: new Cesium.PeliasGeocoderService(new Cesium.Resource({\n *     url: 'https://api.geocode.earth/v1/',\n *       queryParameters: {\n *         api_key: '<Your geocode.earth API key>'\n *     }\n *   }))\n * });\n */\nfunction PeliasGeocoderService(url) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  this._url = Resource.createIfNeeded(url);\n  this._url.appendForwardSlash();\n}\n\nObject.defineProperties(PeliasGeocoderService.prototype, {\n  /**\n   * The Resource used to access the Pelias endpoint.\n   * @type {Resource}\n   * @memberof PeliasGeocoderService.prototype\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._url;\n    },\n  },\n  /**\n   * Gets the credit to display after a geocode is performed. Typically this is used to credit\n   * the geocoder service.\n   * @memberof PeliasGeocoderService.prototype\n   * @type {Credit|undefined}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return undefined;\n    },\n  },\n});\n\n/**\n * @function\n *\n * @param {string} query The query to be sent to the geocoder service\n * @param {GeocodeType} [type=GeocodeType.SEARCH] The type of geocode to perform.\n * @returns {Promise<GeocoderService.Result[]>}\n */\nPeliasGeocoderService.prototype.geocode = async function (query, type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"query\", query);\n  //>>includeEnd('debug');\n\n  const resource = this._url.getDerivedResource({\n    url: type === GeocodeType.AUTOCOMPLETE ? \"autocomplete\" : \"search\",\n    queryParameters: {\n      text: query,\n    },\n  });\n\n  return resource.fetchJson().then(function (results) {\n    return results.features.map(function (resultObject) {\n      let destination;\n      const bboxDegrees = resultObject.bbox;\n\n      if (defined(bboxDegrees)) {\n        destination = Rectangle.fromDegrees(\n          bboxDegrees[0],\n          bboxDegrees[1],\n          bboxDegrees[2],\n          bboxDegrees[3],\n        );\n      } else {\n        const lon = resultObject.geometry.coordinates[0];\n        const lat = resultObject.geometry.coordinates[1];\n        destination = Cartesian3.fromDegrees(lon, lat);\n      }\n\n      return {\n        displayName: resultObject.properties.label,\n        destination: destination,\n        attributions: results.attributions,\n      };\n    });\n  });\n};\nexport default PeliasGeocoderService;\n"],"names":["PeliasGeocoderService","url","defined","_url","createIfNeeded","appendForwardSlash","Object","defineProperties","prototype","get","credit","undefined","geocode","query","type","typeOf","string","resource","getDerivedResource","AUTOCOMPLETE","queryParameters","text","fetchJson","then","results","features","map","resultObject","destination","bboxDegrees","bbox","fromDegrees","lon","geometry","coordinates","lat","displayName","properties","label","attributions"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEA;;;;;;;;;;;;;;;;;CAiBC,GACD,SAASA,sBAAsBC,GAAG;IAChC,yCAAyC;IACzC,2KAAK,CAACC,OAAO,CAAC,OAAOD;IACrB,wBAAwB;IAExB,IAAI,CAACE,IAAI,GAAG,8KAAQ,CAACC,cAAc,CAACH;IACpC,IAAI,CAACE,IAAI,CAACE,kBAAkB;AAC9B;AAEAC,OAAOC,gBAAgB,CAACP,sBAAsBQ,SAAS,EAAE;IACvD;;;;;GAKC,GACDP,KAAK;QACHQ,KAAK;YACH,OAAO,IAAI,CAACN,IAAI;QAClB;IACF;IACA;;;;;;GAMC,GACDO,QAAQ;QACND,KAAK;YACH,OAAOE;QACT;IACF;AACF;AAEA;;;;;;CAMC,GACDX,sBAAsBQ,SAAS,CAACI,OAAO,GAAG,eAAgBC,KAAK,EAAEC,IAAI;IACnE,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,SAASH;IAC7B,wBAAwB;IAExB,MAAMI,WAAW,IAAI,CAACd,IAAI,CAACe,kBAAkB,CAAC;QAC5CjB,KAAKa,SAAS,iLAAW,CAACK,YAAY,GAAG,iBAAiB;QAC1DC,iBAAiB;YACfC,MAAMR;QACR;IACF;IAEA,OAAOI,SAASK,SAAS,GAAGC,IAAI,CAAC,SAAUC,OAAO;QAChD,OAAOA,QAAQC,QAAQ,CAACC,GAAG,CAAC,SAAUC,YAAY;YAChD,IAAIC;YACJ,MAAMC,cAAcF,aAAaG,IAAI;YAErC,IAAI,IAAA,6KAAO,EAACD,cAAc;gBACxBD,cAAc,+KAAS,CAACG,WAAW,CACjCF,WAAW,CAAC,EAAE,EACdA,WAAW,CAAC,EAAE,EACdA,WAAW,CAAC,EAAE,EACdA,WAAW,CAAC,EAAE;YAElB,OAAO;gBACL,MAAMG,MAAML,aAAaM,QAAQ,CAACC,WAAW,CAAC,EAAE;gBAChD,MAAMC,MAAMR,aAAaM,QAAQ,CAACC,WAAW,CAAC,EAAE;gBAChDN,cAAc,gLAAU,CAACG,WAAW,CAACC,KAAKG;YAC5C;YAEA,OAAO;gBACLC,aAAaT,aAAaU,UAAU,CAACC,KAAK;gBAC1CV,aAAaA;gBACbW,cAAcf,QAAQe,YAAY;YACpC;QACF;IACF;AACF;uCACevC","ignoreList":[0]}},
    {"offset": {"line": 61452, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/IonGeocoderService.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport Credit from \"./Credit.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ion from \"./Ion.js\";\nimport IonGeocodeProviderType from \"./IonGeocodeProviderType.js\";\nimport PeliasGeocoderService from \"./PeliasGeocoderService.js\";\nimport Resource from \"./Resource.js\";\n\n/**\n * @param {*} geocodeProviderType\n * @throws {DeveloperError}\n * @private\n */\nfunction validateIonGeocodeProviderType(geocodeProviderType) {\n  if (\n    !Object.values(IonGeocodeProviderType).some(\n      (value) => value === geocodeProviderType,\n    )\n  ) {\n    throw new DeveloperError(\n      `Invalid geocodeProviderType: \"${geocodeProviderType}\"`,\n    );\n  }\n}\n\nconst providerToParameterMap = Object.freeze({\n  [IonGeocodeProviderType.GOOGLE]: \"google\",\n  [IonGeocodeProviderType.BING]: \"bing\",\n  [IonGeocodeProviderType.DEFAULT]: undefined,\n});\n\nfunction providerToQueryParameter(provider) {\n  return providerToParameterMap[provider];\n}\n\nfunction queryParameterToProvider(parameter) {\n  return Object.entries(providerToParameterMap).find(\n    (entry) => entry[1] === parameter,\n  )[0];\n}\n\n/**\n * Provides geocoding through Cesium ion.\n * @alias IonGeocoderService\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Scene} options.scene The scene\n * @param {string} [options.accessToken=Ion.defaultAccessToken] The access token to use.\n * @param {string|Resource} [options.server=Ion.defaultServer] The resource to the Cesium ion API server.\n * @param {IonGeocodeProviderType} [options.geocodeProviderType=IonGeocodeProviderType.DEFAULT] The geocoder the Cesium ion API server should use to fulfill this request.\n *\n * @see Ion\n */\nfunction IonGeocoderService(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.scene\", options.scene);\n  //>>includeEnd('debug');\n\n  const geocodeProviderType =\n    options.geocodeProviderType ?? IonGeocodeProviderType.DEFAULT;\n  //>>includeStart('debug', pragmas.debug);\n  validateIonGeocodeProviderType(geocodeProviderType);\n  //>>includeEnd('debug');\n\n  const accessToken = options.accessToken ?? Ion.defaultAccessToken;\n  const server = Resource.createIfNeeded(options.server ?? Ion.defaultServer);\n  server.appendForwardSlash();\n\n  const defaultTokenCredit = Ion.getDefaultTokenCredit(accessToken);\n  if (defined(defaultTokenCredit)) {\n    options.scene.frameState.creditDisplay.addStaticCredit(\n      Credit.clone(defaultTokenCredit),\n    );\n  }\n\n  const searchEndpoint = server.getDerivedResource({\n    url: \"v1/geocode\",\n  });\n\n  if (defined(accessToken)) {\n    searchEndpoint.appendQueryParameters({ access_token: accessToken });\n  }\n\n  this._accessToken = accessToken;\n  this._server = server;\n  this._pelias = new PeliasGeocoderService(searchEndpoint);\n  // geocoderProviderType isn't stored here directly but instead relies on the\n  // query parameters of this._pelias.url.  Use the setter logic to update value.\n  this.geocodeProviderType = geocodeProviderType;\n}\n\nObject.defineProperties(IonGeocoderService.prototype, {\n  /**\n   * Gets the credit to display after a geocode is performed. Typically this is used to credit\n   * the geocoder service.\n   * @memberof IonGeocoderService.prototype\n   * @type {Credit|undefined}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return undefined;\n    },\n  },\n  /**\n   * The geocoding service that Cesium ion API server should use to fulfill geocding requests.\n   * @memberof IonGeocoderService.prototype\n   * @type {IonGeocodeProviderType}\n   * @default IonGeocodeProviderType.DEFAULT\n   */\n  geocodeProviderType: {\n    get: function () {\n      return queryParameterToProvider(\n        this._pelias.url.queryParameters[\"geocoder\"],\n      );\n    },\n    set: function (geocodeProviderType) {\n      validateIonGeocodeProviderType(geocodeProviderType);\n      const query = {\n        ...this._pelias.url.queryParameters,\n        geocoder: providerToQueryParameter(geocodeProviderType),\n      };\n      // Delete the geocoder parameter to prevent sending &geocoder=undefined in the query\n      if (!defined(query.geocoder)) {\n        delete query.geocoder;\n      }\n      this._pelias.url.setQueryParameters(query);\n    },\n  },\n});\n\n/**\n * @function\n *\n * @param {string} query The query to be sent to the geocoder service\n * @param {GeocodeType} [type=GeocodeType.SEARCH] The type of geocode to perform.\n * @returns {Promise<GeocoderService.Result[]>}\n */\nIonGeocoderService.prototype.geocode = async function (query, geocodeType) {\n  return this._pelias.geocode(query, geocodeType);\n};\nexport default IonGeocoderService;\n"],"names":["validateIonGeocodeProviderType","geocodeProviderType","Object","values","some","value","providerToParameterMap","freeze","GOOGLE","BING","DEFAULT","undefined","providerToQueryParameter","provider","queryParameterToProvider","parameter","entries","find","entry","IonGeocoderService","options","EMPTY_OBJECT","typeOf","object","scene","accessToken","defaultAccessToken","server","createIfNeeded","defaultServer","appendForwardSlash","defaultTokenCredit","getDefaultTokenCredit","frameState","creditDisplay","addStaticCredit","clone","searchEndpoint","getDerivedResource","url","appendQueryParameters","access_token","_accessToken","_server","_pelias","defineProperties","prototype","credit","get","queryParameters","set","query","geocoder","setQueryParameters","geocode","geocodeType"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 61658, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/Intersections2D.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Contains functions for operating on 2D triangles.\n *\n * @namespace Intersections2D\n */\nconst Intersections2D = {};\n\n/**\n * Splits a 2D triangle at given axis-aligned threshold value and returns the resulting\n * polygon on a given side of the threshold.  The resulting polygon may have 0, 1, 2,\n * 3, or 4 vertices.\n *\n * @param {number} threshold The threshold coordinate value at which to clip the triangle.\n * @param {boolean} keepAbove true to keep the portion of the triangle above the threshold, or false\n *                            to keep the portion below.\n * @param {number} u0 The coordinate of the first vertex in the triangle, in counter-clockwise order.\n * @param {number} u1 The coordinate of the second vertex in the triangle, in counter-clockwise order.\n * @param {number} u2 The coordinate of the third vertex in the triangle, in counter-clockwise order.\n * @param {number[]} [result] The array into which to copy the result.  If this parameter is not supplied,\n *                            a new array is constructed and returned.\n * @returns {number[]} The polygon that results after the clip, specified as a list of\n *                     vertices.  The vertices are specified in counter-clockwise order.\n *                     Each vertex is either an index from the existing list (identified as\n *                     a 0, 1, or 2) or -1 indicating a new vertex not in the original triangle.\n *                     For new vertices, the -1 is followed by three additional numbers: the\n *                     index of each of the two original vertices forming the line segment that\n *                     the new vertex lies on, and the fraction of the distance from the first\n *                     vertex to the second one.\n *\n * @example\n * const result = Cesium.Intersections2D.clipTriangleAtAxisAlignedThreshold(0.5, false, 0.2, 0.6, 0.4);\n * // result === [2, 0, -1, 1, 0, 0.25, -1, 1, 2, 0.5]\n */\nIntersections2D.clipTriangleAtAxisAlignedThreshold = function (\n  threshold,\n  keepAbove,\n  u0,\n  u1,\n  u2,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(threshold)) {\n    throw new DeveloperError(\"threshold is required.\");\n  }\n  if (!defined(keepAbove)) {\n    throw new DeveloperError(\"keepAbove is required.\");\n  }\n  if (!defined(u0)) {\n    throw new DeveloperError(\"u0 is required.\");\n  }\n  if (!defined(u1)) {\n    throw new DeveloperError(\"u1 is required.\");\n  }\n  if (!defined(u2)) {\n    throw new DeveloperError(\"u2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  } else {\n    result.length = 0;\n  }\n\n  let u0Behind;\n  let u1Behind;\n  let u2Behind;\n  if (keepAbove) {\n    u0Behind = u0 < threshold;\n    u1Behind = u1 < threshold;\n    u2Behind = u2 < threshold;\n  } else {\n    u0Behind = u0 > threshold;\n    u1Behind = u1 > threshold;\n    u2Behind = u2 > threshold;\n  }\n\n  const numBehind = u0Behind + u1Behind + u2Behind;\n\n  let u01Ratio;\n  let u02Ratio;\n  let u12Ratio;\n  let u10Ratio;\n  let u20Ratio;\n  let u21Ratio;\n\n  if (numBehind === 1) {\n    if (u0Behind) {\n      u01Ratio = (threshold - u0) / (u1 - u0);\n      u02Ratio = (threshold - u0) / (u2 - u0);\n\n      result.push(1);\n\n      result.push(2);\n\n      if (u02Ratio !== 1.0) {\n        result.push(-1);\n        result.push(0);\n        result.push(2);\n        result.push(u02Ratio);\n      }\n\n      if (u01Ratio !== 1.0) {\n        result.push(-1);\n        result.push(0);\n        result.push(1);\n        result.push(u01Ratio);\n      }\n    } else if (u1Behind) {\n      u12Ratio = (threshold - u1) / (u2 - u1);\n      u10Ratio = (threshold - u1) / (u0 - u1);\n\n      result.push(2);\n\n      result.push(0);\n\n      if (u10Ratio !== 1.0) {\n        result.push(-1);\n        result.push(1);\n        result.push(0);\n        result.push(u10Ratio);\n      }\n\n      if (u12Ratio !== 1.0) {\n        result.push(-1);\n        result.push(1);\n        result.push(2);\n        result.push(u12Ratio);\n      }\n    } else if (u2Behind) {\n      u20Ratio = (threshold - u2) / (u0 - u2);\n      u21Ratio = (threshold - u2) / (u1 - u2);\n\n      result.push(0);\n\n      result.push(1);\n\n      if (u21Ratio !== 1.0) {\n        result.push(-1);\n        result.push(2);\n        result.push(1);\n        result.push(u21Ratio);\n      }\n\n      if (u20Ratio !== 1.0) {\n        result.push(-1);\n        result.push(2);\n        result.push(0);\n        result.push(u20Ratio);\n      }\n    }\n  } else if (numBehind === 2) {\n    if (!u0Behind && u0 !== threshold) {\n      u10Ratio = (threshold - u1) / (u0 - u1);\n      u20Ratio = (threshold - u2) / (u0 - u2);\n\n      result.push(0);\n\n      result.push(-1);\n      result.push(1);\n      result.push(0);\n      result.push(u10Ratio);\n\n      result.push(-1);\n      result.push(2);\n      result.push(0);\n      result.push(u20Ratio);\n    } else if (!u1Behind && u1 !== threshold) {\n      u21Ratio = (threshold - u2) / (u1 - u2);\n      u01Ratio = (threshold - u0) / (u1 - u0);\n\n      result.push(1);\n\n      result.push(-1);\n      result.push(2);\n      result.push(1);\n      result.push(u21Ratio);\n\n      result.push(-1);\n      result.push(0);\n      result.push(1);\n      result.push(u01Ratio);\n    } else if (!u2Behind && u2 !== threshold) {\n      u02Ratio = (threshold - u0) / (u2 - u0);\n      u12Ratio = (threshold - u1) / (u2 - u1);\n\n      result.push(2);\n\n      result.push(-1);\n      result.push(0);\n      result.push(2);\n      result.push(u02Ratio);\n\n      result.push(-1);\n      result.push(1);\n      result.push(2);\n      result.push(u12Ratio);\n    }\n  } else if (numBehind !== 3) {\n    // Completely in front of threshold\n    result.push(0);\n    result.push(1);\n    result.push(2);\n  }\n  // else Completely behind threshold\n\n  return result;\n};\n\n/**\n * Compute the barycentric coordinates of a 2D position within a 2D triangle.\n *\n * @param {number} x The x coordinate of the position for which to find the barycentric coordinates.\n * @param {number} y The y coordinate of the position for which to find the barycentric coordinates.\n * @param {number} x1 The x coordinate of the triangle's first vertex.\n * @param {number} y1 The y coordinate of the triangle's first vertex.\n * @param {number} x2 The x coordinate of the triangle's second vertex.\n * @param {number} y2 The y coordinate of the triangle's second vertex.\n * @param {number} x3 The x coordinate of the triangle's third vertex.\n * @param {number} y3 The y coordinate of the triangle's third vertex.\n * @param {Cartesian3} [result] The instance into to which to copy the result.  If this parameter\n *                     is undefined, a new instance is created and returned.\n * @returns {Cartesian3} The barycentric coordinates of the position within the triangle.\n *\n * @example\n * const result = Cesium.Intersections2D.computeBarycentricCoordinates(0.0, 0.0, 0.0, 1.0, -1, -0.5, 1, -0.5);\n * // result === new Cesium.Cartesian3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0);\n */\nIntersections2D.computeBarycentricCoordinates = function (\n  x,\n  y,\n  x1,\n  y1,\n  x2,\n  y2,\n  x3,\n  y3,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(x)) {\n    throw new DeveloperError(\"x is required.\");\n  }\n  if (!defined(y)) {\n    throw new DeveloperError(\"y is required.\");\n  }\n  if (!defined(x1)) {\n    throw new DeveloperError(\"x1 is required.\");\n  }\n  if (!defined(y1)) {\n    throw new DeveloperError(\"y1 is required.\");\n  }\n  if (!defined(x2)) {\n    throw new DeveloperError(\"x2 is required.\");\n  }\n  if (!defined(y2)) {\n    throw new DeveloperError(\"y2 is required.\");\n  }\n  if (!defined(x3)) {\n    throw new DeveloperError(\"x3 is required.\");\n  }\n  if (!defined(y3)) {\n    throw new DeveloperError(\"y3 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const x1mx3 = x1 - x3;\n  const x3mx2 = x3 - x2;\n  const y2my3 = y2 - y3;\n  const y1my3 = y1 - y3;\n  const inverseDeterminant = 1.0 / (y2my3 * x1mx3 + x3mx2 * y1my3);\n  const ymy3 = y - y3;\n  const xmx3 = x - x3;\n  const l1 = (y2my3 * xmx3 + x3mx2 * ymy3) * inverseDeterminant;\n  const l2 = (-y1my3 * xmx3 + x1mx3 * ymy3) * inverseDeterminant;\n  const l3 = 1.0 - l1 - l2;\n\n  if (defined(result)) {\n    result.x = l1;\n    result.y = l2;\n    result.z = l3;\n    return result;\n  }\n  return new Cartesian3(l1, l2, l3);\n};\n\n/**\n * Compute the intersection between 2 line segments\n *\n * @param {number} x00 The x coordinate of the first line's first vertex.\n * @param {number} y00 The y coordinate of the first line's first vertex.\n * @param {number} x01 The x coordinate of the first line's second vertex.\n * @param {number} y01 The y coordinate of the first line's second vertex.\n * @param {number} x10 The x coordinate of the second line's first vertex.\n * @param {number} y10 The y coordinate of the second line's first vertex.\n * @param {number} x11 The x coordinate of the second line's second vertex.\n * @param {number} y11 The y coordinate of the second line's second vertex.\n * @param {Cartesian2} [result] The instance into to which to copy the result. If this parameter\n *                     is undefined, a new instance is created and returned.\n * @returns {Cartesian2} The intersection point, undefined if there is no intersection point or lines are coincident.\n *\n * @example\n * const result = Cesium.Intersections2D.computeLineSegmentLineSegmentIntersection(0.0, 0.0, 0.0, 2.0, -1, 1, 1, 1);\n * // result === new Cesium.Cartesian2(0.0, 1.0);\n */\nIntersections2D.computeLineSegmentLineSegmentIntersection = function (\n  x00,\n  y00,\n  x01,\n  y01,\n  x10,\n  y10,\n  x11,\n  y11,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x00\", x00);\n  Check.typeOf.number(\"y00\", y00);\n  Check.typeOf.number(\"x01\", x01);\n  Check.typeOf.number(\"y01\", y01);\n  Check.typeOf.number(\"x10\", x10);\n  Check.typeOf.number(\"y10\", y10);\n  Check.typeOf.number(\"x11\", x11);\n  Check.typeOf.number(\"y11\", y11);\n  //>>includeEnd('debug');\n\n  const numerator1A = (x11 - x10) * (y00 - y10) - (y11 - y10) * (x00 - x10);\n  const numerator1B = (x01 - x00) * (y00 - y10) - (y01 - y00) * (x00 - x10);\n  const denominator1 = (y11 - y10) * (x01 - x00) - (x11 - x10) * (y01 - y00);\n\n  // If denominator = 0, then lines are parallel. If denominator = 0 and both numerators are 0, then coincident\n  if (denominator1 === 0) {\n    return;\n  }\n\n  const ua1 = numerator1A / denominator1;\n  const ub1 = numerator1B / denominator1;\n\n  if (ua1 >= 0 && ua1 <= 1 && ub1 >= 0 && ub1 <= 1) {\n    if (!defined(result)) {\n      result = new Cartesian2();\n    }\n\n    result.x = x00 + ua1 * (x01 - x00);\n    result.y = y00 + ua1 * (y01 - y00);\n\n    return result;\n  }\n};\nexport default Intersections2D;\n"],"names":["Intersections2D","clipTriangleAtAxisAlignedThreshold","threshold","keepAbove","u0","u1","u2","result","length","u0Behind","u1Behind","u2Behind","numBehind","u01Ratio","u02Ratio","u12Ratio","u10Ratio","u20Ratio","u21Ratio","push","computeBarycentricCoordinates","x","y","x1","y1","x2","y2","x3","y3","x1mx3","x3mx2","y2my3","y1my3","inverseDeterminant","ymy3","xmx3","l1","l2","l3","z","computeLineSegmentLineSegmentIntersection","x00","y00","x01","y01","x10","y10","x11","y11","typeOf","number","numerator1A","numerator1B","denominator1","ua1","ub1"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 61959, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/QuantizedMeshTerrainData.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersections2D from \"./Intersections2D.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\n\n/**\n * Terrain data for a single tile where the terrain data is represented as a quantized mesh.  A quantized\n * mesh consists of three vertex attributes, longitude, latitude, and height.  All attributes are expressed\n * as 16-bit values in the range 0 to 32767.  Longitude and latitude are zero at the southwest corner\n * of the tile and 32767 at the northeast corner.  Height is zero at the minimum height in the tile\n * and 32767 at the maximum height in the tile.\n *\n * @alias QuantizedMeshTerrainData\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Uint16Array} options.quantizedVertices The buffer containing the quantized mesh.\n * @param {Uint16Array|Uint32Array} options.indices The indices specifying how the quantized vertices are linked\n *                      together into triangles.  Each three indices specifies one triangle.\n * @param {number} options.minimumHeight The minimum terrain height within the tile, in meters above the ellipsoid.\n * @param {number} options.maximumHeight The maximum terrain height within the tile, in meters above the ellipsoid.\n * @param {BoundingSphere} options.boundingSphere A sphere bounding all of the vertices in the mesh.\n * @param {OrientedBoundingBox} [options.orientedBoundingBox] An OrientedBoundingBox bounding all of the vertices in the mesh.\n * @param {Cartesian3} options.horizonOcclusionPoint The horizon occlusion point of the mesh.  If this point\n *                      is below the horizon, the entire tile is assumed to be below the horizon as well.\n *                      The point is expressed in ellipsoid-scaled coordinates.\n * @param {number[]} options.westIndices The indices of the vertices on the western edge of the tile.\n * @param {number[]} options.southIndices The indices of the vertices on the southern edge of the tile.\n * @param {number[]} options.eastIndices The indices of the vertices on the eastern edge of the tile.\n * @param {number[]} options.northIndices The indices of the vertices on the northern edge of the tile.\n * @param {number} options.westSkirtHeight The height of the skirt to add on the western edge of the tile.\n * @param {number} options.southSkirtHeight The height of the skirt to add on the southern edge of the tile.\n * @param {number} options.eastSkirtHeight The height of the skirt to add on the eastern edge of the tile.\n * @param {number} options.northSkirtHeight The height of the skirt to add on the northern edge of the tile.\n * @param {number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n * @param {Uint8Array} [options.encodedNormals] The buffer containing per vertex normals, encoded using 'oct' encoding\n * @param {Uint8Array} [options.waterMask] The buffer containing the watermask.\n * @param {Credit[]} [options.credits] Array of credits for this tile.\n *\n *\n * @example\n * const data = new Cesium.QuantizedMeshTerrainData({\n *     minimumHeight : -100,\n *     maximumHeight : 2101,\n *     quantizedVertices : new Uint16Array([// order is SW NW SE NE\n *                                          // longitude\n *                                          0, 0, 32767, 32767,\n *                                          // latitude\n *                                          0, 32767, 0, 32767,\n *                                          // heights\n *                                          16384, 0, 32767, 16384]),\n *     indices : new Uint16Array([0, 3, 1,\n *                                0, 2, 3]),\n *     boundingSphere : new Cesium.BoundingSphere(new Cesium.Cartesian3(1.0, 2.0, 3.0), 10000),\n *     orientedBoundingBox : new Cesium.OrientedBoundingBox(new Cesium.Cartesian3(1.0, 2.0, 3.0), Cesium.Matrix3.fromRotationX(Cesium.Math.PI, new Cesium.Matrix3())),\n *     horizonOcclusionPoint : new Cesium.Cartesian3(3.0, 2.0, 1.0),\n *     westIndices : [0, 1],\n *     southIndices : [0, 1],\n *     eastIndices : [2, 3],\n *     northIndices : [1, 3],\n *     westSkirtHeight : 1.0,\n *     southSkirtHeight : 1.0,\n *     eastSkirtHeight : 1.0,\n *     northSkirtHeight : 1.0\n * });\n *\n * @see TerrainData\n * @see HeightmapTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\nfunction QuantizedMeshTerrainData(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug)\n  Check.typeOf.object(\"options.quantizedVertices\", options.quantizedVertices);\n  Check.typeOf.object(\"options.indices\", options.indices);\n  Check.typeOf.number(\"options.minimumHeight\", options.minimumHeight);\n  Check.typeOf.number(\"options.maximumHeight\", options.maximumHeight);\n  Check.typeOf.object(\"options.boundingSphere\", options.boundingSphere);\n  Check.typeOf.object(\n    \"options.horizonOcclusionPoint\",\n    options.horizonOcclusionPoint,\n  );\n  Check.typeOf.object(\"options.westIndices\", options.westIndices);\n  Check.typeOf.object(\"options.southIndices\", options.southIndices);\n  Check.typeOf.object(\"options.eastIndices\", options.eastIndices);\n  Check.typeOf.object(\"options.northIndices\", options.northIndices);\n  Check.typeOf.number(\"options.westSkirtHeight\", options.westSkirtHeight);\n  Check.typeOf.number(\"options.southSkirtHeight\", options.southSkirtHeight);\n  Check.typeOf.number(\"options.eastSkirtHeight\", options.eastSkirtHeight);\n  Check.typeOf.number(\"options.northSkirtHeight\", options.northSkirtHeight);\n  //>>includeEnd('debug');\n\n  this._quantizedVertices = options.quantizedVertices;\n  this._encodedNormals = options.encodedNormals;\n  this._indices = options.indices;\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._boundingSphere = options.boundingSphere;\n  this._orientedBoundingBox = options.orientedBoundingBox;\n  this._horizonOcclusionPoint = options.horizonOcclusionPoint;\n  this._credits = options.credits;\n\n  const vertexCount = this._quantizedVertices.length / 3;\n  const uValues = (this._uValues = this._quantizedVertices.subarray(\n    0,\n    vertexCount,\n  ));\n  const vValues = (this._vValues = this._quantizedVertices.subarray(\n    vertexCount,\n    2 * vertexCount,\n  ));\n  this._heightValues = this._quantizedVertices.subarray(\n    2 * vertexCount,\n    3 * vertexCount,\n  );\n\n  // We don't assume that we can count on the edge vertices being sorted by u or v.\n  function sortByV(a, b) {\n    return vValues[a] - vValues[b];\n  }\n\n  function sortByU(a, b) {\n    return uValues[a] - uValues[b];\n  }\n\n  this._westIndices = sortIndicesIfNecessary(\n    options.westIndices,\n    sortByV,\n    vertexCount,\n  );\n  this._southIndices = sortIndicesIfNecessary(\n    options.southIndices,\n    sortByU,\n    vertexCount,\n  );\n  this._eastIndices = sortIndicesIfNecessary(\n    options.eastIndices,\n    sortByV,\n    vertexCount,\n  );\n  this._northIndices = sortIndicesIfNecessary(\n    options.northIndices,\n    sortByU,\n    vertexCount,\n  );\n\n  this._westSkirtHeight = options.westSkirtHeight;\n  this._southSkirtHeight = options.southSkirtHeight;\n  this._eastSkirtHeight = options.eastSkirtHeight;\n  this._northSkirtHeight = options.northSkirtHeight;\n\n  this._childTileMask = options.childTileMask ?? 15;\n\n  this._createdByUpsampling = options.createdByUpsampling ?? false;\n  this._waterMask = options.waterMask;\n\n  this._mesh = undefined;\n}\n\nObject.defineProperties(QuantizedMeshTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof QuantizedMeshTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return this._credits;\n    },\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof QuantizedMeshTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement|undefined}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    },\n  },\n\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    },\n  },\n\n  canUpsample: {\n    get: function () {\n      return defined(this._mesh);\n    },\n  },\n});\n\nconst arrayScratch = [];\n\nfunction sortIndicesIfNecessary(indices, sortFunction, vertexCount) {\n  arrayScratch.length = indices.length;\n\n  let needsSort = false;\n  for (let i = 0, len = indices.length; i < len; ++i) {\n    arrayScratch[i] = indices[i];\n    needsSort =\n      needsSort || (i > 0 && sortFunction(indices[i - 1], indices[i]) > 0);\n  }\n\n  if (needsSort) {\n    arrayScratch.sort(sortFunction);\n    return IndexDatatype.createTypedArray(vertexCount, arrayScratch);\n  }\n  return indices;\n}\n\nconst createMeshTaskName = \"createVerticesFromQuantizedTerrainMesh\";\nconst createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nconst createMeshTaskProcessorThrottle = new TaskProcessor(\n  createMeshTaskName,\n  TerrainData.maximumAsynchronousTasks,\n);\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {number} options.level The level of the tile for which to create the terrain data.\n * @param {number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {number} [options.exaggerationRelativeHeight=0.0] The height relative to which terrain is exaggerated.\n * @param {boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nQuantizedMeshTerrainData.prototype.createMesh = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  const tilingScheme = options.tilingScheme;\n  const x = options.x;\n  const y = options.y;\n  const level = options.level;\n  const exaggeration = options.exaggeration ?? 1.0;\n  const exaggerationRelativeHeight = options.exaggerationRelativeHeight ?? 0.0;\n  const throttle = options.throttle ?? true;\n\n  const ellipsoid = tilingScheme.ellipsoid;\n  const rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  const createMeshTaskProcessor = throttle\n    ? createMeshTaskProcessorThrottle\n    : createMeshTaskProcessorNoThrottle;\n\n  const verticesPromise = createMeshTaskProcessor.scheduleTask({\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    quantizedVertices: this._quantizedVertices,\n    octEncodedNormals: this._encodedNormals,\n    includeWebMercatorT: true,\n    indices: this._indices,\n    westIndices: this._westIndices,\n    southIndices: this._southIndices,\n    eastIndices: this._eastIndices,\n    northIndices: this._northIndices,\n    westSkirtHeight: this._westSkirtHeight,\n    southSkirtHeight: this._southSkirtHeight,\n    eastSkirtHeight: this._eastSkirtHeight,\n    northSkirtHeight: this._northSkirtHeight,\n    rectangle: rectangle,\n    relativeToCenter: this._boundingSphere.center,\n    ellipsoid: ellipsoid,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight,\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  const that = this;\n  return Promise.resolve(verticesPromise).then(function (result) {\n    const vertexCountWithoutSkirts = that._quantizedVertices.length / 3;\n    const vertexCount =\n      vertexCountWithoutSkirts +\n      that._westIndices.length +\n      that._southIndices.length +\n      that._eastIndices.length +\n      that._northIndices.length;\n    const indicesTypedArray = IndexDatatype.createTypedArray(\n      vertexCount,\n      result.indices,\n    );\n\n    const vertices = new Float32Array(result.vertices);\n    const rtc = result.center;\n    const minimumHeight = result.minimumHeight;\n    const maximumHeight = result.maximumHeight;\n    const boundingSphere = that._boundingSphere;\n    const obb = that._orientedBoundingBox;\n    const occludeePointInScaledSpace =\n      Cartesian3.clone(result.occludeePointInScaledSpace) ??\n      that._horizonOcclusionPoint;\n    const stride = result.vertexStride;\n    const terrainEncoding = TerrainEncoding.clone(result.encoding);\n\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(\n      rtc,\n      vertices,\n      indicesTypedArray,\n      result.indexCountWithoutSkirts,\n      vertexCountWithoutSkirts,\n      minimumHeight,\n      maximumHeight,\n      rectangle,\n      boundingSphere,\n      occludeePointInScaledSpace,\n      stride,\n      obb,\n      terrainEncoding,\n      result.westIndicesSouthToNorth,\n      result.southIndicesEastToWest,\n      result.eastIndicesNorthToSouth,\n      result.northIndicesWestToEast,\n    );\n\n    // Free memory received from server after mesh is created.\n    that._quantizedVertices = undefined;\n    that._encodedNormals = undefined;\n    that._indices = undefined;\n\n    that._uValues = undefined;\n    that._vValues = undefined;\n    that._heightValues = undefined;\n\n    that._westIndices = undefined;\n    that._southIndices = undefined;\n    that._eastIndices = undefined;\n    that._northIndices = undefined;\n\n    return that._mesh;\n  });\n};\n\nconst upsampleTaskProcessor = new TaskProcessor(\n  \"upsampleQuantizedTerrainMesh\",\n  TerrainData.maximumAsynchronousTasks,\n);\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * vertices in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {number} thisLevel The level of this tile in the tiling scheme.\n * @param {number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise<QuantizedMeshTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\nQuantizedMeshTerrainData.prototype.upsample = function (\n  tilingScheme,\n  thisX,\n  thisY,\n  thisLevel,\n  descendantX,\n  descendantY,\n  descendantLevel,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(thisLevel)) {\n    throw new DeveloperError(\"thisLevel is required.\");\n  }\n  if (!defined(descendantX)) {\n    throw new DeveloperError(\"descendantX is required.\");\n  }\n  if (!defined(descendantY)) {\n    throw new DeveloperError(\"descendantY is required.\");\n  }\n  if (!defined(descendantLevel)) {\n    throw new DeveloperError(\"descendantLevel is required.\");\n  }\n  const levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\n      \"Upsampling through more than one level at a time is not currently supported.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const mesh = this._mesh;\n  if (!defined(this._mesh)) {\n    return undefined;\n  }\n\n  const isEastChild = thisX * 2 !== descendantX;\n  const isNorthChild = thisY * 2 === descendantY;\n\n  const ellipsoid = tilingScheme.ellipsoid;\n  const childRectangle = tilingScheme.tileXYToRectangle(\n    descendantX,\n    descendantY,\n    descendantLevel,\n  );\n\n  const upsamplePromise = upsampleTaskProcessor.scheduleTask({\n    vertices: mesh.vertices,\n    vertexCountWithoutSkirts: mesh.vertexCountWithoutSkirts,\n    indices: mesh.indices,\n    indexCountWithoutSkirts: mesh.indexCountWithoutSkirts,\n    encoding: mesh.encoding,\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    isEastChild: isEastChild,\n    isNorthChild: isNorthChild,\n    childRectangle: childRectangle,\n    ellipsoid: ellipsoid,\n  });\n\n  if (!defined(upsamplePromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  let shortestSkirt = Math.min(this._westSkirtHeight, this._eastSkirtHeight);\n  shortestSkirt = Math.min(shortestSkirt, this._southSkirtHeight);\n  shortestSkirt = Math.min(shortestSkirt, this._northSkirtHeight);\n\n  const westSkirtHeight = isEastChild\n    ? shortestSkirt * 0.5\n    : this._westSkirtHeight;\n  const southSkirtHeight = isNorthChild\n    ? shortestSkirt * 0.5\n    : this._southSkirtHeight;\n  const eastSkirtHeight = isEastChild\n    ? this._eastSkirtHeight\n    : shortestSkirt * 0.5;\n  const northSkirtHeight = isNorthChild\n    ? this._northSkirtHeight\n    : shortestSkirt * 0.5;\n  const credits = this._credits;\n\n  return Promise.resolve(upsamplePromise).then(function (result) {\n    const quantizedVertices = new Uint16Array(result.vertices);\n    const indicesTypedArray = IndexDatatype.createTypedArray(\n      quantizedVertices.length / 3,\n      result.indices,\n    );\n    let encodedNormals;\n    if (defined(result.encodedNormals)) {\n      encodedNormals = new Uint8Array(result.encodedNormals);\n    }\n\n    return new QuantizedMeshTerrainData({\n      quantizedVertices: quantizedVertices,\n      indices: indicesTypedArray,\n      encodedNormals: encodedNormals,\n      minimumHeight: result.minimumHeight,\n      maximumHeight: result.maximumHeight,\n      boundingSphere: BoundingSphere.clone(result.boundingSphere),\n      orientedBoundingBox: OrientedBoundingBox.clone(\n        result.orientedBoundingBox,\n      ),\n      horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),\n      westIndices: result.westIndices,\n      southIndices: result.southIndices,\n      eastIndices: result.eastIndices,\n      northIndices: result.northIndices,\n      westSkirtHeight: westSkirtHeight,\n      southSkirtHeight: southSkirtHeight,\n      eastSkirtHeight: eastSkirtHeight,\n      northSkirtHeight: northSkirtHeight,\n      childTileMask: 0,\n      credits: credits,\n      createdByUpsampling: true,\n    });\n  });\n};\n\nconst maxShort = 32767;\nconst barycentricCoordinateScratch = new Cartesian3();\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {number} longitude The longitude in radians.\n * @param {number} latitude The latitude in radians.\n * @returns {number} The terrain height at the specified position.  The position is clamped to\n *          the rectangle, so expect incorrect results for positions far outside the rectangle.\n */\nQuantizedMeshTerrainData.prototype.interpolateHeight = function (\n  rectangle,\n  longitude,\n  latitude,\n) {\n  let u = CesiumMath.clamp(\n    (longitude - rectangle.west) / rectangle.width,\n    0.0,\n    1.0,\n  );\n  u *= maxShort;\n  let v = CesiumMath.clamp(\n    (latitude - rectangle.south) / rectangle.height,\n    0.0,\n    1.0,\n  );\n  v *= maxShort;\n\n  if (!defined(this._mesh)) {\n    return interpolateHeight(this, u, v);\n  }\n\n  return interpolateMeshHeight(this, u, v);\n};\n\nfunction pointInBoundingBox(u, v, u0, v0, u1, v1, u2, v2) {\n  const minU = Math.min(u0, u1, u2);\n  const maxU = Math.max(u0, u1, u2);\n  const minV = Math.min(v0, v1, v2);\n  const maxV = Math.max(v0, v1, v2);\n  return u >= minU && u <= maxU && v >= minV && v <= maxV;\n}\n\nconst texCoordScratch0 = new Cartesian2();\nconst texCoordScratch1 = new Cartesian2();\nconst texCoordScratch2 = new Cartesian2();\n\nfunction interpolateMeshHeight(terrainData, u, v) {\n  const mesh = terrainData._mesh;\n  const vertices = mesh.vertices;\n  const encoding = mesh.encoding;\n  const indices = mesh.indices;\n\n  for (let i = 0, len = indices.length; i < len; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n\n    const uv0 = encoding.decodeTextureCoordinates(\n      vertices,\n      i0,\n      texCoordScratch0,\n    );\n    const uv1 = encoding.decodeTextureCoordinates(\n      vertices,\n      i1,\n      texCoordScratch1,\n    );\n    const uv2 = encoding.decodeTextureCoordinates(\n      vertices,\n      i2,\n      texCoordScratch2,\n    );\n\n    if (pointInBoundingBox(u, v, uv0.x, uv0.y, uv1.x, uv1.y, uv2.x, uv2.y)) {\n      const barycentric = Intersections2D.computeBarycentricCoordinates(\n        u,\n        v,\n        uv0.x,\n        uv0.y,\n        uv1.x,\n        uv1.y,\n        uv2.x,\n        uv2.y,\n        barycentricCoordinateScratch,\n      );\n      if (\n        barycentric.x >= -1e-15 &&\n        barycentric.y >= -1e-15 &&\n        barycentric.z >= -1e-15\n      ) {\n        const h0 = encoding.decodeHeight(vertices, i0);\n        const h1 = encoding.decodeHeight(vertices, i1);\n        const h2 = encoding.decodeHeight(vertices, i2);\n        return barycentric.x * h0 + barycentric.y * h1 + barycentric.z * h2;\n      }\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\n\nfunction interpolateHeight(terrainData, u, v) {\n  const uBuffer = terrainData._uValues;\n  const vBuffer = terrainData._vValues;\n  const heightBuffer = terrainData._heightValues;\n\n  const indices = terrainData._indices;\n  for (let i = 0, len = indices.length; i < len; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n\n    const u0 = uBuffer[i0];\n    const u1 = uBuffer[i1];\n    const u2 = uBuffer[i2];\n\n    const v0 = vBuffer[i0];\n    const v1 = vBuffer[i1];\n    const v2 = vBuffer[i2];\n\n    if (pointInBoundingBox(u, v, u0, v0, u1, v1, u2, v2)) {\n      const barycentric = Intersections2D.computeBarycentricCoordinates(\n        u,\n        v,\n        u0,\n        v0,\n        u1,\n        v1,\n        u2,\n        v2,\n        barycentricCoordinateScratch,\n      );\n      if (\n        barycentric.x >= -1e-15 &&\n        barycentric.y >= -1e-15 &&\n        barycentric.z >= -1e-15\n      ) {\n        const quantizedHeight =\n          barycentric.x * heightBuffer[i0] +\n          barycentric.y * heightBuffer[i1] +\n          barycentric.z * heightBuffer[i2];\n        return CesiumMath.lerp(\n          terrainData._minimumHeight,\n          terrainData._maximumHeight,\n          quantizedHeight / maxShort,\n        );\n      }\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link QuantizedMeshTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {number} thisX The tile X coordinate of this (the parent) tile.\n * @param {number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {number} childX The tile X coordinate of the child tile to check for availability.\n * @param {number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {boolean} True if the child tile is available; otherwise, false.\n */\nQuantizedMeshTerrainData.prototype.isChildAvailable = function (\n  thisX,\n  thisY,\n  childX,\n  childY,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"thisX\", thisX);\n  Check.typeOf.number(\"thisY\", thisY);\n  Check.typeOf.number(\"childX\", childX);\n  Check.typeOf.number(\"childY\", childY);\n  //>>includeEnd('debug');\n\n  let bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & (1 << bitNumber)) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {boolean} True if this instance was created by upsampling; otherwise, false.\n */\nQuantizedMeshTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\nexport default QuantizedMeshTerrainData;\n"],"names":["QuantizedMeshTerrainData","options","EMPTY_OBJECT","typeOf","object","quantizedVertices","indices","number","minimumHeight","maximumHeight","boundingSphere","horizonOcclusionPoint","westIndices","southIndices","eastIndices","northIndices","westSkirtHeight","southSkirtHeight","eastSkirtHeight","northSkirtHeight","_quantizedVertices","_encodedNormals","encodedNormals","_indices","_minimumHeight","_maximumHeight","_boundingSphere","_orientedBoundingBox","orientedBoundingBox","_horizonOcclusionPoint","_credits","credits","vertexCount","length","uValues","_uValues","subarray","vValues","_vValues","_heightValues","sortByV","a","b","sortByU","_westIndices","sortIndicesIfNecessary","_southIndices","_eastIndices","_northIndices","_westSkirtHeight","_southSkirtHeight","_eastSkirtHeight","_northSkirtHeight","_childTileMask","childTileMask","_createdByUpsampling","createdByUpsampling","_waterMask","waterMask","_mesh","undefined","Object","defineProperties","prototype","get","canUpsample","arrayScratch","sortFunction","needsSort","i","len","sort","createTypedArray","createMeshTaskName","createMeshTaskProcessorNoThrottle","createMeshTaskProcessorThrottle","maximumAsynchronousTasks","createMesh","tilingScheme","x","y","level","exaggeration","exaggerationRelativeHeight","throttle","ellipsoid","rectangle","tileXYToRectangle","createMeshTaskProcessor","verticesPromise","scheduleTask","octEncodedNormals","includeWebMercatorT","relativeToCenter","center","that","Promise","resolve","then","result","vertexCountWithoutSkirts","indicesTypedArray","vertices","Float32Array","rtc","obb","occludeePointInScaledSpace","clone","stride","vertexStride","terrainEncoding","encoding","indexCountWithoutSkirts","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","upsampleTaskProcessor","upsample","thisX","thisY","thisLevel","descendantX","descendantY","descendantLevel","levelDifference","mesh","isEastChild","isNorthChild","childRectangle","upsamplePromise","shortestSkirt","Math","min","Uint16Array","Uint8Array","maxShort","barycentricCoordinateScratch","interpolateHeight","longitude","latitude","u","clamp","west","width","v","south","height","interpolateMeshHeight","pointInBoundingBox","u0","v0","u1","v1","u2","v2","minU","maxU","max","minV","maxV","texCoordScratch0","texCoordScratch1","texCoordScratch2","terrainData","i0","i1","i2","uv0","decodeTextureCoordinates","uv1","uv2","barycentric","computeBarycentricCoordinates","z","h0","decodeHeight","h1","h2","uBuffer","vBuffer","heightBuffer","quantizedHeight","lerp","isChildAvailable","childX","childY","bitNumber","wasCreatedByUpsampling"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4EC,GACD,SAASA,yBAAyBC,OAAO;IACvCA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC,wCAAwC;IACxC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,6BAA6BH,QAAQI,iBAAiB;IAC1E,2KAAK,CAACF,MAAM,CAACC,MAAM,CAAC,mBAAmBH,QAAQK,OAAO;IACtD,2KAAK,CAACH,MAAM,CAACI,MAAM,CAAC,yBAAyBN,QAAQO,aAAa;IAClE,2KAAK,CAACL,MAAM,CAACI,MAAM,CAAC,yBAAyBN,QAAQQ,aAAa;IAClE,2KAAK,CAACN,MAAM,CAACC,MAAM,CAAC,0BAA0BH,QAAQS,cAAc;IACpE,2KAAK,CAACP,MAAM,CAACC,MAAM,CACjB,iCACAH,QAAQU,qBAAqB;IAE/B,2KAAK,CAACR,MAAM,CAACC,MAAM,CAAC,uBAAuBH,QAAQW,WAAW;IAC9D,2KAAK,CAACT,MAAM,CAACC,MAAM,CAAC,wBAAwBH,QAAQY,YAAY;IAChE,2KAAK,CAACV,MAAM,CAACC,MAAM,CAAC,uBAAuBH,QAAQa,WAAW;IAC9D,2KAAK,CAACX,MAAM,CAACC,MAAM,CAAC,wBAAwBH,QAAQc,YAAY;IAChE,2KAAK,CAACZ,MAAM,CAACI,MAAM,CAAC,2BAA2BN,QAAQe,eAAe;IACtE,2KAAK,CAACb,MAAM,CAACI,MAAM,CAAC,4BAA4BN,QAAQgB,gBAAgB;IACxE,2KAAK,CAACd,MAAM,CAACI,MAAM,CAAC,2BAA2BN,QAAQiB,eAAe;IACtE,2KAAK,CAACf,MAAM,CAACI,MAAM,CAAC,4BAA4BN,QAAQkB,gBAAgB;IACxE,wBAAwB;IAExB,IAAI,CAACC,kBAAkB,GAAGnB,QAAQI,iBAAiB;IACnD,IAAI,CAACgB,eAAe,GAAGpB,QAAQqB,cAAc;IAC7C,IAAI,CAACC,QAAQ,GAAGtB,QAAQK,OAAO;IAC/B,IAAI,CAACkB,cAAc,GAAGvB,QAAQO,aAAa;IAC3C,IAAI,CAACiB,cAAc,GAAGxB,QAAQQ,aAAa;IAC3C,IAAI,CAACiB,eAAe,GAAGzB,QAAQS,cAAc;IAC7C,IAAI,CAACiB,oBAAoB,GAAG1B,QAAQ2B,mBAAmB;IACvD,IAAI,CAACC,sBAAsB,GAAG5B,QAAQU,qBAAqB;IAC3D,IAAI,CAACmB,QAAQ,GAAG7B,QAAQ8B,OAAO;IAE/B,MAAMC,cAAc,IAAI,CAACZ,kBAAkB,CAACa,MAAM,GAAG;IACrD,MAAMC,UAAW,IAAI,CAACC,QAAQ,GAAG,IAAI,CAACf,kBAAkB,CAACgB,QAAQ,CAC/D,GACAJ;IAEF,MAAMK,UAAW,IAAI,CAACC,QAAQ,GAAG,IAAI,CAAClB,kBAAkB,CAACgB,QAAQ,CAC/DJ,aACA,IAAIA;IAEN,IAAI,CAACO,aAAa,GAAG,IAAI,CAACnB,kBAAkB,CAACgB,QAAQ,CACnD,IAAIJ,aACJ,IAAIA;IAGN,iFAAiF;IACjF,SAASQ,QAAQC,CAAC,EAAEC,CAAC;QACnB,OAAOL,OAAO,CAACI,EAAE,GAAGJ,OAAO,CAACK,EAAE;IAChC;IAEA,SAASC,QAAQF,CAAC,EAAEC,CAAC;QACnB,OAAOR,OAAO,CAACO,EAAE,GAAGP,OAAO,CAACQ,EAAE;IAChC;IAEA,IAAI,CAACE,YAAY,GAAGC,uBAClB5C,QAAQW,WAAW,EACnB4B,SACAR;IAEF,IAAI,CAACc,aAAa,GAAGD,uBACnB5C,QAAQY,YAAY,EACpB8B,SACAX;IAEF,IAAI,CAACe,YAAY,GAAGF,uBAClB5C,QAAQa,WAAW,EACnB0B,SACAR;IAEF,IAAI,CAACgB,aAAa,GAAGH,uBACnB5C,QAAQc,YAAY,EACpB4B,SACAX;IAGF,IAAI,CAACiB,gBAAgB,GAAGhD,QAAQe,eAAe;IAC/C,IAAI,CAACkC,iBAAiB,GAAGjD,QAAQgB,gBAAgB;IACjD,IAAI,CAACkC,gBAAgB,GAAGlD,QAAQiB,eAAe;IAC/C,IAAI,CAACkC,iBAAiB,GAAGnD,QAAQkB,gBAAgB;IAEjD,IAAI,CAACkC,cAAc,GAAGpD,QAAQqD,aAAa,IAAI;IAE/C,IAAI,CAACC,oBAAoB,GAAGtD,QAAQuD,mBAAmB,IAAI;IAC3D,IAAI,CAACC,UAAU,GAAGxD,QAAQyD,SAAS;IAEnC,IAAI,CAACC,KAAK,GAAGC;AACf;AAEAC,OAAOC,gBAAgB,CAAC9D,yBAAyB+D,SAAS,EAAE;IAC1D;;;;GAIC,GACDhC,SAAS;QACPiC,KAAK;YACH,OAAO,IAAI,CAAClC,QAAQ;QACtB;IACF;IACA;;;;;;GAMC,GACD4B,WAAW;QACTM,KAAK;YACH,OAAO,IAAI,CAACP,UAAU;QACxB;IACF;IAEAH,eAAe;QACbU,KAAK;YACH,OAAO,IAAI,CAACX,cAAc;QAC5B;IACF;IAEAY,aAAa;QACXD,KAAK;YACH,OAAO,IAAA,6KAAO,EAAC,IAAI,CAACL,KAAK;QAC3B;IACF;AACF;AAEA,MAAMO,eAAe,EAAE;AAEvB,SAASrB,uBAAuBvC,OAAO,EAAE6D,YAAY,EAAEnC,WAAW;IAChEkC,aAAajC,MAAM,GAAG3B,QAAQ2B,MAAM;IAEpC,IAAImC,YAAY;IAChB,IAAK,IAAIC,IAAI,GAAGC,MAAMhE,QAAQ2B,MAAM,EAAEoC,IAAIC,KAAK,EAAED,EAAG;QAClDH,YAAY,CAACG,EAAE,GAAG/D,OAAO,CAAC+D,EAAE;QAC5BD,YACEA,aAAcC,IAAI,KAAKF,aAAa7D,OAAO,CAAC+D,IAAI,EAAE,EAAE/D,OAAO,CAAC+D,EAAE,IAAI;IACtE;IAEA,IAAID,WAAW;QACbF,aAAaK,IAAI,CAACJ;QAClB,OAAO,mLAAa,CAACK,gBAAgB,CAACxC,aAAakC;IACrD;IACA,OAAO5D;AACT;AAEA,MAAMmE,qBAAqB;AAC3B,MAAMC,oCAAoC,IAAI,mLAAa,CAACD;AAC5D,MAAME,kCAAkC,IAAI,mLAAa,CACvDF,oBACA,iLAAW,CAACG,wBAAwB;AAGtC;;;;;;;;;;;;;;;;CAgBC,GACD5E,yBAAyB+D,SAAS,CAACc,UAAU,GAAG,SAAU5E,OAAO;IAC/DA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC,yCAAyC;IACzC,2KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,wBAAwBH,QAAQ6E,YAAY;IAChE,2KAAK,CAAC3E,MAAM,CAACI,MAAM,CAAC,aAAaN,QAAQ8E,CAAC;IAC1C,2KAAK,CAAC5E,MAAM,CAACI,MAAM,CAAC,aAAaN,QAAQ+E,CAAC;IAC1C,2KAAK,CAAC7E,MAAM,CAACI,MAAM,CAAC,iBAAiBN,QAAQgF,KAAK;IAClD,wBAAwB;IAExB,MAAMH,eAAe7E,QAAQ6E,YAAY;IACzC,MAAMC,IAAI9E,QAAQ8E,CAAC;IACnB,MAAMC,IAAI/E,QAAQ+E,CAAC;IACnB,MAAMC,QAAQhF,QAAQgF,KAAK;IAC3B,MAAMC,eAAejF,QAAQiF,YAAY,IAAI;IAC7C,MAAMC,6BAA6BlF,QAAQkF,0BAA0B,IAAI;IACzE,MAAMC,WAAWnF,QAAQmF,QAAQ,IAAI;IAErC,MAAMC,YAAYP,aAAaO,SAAS;IACxC,MAAMC,YAAYR,aAAaS,iBAAiB,CAACR,GAAGC,GAAGC;IAEvD,MAAMO,0BAA0BJ,WAC5BT,kCACAD;IAEJ,MAAMe,kBAAkBD,wBAAwBE,YAAY,CAAC;QAC3DlF,eAAe,IAAI,CAACgB,cAAc;QAClCf,eAAe,IAAI,CAACgB,cAAc;QAClCpB,mBAAmB,IAAI,CAACe,kBAAkB;QAC1CuE,mBAAmB,IAAI,CAACtE,eAAe;QACvCuE,qBAAqB;QACrBtF,SAAS,IAAI,CAACiB,QAAQ;QACtBX,aAAa,IAAI,CAACgC,YAAY;QAC9B/B,cAAc,IAAI,CAACiC,aAAa;QAChChC,aAAa,IAAI,CAACiC,YAAY;QAC9BhC,cAAc,IAAI,CAACiC,aAAa;QAChChC,iBAAiB,IAAI,CAACiC,gBAAgB;QACtChC,kBAAkB,IAAI,CAACiC,iBAAiB;QACxChC,iBAAiB,IAAI,CAACiC,gBAAgB;QACtChC,kBAAkB,IAAI,CAACiC,iBAAiB;QACxCkC,WAAWA;QACXO,kBAAkB,IAAI,CAACnE,eAAe,CAACoE,MAAM;QAC7CT,WAAWA;QACXH,cAAcA;QACdC,4BAA4BA;IAC9B;IAEA,IAAI,CAAC,IAAA,6KAAO,EAACM,kBAAkB;QAC7B,YAAY;QACZ,OAAO7B;IACT;IAEA,MAAMmC,OAAO,IAAI;IACjB,OAAOC,QAAQC,OAAO,CAACR,iBAAiBS,IAAI,CAAC,SAAUC,MAAM;QAC3D,MAAMC,2BAA2BL,KAAK3E,kBAAkB,CAACa,MAAM,GAAG;QAClE,MAAMD,cACJoE,2BACAL,KAAKnD,YAAY,CAACX,MAAM,GACxB8D,KAAKjD,aAAa,CAACb,MAAM,GACzB8D,KAAKhD,YAAY,CAACd,MAAM,GACxB8D,KAAK/C,aAAa,CAACf,MAAM;QAC3B,MAAMoE,oBAAoB,mLAAa,CAAC7B,gBAAgB,CACtDxC,aACAmE,OAAO7F,OAAO;QAGhB,MAAMgG,WAAW,IAAIC,aAAaJ,OAAOG,QAAQ;QACjD,MAAME,MAAML,OAAOL,MAAM;QACzB,MAAMtF,gBAAgB2F,OAAO3F,aAAa;QAC1C,MAAMC,gBAAgB0F,OAAO1F,aAAa;QAC1C,MAAMC,iBAAiBqF,KAAKrE,eAAe;QAC3C,MAAM+E,MAAMV,KAAKpE,oBAAoB;QACrC,MAAM+E,6BACJ,gLAAU,CAACC,KAAK,CAACR,OAAOO,0BAA0B,KAClDX,KAAKlE,sBAAsB;QAC7B,MAAM+E,SAAST,OAAOU,YAAY;QAClC,MAAMC,kBAAkB,qLAAe,CAACH,KAAK,CAACR,OAAOY,QAAQ;QAE7D,wEAAwE;QACxE,gDAAgD;QAChDhB,KAAKpC,KAAK,GAAG,IAAI,iLAAW,CAC1B6C,KACAF,UACAD,mBACAF,OAAOa,uBAAuB,EAC9BZ,0BACA5F,eACAC,eACA6E,WACA5E,gBACAgG,4BACAE,QACAH,KACAK,iBACAX,OAAOc,uBAAuB,EAC9Bd,OAAOe,sBAAsB,EAC7Bf,OAAOgB,uBAAuB,EAC9BhB,OAAOiB,sBAAsB;QAG/B,0DAA0D;QAC1DrB,KAAK3E,kBAAkB,GAAGwC;QAC1BmC,KAAK1E,eAAe,GAAGuC;QACvBmC,KAAKxE,QAAQ,GAAGqC;QAEhBmC,KAAK5D,QAAQ,GAAGyB;QAChBmC,KAAKzD,QAAQ,GAAGsB;QAChBmC,KAAKxD,aAAa,GAAGqB;QAErBmC,KAAKnD,YAAY,GAAGgB;QACpBmC,KAAKjD,aAAa,GAAGc;QACrBmC,KAAKhD,YAAY,GAAGa;QACpBmC,KAAK/C,aAAa,GAAGY;QAErB,OAAOmC,KAAKpC,KAAK;IACnB;AACF;AAEA,MAAM0D,wBAAwB,IAAI,mLAAa,CAC7C,gCACA,iLAAW,CAACzC,wBAAwB;AAGtC;;;;;;;;;;;;;;CAcC,GACD5E,yBAAyB+D,SAAS,CAACuD,QAAQ,GAAG,SAC5CxC,YAAY,EACZyC,KAAK,EACLC,KAAK,EACLC,SAAS,EACTC,WAAW,EACXC,WAAW,EACXC,eAAe;IAEf,yCAAyC;IACzC,IAAI,CAAC,IAAA,6KAAO,EAAC9C,eAAe;QAC1B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACyC,QAAQ;QACnB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACC,QAAQ;QACnB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACC,YAAY;QACvB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACC,cAAc;QACzB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACC,cAAc;QACzB,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,IAAI,CAAC,IAAA,6KAAO,EAACC,kBAAkB;QAC7B,MAAM,IAAI,oLAAc,CAAC;IAC3B;IACA,MAAMC,kBAAkBD,kBAAkBH;IAC1C,IAAII,kBAAkB,GAAG;QACvB,MAAM,IAAI,oLAAc,CACtB;IAEJ;IACA,wBAAwB;IAExB,MAAMC,OAAO,IAAI,CAACnE,KAAK;IACvB,IAAI,CAAC,IAAA,6KAAO,EAAC,IAAI,CAACA,KAAK,GAAG;QACxB,OAAOC;IACT;IAEA,MAAMmE,cAAcR,QAAQ,MAAMG;IAClC,MAAMM,eAAeR,QAAQ,MAAMG;IAEnC,MAAMtC,YAAYP,aAAaO,SAAS;IACxC,MAAM4C,iBAAiBnD,aAAaS,iBAAiB,CACnDmC,aACAC,aACAC;IAGF,MAAMM,kBAAkBb,sBAAsB3B,YAAY,CAAC;QACzDY,UAAUwB,KAAKxB,QAAQ;QACvBF,0BAA0B0B,KAAK1B,wBAAwB;QACvD9F,SAASwH,KAAKxH,OAAO;QACrB0G,yBAAyBc,KAAKd,uBAAuB;QACrDD,UAAUe,KAAKf,QAAQ;QACvBvG,eAAe,IAAI,CAACgB,cAAc;QAClCf,eAAe,IAAI,CAACgB,cAAc;QAClCsG,aAAaA;QACbC,cAAcA;QACdC,gBAAgBA;QAChB5C,WAAWA;IACb;IAEA,IAAI,CAAC,IAAA,6KAAO,EAAC6C,kBAAkB;QAC7B,YAAY;QACZ,OAAOtE;IACT;IAEA,IAAIuE,gBAAgBC,KAAKC,GAAG,CAAC,IAAI,CAACpF,gBAAgB,EAAE,IAAI,CAACE,gBAAgB;IACzEgF,gBAAgBC,KAAKC,GAAG,CAACF,eAAe,IAAI,CAACjF,iBAAiB;IAC9DiF,gBAAgBC,KAAKC,GAAG,CAACF,eAAe,IAAI,CAAC/E,iBAAiB;IAE9D,MAAMpC,kBAAkB+G,cACpBI,gBAAgB,MAChB,IAAI,CAAClF,gBAAgB;IACzB,MAAMhC,mBAAmB+G,eACrBG,gBAAgB,MAChB,IAAI,CAACjF,iBAAiB;IAC1B,MAAMhC,kBAAkB6G,cACpB,IAAI,CAAC5E,gBAAgB,GACrBgF,gBAAgB;IACpB,MAAMhH,mBAAmB6G,eACrB,IAAI,CAAC5E,iBAAiB,GACtB+E,gBAAgB;IACpB,MAAMpG,UAAU,IAAI,CAACD,QAAQ;IAE7B,OAAOkE,QAAQC,OAAO,CAACiC,iBAAiBhC,IAAI,CAAC,SAAUC,MAAM;QAC3D,MAAM9F,oBAAoB,IAAIiI,YAAYnC,OAAOG,QAAQ;QACzD,MAAMD,oBAAoB,mLAAa,CAAC7B,gBAAgB,CACtDnE,kBAAkB4B,MAAM,GAAG,GAC3BkE,OAAO7F,OAAO;QAEhB,IAAIgB;QACJ,IAAI,IAAA,6KAAO,EAAC6E,OAAO7E,cAAc,GAAG;YAClCA,iBAAiB,IAAIiH,WAAWpC,OAAO7E,cAAc;QACvD;QAEA,OAAO,IAAItB,yBAAyB;YAClCK,mBAAmBA;YACnBC,SAAS+F;YACT/E,gBAAgBA;YAChBd,eAAe2F,OAAO3F,aAAa;YACnCC,eAAe0F,OAAO1F,aAAa;YACnCC,gBAAgB,oLAAc,CAACiG,KAAK,CAACR,OAAOzF,cAAc;YAC1DkB,qBAAqB,yLAAmB,CAAC+E,KAAK,CAC5CR,OAAOvE,mBAAmB;YAE5BjB,uBAAuB,gLAAU,CAACgG,KAAK,CAACR,OAAOxF,qBAAqB;YACpEC,aAAauF,OAAOvF,WAAW;YAC/BC,cAAcsF,OAAOtF,YAAY;YACjCC,aAAaqF,OAAOrF,WAAW;YAC/BC,cAAcoF,OAAOpF,YAAY;YACjCC,iBAAiBA;YACjBC,kBAAkBA;YAClBC,iBAAiBA;YACjBC,kBAAkBA;YAClBmC,eAAe;YACfvB,SAASA;YACTyB,qBAAqB;QACvB;IACF;AACF;AAEA,MAAMgF,WAAW;AACjB,MAAMC,+BAA+B,IAAI,gLAAU;AAEnD;;;;;;;;CAQC,GACDzI,yBAAyB+D,SAAS,CAAC2E,iBAAiB,GAAG,SACrDpD,SAAS,EACTqD,SAAS,EACTC,QAAQ;IAER,IAAIC,IAAI,0KAAU,CAACC,KAAK,CACtB,CAACH,YAAYrD,UAAUyD,IAAI,IAAIzD,UAAU0D,KAAK,EAC9C,KACA;IAEFH,KAAKL;IACL,IAAIS,IAAI,0KAAU,CAACH,KAAK,CACtB,CAACF,WAAWtD,UAAU4D,KAAK,IAAI5D,UAAU6D,MAAM,EAC/C,KACA;IAEFF,KAAKT;IAEL,IAAI,CAAC,IAAA,6KAAO,EAAC,IAAI,CAAC7E,KAAK,GAAG;QACxB,OAAO+E,kBAAkB,IAAI,EAAEG,GAAGI;IACpC;IAEA,OAAOG,sBAAsB,IAAI,EAAEP,GAAGI;AACxC;AAEA,SAASI,mBAAmBR,CAAC,EAAEI,CAAC,EAAEK,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE;IACtD,MAAMC,OAAOxB,KAAKC,GAAG,CAACiB,IAAIE,IAAIE;IAC9B,MAAMG,OAAOzB,KAAK0B,GAAG,CAACR,IAAIE,IAAIE;IAC9B,MAAMK,OAAO3B,KAAKC,GAAG,CAACkB,IAAIE,IAAIE;IAC9B,MAAMK,OAAO5B,KAAK0B,GAAG,CAACP,IAAIE,IAAIE;IAC9B,OAAOd,KAAKe,QAAQf,KAAKgB,QAAQZ,KAAKc,QAAQd,KAAKe;AACrD;AAEA,MAAMC,mBAAmB,IAAI,gLAAU;AACvC,MAAMC,mBAAmB,IAAI,gLAAU;AACvC,MAAMC,mBAAmB,IAAI,gLAAU;AAEvC,SAASf,sBAAsBgB,WAAW,EAAEvB,CAAC,EAAEI,CAAC;IAC9C,MAAMnB,OAAOsC,YAAYzG,KAAK;IAC9B,MAAM2C,WAAWwB,KAAKxB,QAAQ;IAC9B,MAAMS,WAAWe,KAAKf,QAAQ;IAC9B,MAAMzG,UAAUwH,KAAKxH,OAAO;IAE5B,IAAK,IAAI+D,IAAI,GAAGC,MAAMhE,QAAQ2B,MAAM,EAAEoC,IAAIC,KAAKD,KAAK,EAAG;QACrD,MAAMgG,KAAK/J,OAAO,CAAC+D,EAAE;QACrB,MAAMiG,KAAKhK,OAAO,CAAC+D,IAAI,EAAE;QACzB,MAAMkG,KAAKjK,OAAO,CAAC+D,IAAI,EAAE;QAEzB,MAAMmG,MAAMzD,SAAS0D,wBAAwB,CAC3CnE,UACA+D,IACAJ;QAEF,MAAMS,MAAM3D,SAAS0D,wBAAwB,CAC3CnE,UACAgE,IACAJ;QAEF,MAAMS,MAAM5D,SAAS0D,wBAAwB,CAC3CnE,UACAiE,IACAJ;QAGF,IAAId,mBAAmBR,GAAGI,GAAGuB,IAAIzF,CAAC,EAAEyF,IAAIxF,CAAC,EAAE0F,IAAI3F,CAAC,EAAE2F,IAAI1F,CAAC,EAAE2F,IAAI5F,CAAC,EAAE4F,IAAI3F,CAAC,GAAG;YACtE,MAAM4F,cAAc,qLAAe,CAACC,6BAA6B,CAC/DhC,GACAI,GACAuB,IAAIzF,CAAC,EACLyF,IAAIxF,CAAC,EACL0F,IAAI3F,CAAC,EACL2F,IAAI1F,CAAC,EACL2F,IAAI5F,CAAC,EACL4F,IAAI3F,CAAC,EACLyD;YAEF,IACEmC,YAAY7F,CAAC,IAAI,CAAC,SAClB6F,YAAY5F,CAAC,IAAI,CAAC,SAClB4F,YAAYE,CAAC,IAAI,CAAC,OAClB;gBACA,MAAMC,KAAKhE,SAASiE,YAAY,CAAC1E,UAAU+D;gBAC3C,MAAMY,KAAKlE,SAASiE,YAAY,CAAC1E,UAAUgE;gBAC3C,MAAMY,KAAKnE,SAASiE,YAAY,CAAC1E,UAAUiE;gBAC3C,OAAOK,YAAY7F,CAAC,GAAGgG,KAAKH,YAAY5F,CAAC,GAAGiG,KAAKL,YAAYE,CAAC,GAAGI;YACnE;QACF;IACF;IAEA,sDAAsD;IACtD,OAAOtH;AACT;AAEA,SAAS8E,kBAAkB0B,WAAW,EAAEvB,CAAC,EAAEI,CAAC;IAC1C,MAAMkC,UAAUf,YAAYjI,QAAQ;IACpC,MAAMiJ,UAAUhB,YAAY9H,QAAQ;IACpC,MAAM+I,eAAejB,YAAY7H,aAAa;IAE9C,MAAMjC,UAAU8J,YAAY7I,QAAQ;IACpC,IAAK,IAAI8C,IAAI,GAAGC,MAAMhE,QAAQ2B,MAAM,EAAEoC,IAAIC,KAAKD,KAAK,EAAG;QACrD,MAAMgG,KAAK/J,OAAO,CAAC+D,EAAE;QACrB,MAAMiG,KAAKhK,OAAO,CAAC+D,IAAI,EAAE;QACzB,MAAMkG,KAAKjK,OAAO,CAAC+D,IAAI,EAAE;QAEzB,MAAMiF,KAAK6B,OAAO,CAACd,GAAG;QACtB,MAAMb,KAAK2B,OAAO,CAACb,GAAG;QACtB,MAAMZ,KAAKyB,OAAO,CAACZ,GAAG;QAEtB,MAAMhB,KAAK6B,OAAO,CAACf,GAAG;QACtB,MAAMZ,KAAK2B,OAAO,CAACd,GAAG;QACtB,MAAMX,KAAKyB,OAAO,CAACb,GAAG;QAEtB,IAAIlB,mBAAmBR,GAAGI,GAAGK,IAAIC,IAAIC,IAAIC,IAAIC,IAAIC,KAAK;YACpD,MAAMiB,cAAc,qLAAe,CAACC,6BAA6B,CAC/DhC,GACAI,GACAK,IACAC,IACAC,IACAC,IACAC,IACAC,IACAlB;YAEF,IACEmC,YAAY7F,CAAC,IAAI,CAAC,SAClB6F,YAAY5F,CAAC,IAAI,CAAC,SAClB4F,YAAYE,CAAC,IAAI,CAAC,OAClB;gBACA,MAAMQ,kBACJV,YAAY7F,CAAC,GAAGsG,YAAY,CAAChB,GAAG,GAChCO,YAAY5F,CAAC,GAAGqG,YAAY,CAACf,GAAG,GAChCM,YAAYE,CAAC,GAAGO,YAAY,CAACd,GAAG;gBAClC,OAAO,0KAAU,CAACgB,IAAI,CACpBnB,YAAY5I,cAAc,EAC1B4I,YAAY3I,cAAc,EAC1B6J,kBAAkB9C;YAEtB;QACF;IACF;IAEA,sDAAsD;IACtD,OAAO5E;AACT;AAEA;;;;;;;;;;;CAWC,GACD5D,yBAAyB+D,SAAS,CAACyH,gBAAgB,GAAG,SACpDjE,KAAK,EACLC,KAAK,EACLiE,MAAM,EACNC,MAAM;IAEN,yCAAyC;IACzC,2KAAK,CAACvL,MAAM,CAACI,MAAM,CAAC,SAASgH;IAC7B,2KAAK,CAACpH,MAAM,CAACI,MAAM,CAAC,SAASiH;IAC7B,2KAAK,CAACrH,MAAM,CAACI,MAAM,CAAC,UAAUkL;IAC9B,2KAAK,CAACtL,MAAM,CAACI,MAAM,CAAC,UAAUmL;IAC9B,wBAAwB;IAExB,IAAIC,YAAY,GAAG,kBAAkB;IACrC,IAAIF,WAAWlE,QAAQ,GAAG;QACxB,EAAEoE,WAAW,aAAa;IAC5B;IACA,IAAID,WAAWlE,QAAQ,GAAG;QACxBmE,aAAa,GAAG,cAAc;IAChC;IAEA,OAAO,CAAC,IAAI,CAACtI,cAAc,GAAI,KAAKsI,SAAU,MAAM;AACtD;AAEA;;;;;;;CAOC,GACD3L,yBAAyB+D,SAAS,CAAC6H,sBAAsB,GAAG;IAC1D,OAAO,IAAI,CAACrI,oBAAoB;AAClC;uCACevD","ignoreList":[0]}},
    {"offset": {"line": 62488, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/TileAvailability.js"],"sourcesContent":["import binarySearch from \"./binarySearch.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Reports the availability of tiles in a {@link TilingScheme}.\n *\n * @alias TileAvailability\n * @constructor\n *\n * @param {TilingScheme} tilingScheme The tiling scheme in which to report availability.\n * @param {number} maximumLevel The maximum tile level that is potentially available.\n */\nfunction TileAvailability(tilingScheme, maximumLevel) {\n  this._tilingScheme = tilingScheme;\n  this._maximumLevel = maximumLevel;\n\n  this._rootNodes = [];\n}\n\nconst rectangleScratch = new Rectangle();\n\nfunction findNode(level, x, y, nodes) {\n  const count = nodes.length;\n  for (let i = 0; i < count; ++i) {\n    const node = nodes[i];\n    if (node.x === x && node.y === y && node.level === level) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Marks a rectangular range of tiles in a particular level as being available.  For best performance,\n * add your ranges in order of increasing level.\n *\n * @param {number} level The level.\n * @param {number} startX The X coordinate of the first available tiles at the level.\n * @param {number} startY The Y coordinate of the first available tiles at the level.\n * @param {number} endX The X coordinate of the last available tiles at the level.\n * @param {number} endY The Y coordinate of the last available tiles at the level.\n */\nTileAvailability.prototype.addAvailableTileRange = function (\n  level,\n  startX,\n  startY,\n  endX,\n  endY,\n) {\n  const tilingScheme = this._tilingScheme;\n\n  const rootNodes = this._rootNodes;\n  if (level === 0) {\n    for (let y = startY; y <= endY; ++y) {\n      for (let x = startX; x <= endX; ++x) {\n        if (!findNode(level, x, y, rootNodes)) {\n          rootNodes.push(new QuadtreeNode(tilingScheme, undefined, 0, x, y));\n        }\n      }\n    }\n  }\n\n  tilingScheme.tileXYToRectangle(startX, startY, level, rectangleScratch);\n  const west = rectangleScratch.west;\n  const north = rectangleScratch.north;\n\n  tilingScheme.tileXYToRectangle(endX, endY, level, rectangleScratch);\n  const east = rectangleScratch.east;\n  const south = rectangleScratch.south;\n\n  const rectangleWithLevel = new RectangleWithLevel(\n    level,\n    west,\n    south,\n    east,\n    north,\n  );\n\n  for (let i = 0; i < rootNodes.length; ++i) {\n    const rootNode = rootNodes[i];\n    if (rectanglesOverlap(rootNode.extent, rectangleWithLevel)) {\n      putRectangleInQuadtree(this._maximumLevel, rootNode, rectangleWithLevel);\n    }\n  }\n};\n\n/**\n * Determines the level of the most detailed tile covering the position.  This function\n * usually completes in time logarithmic to the number of rectangles added with\n * {@link TileAvailability#addAvailableTileRange}.\n *\n * @param {Cartographic} position The position for which to determine the maximum available level.  The height component is ignored.\n * @return {number} The level of the most detailed tile covering the position.\n * @throws {DeveloperError} If position is outside any tile according to the tiling scheme.\n */\nTileAvailability.prototype.computeMaximumLevelAtPosition = function (position) {\n  // Find the root node that contains this position.\n  let node;\n  for (let nodeIndex = 0; nodeIndex < this._rootNodes.length; ++nodeIndex) {\n    const rootNode = this._rootNodes[nodeIndex];\n    if (rectangleContainsPosition(rootNode.extent, position)) {\n      node = rootNode;\n      break;\n    }\n  }\n\n  if (!defined(node)) {\n    return -1;\n  }\n\n  return findMaxLevelFromNode(undefined, node, position);\n};\n\nconst rectanglesScratch = [];\nconst remainingToCoverByLevelScratch = [];\nconst westScratch = new Rectangle();\nconst eastScratch = new Rectangle();\n\n/**\n * Finds the most detailed level that is available _everywhere_ within a given rectangle.  More detailed\n * tiles may be available in parts of the rectangle, but not the whole thing.  The return value of this\n * function may be safely passed to {@link sampleTerrain} for any position within the rectangle.  This function\n * usually completes in time logarithmic to the number of rectangles added with\n * {@link TileAvailability#addAvailableTileRange}.\n *\n * @param {Rectangle} rectangle The rectangle.\n * @return {number} The best available level for the entire rectangle.\n */\nTileAvailability.prototype.computeBestAvailableLevelOverRectangle = function (\n  rectangle,\n) {\n  const rectangles = rectanglesScratch;\n  rectangles.length = 0;\n\n  if (rectangle.east < rectangle.west) {\n    // Rectangle crosses the IDL, make it two rectangles.\n    rectangles.push(\n      Rectangle.fromRadians(\n        -Math.PI,\n        rectangle.south,\n        rectangle.east,\n        rectangle.north,\n        westScratch,\n      ),\n    );\n    rectangles.push(\n      Rectangle.fromRadians(\n        rectangle.west,\n        rectangle.south,\n        Math.PI,\n        rectangle.north,\n        eastScratch,\n      ),\n    );\n  } else {\n    rectangles.push(rectangle);\n  }\n\n  const remainingToCoverByLevel = remainingToCoverByLevelScratch;\n  remainingToCoverByLevel.length = 0;\n\n  let i;\n  for (i = 0; i < this._rootNodes.length; ++i) {\n    updateCoverageWithNode(\n      remainingToCoverByLevel,\n      this._rootNodes[i],\n      rectangles,\n    );\n  }\n\n  for (i = remainingToCoverByLevel.length - 1; i >= 0; --i) {\n    if (\n      defined(remainingToCoverByLevel[i]) &&\n      remainingToCoverByLevel[i].length === 0\n    ) {\n      return i;\n    }\n  }\n\n  return 0;\n};\n\nconst cartographicScratch = new Cartographic();\n\n/**\n * Determines if a particular tile is available.\n * @param {number} level The tile level to check.\n * @param {number} x The X coordinate of the tile to check.\n * @param {number} y The Y coordinate of the tile to check.\n * @return {boolean} True if the tile is available; otherwise, false.\n */\nTileAvailability.prototype.isTileAvailable = function (level, x, y) {\n  // Get the center of the tile and find the maximum level at that position.\n  // Because availability is by tile, if the level is available at that point, it\n  // is sure to be available for the whole tile.  We assume that if a tile at level n exists,\n  // then all its parent tiles back to level 0 exist too.  This isn't really enforced\n  // anywhere, but Cesium would never load a tile for which this is not true.\n  const rectangle = this._tilingScheme.tileXYToRectangle(\n    x,\n    y,\n    level,\n    rectangleScratch,\n  );\n  Rectangle.center(rectangle, cartographicScratch);\n  return this.computeMaximumLevelAtPosition(cartographicScratch) >= level;\n};\n\n/**\n * Computes a bit mask indicating which of a tile's four children exist.\n * If a child's bit is set, a tile is available for that child.  If it is cleared,\n * the tile is not available.  The bit values are as follows:\n * <table>\n *     <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *     <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *     <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *     <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *     <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n * </table>\n *\n * @param {number} level The level of the parent tile.\n * @param {number} x The X coordinate of the parent tile.\n * @param {number} y The Y coordinate of the parent tile.\n * @return {number} The bit mask indicating child availability.\n */\nTileAvailability.prototype.computeChildMaskForTile = function (level, x, y) {\n  const childLevel = level + 1;\n  if (childLevel >= this._maximumLevel) {\n    return 0;\n  }\n\n  let mask = 0;\n\n  mask |= this.isTileAvailable(childLevel, 2 * x, 2 * y + 1) ? 1 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x + 1, 2 * y + 1) ? 2 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x, 2 * y) ? 4 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x + 1, 2 * y) ? 8 : 0;\n\n  return mask;\n};\n\nfunction QuadtreeNode(tilingScheme, parent, level, x, y) {\n  this.tilingScheme = tilingScheme;\n  this.parent = parent;\n  this.level = level;\n  this.x = x;\n  this.y = y;\n  this.extent = tilingScheme.tileXYToRectangle(x, y, level);\n\n  this.rectangles = [];\n  this._sw = undefined;\n  this._se = undefined;\n  this._nw = undefined;\n  this._ne = undefined;\n}\n\nObject.defineProperties(QuadtreeNode.prototype, {\n  nw: {\n    get: function () {\n      if (!this._nw) {\n        this._nw = new QuadtreeNode(\n          this.tilingScheme,\n          this,\n          this.level + 1,\n          this.x * 2,\n          this.y * 2,\n        );\n      }\n      return this._nw;\n    },\n  },\n\n  ne: {\n    get: function () {\n      if (!this._ne) {\n        this._ne = new QuadtreeNode(\n          this.tilingScheme,\n          this,\n          this.level + 1,\n          this.x * 2 + 1,\n          this.y * 2,\n        );\n      }\n      return this._ne;\n    },\n  },\n\n  sw: {\n    get: function () {\n      if (!this._sw) {\n        this._sw = new QuadtreeNode(\n          this.tilingScheme,\n          this,\n          this.level + 1,\n          this.x * 2,\n          this.y * 2 + 1,\n        );\n      }\n      return this._sw;\n    },\n  },\n\n  se: {\n    get: function () {\n      if (!this._se) {\n        this._se = new QuadtreeNode(\n          this.tilingScheme,\n          this,\n          this.level + 1,\n          this.x * 2 + 1,\n          this.y * 2 + 1,\n        );\n      }\n      return this._se;\n    },\n  },\n});\n\nfunction RectangleWithLevel(level, west, south, east, north) {\n  this.level = level;\n  this.west = west;\n  this.south = south;\n  this.east = east;\n  this.north = north;\n}\n\nfunction rectanglesOverlap(rectangle1, rectangle2) {\n  const west = Math.max(rectangle1.west, rectangle2.west);\n  const south = Math.max(rectangle1.south, rectangle2.south);\n  const east = Math.min(rectangle1.east, rectangle2.east);\n  const north = Math.min(rectangle1.north, rectangle2.north);\n  return south < north && west < east;\n}\n\nfunction putRectangleInQuadtree(maxDepth, node, rectangle) {\n  while (node.level < maxDepth) {\n    if (rectangleFullyContainsRectangle(node.nw.extent, rectangle)) {\n      node = node.nw;\n    } else if (rectangleFullyContainsRectangle(node.ne.extent, rectangle)) {\n      node = node.ne;\n    } else if (rectangleFullyContainsRectangle(node.sw.extent, rectangle)) {\n      node = node.sw;\n    } else if (rectangleFullyContainsRectangle(node.se.extent, rectangle)) {\n      node = node.se;\n    } else {\n      break;\n    }\n  }\n\n  if (\n    node.rectangles.length === 0 ||\n    node.rectangles[node.rectangles.length - 1].level <= rectangle.level\n  ) {\n    node.rectangles.push(rectangle);\n  } else {\n    // Maintain ordering by level when inserting.\n    let index = binarySearch(\n      node.rectangles,\n      rectangle.level,\n      rectangleLevelComparator,\n    );\n    if (index < 0) {\n      index = ~index;\n    }\n    node.rectangles.splice(index, 0, rectangle);\n  }\n}\n\nfunction rectangleLevelComparator(a, b) {\n  return a.level - b;\n}\n\nfunction rectangleFullyContainsRectangle(potentialContainer, rectangleToTest) {\n  return (\n    rectangleToTest.west >= potentialContainer.west &&\n    rectangleToTest.east <= potentialContainer.east &&\n    rectangleToTest.south >= potentialContainer.south &&\n    rectangleToTest.north <= potentialContainer.north\n  );\n}\n\nfunction rectangleContainsPosition(potentialContainer, positionToTest) {\n  return (\n    positionToTest.longitude >= potentialContainer.west &&\n    positionToTest.longitude <= potentialContainer.east &&\n    positionToTest.latitude >= potentialContainer.south &&\n    positionToTest.latitude <= potentialContainer.north\n  );\n}\n\nfunction findMaxLevelFromNode(stopNode, node, position) {\n  let maxLevel = 0;\n\n  // Find the deepest quadtree node containing this point.\n  let found = false;\n  while (!found) {\n    const nw = node._nw && rectangleContainsPosition(node._nw.extent, position);\n    const ne = node._ne && rectangleContainsPosition(node._ne.extent, position);\n    const sw = node._sw && rectangleContainsPosition(node._sw.extent, position);\n    const se = node._se && rectangleContainsPosition(node._se.extent, position);\n\n    // The common scenario is that the point is in only one quadrant and we can simply\n    // iterate down the tree.  But if the point is on a boundary between tiles, it is\n    // in multiple tiles and we need to check all of them, so use recursion.\n    if (nw + ne + sw + se > 1) {\n      if (nw) {\n        maxLevel = Math.max(\n          maxLevel,\n          findMaxLevelFromNode(node, node._nw, position),\n        );\n      }\n      if (ne) {\n        maxLevel = Math.max(\n          maxLevel,\n          findMaxLevelFromNode(node, node._ne, position),\n        );\n      }\n      if (sw) {\n        maxLevel = Math.max(\n          maxLevel,\n          findMaxLevelFromNode(node, node._sw, position),\n        );\n      }\n      if (se) {\n        maxLevel = Math.max(\n          maxLevel,\n          findMaxLevelFromNode(node, node._se, position),\n        );\n      }\n      break;\n    } else if (nw) {\n      node = node._nw;\n    } else if (ne) {\n      node = node._ne;\n    } else if (sw) {\n      node = node._sw;\n    } else if (se) {\n      node = node._se;\n    } else {\n      found = true;\n    }\n  }\n\n  // Work up the tree until we find a rectangle that contains this point.\n  while (node !== stopNode) {\n    const rectangles = node.rectangles;\n\n    // Rectangles are sorted by level, lowest first.\n    for (\n      let i = rectangles.length - 1;\n      i >= 0 && rectangles[i].level > maxLevel;\n      --i\n    ) {\n      const rectangle = rectangles[i];\n      if (rectangleContainsPosition(rectangle, position)) {\n        maxLevel = rectangle.level;\n      }\n    }\n\n    node = node.parent;\n  }\n\n  return maxLevel;\n}\n\nfunction updateCoverageWithNode(\n  remainingToCoverByLevel,\n  node,\n  rectanglesToCover,\n) {\n  if (!node) {\n    return;\n  }\n\n  let i;\n  let anyOverlap = false;\n  for (i = 0; i < rectanglesToCover.length; ++i) {\n    anyOverlap =\n      anyOverlap || rectanglesOverlap(node.extent, rectanglesToCover[i]);\n  }\n\n  if (!anyOverlap) {\n    // This node is not applicable to the rectangle(s).\n    return;\n  }\n\n  const rectangles = node.rectangles;\n  for (i = 0; i < rectangles.length; ++i) {\n    const rectangle = rectangles[i];\n\n    if (!remainingToCoverByLevel[rectangle.level]) {\n      remainingToCoverByLevel[rectangle.level] = rectanglesToCover;\n    }\n\n    remainingToCoverByLevel[rectangle.level] = subtractRectangle(\n      remainingToCoverByLevel[rectangle.level],\n      rectangle,\n    );\n  }\n\n  // Update with child nodes.\n  updateCoverageWithNode(remainingToCoverByLevel, node._nw, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._ne, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._sw, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._se, rectanglesToCover);\n}\n\nfunction subtractRectangle(rectangleList, rectangleToSubtract) {\n  const result = [];\n  for (let i = 0; i < rectangleList.length; ++i) {\n    const rectangle = rectangleList[i];\n    if (!rectanglesOverlap(rectangle, rectangleToSubtract)) {\n      // Disjoint rectangles.  Original rectangle is unmodified.\n      result.push(rectangle);\n    } else {\n      // rectangleToSubtract partially or completely overlaps rectangle.\n      if (rectangle.west < rectangleToSubtract.west) {\n        result.push(\n          new Rectangle(\n            rectangle.west,\n            rectangle.south,\n            rectangleToSubtract.west,\n            rectangle.north,\n          ),\n        );\n      }\n      if (rectangle.east > rectangleToSubtract.east) {\n        result.push(\n          new Rectangle(\n            rectangleToSubtract.east,\n            rectangle.south,\n            rectangle.east,\n            rectangle.north,\n          ),\n        );\n      }\n      if (rectangle.south < rectangleToSubtract.south) {\n        result.push(\n          new Rectangle(\n            Math.max(rectangleToSubtract.west, rectangle.west),\n            rectangle.south,\n            Math.min(rectangleToSubtract.east, rectangle.east),\n            rectangleToSubtract.south,\n          ),\n        );\n      }\n      if (rectangle.north > rectangleToSubtract.north) {\n        result.push(\n          new Rectangle(\n            Math.max(rectangleToSubtract.west, rectangle.west),\n            rectangleToSubtract.north,\n            Math.min(rectangleToSubtract.east, rectangle.east),\n            rectangle.north,\n          ),\n        );\n      }\n    }\n  }\n\n  return result;\n}\nexport default TileAvailability;\n"],"names":["TileAvailability","tilingScheme","maximumLevel","_tilingScheme","_maximumLevel","_rootNodes","rectangleScratch","findNode","level","x","y","nodes","count","length","i","node","prototype","addAvailableTileRange","startX","startY","endX","endY","rootNodes","push","QuadtreeNode","undefined","tileXYToRectangle","west","north","east","south","rectangleWithLevel","RectangleWithLevel","rootNode","rectanglesOverlap","extent","putRectangleInQuadtree","computeMaximumLevelAtPosition","position","nodeIndex","rectangleContainsPosition","findMaxLevelFromNode","rectanglesScratch","remainingToCoverByLevelScratch","westScratch","eastScratch","computeBestAvailableLevelOverRectangle","rectangle","rectangles","fromRadians","Math","PI","remainingToCoverByLevel","updateCoverageWithNode","cartographicScratch","isTileAvailable","center","computeChildMaskForTile","childLevel","mask","parent","_sw","_se","_nw","_ne","Object","defineProperties","nw","get","ne","sw","se","rectangle1","rectangle2","max","min","maxDepth","rectangleFullyContainsRectangle","index","rectangleLevelComparator","splice","a","b","potentialContainer","rectangleToTest","positionToTest","longitude","latitude","stopNode","maxLevel","found","rectanglesToCover","anyOverlap","subtractRectangle","rectangleList","rectangleToSubtract","result"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 62867, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/CesiumTerrainProvider.js"],"sourcesContent":["import AttributeCompression from \"./AttributeCompression.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport Credit from \"./Credit.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport WebMercatorTilingScheme from \"./WebMercatorTilingScheme.js\";\nimport getJsonFromTypedArray from \"./getJsonFromTypedArray.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport IonResource from \"./IonResource.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport QuantizedMeshTerrainData from \"./QuantizedMeshTerrainData.js\";\nimport Request from \"./Request.js\";\nimport RequestType from \"./RequestType.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\nimport TileAvailability from \"./TileAvailability.js\";\nimport TileProviderError from \"./TileProviderError.js\";\n\nfunction LayerInformation(layer) {\n  this.resource = layer.resource;\n  this.version = layer.version;\n  this.isHeightmap = layer.isHeightmap;\n  this.tileUrlTemplates = layer.tileUrlTemplates;\n  this.availability = layer.availability;\n  this.hasVertexNormals = layer.hasVertexNormals;\n  this.hasWaterMask = layer.hasWaterMask;\n  this.hasMetadata = layer.hasMetadata;\n  this.availabilityLevels = layer.availabilityLevels;\n  this.availabilityTilesLoaded = layer.availabilityTilesLoaded;\n  this.littleEndianExtensionSize = layer.littleEndianExtensionSize;\n  this.availabilityPromiseCache = {};\n}\n\n/**\n * @typedef {object} CesiumTerrainProvider.ConstructorOptions\n *\n * Initialization options for the CesiumTerrainProvider constructor\n *\n * @property {boolean} [requestVertexNormals=false] Flag that indicates if the client should request additional lighting information from the server, in the form of per vertex normals if available.\n * @property {boolean} [requestWaterMask=false] Flag that indicates if the client should request per tile water masks from the server, if available.\n * @property {boolean} [requestMetadata=true] Flag that indicates if the client should request per tile metadata from the server, if available.\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid.  If not specified, the default ellipsoid is used.\n * @property {Credit|string} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * Used to track creation details while fetching initial metadata\n *\n * @constructor\n * @private\n *\n * @param {CesiumTerrainProvider.ConstructorOptions} options An object describing initialization options\n */\nfunction TerrainProviderBuilder(options) {\n  this.requestVertexNormals = options.requestVertexNormals ?? false;\n  this.requestWaterMask = options.requestWaterMask ?? false;\n  this.requestMetadata = options.requestMetadata ?? true;\n  this.ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n\n  this.heightmapWidth = 65;\n  this.heightmapStructure = undefined;\n  this.hasWaterMask = false;\n  this.hasMetadata = false;\n  this.hasVertexNormals = false;\n  this.scheme = undefined;\n\n  this.lastResource = undefined;\n  this.layerJsonResource = undefined;\n  this.previousError = undefined;\n  this.availability = undefined;\n  this.tilingScheme = undefined;\n  this.levelZeroMaximumGeometricError = undefined;\n  this.heightmapStructure = undefined;\n  this.layers = [];\n  this.attribution = \"\";\n  this.overallAvailability = [];\n  this.overallMaxZoom = 0;\n  this.tileCredits = [];\n}\n\n/**\n * Complete CesiumTerrainProvider creation based on builder values.\n *\n * @private\n *\n * @param {CesiumTerrainProvider} provider\n */\nTerrainProviderBuilder.prototype.build = function (provider) {\n  provider._heightmapWidth = this.heightmapWidth;\n  provider._scheme = this.scheme;\n\n  // ion resources have a credits property we can use for additional attribution.\n  const credits = defined(this.lastResource.credits)\n    ? this.lastResource.credits\n    : [];\n  provider._tileCredits = credits.concat(this.tileCredits);\n  provider._availability = this.availability;\n  provider._tilingScheme = this.tilingScheme;\n  provider._requestWaterMask = this.requestWaterMask;\n  provider._levelZeroMaximumGeometricError =\n    this.levelZeroMaximumGeometricError;\n  provider._heightmapStructure = this.heightmapStructure;\n  provider._layers = this.layers;\n\n  provider._hasWaterMask = this.hasWaterMask;\n  provider._hasVertexNormals = this.hasVertexNormals;\n  provider._hasMetadata = this.hasMetadata;\n};\n\nasync function parseMetadataSuccess(terrainProviderBuilder, data, provider) {\n  if (!data.format) {\n    const message = \"The tile format is not specified in the layer.json file.\";\n    terrainProviderBuilder.previousError = TileProviderError.reportError(\n      terrainProviderBuilder.previousError,\n      provider,\n      defined(provider) ? provider._errorEvent : undefined,\n      message,\n    );\n\n    throw new RuntimeError(message);\n  }\n\n  if (!data.tiles || data.tiles.length === 0) {\n    const message =\n      \"The layer.json file does not specify any tile URL templates.\";\n    terrainProviderBuilder.previousError = TileProviderError.reportError(\n      terrainProviderBuilder.previousError,\n      provider,\n      defined(provider) ? provider._errorEvent : undefined,\n      message,\n    );\n\n    throw new RuntimeError(message);\n  }\n\n  let hasVertexNormals = false;\n  let hasWaterMask = false;\n  let hasMetadata = false;\n  let littleEndianExtensionSize = true;\n  let isHeightmap = false;\n  if (data.format === \"heightmap-1.0\") {\n    isHeightmap = true;\n    if (!defined(terrainProviderBuilder.heightmapStructure)) {\n      terrainProviderBuilder.heightmapStructure = {\n        heightScale: 1.0 / 5.0,\n        heightOffset: -1000.0,\n        elementsPerHeight: 1,\n        stride: 1,\n        elementMultiplier: 256.0,\n        isBigEndian: false,\n        lowestEncodedHeight: 0,\n        highestEncodedHeight: 256 * 256 - 1,\n      };\n    }\n    hasWaterMask = true;\n    terrainProviderBuilder.requestWaterMask = true;\n  } else if (data.format.indexOf(\"quantized-mesh-1.\") !== 0) {\n    const message = `The tile format \"${data.format}\" is invalid or not supported.`;\n    terrainProviderBuilder.previousError = TileProviderError.reportError(\n      terrainProviderBuilder.previousError,\n      provider,\n      defined(provider) ? provider._errorEvent : undefined,\n      message,\n    );\n\n    throw new RuntimeError(message);\n  }\n\n  const tileUrlTemplates = data.tiles;\n\n  const maxZoom = data.maxzoom;\n  terrainProviderBuilder.overallMaxZoom = Math.max(\n    terrainProviderBuilder.overallMaxZoom,\n    maxZoom,\n  );\n\n  // Keeps track of which of the availability containing tiles have been loaded\n  if (!data.projection || data.projection === \"EPSG:4326\") {\n    terrainProviderBuilder.tilingScheme = new GeographicTilingScheme({\n      numberOfLevelZeroTilesX: 2,\n      numberOfLevelZeroTilesY: 1,\n      ellipsoid: terrainProviderBuilder.ellipsoid,\n    });\n  } else if (data.projection === \"EPSG:3857\") {\n    terrainProviderBuilder.tilingScheme = new WebMercatorTilingScheme({\n      numberOfLevelZeroTilesX: 1,\n      numberOfLevelZeroTilesY: 1,\n      ellipsoid: terrainProviderBuilder.ellipsoid,\n    });\n  } else {\n    const message = `The projection \"${data.projection}\" is invalid or not supported.`;\n    terrainProviderBuilder.previousError = TileProviderError.reportError(\n      terrainProviderBuilder.previousError,\n      provider,\n      defined(provider) ? provider._errorEvent : undefined,\n      message,\n    );\n\n    throw new RuntimeError(message);\n  }\n\n  terrainProviderBuilder.levelZeroMaximumGeometricError =\n    TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n      terrainProviderBuilder.tilingScheme.ellipsoid,\n      terrainProviderBuilder.heightmapWidth,\n      terrainProviderBuilder.tilingScheme.getNumberOfXTilesAtLevel(0),\n    );\n  if (!data.scheme || data.scheme === \"tms\" || data.scheme === \"slippyMap\") {\n    terrainProviderBuilder.scheme = data.scheme;\n  } else {\n    const message = `The scheme \"${data.scheme}\" is invalid or not supported.`;\n    terrainProviderBuilder.previousError = TileProviderError.reportError(\n      terrainProviderBuilder.previousError,\n      provider,\n      defined(provider) ? provider._errorEvent : undefined,\n      message,\n    );\n\n    throw new RuntimeError(message);\n  }\n\n  let availabilityTilesLoaded;\n\n  // The vertex normals defined in the 'octvertexnormals' extension is identical to the original\n  // contents of the original 'vertexnormals' extension.  'vertexnormals' extension is now\n  // deprecated, as the extensionLength for this extension was incorrectly using big endian.\n  // We maintain backwards compatibility with the legacy 'vertexnormal' implementation\n  // by setting the _littleEndianExtensionSize to false. Always prefer 'octvertexnormals'\n  // over 'vertexnormals' if both extensions are supported by the server.\n  if (\n    defined(data.extensions) &&\n    data.extensions.indexOf(\"octvertexnormals\") !== -1\n  ) {\n    hasVertexNormals = true;\n  } else if (\n    defined(data.extensions) &&\n    data.extensions.indexOf(\"vertexnormals\") !== -1\n  ) {\n    hasVertexNormals = true;\n    littleEndianExtensionSize = false;\n  }\n  if (defined(data.extensions) && data.extensions.indexOf(\"watermask\") !== -1) {\n    hasWaterMask = true;\n  }\n  if (defined(data.extensions) && data.extensions.indexOf(\"metadata\") !== -1) {\n    hasMetadata = true;\n  }\n\n  const availabilityLevels = data.metadataAvailability;\n  const availableTiles = data.available;\n  let availability;\n  if (defined(availableTiles) && !defined(availabilityLevels)) {\n    availability = new TileAvailability(\n      terrainProviderBuilder.tilingScheme,\n      availableTiles.length,\n    );\n    for (let level = 0; level < availableTiles.length; ++level) {\n      const rangesAtLevel = availableTiles[level];\n      const yTiles =\n        terrainProviderBuilder.tilingScheme.getNumberOfYTilesAtLevel(level);\n      if (!defined(terrainProviderBuilder.overallAvailability[level])) {\n        terrainProviderBuilder.overallAvailability[level] = [];\n      }\n\n      for (\n        let rangeIndex = 0;\n        rangeIndex < rangesAtLevel.length;\n        ++rangeIndex\n      ) {\n        const range = rangesAtLevel[rangeIndex];\n        const yStart = yTiles - range.endY - 1;\n        const yEnd = yTiles - range.startY - 1;\n        terrainProviderBuilder.overallAvailability[level].push([\n          range.startX,\n          yStart,\n          range.endX,\n          yEnd,\n        ]);\n        availability.addAvailableTileRange(\n          level,\n          range.startX,\n          yStart,\n          range.endX,\n          yEnd,\n        );\n      }\n    }\n  } else if (defined(availabilityLevels)) {\n    availabilityTilesLoaded = new TileAvailability(\n      terrainProviderBuilder.tilingScheme,\n      maxZoom,\n    );\n    availability = new TileAvailability(\n      terrainProviderBuilder.tilingScheme,\n      maxZoom,\n    );\n    terrainProviderBuilder.overallAvailability[0] = [[0, 0, 1, 0]];\n    availability.addAvailableTileRange(0, 0, 0, 1, 0);\n  }\n\n  terrainProviderBuilder.hasWaterMask =\n    terrainProviderBuilder.hasWaterMask || hasWaterMask;\n  terrainProviderBuilder.hasVertexNormals =\n    terrainProviderBuilder.hasVertexNormals || hasVertexNormals;\n  terrainProviderBuilder.hasMetadata =\n    terrainProviderBuilder.hasMetadata || hasMetadata;\n\n  if (defined(data.attribution)) {\n    if (terrainProviderBuilder.attribution.length > 0) {\n      terrainProviderBuilder.attribution += \" \";\n    }\n    terrainProviderBuilder.attribution += data.attribution;\n  }\n\n  terrainProviderBuilder.layers.push(\n    new LayerInformation({\n      resource: terrainProviderBuilder.lastResource,\n      version: data.version,\n      isHeightmap: isHeightmap,\n      tileUrlTemplates: tileUrlTemplates,\n      availability: availability,\n      hasVertexNormals: hasVertexNormals,\n      hasWaterMask: hasWaterMask,\n      hasMetadata: hasMetadata,\n      availabilityLevels: availabilityLevels,\n      availabilityTilesLoaded: availabilityTilesLoaded,\n      littleEndianExtensionSize: littleEndianExtensionSize,\n    }),\n  );\n\n  const parentUrl = data.parentUrl;\n  if (defined(parentUrl)) {\n    if (!defined(availability)) {\n      console.log(\n        \"A layer.json can't have a parentUrl if it does't have an available array.\",\n      );\n      return true;\n    }\n\n    terrainProviderBuilder.lastResource =\n      terrainProviderBuilder.lastResource.getDerivedResource({\n        url: parentUrl,\n      });\n    terrainProviderBuilder.lastResource.appendForwardSlash(); // Terrain always expects a directory\n    terrainProviderBuilder.layerJsonResource =\n      terrainProviderBuilder.lastResource.getDerivedResource({\n        url: \"layer.json\",\n      });\n    await requestLayerJson(terrainProviderBuilder);\n    return true;\n  }\n\n  return true;\n}\n\nfunction parseMetadataFailure(terrainProviderBuilder, error, provider) {\n  let message = `An error occurred while accessing ${terrainProviderBuilder.layerJsonResource.url}.`;\n  if (defined(error)) {\n    message += `\\n${error.message}`;\n  }\n\n  terrainProviderBuilder.previousError = TileProviderError.reportError(\n    terrainProviderBuilder.previousError,\n    provider,\n    defined(provider) ? provider._errorEvent : undefined,\n    message,\n  );\n\n  // If we can retry, do so. Otherwise throw the error.\n  if (terrainProviderBuilder.previousError.retry) {\n    return requestLayerJson(terrainProviderBuilder, provider);\n  }\n\n  throw new RuntimeError(message);\n}\n\nasync function metadataSuccess(terrainProviderBuilder, data, provider) {\n  await parseMetadataSuccess(terrainProviderBuilder, data, provider);\n\n  const length = terrainProviderBuilder.overallAvailability.length;\n  if (length > 0) {\n    const availability = (terrainProviderBuilder.availability =\n      new TileAvailability(\n        terrainProviderBuilder.tilingScheme,\n        terrainProviderBuilder.overallMaxZoom,\n      ));\n    for (let level = 0; level < length; ++level) {\n      const levelRanges = terrainProviderBuilder.overallAvailability[level];\n      for (let i = 0; i < levelRanges.length; ++i) {\n        const range = levelRanges[i];\n        availability.addAvailableTileRange(\n          level,\n          range[0],\n          range[1],\n          range[2],\n          range[3],\n        );\n      }\n    }\n  }\n\n  if (terrainProviderBuilder.attribution.length > 0) {\n    const layerJsonCredit = new Credit(terrainProviderBuilder.attribution);\n    terrainProviderBuilder.tileCredits.push(layerJsonCredit);\n  }\n\n  return true;\n}\n\nasync function requestLayerJson(terrainProviderBuilder, provider) {\n  try {\n    const data = await terrainProviderBuilder.layerJsonResource.fetchJson();\n    return metadataSuccess(terrainProviderBuilder, data, provider);\n  } catch (error) {\n    // If the metadata is not found, assume this is a pre-metadata heightmap tileset.\n    if (defined(error) && error.statusCode === 404) {\n      await parseMetadataSuccess(\n        terrainProviderBuilder,\n        {\n          tilejson: \"2.1.0\",\n          format: \"heightmap-1.0\",\n          version: \"1.0.0\",\n          scheme: \"tms\",\n          tiles: [\"{z}/{x}/{y}.terrain?v={version}\"],\n        },\n        provider,\n      );\n\n      return true;\n    }\n\n    return parseMetadataFailure(terrainProviderBuilder, error, provider);\n  }\n}\n\n/**\n * <div class=\"notice\">\n * To construct a CesiumTerrainProvider, call {@link CesiumTerrainProvider.fromIonAssetId} or {@link CesiumTerrainProvider.fromUrl}. Do not call the constructor directly.\n * </div>\n *\n * A {@link TerrainProvider} that accesses terrain data in a Cesium terrain format.\n * Terrain formats can be one of the following:\n * <ul>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/quantized-mesh Quantized Mesh} </li>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/heightmap-1.0 Height Map} </li>\n * </ul>\n *\n * @alias CesiumTerrainProvider\n * @constructor\n *\n * @param {CesiumTerrainProvider.ConstructorOptions} [options] An object describing initialization options\n *\n * @example\n * // Create Arctic DEM terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(3956, {\n *       requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n * @see createWorldTerrain\n * @see CesiumTerrainProvider.fromUrl\n * @see CesiumTerrainProvider.fromIonAssetId\n * @see TerrainProvider\n */\nfunction CesiumTerrainProvider(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  this._heightmapWidth = undefined;\n  this._heightmapStructure = undefined;\n  this._hasWaterMask = false;\n  this._hasVertexNormals = false;\n  this._hasMetadata = false;\n  this._scheme = undefined;\n  this._ellipsoid = options.ellipsoid;\n\n  /**\n   * Boolean flag that indicates if the client should request vertex normals from the server.\n   * @type {boolean}\n   * @default false\n   * @private\n   */\n  this._requestVertexNormals = options.requestVertexNormals ?? false;\n\n  /**\n   * Boolean flag that indicates if the client should request tile watermasks from the server.\n   * @type {boolean}\n   * @default false\n   * @private\n   */\n  this._requestWaterMask = options.requestWaterMask ?? false;\n\n  /**\n   * Boolean flag that indicates if the client should request tile metadata from the server.\n   * @type {boolean}\n   * @default true\n   * @private\n   */\n  this._requestMetadata = options.requestMetadata ?? true;\n\n  this._errorEvent = new Event();\n\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  this._availability = undefined;\n  this._tilingScheme = undefined;\n  this._levelZeroMaximumGeometricError = undefined;\n  this._layers = undefined;\n  this._tileCredits = undefined;\n}\n\n/**\n * When using the Quantized-Mesh format, a tile may be returned that includes additional extensions, such as PerVertexNormals, watermask, etc.\n * This enumeration defines the unique identifiers for each type of extension data that has been appended to the standard mesh data.\n *\n * @namespace QuantizedMeshExtensionIds\n * @see CesiumTerrainProvider\n * @private\n */\nconst QuantizedMeshExtensionIds = {\n  /**\n   * Oct-Encoded Per-Vertex Normals are included as an extension to the tile mesh\n   *\n   * @type {number}\n   * @constant\n   * @default 1\n   */\n  OCT_VERTEX_NORMALS: 1,\n  /**\n   * A watermask is included as an extension to the tile mesh\n   *\n   * @type {number}\n   * @constant\n   * @default 2\n   */\n  WATER_MASK: 2,\n  /**\n   * A json object contain metadata about the tile\n   *\n   * @type {number}\n   * @constant\n   * @default 4\n   */\n  METADATA: 4,\n};\n\nfunction getRequestHeader(extensionsList) {\n  if (!defined(extensionsList) || extensionsList.length === 0) {\n    return {\n      Accept:\n        \"application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01\",\n    };\n  }\n  const extensions = extensionsList.join(\"-\");\n  return {\n    Accept: `application/vnd.quantized-mesh;extensions=${extensions},application/octet-stream;q=0.9,*/*;q=0.01`,\n  };\n}\n\nfunction createHeightmapTerrainData(provider, buffer, level, x, y) {\n  const heightBuffer = new Uint16Array(\n    buffer,\n    0,\n    provider._heightmapWidth * provider._heightmapWidth,\n  );\n  return new HeightmapTerrainData({\n    buffer: heightBuffer,\n    childTileMask: new Uint8Array(buffer, heightBuffer.byteLength, 1)[0],\n    waterMask: new Uint8Array(\n      buffer,\n      heightBuffer.byteLength + 1,\n      buffer.byteLength - heightBuffer.byteLength - 1,\n    ),\n    width: provider._heightmapWidth,\n    height: provider._heightmapWidth,\n    structure: provider._heightmapStructure,\n    credits: provider._tileCredits,\n  });\n}\n\nfunction createQuantizedMeshTerrainData(provider, buffer, level, x, y, layer) {\n  const littleEndianExtensionSize = layer.littleEndianExtensionSize;\n  let pos = 0;\n  const cartesian3Elements = 3;\n  const boundingSphereElements = cartesian3Elements + 1;\n  const cartesian3Length = Float64Array.BYTES_PER_ELEMENT * cartesian3Elements;\n  const boundingSphereLength =\n    Float64Array.BYTES_PER_ELEMENT * boundingSphereElements;\n  const encodedVertexElements = 3;\n  const encodedVertexLength =\n    Uint16Array.BYTES_PER_ELEMENT * encodedVertexElements;\n  const triangleElements = 3;\n  let bytesPerIndex = Uint16Array.BYTES_PER_ELEMENT;\n  let triangleLength = bytesPerIndex * triangleElements;\n\n  const view = new DataView(buffer);\n  const center = new Cartesian3(\n    view.getFloat64(pos, true),\n    view.getFloat64(pos + 8, true),\n    view.getFloat64(pos + 16, true),\n  );\n  pos += cartesian3Length;\n\n  const minimumHeight = view.getFloat32(pos, true);\n  pos += Float32Array.BYTES_PER_ELEMENT;\n  const maximumHeight = view.getFloat32(pos, true);\n  pos += Float32Array.BYTES_PER_ELEMENT;\n\n  const boundingSphere = new BoundingSphere(\n    new Cartesian3(\n      view.getFloat64(pos, true),\n      view.getFloat64(pos + 8, true),\n      view.getFloat64(pos + 16, true),\n    ),\n    view.getFloat64(pos + cartesian3Length, true),\n  );\n  pos += boundingSphereLength;\n\n  const horizonOcclusionPoint = new Cartesian3(\n    view.getFloat64(pos, true),\n    view.getFloat64(pos + 8, true),\n    view.getFloat64(pos + 16, true),\n  );\n  pos += cartesian3Length;\n\n  const vertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const encodedVertexBuffer = new Uint16Array(buffer, pos, vertexCount * 3);\n  pos += vertexCount * encodedVertexLength;\n\n  if (vertexCount > 64 * 1024) {\n    // More than 64k vertices, so indices are 32-bit.\n    bytesPerIndex = Uint32Array.BYTES_PER_ELEMENT;\n    triangleLength = bytesPerIndex * triangleElements;\n  }\n\n  // Decode the vertex buffer.\n  const uBuffer = encodedVertexBuffer.subarray(0, vertexCount);\n  const vBuffer = encodedVertexBuffer.subarray(vertexCount, 2 * vertexCount);\n  const heightBuffer = encodedVertexBuffer.subarray(\n    vertexCount * 2,\n    3 * vertexCount,\n  );\n\n  AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer);\n\n  // skip over any additional padding that was added for 2/4 byte alignment\n  if (pos % bytesPerIndex !== 0) {\n    pos += bytesPerIndex - (pos % bytesPerIndex);\n  }\n\n  const triangleCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const indices = IndexDatatype.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    triangleCount * triangleElements,\n  );\n  pos += triangleCount * triangleLength;\n\n  // High water mark decoding based on decompressIndices_ in webgl-loader's loader.js.\n  // https://code.google.com/p/webgl-loader/source/browse/trunk/samples/loader.js?r=99#55\n  // Copyright 2012 Google Inc., Apache 2.0 license.\n  let highest = 0;\n  const length = indices.length;\n  for (let i = 0; i < length; ++i) {\n    const code = indices[i];\n    indices[i] = highest - code;\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  const westVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const westIndices = IndexDatatype.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    westVertexCount,\n  );\n  pos += westVertexCount * bytesPerIndex;\n\n  const southVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const southIndices = IndexDatatype.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    southVertexCount,\n  );\n  pos += southVertexCount * bytesPerIndex;\n\n  const eastVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const eastIndices = IndexDatatype.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    eastVertexCount,\n  );\n  pos += eastVertexCount * bytesPerIndex;\n\n  const northVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const northIndices = IndexDatatype.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    northVertexCount,\n  );\n  pos += northVertexCount * bytesPerIndex;\n\n  let encodedNormalBuffer;\n  let waterMaskBuffer;\n  while (pos < view.byteLength) {\n    const extensionId = view.getUint8(pos, true);\n    pos += Uint8Array.BYTES_PER_ELEMENT;\n    const extensionLength = view.getUint32(pos, littleEndianExtensionSize);\n    pos += Uint32Array.BYTES_PER_ELEMENT;\n\n    if (\n      extensionId === QuantizedMeshExtensionIds.OCT_VERTEX_NORMALS &&\n      provider._requestVertexNormals\n    ) {\n      encodedNormalBuffer = new Uint8Array(buffer, pos, vertexCount * 2);\n    } else if (\n      extensionId === QuantizedMeshExtensionIds.WATER_MASK &&\n      provider._requestWaterMask\n    ) {\n      waterMaskBuffer = new Uint8Array(buffer, pos, extensionLength);\n    } else if (\n      extensionId === QuantizedMeshExtensionIds.METADATA &&\n      provider._requestMetadata\n    ) {\n      const stringLength = view.getUint32(pos, true);\n      if (stringLength > 0) {\n        const metadata = getJsonFromTypedArray(\n          new Uint8Array(buffer),\n          pos + Uint32Array.BYTES_PER_ELEMENT,\n          stringLength,\n        );\n        const availableTiles = metadata.available;\n        if (defined(availableTiles)) {\n          for (let offset = 0; offset < availableTiles.length; ++offset) {\n            const availableLevel = level + offset + 1;\n            const rangesAtLevel = availableTiles[offset];\n            const yTiles =\n              provider._tilingScheme.getNumberOfYTilesAtLevel(availableLevel);\n\n            for (\n              let rangeIndex = 0;\n              rangeIndex < rangesAtLevel.length;\n              ++rangeIndex\n            ) {\n              const range = rangesAtLevel[rangeIndex];\n              const yStart = yTiles - range.endY - 1;\n              const yEnd = yTiles - range.startY - 1;\n              provider.availability.addAvailableTileRange(\n                availableLevel,\n                range.startX,\n                yStart,\n                range.endX,\n                yEnd,\n              );\n              layer.availability.addAvailableTileRange(\n                availableLevel,\n                range.startX,\n                yStart,\n                range.endX,\n                yEnd,\n              );\n            }\n          }\n        }\n      }\n      layer.availabilityTilesLoaded.addAvailableTileRange(level, x, y, x, y);\n    }\n    pos += extensionLength;\n  }\n\n  const skirtHeight = provider.getLevelMaximumGeometricError(level) * 5.0;\n\n  // The skirt is not included in the OBB computation. If this ever\n  // causes any rendering artifacts (cracks), they are expected to be\n  // minor and in the corners of the screen. It's possible that this\n  // might need to be changed - just change to `minimumHeight - skirtHeight`\n  // A similar change might also be needed in `upsampleQuantizedTerrainMesh.js`.\n  const rectangle = provider._tilingScheme.tileXYToRectangle(x, y, level);\n  const orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    provider._tilingScheme.ellipsoid,\n  );\n\n  return new QuantizedMeshTerrainData({\n    center: center,\n    minimumHeight: minimumHeight,\n    maximumHeight: maximumHeight,\n    boundingSphere: boundingSphere,\n    orientedBoundingBox: orientedBoundingBox,\n    horizonOcclusionPoint: horizonOcclusionPoint,\n    quantizedVertices: encodedVertexBuffer,\n    encodedNormals: encodedNormalBuffer,\n    indices: indices,\n    westIndices: westIndices,\n    southIndices: southIndices,\n    eastIndices: eastIndices,\n    northIndices: northIndices,\n    westSkirtHeight: skirtHeight,\n    southSkirtHeight: skirtHeight,\n    eastSkirtHeight: skirtHeight,\n    northSkirtHeight: skirtHeight,\n    childTileMask: provider.availability.computeChildMaskForTile(level, x, y),\n    waterMask: waterMaskBuffer,\n    credits: provider._tileCredits,\n  });\n}\n\n/**\n * Requests the geometry for a given tile. The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n *\n */\nCesiumTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request,\n) {\n  const layers = this._layers;\n  let layerToUse;\n  const layerCount = layers.length;\n  let unknownAvailability = false;\n  let availabilityPromise = Promise.resolve();\n\n  if (layerCount === 1) {\n    // Optimized path for single layers\n    layerToUse = layers[0];\n  } else {\n    for (let i = 0; i < layerCount; ++i) {\n      const layer = layers[i];\n      if (\n        !defined(layer.availability) ||\n        layer.availability.isTileAvailable(level, x, y)\n      ) {\n        layerToUse = layer;\n        break;\n      }\n\n      const availabilityUnloaded = checkLayer(\n        this,\n        x,\n        y,\n        level,\n        layer,\n        i === 0,\n      );\n      if (availabilityUnloaded.result) {\n        // We can't know yet since the availability is not yet loaded\n        unknownAvailability = true;\n        availabilityPromise = availabilityPromise.then(\n          () => availabilityUnloaded.promise,\n        );\n      }\n    }\n  }\n\n  if (!defined(layerToUse) && unknownAvailability) {\n    // Try again when availability data is readyâ€“ Otherwise the tile will be marked as failed and never re-requested\n    return availabilityPromise.then(() => {\n      // handle promise or undefined return\n      return new Promise((resolve) => {\n        // defer execution to the next event loop\n        setTimeout(() => {\n          const promise = this.requestTileGeometry(x, y, level, request);\n          resolve(promise);\n        }, 0); // next tick\n      });\n    });\n  }\n  // call overridden function below\n  return requestTileGeometry(this, x, y, level, layerToUse, request);\n};\n\nfunction requestTileGeometry(provider, x, y, level, layerToUse, request) {\n  if (!defined(layerToUse)) {\n    return Promise.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n\n  const urlTemplates = layerToUse.tileUrlTemplates;\n  if (urlTemplates.length === 0) {\n    return undefined;\n  }\n\n  // The TileMapService scheme counts from the bottom left\n  let terrainY;\n  if (!provider._scheme || provider._scheme === \"tms\") {\n    const yTiles = provider._tilingScheme.getNumberOfYTilesAtLevel(level);\n    terrainY = yTiles - y - 1;\n  } else {\n    terrainY = y;\n  }\n\n  const extensionList = [];\n  if (provider._requestVertexNormals && layerToUse.hasVertexNormals) {\n    extensionList.push(\n      layerToUse.littleEndianExtensionSize\n        ? \"octvertexnormals\"\n        : \"vertexnormals\",\n    );\n  }\n  if (provider._requestWaterMask && layerToUse.hasWaterMask) {\n    extensionList.push(\"watermask\");\n  }\n  if (provider._requestMetadata && layerToUse.hasMetadata) {\n    extensionList.push(\"metadata\");\n  }\n\n  let headers;\n  let query;\n  const url = urlTemplates[(x + terrainY + level) % urlTemplates.length];\n\n  const resource = layerToUse.resource;\n  if (\n    defined(resource._ionEndpoint) &&\n    !defined(resource._ionEndpoint.externalType)\n  ) {\n    // ion uses query parameters to request extensions\n    if (extensionList.length !== 0) {\n      query = { extensions: extensionList.join(\"-\") };\n    }\n    headers = getRequestHeader(undefined);\n  } else {\n    //All other terrain servers\n    headers = getRequestHeader(extensionList);\n  }\n\n  const promise = resource\n    .getDerivedResource({\n      url: url,\n      templateValues: {\n        version: layerToUse.version,\n        z: level,\n        x: x,\n        y: terrainY,\n      },\n      queryParameters: query,\n      headers: headers,\n      request: request,\n    })\n    .fetchArrayBuffer();\n\n  if (!defined(promise)) {\n    return undefined;\n  }\n\n  return promise.then(function (buffer) {\n    if (!defined(buffer)) {\n      return Promise.reject(new RuntimeError(\"Mesh buffer doesn't exist.\"));\n    }\n    if (defined(provider._heightmapStructure)) {\n      return createHeightmapTerrainData(provider, buffer, level, x, y);\n    }\n    return createQuantizedMeshTerrainData(\n      provider,\n      buffer,\n      level,\n      x,\n      y,\n      layerToUse,\n    );\n  });\n}\n\nObject.defineProperties(CesiumTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return this._hasWaterMask && this._requestWaterMask;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      // returns true if we can request vertex normals from the server\n      return this._hasVertexNormals && this._requestVertexNormals;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include metadata.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasMetadata: {\n    get: function () {\n      // returns true if we can request metadata from the server\n      return this._hasMetadata && this._requestMetadata;\n    },\n  },\n\n  /**\n   * Boolean flag that indicates if the client should request vertex normals from the server.\n   * Vertex normals data is appended to the standard tile mesh data only if the client requests the vertex normals and\n   * if the server provides vertex normals.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  requestVertexNormals: {\n    get: function () {\n      return this._requestVertexNormals;\n    },\n  },\n\n  /**\n   * Boolean flag that indicates if the client should request a watermask from the server.\n   * Watermask data is appended to the standard tile mesh data only if the client requests the watermask and\n   * if the server provides a watermask.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  requestWaterMask: {\n    get: function () {\n      return this._requestWaterMask;\n    },\n  },\n\n  /**\n   * Boolean flag that indicates if the client should request metadata from the server.\n   * Metadata is appended to the standard tile mesh data only if the client requests the metadata and\n   * if the server provides a metadata.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  requestMetadata: {\n    get: function () {\n      return this._requestMetadata;\n    },\n  },\n\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles. This property may be undefined if availability\n   * information is not available. Note that this reflects tiles that are known to be available currently.\n   * Additional tiles may be discovered to be available in the future, e.g. if availability information\n   * exists deeper in the tree rather than it all being discoverable at the root. However, a tile that\n   * is available now will not become unavailable in the future.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {TileAvailability|undefined}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      return this._availability;\n    },\n  },\n});\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error.\n */\nCesiumTerrainProvider.prototype.getLevelMaximumGeometricError = function (\n  level,\n) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\n/**\n * Creates a {@link TerrainProvider} from a Cesium ion asset ID that accesses terrain data in a Cesium terrain format\n * Terrain formats can be one of the following:\n * <ul>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/quantized-mesh Quantized Mesh} </li>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/heightmap-1.0 Height Map} </li>\n * </ul>\n *\n * @param {number} assetId The Cesium ion asset id.\n * @param {CesiumTerrainProvider.ConstructorOptions} [options] An object describing initialization options.\n * @returns {Promise<CesiumTerrainProvider>}\n *\n * @example\n * // Create Arctic DEM terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(3956, {\n *         requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n * @exception {RuntimeError} layer.json does not specify a format\n * @exception {RuntimeError} layer.json specifies an unknown format\n * @exception {RuntimeError} layer.json specifies an unsupported quantized-mesh version\n * @exception {RuntimeError} layer.json does not specify a tiles property, or specifies an empty array\n * @exception {RuntimeError} layer.json does not specify any tile URL templates\n */\nCesiumTerrainProvider.fromIonAssetId = async function (assetId, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"assetId\", assetId);\n  //>>includeEnd('debug');\n\n  const resource = await IonResource.fromAssetId(assetId);\n  return CesiumTerrainProvider.fromUrl(resource, options);\n};\n\n/**\n * Creates a {@link TerrainProvider} that accesses terrain data in a Cesium terrain format.\n * Terrain formats can be one of the following:\n * <ul>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/quantized-mesh Quantized Mesh} </li>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/heightmap-1.0 Height Map} </li>\n * </ul>\n *\n * @param {Resource|string|Promise<Resource>|Promise<string>} url The URL of the Cesium terrain server.\n * @param {CesiumTerrainProvider.ConstructorOptions} [options] An object describing initialization options.\n * @returns {Promise<CesiumTerrainProvider>}\n *\n * @example\n * // Create Arctic DEM terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.CesiumTerrainProvider.fromUrl(\n *       Cesium.IonResource.fromAssetId(3956), {\n *         requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n * @exception {RuntimeError} layer.json does not specify a format\n * @exception {RuntimeError} layer.json specifies an unknown format\n * @exception {RuntimeError} layer.json specifies an unsupported quantized-mesh version\n * @exception {RuntimeError} layer.json does not specify a tiles property, or specifies an empty array\n * @exception {RuntimeError} layer.json does not specify any tile URL templates\n */\nCesiumTerrainProvider.fromUrl = async function (url, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  url = await Promise.resolve(url);\n  const resource = Resource.createIfNeeded(url);\n  resource.appendForwardSlash();\n\n  const terrainProviderBuilder = new TerrainProviderBuilder(options);\n  terrainProviderBuilder.lastResource = resource;\n  terrainProviderBuilder.layerJsonResource =\n    terrainProviderBuilder.lastResource.getDerivedResource({\n      url: \"layer.json\",\n    });\n\n  await requestLayerJson(terrainProviderBuilder);\n\n  const provider = new CesiumTerrainProvider(options);\n  terrainProviderBuilder.build(provider);\n\n  return provider;\n};\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {boolean|undefined} Undefined if not supported or availability is unknown, otherwise true or false.\n */\nCesiumTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {\n  if (!defined(this._availability)) {\n    return undefined;\n  }\n  if (level > this._availability._maximumLevel) {\n    return false;\n  }\n\n  if (this._availability.isTileAvailable(level, x, y)) {\n    // If the tile is listed as available, then we are done\n    return true;\n  }\n  if (!this._hasMetadata) {\n    // If we don't have any layers with the metadata extension then we don't have this tile\n    return false;\n  }\n\n  const layers = this._layers;\n  const count = layers.length;\n  for (let i = 0; i < count; ++i) {\n    const layerResult = checkLayer(this, x, y, level, layers[i], i === 0);\n    if (layerResult.result) {\n      // There is a layer that may or may not have the tile\n      return undefined;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise<void>} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nCesiumTerrainProvider.prototype.loadTileDataAvailability = function (\n  x,\n  y,\n  level,\n) {\n  if (\n    !defined(this._availability) ||\n    level > this._availability._maximumLevel ||\n    this._availability.isTileAvailable(level, x, y) ||\n    !this._hasMetadata\n  ) {\n    // We know the tile is either available or not available so nothing to wait on\n    return undefined;\n  }\n\n  const layers = this._layers;\n  const count = layers.length;\n  for (let i = 0; i < count; ++i) {\n    const layerResult = checkLayer(this, x, y, level, layers[i], i === 0);\n    if (defined(layerResult.promise)) {\n      return layerResult.promise;\n    }\n  }\n};\n\nfunction getAvailabilityTile(layer, x, y, level) {\n  if (level === 0) {\n    return;\n  }\n\n  const availabilityLevels = layer.availabilityLevels;\n  const parentLevel =\n    level % availabilityLevels === 0\n      ? level - availabilityLevels\n      : ((level / availabilityLevels) | 0) * availabilityLevels;\n  const divisor = 1 << (level - parentLevel);\n  const parentX = (x / divisor) | 0;\n  const parentY = (y / divisor) | 0;\n\n  return {\n    level: parentLevel,\n    x: parentX,\n    y: parentY,\n  };\n}\n\nfunction checkLayer(provider, x, y, level, layer, topLayer) {\n  if (!defined(layer.availabilityLevels)) {\n    // It's definitely not in this layer\n    return {\n      result: false,\n    };\n  }\n\n  let cacheKey;\n  const deleteFromCache = function () {\n    delete layer.availabilityPromiseCache[cacheKey];\n  };\n  const availabilityTilesLoaded = layer.availabilityTilesLoaded;\n  const availability = layer.availability;\n\n  let tile = getAvailabilityTile(layer, x, y, level);\n  while (defined(tile)) {\n    if (\n      availability.isTileAvailable(tile.level, tile.x, tile.y) &&\n      !availabilityTilesLoaded.isTileAvailable(tile.level, tile.x, tile.y)\n    ) {\n      let requestPromise;\n      if (!topLayer) {\n        cacheKey = `${tile.level}-${tile.x}-${tile.y}`;\n        requestPromise = layer.availabilityPromiseCache[cacheKey];\n        if (!defined(requestPromise)) {\n          // For cutout terrain, if this isn't the top layer the availability tiles\n          //  may never get loaded, so request it here.\n          const request = new Request({\n            throttle: false,\n            throttleByServer: true,\n            type: RequestType.TERRAIN,\n          });\n          requestPromise = requestTileGeometry(\n            provider,\n            tile.x,\n            tile.y,\n            tile.level,\n            layer,\n            request,\n          );\n          if (defined(requestPromise)) {\n            layer.availabilityPromiseCache[cacheKey] = requestPromise;\n            requestPromise.then(deleteFromCache);\n          }\n        }\n      }\n\n      // The availability tile is available, but not loaded, so there\n      //  is still a chance that it may become available at some point\n      return {\n        result: true,\n        promise: requestPromise,\n      };\n    }\n\n    tile = getAvailabilityTile(layer, tile.x, tile.y, tile.level);\n  }\n\n  return {\n    result: false,\n  };\n}\n\n// Used for testing\nCesiumTerrainProvider._getAvailabilityTile = getAvailabilityTile;\nexport default CesiumTerrainProvider;\n"],"names":["LayerInformation","layer","resource","version","isHeightmap","tileUrlTemplates","availability","hasVertexNormals","hasWaterMask","hasMetadata","availabilityLevels","availabilityTilesLoaded","littleEndianExtensionSize","availabilityPromiseCache","TerrainProviderBuilder","options","requestVertexNormals","requestWaterMask","requestMetadata","ellipsoid","default","heightmapWidth","heightmapStructure","undefined","scheme","lastResource","layerJsonResource","previousError","tilingScheme","levelZeroMaximumGeometricError","layers","attribution","overallAvailability","overallMaxZoom","tileCredits","prototype","build","provider","_heightmapWidth","_scheme","credits","_tileCredits","concat","_availability","_tilingScheme","_requestWaterMask","_levelZeroMaximumGeometricError","_heightmapStructure","_layers","_hasWaterMask","_hasVertexNormals","_hasMetadata","parseMetadataSuccess","terrainProviderBuilder","data","format","message","reportError","_errorEvent","tiles","length","heightScale","heightOffset","elementsPerHeight","stride","elementMultiplier","isBigEndian","lowestEncodedHeight","highestEncodedHeight","indexOf","maxZoom","maxzoom","Math","max","projection","numberOfLevelZeroTilesX","numberOfLevelZeroTilesY","getEstimatedLevelZeroGeometricErrorForAHeightmap","getNumberOfXTilesAtLevel","extensions","metadataAvailability","availableTiles","available","level","rangesAtLevel","yTiles","getNumberOfYTilesAtLevel","rangeIndex","range","yStart","endY","yEnd","startY","push","startX","endX","addAvailableTileRange","parentUrl","console","log","getDerivedResource","url","appendForwardSlash","requestLayerJson","parseMetadataFailure","error","retry","metadataSuccess","levelRanges","i","layerJsonCredit","fetchJson","statusCode","tilejson","CesiumTerrainProvider","EMPTY_OBJECT","_ellipsoid","_requestVertexNormals","_requestMetadata","credit","_credit","QuantizedMeshExtensionIds","OCT_VERTEX_NORMALS","WATER_MASK","METADATA","getRequestHeader","extensionsList","Accept","join","createHeightmapTerrainData","buffer","x","y","heightBuffer","Uint16Array","childTileMask","Uint8Array","byteLength","waterMask","width","height","structure","createQuantizedMeshTerrainData","pos","cartesian3Elements","boundingSphereElements","cartesian3Length","Float64Array","BYTES_PER_ELEMENT","boundingSphereLength","encodedVertexElements","encodedVertexLength","triangleElements","bytesPerIndex","triangleLength","view","DataView","center","getFloat64","minimumHeight","getFloat32","Float32Array","maximumHeight","boundingSphere","horizonOcclusionPoint","vertexCount","getUint32","Uint32Array","encodedVertexBuffer","uBuffer","subarray","vBuffer","zigZagDeltaDecode","triangleCount","indices","createTypedArrayFromArrayBuffer","highest","code","westVertexCount","westIndices","southVertexCount","southIndices","eastVertexCount","eastIndices","northVertexCount","northIndices","encodedNormalBuffer","waterMaskBuffer","extensionId","getUint8","extensionLength","stringLength","metadata","offset","availableLevel","skirtHeight","getLevelMaximumGeometricError","rectangle","tileXYToRectangle","orientedBoundingBox","fromRectangle","quantizedVertices","encodedNormals","westSkirtHeight","southSkirtHeight","eastSkirtHeight","northSkirtHeight","computeChildMaskForTile","requestTileGeometry","request","layerToUse","layerCount","unknownAvailability","availabilityPromise","Promise","resolve","isTileAvailable","availabilityUnloaded","checkLayer","result","then","promise","setTimeout","reject","urlTemplates","terrainY","extensionList","headers","query","_ionEndpoint","externalType","templateValues","z","queryParameters","fetchArrayBuffer","Object","defineProperties","errorEvent","get","fromIonAssetId","assetId","defined","fromAssetId","fromUrl","createIfNeeded","getTileDataAvailable","_maximumLevel","count","layerResult","loadTileDataAvailability","getAvailabilityTile","parentLevel","divisor","parentX","parentY","topLayer","cacheKey","deleteFromCache","tile","requestPromise","throttle","throttleByServer","type","TERRAIN","_getAvailabilityTile"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 63930, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/createWorldBathymetryAsync.js"],"sourcesContent":["import CesiumTerrainProvider from \"./CesiumTerrainProvider.js\";\nimport Frozen from \"./Frozen.js\";\n\n/**\n * Creates a {@link CesiumTerrainProvider} instance for the {@link https://cesium.com/content/#cesium-world-bathymetry|Cesium World Bathymetry}.\n *\n * @function\n *\n * @param {object} [options] Object with the following properties:\n * @param {boolean} [options.requestVertexNormals=false] Flag that indicates if the client should request additional lighting information from the server if available.\n * @returns {Promise<CesiumTerrainProvider>} A promise that resolves to the created CesiumTerrainProvider\n *\n * @see Ion\n *\n * @example\n * // Create Cesium World Bathymetry with default settings\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.createWorldBathymetryAsync();\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n * @example\n * // Create Cesium World Bathymetry with normals.\n * try {\n *   const viewer1 = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.createWorldBathymetryAsync({\n *       requestVertexNormals: true\n *     });\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n */\nfunction createWorldBathymetryAsync(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  return CesiumTerrainProvider.fromIonAssetId(2426648, {\n    requestVertexNormals: options.requestVertexNormals ?? false,\n  });\n}\nexport default createWorldBathymetryAsync;\n"],"names":["createWorldBathymetryAsync","options","EMPTY_OBJECT","fromIonAssetId","requestVertexNormals"],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiCC,GACD,SAASA,2BAA2BC,OAAO;IACzCA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC,OAAO,2LAAqB,CAACC,cAAc,CAAC,SAAS;QACnDC,sBAAsBH,QAAQG,oBAAoB,IAAI;IACxD;AACF;uCACeJ","ignoreList":[0]}},
    {"offset": {"line": 63982, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/createWorldTerrainAsync.js"],"sourcesContent":["import CesiumTerrainProvider from \"./CesiumTerrainProvider.js\";\nimport Frozen from \"./Frozen.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\n\n/**\n * Creates a {@link CesiumTerrainProvider} instance for the {@link https://cesium.com/content/#cesium-world-terrain|Cesium World Terrain}.\n *\n * @function\n *\n * @param {object} [options] Object with the following properties:\n * @param {boolean} [options.requestVertexNormals=false] Flag that indicates if the client should request additional lighting information from the server if available.\n * @param {boolean} [options.requestWaterMask=false] Flag that indicates if the client should request per tile water masks from the server if available.\n * @returns {Promise<CesiumTerrainProvider>} A promise that resolves to the created CesiumTerrainProvider\n *\n * @see Ion\n *\n * @example\n * // Create Cesium World Terrain with default settings\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.createWorldTerrainAsync();\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n * @example\n * // Create Cesium World Terrain with water and normals.\n * try {\n *   const viewer1 = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.createWorldTerrainAsync({\n *       requestWaterMask: true,\n *       requestVertexNormals: true\n *     });\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n */\nfunction createWorldTerrainAsync(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  return CesiumTerrainProvider.fromIonAssetId(1, {\n    requestVertexNormals: options.requestVertexNormals ?? false,\n    requestWaterMask: options.requestWaterMask ?? false,\n    ellipsoid: Ellipsoid.WGS84,\n  });\n}\nexport default createWorldTerrainAsync;\n"],"names":["createWorldTerrainAsync","options","EMPTY_OBJECT","fromIonAssetId","requestVertexNormals","requestWaterMask","ellipsoid","WGS84"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmCC,GACD,SAASA,wBAAwBC,OAAO;IACtCA,UAAUA,WAAW,4KAAM,CAACC,YAAY;IAExC,OAAO,2LAAqB,CAACC,cAAc,CAAC,GAAG;QAC7CC,sBAAsBH,QAAQG,oBAAoB,IAAI;QACtDC,kBAAkBJ,QAAQI,gBAAgB,IAAI;QAC9CC,WAAW,+KAAS,CAACC,KAAK;IAC5B;AACF;uCACeP","ignoreList":[0]}},
    {"offset": {"line": 64076, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/Core/GeocoderService.js"],"sourcesContent":["import Credit from \"./Credit.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * @typedef {object} GeocoderService.Result\n * @property {string} displayName The display name for a location\n * @property {Rectangle|Cartesian3} destination The bounding box for a location\n * @property {object[]} [attributions]\n */\n\n/**\n * Provides geocoding through an external service. This type describes an interface and\n * is not intended to be used.\n * @alias GeocoderService\n * @constructor\n *\n * @see BingMapsGeocoderService\n * @see PeliasGeocoderService\n * @see OpenCageGeocoderService\n */\nfunction GeocoderService() {\n  DeveloperError.throwInstantiationError();\n}\n\nObject.defineProperties(GeocoderService.prototype, {\n  /**\n   * Gets the credit to display after a geocode is performed. Typically this is used to credit\n   * the geocoder service.\n   * @memberof GeocoderService.prototype\n   * @type {Credit|undefined}\n   * @readonly\n   */\n  credit: {\n    get: DeveloperError.throwInstantiationError,\n  },\n});\n\n/**\n * Parses credits from the geocoder result attributions, if present.\n * @param {GeocoderService.Result} geocoderResult The geocoder result\n * @returns {Credit[]|undefined} A list of credits if present in the result, otherwise undefined\n */\nGeocoderService.getCreditsFromResult = function (geocoderResult) {\n  if (defined(geocoderResult.attributions)) {\n    return geocoderResult.attributions.map(Credit.getIonCredit);\n  }\n\n  return undefined;\n};\n\n/**\n * @function\n *\n * @param {string} query The query to be sent to the geocoder service\n * @param {GeocodeType} [type=GeocodeType.SEARCH] The type of geocode to perform.\n * @returns {Promise<GeocoderService.Result[]>}\n */\nGeocoderService.prototype.geocode = DeveloperError.throwInstantiationError;\nexport default GeocoderService;\n"],"names":["GeocoderService","throwInstantiationError","Object","defineProperties","prototype","credit","get","getCreditsFromResult","geocoderResult","attributions","map","getIonCredit","undefined","geocode"],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;;;CAKC,GAED;;;;;;;;;CASC,GACD,SAASA;IACP,oLAAc,CAACC,uBAAuB;AACxC;AAEAC,OAAOC,gBAAgB,CAACH,gBAAgBI,SAAS,EAAE;IACjD;;;;;;GAMC,GACDC,QAAQ;QACNC,KAAK,oLAAc,CAACL,uBAAuB;IAC7C;AACF;AAEA;;;;CAIC,GACDD,gBAAgBO,oBAAoB,GAAG,SAAUC,cAAc;IAC7D,IAAI,IAAA,6KAAO,EAACA,eAAeC,YAAY,GAAG;QACxC,OAAOD,eAAeC,YAAY,CAACC,GAAG,CAAC,4KAAM,CAACC,YAAY;IAC5D;IAEA,OAAOC;AACT;AAEA;;;;;;CAMC,GACDZ,gBAAgBI,SAAS,CAACS,OAAO,GAAG,oLAAc,CAACZ,uBAAuB;uCAC3DD","ignoreList":[0]}}]
}