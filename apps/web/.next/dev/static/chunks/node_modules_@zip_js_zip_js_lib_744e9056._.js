(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@zip.js/zip.js/lib/core/constants.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BITFLAG_DATA_DESCRIPTOR",
    ()=>BITFLAG_DATA_DESCRIPTOR,
    "BITFLAG_ENCRYPTED",
    ()=>BITFLAG_ENCRYPTED,
    "BITFLAG_LANG_ENCODING_FLAG",
    ()=>BITFLAG_LANG_ENCODING_FLAG,
    "BITFLAG_LEVEL",
    ()=>BITFLAG_LEVEL,
    "BITFLAG_LEVEL_FAST_MASK",
    ()=>BITFLAG_LEVEL_FAST_MASK,
    "BITFLAG_LEVEL_MAX_MASK",
    ()=>BITFLAG_LEVEL_MAX_MASK,
    "BITFLAG_LEVEL_SUPER_FAST_MASK",
    ()=>BITFLAG_LEVEL_SUPER_FAST_MASK,
    "CENTRAL_FILE_HEADER_SIGNATURE",
    ()=>CENTRAL_FILE_HEADER_SIGNATURE,
    "COMPRESSION_METHOD_AES",
    ()=>COMPRESSION_METHOD_AES,
    "COMPRESSION_METHOD_DEFLATE",
    ()=>COMPRESSION_METHOD_DEFLATE,
    "COMPRESSION_METHOD_DEFLATE_64",
    ()=>COMPRESSION_METHOD_DEFLATE_64,
    "COMPRESSION_METHOD_STORE",
    ()=>COMPRESSION_METHOD_STORE,
    "DATA_DESCRIPTOR_RECORD_LENGTH",
    ()=>DATA_DESCRIPTOR_RECORD_LENGTH,
    "DATA_DESCRIPTOR_RECORD_SIGNATURE",
    ()=>DATA_DESCRIPTOR_RECORD_SIGNATURE,
    "DATA_DESCRIPTOR_RECORD_SIGNATURE_LENGTH",
    ()=>DATA_DESCRIPTOR_RECORD_SIGNATURE_LENGTH,
    "DATA_DESCRIPTOR_RECORD_ZIP_64_LENGTH",
    ()=>DATA_DESCRIPTOR_RECORD_ZIP_64_LENGTH,
    "DIRECTORY_SIGNATURE",
    ()=>DIRECTORY_SIGNATURE,
    "END_OF_CENTRAL_DIR_LENGTH",
    ()=>END_OF_CENTRAL_DIR_LENGTH,
    "END_OF_CENTRAL_DIR_SIGNATURE",
    ()=>END_OF_CENTRAL_DIR_SIGNATURE,
    "EXTRAFIELD_TYPE_AES",
    ()=>EXTRAFIELD_TYPE_AES,
    "EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP",
    ()=>EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP,
    "EXTRAFIELD_TYPE_INFOZIP",
    ()=>EXTRAFIELD_TYPE_INFOZIP,
    "EXTRAFIELD_TYPE_NTFS",
    ()=>EXTRAFIELD_TYPE_NTFS,
    "EXTRAFIELD_TYPE_NTFS_TAG1",
    ()=>EXTRAFIELD_TYPE_NTFS_TAG1,
    "EXTRAFIELD_TYPE_UNICODE_COMMENT",
    ()=>EXTRAFIELD_TYPE_UNICODE_COMMENT,
    "EXTRAFIELD_TYPE_UNICODE_PATH",
    ()=>EXTRAFIELD_TYPE_UNICODE_PATH,
    "EXTRAFIELD_TYPE_UNIX",
    ()=>EXTRAFIELD_TYPE_UNIX,
    "EXTRAFIELD_TYPE_USDZ",
    ()=>EXTRAFIELD_TYPE_USDZ,
    "EXTRAFIELD_TYPE_ZIP64",
    ()=>EXTRAFIELD_TYPE_ZIP64,
    "FILE_ATTR_MSDOS_ARCHIVE_MASK",
    ()=>FILE_ATTR_MSDOS_ARCHIVE_MASK,
    "FILE_ATTR_MSDOS_DIR_MASK",
    ()=>FILE_ATTR_MSDOS_DIR_MASK,
    "FILE_ATTR_MSDOS_HIDDEN_MASK",
    ()=>FILE_ATTR_MSDOS_HIDDEN_MASK,
    "FILE_ATTR_MSDOS_READONLY_MASK",
    ()=>FILE_ATTR_MSDOS_READONLY_MASK,
    "FILE_ATTR_MSDOS_SYSTEM_MASK",
    ()=>FILE_ATTR_MSDOS_SYSTEM_MASK,
    "FILE_ATTR_UNIX_DEFAULT_MASK",
    ()=>FILE_ATTR_UNIX_DEFAULT_MASK,
    "FILE_ATTR_UNIX_EXECUTABLE_MASK",
    ()=>FILE_ATTR_UNIX_EXECUTABLE_MASK,
    "FILE_ATTR_UNIX_SETGID_MASK",
    ()=>FILE_ATTR_UNIX_SETGID_MASK,
    "FILE_ATTR_UNIX_SETUID_MASK",
    ()=>FILE_ATTR_UNIX_SETUID_MASK,
    "FILE_ATTR_UNIX_STICKY_MASK",
    ()=>FILE_ATTR_UNIX_STICKY_MASK,
    "FILE_ATTR_UNIX_TYPE_DIR",
    ()=>FILE_ATTR_UNIX_TYPE_DIR,
    "FILE_ATTR_UNIX_TYPE_MASK",
    ()=>FILE_ATTR_UNIX_TYPE_MASK,
    "FUNCTION_TYPE",
    ()=>FUNCTION_TYPE,
    "HEADER_OFFSET_COMPRESSED_SIZE",
    ()=>HEADER_OFFSET_COMPRESSED_SIZE,
    "HEADER_OFFSET_SIGNATURE",
    ()=>HEADER_OFFSET_SIGNATURE,
    "HEADER_OFFSET_UNCOMPRESSED_SIZE",
    ()=>HEADER_OFFSET_UNCOMPRESSED_SIZE,
    "HEADER_SIZE",
    ()=>HEADER_SIZE,
    "LOCAL_FILE_HEADER_SIGNATURE",
    ()=>LOCAL_FILE_HEADER_SIGNATURE,
    "MAX_16_BITS",
    ()=>MAX_16_BITS,
    "MAX_32_BITS",
    ()=>MAX_32_BITS,
    "MAX_8_BITS",
    ()=>MAX_8_BITS,
    "MAX_DATE",
    ()=>MAX_DATE,
    "MIN_DATE",
    ()=>MIN_DATE,
    "OBJECT_TYPE",
    ()=>OBJECT_TYPE,
    "SPLIT_ZIP_FILE_SIGNATURE",
    ()=>SPLIT_ZIP_FILE_SIGNATURE,
    "UNDEFINED_TYPE",
    ()=>UNDEFINED_TYPE,
    "UNDEFINED_VALUE",
    ()=>UNDEFINED_VALUE,
    "VERSION_AES",
    ()=>VERSION_AES,
    "VERSION_DEFLATE",
    ()=>VERSION_DEFLATE,
    "VERSION_ZIP64",
    ()=>VERSION_ZIP64,
    "ZIP64_END_OF_CENTRAL_DIR_LENGTH",
    ()=>ZIP64_END_OF_CENTRAL_DIR_LENGTH,
    "ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH",
    ()=>ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH,
    "ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE",
    ()=>ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE,
    "ZIP64_END_OF_CENTRAL_DIR_SIGNATURE",
    ()=>ZIP64_END_OF_CENTRAL_DIR_SIGNATURE,
    "ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH",
    ()=>ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH
]);
/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ const MAX_32_BITS = 0xffffffff;
const MAX_16_BITS = 0xffff;
const MAX_8_BITS = 0xff;
const COMPRESSION_METHOD_DEFLATE = 0x08;
const COMPRESSION_METHOD_DEFLATE_64 = 0x09;
const COMPRESSION_METHOD_STORE = 0x00;
const COMPRESSION_METHOD_AES = 0x63;
const LOCAL_FILE_HEADER_SIGNATURE = 0x04034b50;
const SPLIT_ZIP_FILE_SIGNATURE = 0x08074b50;
const DATA_DESCRIPTOR_RECORD_SIGNATURE = SPLIT_ZIP_FILE_SIGNATURE;
const CENTRAL_FILE_HEADER_SIGNATURE = 0x02014b50;
const END_OF_CENTRAL_DIR_SIGNATURE = 0x06054b50;
const ZIP64_END_OF_CENTRAL_DIR_SIGNATURE = 0x06064b50;
const ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE = 0x07064b50;
const END_OF_CENTRAL_DIR_LENGTH = 22;
const ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH = 20;
const ZIP64_END_OF_CENTRAL_DIR_LENGTH = 56;
const ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH = END_OF_CENTRAL_DIR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LENGTH;
const DATA_DESCRIPTOR_RECORD_LENGTH = 12;
const DATA_DESCRIPTOR_RECORD_ZIP_64_LENGTH = 20;
const DATA_DESCRIPTOR_RECORD_SIGNATURE_LENGTH = 4;
const EXTRAFIELD_TYPE_ZIP64 = 0x0001;
const EXTRAFIELD_TYPE_AES = 0x9901;
const EXTRAFIELD_TYPE_NTFS = 0x000a;
const EXTRAFIELD_TYPE_NTFS_TAG1 = 0x0001;
const EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP = 0x5455;
const EXTRAFIELD_TYPE_UNICODE_PATH = 0x7075;
const EXTRAFIELD_TYPE_UNICODE_COMMENT = 0x6375;
const EXTRAFIELD_TYPE_USDZ = 0x1986;
const EXTRAFIELD_TYPE_INFOZIP = 0x7875;
const EXTRAFIELD_TYPE_UNIX = 0x7855;
const BITFLAG_ENCRYPTED = 0b1;
const BITFLAG_LEVEL = 0b0110;
const BITFLAG_LEVEL_MAX_MASK = 0b010;
const BITFLAG_LEVEL_FAST_MASK = 0b100;
const BITFLAG_LEVEL_SUPER_FAST_MASK = 0b110;
const BITFLAG_DATA_DESCRIPTOR = 0b1000;
const BITFLAG_LANG_ENCODING_FLAG = 0b100000000000;
const FILE_ATTR_MSDOS_DIR_MASK = 0b10000;
const FILE_ATTR_MSDOS_READONLY_MASK = 0x01;
const FILE_ATTR_MSDOS_HIDDEN_MASK = 0x02;
const FILE_ATTR_MSDOS_SYSTEM_MASK = 0x04;
const FILE_ATTR_MSDOS_ARCHIVE_MASK = 0x20;
const FILE_ATTR_UNIX_TYPE_MASK = 0o170000;
const FILE_ATTR_UNIX_TYPE_DIR = 0o040000;
const FILE_ATTR_UNIX_EXECUTABLE_MASK = 0o111;
const FILE_ATTR_UNIX_DEFAULT_MASK = 0o644;
const FILE_ATTR_UNIX_SETUID_MASK = 0o4000;
const FILE_ATTR_UNIX_SETGID_MASK = 0o2000;
const FILE_ATTR_UNIX_STICKY_MASK = 0o1000;
const VERSION_DEFLATE = 0x14;
const VERSION_ZIP64 = 0x2D;
const VERSION_AES = 0x33;
const DIRECTORY_SIGNATURE = "/";
const HEADER_SIZE = 30;
const HEADER_OFFSET_SIGNATURE = 10;
const HEADER_OFFSET_COMPRESSED_SIZE = 14;
const HEADER_OFFSET_UNCOMPRESSED_SIZE = 18;
const MAX_DATE = new Date(2107, 11, 31);
const MIN_DATE = new Date(1980, 0, 1);
const UNDEFINED_VALUE = undefined;
const UNDEFINED_TYPE = "undefined";
const FUNCTION_TYPE = "function";
const OBJECT_TYPE = "object";
;
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/configuration.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "configure",
    ()=>configure,
    "getChunkSize",
    ()=>getChunkSize,
    "getConfiguration",
    ()=>getConfiguration
]);
/*
 Copyright (c) 2025 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /* global navigator, CompressionStream, DecompressionStream */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/constants.js [app-client] (ecmascript)");
;
const MINIMUM_CHUNK_SIZE = 64;
let maxWorkers = 2;
try {
    if (typeof navigator != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_TYPE"] && navigator.hardwareConcurrency) {
        maxWorkers = navigator.hardwareConcurrency;
    }
} catch  {
// ignored
}
const DEFAULT_CONFIGURATION = {
    workerURI: "./core/web-worker-wasm.js",
    wasmURI: "./core/streams/zlib-wasm/zlib-streams.wasm",
    chunkSize: 64 * 1024,
    maxWorkers,
    terminateWorkerTimeout: 5000,
    useWebWorkers: true,
    useCompressionStream: true,
    CompressionStream: typeof CompressionStream != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_TYPE"] && CompressionStream,
    DecompressionStream: typeof DecompressionStream != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_TYPE"] && DecompressionStream
};
const config = Object.assign({}, DEFAULT_CONFIGURATION);
;
function getConfiguration() {
    return config;
}
function getChunkSize(config) {
    return Math.max(config.chunkSize, MINIMUM_CHUNK_SIZE);
}
function configure(configuration) {
    const { baseURI, chunkSize, maxWorkers, terminateWorkerTimeout, useCompressionStream, useWebWorkers, CompressionStream: CompressionStream1, DecompressionStream: DecompressionStream1, CompressionStreamZlib, DecompressionStreamZlib, workerURI, wasmURI } = configuration;
    setIfDefined("baseURI", baseURI);
    setIfDefined("wasmURI", wasmURI);
    setIfDefined("workerURI", workerURI);
    setIfDefined("chunkSize", chunkSize);
    setIfDefined("maxWorkers", maxWorkers);
    setIfDefined("terminateWorkerTimeout", terminateWorkerTimeout);
    setIfDefined("useCompressionStream", useCompressionStream);
    setIfDefined("useWebWorkers", useWebWorkers);
    setIfDefined("CompressionStream", CompressionStream1);
    setIfDefined("DecompressionStream", DecompressionStream1);
    setIfDefined("CompressionStreamZlib", CompressionStreamZlib);
    setIfDefined("DecompressionStreamZlib", DecompressionStreamZlib);
}
function setIfDefined(propertyName, propertyValue) {
    if (propertyValue !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
        config[propertyName] = propertyValue;
    }
}
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/streams/codecs/crc32.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Crc32",
    ()=>Crc32
]);
/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ const table = [];
for(let i = 0; i < 256; i++){
    let t = i;
    for(let j = 0; j < 8; j++){
        if (t & 1) {
            t = t >>> 1 ^ 0xEDB88320;
        } else {
            t = t >>> 1;
        }
    }
    table[i] = t;
}
class Crc32 {
    constructor(crc){
        this.crc = crc || -1;
    }
    append(data) {
        let crc = this.crc | 0;
        for(let offset = 0, length = data.length | 0; offset < length; offset++){
            crc = crc >>> 8 ^ table[(crc ^ data[offset]) & 0xFF];
        }
        this.crc = crc;
    }
    get() {
        return ~this.crc;
    }
}
;
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/streams/crc32-stream.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Crc32Stream",
    ()=>Crc32Stream
]);
/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /* global TransformStream */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$crc32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/codecs/crc32.js [app-client] (ecmascript)");
;
class Crc32Stream extends TransformStream {
    constructor(){
        // deno-lint-ignore prefer-const
        let stream;
        const crc32 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$crc32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Crc32"]();
        super({
            transform (chunk, controller) {
                crc32.append(chunk);
                controller.enqueue(chunk);
            },
            flush () {
                const value = new Uint8Array(4);
                const dataView = new DataView(value.buffer);
                dataView.setUint32(0, crc32.get());
                stream.value = value;
            }
        });
        stream = this;
    }
}
;
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/util/encode-text.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "encodeText",
    ()=>encodeText
]);
/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /* global TextEncoder */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/constants.js [app-client] (ecmascript)");
;
;
function encodeText(value) {
    // deno-lint-ignore valid-typeof
    if (typeof TextEncoder == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_TYPE"]) {
        value = unescape(encodeURIComponent(value));
        const result = new Uint8Array(value.length);
        for(let i = 0; i < result.length; i++){
            result[i] = value.charCodeAt(i);
        }
        return result;
    } else {
        return new TextEncoder().encode(value);
    }
}
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/streams/codecs/sjcl.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "cipher",
    ()=>cipher,
    "codec",
    ()=>codec,
    "misc",
    ()=>misc,
    "mode",
    ()=>mode,
    "random",
    ()=>random
]);
// Derived from https://github.com/xqdoo00o/jszip/blob/master/lib/sjcl.js and https://github.com/bitwiseshiftleft/sjcl
// deno-lint-ignore-file no-this-alias
/*
 * SJCL is open. You can use, modify and redistribute it under a BSD
 * license or under the GNU GPL, version 2.0.
 */ /** @fileOverview Javascript cryptography implementation.
 *
 * Crush to remove comments, shorten variable names and
 * generally reduce transmission size.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */ /*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */ /** @fileOverview Arrays of bits, encoded as arrays of Numbers.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */ /**
 * Arrays of bits, encoded as arrays of Numbers.
 * @namespace
 * @description
 * <p>
 * These objects are the currency accepted by SJCL's crypto functions.
 * </p>
 *
 * <p>
 * Most of our crypto primitives operate on arrays of 4-byte words internally,
 * but many of them can take arguments that are not a multiple of 4 bytes.
 * This library encodes arrays of bits (whose size need not be a multiple of 8
 * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an
 * array of words, 32 bits at a time.  Since the words are double-precision
 * floating point numbers, they fit some extra data.  We use this (in a private,
 * possibly-changing manner) to encode the number of bits actually  present
 * in the last word of the array.
 * </p>
 *
 * <p>
 * Because bitwise ops clear this out-of-band data, these arrays can be passed
 * to ciphers like AES which want arrays of words.
 * </p>
 */ const bitArray = {
    /**
	 * Concatenate two bit arrays.
	 * @param {bitArray} a1 The first array.
	 * @param {bitArray} a2 The second array.
	 * @return {bitArray} The concatenation of a1 and a2.
	 */ concat (a1, a2) {
        if (a1.length === 0 || a2.length === 0) {
            return a1.concat(a2);
        }
        const last = a1[a1.length - 1], shift = bitArray.getPartial(last);
        if (shift === 32) {
            return a1.concat(a2);
        } else {
            return bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));
        }
    },
    /**
	 * Find the length of an array of bits.
	 * @param {bitArray} a The array.
	 * @return {Number} The length of a, in bits.
	 */ bitLength (a) {
        const l = a.length;
        if (l === 0) {
            return 0;
        }
        const x = a[l - 1];
        return (l - 1) * 32 + bitArray.getPartial(x);
    },
    /**
	 * Truncate an array.
	 * @param {bitArray} a The array.
	 * @param {Number} len The length to truncate to, in bits.
	 * @return {bitArray} A new array, truncated to len bits.
	 */ clamp (a, len) {
        if (a.length * 32 < len) {
            return a;
        }
        a = a.slice(0, Math.ceil(len / 32));
        const l = a.length;
        len = len & 31;
        if (l > 0 && len) {
            a[l - 1] = bitArray.partial(len, a[l - 1] & 0x80000000 >> len - 1, 1);
        }
        return a;
    },
    /**
	 * Make a partial word for a bit array.
	 * @param {Number} len The number of bits in the word.
	 * @param {Number} x The bits.
	 * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.
	 * @return {Number} The partial word.
	 */ partial (len, x, _end) {
        if (len === 32) {
            return x;
        }
        return (_end ? x | 0 : x << 32 - len) + len * 0x10000000000;
    },
    /**
	 * Get the number of bits used by a partial word.
	 * @param {Number} x The partial word.
	 * @return {Number} The number of bits used by the partial word.
	 */ getPartial (x) {
        return Math.round(x / 0x10000000000) || 32;
    },
    /** Shift an array right.
	 * @param {bitArray} a The array to shift.
	 * @param {Number} shift The number of bits to shift.
	 * @param {Number} [carry=0] A byte to carry in
	 * @param {bitArray} [out=[]] An array to prepend to the output.
	 * @private
	 */ _shiftRight (a, shift, carry, out) {
        if (out === undefined) {
            out = [];
        }
        for(; shift >= 32; shift -= 32){
            out.push(carry);
            carry = 0;
        }
        if (shift === 0) {
            return out.concat(a);
        }
        for(let i = 0; i < a.length; i++){
            out.push(carry | a[i] >>> shift);
            carry = a[i] << 32 - shift;
        }
        const last2 = a.length ? a[a.length - 1] : 0;
        const shift2 = bitArray.getPartial(last2);
        out.push(bitArray.partial(shift + shift2 & 31, shift + shift2 > 32 ? carry : out.pop(), 1));
        return out;
    }
};
/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */ /**
 * Arrays of bytes
 * @namespace
 */ const codec = {
    bytes: {
        /** Convert from a bitArray to an array of bytes. */ fromBits (arr) {
            const bl = bitArray.bitLength(arr);
            const byteLength = bl / 8;
            const out = new Uint8Array(byteLength);
            let tmp;
            for(let i = 0; i < byteLength; i++){
                if ((i & 3) === 0) {
                    tmp = arr[i / 4];
                }
                out[i] = tmp >>> 24;
                tmp <<= 8;
            }
            return out;
        },
        /** Convert from an array of bytes to a bitArray. */ toBits (bytes) {
            const out = [];
            let i;
            let tmp = 0;
            for(i = 0; i < bytes.length; i++){
                tmp = tmp << 8 | bytes[i];
                if ((i & 3) === 3) {
                    out.push(tmp);
                    tmp = 0;
                }
            }
            if (i & 3) {
                out.push(bitArray.partial(8 * (i & 3), tmp));
            }
            return out;
        }
    }
};
const hash = {};
/**
 * Context for a SHA-1 operation in progress.
 * @constructor
 */ hash.sha1 = class {
    constructor(hash){
        const sha1 = this;
        /**
		 * The hash's block size, in bits.
		 * @constant
		 */ sha1.blockSize = 512;
        /**
		 * The SHA-1 initialization vector.
		 * @private
		 */ sha1._init = [
            0x67452301,
            0xEFCDAB89,
            0x98BADCFE,
            0x10325476,
            0xC3D2E1F0
        ];
        /**
		 * The SHA-1 hash key.
		 * @private
		 */ sha1._key = [
            0x5A827999,
            0x6ED9EBA1,
            0x8F1BBCDC,
            0xCA62C1D6
        ];
        if (hash) {
            sha1._h = hash._h.slice(0);
            sha1._buffer = hash._buffer.slice(0);
            sha1._length = hash._length;
        } else {
            sha1.reset();
        }
    }
    /**
	 * Reset the hash state.
	 * @return this
	 */ reset() {
        const sha1 = this;
        sha1._h = sha1._init.slice(0);
        sha1._buffer = [];
        sha1._length = 0;
        return sha1;
    }
    /**
	 * Input several words to the hash.
	 * @param {bitArray|String} data the data to hash.
	 * @return this
	 */ update(data) {
        const sha1 = this;
        if (typeof data === "string") {
            data = codec.utf8String.toBits(data);
        }
        const b = sha1._buffer = bitArray.concat(sha1._buffer, data);
        const ol = sha1._length;
        const nl = sha1._length = ol + bitArray.bitLength(data);
        if (nl > 9007199254740991) {
            throw new Error("Cannot hash more than 2^53 - 1 bits");
        }
        const c = new Uint32Array(b);
        let j = 0;
        for(let i = sha1.blockSize + ol - (sha1.blockSize + ol & sha1.blockSize - 1); i <= nl; i += sha1.blockSize){
            sha1._block(c.subarray(16 * j, 16 * (j + 1)));
            j += 1;
        }
        b.splice(0, 16 * j);
        return sha1;
    }
    /**
	 * Complete hashing and output the hash value.
	 * @return {bitArray} The hash value, an array of 5 big-endian words. TODO
	 */ finalize() {
        const sha1 = this;
        let b = sha1._buffer;
        const h = sha1._h;
        // Round out and push the buffer
        b = bitArray.concat(b, [
            bitArray.partial(1, 1)
        ]);
        // Round out the buffer to a multiple of 16 words, less the 2 length words.
        for(let i = b.length + 2; i & 15; i++){
            b.push(0);
        }
        // append the length
        b.push(Math.floor(sha1._length / 0x100000000));
        b.push(sha1._length | 0);
        while(b.length){
            sha1._block(b.splice(0, 16));
        }
        sha1.reset();
        return h;
    }
    /**
	 * The SHA-1 logical functions f(0), f(1), ..., f(79).
	 * @private
	 */ _f(t, b, c, d) {
        if (t <= 19) {
            return b & c | ~b & d;
        } else if (t <= 39) {
            return b ^ c ^ d;
        } else if (t <= 59) {
            return b & c | b & d | c & d;
        } else if (t <= 79) {
            return b ^ c ^ d;
        }
    }
    /**
	 * Circular left-shift operator.
	 * @private
	 */ _S(n, x) {
        return x << n | x >>> 32 - n;
    }
    /**
	 * Perform one cycle of SHA-1.
	 * @param {Uint32Array|bitArray} words one block of words.
	 * @private
	 */ _block(words) {
        const sha1 = this;
        const h = sha1._h;
        // When words is passed to _block, it has 16 elements. SHA1 _block
        // function extends words with new elements (at the end there are 80 elements). 
        // The problem is that if we use Uint32Array instead of Array, 
        // the length of Uint32Array cannot be changed. Thus, we replace words with a 
        // normal Array here.
        const w = Array(80); // do not use Uint32Array here as the instantiation is slower
        for(let j = 0; j < 16; j++){
            w[j] = words[j];
        }
        let a = h[0];
        let b = h[1];
        let c = h[2];
        let d = h[3];
        let e = h[4];
        for(let t = 0; t <= 79; t++){
            if (t >= 16) {
                w[t] = sha1._S(1, w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]);
            }
            const tmp = sha1._S(5, a) + sha1._f(t, b, c, d) + e + w[t] + sha1._key[Math.floor(t / 20)] | 0;
            e = d;
            d = c;
            c = sha1._S(30, b);
            b = a;
            a = tmp;
        }
        h[0] = h[0] + a | 0;
        h[1] = h[1] + b | 0;
        h[2] = h[2] + c | 0;
        h[3] = h[3] + d | 0;
        h[4] = h[4] + e | 0;
    }
};
/** @fileOverview Low-level AES implementation.
 *
 * This file contains a low-level implementation of AES, optimized for
 * size and for efficiency on several browsers.  It is based on
 * OpenSSL's aes_core.c, a public-domain implementation by Vincent
 * Rijmen, Antoon Bosselaers and Paulo Barreto.
 *
 * An older version of this implementation is available in the public
 * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
 * Stanford University 2008-2010 and BSD-licensed for liability
 * reasons.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */ const cipher = {};
/**
 * Schedule out an AES key for both encryption and decryption.  This
 * is a low-level class.  Use a cipher mode to do bulk encryption.
 *
 * @constructor
 * @param {Array} key The key as an array of 4, 6 or 8 words.
 */ cipher.aes = class {
    constructor(key){
        /**
		 * The expanded S-box and inverse S-box tables.  These will be computed
		 * on the client so that we don't have to send them down the wire.
		 *
		 * There are two tables, _tables[0] is for encryption and
		 * _tables[1] is for decryption.
		 *
		 * The first 4 sub-tables are the expanded S-box with MixColumns.  The
		 * last (_tables[01][4]) is the S-box itself.
		 *
		 * @private
		 */ const aes = this;
        aes._tables = [
            [
                [],
                [],
                [],
                [],
                []
            ],
            [
                [],
                [],
                [],
                [],
                []
            ]
        ];
        if (!aes._tables[0][0][0]) {
            aes._precompute();
        }
        const sbox = aes._tables[0][4];
        const decTable = aes._tables[1];
        const keyLen = key.length;
        let i, encKey, decKey, rcon = 1;
        if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
            throw new Error("invalid aes key size");
        }
        aes._key = [
            encKey = key.slice(0),
            decKey = []
        ];
        // schedule encryption keys
        for(i = keyLen; i < 4 * keyLen + 28; i++){
            let tmp = encKey[i - 1];
            // apply sbox
            if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
                tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
                // shift rows and add rcon
                if (i % keyLen === 0) {
                    tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
                    rcon = rcon << 1 ^ (rcon >> 7) * 283;
                }
            }
            encKey[i] = encKey[i - keyLen] ^ tmp;
        }
        // schedule decryption keys
        for(let j = 0; i; j++, i--){
            const tmp = encKey[j & 3 ? i : i - 4];
            if (i <= 4 || j < 4) {
                decKey[j] = tmp;
            } else {
                decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
            }
        }
    }
    // public
    /* Something like this might appear here eventually
	name: "AES",
	blockSize: 4,
	keySizes: [4,6,8],
	*/ /**
	 * Encrypt an array of 4 big-endian words.
	 * @param {Array} data The plaintext.
	 * @return {Array} The ciphertext.
	 */ encrypt(data) {
        return this._crypt(data, 0);
    }
    /**
	 * Decrypt an array of 4 big-endian words.
	 * @param {Array} data The ciphertext.
	 * @return {Array} The plaintext.
	 */ decrypt(data) {
        return this._crypt(data, 1);
    }
    /**
	 * Expand the S-box tables.
	 *
	 * @private
	 */ _precompute() {
        const encTable = this._tables[0];
        const decTable = this._tables[1];
        const sbox = encTable[4];
        const sboxInv = decTable[4];
        const d = [];
        const th = [];
        let xInv, x2, x4, x8;
        // Compute double and third tables
        for(let i = 0; i < 256; i++){
            th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
        }
        for(let x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1){
            // Compute sbox
            let s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
            s = s >> 8 ^ s & 255 ^ 99;
            sbox[x] = s;
            sboxInv[s] = x;
            // Compute MixColumns
            x8 = d[x4 = d[x2 = d[x]]];
            let tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
            let tEnc = d[s] * 0x101 ^ s * 0x1010100;
            for(let i = 0; i < 4; i++){
                encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
                decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
            }
        }
        // Compactify.  Considerable speedup on Firefox.
        for(let i = 0; i < 5; i++){
            encTable[i] = encTable[i].slice(0);
            decTable[i] = decTable[i].slice(0);
        }
    }
    /**
	 * Encryption and decryption core.
	 * @param {Array} input Four words to be encrypted or decrypted.
	 * @param dir The direction, 0 for encrypt and 1 for decrypt.
	 * @return {Array} The four encrypted or decrypted words.
	 * @private
	 */ _crypt(input, dir) {
        if (input.length !== 4) {
            throw new Error("invalid aes block size");
        }
        const key = this._key[dir];
        const nInnerRounds = key.length / 4 - 2;
        const out = [
            0,
            0,
            0,
            0
        ];
        const table = this._tables[dir];
        // load up the tables
        const t0 = table[0];
        const t1 = table[1];
        const t2 = table[2];
        const t3 = table[3];
        const sbox = table[4];
        // state variables a,b,c,d are loaded with pre-whitened data
        let a = input[0] ^ key[0];
        let b = input[dir ? 3 : 1] ^ key[1];
        let c = input[2] ^ key[2];
        let d = input[dir ? 1 : 3] ^ key[3];
        let kIndex = 4;
        let a2, b2, c2;
        // Inner rounds.  Cribbed from OpenSSL.
        for(let i = 0; i < nInnerRounds; i++){
            a2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];
            b2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
            c2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
            d = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
            kIndex += 4;
            a = a2;
            b = b2;
            c = c2;
        }
        // Last round.
        for(let i = 0; i < 4; i++){
            out[dir ? 3 & -i : i] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
            a2 = a;
            a = b;
            b = c;
            c = d;
            d = a2;
        }
        return out;
    }
};
/**
 * Random values
 * @namespace
 */ const random = {
    /** 
	 * Generate random words with pure js, cryptographically not as strong & safe as native implementation.
	 * @param {TypedArray} typedArray The array to fill.
	 * @return {TypedArray} The random values.
	 */ getRandomValues (typedArray) {
        const words = new Uint32Array(typedArray.buffer);
        const r = (m_w)=>{
            let m_z = 0x3ade68b1;
            const mask = 0xffffffff;
            return function() {
                m_z = 0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10) & mask;
                m_w = 0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10) & mask;
                const result = ((m_z << 0x10) + m_w & mask) / 0x100000000 + .5;
                return result * (Math.random() > .5 ? 1 : -1);
            };
        };
        for(let i = 0, rcache; i < typedArray.length; i += 4){
            const _r = r((rcache || Math.random()) * 0x100000000);
            rcache = _r() * 0x3ade67b7;
            words[i / 4] = _r() * 0x100000000 | 0;
        }
        return typedArray;
    }
};
/** @fileOverview CTR mode implementation.
 *
 * Special thanks to Roy Nicholson for pointing out a bug in our
 * implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */ /** Brian Gladman's CTR Mode.
* @constructor
* @param {Object} _prf The aes instance to generate key.
* @param {bitArray} _iv The iv for ctr mode, it must be 128 bits.
*/ const mode = {};
/**
 * Brian Gladman's CTR Mode.
 * @namespace
 */ mode.ctrGladman = class {
    constructor(prf, iv){
        this._prf = prf;
        this._initIv = iv;
        this._iv = iv;
    }
    reset() {
        this._iv = this._initIv;
    }
    /** Input some data to calculate.
	 * @param {bitArray} data the data to process, it must be intergral multiple of 128 bits unless it's the last.
	 */ update(data) {
        return this.calculate(this._prf, data, this._iv);
    }
    incWord(word) {
        if ((word >> 24 & 0xff) === 0xff) {
            let b1 = word >> 16 & 0xff;
            let b2 = word >> 8 & 0xff;
            let b3 = word & 0xff;
            if (b1 === 0xff) {
                b1 = 0;
                if (b2 === 0xff) {
                    b2 = 0;
                    if (b3 === 0xff) {
                        b3 = 0;
                    } else {
                        ++b3;
                    }
                } else {
                    ++b2;
                }
            } else {
                ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
        } else {
            word += 0x01 << 24;
        }
        return word;
    }
    incCounter(counter) {
        if ((counter[0] = this.incWord(counter[0])) === 0) {
            // encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
            counter[1] = this.incWord(counter[1]);
        }
    }
    calculate(prf, data, iv) {
        let l;
        if (!(l = data.length)) {
            return [];
        }
        const bl = bitArray.bitLength(data);
        for(let i = 0; i < l; i += 4){
            this.incCounter(iv);
            const e = prf.encrypt(iv);
            data[i] ^= e[0];
            data[i + 1] ^= e[1];
            data[i + 2] ^= e[2];
            data[i + 3] ^= e[3];
        }
        return bitArray.clamp(data, bl);
    }
};
const misc = {
    importKey (password) {
        return new misc.hmacSha1(codec.bytes.toBits(password));
    },
    pbkdf2 (prf, salt, count, length) {
        count = count || 10000;
        if (length < 0 || count < 0) {
            throw new Error("invalid params to pbkdf2");
        }
        const byteLength = (length >> 5) + 1 << 2;
        let u, ui, i, j, k;
        const arrayBuffer = new ArrayBuffer(byteLength);
        const out = new DataView(arrayBuffer);
        let outLength = 0;
        const b = bitArray;
        salt = codec.bytes.toBits(salt);
        for(k = 1; outLength < (byteLength || 1); k++){
            u = ui = prf.encrypt(b.concat(salt, [
                k
            ]));
            for(i = 1; i < count; i++){
                ui = prf.encrypt(ui);
                for(j = 0; j < ui.length; j++){
                    u[j] ^= ui[j];
                }
            }
            for(i = 0; outLength < (byteLength || 1) && i < u.length; i++){
                out.setInt32(outLength, u[i]);
                outLength += 4;
            }
        }
        return arrayBuffer.slice(0, length / 8);
    }
};
/** @fileOverview HMAC implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */ /** HMAC with the specified hash function.
 * @constructor
 * @param {bitArray} key the key for HMAC.
 * @param {Object} [Hash=hash.sha1] The hash function to use.
 */ misc.hmacSha1 = class {
    constructor(key){
        const hmac = this;
        const Hash = hmac._hash = hash.sha1;
        const exKey = [
            [],
            []
        ];
        hmac._baseHash = [
            new Hash(),
            new Hash()
        ];
        const bs = hmac._baseHash[0].blockSize / 32;
        if (key.length > bs) {
            key = new Hash().update(key).finalize();
        }
        for(let i = 0; i < bs; i++){
            exKey[0][i] = key[i] ^ 0x36363636;
            exKey[1][i] = key[i] ^ 0x5C5C5C5C;
        }
        hmac._baseHash[0].update(exKey[0]);
        hmac._baseHash[1].update(exKey[1]);
        hmac._resultHash = new Hash(hmac._baseHash[0]);
    }
    reset() {
        const hmac = this;
        hmac._resultHash = new hmac._hash(hmac._baseHash[0]);
        hmac._updated = false;
    }
    update(data) {
        const hmac = this;
        hmac._updated = true;
        hmac._resultHash.update(data);
    }
    digest() {
        const hmac = this;
        const w = hmac._resultHash.finalize();
        const result = new hmac._hash(hmac._baseHash[1]).update(w).finalize();
        hmac.reset();
        return result;
    }
    encrypt(data) {
        if (!this._updated) {
            this.update(data);
            return this.digest(data);
        } else {
            throw new Error("encrypt on already updated hmac called!");
        }
    }
};
;
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/streams/common-crypto.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ERR_ABORT_CHECK_PASSWORD",
    ()=>ERR_ABORT_CHECK_PASSWORD,
    "ERR_INVALID_PASSWORD",
    ()=>ERR_INVALID_PASSWORD,
    "ERR_INVALID_SIGNATURE",
    ()=>ERR_INVALID_SIGNATURE,
    "getRandomValues",
    ()=>getRandomValues
]);
/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /* global crypto */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$sjcl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/codecs/sjcl.js [app-client] (ecmascript)");
;
;
const GET_RANDOM_VALUES_SUPPORTED = typeof crypto != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_TYPE"] && typeof crypto.getRandomValues == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FUNCTION_TYPE"];
const ERR_INVALID_PASSWORD = "Invalid password";
const ERR_INVALID_SIGNATURE = "Invalid signature";
const ERR_ABORT_CHECK_PASSWORD = "zipjs-abort-check-password";
;
function getRandomValues(array) {
    if (GET_RANDOM_VALUES_SUPPORTED) {
        return crypto.getRandomValues(array);
    } else {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$sjcl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["random"].getRandomValues(array);
    }
}
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/streams/aes-crypto-stream.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AESDecryptionStream",
    ()=>AESDecryptionStream,
    "AESEncryptionStream",
    ()=>AESEncryptionStream
]);
/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /* global crypto, TransformStream */ // deno-lint-ignore-file no-this-alias
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$util$2f$encode$2d$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/util/encode-text.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$sjcl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/codecs/sjcl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/common-crypto.js [app-client] (ecmascript)");
;
;
;
;
const BLOCK_LENGTH = 16;
const RAW_FORMAT = "raw";
const PBKDF2_ALGORITHM = {
    name: "PBKDF2"
};
const HASH_ALGORITHM = {
    name: "HMAC"
};
const HASH_FUNCTION = "SHA-1";
const BASE_KEY_ALGORITHM = Object.assign({
    hash: HASH_ALGORITHM
}, PBKDF2_ALGORITHM);
const DERIVED_BITS_ALGORITHM = Object.assign({
    iterations: 1000,
    hash: {
        name: HASH_FUNCTION
    }
}, PBKDF2_ALGORITHM);
const DERIVED_BITS_USAGE = [
    "deriveBits"
];
const SALT_LENGTH = [
    8,
    12,
    16
];
const KEY_LENGTH = [
    16,
    24,
    32
];
const SIGNATURE_LENGTH = 10;
const COUNTER_DEFAULT_VALUE = [
    0,
    0,
    0,
    0
];
// deno-lint-ignore valid-typeof
const CRYPTO_API_SUPPORTED = typeof crypto != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_TYPE"];
const subtle = CRYPTO_API_SUPPORTED && crypto.subtle;
const SUBTLE_API_SUPPORTED = CRYPTO_API_SUPPORTED && typeof subtle != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_TYPE"];
const codecBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$sjcl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codec"].bytes;
const Aes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$sjcl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cipher"].aes;
const CtrGladman = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$sjcl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mode"].ctrGladman;
const HmacSha1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$sjcl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["misc"].hmacSha1;
let IMPORT_KEY_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.importKey == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FUNCTION_TYPE"];
let DERIVE_BITS_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.deriveBits == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FUNCTION_TYPE"];
class AESDecryptionStream extends TransformStream {
    constructor({ password, rawPassword, signed, encryptionStrength, checkPasswordOnly }){
        super({
            start () {
                Object.assign(this, {
                    ready: new Promise((resolve)=>this.resolveReady = resolve),
                    password: encodePassword(password, rawPassword),
                    signed,
                    strength: encryptionStrength - 1,
                    pending: new Uint8Array()
                });
            },
            async transform (chunk, controller) {
                const aesCrypto = this;
                const { password, strength, resolveReady, ready } = aesCrypto;
                if (password) {
                    await createDecryptionKeys(aesCrypto, strength, password, subarray(chunk, 0, SALT_LENGTH[strength] + 2));
                    chunk = subarray(chunk, SALT_LENGTH[strength] + 2);
                    if (checkPasswordOnly) {
                        controller.error(new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_ABORT_CHECK_PASSWORD"]));
                    } else {
                        resolveReady();
                    }
                } else {
                    await ready;
                }
                const output = new Uint8Array(chunk.length - SIGNATURE_LENGTH - (chunk.length - SIGNATURE_LENGTH) % BLOCK_LENGTH);
                controller.enqueue(append(aesCrypto, chunk, output, 0, SIGNATURE_LENGTH, true));
            },
            async flush (controller) {
                const { signed, ctr, hmac, pending, ready } = this;
                if (hmac && ctr) {
                    await ready;
                    const chunkToDecrypt = subarray(pending, 0, pending.length - SIGNATURE_LENGTH);
                    const originalSignature = subarray(pending, pending.length - SIGNATURE_LENGTH);
                    let decryptedChunkArray = new Uint8Array();
                    if (chunkToDecrypt.length) {
                        const encryptedChunk = toBits(codecBytes, chunkToDecrypt);
                        hmac.update(encryptedChunk);
                        const decryptedChunk = ctr.update(encryptedChunk);
                        decryptedChunkArray = fromBits(codecBytes, decryptedChunk);
                    }
                    if (signed) {
                        const signature = subarray(fromBits(codecBytes, hmac.digest()), 0, SIGNATURE_LENGTH);
                        for(let indexSignature = 0; indexSignature < SIGNATURE_LENGTH; indexSignature++){
                            if (signature[indexSignature] != originalSignature[indexSignature]) {
                                throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_SIGNATURE"]);
                            }
                        }
                    }
                    controller.enqueue(decryptedChunkArray);
                }
            }
        });
    }
}
class AESEncryptionStream extends TransformStream {
    constructor({ password, rawPassword, encryptionStrength }){
        // deno-lint-ignore prefer-const
        let stream;
        super({
            start () {
                Object.assign(this, {
                    ready: new Promise((resolve)=>this.resolveReady = resolve),
                    password: encodePassword(password, rawPassword),
                    strength: encryptionStrength - 1,
                    pending: new Uint8Array()
                });
            },
            async transform (chunk, controller) {
                const aesCrypto = this;
                const { password, strength, resolveReady, ready } = aesCrypto;
                let preamble = new Uint8Array();
                if (password) {
                    preamble = await createEncryptionKeys(aesCrypto, strength, password);
                    resolveReady();
                } else {
                    await ready;
                }
                const output = new Uint8Array(preamble.length + chunk.length - chunk.length % BLOCK_LENGTH);
                output.set(preamble, 0);
                controller.enqueue(append(aesCrypto, chunk, output, preamble.length, 0));
            },
            async flush (controller) {
                const { ctr, hmac, pending, ready } = this;
                if (hmac && ctr) {
                    await ready;
                    let encryptedChunkArray = new Uint8Array();
                    if (pending.length) {
                        const encryptedChunk = ctr.update(toBits(codecBytes, pending));
                        hmac.update(encryptedChunk);
                        encryptedChunkArray = fromBits(codecBytes, encryptedChunk);
                    }
                    stream.signature = fromBits(codecBytes, hmac.digest()).slice(0, SIGNATURE_LENGTH);
                    controller.enqueue(concat(encryptedChunkArray, stream.signature));
                }
            }
        });
        stream = this;
    }
}
;
function append(aesCrypto, input, output, paddingStart, paddingEnd, verifySignature) {
    const { ctr, hmac, pending } = aesCrypto;
    const inputLength = input.length - paddingEnd;
    if (pending.length) {
        input = concat(pending, input);
        output = expand(output, inputLength - inputLength % BLOCK_LENGTH);
    }
    let offset;
    for(offset = 0; offset <= inputLength - BLOCK_LENGTH; offset += BLOCK_LENGTH){
        const inputChunk = toBits(codecBytes, subarray(input, offset, offset + BLOCK_LENGTH));
        if (verifySignature) {
            hmac.update(inputChunk);
        }
        const outputChunk = ctr.update(inputChunk);
        if (!verifySignature) {
            hmac.update(outputChunk);
        }
        output.set(fromBits(codecBytes, outputChunk), offset + paddingStart);
    }
    aesCrypto.pending = subarray(input, offset);
    return output;
}
async function createDecryptionKeys(decrypt, strength, password, preamble) {
    const passwordVerificationKey = await createKeys(decrypt, strength, password, subarray(preamble, 0, SALT_LENGTH[strength]));
    const passwordVerification = subarray(preamble, SALT_LENGTH[strength]);
    if (passwordVerificationKey[0] != passwordVerification[0] || passwordVerificationKey[1] != passwordVerification[1]) {
        throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_PASSWORD"]);
    }
}
async function createEncryptionKeys(encrypt, strength, password) {
    const salt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRandomValues"])(new Uint8Array(SALT_LENGTH[strength]));
    const passwordVerification = await createKeys(encrypt, strength, password, salt);
    return concat(salt, passwordVerification);
}
async function createKeys(aesCrypto, strength, password, salt) {
    aesCrypto.password = null;
    const baseKey = await importKey(RAW_FORMAT, password, BASE_KEY_ALGORITHM, false, DERIVED_BITS_USAGE);
    const derivedBits = await deriveBits(Object.assign({
        salt
    }, DERIVED_BITS_ALGORITHM), baseKey, 8 * (KEY_LENGTH[strength] * 2 + 2));
    const compositeKey = new Uint8Array(derivedBits);
    const key = toBits(codecBytes, subarray(compositeKey, 0, KEY_LENGTH[strength]));
    const authentication = toBits(codecBytes, subarray(compositeKey, KEY_LENGTH[strength], KEY_LENGTH[strength] * 2));
    const passwordVerification = subarray(compositeKey, KEY_LENGTH[strength] * 2);
    Object.assign(aesCrypto, {
        keys: {
            key,
            authentication,
            passwordVerification
        },
        ctr: new CtrGladman(new Aes(key), Array.from(COUNTER_DEFAULT_VALUE)),
        hmac: new HmacSha1(authentication)
    });
    return passwordVerification;
}
async function importKey(format, password, algorithm, extractable, keyUsages) {
    if (IMPORT_KEY_SUPPORTED) {
        try {
            return await subtle.importKey(format, password, algorithm, extractable, keyUsages);
        } catch  {
            IMPORT_KEY_SUPPORTED = false;
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$sjcl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["misc"].importKey(password);
        }
    } else {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$sjcl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["misc"].importKey(password);
    }
}
async function deriveBits(algorithm, baseKey, length) {
    if (DERIVE_BITS_SUPPORTED) {
        try {
            return await subtle.deriveBits(algorithm, baseKey, length);
        } catch  {
            DERIVE_BITS_SUPPORTED = false;
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$sjcl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["misc"].pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
        }
    } else {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$sjcl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["misc"].pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
    }
}
function encodePassword(password, rawPassword) {
    if (rawPassword === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$util$2f$encode$2d$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeText"])(password);
    } else {
        return rawPassword;
    }
}
function concat(leftArray, rightArray) {
    let array = leftArray;
    if (leftArray.length + rightArray.length) {
        array = new Uint8Array(leftArray.length + rightArray.length);
        array.set(leftArray, 0);
        array.set(rightArray, leftArray.length);
    }
    return array;
}
function expand(inputArray, length) {
    if (length && length > inputArray.length) {
        const array = inputArray;
        inputArray = new Uint8Array(length);
        inputArray.set(array, 0);
    }
    return inputArray;
}
function subarray(array, begin, end) {
    return array.subarray(begin, end);
}
function fromBits(codecBytes, chunk) {
    return codecBytes.fromBits(chunk);
}
function toBits(codecBytes, chunk) {
    return codecBytes.toBits(chunk);
}
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/streams/zip-crypto-stream.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ZipCryptoDecryptionStream",
    ()=>ZipCryptoDecryptionStream,
    "ZipCryptoEncryptionStream",
    ()=>ZipCryptoEncryptionStream
]);
/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /* global TransformStream */ // deno-lint-ignore-file no-this-alias
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$crc32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/codecs/crc32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/common-crypto.js [app-client] (ecmascript)");
;
;
const HEADER_LENGTH = 12;
class ZipCryptoDecryptionStream extends TransformStream {
    constructor({ password, passwordVerification, checkPasswordOnly }){
        super({
            start () {
                Object.assign(this, {
                    password,
                    passwordVerification
                });
                createKeys(this, password);
            },
            transform (chunk, controller) {
                const zipCrypto = this;
                if (zipCrypto.password) {
                    const decryptedHeader = decrypt(zipCrypto, chunk.subarray(0, HEADER_LENGTH));
                    zipCrypto.password = null;
                    if (decryptedHeader.at(-1) != zipCrypto.passwordVerification) {
                        throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_PASSWORD"]);
                    }
                    chunk = chunk.subarray(HEADER_LENGTH);
                }
                if (checkPasswordOnly) {
                    controller.error(new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_ABORT_CHECK_PASSWORD"]));
                } else {
                    controller.enqueue(decrypt(zipCrypto, chunk));
                }
            }
        });
    }
}
class ZipCryptoEncryptionStream extends TransformStream {
    constructor({ password, passwordVerification }){
        super({
            start () {
                Object.assign(this, {
                    password,
                    passwordVerification
                });
                createKeys(this, password);
            },
            transform (chunk, controller) {
                const zipCrypto = this;
                let output;
                let offset;
                if (zipCrypto.password) {
                    zipCrypto.password = null;
                    const header = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRandomValues"])(new Uint8Array(HEADER_LENGTH));
                    header[HEADER_LENGTH - 1] = zipCrypto.passwordVerification;
                    output = new Uint8Array(chunk.length + header.length);
                    output.set(encrypt(zipCrypto, header), 0);
                    offset = HEADER_LENGTH;
                } else {
                    output = new Uint8Array(chunk.length);
                    offset = 0;
                }
                output.set(encrypt(zipCrypto, chunk), offset);
                controller.enqueue(output);
            }
        });
    }
}
;
function decrypt(target, input) {
    const output = new Uint8Array(input.length);
    for(let index = 0; index < input.length; index++){
        output[index] = getByte(target) ^ input[index];
        updateKeys(target, output[index]);
    }
    return output;
}
function encrypt(target, input) {
    const output = new Uint8Array(input.length);
    for(let index = 0; index < input.length; index++){
        output[index] = getByte(target) ^ input[index];
        updateKeys(target, input[index]);
    }
    return output;
}
function createKeys(target, password) {
    const keys = [
        0x12345678,
        0x23456789,
        0x34567890
    ];
    Object.assign(target, {
        keys,
        crcKey0: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$crc32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Crc32"](keys[0]),
        crcKey2: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$crc32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Crc32"](keys[2])
    });
    for(let index = 0; index < password.length; index++){
        updateKeys(target, password.charCodeAt(index));
    }
}
function updateKeys(target, byte) {
    let [key0, key1, key2] = target.keys;
    target.crcKey0.append([
        byte
    ]);
    key0 = ~target.crcKey0.get();
    key1 = getInt32(Math.imul(getInt32(key1 + getInt8(key0)), 134775813) + 1);
    target.crcKey2.append([
        key1 >>> 24
    ]);
    key2 = ~target.crcKey2.get();
    target.keys = [
        key0,
        key1,
        key2
    ];
}
function getByte(target) {
    const temp = target.keys[2] | 2;
    return getInt8(Math.imul(temp, temp ^ 1) >>> 8);
}
function getInt8(number) {
    return number & 0xFF;
}
function getInt32(number) {
    return number & 0xFFFFFFFF;
}
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/streams/zip-entry-stream.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DeflateStream",
    ()=>DeflateStream,
    "ERR_INVALID_UNCOMPRESSED_SIZE",
    ()=>ERR_INVALID_UNCOMPRESSED_SIZE,
    "InflateStream",
    ()=>InflateStream
]);
/*
 Copyright (c) 2025 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /* global TransformStream */ // deno-lint-ignore-file no-this-alias
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$crc32$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/crc32-stream.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$aes$2d$crypto$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/aes-crypto-stream.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zip$2d$crypto$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/zip-crypto-stream.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/common-crypto.js [app-client] (ecmascript)");
;
;
;
;
const ERR_INVALID_UNCOMPRESSED_SIZE = "Invalid uncompressed size";
const FORMAT_DEFLATE_RAW = "deflate-raw";
const FORMAT_DEFLATE64_RAW = "deflate64-raw";
class DeflateStream extends TransformStream {
    constructor(options, { chunkSize, CompressionStreamZlib, CompressionStream }){
        super({});
        const { compressed, encrypted, useCompressionStream, zipCrypto, signed, level } = options;
        const stream = this;
        let crc32Stream, encryptionStream;
        let readable = super.readable;
        if ((!encrypted || zipCrypto) && signed) {
            crc32Stream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$crc32$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Crc32Stream"]();
            readable = pipeThrough(readable, crc32Stream);
        }
        if (compressed) {
            readable = pipeThroughCommpressionStream(readable, useCompressionStream, {
                level,
                chunkSize
            }, CompressionStream, CompressionStreamZlib, CompressionStream);
        }
        if (encrypted) {
            if (zipCrypto) {
                readable = pipeThrough(readable, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zip$2d$crypto$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ZipCryptoEncryptionStream"](options));
            } else {
                encryptionStream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$aes$2d$crypto$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["AESEncryptionStream"](options);
                readable = pipeThrough(readable, encryptionStream);
            }
        }
        setReadable(stream, readable, ()=>{
            let signature;
            if (encrypted && !zipCrypto) {
                signature = encryptionStream.signature;
            }
            if ((!encrypted || zipCrypto) && signed) {
                signature = new DataView(crc32Stream.value.buffer).getUint32(0);
            }
            stream.signature = signature;
        });
    }
}
class InflateStream extends TransformStream {
    constructor(options, { chunkSize, DecompressionStreamZlib, DecompressionStream }){
        super({});
        const { zipCrypto, encrypted, signed, signature, compressed, useCompressionStream, deflate64 } = options;
        let crc32Stream, decryptionStream;
        let readable = super.readable;
        if (encrypted) {
            if (zipCrypto) {
                readable = pipeThrough(readable, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zip$2d$crypto$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ZipCryptoDecryptionStream"](options));
            } else {
                decryptionStream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$aes$2d$crypto$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["AESDecryptionStream"](options);
                readable = pipeThrough(readable, decryptionStream);
            }
        }
        if (compressed) {
            readable = pipeThroughCommpressionStream(readable, useCompressionStream, {
                chunkSize,
                deflate64
            }, DecompressionStream, DecompressionStreamZlib, DecompressionStream);
        }
        if ((!encrypted || zipCrypto) && signed) {
            crc32Stream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$crc32$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Crc32Stream"]();
            readable = pipeThrough(readable, crc32Stream);
        }
        setReadable(this, readable, ()=>{
            if ((!encrypted || zipCrypto) && signed) {
                const dataViewSignature = new DataView(crc32Stream.value.buffer);
                if (signature != dataViewSignature.getUint32(0, false)) {
                    throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_SIGNATURE"]);
                }
            }
        });
    }
}
;
function setReadable(stream, readable, flush) {
    readable = pipeThrough(readable, new TransformStream({
        flush
    }));
    Object.defineProperty(stream, "readable", {
        get () {
            return readable;
        }
    });
}
function pipeThroughCommpressionStream(readable, useCompressionStream, options, CompressionStreamNative, CompressionStreamZlib, CompressionStream) {
    const Stream = useCompressionStream && CompressionStreamNative ? CompressionStreamNative : CompressionStreamZlib || CompressionStream;
    const format = options.deflate64 ? FORMAT_DEFLATE64_RAW : FORMAT_DEFLATE_RAW;
    try {
        readable = pipeThrough(readable, new Stream(format, options));
    } catch (error) {
        if (useCompressionStream) {
            if (CompressionStreamZlib) {
                readable = pipeThrough(readable, new CompressionStreamZlib(format, options));
            } else if (CompressionStream) {
                readable = pipeThrough(readable, new CompressionStream(format, options));
            } else {
                throw error;
            }
        } else {
            throw error;
        }
    }
    return readable;
}
function pipeThrough(readable, transformStream) {
    return readable.pipeThrough(transformStream);
}
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/streams/codec-stream.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CODEC_DEFLATE",
    ()=>CODEC_DEFLATE,
    "CODEC_INFLATE",
    ()=>CODEC_INFLATE,
    "ChunkStream",
    ()=>ChunkStream,
    "CodecStream",
    ()=>CodecStream,
    "MESSAGE_ACK_DATA",
    ()=>MESSAGE_ACK_DATA,
    "MESSAGE_CLOSE",
    ()=>MESSAGE_CLOSE,
    "MESSAGE_DATA",
    ()=>MESSAGE_DATA,
    "MESSAGE_EVENT_TYPE",
    ()=>MESSAGE_EVENT_TYPE,
    "MESSAGE_PULL",
    ()=>MESSAGE_PULL,
    "MESSAGE_START",
    ()=>MESSAGE_START
]);
/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /*
 * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.
 * JZlib is based on zlib-1.1.3, so all credit should go authors
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
 * and contributors of zlib.
 */ /* global TransformStream */ // deno-lint-ignore-file no-this-alias
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zip$2d$entry$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/zip-entry-stream.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/common-crypto.js [app-client] (ecmascript)");
;
;
const MESSAGE_EVENT_TYPE = "message";
const MESSAGE_START = "start";
const MESSAGE_PULL = "pull";
const MESSAGE_DATA = "data";
const MESSAGE_ACK_DATA = "ack";
const MESSAGE_CLOSE = "close";
const CODEC_DEFLATE = "deflate";
const CODEC_INFLATE = "inflate";
;
class CodecStream extends TransformStream {
    constructor(options, config){
        super({});
        const codec = this;
        const { codecType } = options;
        let Stream;
        if (codecType.startsWith(CODEC_DEFLATE)) {
            Stream = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zip$2d$entry$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DeflateStream"];
        } else if (codecType.startsWith(CODEC_INFLATE)) {
            Stream = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zip$2d$entry$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["InflateStream"];
        }
        codec.outputSize = 0;
        let inputSize = 0;
        const stream = new Stream(options, config);
        const readable = super.readable;
        const inputSizeStream = new TransformStream({
            transform (chunk, controller) {
                if (chunk && chunk.length) {
                    inputSize += chunk.length;
                    controller.enqueue(chunk);
                }
            },
            flush () {
                Object.assign(codec, {
                    inputSize
                });
            }
        });
        const outputSizeStream = new TransformStream({
            transform (chunk, controller) {
                if (chunk && chunk.length) {
                    controller.enqueue(chunk);
                    codec.outputSize += chunk.length;
                    if (options.outputSize !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && codec.outputSize > options.outputSize) {
                        throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zip$2d$entry$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ERR_INVALID_UNCOMPRESSED_SIZE"]);
                    }
                }
            },
            flush () {
                const { signature } = stream;
                Object.assign(codec, {
                    signature,
                    inputSize
                });
            }
        });
        Object.defineProperty(codec, "readable", {
            get () {
                return readable.pipeThrough(inputSizeStream).pipeThrough(stream).pipeThrough(outputSizeStream);
            }
        });
    }
}
class ChunkStream extends TransformStream {
    constructor(chunkSize){
        let pendingChunk;
        super({
            transform,
            flush (controller) {
                if (pendingChunk && pendingChunk.length) {
                    controller.enqueue(pendingChunk);
                }
            }
        });
        function transform(chunk, controller) {
            if (pendingChunk) {
                const newChunk = new Uint8Array(pendingChunk.length + chunk.length);
                newChunk.set(pendingChunk);
                newChunk.set(chunk, pendingChunk.length);
                chunk = newChunk;
                pendingChunk = null;
            }
            if (chunk.length > chunkSize) {
                controller.enqueue(chunk.slice(0, chunkSize));
                transform(chunk.slice(chunkSize), controller);
            } else {
                pendingChunk = chunk;
            }
        }
    }
}
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/codec-worker.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CodecWorker",
    ()=>CodecWorker,
    "configureWorker",
    ()=>configureWorker
]);
/*
 Copyright (c) 2025 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /* global Worker, URL, TransformStream, WritableStream */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codec$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/codec-stream.js [app-client] (ecmascript) <locals>");
;
;
// deno-lint-ignore valid-typeof
let WEB_WORKERS_SUPPORTED = typeof Worker != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_TYPE"];
let initModule = ()=>{};
;
function configureWorker({ initModule: initModuleFunction }) {
    initModule = initModuleFunction;
}
class CodecWorker {
    constructor(workerData, { readable, writable }, { options, config, streamOptions, useWebWorkers, transferStreams, workerURI }, onTaskFinished){
        const { signal } = streamOptions;
        Object.assign(workerData, {
            busy: true,
            readable: readable.pipeThrough(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codec$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ChunkStream"](config.chunkSize)).pipeThrough(new ProgressWatcherStream(streamOptions), {
                signal
            }),
            writable,
            options: Object.assign({}, options),
            workerURI,
            transferStreams,
            terminate () {
                return new Promise((resolve)=>{
                    const { worker, busy } = workerData;
                    if (worker) {
                        if (busy) {
                            workerData.resolveTerminated = resolve;
                        } else {
                            worker.terminate();
                            resolve();
                        }
                        workerData.interface = null;
                    } else {
                        resolve();
                    }
                });
            },
            onTaskFinished () {
                const { resolveTerminated } = workerData;
                if (resolveTerminated) {
                    workerData.resolveTerminated = null;
                    workerData.terminated = true;
                    workerData.worker.terminate();
                    resolveTerminated();
                }
                workerData.busy = false;
                onTaskFinished(workerData);
            }
        });
        return (useWebWorkers && WEB_WORKERS_SUPPORTED ? createWebWorkerInterface : createWorkerInterface)(workerData, config);
    }
}
class ProgressWatcherStream extends TransformStream {
    constructor({ onstart, onprogress, size, onend }){
        let chunkOffset = 0;
        super({
            async start () {
                if (onstart) {
                    await callHandler(onstart, size);
                }
            },
            async transform (chunk, controller) {
                chunkOffset += chunk.length;
                if (onprogress) {
                    await callHandler(onprogress, chunkOffset, size);
                }
                controller.enqueue(chunk);
            },
            async flush () {
                if (onend) {
                    await callHandler(onend, chunkOffset);
                }
            }
        });
    }
}
async function callHandler(handler, ...parameters) {
    try {
        await handler(...parameters);
    } catch  {
    // ignored
    }
}
function createWorkerInterface(workerData, config) {
    return {
        run: ()=>runWorker(workerData, config)
    };
}
function createWebWorkerInterface(workerData, config) {
    const { baseURI, chunkSize } = config;
    let { wasmURI } = config;
    if (!workerData.interface) {
        // deno-lint-ignore valid-typeof
        if (typeof wasmURI == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FUNCTION_TYPE"]) {
            wasmURI = wasmURI();
        }
        let worker;
        try {
            worker = getWebWorker(workerData.workerURI, baseURI, workerData);
        } catch  {
            WEB_WORKERS_SUPPORTED = false;
            return createWorkerInterface(workerData, config);
        }
        Object.assign(workerData, {
            worker,
            interface: {
                run: ()=>runWebWorker(workerData, {
                        chunkSize,
                        wasmURI,
                        baseURI
                    })
            }
        });
    }
    return workerData.interface;
}
async function runWorker({ options, readable, writable, onTaskFinished }, config) {
    let codecStream;
    try {
        if (!options.useCompressionStream) {
            try {
                await initModule(config);
            } catch  {
                options.useCompressionStream = true;
            }
        }
        codecStream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codec$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CodecStream"](options, config);
        await readable.pipeThrough(codecStream).pipeTo(writable, {
            preventClose: true,
            preventAbort: true
        });
        const { signature, inputSize, outputSize } = codecStream;
        return {
            signature,
            inputSize,
            outputSize
        };
    } catch (error) {
        if (codecStream) {
            error.outputSize = codecStream.outputSize;
        }
        throw error;
    } finally{
        onTaskFinished();
    }
}
async function runWebWorker(workerData, config) {
    let resolveResult, rejectResult;
    const result = new Promise((resolve, reject)=>{
        resolveResult = resolve;
        rejectResult = reject;
    });
    Object.assign(workerData, {
        reader: null,
        writer: null,
        resolveResult,
        rejectResult,
        result
    });
    const { readable, options } = workerData;
    const { writable, closed } = watchClosedStream(workerData.writable);
    const streamsTransferred = sendMessage({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codec$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MESSAGE_START"],
        options,
        config,
        readable,
        writable
    }, workerData);
    if (!streamsTransferred) {
        Object.assign(workerData, {
            reader: readable.getReader(),
            writer: writable.getWriter()
        });
    }
    const resultValue = await result;
    if (!streamsTransferred) {
        await writable.getWriter().close();
    }
    await closed;
    return resultValue;
}
function watchClosedStream(writableSource) {
    let resolveStreamClosed;
    const closed = new Promise((resolve)=>resolveStreamClosed = resolve);
    const writable = new WritableStream({
        async write (chunk) {
            const writer = writableSource.getWriter();
            await writer.ready;
            await writer.write(chunk);
            writer.releaseLock();
        },
        close () {
            resolveStreamClosed();
        },
        abort (reason) {
            const writer = writableSource.getWriter();
            return writer.abort(reason);
        }
    });
    return {
        writable,
        closed
    };
}
let transferStreamsSupported = true;
function getWebWorker(url, baseURI, workerData) {
    const workerOptions = {
        type: "module"
    };
    let scriptUrl, worker;
    // deno-lint-ignore valid-typeof
    if (typeof url == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FUNCTION_TYPE"]) {
        url = url();
    }
    if (url.startsWith("data:") || url.startsWith("blob:")) {
        try {
            worker = new Worker(url);
        } catch  {
            worker = new Worker(url, workerOptions);
        }
    } else {
        try {
            scriptUrl = new URL(url, baseURI);
        } catch  {
            scriptUrl = url;
        }
        worker = new Worker(scriptUrl, workerOptions);
    }
    worker.addEventListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codec$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MESSAGE_EVENT_TYPE"], (event)=>onMessage(event, workerData));
    return worker;
}
function sendMessage(message, { worker, writer, onTaskFinished, transferStreams }) {
    try {
        const { value, readable, writable } = message;
        const transferables = [];
        if (value) {
            message.value = value;
            transferables.push(message.value.buffer);
        }
        if (transferStreams && transferStreamsSupported) {
            if (readable) {
                transferables.push(readable);
            }
            if (writable) {
                transferables.push(writable);
            }
        } else {
            message.readable = message.writable = null;
        }
        if (transferables.length) {
            try {
                worker.postMessage(message, transferables);
                return true;
            } catch  {
                transferStreamsSupported = false;
                message.readable = message.writable = null;
                worker.postMessage(message);
            }
        } else {
            worker.postMessage(message);
        }
    } catch (error) {
        if (writer) {
            writer.releaseLock();
        }
        onTaskFinished();
        throw error;
    }
}
async function onMessage({ data }, workerData) {
    const { type, value, messageId, result, error } = data;
    const { reader, writer, resolveResult, rejectResult, onTaskFinished } = workerData;
    try {
        if (error) {
            const { message, stack, code, name, outputSize } = error;
            const responseError = new Error(message);
            Object.assign(responseError, {
                stack,
                code,
                name,
                outputSize
            });
            close(responseError);
        } else {
            if (type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codec$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MESSAGE_PULL"]) {
                const { value, done } = await reader.read();
                sendMessage({
                    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codec$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MESSAGE_DATA"],
                    value,
                    done,
                    messageId
                }, workerData);
            }
            if (type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codec$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MESSAGE_DATA"]) {
                await writer.ready;
                await writer.write(new Uint8Array(value));
                sendMessage({
                    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codec$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MESSAGE_ACK_DATA"],
                    messageId
                }, workerData);
            }
            if (type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codec$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MESSAGE_CLOSE"]) {
                close(null, result);
            }
        }
    } catch (error) {
        sendMessage({
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codec$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MESSAGE_CLOSE"],
            messageId
        }, workerData);
        close(error);
    }
    function close(error, result) {
        if (error) {
            rejectResult(error);
        } else {
            resolveResult(result);
        }
        if (writer) {
            writer.releaseLock();
        }
        onTaskFinished();
    }
}
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/codec-pool.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "runWorker",
    ()=>runWorker,
    "terminateWorkers",
    ()=>terminateWorkers
]);
/*
 Copyright (c) 2025 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /* global setTimeout, clearTimeout */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codec$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/codec-stream.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/common-crypto.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zip$2d$entry$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/zip-entry-stream.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$codec$2d$worker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/codec-worker.js [app-client] (ecmascript)");
;
;
;
let pool = [];
const pendingRequests = [];
;
let indexWorker = 0;
async function runWorker(stream, workerOptions) {
    const { options, config } = workerOptions;
    const { transferStreams, useWebWorkers, useCompressionStream, compressed, signed, encrypted } = options;
    const { workerURI, maxWorkers } = config;
    workerOptions.transferStreams = transferStreams || transferStreams === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"];
    const streamCopy = !compressed && !signed && !encrypted && !workerOptions.transferStreams;
    workerOptions.useWebWorkers = !streamCopy && (useWebWorkers || useWebWorkers === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && config.useWebWorkers);
    workerOptions.workerURI = workerOptions.useWebWorkers && workerURI ? workerURI : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"];
    options.useCompressionStream = useCompressionStream || useCompressionStream === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && config.useCompressionStream;
    return (await getWorker()).run();
    //TURBOPACK unreachable
    ;
    // deno-lint-ignore require-await
    async function getWorker() {
        const workerData = pool.find((workerData)=>!workerData.busy);
        if (workerData) {
            clearTerminateTimeout(workerData);
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$codec$2d$worker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CodecWorker"](workerData, stream, workerOptions, onTaskFinished);
        } else if (pool.length < maxWorkers) {
            const workerData = {
                indexWorker
            };
            indexWorker++;
            pool.push(workerData);
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$codec$2d$worker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CodecWorker"](workerData, stream, workerOptions, onTaskFinished);
        } else {
            return new Promise((resolve)=>pendingRequests.push({
                    resolve,
                    stream,
                    workerOptions
                }));
        }
    }
    function onTaskFinished(workerData) {
        if (pendingRequests.length) {
            const [{ resolve, stream, workerOptions }] = pendingRequests.splice(0, 1);
            resolve(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$codec$2d$worker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CodecWorker"](workerData, stream, workerOptions, onTaskFinished));
        } else if (workerData.worker) {
            clearTerminateTimeout(workerData);
            terminateWorker(workerData, workerOptions);
        } else {
            pool = pool.filter((data)=>data != workerData);
        }
    }
}
function terminateWorker(workerData, workerOptions) {
    const { config } = workerOptions;
    const { terminateWorkerTimeout } = config;
    if (Number.isFinite(terminateWorkerTimeout) && terminateWorkerTimeout >= 0) {
        if (workerData.terminated) {
            workerData.terminated = false;
        } else {
            workerData.terminateTimeout = setTimeout(async ()=>{
                pool = pool.filter((data)=>data != workerData);
                try {
                    await workerData.terminate();
                } catch  {
                // ignored
                }
            }, terminateWorkerTimeout);
        }
    }
}
function clearTerminateTimeout(workerData) {
    const { terminateTimeout } = workerData;
    if (terminateTimeout) {
        clearTimeout(terminateTimeout);
        workerData.terminateTimeout = null;
    }
}
async function terminateWorkers() {
    await Promise.allSettled(pool.map((workerData)=>{
        clearTerminateTimeout(workerData);
        return workerData.terminate();
    }));
}
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/io.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BlobReader",
    ()=>BlobReader,
    "BlobWriter",
    ()=>BlobWriter,
    "Data64URIReader",
    ()=>Data64URIReader,
    "Data64URIWriter",
    ()=>Data64URIWriter,
    "ERR_HTTP_RANGE",
    ()=>ERR_HTTP_RANGE,
    "ERR_ITERATOR_COMPLETED_TOO_SOON",
    ()=>ERR_ITERATOR_COMPLETED_TOO_SOON,
    "ERR_WRITER_NOT_INITIALIZED",
    ()=>ERR_WRITER_NOT_INITIALIZED,
    "GenericReader",
    ()=>GenericReader,
    "GenericWriter",
    ()=>GenericWriter,
    "HttpRangeReader",
    ()=>HttpRangeReader,
    "HttpReader",
    ()=>HttpReader,
    "Reader",
    ()=>Reader,
    "SplitDataReader",
    ()=>SplitDataReader,
    "SplitDataWriter",
    ()=>SplitDataWriter,
    "TextReader",
    ()=>TextReader,
    "TextWriter",
    ()=>TextWriter,
    "Uint8ArrayReader",
    ()=>Uint8ArrayReader,
    "Uint8ArrayWriter",
    ()=>Uint8ArrayWriter,
    "Writer",
    ()=>Writer,
    "initStream",
    ()=>initStream,
    "readUint8Array",
    ()=>readUint8Array
]);
/*
 Copyright (c) 2025 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /* global Blob, atob, btoa, XMLHttpRequest, URL, fetch, ReadableStream, WritableStream, FileReader, TransformStream, Response */ // deno-lint-ignore-file no-this-alias
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$configuration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/configuration.js [app-client] (ecmascript)");
;
;
const ERR_HTTP_STATUS = "HTTP error ";
const ERR_HTTP_RANGE = "HTTP Range not supported";
const ERR_ITERATOR_COMPLETED_TOO_SOON = "Writer iterator completed too soon";
const ERR_WRITER_NOT_INITIALIZED = "Writer not initialized";
const CONTENT_TYPE_TEXT_PLAIN = "text/plain";
const HTTP_HEADER_CONTENT_LENGTH = "Content-Length";
const HTTP_HEADER_CONTENT_RANGE = "Content-Range";
const HTTP_HEADER_ACCEPT_RANGES = "Accept-Ranges";
const HTTP_HEADER_RANGE = "Range";
const HTTP_HEADER_CONTENT_TYPE = "Content-Type";
const HTTP_METHOD_HEAD = "HEAD";
const HTTP_METHOD_GET = "GET";
const HTTP_RANGE_UNIT = "bytes";
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const DEFAULT_BUFFER_SIZE = 256 * 1024;
const PROPERTY_NAME_WRITABLE = "writable";
class Stream {
    constructor(){
        this.size = 0;
    }
    init() {
        this.initialized = true;
    }
}
class Reader extends Stream {
    get readable() {
        const reader = this;
        const { chunkSize = DEFAULT_CHUNK_SIZE } = reader;
        const readable = new ReadableStream({
            start () {
                this.chunkOffset = 0;
            },
            async pull (controller) {
                const { offset = 0, size, diskNumberStart } = readable;
                const { chunkOffset } = this;
                const dataSize = size === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] ? chunkSize : Math.min(chunkSize, size - chunkOffset);
                const data = await readUint8Array(reader, offset + chunkOffset, dataSize, diskNumberStart);
                controller.enqueue(data);
                if (chunkOffset + chunkSize > size || size === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && !data.length && dataSize) {
                    controller.close();
                } else {
                    this.chunkOffset += chunkSize;
                }
            }
        });
        return readable;
    }
}
class Writer extends Stream {
    constructor(){
        super();
        const writer = this;
        const writable = new WritableStream({
            write (chunk) {
                if (!writer.initialized) {
                    throw new Error(ERR_WRITER_NOT_INITIALIZED);
                }
                return writer.writeUint8Array(chunk);
            }
        });
        Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
            get () {
                return writable;
            }
        });
    }
    writeUint8Array() {
    // abstract
    }
}
class Data64URIReader extends Reader {
    constructor(dataURI){
        super();
        let dataEnd = dataURI.length;
        while(dataURI.charAt(dataEnd - 1) == "="){
            dataEnd--;
        }
        const dataStart = dataURI.indexOf(",") + 1;
        Object.assign(this, {
            dataURI,
            dataStart,
            size: Math.floor((dataEnd - dataStart) * 0.75)
        });
    }
    readUint8Array(offset, length) {
        const { dataStart, dataURI } = this;
        const dataArray = new Uint8Array(length);
        const start = Math.floor(offset / 3) * 4;
        const bytes = atob(dataURI.substring(start + dataStart, Math.ceil((offset + length) / 3) * 4 + dataStart));
        const delta = offset - Math.floor(start / 4) * 3;
        let effectiveLength = 0;
        for(let indexByte = delta; indexByte < delta + length && indexByte < bytes.length; indexByte++){
            dataArray[indexByte - delta] = bytes.charCodeAt(indexByte);
            effectiveLength++;
        }
        if (effectiveLength < dataArray.length) {
            return dataArray.subarray(0, effectiveLength);
        } else {
            return dataArray;
        }
    }
}
class Data64URIWriter extends Writer {
    constructor(contentType){
        super();
        Object.assign(this, {
            data: "data:" + (contentType || "") + ";base64,",
            pending: []
        });
    }
    writeUint8Array(array) {
        const writer = this;
        let indexArray = 0;
        let dataString = writer.pending;
        const delta = writer.pending.length;
        writer.pending = "";
        for(indexArray = 0; indexArray < Math.floor((delta + array.length) / 3) * 3 - delta; indexArray++){
            dataString += String.fromCharCode(array[indexArray]);
        }
        for(; indexArray < array.length; indexArray++){
            writer.pending += String.fromCharCode(array[indexArray]);
        }
        if (dataString.length) {
            if (dataString.length > 2) {
                writer.data += btoa(dataString);
            } else {
                writer.pending += dataString;
            }
        }
    }
    getData() {
        return this.data + btoa(this.pending);
    }
}
class BlobReader extends Reader {
    constructor(blob){
        super();
        Object.assign(this, {
            blob,
            size: blob.size
        });
    }
    async readUint8Array(offset, length) {
        const reader = this;
        const offsetEnd = offset + length;
        const blob = offset || offsetEnd < reader.size ? reader.blob.slice(offset, offsetEnd) : reader.blob;
        let arrayBuffer = await blob.arrayBuffer();
        if (arrayBuffer.byteLength > length) {
            arrayBuffer = arrayBuffer.slice(offset, offsetEnd);
        }
        return new Uint8Array(arrayBuffer);
    }
}
class BlobWriter extends Stream {
    constructor(contentType){
        super();
        const writer = this;
        const transformStream = new TransformStream();
        const headers = [];
        if (contentType) {
            headers.push([
                HTTP_HEADER_CONTENT_TYPE,
                contentType
            ]);
        }
        Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
            get () {
                return transformStream.writable;
            }
        });
        writer.blob = new Response(transformStream.readable, {
            headers
        }).blob();
    }
    getData() {
        return this.blob;
    }
}
class TextReader extends BlobReader {
    constructor(text){
        super(new Blob([
            text
        ], {
            type: CONTENT_TYPE_TEXT_PLAIN
        }));
    }
}
class TextWriter extends BlobWriter {
    constructor(encoding){
        super(encoding);
        Object.assign(this, {
            encoding,
            utf8: !encoding || encoding.toLowerCase() == "utf-8"
        });
    }
    async getData() {
        const { encoding, utf8 } = this;
        const blob = await super.getData();
        if (blob.text && utf8) {
            return blob.text();
        } else {
            const reader = new FileReader();
            return new Promise((resolve, reject)=>{
                Object.assign(reader, {
                    onload: ({ target })=>resolve(target.result),
                    onerror: ()=>reject(reader.error)
                });
                reader.readAsText(blob, encoding);
            });
        }
    }
}
class FetchReader extends Reader {
    constructor(url, options){
        super();
        createHttpReader(this, url, options);
    }
    async init() {
        await initHttpReader(this, sendFetchRequest, getFetchRequestData);
        super.init();
    }
    readUint8Array(index, length) {
        return readUint8ArrayHttpReader(this, index, length, sendFetchRequest, getFetchRequestData);
    }
}
class XHRReader extends Reader {
    constructor(url, options){
        super();
        createHttpReader(this, url, options);
    }
    async init() {
        await initHttpReader(this, sendXMLHttpRequest, getXMLHttpRequestData);
        super.init();
    }
    readUint8Array(index, length) {
        return readUint8ArrayHttpReader(this, index, length, sendXMLHttpRequest, getXMLHttpRequestData);
    }
}
function createHttpReader(httpReader, url, options) {
    const { preventHeadRequest, useRangeHeader, forceRangeRequests, combineSizeEocd } = options;
    options = Object.assign({}, options);
    delete options.preventHeadRequest;
    delete options.useRangeHeader;
    delete options.forceRangeRequests;
    delete options.combineSizeEocd;
    delete options.useXHR;
    Object.assign(httpReader, {
        url,
        options,
        preventHeadRequest,
        useRangeHeader,
        forceRangeRequests,
        combineSizeEocd
    });
}
async function initHttpReader(httpReader, sendRequest, getRequestData) {
    const { url, preventHeadRequest, useRangeHeader, forceRangeRequests, combineSizeEocd } = httpReader;
    if (isHttpFamily(url) && (useRangeHeader || forceRangeRequests) && (typeof preventHeadRequest == "undefined" || preventHeadRequest)) {
        const response = await sendRequest(HTTP_METHOD_GET, httpReader, getRangeHeaders(httpReader, combineSizeEocd ? -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["END_OF_CENTRAL_DIR_LENGTH"] : undefined));
        const acceptRanges = response.headers.get(HTTP_HEADER_ACCEPT_RANGES);
        if (!forceRangeRequests && (!acceptRanges || acceptRanges.toLowerCase() != HTTP_RANGE_UNIT)) {
            throw new Error(ERR_HTTP_RANGE);
        } else {
            if (combineSizeEocd) {
                httpReader.eocdCache = new Uint8Array(await response.arrayBuffer());
            }
            let contentSize;
            const contentRangeHeader = response.headers.get(HTTP_HEADER_CONTENT_RANGE);
            if (contentRangeHeader) {
                const splitHeader = contentRangeHeader.trim().split(/\s*\/\s*/);
                if (splitHeader.length) {
                    const headerValue = splitHeader[1];
                    if (headerValue && headerValue != "*") {
                        contentSize = Number(headerValue);
                    }
                }
            }
            if (contentSize === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
                await getContentLength(httpReader, sendRequest, getRequestData);
            } else {
                httpReader.size = contentSize;
            }
        }
    } else {
        await getContentLength(httpReader, sendRequest, getRequestData);
    }
}
async function readUint8ArrayHttpReader(httpReader, index, length, sendRequest, getRequestData) {
    const { useRangeHeader, forceRangeRequests, eocdCache, size, options } = httpReader;
    if (useRangeHeader || forceRangeRequests) {
        if (eocdCache && index == size - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["END_OF_CENTRAL_DIR_LENGTH"] && length == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["END_OF_CENTRAL_DIR_LENGTH"]) {
            return eocdCache;
        }
        if (index >= size) {
            return new Uint8Array();
        } else {
            if (index + length > size) {
                length = size - index;
            }
            const response = await sendRequest(HTTP_METHOD_GET, httpReader, getRangeHeaders(httpReader, index, length));
            if (response.status != 206) {
                throw new Error(ERR_HTTP_RANGE);
            }
            return new Uint8Array(await response.arrayBuffer());
        }
    } else {
        const { data } = httpReader;
        if (!data) {
            await getRequestData(httpReader, options);
        }
        return new Uint8Array(httpReader.data.subarray(index, index + length));
    }
}
function getRangeHeaders(httpReader, index = 0, length = 1) {
    return Object.assign({}, getHeaders(httpReader), {
        [HTTP_HEADER_RANGE]: HTTP_RANGE_UNIT + "=" + (index < 0 ? index : index + "-" + (index + length - 1))
    });
}
function getHeaders({ options }) {
    const { headers } = options;
    if (headers) {
        if (Symbol.iterator in headers) {
            return Object.fromEntries(headers);
        } else {
            return headers;
        }
    }
}
async function getFetchRequestData(httpReader) {
    await getRequestData(httpReader, sendFetchRequest);
}
async function getXMLHttpRequestData(httpReader) {
    await getRequestData(httpReader, sendXMLHttpRequest);
}
async function getRequestData(httpReader, sendRequest) {
    const response = await sendRequest(HTTP_METHOD_GET, httpReader, getHeaders(httpReader));
    httpReader.data = new Uint8Array(await response.arrayBuffer());
    if (!httpReader.size) {
        httpReader.size = httpReader.data.length;
    }
}
async function getContentLength(httpReader, sendRequest, getRequestData) {
    if (httpReader.preventHeadRequest) {
        await getRequestData(httpReader, httpReader.options);
    } else {
        const response = await sendRequest(HTTP_METHOD_HEAD, httpReader, getHeaders(httpReader));
        const contentLength = response.headers.get(HTTP_HEADER_CONTENT_LENGTH);
        if (contentLength) {
            httpReader.size = Number(contentLength);
        } else {
            await getRequestData(httpReader, httpReader.options);
        }
    }
}
async function sendFetchRequest(method, { options, url }, headers) {
    const response = await fetch(url, Object.assign({}, options, {
        method,
        headers
    }));
    if (response.status < 400) {
        return response;
    } else {
        throw response.status == 416 ? new Error(ERR_HTTP_RANGE) : new Error(ERR_HTTP_STATUS + (response.statusText || response.status));
    }
}
function sendXMLHttpRequest(method, { url }, headers) {
    return new Promise((resolve, reject)=>{
        const request = new XMLHttpRequest();
        request.addEventListener("load", ()=>{
            if (request.status < 400) {
                const headers = [];
                request.getAllResponseHeaders().trim().split(/[\r\n]+/).forEach((header)=>{
                    const splitHeader = header.trim().split(/\s*:\s*/);
                    splitHeader[0] = splitHeader[0].trim().replace(/^[a-z]|-[a-z]/g, (value)=>value.toUpperCase());
                    headers.push(splitHeader);
                });
                resolve({
                    status: request.status,
                    arrayBuffer: ()=>request.response,
                    headers: new Map(headers)
                });
            } else {
                reject(request.status == 416 ? new Error(ERR_HTTP_RANGE) : new Error(ERR_HTTP_STATUS + (request.statusText || request.status)));
            }
        }, false);
        request.addEventListener("error", (event)=>reject(event.detail ? event.detail.error : new Error("Network error")), false);
        request.open(method, url);
        if (headers) {
            for (const entry of Object.entries(headers)){
                request.setRequestHeader(entry[0], entry[1]);
            }
        }
        request.responseType = "arraybuffer";
        request.send();
    });
}
class HttpReader extends Reader {
    constructor(url, options = {}){
        super();
        Object.assign(this, {
            url,
            reader: options.useXHR ? new XHRReader(url, options) : new FetchReader(url, options)
        });
    }
    set size(value) {
    // ignored
    }
    get size() {
        return this.reader.size;
    }
    async init() {
        await this.reader.init();
        super.init();
    }
    readUint8Array(index, length) {
        return this.reader.readUint8Array(index, length);
    }
}
class HttpRangeReader extends HttpReader {
    constructor(url, options = {}){
        options.useRangeHeader = true;
        super(url, options);
    }
}
class Uint8ArrayReader extends Reader {
    constructor(array){
        super();
        array = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
        Object.assign(this, {
            array,
            size: array.length
        });
    }
    readUint8Array(index, length) {
        return this.array.slice(index, index + length);
    }
}
class Uint8ArrayWriter extends Writer {
    constructor(defaultBufferSize){
        super();
        this.defaultBufferSize = defaultBufferSize || DEFAULT_BUFFER_SIZE;
    }
    init(initSize = 0) {
        Object.assign(this, {
            offset: 0,
            array: new Uint8Array(initSize > 0 ? initSize : this.defaultBufferSize)
        });
        super.init();
    }
    writeUint8Array(array) {
        const writer = this;
        const requiredLength = writer.offset + array.length;
        if (requiredLength > writer.array.length) {
            let newLength = writer.array.length ? writer.array.length * 2 : writer.defaultBufferSize;
            while(newLength < requiredLength){
                newLength *= 2;
            }
            const previousArray = writer.array;
            writer.array = new Uint8Array(newLength);
            writer.array.set(previousArray);
        }
        writer.array.set(array, writer.offset);
        writer.offset += array.length;
    }
    getData() {
        if (this.offset === this.array.length) {
            return this.array;
        } else {
            return this.array.slice(0, this.offset);
        }
    }
}
class SplitDataReader extends Reader {
    constructor(readers){
        super();
        this.readers = readers;
    }
    async init() {
        const reader = this;
        const { readers } = reader;
        reader.lastDiskNumber = 0;
        reader.lastDiskOffset = 0;
        await Promise.all(readers.map(async (diskReader, indexDiskReader)=>{
            await diskReader.init();
            if (indexDiskReader != readers.length - 1) {
                reader.lastDiskOffset += diskReader.size;
            }
            reader.size += diskReader.size;
        }));
        super.init();
    }
    async readUint8Array(offset, length, diskNumber = 0) {
        const reader = this;
        const { readers } = this;
        let result;
        let currentDiskNumber = diskNumber;
        if (currentDiskNumber == -1) {
            currentDiskNumber = readers.length - 1;
        }
        let currentReaderOffset = offset;
        while(readers[currentDiskNumber] && currentReaderOffset >= readers[currentDiskNumber].size){
            currentReaderOffset -= readers[currentDiskNumber].size;
            currentDiskNumber++;
        }
        const currentReader = readers[currentDiskNumber];
        if (currentReader) {
            const currentReaderSize = currentReader.size;
            if (currentReaderOffset + length <= currentReaderSize) {
                result = await readUint8Array(currentReader, currentReaderOffset, length);
            } else {
                const chunkLength = currentReaderSize - currentReaderOffset;
                result = new Uint8Array(length);
                const firstPart = await readUint8Array(currentReader, currentReaderOffset, chunkLength);
                result.set(firstPart, 0);
                const secondPart = await reader.readUint8Array(offset + chunkLength, length - chunkLength, diskNumber);
                result.set(secondPart, chunkLength);
                if (firstPart.length + secondPart.length < length) {
                    result = result.subarray(0, firstPart.length + secondPart.length);
                }
            }
        } else {
            result = new Uint8Array();
        }
        reader.lastDiskNumber = Math.max(currentDiskNumber, reader.lastDiskNumber);
        return result;
    }
}
class SplitDataWriter extends Stream {
    constructor(writerGenerator, maxSize = 4294967295){
        super();
        const writer = this;
        Object.assign(writer, {
            diskNumber: 0,
            diskOffset: 0,
            size: 0,
            maxSize,
            availableSize: maxSize
        });
        let diskSourceWriter, diskWritable, diskWriter;
        const writable = new WritableStream({
            async write (chunk) {
                const { availableSize } = writer;
                if (!diskWriter) {
                    const { value, done } = await writerGenerator.next();
                    if (done && !value) {
                        throw new Error(ERR_ITERATOR_COMPLETED_TOO_SOON);
                    } else {
                        diskSourceWriter = value;
                        diskSourceWriter.size = 0;
                        if (diskSourceWriter.maxSize) {
                            writer.maxSize = diskSourceWriter.maxSize;
                        }
                        writer.availableSize = writer.maxSize;
                        await initStream(diskSourceWriter);
                        diskWritable = value.writable;
                        diskWriter = diskWritable.getWriter();
                    }
                    await this.write(chunk);
                } else if (chunk.length >= availableSize) {
                    await writeChunk(chunk.subarray(0, availableSize));
                    await closeDisk();
                    writer.diskOffset += diskSourceWriter.size;
                    writer.diskNumber++;
                    diskWriter = null;
                    await this.write(chunk.subarray(availableSize));
                } else {
                    await writeChunk(chunk);
                }
            },
            async close () {
                await diskWriter.ready;
                await closeDisk();
            }
        });
        Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
            get () {
                return writable;
            }
        });
        async function writeChunk(chunk) {
            const chunkLength = chunk.length;
            if (chunkLength) {
                await diskWriter.ready;
                await diskWriter.write(chunk);
                diskSourceWriter.size += chunkLength;
                writer.size += chunkLength;
                writer.availableSize -= chunkLength;
            }
        }
        async function closeDisk() {
            await diskWriter.close();
        }
    }
}
class GenericReader {
    constructor(reader){
        if (Array.isArray(reader)) {
            reader = new SplitDataReader(reader);
        }
        if (reader instanceof ReadableStream) {
            reader = {
                readable: reader
            };
        }
        return reader;
    }
}
class GenericWriter {
    constructor(writer){
        if (writer.writable === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && typeof writer.next == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FUNCTION_TYPE"]) {
            writer = new SplitDataWriter(writer);
        }
        if (writer instanceof WritableStream) {
            writer = {
                writable: writer
            };
        }
        if (writer.size === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
            writer.size = 0;
        }
        if (!(writer instanceof SplitDataWriter)) {
            Object.assign(writer, {
                diskNumber: 0,
                diskOffset: 0,
                availableSize: Infinity,
                maxSize: Infinity
            });
        }
        return writer;
    }
}
function isHttpFamily(url) {
    const { baseURI } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$configuration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getConfiguration"])();
    const { protocol } = new URL(url, baseURI);
    return protocol == "http:" || protocol == "https:";
}
async function initStream(stream, initSize) {
    if (stream.init && !stream.initialized) {
        await stream.init(initSize);
    } else {
        return Promise.resolve();
    }
}
function readUint8Array(reader, offset, size, diskNumber) {
    return reader.readUint8Array(offset, size, diskNumber);
}
;
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/util/decode-cp437.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decodeCP437",
    ()=>decodeCP437
]);
/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /* global TextDecoder */ const CP437 = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ".split("");
const VALID_CP437 = CP437.length == 256;
;
function decodeCP437(stringValue) {
    if (VALID_CP437) {
        let result = "";
        for(let indexCharacter = 0; indexCharacter < stringValue.length; indexCharacter++){
            result += CP437[stringValue[indexCharacter]];
        }
        return result;
    } else {
        return new TextDecoder().decode(stringValue);
    }
}
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/util/decode-text.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decodeText",
    ()=>decodeText
]);
/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /* global TextDecoder */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$util$2f$decode$2d$cp437$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/util/decode-cp437.js [app-client] (ecmascript)");
;
;
function decodeText(value, encoding) {
    if (encoding && encoding.trim().toLowerCase() == "cp437") {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$util$2f$decode$2d$cp437$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeCP437"])(value);
    } else {
        return new TextDecoder(encoding).decode(value);
    }
}
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/zip-entry.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Entry",
    ()=>Entry,
    "PROPERTY_NAME_COMMENT",
    ()=>PROPERTY_NAME_COMMENT,
    "PROPERTY_NAME_COMPRESSED_SIZE",
    ()=>PROPERTY_NAME_COMPRESSED_SIZE,
    "PROPERTY_NAME_COMPRESSION_METHOD",
    ()=>PROPERTY_NAME_COMPRESSION_METHOD,
    "PROPERTY_NAME_CREATION_DATE",
    ()=>PROPERTY_NAME_CREATION_DATE,
    "PROPERTY_NAME_DIRECTORY",
    ()=>PROPERTY_NAME_DIRECTORY,
    "PROPERTY_NAME_DISK_NUMBER_START",
    ()=>PROPERTY_NAME_DISK_NUMBER_START,
    "PROPERTY_NAME_ENCRYPTED",
    ()=>PROPERTY_NAME_ENCRYPTED,
    "PROPERTY_NAME_EXECUTABLE",
    ()=>PROPERTY_NAME_EXECUTABLE,
    "PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES",
    ()=>PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES,
    "PROPERTY_NAME_EXTRA_FIELD",
    ()=>PROPERTY_NAME_EXTRA_FIELD,
    "PROPERTY_NAME_FILENAME",
    ()=>PROPERTY_NAME_FILENAME,
    "PROPERTY_NAME_GID",
    ()=>PROPERTY_NAME_GID,
    "PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES",
    ()=>PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES,
    "PROPERTY_NAME_LAST_ACCESS_DATE",
    ()=>PROPERTY_NAME_LAST_ACCESS_DATE,
    "PROPERTY_NAME_LAST_MODIFICATION_DATE",
    ()=>PROPERTY_NAME_LAST_MODIFICATION_DATE,
    "PROPERTY_NAME_MSDOS_ATTRIBUTES",
    ()=>PROPERTY_NAME_MSDOS_ATTRIBUTES,
    "PROPERTY_NAME_MSDOS_ATTRIBUTES_RAW",
    ()=>PROPERTY_NAME_MSDOS_ATTRIBUTES_RAW,
    "PROPERTY_NAME_MS_DOS_COMPATIBLE",
    ()=>PROPERTY_NAME_MS_DOS_COMPATIBLE,
    "PROPERTY_NAME_OFFSET",
    ()=>PROPERTY_NAME_OFFSET,
    "PROPERTY_NAME_RAW_COMMENT",
    ()=>PROPERTY_NAME_RAW_COMMENT,
    "PROPERTY_NAME_RAW_CREATION_DATE",
    ()=>PROPERTY_NAME_RAW_CREATION_DATE,
    "PROPERTY_NAME_RAW_FILENAME",
    ()=>PROPERTY_NAME_RAW_FILENAME,
    "PROPERTY_NAME_RAW_LAST_ACCESS_DATE",
    ()=>PROPERTY_NAME_RAW_LAST_ACCESS_DATE,
    "PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE",
    ()=>PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE,
    "PROPERTY_NAME_SETGID",
    ()=>PROPERTY_NAME_SETGID,
    "PROPERTY_NAME_SETUID",
    ()=>PROPERTY_NAME_SETUID,
    "PROPERTY_NAME_SIGNATURE",
    ()=>PROPERTY_NAME_SIGNATURE,
    "PROPERTY_NAME_STICKY",
    ()=>PROPERTY_NAME_STICKY,
    "PROPERTY_NAME_UID",
    ()=>PROPERTY_NAME_UID,
    "PROPERTY_NAME_UNCOMPRESSED_SIZE",
    ()=>PROPERTY_NAME_UNCOMPRESSED_SIZE,
    "PROPERTY_NAME_UNIX_MODE",
    ()=>PROPERTY_NAME_UNIX_MODE,
    "PROPERTY_NAME_VERSION",
    ()=>PROPERTY_NAME_VERSION,
    "PROPERTY_NAME_VERSION_MADE_BY",
    ()=>PROPERTY_NAME_VERSION_MADE_BY,
    "PROPERTY_NAME_ZIP64",
    ()=>PROPERTY_NAME_ZIP64,
    "PROPERTY_NAME_ZIPCRYPTO",
    ()=>PROPERTY_NAME_ZIPCRYPTO
]);
/*
 Copyright (c) 2025 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ const PROPERTY_NAME_FILENAME = "filename";
const PROPERTY_NAME_RAW_FILENAME = "rawFilename";
const PROPERTY_NAME_COMMENT = "comment";
const PROPERTY_NAME_RAW_COMMENT = "rawComment";
const PROPERTY_NAME_UNCOMPRESSED_SIZE = "uncompressedSize";
const PROPERTY_NAME_COMPRESSED_SIZE = "compressedSize";
const PROPERTY_NAME_OFFSET = "offset";
const PROPERTY_NAME_DISK_NUMBER_START = "diskNumberStart";
const PROPERTY_NAME_LAST_MODIFICATION_DATE = "lastModDate";
const PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE = "rawLastModDate";
const PROPERTY_NAME_LAST_ACCESS_DATE = "lastAccessDate";
const PROPERTY_NAME_RAW_LAST_ACCESS_DATE = "rawLastAccessDate";
const PROPERTY_NAME_CREATION_DATE = "creationDate";
const PROPERTY_NAME_RAW_CREATION_DATE = "rawCreationDate";
const PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES = "internalFileAttributes";
const PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES = "externalFileAttributes";
const PROPERTY_NAME_MSDOS_ATTRIBUTES_RAW = "msdosAttributesRaw";
const PROPERTY_NAME_MSDOS_ATTRIBUTES = "msdosAttributes";
const PROPERTY_NAME_MS_DOS_COMPATIBLE = "msDosCompatible";
const PROPERTY_NAME_ZIP64 = "zip64";
const PROPERTY_NAME_ENCRYPTED = "encrypted";
const PROPERTY_NAME_VERSION = "version";
const PROPERTY_NAME_VERSION_MADE_BY = "versionMadeBy";
const PROPERTY_NAME_ZIPCRYPTO = "zipCrypto";
const PROPERTY_NAME_DIRECTORY = "directory";
const PROPERTY_NAME_EXECUTABLE = "executable";
const PROPERTY_NAME_COMPRESSION_METHOD = "compressionMethod";
const PROPERTY_NAME_SIGNATURE = "signature";
const PROPERTY_NAME_EXTRA_FIELD = "extraField";
const PROPERTY_NAME_EXTRA_FIELD_INFOZIP = "extraFieldInfoZip";
const PROPERTY_NAME_EXTRA_FIELD_UNIX = "extraFieldUnix";
const PROPERTY_NAME_UID = "uid";
const PROPERTY_NAME_GID = "gid";
const PROPERTY_NAME_UNIX_MODE = "unixMode";
const PROPERTY_NAME_SETUID = "setuid";
const PROPERTY_NAME_SETGID = "setgid";
const PROPERTY_NAME_STICKY = "sticky";
const PROPERTY_NAME_BITFLAG = "bitFlag";
const PROPERTY_NAME_FILENAME_UTF8 = "filenameUTF8";
const PROPERTY_NAME_COMMENT_UTF8 = "commentUTF8";
const PROPERTY_NAME_RAW_EXTRA_FIELD = "rawExtraField";
const PROPERTY_NAME_EXTRA_FIELD_ZIP64 = "extraFieldZip64";
const PROPERTY_NAME_EXTRA_FIELD_UNICODE_PATH = "extraFieldUnicodePath";
const PROPERTY_NAME_EXTRA_FIELD_UNICODE_COMMENT = "extraFieldUnicodeComment";
const PROPERTY_NAME_EXTRA_FIELD_AES = "extraFieldAES";
const PROPERTY_NAME_EXTRA_FIELD_NTFS = "extraFieldNTFS";
const PROPERTY_NAME_EXTRA_FIELD_EXTENDED_TIMESTAMP = "extraFieldExtendedTimestamp";
const PROPERTY_NAMES = [
    PROPERTY_NAME_FILENAME,
    PROPERTY_NAME_RAW_FILENAME,
    PROPERTY_NAME_UNCOMPRESSED_SIZE,
    PROPERTY_NAME_COMPRESSED_SIZE,
    PROPERTY_NAME_LAST_MODIFICATION_DATE,
    PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE,
    PROPERTY_NAME_COMMENT,
    PROPERTY_NAME_RAW_COMMENT,
    PROPERTY_NAME_LAST_ACCESS_DATE,
    PROPERTY_NAME_CREATION_DATE,
    PROPERTY_NAME_RAW_CREATION_DATE,
    PROPERTY_NAME_OFFSET,
    PROPERTY_NAME_DISK_NUMBER_START,
    PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES,
    PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES,
    PROPERTY_NAME_MSDOS_ATTRIBUTES_RAW,
    PROPERTY_NAME_MSDOS_ATTRIBUTES,
    PROPERTY_NAME_MS_DOS_COMPATIBLE,
    PROPERTY_NAME_ZIP64,
    PROPERTY_NAME_ENCRYPTED,
    PROPERTY_NAME_VERSION,
    PROPERTY_NAME_VERSION_MADE_BY,
    PROPERTY_NAME_ZIPCRYPTO,
    PROPERTY_NAME_DIRECTORY,
    PROPERTY_NAME_EXECUTABLE,
    PROPERTY_NAME_COMPRESSION_METHOD,
    PROPERTY_NAME_SIGNATURE,
    PROPERTY_NAME_EXTRA_FIELD,
    PROPERTY_NAME_EXTRA_FIELD_UNIX,
    PROPERTY_NAME_EXTRA_FIELD_INFOZIP,
    PROPERTY_NAME_UID,
    PROPERTY_NAME_GID,
    PROPERTY_NAME_UNIX_MODE,
    PROPERTY_NAME_SETUID,
    PROPERTY_NAME_SETGID,
    PROPERTY_NAME_STICKY,
    PROPERTY_NAME_BITFLAG,
    PROPERTY_NAME_FILENAME_UTF8,
    PROPERTY_NAME_COMMENT_UTF8,
    PROPERTY_NAME_RAW_EXTRA_FIELD,
    PROPERTY_NAME_EXTRA_FIELD_ZIP64,
    PROPERTY_NAME_EXTRA_FIELD_UNICODE_PATH,
    PROPERTY_NAME_EXTRA_FIELD_UNICODE_COMMENT,
    PROPERTY_NAME_EXTRA_FIELD_AES,
    PROPERTY_NAME_EXTRA_FIELD_NTFS,
    PROPERTY_NAME_EXTRA_FIELD_EXTENDED_TIMESTAMP
];
class Entry {
    constructor(data){
        PROPERTY_NAMES.forEach((name)=>this[name] = data[name]);
    }
}
;
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/options.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "OPTION_BUFFERED_WRITE",
    ()=>OPTION_BUFFERED_WRITE,
    "OPTION_CHECK_OVERLAPPING_ENTRY",
    ()=>OPTION_CHECK_OVERLAPPING_ENTRY,
    "OPTION_CHECK_OVERLAPPING_ENTRY_ONLY",
    ()=>OPTION_CHECK_OVERLAPPING_ENTRY_ONLY,
    "OPTION_CHECK_PASSWORD_ONLY",
    ()=>OPTION_CHECK_PASSWORD_ONLY,
    "OPTION_CHECK_SIGNATURE",
    ()=>OPTION_CHECK_SIGNATURE,
    "OPTION_COMMENT_ENCODING",
    ()=>OPTION_COMMENT_ENCODING,
    "OPTION_DATA_DESCRIPTOR",
    ()=>OPTION_DATA_DESCRIPTOR,
    "OPTION_DATA_DESCRIPTOR_SIGNATURE",
    ()=>OPTION_DATA_DESCRIPTOR_SIGNATURE,
    "OPTION_DECODE_TEXT",
    ()=>OPTION_DECODE_TEXT,
    "OPTION_ENCODE_TEXT",
    ()=>OPTION_ENCODE_TEXT,
    "OPTION_ENCRYPTION_STRENGTH",
    ()=>OPTION_ENCRYPTION_STRENGTH,
    "OPTION_EXTENDED_TIMESTAMP",
    ()=>OPTION_EXTENDED_TIMESTAMP,
    "OPTION_EXTRACT_APPENDED_DATA",
    ()=>OPTION_EXTRACT_APPENDED_DATA,
    "OPTION_EXTRACT_PREPENDED_DATA",
    ()=>OPTION_EXTRACT_PREPENDED_DATA,
    "OPTION_FILENAME_ENCODING",
    ()=>OPTION_FILENAME_ENCODING,
    "OPTION_KEEP_ORDER",
    ()=>OPTION_KEEP_ORDER,
    "OPTION_LEVEL",
    ()=>OPTION_LEVEL,
    "OPTION_OFFSET",
    ()=>OPTION_OFFSET,
    "OPTION_PASSWORD",
    ()=>OPTION_PASSWORD,
    "OPTION_PASS_THROUGH",
    ()=>OPTION_PASS_THROUGH,
    "OPTION_PREVENT_CLOSE",
    ()=>OPTION_PREVENT_CLOSE,
    "OPTION_RAW_PASSWORD",
    ()=>OPTION_RAW_PASSWORD,
    "OPTION_SIGNAL",
    ()=>OPTION_SIGNAL,
    "OPTION_SUPPORT_ZIP64_SPLIT_FILE",
    ()=>OPTION_SUPPORT_ZIP64_SPLIT_FILE,
    "OPTION_TRANSFER_STREAMS",
    ()=>OPTION_TRANSFER_STREAMS,
    "OPTION_UNIX_EXTRA_FIELD_TYPE",
    ()=>OPTION_UNIX_EXTRA_FIELD_TYPE,
    "OPTION_USDZ",
    ()=>OPTION_USDZ,
    "OPTION_USE_COMPRESSION_STREAM",
    ()=>OPTION_USE_COMPRESSION_STREAM,
    "OPTION_USE_UNICODE_FILE_NAMES",
    ()=>OPTION_USE_UNICODE_FILE_NAMES,
    "OPTION_USE_WEB_WORKERS",
    ()=>OPTION_USE_WEB_WORKERS
]);
/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ const OPTION_FILENAME_ENCODING = "filenameEncoding";
const OPTION_COMMENT_ENCODING = "commentEncoding";
const OPTION_DECODE_TEXT = "decodeText";
const OPTION_EXTRACT_PREPENDED_DATA = "extractPrependedData";
const OPTION_EXTRACT_APPENDED_DATA = "extractAppendedData";
const OPTION_PASSWORD = "password";
const OPTION_RAW_PASSWORD = "rawPassword";
const OPTION_PASS_THROUGH = "passThrough";
const OPTION_SIGNAL = "signal";
const OPTION_CHECK_PASSWORD_ONLY = "checkPasswordOnly";
const OPTION_CHECK_OVERLAPPING_ENTRY_ONLY = "checkOverlappingEntryOnly";
const OPTION_CHECK_OVERLAPPING_ENTRY = "checkOverlappingEntry";
const OPTION_CHECK_SIGNATURE = "checkSignature";
const OPTION_USE_WEB_WORKERS = "useWebWorkers";
const OPTION_USE_COMPRESSION_STREAM = "useCompressionStream";
const OPTION_TRANSFER_STREAMS = "transferStreams";
const OPTION_PREVENT_CLOSE = "preventClose";
const OPTION_ENCRYPTION_STRENGTH = "encryptionStrength";
const OPTION_EXTENDED_TIMESTAMP = "extendedTimestamp";
const OPTION_KEEP_ORDER = "keepOrder";
const OPTION_LEVEL = "level";
const OPTION_BUFFERED_WRITE = "bufferedWrite";
const OPTION_DATA_DESCRIPTOR_SIGNATURE = "dataDescriptorSignature";
const OPTION_USE_UNICODE_FILE_NAMES = "useUnicodeFileNames";
const OPTION_DATA_DESCRIPTOR = "dataDescriptor";
const OPTION_SUPPORT_ZIP64_SPLIT_FILE = "supportZip64SplitFile";
const OPTION_ENCODE_TEXT = "encodeText";
const OPTION_OFFSET = "offset";
const OPTION_USDZ = "usdz";
const OPTION_UNIX_EXTRA_FIELD_TYPE = "unixExtraFieldType";
;
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/zip-reader.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ERR_BAD_FORMAT",
    ()=>ERR_BAD_FORMAT,
    "ERR_CENTRAL_DIRECTORY_NOT_FOUND",
    ()=>ERR_CENTRAL_DIRECTORY_NOT_FOUND,
    "ERR_ENCRYPTED",
    ()=>ERR_ENCRYPTED,
    "ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND",
    ()=>ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND,
    "ERR_EOCDR_NOT_FOUND",
    ()=>ERR_EOCDR_NOT_FOUND,
    "ERR_EXTRAFIELD_ZIP64_NOT_FOUND",
    ()=>ERR_EXTRAFIELD_ZIP64_NOT_FOUND,
    "ERR_LOCAL_FILE_HEADER_NOT_FOUND",
    ()=>ERR_LOCAL_FILE_HEADER_NOT_FOUND,
    "ERR_OVERLAPPING_ENTRY",
    ()=>ERR_OVERLAPPING_ENTRY,
    "ERR_SPLIT_ZIP_FILE",
    ()=>ERR_SPLIT_ZIP_FILE,
    "ERR_UNSUPPORTED_COMPRESSION",
    ()=>ERR_UNSUPPORTED_COMPRESSION,
    "ERR_UNSUPPORTED_ENCRYPTION",
    ()=>ERR_UNSUPPORTED_ENCRYPTION,
    "ZipReader",
    ()=>ZipReader,
    "ZipReaderStream",
    ()=>ZipReaderStream
]);
/*
 Copyright (c) 2025 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /* global Response, WritableStream, ReadableStream, TransformStream */ // deno-lint-ignore-file no-this-alias
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$configuration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/configuration.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$codec$2d$pool$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/codec-pool.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codec$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/codec-stream.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/common-crypto.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zip$2d$entry$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/zip-entry-stream.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/io.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$util$2f$decode$2d$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/util/decode-text.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$crc32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/codecs/crc32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/zip-entry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/options.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const ERR_BAD_FORMAT = "File format is not recognized";
const ERR_EOCDR_NOT_FOUND = "End of central directory not found";
const ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND = "End of Zip64 central directory locator not found";
const ERR_CENTRAL_DIRECTORY_NOT_FOUND = "Central directory header not found";
const ERR_LOCAL_FILE_HEADER_NOT_FOUND = "Local file header not found";
const ERR_EXTRAFIELD_ZIP64_NOT_FOUND = "Zip64 extra field not found";
const ERR_ENCRYPTED = "File contains encrypted entry";
const ERR_UNSUPPORTED_ENCRYPTION = "Encryption method not supported";
const ERR_UNSUPPORTED_COMPRESSION = "Compression method not supported";
const ERR_SPLIT_ZIP_FILE = "Split zip file";
const ERR_OVERLAPPING_ENTRY = "Overlapping entry found";
const CHARSET_UTF8 = "utf-8";
const PROPERTY_NAME_UTF8_SUFFIX = "UTF8";
const CHARSET_CP437 = "cp437";
const ZIP64_PROPERTIES = [
    [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_UNCOMPRESSED_SIZE"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"]
    ],
    [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_COMPRESSED_SIZE"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"]
    ],
    [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_OFFSET"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"]
    ],
    [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_DISK_NUMBER_START"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"]
    ]
];
const ZIP64_EXTRACTION = {
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"]]: {
        getValue: getUint32,
        bytes: 4
    },
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"]]: {
        getValue: getBigUint64,
        bytes: 8
    }
};
class ZipReader {
    constructor(reader, options = {}){
        Object.assign(this, {
            reader: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GenericReader"](reader),
            options,
            config: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$configuration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getConfiguration"])(),
            readRanges: []
        });
    }
    async *getEntriesGenerator(options = {}) {
        const zipReader = this;
        let { reader } = zipReader;
        const { config } = zipReader;
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initStream"])(reader);
        if (reader.size === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] || !reader.readUint8Array) {
            reader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlobReader"](await new Response(reader.readable).blob());
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initStream"])(reader);
        }
        if (reader.size < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["END_OF_CENTRAL_DIR_LENGTH"]) {
            throw new Error(ERR_BAD_FORMAT);
        }
        reader.chunkSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$configuration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChunkSize"])(config);
        const endOfDirectoryInfo = await seekSignature(reader, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["END_OF_CENTRAL_DIR_SIGNATURE"], reader.size, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["END_OF_CENTRAL_DIR_LENGTH"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"] * 16);
        if (!endOfDirectoryInfo) {
            const signatureArray = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8Array"])(reader, 0, 4);
            const signatureView = getDataView(signatureArray);
            if (getUint32(signatureView) == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SPLIT_ZIP_FILE_SIGNATURE"]) {
                throw new Error(ERR_SPLIT_ZIP_FILE);
            } else {
                throw new Error(ERR_EOCDR_NOT_FOUND);
            }
        }
        const endOfDirectoryView = getDataView(endOfDirectoryInfo);
        let directoryDataLength = getUint32(endOfDirectoryView, 12);
        let directoryDataOffset = getUint32(endOfDirectoryView, 16);
        const commentOffset = endOfDirectoryInfo.offset;
        const commentLength = getUint16(endOfDirectoryView, 20);
        const appendedDataOffset = commentOffset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["END_OF_CENTRAL_DIR_LENGTH"] + commentLength;
        let lastDiskNumber = getUint16(endOfDirectoryView, 4);
        const expectedLastDiskNumber = reader.lastDiskNumber || 0;
        let diskNumber = getUint16(endOfDirectoryView, 6);
        let filesLength = getUint16(endOfDirectoryView, 8);
        let prependedDataLength = 0;
        let startOffset = 0;
        if (directoryDataOffset == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"] || directoryDataLength == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"] || filesLength == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"] || diskNumber == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"]) {
            const endOfDirectoryLocatorArray = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8Array"])(reader, endOfDirectoryInfo.offset - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH"]);
            const endOfDirectoryLocatorView = getDataView(endOfDirectoryLocatorArray);
            if (getUint32(endOfDirectoryLocatorView, 0) == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE"]) {
                directoryDataOffset = getBigUint64(endOfDirectoryLocatorView, 8);
                let endOfDirectoryArray = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8Array"])(reader, directoryDataOffset, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZIP64_END_OF_CENTRAL_DIR_LENGTH"], -1);
                let endOfDirectoryView = getDataView(endOfDirectoryArray);
                const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH"] - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZIP64_END_OF_CENTRAL_DIR_LENGTH"];
                if (getUint32(endOfDirectoryView, 0) != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZIP64_END_OF_CENTRAL_DIR_SIGNATURE"] && directoryDataOffset != expectedDirectoryDataOffset) {
                    const originalDirectoryDataOffset = directoryDataOffset;
                    directoryDataOffset = expectedDirectoryDataOffset;
                    if (directoryDataOffset > originalDirectoryDataOffset) {
                        prependedDataLength = directoryDataOffset - originalDirectoryDataOffset;
                    }
                    endOfDirectoryArray = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8Array"])(reader, directoryDataOffset, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZIP64_END_OF_CENTRAL_DIR_LENGTH"], -1);
                    endOfDirectoryView = getDataView(endOfDirectoryArray);
                }
                if (getUint32(endOfDirectoryView, 0) != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZIP64_END_OF_CENTRAL_DIR_SIGNATURE"]) {
                    throw new Error(ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND);
                }
                if (lastDiskNumber == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"]) {
                    lastDiskNumber = getUint32(endOfDirectoryView, 16);
                }
                if (diskNumber == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"]) {
                    diskNumber = getUint32(endOfDirectoryView, 20);
                }
                if (filesLength == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"]) {
                    filesLength = getBigUint64(endOfDirectoryView, 32);
                }
                if (directoryDataLength == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"]) {
                    directoryDataLength = getBigUint64(endOfDirectoryView, 40);
                }
                directoryDataOffset -= directoryDataLength;
            }
        }
        if (directoryDataOffset >= reader.size) {
            prependedDataLength = reader.size - directoryDataOffset - directoryDataLength - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["END_OF_CENTRAL_DIR_LENGTH"];
            directoryDataOffset = reader.size - directoryDataLength - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["END_OF_CENTRAL_DIR_LENGTH"];
        }
        if (expectedLastDiskNumber != lastDiskNumber) {
            throw new Error(ERR_SPLIT_ZIP_FILE);
        }
        if (directoryDataOffset < 0) {
            throw new Error(ERR_BAD_FORMAT);
        }
        let offset = 0;
        let directoryArray = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8Array"])(reader, directoryDataOffset, directoryDataLength, diskNumber);
        let directoryView = getDataView(directoryArray);
        if (directoryDataLength) {
            const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - directoryDataLength;
            if (getUint32(directoryView, offset) != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CENTRAL_FILE_HEADER_SIGNATURE"] && directoryDataOffset != expectedDirectoryDataOffset) {
                const originalDirectoryDataOffset = directoryDataOffset;
                directoryDataOffset = expectedDirectoryDataOffset;
                if (directoryDataOffset > originalDirectoryDataOffset) {
                    prependedDataLength += directoryDataOffset - originalDirectoryDataOffset;
                }
                directoryArray = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8Array"])(reader, directoryDataOffset, directoryDataLength, diskNumber);
                directoryView = getDataView(directoryArray);
            }
        }
        const expectedDirectoryDataLength = endOfDirectoryInfo.offset - directoryDataOffset - (reader.lastDiskOffset || 0);
        if (directoryDataLength != expectedDirectoryDataLength && expectedDirectoryDataLength >= 0) {
            directoryDataLength = expectedDirectoryDataLength;
            directoryArray = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8Array"])(reader, directoryDataOffset, directoryDataLength, diskNumber);
            directoryView = getDataView(directoryArray);
        }
        if (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {
            throw new Error(ERR_BAD_FORMAT);
        }
        const filenameEncoding = getOptionValue(zipReader, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_FILENAME_ENCODING"]);
        const commentEncoding = getOptionValue(zipReader, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_COMMENT_ENCODING"]);
        for(let indexFile = 0; indexFile < filesLength; indexFile++){
            const fileEntry = new ZipEntry(reader, config, zipReader.options);
            if (getUint32(directoryView, offset) != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CENTRAL_FILE_HEADER_SIGNATURE"]) {
                throw new Error(ERR_CENTRAL_DIRECTORY_NOT_FOUND);
            }
            readCommonHeader(fileEntry, directoryView, offset + 6);
            const languageEncodingFlag = Boolean(fileEntry.bitFlag.languageEncodingFlag);
            const filenameOffset = offset + 46;
            const extraFieldOffset = filenameOffset + fileEntry.filenameLength;
            const commentOffset = extraFieldOffset + fileEntry.extraFieldLength;
            const versionMadeBy = getUint16(directoryView, offset + 4);
            const msDosCompatible = versionMadeBy >> 8 == 0;
            const unixCompatible = versionMadeBy >> 8 == 3;
            const rawFilename = directoryArray.subarray(filenameOffset, extraFieldOffset);
            const commentLength = getUint16(directoryView, offset + 32);
            const endOffset = commentOffset + commentLength;
            const rawComment = directoryArray.subarray(commentOffset, endOffset);
            const filenameUTF8 = languageEncodingFlag;
            const commentUTF8 = languageEncodingFlag;
            const externalFileAttributes = getUint32(directoryView, offset + 38);
            const msdosAttributesRaw = externalFileAttributes & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_8_BITS"];
            const msdosAttributes = {
                readOnly: Boolean(msdosAttributesRaw & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_MSDOS_READONLY_MASK"]),
                hidden: Boolean(msdosAttributesRaw & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_MSDOS_HIDDEN_MASK"]),
                system: Boolean(msdosAttributesRaw & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_MSDOS_SYSTEM_MASK"]),
                directory: Boolean(msdosAttributesRaw & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_MSDOS_DIR_MASK"]),
                archive: Boolean(msdosAttributesRaw & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_MSDOS_ARCHIVE_MASK"])
            };
            const offsetFileEntry = getUint32(directoryView, offset + 42) + prependedDataLength;
            const decode = getOptionValue(zipReader, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_DECODE_TEXT"]) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$util$2f$decode$2d$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"];
            const rawFilenameEncoding = filenameUTF8 ? CHARSET_UTF8 : filenameEncoding || CHARSET_CP437;
            const rawCommentEncoding = commentUTF8 ? CHARSET_UTF8 : commentEncoding || CHARSET_CP437;
            let filename = decode(rawFilename, rawFilenameEncoding);
            if (filename === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
                filename = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$util$2f$decode$2d$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(rawFilename, rawFilenameEncoding);
            }
            let comment = decode(rawComment, rawCommentEncoding);
            if (comment === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
                comment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$util$2f$decode$2d$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(rawComment, rawCommentEncoding);
            }
            Object.assign(fileEntry, {
                versionMadeBy,
                msDosCompatible,
                compressedSize: 0,
                uncompressedSize: 0,
                commentLength,
                offset: offsetFileEntry,
                diskNumberStart: getUint16(directoryView, offset + 34),
                internalFileAttributes: getUint16(directoryView, offset + 36),
                externalFileAttributes,
                msdosAttributesRaw,
                msdosAttributes,
                rawFilename,
                filenameUTF8,
                commentUTF8,
                rawExtraField: directoryArray.subarray(extraFieldOffset, commentOffset),
                rawComment,
                filename,
                comment
            });
            startOffset = Math.max(offsetFileEntry, startOffset);
            readCommonFooter(fileEntry, fileEntry, directoryView, offset + 6);
            const unixExternalUpper = fileEntry.externalFileAttributes >> 16 & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"];
            if (fileEntry.unixMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && (unixExternalUpper & (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_DEFAULT_MASK"] | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_EXECUTABLE_MASK"] | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_TYPE_DIR"])) != 0) {
                fileEntry.unixMode = unixExternalUpper;
            }
            const setuid = Boolean(fileEntry.unixMode & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_SETUID_MASK"]);
            const setgid = Boolean(fileEntry.unixMode & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_SETGID_MASK"]);
            const sticky = Boolean(fileEntry.unixMode & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_STICKY_MASK"]);
            const executable = fileEntry.unixMode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] ? (fileEntry.unixMode & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_EXECUTABLE_MASK"]) != 0 : unixCompatible && (unixExternalUpper & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_EXECUTABLE_MASK"]) != 0;
            const modeIsDir = fileEntry.unixMode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && (fileEntry.unixMode & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_TYPE_MASK"]) == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_TYPE_DIR"];
            const upperIsDir = (unixExternalUpper & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_TYPE_MASK"]) == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_TYPE_DIR"];
            Object.assign(fileEntry, {
                setuid,
                setgid,
                sticky,
                unixExternalUpper,
                internalFileAttribute: fileEntry.internalFileAttributes,
                externalFileAttribute: fileEntry.externalFileAttributes,
                executable,
                directory: modeIsDir || upperIsDir || msDosCompatible && msdosAttributes.directory || filename.endsWith(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTORY_SIGNATURE"]) && !fileEntry.uncompressedSize,
                zipCrypto: fileEntry.encrypted && !fileEntry.extraFieldAES
            });
            const entry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Entry"](fileEntry);
            entry.getData = (writer, options)=>fileEntry.getData(writer, entry, zipReader.readRanges, options);
            entry.arrayBuffer = async (options)=>{
                const writer = new TransformStream();
                const [arrayBuffer] = await Promise.all([
                    new Response(writer.readable).arrayBuffer(),
                    fileEntry.getData(writer, entry, zipReader.readRanges, options)
                ]);
                return arrayBuffer;
            };
            offset = endOffset;
            const { onprogress } = options;
            if (onprogress) {
                try {
                    await onprogress(indexFile + 1, filesLength, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Entry"](fileEntry));
                } catch  {
                // ignored
                }
            }
            yield entry;
        }
        const extractPrependedData = getOptionValue(zipReader, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_EXTRACT_PREPENDED_DATA"]);
        const extractAppendedData = getOptionValue(zipReader, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_EXTRACT_APPENDED_DATA"]);
        if (extractPrependedData) {
            zipReader.prependedData = startOffset > 0 ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8Array"])(reader, 0, startOffset) : new Uint8Array();
        }
        zipReader.comment = commentLength ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8Array"])(reader, commentOffset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["END_OF_CENTRAL_DIR_LENGTH"], commentLength) : new Uint8Array();
        if (extractAppendedData) {
            zipReader.appendedData = appendedDataOffset < reader.size ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8Array"])(reader, appendedDataOffset, reader.size - appendedDataOffset) : new Uint8Array();
        }
        return true;
    }
    async getEntries(options = {}) {
        const entries = [];
        for await (const entry of this.getEntriesGenerator(options)){
            entries.push(entry);
        }
        return entries;
    }
    async close() {}
}
class ZipReaderStream {
    constructor(options = {}){
        const { readable, writable } = new TransformStream();
        const gen = new ZipReader(readable, options).getEntriesGenerator();
        this.readable = new ReadableStream({
            async pull (controller) {
                const { done, value } = await gen.next();
                if (done) return controller.close();
                const chunk = {
                    ...value,
                    readable: function() {
                        const { readable, writable } = new TransformStream();
                        if (value.getData) {
                            value.getData(writable);
                            return readable;
                        }
                    }()
                };
                delete chunk.getData;
                controller.enqueue(chunk);
            }
        });
        this.writable = writable;
    }
}
;
class ZipEntry {
    constructor(reader, config, options){
        Object.assign(this, {
            reader,
            config,
            options
        });
    }
    async getData(writer, fileEntry, readRanges, options = {}) {
        const zipEntry = this;
        const { reader, offset, diskNumberStart, extraFieldAES, extraFieldZip64, compressionMethod, config, bitFlag, signature, rawLastModDate, uncompressedSize, compressedSize } = zipEntry;
        const { dataDescriptor } = bitFlag;
        const localDirectory = fileEntry.localDirectory = {};
        const dataArray = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8Array"])(reader, offset, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_SIZE"], diskNumberStart);
        const dataView = getDataView(dataArray);
        let password = getOptionValue(zipEntry, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_PASSWORD"]);
        let rawPassword = getOptionValue(zipEntry, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_RAW_PASSWORD"]);
        const passThrough = getOptionValue(zipEntry, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_PASS_THROUGH"]);
        password = password && password.length && password;
        rawPassword = rawPassword && rawPassword.length && rawPassword;
        if (extraFieldAES) {
            if (extraFieldAES.originalCompressionMethod != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COMPRESSION_METHOD_AES"]) {
                throw new Error(ERR_UNSUPPORTED_COMPRESSION);
            }
        }
        if (compressionMethod != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COMPRESSION_METHOD_STORE"] && compressionMethod != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COMPRESSION_METHOD_DEFLATE"] && compressionMethod != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COMPRESSION_METHOD_DEFLATE_64"] && !passThrough) {
            throw new Error(ERR_UNSUPPORTED_COMPRESSION);
        }
        if (getUint32(dataView, 0) != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LOCAL_FILE_HEADER_SIGNATURE"]) {
            throw new Error(ERR_LOCAL_FILE_HEADER_NOT_FOUND);
        }
        readCommonHeader(localDirectory, dataView, 4);
        const { extraFieldLength, filenameLength, lastAccessDate, creationDate } = localDirectory;
        localDirectory.rawExtraField = extraFieldLength ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8Array"])(reader, offset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_SIZE"] + filenameLength, extraFieldLength, diskNumberStart) : new Uint8Array();
        readCommonFooter(zipEntry, localDirectory, dataView, 4, true);
        Object.assign(fileEntry, {
            lastAccessDate,
            creationDate
        });
        const encrypted = zipEntry.encrypted && localDirectory.encrypted && !passThrough;
        const zipCrypto = encrypted && !extraFieldAES;
        if (!passThrough) {
            fileEntry.zipCrypto = zipCrypto;
        }
        if (encrypted) {
            if (!zipCrypto && extraFieldAES.strength === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
                throw new Error(ERR_UNSUPPORTED_ENCRYPTION);
            } else if (!password && !rawPassword) {
                throw new Error(ERR_ENCRYPTED);
            }
        }
        const dataOffset = offset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_SIZE"] + filenameLength + extraFieldLength;
        const size = compressedSize;
        const readable = reader.readable;
        Object.assign(readable, {
            diskNumberStart,
            offset: dataOffset,
            size
        });
        const signal = getOptionValue(zipEntry, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_SIGNAL"]);
        const checkPasswordOnly = getOptionValue(zipEntry, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_CHECK_PASSWORD_ONLY"]);
        let checkOverlappingEntry = getOptionValue(zipEntry, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_CHECK_OVERLAPPING_ENTRY"]);
        const checkOverlappingEntryOnly = getOptionValue(zipEntry, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_CHECK_OVERLAPPING_ENTRY_ONLY"]);
        if (checkOverlappingEntryOnly) {
            checkOverlappingEntry = true;
        }
        const { onstart, onprogress, onend } = options;
        const deflate64 = compressionMethod == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COMPRESSION_METHOD_DEFLATE_64"];
        let useCompressionStream = getOptionValue(zipEntry, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_USE_COMPRESSION_STREAM"]);
        if (deflate64) {
            useCompressionStream = false;
        }
        const workerOptions = {
            options: {
                codecType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codec$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CODEC_INFLATE"],
                password,
                rawPassword,
                zipCrypto,
                encryptionStrength: extraFieldAES && extraFieldAES.strength,
                signed: getOptionValue(zipEntry, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_CHECK_SIGNATURE"]) && !passThrough,
                passwordVerification: zipCrypto && (dataDescriptor ? rawLastModDate >>> 8 & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_8_BITS"] : signature >>> 24 & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_8_BITS"]),
                outputSize: passThrough ? compressedSize : uncompressedSize,
                signature,
                compressed: compressionMethod != 0 && !passThrough,
                encrypted: zipEntry.encrypted && !passThrough,
                useWebWorkers: getOptionValue(zipEntry, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_USE_WEB_WORKERS"]),
                useCompressionStream,
                transferStreams: getOptionValue(zipEntry, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_TRANSFER_STREAMS"]),
                deflate64,
                checkPasswordOnly
            },
            config,
            streamOptions: {
                signal,
                size,
                onstart,
                onprogress,
                onend
            }
        };
        if (checkOverlappingEntry) {
            await detectOverlappingEntry({
                reader,
                fileEntry,
                offset,
                diskNumberStart,
                signature,
                compressedSize,
                uncompressedSize,
                dataOffset,
                dataDescriptor: dataDescriptor || localDirectory.bitFlag.dataDescriptor,
                extraFieldZip64: extraFieldZip64 || localDirectory.extraFieldZip64,
                readRanges
            });
        }
        let writable;
        try {
            if (!checkOverlappingEntryOnly) {
                if (checkPasswordOnly) {
                    writer = new WritableStream();
                }
                writer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GenericWriter"](writer);
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initStream"])(writer, passThrough ? compressedSize : uncompressedSize);
                ({ writable } = writer);
                const { outputSize } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$codec$2d$pool$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["runWorker"])({
                    readable,
                    writable
                }, workerOptions);
                writer.size += outputSize;
                if (outputSize != (passThrough ? compressedSize : uncompressedSize)) {
                    throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zip$2d$entry$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ERR_INVALID_UNCOMPRESSED_SIZE"]);
                }
            }
        } catch (error) {
            if (error.outputSize !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
                writer.size += error.outputSize;
            }
            if (!checkPasswordOnly || error.message != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_ABORT_CHECK_PASSWORD"]) {
                throw error;
            }
        } finally{
            const preventClose = getOptionValue(zipEntry, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_PREVENT_CLOSE"]);
            if (!preventClose && writable && !writable.locked) {
                await writable.getWriter().close();
            }
        }
        return checkPasswordOnly || checkOverlappingEntryOnly ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] : writer.getData ? writer.getData() : writable;
    }
}
function readCommonHeader(directory, dataView, offset) {
    const rawBitFlag = directory.rawBitFlag = getUint16(dataView, offset + 2);
    const encrypted = (rawBitFlag & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITFLAG_ENCRYPTED"]) == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITFLAG_ENCRYPTED"];
    const rawLastModDate = getUint32(dataView, offset + 6);
    Object.assign(directory, {
        encrypted,
        version: getUint16(dataView, offset),
        bitFlag: {
            level: (rawBitFlag & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITFLAG_LEVEL"]) >> 1,
            dataDescriptor: (rawBitFlag & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITFLAG_DATA_DESCRIPTOR"]) == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITFLAG_DATA_DESCRIPTOR"],
            languageEncodingFlag: (rawBitFlag & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITFLAG_LANG_ENCODING_FLAG"]) == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITFLAG_LANG_ENCODING_FLAG"]
        },
        rawLastModDate,
        lastModDate: getDate(rawLastModDate),
        filenameLength: getUint16(dataView, offset + 22),
        extraFieldLength: getUint16(dataView, offset + 24)
    });
}
function readCommonFooter(fileEntry, directory, dataView, offset, localDirectory) {
    const { rawExtraField } = directory;
    const extraField = directory.extraField = new Map();
    const rawExtraFieldView = getDataView(new Uint8Array(rawExtraField));
    let offsetExtraField = 0;
    try {
        while(offsetExtraField < rawExtraField.length){
            const type = getUint16(rawExtraFieldView, offsetExtraField);
            const size = getUint16(rawExtraFieldView, offsetExtraField + 2);
            extraField.set(type, {
                type,
                data: rawExtraField.slice(offsetExtraField + 4, offsetExtraField + 4 + size)
            });
            offsetExtraField += 4 + size;
        }
    } catch  {
    // ignored
    }
    const compressionMethod = getUint16(dataView, offset + 4);
    Object.assign(directory, {
        signature: getUint32(dataView, offset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_OFFSET_SIGNATURE"]),
        compressedSize: getUint32(dataView, offset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_OFFSET_COMPRESSED_SIZE"]),
        uncompressedSize: getUint32(dataView, offset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_OFFSET_UNCOMPRESSED_SIZE"])
    });
    const extraFieldZip64 = extraField.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_ZIP64"]);
    if (extraFieldZip64) {
        readExtraFieldZip64(extraFieldZip64, directory);
        directory.extraFieldZip64 = extraFieldZip64;
    }
    const extraFieldUnicodePath = extraField.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_UNICODE_PATH"]);
    if (extraFieldUnicodePath) {
        readExtraFieldUnicode(extraFieldUnicodePath, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_FILENAME"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_RAW_FILENAME"], directory, fileEntry);
        directory.extraFieldUnicodePath = extraFieldUnicodePath;
    }
    const extraFieldUnicodeComment = extraField.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_UNICODE_COMMENT"]);
    if (extraFieldUnicodeComment) {
        readExtraFieldUnicode(extraFieldUnicodeComment, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_COMMENT"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_RAW_COMMENT"], directory, fileEntry);
        directory.extraFieldUnicodeComment = extraFieldUnicodeComment;
    }
    const extraFieldAES = extraField.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_AES"]);
    if (extraFieldAES) {
        readExtraFieldAES(extraFieldAES, directory, compressionMethod);
        directory.extraFieldAES = extraFieldAES;
    } else {
        directory.compressionMethod = compressionMethod;
    }
    const extraFieldNTFS = extraField.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_NTFS"]);
    if (extraFieldNTFS) {
        readExtraFieldNTFS(extraFieldNTFS, directory);
        directory.extraFieldNTFS = extraFieldNTFS;
    }
    const extraFieldUnix = extraField.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_UNIX"]);
    if (extraFieldUnix) {
        readExtraFieldUnix(extraFieldUnix, directory, false);
        directory.extraFieldUnix = extraFieldUnix;
    } else {
        const extraFieldInfoZip = extraField.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_INFOZIP"]);
        if (extraFieldInfoZip) {
            readExtraFieldUnix(extraFieldInfoZip, directory, true);
            directory.extraFieldInfoZip = extraFieldInfoZip;
        }
    }
    const extraFieldExtendedTimestamp = extraField.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP"]);
    if (extraFieldExtendedTimestamp) {
        readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory, localDirectory);
        directory.extraFieldExtendedTimestamp = extraFieldExtendedTimestamp;
    }
    const extraFieldUSDZ = extraField.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_USDZ"]);
    if (extraFieldUSDZ) {
        directory.extraFieldUSDZ = extraFieldUSDZ;
    }
}
function readExtraFieldZip64(extraFieldZip64, directory) {
    directory.zip64 = true;
    const extraFieldView = getDataView(extraFieldZip64.data);
    const missingProperties = ZIP64_PROPERTIES.filter(([propertyName, max])=>directory[propertyName] == max);
    for(let indexMissingProperty = 0, offset = 0; indexMissingProperty < missingProperties.length; indexMissingProperty++){
        const [propertyName, max] = missingProperties[indexMissingProperty];
        if (directory[propertyName] == max) {
            const extraction = ZIP64_EXTRACTION[max];
            directory[propertyName] = extraFieldZip64[propertyName] = extraction.getValue(extraFieldView, offset);
            offset += extraction.bytes;
        } else if (extraFieldZip64[propertyName]) {
            throw new Error(ERR_EXTRAFIELD_ZIP64_NOT_FOUND);
        }
    }
}
function readExtraFieldUnicode(extraFieldUnicode, propertyName, rawPropertyName, directory, fileEntry) {
    const extraFieldView = getDataView(extraFieldUnicode.data);
    const crc32 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codecs$2f$crc32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Crc32"]();
    crc32.append(fileEntry[rawPropertyName]);
    const dataViewSignature = getDataView(new Uint8Array(4));
    dataViewSignature.setUint32(0, crc32.get(), true);
    const signature = getUint32(extraFieldView, 1);
    Object.assign(extraFieldUnicode, {
        version: getUint8(extraFieldView, 0),
        [propertyName]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$util$2f$decode$2d$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(extraFieldUnicode.data.subarray(5)),
        valid: !fileEntry.bitFlag.languageEncodingFlag && signature == getUint32(dataViewSignature, 0)
    });
    if (extraFieldUnicode.valid) {
        directory[propertyName] = extraFieldUnicode[propertyName];
        directory[propertyName + PROPERTY_NAME_UTF8_SUFFIX] = true;
    }
}
function readExtraFieldAES(extraFieldAES, directory, compressionMethod) {
    const extraFieldView = getDataView(extraFieldAES.data);
    const strength = getUint8(extraFieldView, 4);
    Object.assign(extraFieldAES, {
        vendorVersion: getUint8(extraFieldView, 0),
        vendorId: getUint8(extraFieldView, 2),
        strength,
        originalCompressionMethod: compressionMethod,
        compressionMethod: getUint16(extraFieldView, 5)
    });
    directory.compressionMethod = extraFieldAES.compressionMethod;
}
function readExtraFieldNTFS(extraFieldNTFS, directory) {
    const extraFieldView = getDataView(extraFieldNTFS.data);
    let offsetExtraField = 4;
    let tag1Data;
    try {
        while(offsetExtraField < extraFieldNTFS.data.length && !tag1Data){
            const tagValue = getUint16(extraFieldView, offsetExtraField);
            const attributeSize = getUint16(extraFieldView, offsetExtraField + 2);
            if (tagValue == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_NTFS_TAG1"]) {
                tag1Data = extraFieldNTFS.data.slice(offsetExtraField + 4, offsetExtraField + 4 + attributeSize);
            }
            offsetExtraField += 4 + attributeSize;
        }
    } catch  {
    // ignored
    }
    try {
        if (tag1Data && tag1Data.length == 24) {
            const tag1View = getDataView(tag1Data);
            const rawLastModDate = tag1View.getBigUint64(0, true);
            const rawLastAccessDate = tag1View.getBigUint64(8, true);
            const rawCreationDate = tag1View.getBigUint64(16, true);
            Object.assign(extraFieldNTFS, {
                rawLastModDate,
                rawLastAccessDate,
                rawCreationDate
            });
            const lastModDate = getDateNTFS(rawLastModDate);
            const lastAccessDate = getDateNTFS(rawLastAccessDate);
            const creationDate = getDateNTFS(rawCreationDate);
            const extraFieldData = {
                lastModDate,
                lastAccessDate,
                creationDate
            };
            Object.assign(extraFieldNTFS, extraFieldData);
            Object.assign(directory, extraFieldData);
        }
    } catch  {
    // ignored
    }
}
function readExtraFieldUnix(extraField, directory, isInfoZip) {
    try {
        const view = getDataView(new Uint8Array(extraField.data));
        let offset = 0;
        const version = getUint8(view, offset++);
        const uidSize = getUint8(view, offset++);
        const uidBytes = extraField.data.subarray(offset, offset + uidSize);
        offset += uidSize;
        const uid = unpackUnixId(uidBytes);
        const gidSize = getUint8(view, offset++);
        const gidBytes = extraField.data.subarray(offset, offset + gidSize);
        offset += gidSize;
        const gid = unpackUnixId(gidBytes);
        let unixMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"];
        if (!isInfoZip && offset + 2 <= extraField.data.length) {
            const base = extraField.data;
            const modeView = new DataView(base.buffer, base.byteOffset + offset, 2);
            unixMode = modeView.getUint16(0, true);
        }
        Object.assign(extraField, {
            version,
            uid,
            gid,
            unixMode
        });
        if (uid !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
            directory.uid = uid;
        }
        if (gid !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
            directory.gid = gid;
        }
        if (unixMode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
            directory.unixMode = unixMode;
        }
    } catch  {
    // ignored
    }
}
function unpackUnixId(bytes) {
    const buffer = new Uint8Array(4);
    buffer.set(bytes, 0);
    const view = new DataView(buffer.buffer, buffer.byteOffset, 4);
    return view.getUint32(0, true);
}
function readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory, localDirectory) {
    const extraFieldView = getDataView(extraFieldExtendedTimestamp.data);
    const flags = getUint8(extraFieldView, 0);
    const timeProperties = [];
    const timeRawProperties = [];
    if (localDirectory) {
        if ((flags & 0x1) == 0x1) {
            timeProperties.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_LAST_MODIFICATION_DATE"]);
            timeRawProperties.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE"]);
        }
        if ((flags & 0x2) == 0x2) {
            timeProperties.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_LAST_ACCESS_DATE"]);
            timeRawProperties.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_RAW_LAST_ACCESS_DATE"]);
        }
        if ((flags & 0x4) == 0x4) {
            timeProperties.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_CREATION_DATE"]);
            timeRawProperties.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_RAW_CREATION_DATE"]);
        }
    } else if (extraFieldExtendedTimestamp.data.length >= 5) {
        timeProperties.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_LAST_MODIFICATION_DATE"]);
        timeRawProperties.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE"]);
    }
    let offset = 1;
    timeProperties.forEach((propertyName, indexProperty)=>{
        if (extraFieldExtendedTimestamp.data.length >= offset + 4) {
            const time = getUint32(extraFieldView, offset);
            directory[propertyName] = extraFieldExtendedTimestamp[propertyName] = new Date(time * 1000);
            const rawPropertyName = timeRawProperties[indexProperty];
            extraFieldExtendedTimestamp[rawPropertyName] = time;
        }
        offset += 4;
    });
}
async function detectOverlappingEntry({ reader, fileEntry, offset, diskNumberStart, signature, compressedSize, uncompressedSize, dataOffset, dataDescriptor, extraFieldZip64, readRanges }) {
    let diskOffset = 0;
    if (diskNumberStart) {
        for(let indexReader = 0; indexReader < diskNumberStart; indexReader++){
            const diskReader = reader.readers[indexReader];
            diskOffset += diskReader.size;
        }
    }
    let dataDescriptorLength = 0;
    if (dataDescriptor) {
        if (extraFieldZip64) {
            dataDescriptorLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DATA_DESCRIPTOR_RECORD_ZIP_64_LENGTH"];
        } else {
            dataDescriptorLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DATA_DESCRIPTOR_RECORD_LENGTH"];
        }
    }
    if (dataDescriptorLength) {
        const dataDescriptorArray = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8Array"])(reader, dataOffset + compressedSize, dataDescriptorLength + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DATA_DESCRIPTOR_RECORD_SIGNATURE_LENGTH"], diskNumberStart);
        const dataDescriptorSignature = getUint32(getDataView(dataDescriptorArray), 0) == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DATA_DESCRIPTOR_RECORD_SIGNATURE"];
        if (dataDescriptorSignature) {
            const readSignature = getUint32(getDataView(dataDescriptorArray), 4);
            let readCompressedSize;
            let readUncompressedSize;
            if (extraFieldZip64) {
                readCompressedSize = getBigUint64(getDataView(dataDescriptorArray), 8);
                readUncompressedSize = getBigUint64(getDataView(dataDescriptorArray), 16);
            } else {
                readCompressedSize = getUint32(getDataView(dataDescriptorArray), 8);
                readUncompressedSize = getUint32(getDataView(dataDescriptorArray), 12);
            }
            const matchSignature = fileEntry.encrypted && !fileEntry.zipCrypto || readSignature == signature;
            if (matchSignature && readCompressedSize == compressedSize && readUncompressedSize == uncompressedSize) {
                dataDescriptorLength += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DATA_DESCRIPTOR_RECORD_SIGNATURE_LENGTH"];
            }
        }
    }
    const range = {
        start: diskOffset + offset,
        end: diskOffset + dataOffset + compressedSize + dataDescriptorLength,
        fileEntry
    };
    for (const otherRange of readRanges){
        if (otherRange.fileEntry != fileEntry && range.start >= otherRange.start && range.start < otherRange.end) {
            const error = new Error(ERR_OVERLAPPING_ENTRY);
            error.overlappingEntry = otherRange.fileEntry;
            throw error;
        }
    }
    readRanges.push(range);
}
async function seekSignature(reader, signature, startOffset, minimumBytes, maximumLength) {
    const signatureArray = new Uint8Array(4);
    const signatureView = getDataView(signatureArray);
    setUint32(signatureView, 0, signature);
    const maximumBytes = minimumBytes + maximumLength;
    return await seek(minimumBytes) || await seek(Math.min(maximumBytes, startOffset));
    //TURBOPACK unreachable
    ;
    async function seek(length) {
        const offset = startOffset - length;
        const bytes = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readUint8Array"])(reader, offset, length);
        for(let indexByte = bytes.length - minimumBytes; indexByte >= 0; indexByte--){
            if (bytes[indexByte] == signatureArray[0] && bytes[indexByte + 1] == signatureArray[1] && bytes[indexByte + 2] == signatureArray[2] && bytes[indexByte + 3] == signatureArray[3]) {
                return {
                    offset: offset + indexByte,
                    buffer: bytes.slice(indexByte, indexByte + minimumBytes).buffer
                };
            }
        }
    }
}
function getOptionValue(zipReader, options, name) {
    return options[name] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] ? zipReader.options[name] : options[name];
}
function getDate(timeRaw) {
    const date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"];
    try {
        return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5, (time & 0x001F) * 2, 0);
    } catch  {
    // ignored
    }
}
function getDateNTFS(timeRaw) {
    return new Date(Number(timeRaw / BigInt(10000) - BigInt(11644473600000)));
}
function getUint8(view, offset) {
    return view.getUint8(offset);
}
function getUint16(view, offset) {
    return view.getUint16(offset, true);
}
function getUint32(view, offset) {
    return view.getUint32(offset, true);
}
function getBigUint64(view, offset) {
    return Number(view.getBigUint64(offset, true));
}
function setUint32(view, offset, value) {
    view.setUint32(offset, value, true);
}
function getDataView(array) {
    return new DataView(array.buffer);
}
}),
"[project]/node_modules/@zip.js/zip.js/lib/zip-core-reader.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
/*
 Copyright (c) 2025 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/zip-reader.js [app-client] (ecmascript) <locals>");
;
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/zip-writer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ERR_DUPLICATED_NAME",
    ()=>ERR_DUPLICATED_NAME,
    "ERR_INVALID_COMMENT",
    ()=>ERR_INVALID_COMMENT,
    "ERR_INVALID_ENCRYPTION_STRENGTH",
    ()=>ERR_INVALID_ENCRYPTION_STRENGTH,
    "ERR_INVALID_ENTRY_COMMENT",
    ()=>ERR_INVALID_ENTRY_COMMENT,
    "ERR_INVALID_ENTRY_NAME",
    ()=>ERR_INVALID_ENTRY_NAME,
    "ERR_INVALID_EXTRAFIELD_DATA",
    ()=>ERR_INVALID_EXTRAFIELD_DATA,
    "ERR_INVALID_EXTRAFIELD_TYPE",
    ()=>ERR_INVALID_EXTRAFIELD_TYPE,
    "ERR_INVALID_VERSION",
    ()=>ERR_INVALID_VERSION,
    "ERR_UNDEFINED_UNCOMPRESSED_SIZE",
    ()=>ERR_UNDEFINED_UNCOMPRESSED_SIZE,
    "ERR_UNSUPPORTED_FORMAT",
    ()=>ERR_UNSUPPORTED_FORMAT,
    "ERR_ZIP_NOT_EMPTY",
    ()=>ERR_ZIP_NOT_EMPTY,
    "ZipWriter",
    ()=>ZipWriter,
    "ZipWriterStream",
    ()=>ZipWriterStream
]);
/*
 Copyright (c) 2025 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /* global TransformStream, Response */ // deno-lint-ignore-file no-this-alias
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$configuration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/configuration.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$codec$2d$pool$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/codec-pool.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codec$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/codec-stream.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/io.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$util$2f$encode$2d$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/util/encode-text.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/zip-entry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/options.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/zip-reader.js [app-client] (ecmascript) <locals>");
;
;
;
;
;
;
;
;
const ERR_DUPLICATED_NAME = "File already exists";
const ERR_INVALID_COMMENT = "Zip file comment exceeds 64KB";
const ERR_INVALID_ENTRY_COMMENT = "File entry comment exceeds 64KB";
const ERR_INVALID_ENTRY_NAME = "File entry name exceeds 64KB";
const ERR_INVALID_VERSION = "Version exceeds 65535";
const ERR_INVALID_ENCRYPTION_STRENGTH = "The strength must equal 1, 2, or 3";
const ERR_INVALID_EXTRAFIELD_TYPE = "Extra field type exceeds 65535";
const ERR_INVALID_EXTRAFIELD_DATA = "Extra field data exceeds 64KB";
const ERR_UNSUPPORTED_FORMAT = "Zip64 is not supported (make sure 'keepOrder' is set to 'true')";
const ERR_UNDEFINED_UNCOMPRESSED_SIZE = "Undefined uncompressed size";
const ERR_ZIP_NOT_EMPTY = "Zip file not empty";
const ERR_INVALID_UID = "Invalid uid (must be integer 0..2^32-1)";
const ERR_INVALID_GID = "Invalid gid (must be integer 0..2^32-1)";
const ERR_INVALID_UNIX_MODE = "Invalid UNIX mode (must be integer 0..65535)";
const ERR_INVALID_UNIX_EXTRA_FIELD_TYPE = "Invalid unixExtraFieldType (must be 'infozip' or 'unix')";
const ERR_INVALID_MSDOS_ATTRIBUTES = "Invalid msdosAttributesRaw (must be integer 0..255)";
const ERR_INVALID_MSDOS_DATA = "Invalid msdosAttributes (must be an object with boolean flags)";
const EXTRAFIELD_DATA_AES = new Uint8Array([
    0x07,
    0x00,
    0x02,
    0x00,
    0x41,
    0x45,
    0x03,
    0x00,
    0x00
]);
const INFOZIP_EXTRA_FIELD_TYPE = "infozip";
const UNIX_EXTRA_FIELD_TYPE = "unix";
let workers = 0;
const pendingEntries = [];
class ZipWriter {
    constructor(writer, options = {}){
        writer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GenericWriter"](writer);
        const addSplitZipSignature = writer.availableSize !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && writer.availableSize > 0 && writer.availableSize !== Infinity && writer.maxSize !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && writer.maxSize > 0 && writer.maxSize !== Infinity;
        Object.assign(this, {
            writer,
            addSplitZipSignature,
            options,
            config: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$configuration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getConfiguration"])(),
            files: new Map(),
            filenames: new Set(),
            offset: options[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_OFFSET"]] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] ? writer.size || writer.writable.size || 0 : options[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_OFFSET"]],
            pendingEntriesSize: 0,
            pendingAddFileCalls: new Set(),
            bufferedWrites: 0
        });
    }
    async prependZip(reader) {
        if (this.filenames.size) {
            throw new Error(ERR_ZIP_NOT_EMPTY);
        }
        reader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GenericReader"](reader);
        const zipReader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ZipReader"](reader.readable);
        const entries = await zipReader.getEntries();
        await zipReader.close();
        await reader.readable.pipeTo(this.writer.writable, {
            preventClose: true,
            preventAbort: true
        });
        this.writer.size = this.offset = reader.size;
        this.filenames = new Set(entries.map((entry)=>entry.filename));
        this.files = new Map(entries.map((entry)=>{
            const { version, compressionMethod, lastModDate, lastAccessDate, creationDate, rawFilename, bitFlag, encrypted, uncompressedSize, compressedSize, diskOffset, diskNumber, zip64 } = entry;
            let { rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraFieldUnix, rawExtraField } = entry;
            const { level, languageEncodingFlag, dataDescriptor } = bitFlag;
            rawExtraFieldZip64 = rawExtraFieldZip64 || new Uint8Array();
            rawExtraFieldAES = rawExtraFieldAES || new Uint8Array();
            rawExtraFieldExtendedTimestamp = rawExtraFieldExtendedTimestamp || new Uint8Array();
            rawExtraFieldNTFS = rawExtraFieldNTFS || new Uint8Array();
            rawExtraFieldUnix = entry.rawExtraFieldUnix || new Uint8Array();
            rawExtraField = rawExtraField || new Uint8Array();
            const extraFieldLength = getLength(rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraFieldUnix, rawExtraField);
            const zip64UncompressedSize = zip64 && uncompressedSize > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"];
            const zip64CompressedSize = zip64 && compressedSize > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"];
            const { headerArray, headerView } = getHeaderArrayData({
                version,
                bitFlag: getBitFlag(level, languageEncodingFlag, dataDescriptor, encrypted, compressionMethod),
                compressionMethod,
                uncompressedSize,
                compressedSize,
                lastModDate,
                rawFilename,
                zip64CompressedSize,
                zip64UncompressedSize,
                extraFieldLength
            });
            Object.assign(entry, {
                zip64UncompressedSize,
                zip64CompressedSize,
                zip64Offset: zip64 && this.offset - diskOffset > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"],
                zip64DiskNumberStart: zip64 && diskNumber > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"],
                rawExtraFieldZip64,
                rawExtraFieldAES,
                rawExtraFieldExtendedTimestamp,
                rawExtraFieldNTFS,
                rawExtraFieldUnix,
                rawExtraField,
                extendedTimestamp: rawExtraFieldExtendedTimestamp.length > 0 || rawExtraFieldNTFS.length > 0,
                extraFieldExtendedTimestampFlag: 0x1 + (lastAccessDate ? 0x2 : 0) + (creationDate ? 0x4 : 0),
                headerArray,
                headerView
            });
            return [
                entry.filename,
                entry
            ];
        }));
    }
    async add(name = "", reader, options = {}) {
        const zipWriter = this;
        const { pendingAddFileCalls, config } = zipWriter;
        if (workers < config.maxWorkers) {
            workers++;
        } else {
            await new Promise((resolve)=>pendingEntries.push(resolve));
        }
        let promiseAddFile;
        try {
            name = name.trim();
            if (zipWriter.filenames.has(name)) {
                throw new Error(ERR_DUPLICATED_NAME);
            }
            zipWriter.filenames.add(name);
            promiseAddFile = addFile(zipWriter, name, reader, options);
            pendingAddFileCalls.add(promiseAddFile);
            return await promiseAddFile;
        } catch (error) {
            zipWriter.filenames.delete(name);
            throw error;
        } finally{
            pendingAddFileCalls.delete(promiseAddFile);
            const pendingEntry = pendingEntries.shift();
            if (pendingEntry) {
                pendingEntry();
            } else {
                workers--;
            }
        }
    }
    remove(entry) {
        const { filenames, files } = this;
        if (typeof entry == "string") {
            entry = files.get(entry);
        }
        if (entry && entry.filename !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
            const { filename } = entry;
            if (filenames.has(filename) && files.has(filename)) {
                filenames.delete(filename);
                files.delete(filename);
                return true;
            }
        }
        return false;
    }
    async close(comment = new Uint8Array(), options = {}) {
        const zipWriter = this;
        const { pendingAddFileCalls, writer } = this;
        const { writable } = writer;
        while(pendingAddFileCalls.size){
            await Promise.allSettled(Array.from(pendingAddFileCalls));
        }
        await closeFile(zipWriter, comment, options);
        const preventClose = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_PREVENT_CLOSE"]);
        if (!preventClose) {
            await writable.getWriter().close();
        }
        return writer.getData ? writer.getData() : writable;
    }
}
class ZipWriterStream {
    constructor(options = {}){
        const { readable, writable } = new TransformStream();
        this.readable = readable;
        this.zipWriter = new ZipWriter(writable, options);
    }
    transform(path) {
        const { readable, writable } = new TransformStream({
            flush: ()=>{
                this.zipWriter.close();
            }
        });
        this.zipWriter.add(path, readable);
        return {
            readable: this.readable,
            writable
        };
    }
    writable(path) {
        const { readable, writable } = new TransformStream();
        this.zipWriter.add(path, readable);
        return writable;
    }
    close(comment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"], options = {}) {
        return this.zipWriter.close(comment, options);
    }
}
;
async function addFile(zipWriter, name, reader, options) {
    name = name.trim();
    let msDosCompatible = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_MS_DOS_COMPATIBLE"]);
    let versionMadeBy = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_VERSION_MADE_BY"], msDosCompatible ? 20 : 768);
    const executable = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_EXECUTABLE"]);
    const uid = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_UID"]);
    const gid = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_GID"]);
    let unixMode = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_UNIX_MODE"]);
    const unixExtraFieldType = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_UNIX_EXTRA_FIELD_TYPE"]);
    let setuid = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_SETUID"]);
    let setgid = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_SETGID"]);
    let sticky = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_STICKY"]);
    if (uid !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && (uid < 0 || uid > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"])) {
        throw new Error(ERR_INVALID_UID);
    }
    if (gid !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && (gid < 0 || gid > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"])) {
        throw new Error(ERR_INVALID_GID);
    }
    if (unixMode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && (unixMode < 0 || unixMode > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"])) {
        throw new Error(ERR_INVALID_UNIX_MODE);
    }
    if (unixExtraFieldType !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && unixExtraFieldType !== INFOZIP_EXTRA_FIELD_TYPE && unixExtraFieldType !== UNIX_EXTRA_FIELD_TYPE) {
        throw new Error(ERR_INVALID_UNIX_EXTRA_FIELD_TYPE);
    }
    let msdosAttributesRaw = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_MSDOS_ATTRIBUTES_RAW"]);
    let msdosAttributes = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_MSDOS_ATTRIBUTES"]);
    const hasUnixMetadata = uid !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] || gid !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] || unixMode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] || unixExtraFieldType;
    const hasMsDosProvided = msdosAttributesRaw !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] || msdosAttributes !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"];
    if (hasUnixMetadata) {
        msDosCompatible = false;
        versionMadeBy = versionMadeBy & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"] | 3 << 8;
    } else if (hasMsDosProvided) {
        msDosCompatible = true;
        versionMadeBy = versionMadeBy & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_8_BITS"];
    }
    if (msdosAttributesRaw !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && (msdosAttributesRaw < 0 || msdosAttributesRaw > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_8_BITS"])) {
        throw new Error(ERR_INVALID_MSDOS_ATTRIBUTES);
    }
    if (msdosAttributes && typeof msdosAttributes !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OBJECT_TYPE"]) {
        throw new Error(ERR_INVALID_MSDOS_DATA);
    }
    if (versionMadeBy > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"]) {
        throw new Error(ERR_INVALID_VERSION);
    }
    let externalFileAttributes = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES"], 0);
    if (!options[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_DIRECTORY"]] && name.endsWith(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTORY_SIGNATURE"])) {
        options[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_DIRECTORY"]] = true;
    }
    const directory = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_DIRECTORY"]);
    if (directory) {
        if (!name.endsWith(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTORY_SIGNATURE"])) {
            name += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTORY_SIGNATURE"];
        }
        if (externalFileAttributes === 0) {
            externalFileAttributes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_MSDOS_DIR_MASK"];
            if (!msDosCompatible) {
                externalFileAttributes |= (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_TYPE_DIR"] | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_EXECUTABLE_MASK"] | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_DEFAULT_MASK"]) << 16;
            }
        }
    } else if (!msDosCompatible && externalFileAttributes === 0) {
        if (executable) {
            externalFileAttributes = (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_EXECUTABLE_MASK"] | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_DEFAULT_MASK"]) << 16;
        } else {
            externalFileAttributes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_DEFAULT_MASK"] << 16;
        }
    }
    let unixExternalUpper;
    if (!msDosCompatible) {
        unixExternalUpper = externalFileAttributes >> 16 & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"];
        unixMode = unixMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] ? unixExternalUpper : unixMode & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"];
        if (setuid) {
            unixMode |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_SETUID_MASK"];
        } else {
            setuid = Boolean(unixMode & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_SETUID_MASK"]);
        }
        if (setgid) {
            unixMode |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_SETGID_MASK"];
        } else {
            setgid = Boolean(unixMode & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_SETGID_MASK"]);
        }
        if (sticky) {
            unixMode |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_STICKY_MASK"];
        } else {
            sticky = Boolean(unixMode & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_STICKY_MASK"]);
        }
        if (directory) {
            unixMode |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_TYPE_DIR"];
        }
        externalFileAttributes = (unixMode & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"]) << 16 | externalFileAttributes & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_8_BITS"];
    }
    ({ msdosAttributesRaw, msdosAttributes } = normalizeMsdosAttributes(msdosAttributesRaw, msdosAttributes));
    if (hasMsDosProvided) {
        externalFileAttributes = externalFileAttributes & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"] | msdosAttributesRaw & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_8_BITS"];
    }
    const encode = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_ENCODE_TEXT"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$util$2f$encode$2d$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeText"]);
    let rawFilename = encode(name);
    if (rawFilename === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
        rawFilename = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$util$2f$encode$2d$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeText"])(name);
    }
    if (getLength(rawFilename) > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"]) {
        throw new Error(ERR_INVALID_ENTRY_NAME);
    }
    const comment = options[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_COMMENT"]] || "";
    let rawComment = encode(comment);
    if (rawComment === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
        rawComment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$util$2f$encode$2d$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeText"])(comment);
    }
    if (getLength(rawComment) > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"]) {
        throw new Error(ERR_INVALID_ENTRY_COMMENT);
    }
    const version = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_VERSION"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERSION_DEFLATE"]);
    if (version > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"]) {
        throw new Error(ERR_INVALID_VERSION);
    }
    const lastModDate = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_LAST_MODIFICATION_DATE"], new Date());
    const lastAccessDate = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_LAST_ACCESS_DATE"]);
    const creationDate = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_CREATION_DATE"]);
    const internalFileAttributes = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES"], 0);
    const passThrough = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_PASS_THROUGH"]);
    let password, rawPassword;
    if (!passThrough) {
        password = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_PASSWORD"]);
        rawPassword = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_RAW_PASSWORD"]);
    }
    const encryptionStrength = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_ENCRYPTION_STRENGTH"], 3);
    const zipCrypto = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_ZIPCRYPTO"]);
    const extendedTimestamp = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_EXTENDED_TIMESTAMP"], true);
    const keepOrder = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_KEEP_ORDER"], true);
    const useWebWorkers = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_USE_WEB_WORKERS"]);
    const bufferedWrite = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_BUFFERED_WRITE"]);
    const dataDescriptorSignature = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_DATA_DESCRIPTOR_SIGNATURE"], false);
    const signal = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_SIGNAL"]);
    const useUnicodeFileNames = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_USE_UNICODE_FILE_NAMES"], true);
    const compressionMethod = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_COMPRESSION_METHOD"]);
    let level = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_LEVEL"]);
    let useCompressionStream = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_USE_COMPRESSION_STREAM"]);
    let dataDescriptor = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_DATA_DESCRIPTOR"]);
    if (bufferedWrite && dataDescriptor === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
        dataDescriptor = false;
    }
    if (dataDescriptor === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] || zipCrypto) {
        dataDescriptor = true;
    }
    if (level !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && level != 6) {
        useCompressionStream = false;
    }
    if (!useCompressionStream && zipWriter.config.CompressionStream === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && zipWriter.config.CompressionStreamZlib === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
        level = 0;
    }
    let zip64 = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_ZIP64"]);
    if (!zipCrypto && (password !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] || rawPassword !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) && !(encryptionStrength >= 1 && encryptionStrength <= 3)) {
        throw new Error(ERR_INVALID_ENCRYPTION_STRENGTH);
    }
    let rawExtraField = new Uint8Array();
    const extraField = options[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_EXTRA_FIELD"]];
    if (extraField) {
        let extraFieldSize = 0;
        let offset = 0;
        extraField.forEach((data)=>extraFieldSize += 4 + getLength(data));
        rawExtraField = new Uint8Array(extraFieldSize);
        extraField.forEach((data, type)=>{
            if (type > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"]) {
                throw new Error(ERR_INVALID_EXTRAFIELD_TYPE);
            }
            if (getLength(data) > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"]) {
                throw new Error(ERR_INVALID_EXTRAFIELD_DATA);
            }
            arraySet(rawExtraField, new Uint16Array([
                type
            ]), offset);
            arraySet(rawExtraField, new Uint16Array([
                getLength(data)
            ]), offset + 2);
            arraySet(rawExtraField, data, offset + 4);
            offset += 4 + getLength(data);
        });
    }
    let maximumCompressedSize = 0;
    let maximumEntrySize = 0;
    let uncompressedSize = 0;
    if (passThrough) {
        uncompressedSize = options[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_UNCOMPRESSED_SIZE"]];
        if (uncompressedSize === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
            throw new Error(ERR_UNDEFINED_UNCOMPRESSED_SIZE);
        }
    }
    const zip64Enabled = zip64 === true;
    if (reader) {
        reader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GenericReader"](reader);
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initStream"])(reader);
        if (!passThrough) {
            if (reader.size === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
                dataDescriptor = true;
                if (zip64 || zip64 === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
                    zip64 = true;
                    uncompressedSize = maximumCompressedSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"] + 1;
                }
            } else {
                options.uncompressedSize = uncompressedSize = reader.size;
                maximumCompressedSize = getMaximumCompressedSize(uncompressedSize);
            }
        } else {
            options.uncompressedSize = uncompressedSize;
            maximumCompressedSize = getMaximumCompressedSize(uncompressedSize);
        }
    }
    const { diskOffset, diskNumber, maxSize } = zipWriter.writer;
    const zip64UncompressedSize = zip64Enabled || uncompressedSize > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"];
    const zip64CompressedSize = zip64Enabled || maximumCompressedSize > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"];
    const zip64Offset = zip64Enabled || zipWriter.offset + zipWriter.pendingEntriesSize - diskOffset > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"];
    const supportZip64SplitFile = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_SUPPORT_ZIP64_SPLIT_FILE"], true);
    const zip64DiskNumberStart = supportZip64SplitFile && zip64Enabled || diskNumber + Math.ceil(zipWriter.pendingEntriesSize / maxSize) > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"];
    if (zip64Offset || zip64UncompressedSize || zip64CompressedSize || zip64DiskNumberStart) {
        if (zip64 === false || !keepOrder) {
            throw new Error(ERR_UNSUPPORTED_FORMAT);
        } else {
            zip64 = true;
        }
    }
    zip64 = zip64 || false;
    const encrypted = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_ENCRYPTED"]);
    options = Object.assign({}, options, {
        rawFilename,
        rawComment,
        version,
        versionMadeBy,
        lastModDate,
        lastAccessDate,
        creationDate,
        rawExtraField,
        zip64,
        zip64UncompressedSize,
        zip64CompressedSize,
        zip64Offset,
        zip64DiskNumberStart,
        password,
        rawPassword,
        level,
        useWebWorkers,
        encryptionStrength,
        extendedTimestamp,
        zipCrypto,
        bufferedWrite,
        keepOrder,
        useUnicodeFileNames,
        dataDescriptor,
        dataDescriptorSignature,
        signal,
        msDosCompatible,
        internalFileAttribute: internalFileAttributes,
        internalFileAttributes,
        externalFileAttribute: externalFileAttributes,
        externalFileAttributes,
        useCompressionStream,
        passThrough,
        encrypted: Boolean(password && getLength(password) || rawPassword && getLength(rawPassword)) || passThrough && encrypted,
        signature: options[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_SIGNATURE"]],
        compressionMethod,
        uncompressedSize,
        offset: zipWriter.offset - diskOffset,
        diskNumberStart: diskNumber,
        uid,
        gid,
        setuid,
        setgid,
        sticky,
        unixMode,
        msdosAttributesRaw,
        msdosAttributes,
        unixExternalUpper
    });
    const headerInfo = getHeaderInfo(options);
    const dataDescriptorInfo = getDataDescriptorInfo(options);
    const metadataSize = getLength(headerInfo.localHeaderArray, dataDescriptorInfo.dataDescriptorArray);
    maximumEntrySize = metadataSize + maximumCompressedSize;
    if (zipWriter.options[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_USDZ"]]) {
        maximumEntrySize += maximumEntrySize + 64;
    }
    zipWriter.pendingEntriesSize += maximumEntrySize;
    let fileEntry;
    try {
        fileEntry = await getFileEntry(zipWriter, name, reader, {
            headerInfo,
            dataDescriptorInfo,
            metadataSize
        }, options);
    } finally{
        zipWriter.pendingEntriesSize -= maximumEntrySize;
    }
    Object.assign(fileEntry, {
        name,
        comment,
        extraField
    });
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Entry"](fileEntry);
}
async function getFileEntry(zipWriter, name, reader, entryInfo, options) {
    const { files, writer } = zipWriter;
    const { keepOrder, dataDescriptor, signal } = options;
    const { headerInfo } = entryInfo;
    const usdz = zipWriter.options[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_USDZ"]];
    const previousFileEntry = Array.from(files.values()).pop();
    let fileEntry = {};
    let bufferedWrite;
    let releaseLockWriter;
    let releaseLockCurrentFileEntry;
    let writingBufferedEntryData;
    let writingEntryData;
    let fileWriter;
    let blobPromise;
    files.set(name, fileEntry);
    try {
        let lockPreviousFileEntry;
        if (keepOrder) {
            lockPreviousFileEntry = previousFileEntry && previousFileEntry.lock;
            requestLockCurrentFileEntry();
        }
        if ((options.bufferedWrite || zipWriter.writerLocked || zipWriter.bufferedWrites && keepOrder || !dataDescriptor) && !usdz) {
            fileWriter = new TransformStream();
            fileWriter.size = 0;
            bufferedWrite = true;
            zipWriter.bufferedWrites++;
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initStream"])(writer);
        } else {
            fileWriter = writer;
            await requestLockWriter();
        }
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initStream"])(fileWriter);
        const { writable, diskOffset } = writer;
        if (zipWriter.addSplitZipSignature) {
            delete zipWriter.addSplitZipSignature;
            const signatureArray = new Uint8Array(4);
            const signatureArrayView = getDataView(signatureArray);
            setUint32(signatureArrayView, 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SPLIT_ZIP_FILE_SIGNATURE"]);
            await writeData(writer, signatureArray);
            zipWriter.offset += 4;
        }
        if (usdz) {
            appendExtraFieldUSDZ(entryInfo, zipWriter.offset - diskOffset);
        }
        const { localHeaderView, localHeaderArray } = headerInfo;
        if (!bufferedWrite) {
            await lockPreviousFileEntry;
            await skipDiskIfNeeded(writable);
        }
        const { diskNumber } = writer;
        writingEntryData = true;
        fileEntry.diskNumberStart = diskNumber;
        if (bufferedWrite) {
            blobPromise = new Response(fileWriter.readable).blob();
        } else {
            await writeData(fileWriter, localHeaderArray);
        }
        fileEntry = await createFileEntry(reader, fileWriter, fileEntry, entryInfo, zipWriter.config, options);
        const { zip64 } = fileEntry;
        writingEntryData = false;
        files.set(name, fileEntry);
        fileEntry.filename = name;
        if (bufferedWrite) {
            const [blob] = await Promise.all([
                blobPromise,
                fileWriter.writable.getWriter().close(),
                lockPreviousFileEntry
            ]);
            await requestLockWriter();
            writingBufferedEntryData = true;
            fileEntry.diskNumberStart = writer.diskNumber;
            fileEntry.offset = zipWriter.offset - writer.diskOffset;
            if (zip64) {
                updateZip64ExtraField(fileEntry);
            }
            updateLocalHeader(fileEntry, localHeaderView, options);
            await skipDiskIfNeeded(writable);
            await writeData(writer, localHeaderArray);
            await blob.stream().pipeTo(writable, {
                preventClose: true,
                preventAbort: true,
                signal
            });
            writer.size += fileWriter.size;
            writingBufferedEntryData = false;
        } else {
            fileEntry.offset = zipWriter.offset - diskOffset;
            if (zip64) {
                updateZip64ExtraField(fileEntry);
            }
        }
        if (fileEntry.offset > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"] && !zip64) {
            throw new Error(ERR_UNSUPPORTED_FORMAT);
        }
        zipWriter.offset += fileEntry.size;
        return fileEntry;
    } catch (error) {
        if (bufferedWrite && writingBufferedEntryData || !bufferedWrite && writingEntryData) {
            zipWriter.hasCorruptedEntries = true;
            if (error) {
                try {
                    error.corruptedEntry = true;
                } catch  {
                // ignored
                }
            }
            if (bufferedWrite) {
                zipWriter.offset += fileWriter.size;
            } else {
                zipWriter.offset = fileWriter.size;
            }
        }
        files.delete(name);
        throw error;
    } finally{
        if (bufferedWrite) {
            zipWriter.bufferedWrites--;
        }
        if (releaseLockCurrentFileEntry) {
            releaseLockCurrentFileEntry();
        }
        if (releaseLockWriter) {
            releaseLockWriter();
        }
    }
    function requestLockCurrentFileEntry() {
        fileEntry.lock = new Promise((resolve)=>releaseLockCurrentFileEntry = resolve);
    }
    async function requestLockWriter() {
        zipWriter.writerLocked = true;
        const { lockWriter } = zipWriter;
        zipWriter.lockWriter = new Promise((resolve)=>releaseLockWriter = ()=>{
                zipWriter.writerLocked = false;
                resolve();
            });
        await lockWriter;
    }
    async function skipDiskIfNeeded(writable) {
        if (getLength(headerInfo.localHeaderArray) > writer.availableSize) {
            writer.availableSize = 0;
            await writeData(writable, new Uint8Array());
        }
    }
}
async function createFileEntry(reader, writer, { diskNumberStart, lock }, entryInfo, config, options) {
    const { headerInfo, dataDescriptorInfo, metadataSize } = entryInfo;
    const { headerArray, headerView, lastModDate, rawLastModDate, encrypted, compressed, version, compressionMethod, rawExtraFieldZip64, localExtraFieldZip64Length, rawExtraFieldExtendedTimestamp, extraFieldExtendedTimestampFlag, rawExtraFieldNTFS, rawExtraFieldUnix, rawExtraFieldAES } = headerInfo;
    const { dataDescriptorArray } = dataDescriptorInfo;
    const { rawFilename, lastAccessDate, creationDate, password, rawPassword, level, zip64, zip64UncompressedSize, zip64CompressedSize, zip64Offset, zip64DiskNumberStart, zipCrypto, dataDescriptor, directory, executable, versionMadeBy, rawComment, rawExtraField, useWebWorkers, onstart, onprogress, onend, signal, encryptionStrength, extendedTimestamp, msDosCompatible, internalFileAttributes, externalFileAttributes, uid, gid, unixMode, setuid, setgid, sticky, unixExternalUpper, msdosAttributesRaw, msdosAttributes, useCompressionStream, passThrough } = options;
    const fileEntry = {
        lock,
        versionMadeBy,
        zip64,
        directory: Boolean(directory),
        executable: Boolean(executable),
        filenameUTF8: true,
        rawFilename,
        commentUTF8: true,
        rawComment,
        rawExtraFieldZip64,
        localExtraFieldZip64Length,
        rawExtraFieldExtendedTimestamp,
        rawExtraFieldNTFS,
        rawExtraFieldUnix,
        rawExtraFieldAES,
        rawExtraField,
        extendedTimestamp,
        msDosCompatible,
        internalFileAttributes,
        externalFileAttributes,
        diskNumberStart,
        uid,
        gid,
        unixMode,
        setuid,
        setgid,
        sticky,
        unixExternalUpper,
        msdosAttributesRaw,
        msdosAttributes
    };
    let { signature, uncompressedSize } = options;
    let compressedSize = 0;
    if (!passThrough) {
        uncompressedSize = 0;
    }
    const { writable } = writer;
    if (reader) {
        reader.chunkSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$configuration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChunkSize"])(config);
        const readable = reader.readable;
        const size = reader.size;
        const workerOptions = {
            options: {
                codecType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$codec$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CODEC_DEFLATE"],
                level,
                rawPassword,
                password,
                encryptionStrength,
                zipCrypto: encrypted && zipCrypto,
                passwordVerification: encrypted && zipCrypto && rawLastModDate >> 8 & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_8_BITS"],
                signed: !passThrough,
                compressed: compressed && !passThrough,
                encrypted: encrypted && !passThrough,
                useWebWorkers,
                useCompressionStream,
                transferStreams: false
            },
            config,
            streamOptions: {
                signal,
                size,
                onstart,
                onprogress,
                onend
            }
        };
        try {
            const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$codec$2d$pool$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["runWorker"])({
                readable,
                writable
            }, workerOptions);
            compressedSize = result.outputSize;
            writer.size += compressedSize;
            if (!passThrough) {
                uncompressedSize = result.inputSize;
                signature = result.signature;
            }
        } catch (error) {
            if (error.outputSize !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
                writer.size += error.outputSize;
            }
            throw error;
        }
    }
    setEntryInfo({
        signature,
        compressedSize,
        uncompressedSize,
        headerInfo,
        dataDescriptorInfo
    }, options);
    if (dataDescriptor) {
        await writeData(writer, dataDescriptorArray);
    }
    Object.assign(fileEntry, {
        uncompressedSize,
        compressedSize,
        lastModDate,
        rawLastModDate,
        creationDate,
        lastAccessDate,
        encrypted,
        zipCrypto,
        size: metadataSize + compressedSize,
        compressionMethod,
        version,
        headerArray,
        headerView,
        signature,
        extraFieldExtendedTimestampFlag,
        zip64UncompressedSize,
        zip64CompressedSize,
        zip64Offset,
        zip64DiskNumberStart
    });
    return fileEntry;
}
function getHeaderInfo(options) {
    const { rawFilename, lastModDate, lastAccessDate, creationDate, level, zip64, zipCrypto, useUnicodeFileNames, dataDescriptor, directory, rawExtraField, encryptionStrength, extendedTimestamp, passThrough, encrypted, zip64UncompressedSize, zip64CompressedSize, zip64Offset, zip64DiskNumberStart, uncompressedSize, offset, diskNumberStart } = options;
    let { version, compressionMethod } = options;
    const compressed = !directory && (level > 0 || level === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] && compressionMethod !== 0);
    let rawExtraFieldZip64;
    let rawLocalExtraFieldZip64;
    const uncompressedFile = passThrough || !compressed;
    const zip64ExtraFieldComplete = zip64 && (options.bufferedWrite || !zip64UncompressedSize && !zip64CompressedSize || uncompressedFile);
    if (zip64) {
        let rawExtraFieldZip64Length = 4;
        let rawLocalExtraFieldZip64Length = 4;
        if (zip64UncompressedSize) {
            rawExtraFieldZip64Length += 8;
            rawLocalExtraFieldZip64Length += 8;
        }
        if (zip64CompressedSize) {
            rawExtraFieldZip64Length += 8;
            rawLocalExtraFieldZip64Length += 8;
        }
        if (zip64Offset) {
            rawExtraFieldZip64Length += 8;
        }
        if (zip64DiskNumberStart) {
            rawExtraFieldZip64Length += 4;
        }
        rawExtraFieldZip64 = new Uint8Array(rawExtraFieldZip64Length);
        const rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);
        rawLocalExtraFieldZip64 = new Uint8Array(rawLocalExtraFieldZip64Length);
        const rawLocalExtraFieldZip64View = getDataView(rawLocalExtraFieldZip64);
        setUint16(rawExtraFieldZip64View, 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_ZIP64"]);
        setUint16(rawExtraFieldZip64View, 2, getLength(rawExtraFieldZip64) - 4);
        setUint16(rawLocalExtraFieldZip64View, 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_ZIP64"]);
        setUint16(rawLocalExtraFieldZip64View, 2, getLength(rawLocalExtraFieldZip64) - 4);
        if (zip64ExtraFieldComplete) {
            const rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);
            const rawLocalExtraFieldZip64View = getDataView(rawLocalExtraFieldZip64);
            let rawExtraFieldZip64Offset = 4;
            let rawLocalExtraFieldZip64Offset = 4;
            if (zip64UncompressedSize) {
                setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(uncompressedSize));
                rawExtraFieldZip64Offset += 8;
                setBigUint64(rawLocalExtraFieldZip64View, rawLocalExtraFieldZip64Offset, BigInt(uncompressedSize));
                rawLocalExtraFieldZip64Offset += 8;
            }
            if (zip64CompressedSize && uncompressedFile) {
                setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(uncompressedSize));
                rawExtraFieldZip64Offset += 8;
                setBigUint64(rawLocalExtraFieldZip64View, rawLocalExtraFieldZip64Offset, BigInt(uncompressedSize));
                rawLocalExtraFieldZip64Offset += 8;
            }
            if (zip64Offset) {
                setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(offset));
                rawExtraFieldZip64Offset += 8;
            }
            if (zip64DiskNumberStart) {
                setUint32(rawExtraFieldZip64View, rawExtraFieldZip64Offset, diskNumberStart);
                rawExtraFieldZip64Offset += 4;
            }
            if (rawLocalExtraFieldZip64Offset == 4) {
                rawLocalExtraFieldZip64 = new Uint8Array();
            }
        }
    } else {
        rawExtraFieldZip64 = new Uint8Array();
        rawLocalExtraFieldZip64 = new Uint8Array();
    }
    let rawExtraFieldAES;
    if (encrypted && !zipCrypto) {
        rawExtraFieldAES = new Uint8Array(getLength(EXTRAFIELD_DATA_AES) + 2);
        const extraFieldAESView = getDataView(rawExtraFieldAES);
        setUint16(extraFieldAESView, 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_AES"]);
        arraySet(rawExtraFieldAES, EXTRAFIELD_DATA_AES, 2);
        setUint8(extraFieldAESView, 8, encryptionStrength);
    } else {
        rawExtraFieldAES = new Uint8Array();
    }
    let rawExtraFieldNTFS;
    let rawExtraFieldExtendedTimestamp;
    let extraFieldExtendedTimestampFlag;
    if (extendedTimestamp) {
        rawExtraFieldExtendedTimestamp = new Uint8Array(9 + (lastAccessDate ? 4 : 0) + (creationDate ? 4 : 0));
        const extraFieldExtendedTimestampView = getDataView(rawExtraFieldExtendedTimestamp);
        setUint16(extraFieldExtendedTimestampView, 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP"]);
        setUint16(extraFieldExtendedTimestampView, 2, getLength(rawExtraFieldExtendedTimestamp) - 4);
        extraFieldExtendedTimestampFlag = 0x1 + (lastAccessDate ? 0x2 : 0) + (creationDate ? 0x4 : 0);
        setUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);
        let offset = 5;
        setUint32(extraFieldExtendedTimestampView, offset, Math.floor(lastModDate.getTime() / 1000));
        offset += 4;
        if (lastAccessDate) {
            setUint32(extraFieldExtendedTimestampView, offset, Math.floor(lastAccessDate.getTime() / 1000));
            offset += 4;
        }
        if (creationDate) {
            setUint32(extraFieldExtendedTimestampView, offset, Math.floor(creationDate.getTime() / 1000));
        }
        try {
            rawExtraFieldNTFS = new Uint8Array(36);
            const extraFieldNTFSView = getDataView(rawExtraFieldNTFS);
            const lastModTimeNTFS = getTimeNTFS(lastModDate);
            setUint16(extraFieldNTFSView, 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_NTFS"]);
            setUint16(extraFieldNTFSView, 2, 32);
            setUint16(extraFieldNTFSView, 8, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_NTFS_TAG1"]);
            setUint16(extraFieldNTFSView, 10, 24);
            setBigUint64(extraFieldNTFSView, 12, lastModTimeNTFS);
            setBigUint64(extraFieldNTFSView, 20, getTimeNTFS(lastAccessDate) || lastModTimeNTFS);
            setBigUint64(extraFieldNTFSView, 28, getTimeNTFS(creationDate) || lastModTimeNTFS);
        } catch  {
            rawExtraFieldNTFS = new Uint8Array();
        }
    } else {
        rawExtraFieldNTFS = rawExtraFieldExtendedTimestamp = new Uint8Array();
    }
    let rawExtraFieldUnix;
    try {
        const { uid, gid, unixMode, setuid, setgid, sticky, unixExtraFieldType } = options;
        if (unixExtraFieldType && (uid !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] || gid !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] || unixMode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"])) {
            const uidBytes = packUnixId(uid);
            const gidBytes = packUnixId(gid);
            let modeArray = new Uint8Array();
            if (unixExtraFieldType == UNIX_EXTRA_FIELD_TYPE && unixMode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
                let modeToWrite = unixMode & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"];
                if (setuid) {
                    modeToWrite |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_SETUID_MASK"];
                }
                if (setgid) {
                    modeToWrite |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_SETGID_MASK"];
                }
                if (sticky) {
                    modeToWrite |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_UNIX_STICKY_MASK"];
                }
                modeArray = new Uint8Array(2);
                const modeDataView = new DataView(modeArray.buffer);
                modeDataView.setUint16(0, modeToWrite, true);
            }
            const payloadLength = 3 + uidBytes.length + gidBytes.length + modeArray.length;
            rawExtraFieldUnix = new Uint8Array(4 + payloadLength);
            const rawExtraFieldUnixView = getDataView(rawExtraFieldUnix);
            setUint16(rawExtraFieldUnixView, 0, unixExtraFieldType == INFOZIP_EXTRA_FIELD_TYPE ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_INFOZIP"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_UNIX"]);
            setUint16(rawExtraFieldUnixView, 2, payloadLength);
            setUint8(rawExtraFieldUnixView, 4, 1);
            setUint8(rawExtraFieldUnixView, 5, uidBytes.length);
            let offset = 6;
            arraySet(rawExtraFieldUnix, uidBytes, offset);
            offset += uidBytes.length;
            setUint8(rawExtraFieldUnixView, offset, gidBytes.length);
            offset++;
            arraySet(rawExtraFieldUnix, gidBytes, offset);
            offset += gidBytes.length;
            arraySet(rawExtraFieldUnix, modeArray, offset);
        } else {
            rawExtraFieldUnix = new Uint8Array();
        }
    } catch  {
        rawExtraFieldUnix = new Uint8Array();
    }
    if (compressionMethod === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
        compressionMethod = compressed ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COMPRESSION_METHOD_DEFLATE"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COMPRESSION_METHOD_STORE"];
    }
    if (zip64) {
        version = version > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERSION_ZIP64"] ? version : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERSION_ZIP64"];
    }
    if (encrypted && !zipCrypto) {
        version = version > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERSION_AES"] ? version : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERSION_AES"];
        rawExtraFieldAES[9] = compressionMethod;
        compressionMethod = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COMPRESSION_METHOD_AES"];
    }
    const localExtraFieldZip64Length = zip64ExtraFieldComplete ? getLength(rawLocalExtraFieldZip64) : 0;
    const extraFieldLength = localExtraFieldZip64Length + getLength(rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraFieldUnix, rawExtraField);
    const { headerArray, headerView, rawLastModDate } = getHeaderArrayData({
        version,
        bitFlag: getBitFlag(level, useUnicodeFileNames, dataDescriptor, encrypted, compressionMethod),
        compressionMethod,
        uncompressedSize,
        lastModDate: lastModDate < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MIN_DATE"] ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MIN_DATE"] : lastModDate > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_DATE"] ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_DATE"] : lastModDate,
        rawFilename,
        zip64CompressedSize,
        zip64UncompressedSize,
        extraFieldLength
    });
    let localHeaderOffset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_SIZE"];
    const localHeaderArray = new Uint8Array(localHeaderOffset + getLength(rawFilename) + extraFieldLength);
    const localHeaderView = getDataView(localHeaderArray);
    setUint32(localHeaderView, 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LOCAL_FILE_HEADER_SIGNATURE"]);
    arraySet(localHeaderArray, headerArray, 4);
    arraySet(localHeaderArray, rawFilename, localHeaderOffset);
    localHeaderOffset += getLength(rawFilename);
    if (zip64ExtraFieldComplete) {
        arraySet(localHeaderArray, rawLocalExtraFieldZip64, localHeaderOffset);
    }
    localHeaderOffset += localExtraFieldZip64Length;
    arraySet(localHeaderArray, rawExtraFieldAES, localHeaderOffset);
    localHeaderOffset += getLength(rawExtraFieldAES);
    arraySet(localHeaderArray, rawExtraFieldExtendedTimestamp, localHeaderOffset);
    localHeaderOffset += getLength(rawExtraFieldExtendedTimestamp);
    arraySet(localHeaderArray, rawExtraFieldNTFS, localHeaderOffset);
    localHeaderOffset += getLength(rawExtraFieldNTFS);
    arraySet(localHeaderArray, rawExtraFieldUnix, localHeaderOffset);
    localHeaderOffset += getLength(rawExtraFieldUnix);
    arraySet(localHeaderArray, rawExtraField, localHeaderOffset);
    if (dataDescriptor) {
        setUint32(localHeaderView, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_OFFSET_COMPRESSED_SIZE"] + 4, 0);
        setUint32(localHeaderView, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_OFFSET_UNCOMPRESSED_SIZE"] + 4, 0);
    }
    return {
        localHeaderArray,
        localHeaderView,
        headerArray,
        headerView,
        lastModDate,
        rawLastModDate,
        encrypted,
        compressed,
        version,
        compressionMethod,
        extraFieldExtendedTimestampFlag,
        rawExtraFieldZip64,
        localExtraFieldZip64Length,
        rawExtraFieldExtendedTimestamp,
        rawExtraFieldNTFS,
        rawExtraFieldUnix,
        rawExtraFieldAES,
        extraFieldLength
    };
}
function appendExtraFieldUSDZ(entryInfo, zipWriterOffset) {
    const { headerInfo } = entryInfo;
    let { localHeaderArray, extraFieldLength } = headerInfo;
    let localHeaderArrayView = getDataView(localHeaderArray);
    let extraBytesLength = 64 - (zipWriterOffset + getLength(localHeaderArray)) % 64;
    if (extraBytesLength < 4) {
        extraBytesLength += 64;
    }
    const rawExtraFieldUSDZ = new Uint8Array(extraBytesLength);
    const extraFieldUSDZView = getDataView(rawExtraFieldUSDZ);
    setUint16(extraFieldUSDZView, 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_USDZ"]);
    setUint16(extraFieldUSDZView, 2, extraBytesLength - 2);
    const previousLocalHeaderArray = localHeaderArray;
    headerInfo.localHeaderArray = localHeaderArray = new Uint8Array(getLength(previousLocalHeaderArray) + extraBytesLength);
    arraySet(localHeaderArray, previousLocalHeaderArray);
    arraySet(localHeaderArray, rawExtraFieldUSDZ, getLength(previousLocalHeaderArray));
    localHeaderArrayView = getDataView(localHeaderArray);
    setUint16(localHeaderArrayView, 28, extraFieldLength + extraBytesLength);
    entryInfo.metadataSize += extraBytesLength;
}
function packUnixId(id) {
    if (id === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
        return new Uint8Array();
    } else {
        const dataArray = new Uint8Array(4);
        const dataView = getDataView(dataArray);
        dataView.setUint32(0, id, true);
        let length = 4;
        while(length > 1 && dataArray[length - 1] === 0){
            length--;
        }
        return dataArray.subarray(0, length);
    }
}
function normalizeMsdosAttributes(msdosAttributesRaw, msdosAttributes) {
    if (msdosAttributesRaw !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
        msdosAttributesRaw = msdosAttributesRaw & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_8_BITS"];
    } else if (msdosAttributes !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
        const { readOnly, hidden, system, directory: msdDir, archive } = msdosAttributes;
        let raw = 0;
        if (readOnly) raw |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_MSDOS_READONLY_MASK"];
        if (hidden) raw |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_MSDOS_HIDDEN_MASK"];
        if (system) raw |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_MSDOS_SYSTEM_MASK"];
        if (msdDir) raw |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_MSDOS_DIR_MASK"];
        if (archive) raw |= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_MSDOS_ARCHIVE_MASK"];
        msdosAttributesRaw = raw & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_8_BITS"];
    }
    if (msdosAttributes === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
        msdosAttributes = {
            readOnly: Boolean(msdosAttributesRaw & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_MSDOS_READONLY_MASK"]),
            hidden: Boolean(msdosAttributesRaw & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_MSDOS_HIDDEN_MASK"]),
            system: Boolean(msdosAttributesRaw & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_MSDOS_SYSTEM_MASK"]),
            directory: Boolean(msdosAttributesRaw & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_MSDOS_DIR_MASK"]),
            archive: Boolean(msdosAttributesRaw & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_ATTR_MSDOS_ARCHIVE_MASK"])
        };
    }
    return {
        msdosAttributesRaw,
        msdosAttributes
    };
}
function getDataDescriptorInfo({ zip64, dataDescriptor, dataDescriptorSignature }) {
    let dataDescriptorArray = new Uint8Array();
    let dataDescriptorView, dataDescriptorOffset = 0;
    let dataDescriptorLength = zip64 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DATA_DESCRIPTOR_RECORD_ZIP_64_LENGTH"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DATA_DESCRIPTOR_RECORD_LENGTH"];
    if (dataDescriptorSignature) {
        dataDescriptorLength += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DATA_DESCRIPTOR_RECORD_SIGNATURE_LENGTH"];
    }
    if (dataDescriptor) {
        dataDescriptorArray = new Uint8Array(dataDescriptorLength);
        dataDescriptorView = getDataView(dataDescriptorArray);
        if (dataDescriptorSignature) {
            dataDescriptorOffset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DATA_DESCRIPTOR_RECORD_SIGNATURE_LENGTH"];
            setUint32(dataDescriptorView, 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DATA_DESCRIPTOR_RECORD_SIGNATURE"]);
        }
    }
    return {
        dataDescriptorArray,
        dataDescriptorView,
        dataDescriptorOffset
    };
}
function setEntryInfo({ signature, compressedSize, uncompressedSize, headerInfo, dataDescriptorInfo }, { zip64, zipCrypto, dataDescriptor }) {
    const { headerView, encrypted } = headerInfo;
    const { dataDescriptorView, dataDescriptorOffset } = dataDescriptorInfo;
    if ((!encrypted || zipCrypto) && signature !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
        setUint32(headerView, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_OFFSET_SIGNATURE"], signature);
        if (dataDescriptor) {
            setUint32(dataDescriptorView, dataDescriptorOffset, signature);
        }
    }
    if (zip64) {
        if (dataDescriptor) {
            setBigUint64(dataDescriptorView, dataDescriptorOffset + 4, BigInt(compressedSize));
            setBigUint64(dataDescriptorView, dataDescriptorOffset + 12, BigInt(uncompressedSize));
        }
    } else {
        setUint32(headerView, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_OFFSET_COMPRESSED_SIZE"], compressedSize);
        setUint32(headerView, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_OFFSET_UNCOMPRESSED_SIZE"], uncompressedSize);
        if (dataDescriptor) {
            setUint32(dataDescriptorView, dataDescriptorOffset + 4, compressedSize);
            setUint32(dataDescriptorView, dataDescriptorOffset + 8, uncompressedSize);
        }
    }
}
function updateLocalHeader({ rawFilename, encrypted, zip64, localExtraFieldZip64Length, signature, compressedSize, uncompressedSize, zip64UncompressedSize, zip64CompressedSize }, localHeaderView, { dataDescriptor }) {
    if (!dataDescriptor) {
        if (!encrypted) {
            setUint32(localHeaderView, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_OFFSET_SIGNATURE"] + 4, signature);
        }
        if (!zip64CompressedSize) {
            setUint32(localHeaderView, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_OFFSET_COMPRESSED_SIZE"] + 4, compressedSize);
        }
        if (!zip64UncompressedSize) {
            setUint32(localHeaderView, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_OFFSET_UNCOMPRESSED_SIZE"] + 4, uncompressedSize);
        }
    }
    if (zip64 && localExtraFieldZip64Length) {
        let localHeaderOffset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_SIZE"] + getLength(rawFilename) + 4;
        if (zip64UncompressedSize) {
            setBigUint64(localHeaderView, localHeaderOffset, BigInt(uncompressedSize));
            localHeaderOffset += 8;
        }
        if (zip64CompressedSize) {
            setBigUint64(localHeaderView, localHeaderOffset, BigInt(compressedSize));
            localHeaderOffset += 8;
        }
    }
}
function updateZip64ExtraField({ compressedSize, uncompressedSize, offset, diskNumberStart, zip64UncompressedSize, zip64CompressedSize, zip64Offset, zip64DiskNumberStart, rawExtraFieldZip64 }) {
    const rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);
    let rawExtraFieldZip64Offset = 4;
    if (zip64UncompressedSize) {
        setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(uncompressedSize));
        rawExtraFieldZip64Offset += 8;
    }
    if (zip64CompressedSize) {
        setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(compressedSize));
        rawExtraFieldZip64Offset += 8;
    }
    if (zip64Offset) {
        setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(offset));
        rawExtraFieldZip64Offset += 8;
    }
    if (zip64DiskNumberStart) {
        setUint32(rawExtraFieldZip64View, rawExtraFieldZip64Offset, diskNumberStart);
    }
}
async function closeFile(zipWriter, comment, options) {
    const { files, writer } = zipWriter;
    const { diskOffset } = writer;
    let { diskNumber } = writer;
    let offset = 0;
    let directoryDataLength = 0;
    let directoryOffset = zipWriter.offset - diskOffset;
    let filesLength = files.size;
    for (const [, fileEntry] of files){
        const { rawFilename, rawExtraFieldZip64, rawExtraFieldAES, rawComment, rawExtraFieldNTFS, rawExtraFieldUnix, rawExtraField, extendedTimestamp, extraFieldExtendedTimestampFlag, lastModDate } = fileEntry;
        let rawExtraFieldTimestamp;
        if (extendedTimestamp) {
            rawExtraFieldTimestamp = new Uint8Array(9);
            const extraFieldExtendedTimestampView = getDataView(rawExtraFieldTimestamp);
            setUint16(extraFieldExtendedTimestampView, 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP"]);
            setUint16(extraFieldExtendedTimestampView, 2, 5);
            setUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);
            setUint32(extraFieldExtendedTimestampView, 5, Math.floor(lastModDate.getTime() / 1000));
        } else {
            rawExtraFieldTimestamp = new Uint8Array();
        }
        fileEntry.rawExtraFieldExtendedTimestamp = rawExtraFieldTimestamp;
        directoryDataLength += 46 + getLength(rawFilename, rawComment, rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldNTFS, rawExtraFieldUnix, rawExtraFieldTimestamp, rawExtraField);
    }
    const directoryArray = new Uint8Array(directoryDataLength);
    const directoryView = getDataView(directoryArray);
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initStream"])(writer);
    let directoryDiskOffset = 0;
    for (const [indexFileEntry, fileEntry] of Array.from(files.values()).entries()){
        const { offset: fileEntryOffset, rawFilename, rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraFieldUnix, rawExtraField, rawComment, versionMadeBy, headerArray, headerView, zip64, zip64UncompressedSize, zip64CompressedSize, zip64DiskNumberStart, zip64Offset, internalFileAttributes, externalFileAttributes, diskNumberStart, uncompressedSize, compressedSize } = fileEntry;
        const extraFieldLength = getLength(rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraFieldUnix, rawExtraField);
        setUint32(directoryView, offset, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CENTRAL_FILE_HEADER_SIGNATURE"]);
        setUint16(directoryView, offset + 4, versionMadeBy);
        if (!zip64UncompressedSize) {
            setUint32(headerView, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_OFFSET_UNCOMPRESSED_SIZE"], uncompressedSize);
        }
        if (!zip64CompressedSize) {
            setUint32(headerView, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_OFFSET_COMPRESSED_SIZE"], compressedSize);
        }
        arraySet(directoryArray, headerArray, offset + 6);
        let directoryOffset = offset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_SIZE"];
        setUint16(directoryView, directoryOffset, extraFieldLength);
        directoryOffset += 2;
        setUint16(directoryView, directoryOffset, getLength(rawComment));
        directoryOffset += 2;
        setUint16(directoryView, directoryOffset, zip64 && zip64DiskNumberStart ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"] : diskNumberStart);
        directoryOffset += 2;
        setUint16(directoryView, directoryOffset, internalFileAttributes);
        directoryOffset += 2;
        if (externalFileAttributes) {
            setUint32(directoryView, directoryOffset, externalFileAttributes);
        }
        directoryOffset += 4;
        setUint32(directoryView, directoryOffset, zip64 && zip64Offset ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"] : fileEntryOffset);
        directoryOffset += 4;
        arraySet(directoryArray, rawFilename, directoryOffset);
        directoryOffset += getLength(rawFilename);
        arraySet(directoryArray, rawExtraFieldZip64, directoryOffset);
        directoryOffset += getLength(rawExtraFieldZip64);
        arraySet(directoryArray, rawExtraFieldAES, directoryOffset);
        directoryOffset += getLength(rawExtraFieldAES);
        arraySet(directoryArray, rawExtraFieldExtendedTimestamp, directoryOffset);
        directoryOffset += getLength(rawExtraFieldExtendedTimestamp);
        arraySet(directoryArray, rawExtraFieldNTFS, directoryOffset);
        directoryOffset += getLength(rawExtraFieldNTFS);
        arraySet(directoryArray, rawExtraFieldUnix, directoryOffset);
        directoryOffset += getLength(rawExtraFieldUnix);
        arraySet(directoryArray, rawExtraField, directoryOffset);
        directoryOffset += getLength(rawExtraField);
        arraySet(directoryArray, rawComment, directoryOffset);
        directoryOffset += getLength(rawComment);
        if (offset - directoryDiskOffset > writer.availableSize) {
            writer.availableSize = 0;
            await writeData(writer, directoryArray.slice(directoryDiskOffset, offset));
            directoryDiskOffset = offset;
        }
        offset = directoryOffset;
        if (options.onprogress) {
            try {
                await options.onprogress(indexFileEntry + 1, files.size, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Entry"](fileEntry));
            } catch  {
            // ignored
            }
        }
    }
    await writeData(writer, directoryDiskOffset ? directoryArray.slice(directoryDiskOffset) : directoryArray);
    let lastDiskNumber = writer.diskNumber;
    const { availableSize } = writer;
    if (availableSize < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["END_OF_CENTRAL_DIR_LENGTH"]) {
        lastDiskNumber++;
    }
    let zip64 = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$entry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PROPERTY_NAME_ZIP64"]);
    if (directoryOffset > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"] || directoryDataLength > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"] || filesLength > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"] || lastDiskNumber > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"]) {
        if (zip64 === false) {
            throw new Error(ERR_UNSUPPORTED_FORMAT);
        } else {
            zip64 = true;
        }
    }
    const endOfdirectoryArray = new Uint8Array(zip64 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["END_OF_CENTRAL_DIR_LENGTH"]);
    const endOfdirectoryView = getDataView(endOfdirectoryArray);
    offset = 0;
    if (zip64) {
        setUint32(endOfdirectoryView, 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZIP64_END_OF_CENTRAL_DIR_SIGNATURE"]);
        setBigUint64(endOfdirectoryView, 4, BigInt(44));
        setUint16(endOfdirectoryView, 12, 45);
        setUint16(endOfdirectoryView, 14, 45);
        setUint32(endOfdirectoryView, 16, lastDiskNumber);
        setUint32(endOfdirectoryView, 20, diskNumber);
        setBigUint64(endOfdirectoryView, 24, BigInt(filesLength));
        setBigUint64(endOfdirectoryView, 32, BigInt(filesLength));
        setBigUint64(endOfdirectoryView, 40, BigInt(directoryDataLength));
        setBigUint64(endOfdirectoryView, 48, BigInt(directoryOffset));
        setUint32(endOfdirectoryView, 56, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE"]);
        setBigUint64(endOfdirectoryView, 64, BigInt(directoryOffset) + BigInt(directoryDataLength));
        setUint32(endOfdirectoryView, 72, lastDiskNumber + 1);
        const supportZip64SplitFile = getOptionValue(zipWriter, options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OPTION_SUPPORT_ZIP64_SPLIT_FILE"], true);
        if (supportZip64SplitFile) {
            lastDiskNumber = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"];
            diskNumber = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"];
        }
        filesLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"];
        directoryOffset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"];
        directoryDataLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"];
        offset += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZIP64_END_OF_CENTRAL_DIR_LENGTH"] + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH"];
    }
    setUint32(endOfdirectoryView, offset, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["END_OF_CENTRAL_DIR_SIGNATURE"]);
    setUint16(endOfdirectoryView, offset + 4, lastDiskNumber);
    setUint16(endOfdirectoryView, offset + 6, diskNumber);
    setUint16(endOfdirectoryView, offset + 8, filesLength);
    setUint16(endOfdirectoryView, offset + 10, filesLength);
    setUint32(endOfdirectoryView, offset + 12, directoryDataLength);
    setUint32(endOfdirectoryView, offset + 16, directoryOffset);
    const commentLength = getLength(comment);
    if (commentLength) {
        if (commentLength <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_16_BITS"]) {
            setUint16(endOfdirectoryView, offset + 20, commentLength);
        } else {
            throw new Error(ERR_INVALID_COMMENT);
        }
    }
    await writeData(writer, endOfdirectoryArray);
    if (commentLength) {
        await writeData(writer, comment);
    }
}
async function writeData(writer, array) {
    const { writable } = writer;
    const streamWriter = writable.getWriter();
    try {
        await streamWriter.ready;
        writer.size += getLength(array);
        await streamWriter.write(array);
    } finally{
        streamWriter.releaseLock();
    }
}
function getTimeNTFS(date) {
    if (date) {
        return (BigInt(date.getTime()) + BigInt(11644473600000)) * BigInt(10000);
    }
}
function getOptionValue(zipWriter, options, name, defaultValue) {
    const result = options[name] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] ? zipWriter.options[name] : options[name];
    return result === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"] ? defaultValue : result;
}
function getMaximumCompressedSize(uncompressedSize) {
    return uncompressedSize + 5 * (Math.floor(uncompressedSize / 16383) + 1);
}
function setUint8(view, offset, value) {
    view.setUint8(offset, value);
}
function setUint16(view, offset, value) {
    view.setUint16(offset, value, true);
}
function setUint32(view, offset, value) {
    view.setUint32(offset, value, true);
}
function setBigUint64(view, offset, value) {
    view.setBigUint64(offset, value, true);
}
function arraySet(array, typedArray, offset) {
    array.set(typedArray, offset);
}
function getDataView(array) {
    return new DataView(array.buffer);
}
function getLength(...arrayLikes) {
    let result = 0;
    arrayLikes.forEach((arrayLike)=>arrayLike && (result += arrayLike.length));
    return result;
}
function getHeaderArrayData({ version, bitFlag, compressionMethod, uncompressedSize, compressedSize, lastModDate, rawFilename, zip64CompressedSize, zip64UncompressedSize, extraFieldLength }) {
    const headerArray = new Uint8Array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_SIZE"] - 4);
    const headerView = getDataView(headerArray);
    setUint16(headerView, 0, version);
    setUint16(headerView, 2, bitFlag);
    setUint16(headerView, 4, compressionMethod);
    const dateArray = new Uint32Array(1);
    const dateView = getDataView(dateArray);
    setUint16(dateView, 0, (lastModDate.getHours() << 6 | lastModDate.getMinutes()) << 5 | lastModDate.getSeconds() / 2);
    setUint16(dateView, 2, (lastModDate.getFullYear() - 1980 << 4 | lastModDate.getMonth() + 1) << 5 | lastModDate.getDate());
    const rawLastModDate = dateArray[0];
    setUint32(headerView, 6, rawLastModDate);
    if (zip64CompressedSize || compressedSize !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
        setUint32(headerView, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_OFFSET_COMPRESSED_SIZE"], zip64CompressedSize ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"] : compressedSize);
    }
    if (zip64UncompressedSize || uncompressedSize !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNDEFINED_VALUE"]) {
        setUint32(headerView, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEADER_OFFSET_UNCOMPRESSED_SIZE"], zip64UncompressedSize ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_32_BITS"] : uncompressedSize);
    }
    setUint16(headerView, 22, getLength(rawFilename));
    setUint16(headerView, 24, extraFieldLength);
    return {
        headerArray,
        headerView,
        rawLastModDate
    };
}
function getBitFlag(level, useUnicodeFileNames, dataDescriptor, encrypted, compressionMethod) {
    let bitFlag = 0;
    if (useUnicodeFileNames) {
        bitFlag = bitFlag | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITFLAG_LANG_ENCODING_FLAG"];
    }
    if (dataDescriptor) {
        bitFlag = bitFlag | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITFLAG_DATA_DESCRIPTOR"];
    }
    if (compressionMethod == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COMPRESSION_METHOD_DEFLATE"] || compressionMethod == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["COMPRESSION_METHOD_DEFLATE_64"]) {
        if (level >= 0 && level <= 3) {
            bitFlag = bitFlag | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITFLAG_LEVEL_SUPER_FAST_MASK"];
        }
        if (level > 3 && level <= 5) {
            bitFlag = bitFlag | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITFLAG_LEVEL_FAST_MASK"];
        }
        if (level == 9) {
            bitFlag = bitFlag | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITFLAG_LEVEL_MAX_MASK"];
        }
    }
    if (encrypted) {
        bitFlag = bitFlag | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BITFLAG_ENCRYPTED"];
    }
    return bitFlag;
}
}),
"[project]/node_modules/@zip.js/zip.js/lib/zip-core-writer.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
/*
 Copyright (c) 2025 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/zip-writer.js [app-client] (ecmascript)");
;
}),
"[project]/node_modules/@zip.js/zip.js/lib/zip-core-base.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
/*
 Copyright (c) 2025 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$configuration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/configuration.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/zip-core-reader.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/zip-core-writer.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/io.js [app-client] (ecmascript)");
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/@zip.js/zip.js/lib/zip-core-base.js")}`;
    }
};
;
try {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$configuration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["configure"])({
        baseURI: __TURBOPACK__import$2e$meta__.url
    });
} catch  {
// ignored
}
;
;
;
;
;
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/zlib-streams-inline.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "configureZlibModule",
    ()=>g
]);
const A = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function g(g) {
    let B;
    g({
        wasmURI: ()=>(B || (B = "data:application/wasm;base64," + ((g)=>{
                g = ((g)=>{
                    const B = (g = (g + "").replace(/[^A-Za-z0-9+/=]/g, "")).length, E = [];
                    for(let I = 0; B > I; I += 4){
                        const B = A.indexOf(g[I]) << 18 | A.indexOf(g[I + 1]) << 12 | (63 & A.indexOf(g[I + 2])) << 6 | 63 & A.indexOf(g[I + 3]);
                        E.push(B >> 16 & 255), "=" !== g[I + 2] && E.push(B >> 8 & 255), "=" !== g[I + 3] && E.push(255 & B);
                    }
                    return new Uint8Array(E);
                })(g);
                let B = new Uint8Array(1024), E = 0;
                for(let A = 0; A < g.length;){
                    const C = g[A++];
                    if (128 & C) {
                        const Q = 3 + (127 & C), D = g[A++] << 8 | g[A++], o = E - D;
                        I(E + Q);
                        for(let A = 0; Q > A; A++)B[E++] = B[o + A];
                    } else {
                        const Q = C;
                        I(E + Q);
                        for(let I = 0; Q > I && A < g.length; I++)B[E++] = g[A++];
                    }
                }
                return ((g)=>{
                    let B = "";
                    const E = g.length;
                    let I = 0;
                    for(; E > I + 2; I += 3){
                        const E = g[I] << 16 | g[I + 1] << 8 | g[I + 2];
                        B += A[E >> 18 & 63] + A[E >> 12 & 63] + A[E >> 6 & 63] + A[63 & E];
                    }
                    const C = E - I;
                    if (1 === C) {
                        const E = g[I] << 16;
                        B += A[E >> 18 & 63] + A[E >> 12 & 63] + "==";
                    } else if (2 === C) {
                        const E = g[I] << 16 | g[I + 1] << 8;
                        B += A[E >> 18 & 63] + A[E >> 12 & 63] + A[E >> 6 & 63] + "=";
                    }
                    return B;
                })(new Uint8Array(B.buffer.slice(0, E)));
                //TURBOPACK unreachable
                ;
                function I(A) {
                    if (B.length < A) {
                        let g = 2 * B.length;
                        for(; A > g;)g *= 2;
                        const I = new Uint8Array(g);
                        I.set(B.subarray(0, E)), B = I;
                    }
                }
            })("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BAGZgAAEAVmAAAQB2YAABAE5gAAEAbmAAAQBeYAABAH5gAAEAQWAAAQBhYAABAFFgAAEAcWAAAQBJYAABAGlgAAEAWWAAAQB5YAABAEVgAAEAZWAAAQBVYAABAHVgAAEATWAAAQBtYAABAF1gAAEAfWAAAQBDYAABAGNgAAEAU2AAAQBzYAABIARMwIArYAABAFtgAAEAe2AAAQBHYAABAGdgAAEAV2AAAQB3YAABAE9gAAEAb2AAAQBfYAABAH9gAAEAROAAMIFEwEJAJOAAAgBk4AACAFTgAAIAVOAAAgB04AACAHTgAAIATOAAAgBM4AACAGzgAAIAbOAAAgBc4AACAFzgAAIAfOAAAgB84AACAELgAAIgBDagAQCgAAEgAAIAUuAAAgBS4AACAHLgAAIAcuAAAgBK4AACAErgAAIAauAAAgBq4AACAFrgAAIAWuAAAgB64AACAHrgAAIARuAAAgBG4AACAGbgAAIAZuAAAgBW4AACAFbgAAIAduAAAgB24AACAE7gAAIATuAAAgBu4AACAG7gAAIAXuAAAgBe4AACAH7gAAIAfuAAAiBA7YBB4AACAGHgAAIAYeAAAgBR4AACAFHgAAIAceAAAgBx4AACAEngAAIASeAAAgBp4AACAGngAAIAWeAAAgBZ4AACAHngAAIAeeAAAgBF4AACAEXgAAIAZeAAAgBl4AACAFXgAAIAVeAAAgB14AACAHXgAAIATeAAAgBN4AACAG3gAAIAbeAAAgBd4AACAF3gAAIAfeAAAgB94AACAEPgAAIAQ+AAAgBj4AACAGPgAAIAU+AAAgBT4AACAHPgAAIAc+AAAgBL4AACAEvgAAIAa+AAAgBr4AACAFvgAAIAW+AAAgB74AACAHvgAAIAR+AAAgBH4AACAGfgAAIAZ+AAAgBX4AACAFfgAAIAd+AAAgB34AACAE/gAAIAT+AAAgBv4AACAG/gAAIAX+AAAgBf4AACAH/gAAIAf+AAAiBBAoBQIAABAEggAAEAWCAAAQBEIAABAFQgAAEATCAAAQBcIIFVgMHAEiAAAQBKIAABAFogAAEARiAAAQBWIAABAE4gAAEAXiAAAQBBIAABAFEgAAEASSAAAQBZIAABAEUgAAEAVSAAAQBNIAABAF0gAAEAQOAAEIBg4AABAFDgAAEAcOAAAQBI4AABAGjgAAEAWOAAAQB44AABIC+K4AAdIECxgEFgABcAQWCBUoBFIAABAEMgAAEARyAAASAvlaABEQBBYIGBAEaggXqAQWAA9QBBYADuAEFgAOcgE92gAAEARGAAAQBCYAABAEZgAAEgQACARWAAAQBDYAABAEdgAAEgL59gAKkgQZAAQWAAiyBBaYBBYABtAEFgD3fAxsLTYMfuYcABIC+rooABIEHUYkABAEEjAAEAQWKAAQEQbAcC4C9CosAS40AO4UALwEGhAAEgQWIgQAEgQEKgQAEgQGSgQAEgIS2ggAEAQuEAAQBDIQABIAF24FHeQTgHQsjhQBfhQXLAhARgAVtBgcJBgoFC4A6uAQNAg4BgAclBJQeC2mFAJCFAIiFAICFAHiBAGiBAFyBBh8BEIAABAEUgAAEARiAAAQBHIAABAEggAAEASiAAAQBMIAABAE4gAAEAUCAAAQBUIAABIEGvQFwgAAEAYCAAAQBoIAABAHAgAAEAeCAAG8DHwtyjQBvgQBrgQBngQBjgQBfgQBbgQBXgQBTgQBPgQBLgQBHgQBDgQE8AYCvAEGAUc0CC22BAMcBBIAAAgEIgAAEgQEzgQJLARCAAA6DAAyBnqyAqmuEACSBB3OBAE8BCIAACIEAGIUADIEIt4MADAEggQCUgDKEgQBrAYCBCC8BBIMADIA/SAoBABAMAEGRIQv/gCUfgMDAgIKxBQgJCQoKgEk3gAABAQ2AAAEBDoAAAQEPgAABARCEAAEBEYQAAQEShAABAROEAAEBFIwAAQEVjAABARaMAAEBF4wAAQEYnAABARmcAAEBGpwAAQEbmwABARyBffsEBAQFBYHB1QEHgAABAQiEAAGAXSqCAAEBCowAAYAnsooAAYEBMJkAAYEBTJkAAYEBaLkAAYEBpLkAAYIDdYABzoUBvI0BqJ0BkLwBgAIbHLwAAQEdvAABgA9PgH05A9AqAQ==")), B)
    });
}
;
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/streams/zlib-wasm/zlib-streams.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CompressionStreamZlib",
    ()=>CompressionStreamZlib,
    "DecompressionStreamZlib",
    ()=>DecompressionStreamZlib,
    "setWasmExports",
    ()=>setWasmExports
]);
/*
 Copyright (c) 2025 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /* global TransformStream */ let wasm, malloc, free, memory;
function setWasmExports(wasmAPI) {
    wasm = wasmAPI;
    ({ malloc, free, memory } = wasm);
    if (typeof malloc !== "function" || typeof free !== "function" || !memory) {
        wasm = malloc = free = memory = null;
        throw new Error("Invalid WASM module");
    }
}
function _make(isCompress, type, options = {}) {
    const level = typeof options.level === "number" ? options.level : -1;
    const outBufferSize = typeof options.outBuffer === "number" ? options.outBuffer : 64 * 1024;
    const inBufferSize = typeof options.inBufferSize === "number" ? options.inBufferSize : 64 * 1024;
    return new TransformStream({
        start () {
            let result;
            this.out = malloc(outBufferSize);
            this.in = malloc(inBufferSize);
            this.inBufferSize = inBufferSize;
            this._scratch = new Uint8Array(outBufferSize);
            if (isCompress) {
                this._process = wasm.deflate_process;
                this._last_consumed = wasm.deflate_last_consumed;
                this._end = wasm.deflate_end;
                this.streamHandle = wasm.deflate_new();
                if (type === "gzip") {
                    result = wasm.deflate_init_gzip(this.streamHandle, level);
                } else if (type === "deflate-raw") {
                    result = wasm.deflate_init_raw(this.streamHandle, level);
                } else {
                    result = wasm.deflate_init(this.streamHandle, level);
                }
            } else {
                if (type === "deflate64-raw") {
                    this._process = wasm.inflate9_process;
                    this._last_consumed = wasm.inflate9_last_consumed;
                    this._end = wasm.inflate9_end;
                    this.streamHandle = wasm.inflate9_new();
                    result = wasm.inflate9_init_raw(this.streamHandle);
                } else {
                    this._process = wasm.inflate_process;
                    this._last_consumed = wasm.inflate_last_consumed;
                    this._end = wasm.inflate_end;
                    this.streamHandle = wasm.inflate_new();
                    if (type === "deflate-raw") {
                        result = wasm.inflate_init_raw(this.streamHandle);
                    } else if (type === "gzip") {
                        result = wasm.inflate_init_gzip(this.streamHandle);
                    } else {
                        result = wasm.inflate_init(this.streamHandle);
                    }
                }
            }
            if (result !== 0) {
                throw new Error("init failed:" + result);
            }
        },
        transform (chunk, controller) {
            try {
                const buffer = chunk;
                const heap = new Uint8Array(memory.buffer);
                const process = this._process;
                const last_consumed = this._last_consumed;
                const out = this.out;
                const scratch = this._scratch;
                let offset = 0;
                while(offset < buffer.length){
                    const toRead = Math.min(buffer.length - offset, 32 * 1024);
                    if (!this.in || this.inBufferSize < toRead) {
                        if (this.in && free) {
                            free(this.in);
                        }
                        this.in = malloc(toRead);
                        this.inBufferSize = toRead;
                    }
                    heap.set(buffer.subarray(offset, offset + toRead), this.in);
                    const result = process(this.streamHandle, this.in, toRead, out, outBufferSize, 0);
                    const prod = result & 0x00ffffff;
                    if (prod) {
                        scratch.set(heap.subarray(out, out + prod), 0);
                        controller.enqueue(scratch.slice(0, prod));
                    }
                    if (!isCompress) {
                        const code = result >> 24 & 0xff;
                        const signedCode = code & 0x80 ? code - 256 : code;
                        if (signedCode < 0) {
                            throw new Error("process error:" + signedCode);
                        }
                    }
                    const consumed = last_consumed(this.streamHandle);
                    if (consumed === 0) {
                        break;
                    }
                    offset += consumed;
                }
            } catch (error) {
                if (this._end && this.streamHandle) {
                    this._end(this.streamHandle);
                }
                if (this.in && free) {
                    free(this.in);
                }
                if (this.out && free) {
                    free(this.out);
                }
                controller.error(error);
            }
        },
        flush (controller) {
            try {
                const heap = new Uint8Array(memory.buffer);
                const process = this._process;
                const out = this.out;
                const scratch = this._scratch;
                while(true){
                    const result = process(this.streamHandle, 0, 0, out, outBufferSize, 4);
                    const produced = result & 0x00ffffff;
                    const code = result >> 24 & 0xff;
                    if (!isCompress) {
                        const signedCode = code & 0x80 ? code - 256 : code;
                        if (signedCode < 0) {
                            throw new Error("process error:" + signedCode);
                        }
                    }
                    if (produced) {
                        scratch.set(heap.subarray(out, out + produced), 0);
                        controller.enqueue(scratch.slice(0, produced));
                    }
                    if (code === 1 || produced === 0) {
                        break;
                    }
                }
            } catch (error) {
                controller.error(error);
            } finally{
                if (this._end && this.streamHandle) {
                    const result = this._end(this.streamHandle);
                    if (result !== 0) {
                        controller.error(new Error("end error:" + result));
                    }
                }
                if (this.in && free) {
                    free(this.in);
                }
                if (this.out && free) {
                    free(this.out);
                }
            }
        }
    });
}
class CompressionStreamZlib {
    constructor(type = "deflate", options){
        return _make(true, type, options);
    }
}
class DecompressionStreamZlib {
    constructor(type = "deflate", options){
        return _make(false, type, options);
    }
}
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/streams/zlib-wasm/zlib-streams-loader.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "initModule",
    ()=>initModule,
    "initializedModule",
    ()=>initializedModule,
    "resetWasmModule",
    ()=>resetWasmModule
]);
/*
 Copyright (c) 2025 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ /* global WebAssembly, URL, fetch, atob */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zlib$2d$wasm$2f$zlib$2d$streams$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/zlib-wasm/zlib-streams.js [app-client] (ecmascript)");
;
let initializedModule = false;
async function initModule(wasmURI, { baseURI }) {
    if (!initializedModule) {
        let arrayBuffer, uri;
        try {
            try {
                uri = new URL(wasmURI, baseURI);
            } catch  {
            // ignored
            }
            const response = await fetch(uri);
            arrayBuffer = await response.arrayBuffer();
        } catch (error) {
            if (wasmURI.startsWith("data:application/wasm;base64,")) {
                arrayBuffer = arrayBufferFromDataURI(wasmURI);
            } else {
                throw error;
            }
        }
        const wasmInstance = await WebAssembly.instantiate(arrayBuffer);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zlib$2d$wasm$2f$zlib$2d$streams$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setWasmExports"])(wasmInstance.instance.exports);
        initializedModule = true;
    }
}
function resetWasmModule() {
    initializedModule = false;
}
function arrayBufferFromDataURI(dataURI) {
    const base64 = dataURI.split(",")[1];
    const binary = atob(base64);
    const len = binary.length;
    const bytes = new Uint8Array(len);
    for(let i = 0; i < len; ++i){
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes.buffer;
}
;
;
}),
"[project]/node_modules/@zip.js/zip.js/lib/zip-module-wasm.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "terminateWorkers",
    ()=>terminateWorkersAndModule
]);
/*
 Copyright (c) 2025 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$configuration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/configuration.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zlib$2d$streams$2d$inline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/zlib-streams-inline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$codec$2d$worker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/codec-worker.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$codec$2d$pool$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/codec-pool.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zlib$2d$wasm$2f$zlib$2d$streams$2d$loader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/zlib-wasm/zlib-streams-loader.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zlib$2d$wasm$2f$zlib$2d$streams$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/zlib-wasm/zlib-streams.js [app-client] (ecmascript)");
;
;
;
;
;
;
let modulePromise;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zlib$2d$streams$2d$inline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["configureZlibModule"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$configuration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["configure"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$codec$2d$worker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["configureWorker"])({
    initModule: (config)=>{
        if (!modulePromise) {
            let { wasmURI } = config;
            // deno-lint-ignore valid-typeof
            if (typeof wasmURI == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FUNCTION_TYPE"]) {
                wasmURI = wasmURI();
            }
            modulePromise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zlib$2d$wasm$2f$zlib$2d$streams$2d$loader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["initModule"])(wasmURI, config);
        }
        return modulePromise;
    }
});
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$configuration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["configure"])({
    CompressionStreamZlib: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zlib$2d$wasm$2f$zlib$2d$streams$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompressionStreamZlib"],
    DecompressionStreamZlib: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zlib$2d$wasm$2f$zlib$2d$streams$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DecompressionStreamZlib"]
});
;
function terminateWorkersAndModule() {
    modulePromise = null;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$codec$2d$pool$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["terminateWorkers"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zlib$2d$wasm$2f$zlib$2d$streams$2d$loader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["resetWasmModule"])();
}
}),
"[project]/node_modules/@zip.js/zip.js/lib/zip-core-wasm.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
/*
 Copyright (c) 2025 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/zip-core-base.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$module$2d$wasm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/zip-module-wasm.js [app-client] (ecmascript)");
;
;
}),
"[project]/node_modules/@zip.js/zip.js/lib/zip-core-reader.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ERR_BAD_FORMAT",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ERR_BAD_FORMAT"],
    "ERR_CENTRAL_DIRECTORY_NOT_FOUND",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ERR_CENTRAL_DIRECTORY_NOT_FOUND"],
    "ERR_ENCRYPTED",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ERR_ENCRYPTED"],
    "ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND"],
    "ERR_EOCDR_NOT_FOUND",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ERR_EOCDR_NOT_FOUND"],
    "ERR_EXTRAFIELD_ZIP64_NOT_FOUND",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ERR_EXTRAFIELD_ZIP64_NOT_FOUND"],
    "ERR_INVALID_PASSWORD",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_PASSWORD"],
    "ERR_INVALID_SIGNATURE",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_SIGNATURE"],
    "ERR_INVALID_UNCOMPRESSED_SIZE",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zip$2d$entry$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ERR_INVALID_UNCOMPRESSED_SIZE"],
    "ERR_LOCAL_FILE_HEADER_NOT_FOUND",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ERR_LOCAL_FILE_HEADER_NOT_FOUND"],
    "ERR_OVERLAPPING_ENTRY",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ERR_OVERLAPPING_ENTRY"],
    "ERR_SPLIT_ZIP_FILE",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ERR_SPLIT_ZIP_FILE"],
    "ERR_UNSUPPORTED_COMPRESSION",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ERR_UNSUPPORTED_COMPRESSION"],
    "ERR_UNSUPPORTED_ENCRYPTION",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ERR_UNSUPPORTED_ENCRYPTION"],
    "ZipReader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ZipReader"],
    "ZipReaderStream",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ZipReaderStream"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/zip-core-reader.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/zip-reader.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$common$2d$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/common-crypto.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$streams$2f$zip$2d$entry$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/streams/zip-entry-stream.js [app-client] (ecmascript) <locals>");
}),
"[project]/node_modules/@zip.js/zip.js/lib/zip-core-writer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ERR_DUPLICATED_NAME",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_DUPLICATED_NAME"],
    "ERR_INVALID_COMMENT",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_COMMENT"],
    "ERR_INVALID_ENCRYPTION_STRENGTH",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_ENCRYPTION_STRENGTH"],
    "ERR_INVALID_ENTRY_COMMENT",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_ENTRY_COMMENT"],
    "ERR_INVALID_ENTRY_NAME",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_ENTRY_NAME"],
    "ERR_INVALID_EXTRAFIELD_DATA",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_EXTRAFIELD_DATA"],
    "ERR_INVALID_EXTRAFIELD_TYPE",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_EXTRAFIELD_TYPE"],
    "ERR_INVALID_VERSION",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_VERSION"],
    "ERR_UNDEFINED_UNCOMPRESSED_SIZE",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_UNDEFINED_UNCOMPRESSED_SIZE"],
    "ERR_UNSUPPORTED_FORMAT",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_UNSUPPORTED_FORMAT"],
    "ERR_ZIP_NOT_EMPTY",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_ZIP_NOT_EMPTY"],
    "ZipWriter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZipWriter"],
    "ZipWriterStream",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZipWriterStream"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/zip-core-writer.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$zip$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/zip-writer.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@zip.js/zip.js/lib/core/util/default-mime-type.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getMimeType",
    ()=>getMimeType,
    "mimeTypes",
    ()=>mimeTypes
]);
/*
 Copyright (c) 2022 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright 
 notice, this list of conditions and the following disclaimer in 
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ const mimeTypes = {};
;
function getMimeType() {
    return "application/octet-stream";
}
}),
"[project]/node_modules/@zip.js/zip.js/lib/zip-core-base.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BlobReader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlobReader"],
    "BlobWriter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlobWriter"],
    "Data64URIReader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Data64URIReader"],
    "Data64URIWriter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Data64URIWriter"],
    "ERR_BAD_FORMAT",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_BAD_FORMAT"],
    "ERR_CENTRAL_DIRECTORY_NOT_FOUND",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_CENTRAL_DIRECTORY_NOT_FOUND"],
    "ERR_DUPLICATED_NAME",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_DUPLICATED_NAME"],
    "ERR_ENCRYPTED",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_ENCRYPTED"],
    "ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND"],
    "ERR_EOCDR_NOT_FOUND",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_EOCDR_NOT_FOUND"],
    "ERR_EXTRAFIELD_ZIP64_NOT_FOUND",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_EXTRAFIELD_ZIP64_NOT_FOUND"],
    "ERR_HTTP_RANGE",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_HTTP_RANGE"],
    "ERR_INVALID_COMMENT",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_COMMENT"],
    "ERR_INVALID_ENCRYPTION_STRENGTH",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_ENCRYPTION_STRENGTH"],
    "ERR_INVALID_ENTRY_COMMENT",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_ENTRY_COMMENT"],
    "ERR_INVALID_ENTRY_NAME",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_ENTRY_NAME"],
    "ERR_INVALID_EXTRAFIELD_DATA",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_EXTRAFIELD_DATA"],
    "ERR_INVALID_EXTRAFIELD_TYPE",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_EXTRAFIELD_TYPE"],
    "ERR_INVALID_PASSWORD",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_PASSWORD"],
    "ERR_INVALID_SIGNATURE",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_SIGNATURE"],
    "ERR_INVALID_UNCOMPRESSED_SIZE",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_UNCOMPRESSED_SIZE"],
    "ERR_INVALID_VERSION",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_INVALID_VERSION"],
    "ERR_LOCAL_FILE_HEADER_NOT_FOUND",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_LOCAL_FILE_HEADER_NOT_FOUND"],
    "ERR_OVERLAPPING_ENTRY",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_OVERLAPPING_ENTRY"],
    "ERR_SPLIT_ZIP_FILE",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_SPLIT_ZIP_FILE"],
    "ERR_UNDEFINED_UNCOMPRESSED_SIZE",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_UNDEFINED_UNCOMPRESSED_SIZE"],
    "ERR_UNSUPPORTED_COMPRESSION",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_UNSUPPORTED_COMPRESSION"],
    "ERR_UNSUPPORTED_ENCRYPTION",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_UNSUPPORTED_ENCRYPTION"],
    "ERR_UNSUPPORTED_FORMAT",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_UNSUPPORTED_FORMAT"],
    "ERR_ZIP_NOT_EMPTY",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ERR_ZIP_NOT_EMPTY"],
    "HttpRangeReader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HttpRangeReader"],
    "HttpReader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HttpReader"],
    "Reader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Reader"],
    "SplitDataReader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SplitDataReader"],
    "SplitDataWriter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SplitDataWriter"],
    "TextReader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextReader"],
    "TextWriter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextWriter"],
    "Uint8ArrayReader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Uint8ArrayReader"],
    "Uint8ArrayWriter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Uint8ArrayWriter"],
    "Writer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Writer"],
    "ZipReader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZipReader"],
    "ZipReaderStream",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZipReaderStream"],
    "ZipWriter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZipWriter"],
    "ZipWriterStream",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZipWriterStream"],
    "configure",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$configuration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["configure"],
    "getMimeType",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$util$2f$default$2d$mime$2d$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getMimeType"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/zip-core-base.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/zip-core-reader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$zip$2d$core$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/zip-core-writer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$io$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/io.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$util$2f$default$2d$mime$2d$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/util/default-mime-type.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zip$2e$js$2f$zip$2e$js$2f$lib$2f$core$2f$configuration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zip.js/zip.js/lib/core/configuration.js [app-client] (ecmascript)");
}),
]);

//# sourceMappingURL=node_modules_%40zip_js_zip_js_lib_744e9056._.js.map