{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/ezekiel.mogaka/Desktop/Code/radio-globe-next/node_modules/%40cesium/engine/Source/DataSources/CzmlDataSource.js"],"sourcesContent":["import ArcType from \"../Core/ArcType.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport ClockRange from \"../Core/ClockRange.js\";\nimport ClockStep from \"../Core/ClockStep.js\";\nimport Color from \"../Core/Color.js\";\nimport CornerType from \"../Core/CornerType.js\";\nimport Credit from \"../Core/Credit.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Event from \"../Core/Event.js\";\nimport ExtrapolationType from \"../Core/ExtrapolationType.js\";\nimport getFilenameFromUri from \"../Core/getFilenameFromUri.js\";\nimport HermitePolynomialApproximation from \"../Core/HermitePolynomialApproximation.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport LagrangePolynomialApproximation from \"../Core/LagrangePolynomialApproximation.js\";\nimport LinearApproximation from \"../Core/LinearApproximation.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport PolygonHierarchy from \"../Core/PolygonHierarchy.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ReferenceFrame from \"../Core/ReferenceFrame.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Spherical from \"../Core/Spherical.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport ClassificationType from \"../Scene/ClassificationType.js\";\nimport ColorBlendMode from \"../Scene/ColorBlendMode.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport LabelStyle from \"../Scene/LabelStyle.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport Uri from \"urijs\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport BoxGraphics from \"./BoxGraphics.js\";\nimport CallbackProperty from \"./CallbackProperty.js\";\nimport CheckerboardMaterialProperty from \"./CheckerboardMaterialProperty.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport CompositeMaterialProperty from \"./CompositeMaterialProperty.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport CompositeProperty from \"./CompositeProperty.js\";\nimport ConstantPositionProperty from \"./ConstantPositionProperty.js\";\nimport ConstantProperty from \"./ConstantProperty.js\";\nimport CorridorGraphics from \"./CorridorGraphics.js\";\nimport CylinderGraphics from \"./CylinderGraphics.js\";\nimport DataSource from \"./DataSource.js\";\nimport DataSourceClock from \"./DataSourceClock.js\";\nimport EllipseGraphics from \"./EllipseGraphics.js\";\nimport EllipsoidGraphics from \"./EllipsoidGraphics.js\";\nimport EntityCluster from \"./EntityCluster.js\";\nimport EntityCollection from \"./EntityCollection.js\";\nimport GridMaterialProperty from \"./GridMaterialProperty.js\";\nimport ImageMaterialProperty from \"./ImageMaterialProperty.js\";\nimport LabelGraphics from \"./LabelGraphics.js\";\nimport ModelGraphics from \"./ModelGraphics.js\";\nimport NodeTransformationProperty from \"./NodeTransformationProperty.js\";\nimport PathGraphics from \"./PathGraphics.js\";\nimport PointGraphics from \"./PointGraphics.js\";\nimport PolygonGraphics from \"./PolygonGraphics.js\";\nimport PolylineArrowMaterialProperty from \"./PolylineArrowMaterialProperty.js\";\nimport PolylineDashMaterialProperty from \"./PolylineDashMaterialProperty.js\";\nimport PolylineGlowMaterialProperty from \"./PolylineGlowMaterialProperty.js\";\nimport PolylineGraphics from \"./PolylineGraphics.js\";\nimport PolylineOutlineMaterialProperty from \"./PolylineOutlineMaterialProperty.js\";\nimport PolylineVolumeGraphics from \"./PolylineVolumeGraphics.js\";\nimport PositionPropertyArray from \"./PositionPropertyArray.js\";\nimport Property from \"./Property.js\";\nimport PropertyArray from \"./PropertyArray.js\";\nimport PropertyBag from \"./PropertyBag.js\";\nimport RectangleGraphics from \"./RectangleGraphics.js\";\nimport ReferenceProperty from \"./ReferenceProperty.js\";\nimport Rotation from \"./Rotation.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport SampledProperty from \"./SampledProperty.js\";\nimport StripeMaterialProperty from \"./StripeMaterialProperty.js\";\nimport StripeOrientation from \"./StripeOrientation.js\";\nimport TimeIntervalCollectionPositionProperty from \"./TimeIntervalCollectionPositionProperty.js\";\nimport TimeIntervalCollectionProperty from \"./TimeIntervalCollectionProperty.js\";\nimport VelocityOrientationProperty from \"./VelocityOrientationProperty.js\";\nimport VelocityVectorProperty from \"./VelocityVectorProperty.js\";\nimport WallGraphics from \"./WallGraphics.js\";\nimport Cesium3DTilesetGraphics from \"./Cesium3DTilesetGraphics.js\";\nimport SensorVolumePortionToDisplay from \"../Scene/SensorVolumePortionToDisplay.js\";\n\n// A marker type to distinguish CZML properties where we need to end up with a unit vector.\n// The data is still loaded into Cartesian3 objects but they are normalized.\nfunction UnitCartesian3() {}\nUnitCartesian3.packedLength = Cartesian3.packedLength;\nUnitCartesian3.unpack = Cartesian3.unpack;\nUnitCartesian3.pack = Cartesian3.pack;\n\n// As a side note, for the purposes of CZML, Quaternion always indicates a unit quaternion.\n\nlet currentId;\n\nfunction createReferenceProperty(entityCollection, referenceString) {\n  if (referenceString[0] === \"#\") {\n    referenceString = currentId + referenceString;\n  }\n  return ReferenceProperty.fromString(entityCollection, referenceString);\n}\n\nfunction createSpecializedProperty(type, entityCollection, packetData) {\n  if (defined(packetData.reference)) {\n    return createReferenceProperty(entityCollection, packetData.reference);\n  }\n\n  if (defined(packetData.velocityReference)) {\n    const referenceProperty = createReferenceProperty(\n      entityCollection,\n      packetData.velocityReference,\n    );\n    switch (type) {\n      case Cartesian3:\n      case UnitCartesian3:\n        return new VelocityVectorProperty(\n          referenceProperty,\n          type === UnitCartesian3,\n        );\n      case Quaternion:\n        return new VelocityOrientationProperty(referenceProperty);\n    }\n  }\n\n  throw new RuntimeError(`${JSON.stringify(packetData)} is not valid CZML.`);\n}\n\nfunction createAdapterProperty(property, adapterFunction) {\n  return new CallbackProperty(function (time, result) {\n    return adapterFunction(property.getValue(time, result));\n  }, property.isConstant);\n}\n\nconst scratchCartesian = new Cartesian3();\nconst scratchSpherical = new Spherical();\nconst scratchCartographic = new Cartographic();\nconst scratchTimeInterval = new TimeInterval();\nconst scratchQuaternion = new Quaternion();\n\nfunction unwrapColorInterval(czmlInterval) {\n  let rgbaf = czmlInterval.rgbaf;\n  if (defined(rgbaf)) {\n    return rgbaf;\n  }\n\n  const rgba = czmlInterval.rgba;\n  if (!defined(rgba)) {\n    return undefined;\n  }\n\n  const length = rgba.length;\n  if (length === Color.packedLength) {\n    return [\n      Color.byteToFloat(rgba[0]),\n      Color.byteToFloat(rgba[1]),\n      Color.byteToFloat(rgba[2]),\n      Color.byteToFloat(rgba[3]),\n    ];\n  }\n\n  rgbaf = new Array(length);\n  for (let i = 0; i < length; i += 5) {\n    rgbaf[i] = rgba[i];\n    rgbaf[i + 1] = Color.byteToFloat(rgba[i + 1]);\n    rgbaf[i + 2] = Color.byteToFloat(rgba[i + 2]);\n    rgbaf[i + 3] = Color.byteToFloat(rgba[i + 3]);\n    rgbaf[i + 4] = Color.byteToFloat(rgba[i + 4]);\n  }\n  return rgbaf;\n}\n\nfunction unwrapUriInterval(czmlInterval, sourceUri) {\n  const uri = czmlInterval.uri ?? czmlInterval;\n  if (defined(sourceUri)) {\n    return sourceUri.getDerivedResource({\n      url: uri,\n    });\n  }\n\n  return Resource.createIfNeeded(uri);\n}\n\nfunction unwrapRectangleInterval(czmlInterval) {\n  let wsen = czmlInterval.wsen;\n  if (defined(wsen)) {\n    return wsen;\n  }\n\n  const wsenDegrees = czmlInterval.wsenDegrees;\n  if (!defined(wsenDegrees)) {\n    return undefined;\n  }\n\n  const length = wsenDegrees.length;\n  if (length === Rectangle.packedLength) {\n    return [\n      CesiumMath.toRadians(wsenDegrees[0]),\n      CesiumMath.toRadians(wsenDegrees[1]),\n      CesiumMath.toRadians(wsenDegrees[2]),\n      CesiumMath.toRadians(wsenDegrees[3]),\n    ];\n  }\n\n  wsen = new Array(length);\n  for (let i = 0; i < length; i += 5) {\n    wsen[i] = wsenDegrees[i];\n    wsen[i + 1] = CesiumMath.toRadians(wsenDegrees[i + 1]);\n    wsen[i + 2] = CesiumMath.toRadians(wsenDegrees[i + 2]);\n    wsen[i + 3] = CesiumMath.toRadians(wsenDegrees[i + 3]);\n    wsen[i + 4] = CesiumMath.toRadians(wsenDegrees[i + 4]);\n  }\n  return wsen;\n}\n\nfunction convertUnitSphericalToCartesian(unitSpherical) {\n  const length = unitSpherical.length;\n  scratchSpherical.magnitude = 1.0;\n  if (length === 2) {\n    scratchSpherical.clock = unitSpherical[0];\n    scratchSpherical.cone = unitSpherical[1];\n    Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);\n    return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];\n  }\n\n  const result = new Array((length / 3) * 4);\n  for (let i = 0, j = 0; i < length; i += 3, j += 4) {\n    result[j] = unitSpherical[i];\n\n    scratchSpherical.clock = unitSpherical[i + 1];\n    scratchSpherical.cone = unitSpherical[i + 2];\n    Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);\n\n    result[j + 1] = scratchCartesian.x;\n    result[j + 2] = scratchCartesian.y;\n    result[j + 3] = scratchCartesian.z;\n  }\n  return result;\n}\n\nfunction convertSphericalToCartesian(spherical) {\n  const length = spherical.length;\n  if (length === 3) {\n    scratchSpherical.clock = spherical[0];\n    scratchSpherical.cone = spherical[1];\n    scratchSpherical.magnitude = spherical[2];\n    Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);\n    return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];\n  }\n\n  const result = new Array(length);\n  for (let i = 0; i < length; i += 4) {\n    result[i] = spherical[i];\n\n    scratchSpherical.clock = spherical[i + 1];\n    scratchSpherical.cone = spherical[i + 2];\n    scratchSpherical.magnitude = spherical[i + 3];\n    Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);\n\n    result[i + 1] = scratchCartesian.x;\n    result[i + 2] = scratchCartesian.y;\n    result[i + 3] = scratchCartesian.z;\n  }\n  return result;\n}\n\nfunction convertCartographicRadiansToCartesian(cartographicRadians) {\n  const length = cartographicRadians.length;\n  if (length === 3) {\n    scratchCartographic.longitude = cartographicRadians[0];\n    scratchCartographic.latitude = cartographicRadians[1];\n    scratchCartographic.height = cartographicRadians[2];\n    Ellipsoid.default.cartographicToCartesian(\n      scratchCartographic,\n      scratchCartesian,\n    );\n    return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];\n  }\n\n  const result = new Array(length);\n  for (let i = 0; i < length; i += 4) {\n    result[i] = cartographicRadians[i];\n\n    scratchCartographic.longitude = cartographicRadians[i + 1];\n    scratchCartographic.latitude = cartographicRadians[i + 2];\n    scratchCartographic.height = cartographicRadians[i + 3];\n    Ellipsoid.default.cartographicToCartesian(\n      scratchCartographic,\n      scratchCartesian,\n    );\n\n    result[i + 1] = scratchCartesian.x;\n    result[i + 2] = scratchCartesian.y;\n    result[i + 3] = scratchCartesian.z;\n  }\n  return result;\n}\n\nfunction convertCartographicDegreesToCartesian(cartographicDegrees) {\n  const length = cartographicDegrees.length;\n  if (length === 3) {\n    scratchCartographic.longitude = CesiumMath.toRadians(\n      cartographicDegrees[0],\n    );\n    scratchCartographic.latitude = CesiumMath.toRadians(cartographicDegrees[1]);\n    scratchCartographic.height = cartographicDegrees[2];\n    Ellipsoid.default.cartographicToCartesian(\n      scratchCartographic,\n      scratchCartesian,\n    );\n    return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];\n  }\n\n  const result = new Array(length);\n  for (let i = 0; i < length; i += 4) {\n    result[i] = cartographicDegrees[i];\n\n    scratchCartographic.longitude = CesiumMath.toRadians(\n      cartographicDegrees[i + 1],\n    );\n    scratchCartographic.latitude = CesiumMath.toRadians(\n      cartographicDegrees[i + 2],\n    );\n    scratchCartographic.height = cartographicDegrees[i + 3];\n    Ellipsoid.default.cartographicToCartesian(\n      scratchCartographic,\n      scratchCartesian,\n    );\n\n    result[i + 1] = scratchCartesian.x;\n    result[i + 2] = scratchCartesian.y;\n    result[i + 3] = scratchCartesian.z;\n  }\n  return result;\n}\n\nfunction unwrapCartesianInterval(czmlInterval) {\n  const cartesian = czmlInterval.cartesian;\n  if (defined(cartesian)) {\n    return cartesian;\n  }\n\n  const cartesianVelocity = czmlInterval.cartesianVelocity;\n  if (defined(cartesianVelocity)) {\n    return cartesianVelocity;\n  }\n\n  const unitCartesian = czmlInterval.unitCartesian;\n  if (defined(unitCartesian)) {\n    return unitCartesian;\n  }\n\n  const unitSpherical = czmlInterval.unitSpherical;\n  if (defined(unitSpherical)) {\n    return convertUnitSphericalToCartesian(unitSpherical);\n  }\n\n  const spherical = czmlInterval.spherical;\n  if (defined(spherical)) {\n    return convertSphericalToCartesian(spherical);\n  }\n\n  const cartographicRadians = czmlInterval.cartographicRadians;\n  if (defined(cartographicRadians)) {\n    return convertCartographicRadiansToCartesian(cartographicRadians);\n  }\n\n  const cartographicDegrees = czmlInterval.cartographicDegrees;\n  if (defined(cartographicDegrees)) {\n    return convertCartographicDegreesToCartesian(cartographicDegrees);\n  }\n\n  throw new RuntimeError(\n    `${JSON.stringify(czmlInterval)} is not a valid CZML interval.`,\n  );\n}\n\nfunction normalizePackedCartesianArray(array, startingIndex) {\n  Cartesian3.unpack(array, startingIndex, scratchCartesian);\n  Cartesian3.normalize(scratchCartesian, scratchCartesian);\n  Cartesian3.pack(scratchCartesian, array, startingIndex);\n}\n\nfunction unwrapUnitCartesianInterval(czmlInterval) {\n  const cartesian = unwrapCartesianInterval(czmlInterval);\n  if (cartesian.length === 3) {\n    normalizePackedCartesianArray(cartesian, 0);\n    return cartesian;\n  }\n\n  for (let i = 1; i < cartesian.length; i += 4) {\n    normalizePackedCartesianArray(cartesian, i);\n  }\n\n  return cartesian;\n}\n\nfunction normalizePackedQuaternionArray(array, startingIndex) {\n  Quaternion.unpack(array, startingIndex, scratchQuaternion);\n  Quaternion.normalize(scratchQuaternion, scratchQuaternion);\n  Quaternion.pack(scratchQuaternion, array, startingIndex);\n}\n\nfunction unwrapQuaternionInterval(czmlInterval) {\n  const unitQuaternion = czmlInterval.unitQuaternion;\n  if (defined(unitQuaternion)) {\n    if (unitQuaternion.length === 4) {\n      normalizePackedQuaternionArray(unitQuaternion, 0);\n      return unitQuaternion;\n    }\n\n    for (let i = 1; i < unitQuaternion.length; i += 5) {\n      normalizePackedQuaternionArray(unitQuaternion, i);\n    }\n  }\n  return unitQuaternion;\n}\n\nfunction getPropertyType(czmlInterval) {\n  // The associations in this function need to be kept in sync with the\n  // associations in unwrapInterval.\n\n  // Intentionally omitted due to conficts in CZML property names:\n  // * Image (conflicts with Uri)\n  // * Rotation (conflicts with Number)\n  //\n  // cartesianVelocity is also omitted due to incomplete support for\n  // derivative information in CZML properties.\n  // (Currently cartesianVelocity is hacked directly into the position processing code)\n  if (typeof czmlInterval === \"boolean\") {\n    return Boolean;\n  } else if (typeof czmlInterval === \"number\") {\n    return Number;\n  } else if (typeof czmlInterval === \"string\") {\n    return String;\n  } else if (czmlInterval.hasOwnProperty(\"array\")) {\n    return Array;\n  } else if (czmlInterval.hasOwnProperty(\"boolean\")) {\n    return Boolean;\n  } else if (czmlInterval.hasOwnProperty(\"boundingRectangle\")) {\n    return BoundingRectangle;\n  } else if (czmlInterval.hasOwnProperty(\"cartesian2\")) {\n    return Cartesian2;\n  } else if (\n    czmlInterval.hasOwnProperty(\"cartesian\") ||\n    czmlInterval.hasOwnProperty(\"spherical\") ||\n    czmlInterval.hasOwnProperty(\"cartographicRadians\") ||\n    czmlInterval.hasOwnProperty(\"cartographicDegrees\")\n  ) {\n    return Cartesian3;\n  } else if (\n    czmlInterval.hasOwnProperty(\"unitCartesian\") ||\n    czmlInterval.hasOwnProperty(\"unitSpherical\")\n  ) {\n    return UnitCartesian3;\n  } else if (\n    czmlInterval.hasOwnProperty(\"rgba\") ||\n    czmlInterval.hasOwnProperty(\"rgbaf\")\n  ) {\n    return Color;\n  } else if (czmlInterval.hasOwnProperty(\"arcType\")) {\n    return ArcType;\n  } else if (czmlInterval.hasOwnProperty(\"classificationType\")) {\n    return ClassificationType;\n  } else if (czmlInterval.hasOwnProperty(\"colorBlendMode\")) {\n    return ColorBlendMode;\n  } else if (czmlInterval.hasOwnProperty(\"cornerType\")) {\n    return CornerType;\n  } else if (czmlInterval.hasOwnProperty(\"heightReference\")) {\n    return HeightReference;\n  } else if (czmlInterval.hasOwnProperty(\"horizontalOrigin\")) {\n    return HorizontalOrigin;\n  } else if (czmlInterval.hasOwnProperty(\"date\")) {\n    return JulianDate;\n  } else if (czmlInterval.hasOwnProperty(\"labelStyle\")) {\n    return LabelStyle;\n  } else if (czmlInterval.hasOwnProperty(\"number\")) {\n    return Number;\n  } else if (czmlInterval.hasOwnProperty(\"nearFarScalar\")) {\n    return NearFarScalar;\n  } else if (czmlInterval.hasOwnProperty(\"distanceDisplayCondition\")) {\n    return DistanceDisplayCondition;\n  } else if (\n    czmlInterval.hasOwnProperty(\"object\") ||\n    czmlInterval.hasOwnProperty(\"value\")\n  ) {\n    return Object;\n  } else if (czmlInterval.hasOwnProperty(\"unitQuaternion\")) {\n    return Quaternion;\n  } else if (czmlInterval.hasOwnProperty(\"shadowMode\")) {\n    return ShadowMode;\n  } else if (czmlInterval.hasOwnProperty(\"string\")) {\n    return String;\n  } else if (czmlInterval.hasOwnProperty(\"stripeOrientation\")) {\n    return StripeOrientation;\n  } else if (\n    czmlInterval.hasOwnProperty(\"wsen\") ||\n    czmlInterval.hasOwnProperty(\"wsenDegrees\")\n  ) {\n    return Rectangle;\n  } else if (czmlInterval.hasOwnProperty(\"uri\")) {\n    return Uri;\n  } else if (czmlInterval.hasOwnProperty(\"verticalOrigin\")) {\n    return VerticalOrigin;\n  }\n  // fallback case\n  return Object;\n}\n\nfunction unwrapInterval(type, czmlInterval, sourceUri) {\n  // The associations in this function need to be kept in sync with the\n  // associations in getPropertyType\n  switch (type) {\n    case ArcType:\n      return ArcType[czmlInterval.arcType ?? czmlInterval];\n    case Array:\n      return czmlInterval.array;\n    case Boolean:\n      return czmlInterval[\"boolean\"] ?? czmlInterval;\n    case BoundingRectangle:\n      return czmlInterval.boundingRectangle;\n    case Cartesian2:\n      return czmlInterval.cartesian2;\n    case Cartesian3:\n      return unwrapCartesianInterval(czmlInterval);\n    case UnitCartesian3:\n      return unwrapUnitCartesianInterval(czmlInterval);\n    case Color:\n      return unwrapColorInterval(czmlInterval);\n    case ClassificationType:\n      return ClassificationType[\n        czmlInterval.classificationType ?? czmlInterval\n      ];\n    case ColorBlendMode:\n      return ColorBlendMode[czmlInterval.colorBlendMode ?? czmlInterval];\n    case CornerType:\n      return CornerType[czmlInterval.cornerType ?? czmlInterval];\n    case HeightReference:\n      return HeightReference[czmlInterval.heightReference ?? czmlInterval];\n    case HorizontalOrigin:\n      return HorizontalOrigin[czmlInterval.horizontalOrigin ?? czmlInterval];\n    case Image:\n      return unwrapUriInterval(czmlInterval, sourceUri);\n    case JulianDate:\n      return JulianDate.fromIso8601(czmlInterval.date ?? czmlInterval);\n    case LabelStyle:\n      return LabelStyle[czmlInterval.labelStyle ?? czmlInterval];\n    case Number:\n      return czmlInterval.number ?? czmlInterval;\n    case NearFarScalar:\n      return czmlInterval.nearFarScalar;\n    case DistanceDisplayCondition:\n      return czmlInterval.distanceDisplayCondition;\n    case Object:\n      return czmlInterval.object ?? czmlInterval.value ?? czmlInterval;\n    case Quaternion:\n      return unwrapQuaternionInterval(czmlInterval);\n    case Rotation:\n      return czmlInterval.number ?? czmlInterval;\n    case SensorVolumePortionToDisplay:\n      return SensorVolumePortionToDisplay[\n        czmlInterval.portionToDisplay ?? czmlInterval\n      ];\n    case ShadowMode:\n      return ShadowMode[\n        czmlInterval.shadowMode ?? czmlInterval.shadows ?? czmlInterval\n      ];\n    case String:\n      return czmlInterval.string ?? czmlInterval;\n    case StripeOrientation:\n      return StripeOrientation[czmlInterval.stripeOrientation ?? czmlInterval];\n    case Rectangle:\n      return unwrapRectangleInterval(czmlInterval);\n    case Uri:\n      return unwrapUriInterval(czmlInterval, sourceUri);\n    case VerticalOrigin:\n      return VerticalOrigin[czmlInterval.verticalOrigin ?? czmlInterval];\n    default:\n      throw new RuntimeError(`Unknown CzmlDataSource interval type: ${type}`);\n  }\n}\n\nconst interpolators = {\n  HERMITE: HermitePolynomialApproximation,\n  LAGRANGE: LagrangePolynomialApproximation,\n  LINEAR: LinearApproximation,\n};\n\nfunction updateInterpolationSettings(packetData, property) {\n  const interpolationAlgorithm = packetData.interpolationAlgorithm;\n  const interpolationDegree = packetData.interpolationDegree;\n  if (defined(interpolationAlgorithm) || defined(interpolationDegree)) {\n    property.setInterpolationOptions({\n      interpolationAlgorithm: interpolators[interpolationAlgorithm],\n      interpolationDegree: interpolationDegree,\n    });\n  }\n\n  const forwardExtrapolationType = packetData.forwardExtrapolationType;\n  if (defined(forwardExtrapolationType)) {\n    property.forwardExtrapolationType =\n      ExtrapolationType[forwardExtrapolationType];\n  }\n\n  const forwardExtrapolationDuration = packetData.forwardExtrapolationDuration;\n  if (defined(forwardExtrapolationDuration)) {\n    property.forwardExtrapolationDuration = forwardExtrapolationDuration;\n  }\n\n  const backwardExtrapolationType = packetData.backwardExtrapolationType;\n  if (defined(backwardExtrapolationType)) {\n    property.backwardExtrapolationType =\n      ExtrapolationType[backwardExtrapolationType];\n  }\n\n  const backwardExtrapolationDuration =\n    packetData.backwardExtrapolationDuration;\n  if (defined(backwardExtrapolationDuration)) {\n    property.backwardExtrapolationDuration = backwardExtrapolationDuration;\n  }\n}\n\nconst iso8601Scratch = {\n  iso8601: undefined,\n};\n\nfunction intervalFromString(intervalString) {\n  if (!defined(intervalString)) {\n    return undefined;\n  }\n  iso8601Scratch.iso8601 = intervalString;\n  return TimeInterval.fromIso8601(iso8601Scratch);\n}\n\nfunction wrapPropertyInInfiniteInterval(property) {\n  const interval = Iso8601.MAXIMUM_INTERVAL.clone();\n  interval.data = property;\n  return interval;\n}\n\nfunction convertPropertyToComposite(property) {\n  // Create the composite and add the old property, wrapped in an infinite interval.\n  const composite = new CompositeProperty();\n  composite.intervals.addInterval(wrapPropertyInInfiniteInterval(property));\n  return composite;\n}\n\nfunction convertPositionPropertyToComposite(property) {\n  // Create the composite and add the old property, wrapped in an infinite interval.\n  const composite = new CompositePositionProperty(property.referenceFrame);\n  composite.intervals.addInterval(wrapPropertyInInfiniteInterval(property));\n  return composite;\n}\n\nfunction processProperty(\n  type,\n  object,\n  propertyName,\n  packetData,\n  constrainedInterval,\n  sourceUri,\n  entityCollection,\n) {\n  let combinedInterval = intervalFromString(packetData.interval);\n  if (defined(constrainedInterval)) {\n    if (defined(combinedInterval)) {\n      combinedInterval = TimeInterval.intersect(\n        combinedInterval,\n        constrainedInterval,\n        scratchTimeInterval,\n      );\n    } else {\n      combinedInterval = constrainedInterval;\n    }\n  }\n\n  let packedLength;\n  let unwrappedInterval;\n  let unwrappedIntervalLength;\n\n  // CZML properties can be defined in many ways.  Most ways represent a structure for\n  // encoding a single value (number, string, cartesian, etc.)  Regardless of the value type,\n  // if it encodes a single value it will get loaded into a ConstantProperty eventually.\n  // Alternatively, there are ways of defining a property that require specialized\n  // client-side representation. Currently, these are ReferenceProperty,\n  // and client-side velocity computation properties such as VelocityVectorProperty.\n  const isValue =\n    !defined(packetData.reference) && !defined(packetData.velocityReference);\n  const hasInterval =\n    defined(combinedInterval) &&\n    !combinedInterval.equals(Iso8601.MAXIMUM_INTERVAL);\n\n  if (packetData.delete === true) {\n    // If deleting this property for all time, we can simply set to undefined and return.\n    if (!hasInterval) {\n      object[propertyName] = undefined;\n      return;\n    }\n\n    // Deleting depends on the type of property we have.\n    return removePropertyData(object[propertyName], combinedInterval);\n  }\n\n  let isSampled = false;\n\n  if (isValue) {\n    unwrappedInterval = unwrapInterval(type, packetData, sourceUri);\n    if (!defined(unwrappedInterval)) {\n      // not a known value type, bail\n      return;\n    }\n    packedLength = type.packedLength ?? 1;\n    unwrappedIntervalLength = unwrappedInterval.length ?? 1;\n    isSampled =\n      !defined(packetData.array) &&\n      typeof unwrappedInterval !== \"string\" &&\n      unwrappedIntervalLength > packedLength &&\n      type !== Object;\n  }\n\n  // Rotation is a special case because it represents a native type (Number)\n  // and therefore does not need to be unpacked when loaded as a constant value.\n  const needsUnpacking = typeof type.unpack === \"function\" && type !== Rotation;\n\n  // Any time a constant value is assigned, it completely blows away anything else.\n  if (!isSampled && !hasInterval) {\n    if (isValue) {\n      object[propertyName] = new ConstantProperty(\n        needsUnpacking ? type.unpack(unwrappedInterval, 0) : unwrappedInterval,\n      );\n    } else {\n      object[propertyName] = createSpecializedProperty(\n        type,\n        entityCollection,\n        packetData,\n      );\n    }\n    return;\n  }\n\n  let property = object[propertyName];\n\n  let epoch;\n  const packetEpoch = packetData.epoch;\n  if (defined(packetEpoch)) {\n    epoch = JulianDate.fromIso8601(packetEpoch);\n  }\n\n  // Without an interval, any sampled value is infinite, meaning it completely\n  // replaces any non-sampled property that may exist.\n  if (isSampled && !hasInterval) {\n    if (!(property instanceof SampledProperty)) {\n      object[propertyName] = property = new SampledProperty(type);\n    }\n    property.addSamplesPackedArray(unwrappedInterval, epoch);\n    updateInterpolationSettings(packetData, property);\n    return;\n  }\n\n  let interval;\n\n  // A constant value with an interval is normally part of a TimeIntervalCollection,\n  // However, if the current property is not a time-interval collection, we need\n  // to turn it into a Composite, preserving the old data with the new interval.\n  if (!isSampled && hasInterval) {\n    // Create a new interval for the constant value.\n    combinedInterval = combinedInterval.clone();\n    if (isValue) {\n      combinedInterval.data = needsUnpacking\n        ? type.unpack(unwrappedInterval, 0)\n        : unwrappedInterval;\n    } else {\n      combinedInterval.data = createSpecializedProperty(\n        type,\n        entityCollection,\n        packetData,\n      );\n    }\n\n    // If no property exists, simply use a new interval collection\n    if (!defined(property)) {\n      object[propertyName] = property = isValue\n        ? new TimeIntervalCollectionProperty()\n        : new CompositeProperty();\n    }\n\n    if (isValue && property instanceof TimeIntervalCollectionProperty) {\n      // If we created a collection, or it already was one, use it.\n      property.intervals.addInterval(combinedInterval);\n    } else if (property instanceof CompositeProperty) {\n      // If the collection was already a CompositeProperty, use it.\n      if (isValue) {\n        combinedInterval.data = new ConstantProperty(combinedInterval.data);\n      }\n      property.intervals.addInterval(combinedInterval);\n    } else {\n      // Otherwise, create a CompositeProperty but preserve the existing data.\n      object[propertyName] = property = convertPropertyToComposite(property);\n\n      // Change the new data to a ConstantProperty and add it.\n      if (isValue) {\n        combinedInterval.data = new ConstantProperty(combinedInterval.data);\n      }\n      property.intervals.addInterval(combinedInterval);\n    }\n\n    return;\n  }\n\n  // isSampled && hasInterval\n  if (!defined(property)) {\n    object[propertyName] = property = new CompositeProperty();\n  }\n\n  // Create a CompositeProperty but preserve the existing data.\n  if (!(property instanceof CompositeProperty)) {\n    object[propertyName] = property = convertPropertyToComposite(property);\n  }\n\n  // Check if the interval already exists in the composite.\n  const intervals = property.intervals;\n  interval = intervals.findInterval(combinedInterval);\n  if (!defined(interval) || !(interval.data instanceof SampledProperty)) {\n    // If not, create a SampledProperty for it.\n    interval = combinedInterval.clone();\n    interval.data = new SampledProperty(type);\n    intervals.addInterval(interval);\n  }\n  interval.data.addSamplesPackedArray(unwrappedInterval, epoch);\n  updateInterpolationSettings(packetData, interval.data);\n}\n\nfunction removePropertyData(property, interval) {\n  if (property instanceof SampledProperty) {\n    property.removeSamples(interval);\n    return;\n  } else if (property instanceof TimeIntervalCollectionProperty) {\n    property.intervals.removeInterval(interval);\n    return;\n  } else if (property instanceof CompositeProperty) {\n    const intervals = property.intervals;\n    for (let i = 0; i < intervals.length; ++i) {\n      const intersection = TimeInterval.intersect(\n        intervals.get(i),\n        interval,\n        scratchTimeInterval,\n      );\n      if (!intersection.isEmpty) {\n        // remove data from the contained properties\n        removePropertyData(intersection.data, interval);\n      }\n    }\n    // remove the intervals from the composite\n    intervals.removeInterval(interval);\n    return;\n  }\n}\n\nfunction processPacketData(\n  type,\n  object,\n  propertyName,\n  packetData,\n  interval,\n  sourceUri,\n  entityCollection,\n) {\n  if (!defined(packetData)) {\n    return;\n  }\n\n  if (Array.isArray(packetData)) {\n    for (let i = 0, len = packetData.length; i < len; ++i) {\n      processProperty(\n        type,\n        object,\n        propertyName,\n        packetData[i],\n        interval,\n        sourceUri,\n        entityCollection,\n      );\n    }\n  } else {\n    processProperty(\n      type,\n      object,\n      propertyName,\n      packetData,\n      interval,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processPositionProperty(\n  object,\n  propertyName,\n  packetData,\n  constrainedInterval,\n  sourceUri,\n  entityCollection,\n) {\n  let combinedInterval = intervalFromString(packetData.interval);\n  if (defined(constrainedInterval)) {\n    if (defined(combinedInterval)) {\n      combinedInterval = TimeInterval.intersect(\n        combinedInterval,\n        constrainedInterval,\n        scratchTimeInterval,\n      );\n    } else {\n      combinedInterval = constrainedInterval;\n    }\n  }\n\n  const numberOfDerivatives = defined(packetData.cartesianVelocity) ? 1 : 0;\n  const packedLength = Cartesian3.packedLength * (numberOfDerivatives + 1);\n  let unwrappedInterval;\n  let unwrappedIntervalLength;\n  const isValue = !defined(packetData.reference);\n  const hasInterval =\n    defined(combinedInterval) &&\n    !combinedInterval.equals(Iso8601.MAXIMUM_INTERVAL);\n\n  if (packetData.delete === true) {\n    // If deleting this property for all time, we can simply set to undefined and return.\n    if (!hasInterval) {\n      object[propertyName] = undefined;\n      return;\n    }\n\n    // Deleting depends on the type of property we have.\n    return removePositionPropertyData(object[propertyName], combinedInterval);\n  }\n\n  let referenceFrame;\n  let isSampled = false;\n\n  if (isValue) {\n    if (defined(packetData.referenceFrame)) {\n      referenceFrame = ReferenceFrame[packetData.referenceFrame];\n    }\n    referenceFrame = referenceFrame ?? ReferenceFrame.FIXED;\n    unwrappedInterval = unwrapCartesianInterval(packetData);\n    unwrappedIntervalLength = unwrappedInterval.length ?? 1;\n    isSampled = unwrappedIntervalLength > packedLength;\n  }\n\n  // Any time a constant value is assigned, it completely blows away anything else.\n  if (!isSampled && !hasInterval) {\n    if (isValue) {\n      object[propertyName] = new ConstantPositionProperty(\n        Cartesian3.unpack(unwrappedInterval),\n        referenceFrame,\n      );\n    } else {\n      object[propertyName] = createReferenceProperty(\n        entityCollection,\n        packetData.reference,\n      );\n    }\n    return;\n  }\n\n  let property = object[propertyName];\n\n  let epoch;\n  const packetEpoch = packetData.epoch;\n  if (defined(packetEpoch)) {\n    epoch = JulianDate.fromIso8601(packetEpoch);\n  }\n\n  // Without an interval, any sampled value is infinite, meaning it completely\n  // replaces any non-sampled property that may exist.\n  if (isSampled && !hasInterval) {\n    if (\n      !(property instanceof SampledPositionProperty) ||\n      (defined(referenceFrame) && property.referenceFrame !== referenceFrame)\n    ) {\n      object[propertyName] = property = new SampledPositionProperty(\n        referenceFrame,\n        numberOfDerivatives,\n      );\n    }\n    property.addSamplesPackedArray(unwrappedInterval, epoch);\n    updateInterpolationSettings(packetData, property);\n    return;\n  }\n\n  let interval;\n\n  // A constant value with an interval is normally part of a TimeIntervalCollection,\n  // However, if the current property is not a time-interval collection, we need\n  // to turn it into a Composite, preserving the old data with the new interval.\n  if (!isSampled && hasInterval) {\n    // Create a new interval for the constant value.\n    combinedInterval = combinedInterval.clone();\n    if (isValue) {\n      combinedInterval.data = Cartesian3.unpack(unwrappedInterval);\n    } else {\n      combinedInterval.data = createReferenceProperty(\n        entityCollection,\n        packetData.reference,\n      );\n    }\n\n    // If no property exists, simply use a new interval collection\n    if (!defined(property)) {\n      if (isValue) {\n        property = new TimeIntervalCollectionPositionProperty(referenceFrame);\n      } else {\n        property = new CompositePositionProperty(referenceFrame);\n      }\n      object[propertyName] = property;\n    }\n\n    if (\n      isValue &&\n      property instanceof TimeIntervalCollectionPositionProperty &&\n      defined(referenceFrame) &&\n      property.referenceFrame === referenceFrame\n    ) {\n      // If we create a collection, or it already existed, use it.\n      property.intervals.addInterval(combinedInterval);\n    } else if (property instanceof CompositePositionProperty) {\n      // If the collection was already a CompositePositionProperty, use it.\n      if (isValue) {\n        combinedInterval.data = new ConstantPositionProperty(\n          combinedInterval.data,\n          referenceFrame,\n        );\n      }\n      property.intervals.addInterval(combinedInterval);\n    } else {\n      // Otherwise, create a CompositePositionProperty but preserve the existing data.\n      object[propertyName] = property =\n        convertPositionPropertyToComposite(property);\n\n      // Change the new data to a ConstantPositionProperty and add it.\n      if (isValue) {\n        combinedInterval.data = new ConstantPositionProperty(\n          combinedInterval.data,\n          referenceFrame,\n        );\n      }\n      property.intervals.addInterval(combinedInterval);\n    }\n\n    return;\n  }\n\n  // isSampled && hasInterval\n  if (!defined(property)) {\n    object[propertyName] = property = new CompositePositionProperty(\n      referenceFrame,\n    );\n  } else if (!(property instanceof CompositePositionProperty)) {\n    // Create a CompositeProperty but preserve the existing data.\n    object[propertyName] = property =\n      convertPositionPropertyToComposite(property);\n  }\n\n  // Check if the interval already exists in the composite.\n  const intervals = property.intervals;\n  interval = intervals.findInterval(combinedInterval);\n  if (\n    !defined(interval) ||\n    !(interval.data instanceof SampledPositionProperty) ||\n    (defined(referenceFrame) && interval.data.referenceFrame !== referenceFrame)\n  ) {\n    // If not, create a SampledPositionProperty for it.\n    interval = combinedInterval.clone();\n    interval.data = new SampledPositionProperty(\n      referenceFrame,\n      numberOfDerivatives,\n    );\n    intervals.addInterval(interval);\n  }\n  interval.data.addSamplesPackedArray(unwrappedInterval, epoch);\n  updateInterpolationSettings(packetData, interval.data);\n}\n\nfunction removePositionPropertyData(property, interval) {\n  if (property instanceof SampledPositionProperty) {\n    property.removeSamples(interval);\n    return;\n  } else if (property instanceof TimeIntervalCollectionPositionProperty) {\n    property.intervals.removeInterval(interval);\n    return;\n  } else if (property instanceof CompositePositionProperty) {\n    const intervals = property.intervals;\n    for (let i = 0; i < intervals.length; ++i) {\n      const intersection = TimeInterval.intersect(\n        intervals.get(i),\n        interval,\n        scratchTimeInterval,\n      );\n      if (!intersection.isEmpty) {\n        // remove data from the contained properties\n        removePositionPropertyData(intersection.data, interval);\n      }\n    }\n    // remove the intervals from the composite\n    intervals.removeInterval(interval);\n    return;\n  }\n}\n\nfunction processPositionPacketData(\n  object,\n  propertyName,\n  packetData,\n  interval,\n  sourceUri,\n  entityCollection,\n) {\n  if (!defined(packetData)) {\n    return;\n  }\n\n  if (Array.isArray(packetData)) {\n    for (let i = 0, len = packetData.length; i < len; ++i) {\n      processPositionProperty(\n        object,\n        propertyName,\n        packetData[i],\n        interval,\n        sourceUri,\n        entityCollection,\n      );\n    }\n  } else {\n    processPositionProperty(\n      object,\n      propertyName,\n      packetData,\n      interval,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processShapePacketData(\n  object,\n  propertyName,\n  packetData,\n  entityCollection,\n) {\n  if (defined(packetData.references)) {\n    processReferencesArrayPacketData(\n      object,\n      propertyName,\n      packetData.references,\n      packetData.interval,\n      entityCollection,\n      PropertyArray,\n      CompositeProperty,\n    );\n  } else {\n    if (defined(packetData.cartesian2)) {\n      packetData.array = Cartesian2.unpackArray(packetData.cartesian2);\n    } else if (defined(packetData.cartesian)) {\n      // for backwards compatibility, also accept `cartesian`\n      packetData.array = Cartesian2.unpackArray(packetData.cartesian);\n    }\n\n    if (defined(packetData.array)) {\n      processPacketData(\n        Array,\n        object,\n        propertyName,\n        packetData,\n        undefined,\n        undefined,\n        entityCollection,\n      );\n    }\n  }\n}\n\nfunction processMaterialProperty(\n  object,\n  propertyName,\n  packetData,\n  constrainedInterval,\n  sourceUri,\n  entityCollection,\n) {\n  let combinedInterval = intervalFromString(packetData.interval);\n  if (defined(constrainedInterval)) {\n    if (defined(combinedInterval)) {\n      combinedInterval = TimeInterval.intersect(\n        combinedInterval,\n        constrainedInterval,\n        scratchTimeInterval,\n      );\n    } else {\n      combinedInterval = constrainedInterval;\n    }\n  }\n\n  let property = object[propertyName];\n  let existingMaterial;\n  let existingInterval;\n\n  if (defined(combinedInterval)) {\n    if (!(property instanceof CompositeMaterialProperty)) {\n      property = new CompositeMaterialProperty();\n      object[propertyName] = property;\n    }\n    //See if we already have data at that interval.\n    const thisIntervals = property.intervals;\n    existingInterval = thisIntervals.findInterval({\n      start: combinedInterval.start,\n      stop: combinedInterval.stop,\n    });\n    if (defined(existingInterval)) {\n      //We have an interval, but we need to make sure the\n      //new data is the same type of material as the old data.\n      existingMaterial = existingInterval.data;\n    } else {\n      //If not, create it.\n      existingInterval = combinedInterval.clone();\n      thisIntervals.addInterval(existingInterval);\n    }\n  } else {\n    existingMaterial = property;\n  }\n\n  let materialData;\n  if (defined(packetData.solidColor)) {\n    if (!(existingMaterial instanceof ColorMaterialProperty)) {\n      existingMaterial = new ColorMaterialProperty();\n    }\n    materialData = packetData.solidColor;\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"color\",\n      materialData.color,\n      undefined,\n      undefined,\n      entityCollection,\n    );\n  } else if (defined(packetData.grid)) {\n    if (!(existingMaterial instanceof GridMaterialProperty)) {\n      existingMaterial = new GridMaterialProperty();\n    }\n    materialData = packetData.grid;\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"color\",\n      materialData.color,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Number,\n      existingMaterial,\n      \"cellAlpha\",\n      materialData.cellAlpha,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Cartesian2,\n      existingMaterial,\n      \"lineCount\",\n      materialData.lineCount,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Cartesian2,\n      existingMaterial,\n      \"lineThickness\",\n      materialData.lineThickness,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Cartesian2,\n      existingMaterial,\n      \"lineOffset\",\n      materialData.lineOffset,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  } else if (defined(packetData.image)) {\n    if (!(existingMaterial instanceof ImageMaterialProperty)) {\n      existingMaterial = new ImageMaterialProperty();\n    }\n    materialData = packetData.image;\n    processPacketData(\n      Image,\n      existingMaterial,\n      \"image\",\n      materialData.image,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Cartesian2,\n      existingMaterial,\n      \"repeat\",\n      materialData.repeat,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"color\",\n      materialData.color,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Boolean,\n      existingMaterial,\n      \"transparent\",\n      materialData.transparent,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  } else if (defined(packetData.stripe)) {\n    if (!(existingMaterial instanceof StripeMaterialProperty)) {\n      existingMaterial = new StripeMaterialProperty();\n    }\n    materialData = packetData.stripe;\n    processPacketData(\n      StripeOrientation,\n      existingMaterial,\n      \"orientation\",\n      materialData.orientation,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"evenColor\",\n      materialData.evenColor,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"oddColor\",\n      materialData.oddColor,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Number,\n      existingMaterial,\n      \"offset\",\n      materialData.offset,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Number,\n      existingMaterial,\n      \"repeat\",\n      materialData.repeat,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  } else if (defined(packetData.polylineOutline)) {\n    if (!(existingMaterial instanceof PolylineOutlineMaterialProperty)) {\n      existingMaterial = new PolylineOutlineMaterialProperty();\n    }\n    materialData = packetData.polylineOutline;\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"color\",\n      materialData.color,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"outlineColor\",\n      materialData.outlineColor,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Number,\n      existingMaterial,\n      \"outlineWidth\",\n      materialData.outlineWidth,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  } else if (defined(packetData.polylineGlow)) {\n    if (!(existingMaterial instanceof PolylineGlowMaterialProperty)) {\n      existingMaterial = new PolylineGlowMaterialProperty();\n    }\n    materialData = packetData.polylineGlow;\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"color\",\n      materialData.color,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Number,\n      existingMaterial,\n      \"glowPower\",\n      materialData.glowPower,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Number,\n      existingMaterial,\n      \"taperPower\",\n      materialData.taperPower,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  } else if (defined(packetData.polylineArrow)) {\n    if (!(existingMaterial instanceof PolylineArrowMaterialProperty)) {\n      existingMaterial = new PolylineArrowMaterialProperty();\n    }\n    materialData = packetData.polylineArrow;\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"color\",\n      materialData.color,\n      undefined,\n      undefined,\n      entityCollection,\n    );\n  } else if (defined(packetData.polylineDash)) {\n    if (!(existingMaterial instanceof PolylineDashMaterialProperty)) {\n      existingMaterial = new PolylineDashMaterialProperty();\n    }\n    materialData = packetData.polylineDash;\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"color\",\n      materialData.color,\n      undefined,\n      undefined,\n      entityCollection,\n    );\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"gapColor\",\n      materialData.gapColor,\n      undefined,\n      undefined,\n      entityCollection,\n    );\n    processPacketData(\n      Number,\n      existingMaterial,\n      \"dashLength\",\n      materialData.dashLength,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Number,\n      existingMaterial,\n      \"dashPattern\",\n      materialData.dashPattern,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  } else if (defined(packetData.checkerboard)) {\n    if (!(existingMaterial instanceof CheckerboardMaterialProperty)) {\n      existingMaterial = new CheckerboardMaterialProperty();\n    }\n    materialData = packetData.checkerboard;\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"evenColor\",\n      materialData.evenColor,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"oddColor\",\n      materialData.oddColor,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Cartesian2,\n      existingMaterial,\n      \"repeat\",\n      materialData.repeat,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  }\n\n  if (defined(existingInterval)) {\n    existingInterval.data = existingMaterial;\n  } else {\n    object[propertyName] = existingMaterial;\n  }\n}\n\nfunction processMaterialPacketData(\n  object,\n  propertyName,\n  packetData,\n  interval,\n  sourceUri,\n  entityCollection,\n) {\n  if (!defined(packetData)) {\n    return;\n  }\n\n  if (Array.isArray(packetData)) {\n    for (let i = 0, len = packetData.length; i < len; ++i) {\n      processMaterialProperty(\n        object,\n        propertyName,\n        packetData[i],\n        interval,\n        sourceUri,\n        entityCollection,\n      );\n    }\n  } else {\n    processMaterialProperty(\n      object,\n      propertyName,\n      packetData,\n      interval,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processName(entity, packet, entityCollection, sourceUri) {\n  const nameData = packet.name;\n  if (defined(nameData)) {\n    entity.name = packet.name;\n  }\n}\n\nfunction processDescription(entity, packet, entityCollection, sourceUri) {\n  const descriptionData = packet.description;\n  if (defined(descriptionData)) {\n    processPacketData(\n      String,\n      entity,\n      \"description\",\n      descriptionData,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processPosition(entity, packet, entityCollection, sourceUri) {\n  const positionData = packet.position;\n  if (defined(positionData)) {\n    processPositionPacketData(\n      entity,\n      \"position\",\n      positionData,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processViewFrom(entity, packet, entityCollection, sourceUri) {\n  const viewFromData = packet.viewFrom;\n  if (defined(viewFromData)) {\n    processPacketData(\n      Cartesian3,\n      entity,\n      \"viewFrom\",\n      viewFromData,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processOrientation(entity, packet, entityCollection, sourceUri) {\n  const orientationData = packet.orientation;\n  if (defined(orientationData)) {\n    processPacketData(\n      Quaternion,\n      entity,\n      \"orientation\",\n      orientationData,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processProperties(entity, packet, entityCollection, sourceUri) {\n  const propertiesData = packet.properties;\n  if (defined(propertiesData)) {\n    if (!defined(entity.properties)) {\n      entity.properties = new PropertyBag();\n    }\n\n    // We cannot simply call processPacketData(entity, 'properties', propertyData, undefined, sourceUri, entityCollection)\n    // because each property of \"properties\" may vary separately.\n    // The properties will be accessible as entity.properties.myprop.getValue(time).\n\n    for (const key in propertiesData) {\n      if (propertiesData.hasOwnProperty(key)) {\n        if (!entity.properties.hasProperty(key)) {\n          entity.properties.addProperty(key);\n        }\n\n        const propertyData = propertiesData[key];\n        if (Array.isArray(propertyData)) {\n          for (let i = 0, len = propertyData.length; i < len; ++i) {\n            processProperty(\n              getPropertyType(propertyData[i]),\n              entity.properties,\n              key,\n              propertyData[i],\n              undefined,\n              sourceUri,\n              entityCollection,\n            );\n          }\n        } else {\n          processProperty(\n            getPropertyType(propertyData),\n            entity.properties,\n            key,\n            propertyData,\n            undefined,\n            sourceUri,\n            entityCollection,\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction processReferencesArrayPacketData(\n  object,\n  propertyName,\n  references,\n  interval,\n  entityCollection,\n  PropertyArrayType,\n  CompositePropertyArrayType,\n) {\n  const properties = references.map(function (reference) {\n    return createReferenceProperty(entityCollection, reference);\n  });\n\n  if (defined(interval)) {\n    interval = intervalFromString(interval);\n    let property = object[propertyName];\n    if (!(property instanceof CompositePropertyArrayType)) {\n      // If the property was not already a CompositeProperty,\n      // create a CompositeProperty but preserve the existing data.\n\n      // Create the composite and add the old property, wrapped in an infinite interval.\n      const composite = new CompositePropertyArrayType();\n      composite.intervals.addInterval(wrapPropertyInInfiniteInterval(property));\n\n      object[propertyName] = property = composite;\n    }\n\n    interval.data = new PropertyArrayType(properties);\n    property.intervals.addInterval(interval);\n  } else {\n    object[propertyName] = new PropertyArrayType(properties);\n  }\n}\n\nfunction processArrayPacketData(\n  object,\n  propertyName,\n  packetData,\n  entityCollection,\n) {\n  const references = packetData.references;\n  if (defined(references)) {\n    processReferencesArrayPacketData(\n      object,\n      propertyName,\n      references,\n      packetData.interval,\n      entityCollection,\n      PropertyArray,\n      CompositeProperty,\n    );\n  } else {\n    processPacketData(\n      Array,\n      object,\n      propertyName,\n      packetData,\n      undefined,\n      undefined,\n      entityCollection,\n    );\n  }\n}\n\nfunction processArray(object, propertyName, packetData, entityCollection) {\n  if (!defined(packetData)) {\n    return;\n  }\n\n  if (Array.isArray(packetData)) {\n    for (let i = 0, length = packetData.length; i < length; ++i) {\n      processArrayPacketData(\n        object,\n        propertyName,\n        packetData[i],\n        entityCollection,\n      );\n    }\n  } else {\n    processArrayPacketData(object, propertyName, packetData, entityCollection);\n  }\n}\n\nfunction processPositionArrayPacketData(\n  object,\n  propertyName,\n  packetData,\n  entityCollection,\n) {\n  const references = packetData.references;\n  if (defined(references)) {\n    processReferencesArrayPacketData(\n      object,\n      propertyName,\n      references,\n      packetData.interval,\n      entityCollection,\n      PositionPropertyArray,\n      CompositePositionProperty,\n    );\n  } else {\n    if (defined(packetData.cartesian)) {\n      packetData.array = Cartesian3.unpackArray(packetData.cartesian);\n    } else if (defined(packetData.cartographicRadians)) {\n      packetData.array = Cartesian3.fromRadiansArrayHeights(\n        packetData.cartographicRadians,\n        Ellipsoid.default,\n      );\n    } else if (defined(packetData.cartographicDegrees)) {\n      packetData.array = Cartesian3.fromDegreesArrayHeights(\n        packetData.cartographicDegrees,\n        Ellipsoid.default,\n      );\n    }\n\n    if (defined(packetData.array)) {\n      processPacketData(\n        Array,\n        object,\n        propertyName,\n        packetData,\n        undefined,\n        undefined,\n        entityCollection,\n      );\n    }\n  }\n}\n\nfunction processPositionArray(\n  object,\n  propertyName,\n  packetData,\n  entityCollection,\n) {\n  if (!defined(packetData)) {\n    return;\n  }\n\n  if (Array.isArray(packetData)) {\n    for (let i = 0, length = packetData.length; i < length; ++i) {\n      processPositionArrayPacketData(\n        object,\n        propertyName,\n        packetData[i],\n        entityCollection,\n      );\n    }\n  } else {\n    processPositionArrayPacketData(\n      object,\n      propertyName,\n      packetData,\n      entityCollection,\n    );\n  }\n}\n\nfunction unpackCartesianArray(array) {\n  return Cartesian3.unpackArray(array);\n}\n\nfunction unpackCartographicRadiansArray(array) {\n  return Cartesian3.fromRadiansArrayHeights(array, Ellipsoid.default);\n}\n\nfunction unpackCartographicDegreesArray(array) {\n  return Cartesian3.fromDegreesArrayHeights(array, Ellipsoid.default);\n}\n\nfunction processPositionArrayOfArraysPacketData(\n  object,\n  propertyName,\n  packetData,\n  entityCollection,\n) {\n  const references = packetData.references;\n  if (defined(references)) {\n    const properties = references.map(function (referenceArray) {\n      const tempObj = {};\n      processReferencesArrayPacketData(\n        tempObj,\n        \"positions\",\n        referenceArray,\n        packetData.interval,\n        entityCollection,\n        PositionPropertyArray,\n        CompositePositionProperty,\n      );\n      return tempObj.positions;\n    });\n    object[propertyName] = new PositionPropertyArray(properties);\n  } else {\n    if (defined(packetData.cartesian)) {\n      packetData.array = packetData.cartesian.map(unpackCartesianArray);\n    } else if (defined(packetData.cartographicRadians)) {\n      packetData.array = packetData.cartographicRadians.map(\n        unpackCartographicRadiansArray,\n      );\n    } else if (defined(packetData.cartographicDegrees)) {\n      packetData.array = packetData.cartographicDegrees.map(\n        unpackCartographicDegreesArray,\n      );\n    }\n\n    if (defined(packetData.array)) {\n      processPacketData(\n        Array,\n        object,\n        propertyName,\n        packetData,\n        undefined,\n        undefined,\n        entityCollection,\n      );\n    }\n  }\n}\n\nfunction processPositionArrayOfArrays(\n  object,\n  propertyName,\n  packetData,\n  entityCollection,\n) {\n  if (!defined(packetData)) {\n    return;\n  }\n\n  if (Array.isArray(packetData)) {\n    for (let i = 0, length = packetData.length; i < length; ++i) {\n      processPositionArrayOfArraysPacketData(\n        object,\n        propertyName,\n        packetData[i],\n        entityCollection,\n      );\n    }\n  } else {\n    processPositionArrayOfArraysPacketData(\n      object,\n      propertyName,\n      packetData,\n      entityCollection,\n    );\n  }\n}\n\nfunction processShape(object, propertyName, packetData, entityCollection) {\n  if (!defined(packetData)) {\n    return;\n  }\n\n  if (Array.isArray(packetData)) {\n    for (let i = 0, length = packetData.length; i < length; i++) {\n      processShapePacketData(\n        object,\n        propertyName,\n        packetData[i],\n        entityCollection,\n      );\n    }\n  } else {\n    processShapePacketData(object, propertyName, packetData, entityCollection);\n  }\n}\n\nfunction processAvailability(entity, packet, entityCollection, sourceUri) {\n  const packetData = packet.availability;\n  if (!defined(packetData)) {\n    return;\n  }\n\n  let intervals;\n  if (Array.isArray(packetData)) {\n    for (let i = 0, len = packetData.length; i < len; ++i) {\n      if (!defined(intervals)) {\n        intervals = new TimeIntervalCollection();\n      }\n      intervals.addInterval(intervalFromString(packetData[i]));\n    }\n  } else {\n    intervals = new TimeIntervalCollection();\n    intervals.addInterval(intervalFromString(packetData));\n  }\n  entity.availability = intervals;\n}\n\nfunction processAlignedAxis(\n  billboard,\n  packetData,\n  interval,\n  sourceUri,\n  entityCollection,\n) {\n  if (!defined(packetData)) {\n    return;\n  }\n\n  processPacketData(\n    UnitCartesian3,\n    billboard,\n    \"alignedAxis\",\n    packetData,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processBillboard(entity, packet, entityCollection, sourceUri) {\n  const billboardData = packet.billboard;\n  if (!defined(billboardData)) {\n    return;\n  }\n\n  const interval = intervalFromString(billboardData.interval);\n  let billboard = entity.billboard;\n  if (!defined(billboard)) {\n    entity.billboard = billboard = new BillboardGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    billboard,\n    \"show\",\n    billboardData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Image,\n    billboard,\n    \"image\",\n    billboardData.image,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    billboard,\n    \"scale\",\n    billboardData.scale,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Cartesian2,\n    billboard,\n    \"pixelOffset\",\n    billboardData.pixelOffset,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Cartesian3,\n    billboard,\n    \"eyeOffset\",\n    billboardData.eyeOffset,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HorizontalOrigin,\n    billboard,\n    \"horizontalOrigin\",\n    billboardData.horizontalOrigin,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    VerticalOrigin,\n    billboard,\n    \"verticalOrigin\",\n    billboardData.verticalOrigin,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    billboard,\n    \"heightReference\",\n    billboardData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    billboard,\n    \"color\",\n    billboardData.color,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Rotation,\n    billboard,\n    \"rotation\",\n    billboardData.rotation,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processAlignedAxis(\n    billboard,\n    billboardData.alignedAxis,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    billboard,\n    \"sizeInMeters\",\n    billboardData.sizeInMeters,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    billboard,\n    \"width\",\n    billboardData.width,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    billboard,\n    \"height\",\n    billboardData.height,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    NearFarScalar,\n    billboard,\n    \"scaleByDistance\",\n    billboardData.scaleByDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    NearFarScalar,\n    billboard,\n    \"translucencyByDistance\",\n    billboardData.translucencyByDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    NearFarScalar,\n    billboard,\n    \"pixelOffsetScaleByDistance\",\n    billboardData.pixelOffsetScaleByDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    BoundingRectangle,\n    billboard,\n    \"imageSubRegion\",\n    billboardData.imageSubRegion,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    billboard,\n    \"distanceDisplayCondition\",\n    billboardData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    billboard,\n    \"disableDepthTestDistance\",\n    billboardData.disableDepthTestDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processBox(entity, packet, entityCollection, sourceUri) {\n  const boxData = packet.box;\n  if (!defined(boxData)) {\n    return;\n  }\n\n  const interval = intervalFromString(boxData.interval);\n  let box = entity.box;\n  if (!defined(box)) {\n    entity.box = box = new BoxGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    box,\n    \"show\",\n    boxData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Cartesian3,\n    box,\n    \"dimensions\",\n    boxData.dimensions,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    box,\n    \"heightReference\",\n    boxData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    box,\n    \"fill\",\n    boxData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    box,\n    \"material\",\n    boxData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    box,\n    \"outline\",\n    boxData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    box,\n    \"outlineColor\",\n    boxData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    box,\n    \"outlineWidth\",\n    boxData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    box,\n    \"shadows\",\n    boxData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    box,\n    \"distanceDisplayCondition\",\n    boxData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processCorridor(entity, packet, entityCollection, sourceUri) {\n  const corridorData = packet.corridor;\n  if (!defined(corridorData)) {\n    return;\n  }\n\n  const interval = intervalFromString(corridorData.interval);\n  let corridor = entity.corridor;\n  if (!defined(corridor)) {\n    entity.corridor = corridor = new CorridorGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    corridor,\n    \"show\",\n    corridorData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPositionArray(\n    corridor,\n    \"positions\",\n    corridorData.positions,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    corridor,\n    \"width\",\n    corridorData.width,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    corridor,\n    \"height\",\n    corridorData.height,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    corridor,\n    \"heightReference\",\n    corridorData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    corridor,\n    \"extrudedHeight\",\n    corridorData.extrudedHeight,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    corridor,\n    \"extrudedHeightReference\",\n    corridorData.extrudedHeightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    CornerType,\n    corridor,\n    \"cornerType\",\n    corridorData.cornerType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    corridor,\n    \"granularity\",\n    corridorData.granularity,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    corridor,\n    \"fill\",\n    corridorData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    corridor,\n    \"material\",\n    corridorData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    corridor,\n    \"outline\",\n    corridorData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    corridor,\n    \"outlineColor\",\n    corridorData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    corridor,\n    \"outlineWidth\",\n    corridorData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    corridor,\n    \"shadows\",\n    corridorData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    corridor,\n    \"distanceDisplayCondition\",\n    corridorData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ClassificationType,\n    corridor,\n    \"classificationType\",\n    corridorData.classificationType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    corridor,\n    \"zIndex\",\n    corridorData.zIndex,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processCylinder(entity, packet, entityCollection, sourceUri) {\n  const cylinderData = packet.cylinder;\n  if (!defined(cylinderData)) {\n    return;\n  }\n\n  const interval = intervalFromString(cylinderData.interval);\n  let cylinder = entity.cylinder;\n  if (!defined(cylinder)) {\n    entity.cylinder = cylinder = new CylinderGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    cylinder,\n    \"show\",\n    cylinderData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    cylinder,\n    \"length\",\n    cylinderData.length,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    cylinder,\n    \"topRadius\",\n    cylinderData.topRadius,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    cylinder,\n    \"bottomRadius\",\n    cylinderData.bottomRadius,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    cylinder,\n    \"heightReference\",\n    cylinderData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    cylinder,\n    \"fill\",\n    cylinderData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    cylinder,\n    \"material\",\n    cylinderData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    cylinder,\n    \"outline\",\n    cylinderData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    cylinder,\n    \"outlineColor\",\n    cylinderData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    cylinder,\n    \"outlineWidth\",\n    cylinderData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    cylinder,\n    \"numberOfVerticalLines\",\n    cylinderData.numberOfVerticalLines,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    cylinder,\n    \"slices\",\n    cylinderData.slices,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    cylinder,\n    \"shadows\",\n    cylinderData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    cylinder,\n    \"distanceDisplayCondition\",\n    cylinderData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processDocument(packet, dataSource) {\n  const version = packet.version;\n  if (defined(version)) {\n    if (typeof version === \"string\") {\n      const tokens = version.split(\".\");\n      if (tokens.length === 2) {\n        if (tokens[0] !== \"1\") {\n          throw new RuntimeError(\"Cesium only supports CZML version 1.\");\n        }\n        dataSource._version = version;\n      }\n    }\n  }\n\n  if (!defined(dataSource._version)) {\n    throw new RuntimeError(\n      \"CZML version information invalid.  It is expected to be a property on the document object in the <Major>.<Minor> version format.\",\n    );\n  }\n\n  const documentPacket = dataSource._documentPacket;\n\n  if (defined(packet.name)) {\n    documentPacket.name = packet.name;\n  }\n\n  const clockPacket = packet.clock;\n  if (defined(clockPacket)) {\n    const clock = documentPacket.clock;\n    if (!defined(clock)) {\n      documentPacket.clock = {\n        interval: clockPacket.interval,\n        currentTime: clockPacket.currentTime,\n        range: clockPacket.range,\n        step: clockPacket.step,\n        multiplier: clockPacket.multiplier,\n      };\n    } else {\n      clock.interval = clockPacket.interval ?? clock.interval;\n      clock.currentTime = clockPacket.currentTime ?? clock.currentTime;\n      clock.range = clockPacket.range ?? clock.range;\n      clock.step = clockPacket.step ?? clock.step;\n      clock.multiplier = clockPacket.multiplier ?? clock.multiplier;\n    }\n  }\n}\n\nfunction processEllipse(entity, packet, entityCollection, sourceUri) {\n  const ellipseData = packet.ellipse;\n  if (!defined(ellipseData)) {\n    return;\n  }\n\n  const interval = intervalFromString(ellipseData.interval);\n  let ellipse = entity.ellipse;\n  if (!defined(ellipse)) {\n    entity.ellipse = ellipse = new EllipseGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    ellipse,\n    \"show\",\n    ellipseData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipse,\n    \"semiMajorAxis\",\n    ellipseData.semiMajorAxis,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipse,\n    \"semiMinorAxis\",\n    ellipseData.semiMinorAxis,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipse,\n    \"height\",\n    ellipseData.height,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    ellipse,\n    \"heightReference\",\n    ellipseData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipse,\n    \"extrudedHeight\",\n    ellipseData.extrudedHeight,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    ellipse,\n    \"extrudedHeightReference\",\n    ellipseData.extrudedHeightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Rotation,\n    ellipse,\n    \"rotation\",\n    ellipseData.rotation,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Rotation,\n    ellipse,\n    \"stRotation\",\n    ellipseData.stRotation,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipse,\n    \"granularity\",\n    ellipseData.granularity,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    ellipse,\n    \"fill\",\n    ellipseData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    ellipse,\n    \"material\",\n    ellipseData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    ellipse,\n    \"outline\",\n    ellipseData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    ellipse,\n    \"outlineColor\",\n    ellipseData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipse,\n    \"outlineWidth\",\n    ellipseData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipse,\n    \"numberOfVerticalLines\",\n    ellipseData.numberOfVerticalLines,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    ellipse,\n    \"shadows\",\n    ellipseData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    ellipse,\n    \"distanceDisplayCondition\",\n    ellipseData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ClassificationType,\n    ellipse,\n    \"classificationType\",\n    ellipseData.classificationType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipse,\n    \"zIndex\",\n    ellipseData.zIndex,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processEllipsoid(entity, packet, entityCollection, sourceUri) {\n  const ellipsoidData = packet.ellipsoid;\n  if (!defined(ellipsoidData)) {\n    return;\n  }\n\n  const interval = intervalFromString(ellipsoidData.interval);\n  let ellipsoid = entity.ellipsoid;\n  if (!defined(ellipsoid)) {\n    entity.ellipsoid = ellipsoid = new EllipsoidGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    ellipsoid,\n    \"show\",\n    ellipsoidData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Cartesian3,\n    ellipsoid,\n    \"radii\",\n    ellipsoidData.radii,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Cartesian3,\n    ellipsoid,\n    \"innerRadii\",\n    ellipsoidData.innerRadii,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipsoid,\n    \"minimumClock\",\n    ellipsoidData.minimumClock,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipsoid,\n    \"maximumClock\",\n    ellipsoidData.maximumClock,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipsoid,\n    \"minimumCone\",\n    ellipsoidData.minimumCone,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipsoid,\n    \"maximumCone\",\n    ellipsoidData.maximumCone,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    ellipsoid,\n    \"heightReference\",\n    ellipsoidData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    ellipsoid,\n    \"fill\",\n    ellipsoidData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    ellipsoid,\n    \"material\",\n    ellipsoidData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    ellipsoid,\n    \"outline\",\n    ellipsoidData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    ellipsoid,\n    \"outlineColor\",\n    ellipsoidData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipsoid,\n    \"outlineWidth\",\n    ellipsoidData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipsoid,\n    \"stackPartitions\",\n    ellipsoidData.stackPartitions,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipsoid,\n    \"slicePartitions\",\n    ellipsoidData.slicePartitions,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipsoid,\n    \"subdivisions\",\n    ellipsoidData.subdivisions,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    ellipsoid,\n    \"shadows\",\n    ellipsoidData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    ellipsoid,\n    \"distanceDisplayCondition\",\n    ellipsoidData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processLabel(entity, packet, entityCollection, sourceUri) {\n  const labelData = packet.label;\n  if (!defined(labelData)) {\n    return;\n  }\n\n  const interval = intervalFromString(labelData.interval);\n  let label = entity.label;\n  if (!defined(label)) {\n    entity.label = label = new LabelGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    label,\n    \"show\",\n    labelData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    String,\n    label,\n    \"text\",\n    labelData.text,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    String,\n    label,\n    \"font\",\n    labelData.font,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    LabelStyle,\n    label,\n    \"style\",\n    labelData.style,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    label,\n    \"scale\",\n    labelData.scale,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    label,\n    \"showBackground\",\n    labelData.showBackground,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    label,\n    \"backgroundColor\",\n    labelData.backgroundColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Cartesian2,\n    label,\n    \"backgroundPadding\",\n    labelData.backgroundPadding,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Cartesian2,\n    label,\n    \"pixelOffset\",\n    labelData.pixelOffset,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Cartesian3,\n    label,\n    \"eyeOffset\",\n    labelData.eyeOffset,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HorizontalOrigin,\n    label,\n    \"horizontalOrigin\",\n    labelData.horizontalOrigin,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    VerticalOrigin,\n    label,\n    \"verticalOrigin\",\n    labelData.verticalOrigin,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    label,\n    \"heightReference\",\n    labelData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    label,\n    \"fillColor\",\n    labelData.fillColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    label,\n    \"outlineColor\",\n    labelData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    label,\n    \"outlineWidth\",\n    labelData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    NearFarScalar,\n    label,\n    \"translucencyByDistance\",\n    labelData.translucencyByDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    NearFarScalar,\n    label,\n    \"pixelOffsetScaleByDistance\",\n    labelData.pixelOffsetScaleByDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    NearFarScalar,\n    label,\n    \"scaleByDistance\",\n    labelData.scaleByDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    label,\n    \"distanceDisplayCondition\",\n    labelData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    label,\n    \"disableDepthTestDistance\",\n    labelData.disableDepthTestDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processModel(entity, packet, entityCollection, sourceUri) {\n  const modelData = packet.model;\n  if (!defined(modelData)) {\n    return;\n  }\n\n  const interval = intervalFromString(modelData.interval);\n  let model = entity.model;\n  if (!defined(model)) {\n    entity.model = model = new ModelGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    model,\n    \"show\",\n    modelData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Uri,\n    model,\n    \"uri\",\n    modelData.gltf,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    model,\n    \"scale\",\n    modelData.scale,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    model,\n    \"minimumPixelSize\",\n    modelData.minimumPixelSize,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    model,\n    \"maximumScale\",\n    modelData.maximumScale,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    model,\n    \"incrementallyLoadTextures\",\n    modelData.incrementallyLoadTextures,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    model,\n    \"runAnimations\",\n    modelData.runAnimations,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    model,\n    \"clampAnimations\",\n    modelData.clampAnimations,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    model,\n    \"shadows\",\n    modelData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    model,\n    \"heightReference\",\n    modelData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    model,\n    \"silhouetteColor\",\n    modelData.silhouetteColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    model,\n    \"silhouetteSize\",\n    modelData.silhouetteSize,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    model,\n    \"color\",\n    modelData.color,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ColorBlendMode,\n    model,\n    \"colorBlendMode\",\n    modelData.colorBlendMode,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    model,\n    \"colorBlendAmount\",\n    modelData.colorBlendAmount,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    model,\n    \"distanceDisplayCondition\",\n    modelData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n\n  let i, len;\n  const nodeTransformationsData = modelData.nodeTransformations;\n  if (defined(nodeTransformationsData)) {\n    if (Array.isArray(nodeTransformationsData)) {\n      for (i = 0, len = nodeTransformationsData.length; i < len; ++i) {\n        processNodeTransformations(\n          model,\n          nodeTransformationsData[i],\n          interval,\n          sourceUri,\n          entityCollection,\n        );\n      }\n    } else {\n      processNodeTransformations(\n        model,\n        nodeTransformationsData,\n        interval,\n        sourceUri,\n        entityCollection,\n      );\n    }\n  }\n\n  const articulationsData = modelData.articulations;\n  if (defined(articulationsData)) {\n    if (Array.isArray(articulationsData)) {\n      for (i = 0, len = articulationsData.length; i < len; ++i) {\n        processArticulations(\n          model,\n          articulationsData[i],\n          interval,\n          sourceUri,\n          entityCollection,\n        );\n      }\n    } else {\n      processArticulations(\n        model,\n        articulationsData,\n        interval,\n        sourceUri,\n        entityCollection,\n      );\n    }\n  }\n}\n\nfunction processNodeTransformations(\n  model,\n  nodeTransformationsData,\n  constrainedInterval,\n  sourceUri,\n  entityCollection,\n) {\n  let combinedInterval = intervalFromString(nodeTransformationsData.interval);\n  if (defined(constrainedInterval)) {\n    if (defined(combinedInterval)) {\n      combinedInterval = TimeInterval.intersect(\n        combinedInterval,\n        constrainedInterval,\n        scratchTimeInterval,\n      );\n    } else {\n      combinedInterval = constrainedInterval;\n    }\n  }\n\n  let nodeTransformations = model.nodeTransformations;\n  const nodeNames = Object.keys(nodeTransformationsData);\n  for (let i = 0, len = nodeNames.length; i < len; ++i) {\n    const nodeName = nodeNames[i];\n    if (nodeName === \"interval\") {\n      continue;\n    }\n\n    const nodeTransformationData = nodeTransformationsData[nodeName];\n    if (!defined(nodeTransformationData)) {\n      continue;\n    }\n\n    if (!defined(nodeTransformations)) {\n      model.nodeTransformations = nodeTransformations = new PropertyBag();\n    }\n\n    if (!nodeTransformations.hasProperty(nodeName)) {\n      nodeTransformations.addProperty(nodeName);\n    }\n\n    let nodeTransformation = nodeTransformations[nodeName];\n    if (!defined(nodeTransformation)) {\n      nodeTransformations[nodeName] = nodeTransformation =\n        new NodeTransformationProperty();\n    }\n\n    processPacketData(\n      Cartesian3,\n      nodeTransformation,\n      \"translation\",\n      nodeTransformationData.translation,\n      combinedInterval,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Quaternion,\n      nodeTransformation,\n      \"rotation\",\n      nodeTransformationData.rotation,\n      combinedInterval,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Cartesian3,\n      nodeTransformation,\n      \"scale\",\n      nodeTransformationData.scale,\n      combinedInterval,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processArticulations(\n  model,\n  articulationsData,\n  constrainedInterval,\n  sourceUri,\n  entityCollection,\n) {\n  let combinedInterval = intervalFromString(articulationsData.interval);\n  if (defined(constrainedInterval)) {\n    if (defined(combinedInterval)) {\n      combinedInterval = TimeInterval.intersect(\n        combinedInterval,\n        constrainedInterval,\n        scratchTimeInterval,\n      );\n    } else {\n      combinedInterval = constrainedInterval;\n    }\n  }\n\n  let articulations = model.articulations;\n  const keys = Object.keys(articulationsData);\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    const key = keys[i];\n    if (key === \"interval\") {\n      continue;\n    }\n\n    const articulationStageData = articulationsData[key];\n    if (!defined(articulationStageData)) {\n      continue;\n    }\n\n    if (!defined(articulations)) {\n      model.articulations = articulations = new PropertyBag();\n    }\n\n    if (!articulations.hasProperty(key)) {\n      articulations.addProperty(key);\n    }\n\n    processPacketData(\n      Number,\n      articulations,\n      key,\n      articulationStageData,\n      combinedInterval,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processPath(entity, packet, entityCollection, sourceUri) {\n  const pathData = packet.path;\n  if (!defined(pathData)) {\n    return;\n  }\n\n  const interval = intervalFromString(pathData.interval);\n  let path = entity.path;\n  if (!defined(path)) {\n    entity.path = path = new PathGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    path,\n    \"show\",\n    pathData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    path,\n    \"leadTime\",\n    pathData.leadTime,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    path,\n    \"trailTime\",\n    pathData.trailTime,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    path,\n    \"width\",\n    pathData.width,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    path,\n    \"resolution\",\n    pathData.resolution,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    path,\n    \"material\",\n    pathData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    path,\n    \"distanceDisplayCondition\",\n    pathData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processPoint(entity, packet, entityCollection, sourceUri) {\n  const pointData = packet.point;\n  if (!defined(pointData)) {\n    return;\n  }\n\n  const interval = intervalFromString(pointData.interval);\n  let point = entity.point;\n  if (!defined(point)) {\n    entity.point = point = new PointGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    point,\n    \"show\",\n    pointData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    point,\n    \"pixelSize\",\n    pointData.pixelSize,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    point,\n    \"heightReference\",\n    pointData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    point,\n    \"color\",\n    pointData.color,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    point,\n    \"outlineColor\",\n    pointData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    point,\n    \"outlineWidth\",\n    pointData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    NearFarScalar,\n    point,\n    \"scaleByDistance\",\n    pointData.scaleByDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    NearFarScalar,\n    point,\n    \"translucencyByDistance\",\n    pointData.translucencyByDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    point,\n    \"distanceDisplayCondition\",\n    pointData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    point,\n    \"disableDepthTestDistance\",\n    pointData.disableDepthTestDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction PolygonHierarchyProperty(polygon) {\n  this.polygon = polygon;\n  this._definitionChanged = new Event();\n}\n\nObject.defineProperties(PolygonHierarchyProperty.prototype, {\n  isConstant: {\n    get: function () {\n      const positions = this.polygon._positions;\n      const holes = this.polygon._holes;\n      return (\n        (!defined(positions) || positions.isConstant) &&\n        (!defined(holes) || holes.isConstant)\n      );\n    },\n  },\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    },\n  },\n});\n\nPolygonHierarchyProperty.prototype.getValue = function (time, result) {\n  let positions;\n  if (defined(this.polygon._positions)) {\n    positions = this.polygon._positions.getValue(time);\n  }\n\n  let holes;\n  if (defined(this.polygon._holes)) {\n    holes = this.polygon._holes.getValue(time);\n    if (defined(holes)) {\n      holes = holes.map(function (holePositions) {\n        return new PolygonHierarchy(holePositions);\n      });\n    }\n  }\n\n  if (!defined(result)) {\n    return new PolygonHierarchy(positions, holes);\n  }\n\n  result.positions = positions;\n  result.holes = holes;\n  return result;\n};\n\nPolygonHierarchyProperty.prototype.equals = function (other) {\n  return (\n    this === other ||\n    (other instanceof PolygonHierarchyProperty &&\n      Property.equals(this.polygon._positions, other.polygon._positions) &&\n      Property.equals(this.polygon._holes, other.polygon._holes))\n  );\n};\n\nfunction processPolygon(entity, packet, entityCollection, sourceUri) {\n  const polygonData = packet.polygon;\n  if (!defined(polygonData)) {\n    return;\n  }\n\n  const interval = intervalFromString(polygonData.interval);\n  let polygon = entity.polygon;\n  if (!defined(polygon)) {\n    entity.polygon = polygon = new PolygonGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    polygon,\n    \"show\",\n    polygonData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n\n  // adapt 'position' property producing Cartesian[]\n  // and 'holes' property producing Cartesian[][]\n  // to a single property producing PolygonHierarchy\n  processPositionArray(\n    polygon,\n    \"_positions\",\n    polygonData.positions,\n    entityCollection,\n  );\n  processPositionArrayOfArrays(\n    polygon,\n    \"_holes\",\n    polygonData.holes,\n    entityCollection,\n  );\n  if (defined(polygon._positions) || defined(polygon._holes)) {\n    polygon.hierarchy = new PolygonHierarchyProperty(polygon);\n  }\n\n  processPacketData(\n    Number,\n    polygon,\n    \"height\",\n    polygonData.height,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    polygon,\n    \"heightReference\",\n    polygonData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polygon,\n    \"extrudedHeight\",\n    polygonData.extrudedHeight,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    polygon,\n    \"extrudedHeightReference\",\n    polygonData.extrudedHeightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Rotation,\n    polygon,\n    \"stRotation\",\n    polygonData.stRotation,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polygon,\n    \"granularity\",\n    polygonData.granularity,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polygon,\n    \"fill\",\n    polygonData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    polygon,\n    \"material\",\n    polygonData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polygon,\n    \"outline\",\n    polygonData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    polygon,\n    \"outlineColor\",\n    polygonData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polygon,\n    \"outlineWidth\",\n    polygonData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polygon,\n    \"perPositionHeight\",\n    polygonData.perPositionHeight,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polygon,\n    \"closeTop\",\n    polygonData.closeTop,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polygon,\n    \"closeBottom\",\n    polygonData.closeBottom,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ArcType,\n    polygon,\n    \"arcType\",\n    polygonData.arcType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    polygon,\n    \"shadows\",\n    polygonData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    polygon,\n    \"distanceDisplayCondition\",\n    polygonData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ClassificationType,\n    polygon,\n    \"classificationType\",\n    polygonData.classificationType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polygon,\n    \"zIndex\",\n    polygonData.zIndex,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction adaptFollowSurfaceToArcType(followSurface) {\n  return followSurface ? ArcType.GEODESIC : ArcType.NONE;\n}\n\nfunction processPolyline(entity, packet, entityCollection, sourceUri) {\n  const polylineData = packet.polyline;\n  if (!defined(polylineData)) {\n    return;\n  }\n\n  const interval = intervalFromString(polylineData.interval);\n  let polyline = entity.polyline;\n  if (!defined(polyline)) {\n    entity.polyline = polyline = new PolylineGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    polyline,\n    \"show\",\n    polylineData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPositionArray(\n    polyline,\n    \"positions\",\n    polylineData.positions,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polyline,\n    \"width\",\n    polylineData.width,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polyline,\n    \"granularity\",\n    polylineData.granularity,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    polyline,\n    \"material\",\n    polylineData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    polyline,\n    \"depthFailMaterial\",\n    polylineData.depthFailMaterial,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ArcType,\n    polyline,\n    \"arcType\",\n    polylineData.arcType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polyline,\n    \"clampToGround\",\n    polylineData.clampToGround,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    polyline,\n    \"shadows\",\n    polylineData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    polyline,\n    \"distanceDisplayCondition\",\n    polylineData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ClassificationType,\n    polyline,\n    \"classificationType\",\n    polylineData.classificationType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polyline,\n    \"zIndex\",\n    polylineData.zIndex,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n\n  // for backwards compatibility, adapt CZML followSurface to arcType.\n  if (defined(polylineData.followSurface) && !defined(polylineData.arcType)) {\n    const tempObj = {};\n    processPacketData(\n      Boolean,\n      tempObj,\n      \"followSurface\",\n      polylineData.followSurface,\n      interval,\n      sourceUri,\n      entityCollection,\n    );\n    polyline.arcType = createAdapterProperty(\n      tempObj.followSurface,\n      adaptFollowSurfaceToArcType,\n    );\n  }\n}\n\nfunction processPolylineVolume(entity, packet, entityCollection, sourceUri) {\n  const polylineVolumeData = packet.polylineVolume;\n  if (!defined(polylineVolumeData)) {\n    return;\n  }\n\n  const interval = intervalFromString(polylineVolumeData.interval);\n  let polylineVolume = entity.polylineVolume;\n  if (!defined(polylineVolume)) {\n    entity.polylineVolume = polylineVolume = new PolylineVolumeGraphics();\n  }\n\n  processPositionArray(\n    polylineVolume,\n    \"positions\",\n    polylineVolumeData.positions,\n    entityCollection,\n  );\n  processShape(\n    polylineVolume,\n    \"shape\",\n    polylineVolumeData.shape,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polylineVolume,\n    \"show\",\n    polylineVolumeData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    CornerType,\n    polylineVolume,\n    \"cornerType\",\n    polylineVolumeData.cornerType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polylineVolume,\n    \"fill\",\n    polylineVolumeData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    polylineVolume,\n    \"material\",\n    polylineVolumeData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polylineVolume,\n    \"outline\",\n    polylineVolumeData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    polylineVolume,\n    \"outlineColor\",\n    polylineVolumeData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polylineVolume,\n    \"outlineWidth\",\n    polylineVolumeData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polylineVolume,\n    \"granularity\",\n    polylineVolumeData.granularity,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    polylineVolume,\n    \"shadows\",\n    polylineVolumeData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    polylineVolume,\n    \"distanceDisplayCondition\",\n    polylineVolumeData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processRectangle(entity, packet, entityCollection, sourceUri) {\n  const rectangleData = packet.rectangle;\n  if (!defined(rectangleData)) {\n    return;\n  }\n\n  const interval = intervalFromString(rectangleData.interval);\n  let rectangle = entity.rectangle;\n  if (!defined(rectangle)) {\n    entity.rectangle = rectangle = new RectangleGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    rectangle,\n    \"show\",\n    rectangleData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Rectangle,\n    rectangle,\n    \"coordinates\",\n    rectangleData.coordinates,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    rectangle,\n    \"height\",\n    rectangleData.height,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    rectangle,\n    \"heightReference\",\n    rectangleData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    rectangle,\n    \"extrudedHeight\",\n    rectangleData.extrudedHeight,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    rectangle,\n    \"extrudedHeightReference\",\n    rectangleData.extrudedHeightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Rotation,\n    rectangle,\n    \"rotation\",\n    rectangleData.rotation,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Rotation,\n    rectangle,\n    \"stRotation\",\n    rectangleData.stRotation,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    rectangle,\n    \"granularity\",\n    rectangleData.granularity,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    rectangle,\n    \"fill\",\n    rectangleData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    rectangle,\n    \"material\",\n    rectangleData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    rectangle,\n    \"outline\",\n    rectangleData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    rectangle,\n    \"outlineColor\",\n    rectangleData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    rectangle,\n    \"outlineWidth\",\n    rectangleData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    rectangle,\n    \"shadows\",\n    rectangleData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    rectangle,\n    \"distanceDisplayCondition\",\n    rectangleData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ClassificationType,\n    rectangle,\n    \"classificationType\",\n    rectangleData.classificationType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    rectangle,\n    \"zIndex\",\n    rectangleData.zIndex,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processTileset(entity, packet, entityCollection, sourceUri) {\n  const tilesetData = packet.tileset;\n  if (!defined(tilesetData)) {\n    return;\n  }\n\n  const interval = intervalFromString(tilesetData.interval);\n  let tileset = entity.tileset;\n  if (!defined(tileset)) {\n    entity.tileset = tileset = new Cesium3DTilesetGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    tileset,\n    \"show\",\n    tilesetData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Uri,\n    tileset,\n    \"uri\",\n    tilesetData.uri,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    tileset,\n    \"maximumScreenSpaceError\",\n    tilesetData.maximumScreenSpaceError,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processWall(entity, packet, entityCollection, sourceUri) {\n  const wallData = packet.wall;\n  if (!defined(wallData)) {\n    return;\n  }\n\n  const interval = intervalFromString(wallData.interval);\n  let wall = entity.wall;\n  if (!defined(wall)) {\n    entity.wall = wall = new WallGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    wall,\n    \"show\",\n    wallData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPositionArray(wall, \"positions\", wallData.positions, entityCollection);\n  processArray(\n    wall,\n    \"minimumHeights\",\n    wallData.minimumHeights,\n    entityCollection,\n  );\n  processArray(\n    wall,\n    \"maximumHeights\",\n    wallData.maximumHeights,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    wall,\n    \"granularity\",\n    wallData.granularity,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    wall,\n    \"fill\",\n    wallData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    wall,\n    \"material\",\n    wallData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    wall,\n    \"outline\",\n    wallData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    wall,\n    \"outlineColor\",\n    wallData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    wall,\n    \"outlineWidth\",\n    wallData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    wall,\n    \"shadows\",\n    wallData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    wall,\n    \"distanceDisplayCondition\",\n    wallData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processCzmlPacket(\n  packet,\n  entityCollection,\n  updaterFunctions,\n  sourceUri,\n  dataSource,\n) {\n  let objectId = packet.id;\n  if (!defined(objectId)) {\n    objectId = createGuid();\n  }\n\n  currentId = objectId;\n\n  if (!defined(dataSource._version) && objectId !== \"document\") {\n    throw new RuntimeError(\n      \"The first CZML packet is required to be the document object.\",\n    );\n  }\n\n  if (packet[\"delete\"] === true) {\n    entityCollection.removeById(objectId);\n  } else if (objectId === \"document\") {\n    processDocument(packet, dataSource);\n  } else {\n    const entity = entityCollection.getOrCreateEntity(objectId);\n\n    const parentId = packet.parent;\n    if (defined(parentId)) {\n      entity.parent = entityCollection.getOrCreateEntity(parentId);\n    }\n\n    for (let i = updaterFunctions.length - 1; i > -1; i--) {\n      updaterFunctions[i](entity, packet, entityCollection, sourceUri);\n    }\n  }\n\n  currentId = undefined;\n}\n\nfunction updateClock(dataSource) {\n  let clock;\n  const clockPacket = dataSource._documentPacket.clock;\n  if (!defined(clockPacket)) {\n    if (!defined(dataSource._clock)) {\n      const availability = dataSource._entityCollection.computeAvailability();\n      if (!availability.start.equals(Iso8601.MINIMUM_VALUE)) {\n        const startTime = availability.start;\n        const stopTime = availability.stop;\n        const totalSeconds = JulianDate.secondsDifference(stopTime, startTime);\n        const multiplier = Math.round(totalSeconds / 120.0);\n\n        clock = new DataSourceClock();\n        clock.startTime = JulianDate.clone(startTime);\n        clock.stopTime = JulianDate.clone(stopTime);\n        clock.clockRange = ClockRange.LOOP_STOP;\n        clock.multiplier = multiplier;\n        clock.currentTime = JulianDate.clone(startTime);\n        clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n        dataSource._clock = clock;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  if (defined(dataSource._clock)) {\n    clock = dataSource._clock.clone();\n  } else {\n    clock = new DataSourceClock();\n    clock.startTime = Iso8601.MINIMUM_VALUE.clone();\n    clock.stopTime = Iso8601.MAXIMUM_VALUE.clone();\n    clock.currentTime = Iso8601.MINIMUM_VALUE.clone();\n    clock.clockRange = ClockRange.LOOP_STOP;\n    clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n    clock.multiplier = 1.0;\n  }\n\n  const interval = intervalFromString(clockPacket.interval);\n  if (defined(interval)) {\n    clock.startTime = interval.start;\n    clock.stopTime = interval.stop;\n  }\n\n  if (defined(clockPacket.currentTime)) {\n    clock.currentTime = JulianDate.fromIso8601(clockPacket.currentTime);\n  }\n  if (defined(clockPacket.range)) {\n    clock.clockRange = ClockRange[clockPacket.range] ?? ClockRange.LOOP_STOP;\n  }\n  if (defined(clockPacket.step)) {\n    clock.clockStep =\n      ClockStep[clockPacket.step] ?? ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n  }\n  if (defined(clockPacket.multiplier)) {\n    clock.multiplier = clockPacket.multiplier;\n  }\n\n  if (!clock.equals(dataSource._clock)) {\n    dataSource._clock = clock.clone(dataSource._clock);\n    return true;\n  }\n\n  return false;\n}\n\nfunction load(dataSource, czml, options, clear) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(czml)) {\n    throw new DeveloperError(\"czml is required.\");\n  }\n  //>>includeEnd('debug');\n\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  let promise = czml;\n  let sourceUri = options.sourceUri;\n\n  // User specified credit\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  dataSource._credit = credit;\n\n  // If the czml is a URL\n  if (typeof czml === \"string\" || czml instanceof Resource) {\n    czml = Resource.createIfNeeded(czml);\n    promise = czml.fetchJson();\n    sourceUri = sourceUri ?? czml.clone();\n\n    // Add resource credits to our list of credits to display\n    const resourceCredits = dataSource._resourceCredits;\n    const credits = czml.credits;\n    if (defined(credits)) {\n      const length = credits.length;\n      for (let i = 0; i < length; i++) {\n        resourceCredits.push(credits[i]);\n      }\n    }\n  }\n\n  sourceUri = Resource.createIfNeeded(sourceUri);\n\n  DataSource.setLoading(dataSource, true);\n\n  return Promise.resolve(promise)\n    .then(function (czml) {\n      return loadCzml(dataSource, czml, sourceUri, clear);\n    })\n    .catch(function (error) {\n      DataSource.setLoading(dataSource, false);\n      dataSource._error.raiseEvent(dataSource, error);\n      console.log(error);\n      return Promise.reject(error);\n    });\n}\n\nfunction loadCzml(dataSource, czml, sourceUri, clear) {\n  DataSource.setLoading(dataSource, true);\n  const entityCollection = dataSource._entityCollection;\n\n  if (clear) {\n    dataSource._version = undefined;\n    dataSource._documentPacket = new DocumentPacket();\n    entityCollection.removeAll();\n  }\n\n  CzmlDataSource._processCzml(\n    czml,\n    entityCollection,\n    sourceUri,\n    undefined,\n    dataSource,\n  );\n\n  let raiseChangedEvent = updateClock(dataSource);\n\n  const documentPacket = dataSource._documentPacket;\n  if (\n    defined(documentPacket.name) &&\n    dataSource._name !== documentPacket.name\n  ) {\n    dataSource._name = documentPacket.name;\n    raiseChangedEvent = true;\n  } else if (!defined(dataSource._name) && defined(sourceUri)) {\n    dataSource._name = getFilenameFromUri(sourceUri.getUrlComponent());\n    raiseChangedEvent = true;\n  }\n\n  DataSource.setLoading(dataSource, false);\n  if (raiseChangedEvent) {\n    dataSource._changed.raiseEvent(dataSource);\n  }\n\n  return dataSource;\n}\n\nfunction DocumentPacket() {\n  this.name = undefined;\n  this.clock = undefined;\n}\n\n/**\n * @typedef {object} CzmlDataSource.LoadOptions\n *\n * Initialization options for the <code>load</code> method.\n *\n * @property {Resource|string} [sourceUri] Overrides the url to use for resolving relative links.\n * @property {Credit|string} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * A {@link DataSource} which processes {@link https://github.com/AnalyticalGraphicsInc/czml-writer/wiki/CZML-Guide|CZML}.\n * @alias CzmlDataSource\n * @constructor\n *\n * @param {string} [name] An optional name for the data source.  This value will be overwritten if a loaded document contains a name.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=CZML.html|Cesium Sandcastle CZML Demo}\n */\nfunction CzmlDataSource(name) {\n  this._name = name;\n  this._changed = new Event();\n  this._error = new Event();\n  this._isLoading = false;\n  this._loading = new Event();\n  this._clock = undefined;\n  this._documentPacket = new DocumentPacket();\n  this._version = undefined;\n  this._entityCollection = new EntityCollection(this);\n  this._entityCluster = new EntityCluster();\n  this._credit = undefined;\n  this._resourceCredits = [];\n}\n\n/**\n * Creates a Promise to a new instance loaded with the provided CZML data.\n *\n * @param {Resource|string|object} czml A url or CZML object to be processed.\n * @param {CzmlDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<CzmlDataSource>} A promise that resolves to the new instance once the data is processed.\n */\nCzmlDataSource.load = function (czml, options) {\n  return new CzmlDataSource().load(czml, options);\n};\n\nObject.defineProperties(CzmlDataSource.prototype, {\n  /**\n   * Gets a human-readable name for this instance.\n   * @memberof CzmlDataSource.prototype\n   * @type {string}\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n  /**\n   * Gets the clock settings defined by the loaded CZML.  If no clock is explicitly\n   * defined in the CZML, the combined availability of all objects is returned.  If\n   * only static data exists, this value is undefined.\n   * @memberof CzmlDataSource.prototype\n   * @type {DataSourceClock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    },\n  },\n  /**\n   * Gets the collection of {@link Entity} instances.\n   * @memberof CzmlDataSource.prototype\n   * @type {EntityCollection}\n   */\n  entities: {\n    get: function () {\n      return this._entityCollection;\n    },\n  },\n  /**\n   * Gets a value indicating if the data source is currently loading data.\n   * @memberof CzmlDataSource.prototype\n   * @type {boolean}\n   */\n  isLoading: {\n    get: function () {\n      return this._isLoading;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the underlying data changes.\n   * @memberof CzmlDataSource.prototype\n   * @type {Event}\n   */\n  changedEvent: {\n    get: function () {\n      return this._changed;\n    },\n  },\n  /**\n   * Gets an event that will be raised if an error is encountered during processing.\n   * @memberof CzmlDataSource.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._error;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the data source either starts or stops loading.\n   * @memberof CzmlDataSource.prototype\n   * @type {Event}\n   */\n  loadingEvent: {\n    get: function () {\n      return this._loading;\n    },\n  },\n  /**\n   * Gets whether or not this data source should be displayed.\n   * @memberof CzmlDataSource.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return this._entityCollection.show;\n    },\n    set: function (value) {\n      this._entityCollection.show = value;\n    },\n  },\n\n  /**\n   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.\n   *\n   * @memberof CzmlDataSource.prototype\n   * @type {EntityCluster}\n   */\n  clustering: {\n    get: function () {\n      return this._entityCluster;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value must be defined.\");\n      }\n      //>>includeEnd('debug');\n      this._entityCluster = value;\n    },\n  },\n  /**\n   * Gets the credit that will be displayed for the data source\n   * @memberof CzmlDataSource.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n});\n\n/**\n * @callback CzmlDataSource.UpdaterFunction\n *\n * A CZML processing function that adds or updates entities in the provided\n * collection based on the provided CZML packet.\n *\n * @param {Entity} entity\n * @param {object} packet\n * @param {EntityCollection} entityCollection\n * @param {string} sourceUri\n */\n\n/**\n * Gets the array of CZML processing functions.\n * @memberof CzmlDataSource\n * @type {CzmlDataSource.UpdaterFunction[]}\n */\nCzmlDataSource.updaters = [\n  processBillboard,\n  processBox,\n  processCorridor,\n  processCylinder,\n  processEllipse,\n  processEllipsoid,\n  processLabel,\n  processModel,\n  processName,\n  processDescription,\n  processPath,\n  processPoint,\n  processPolygon,\n  processPolyline,\n  processPolylineVolume,\n  processProperties,\n  processRectangle,\n  processPosition,\n  processTileset,\n  processViewFrom,\n  processWall,\n  processOrientation,\n  processAvailability,\n];\n\n/**\n * Add the provided updater to the list of updaters if not already included\n * @private\n * @param {CzmlDataSource.UpdaterFunction} updater\n */\nCzmlDataSource.registerUpdater = function (updater) {\n  if (!CzmlDataSource.updaters.includes(updater)) {\n    CzmlDataSource.updaters.push(updater);\n  }\n};\n\n/**\n * Remove the provided updater from the list of updaters if already included\n * @private\n * @param {CzmlDataSource.UpdaterFunction} updater\n */\nCzmlDataSource.unregisterUpdater = function (updater) {\n  if (CzmlDataSource.updaters.includes(updater)) {\n    const index = CzmlDataSource.updaters.indexOf(updater);\n    CzmlDataSource.updaters.splice(index, 1);\n  }\n};\n\n/**\n * Processes the provided url or CZML object without clearing any existing data.\n *\n * @param {Resource|string|object} czml A url or CZML object to be processed.\n * @param {CzmlDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<CzmlDataSource>} A promise that resolves to this instances once the data is processed.\n */\nCzmlDataSource.prototype.process = function (czml, options) {\n  return load(this, czml, options, false);\n};\n\n/**\n * Loads the provided url or CZML object, replacing any existing data.\n *\n * @param {Resource|string|object} czml A url or CZML object to be processed.\n * @param {CzmlDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<CzmlDataSource>} A promise that resolves to this instances once the data is processed.\n */\nCzmlDataSource.prototype.load = function (czml, options) {\n  return load(this, czml, options, true);\n};\n\n/**\n * Updates the data source to the provided time.  This function is optional and\n * is not required to be implemented.  It is provided for data sources which\n * retrieve data based on the current animation time or scene state.\n * If implemented, update will be called by {@link DataSourceDisplay} once a frame.\n *\n * @param {JulianDate} time The simulation time.\n * @returns {boolean} True if this data source is ready to be displayed at the provided time, false otherwise.\n */\nCzmlDataSource.prototype.update = function (time) {\n  return true;\n};\n\n/**\n * A helper function used by custom CZML updater functions\n * which creates or updates a {@link Property} from a CZML packet.\n * @function\n *\n * @param {Function} type The constructor function for the property being processed.\n * @param {object} object The object on which the property will be added or updated.\n * @param {string} propertyName The name of the property on the object.\n * @param {object} packetData The CZML packet being processed.\n * @param {TimeInterval} interval A constraining interval for which the data is valid.\n * @param {string} sourceUri The originating uri of the data being processed.\n * @param {EntityCollection} entityCollection The collection being processsed.\n */\nCzmlDataSource.processPacketData = processPacketData;\n\n/**\n * A helper function used by custom CZML updater functions\n * which creates or updates a {@link PositionProperty} from a CZML packet.\n * @function\n *\n * @param {object} object The object on which the property will be added or updated.\n * @param {string} propertyName The name of the property on the object.\n * @param {object} packetData The CZML packet being processed.\n * @param {TimeInterval} interval A constraining interval for which the data is valid.\n * @param {string} sourceUri The originating uri of the data being processed.\n * @param {EntityCollection} entityCollection The collection being processsed.\n */\nCzmlDataSource.processPositionPacketData = processPositionPacketData;\n\n/**\n * A helper function used by custom CZML updater functions\n * which creates or updates a {@link MaterialProperty} from a CZML packet.\n * @function\n *\n * @param {object} object The object on which the property will be added or updated.\n * @param {string} propertyName The name of the property on the object.\n * @param {object} packetData The CZML packet being processed.\n * @param {TimeInterval} interval A constraining interval for which the data is valid.\n * @param {string} sourceUri The originating uri of the data being processed.\n * @param {EntityCollection} entityCollection The collection being processsed.\n */\nCzmlDataSource.processMaterialPacketData = processMaterialPacketData;\n\nCzmlDataSource._processCzml = function (\n  czml,\n  entityCollection,\n  sourceUri,\n  updaterFunctions,\n  dataSource,\n) {\n  updaterFunctions = updaterFunctions ?? CzmlDataSource.updaters;\n\n  if (Array.isArray(czml)) {\n    for (let i = 0, len = czml.length; i < len; ++i) {\n      processCzmlPacket(\n        czml[i],\n        entityCollection,\n        updaterFunctions,\n        sourceUri,\n        dataSource,\n      );\n    }\n  } else {\n    processCzmlPacket(\n      czml,\n      entityCollection,\n      updaterFunctions,\n      sourceUri,\n      dataSource,\n    );\n  }\n};\nexport default CzmlDataSource;\n"],"names":["UnitCartesian3","packedLength","unpack","pack","currentId","createReferenceProperty","entityCollection","referenceString","fromString","createSpecializedProperty","type","packetData","reference","velocityReference","referenceProperty","JSON","stringify","createAdapterProperty","property","adapterFunction","time","result","getValue","isConstant","scratchCartesian","scratchSpherical","scratchCartographic","scratchTimeInterval","scratchQuaternion","unwrapColorInterval","czmlInterval","rgbaf","rgba","undefined","length","byteToFloat","Array","i","unwrapUriInterval","sourceUri","uri","getDerivedResource","url","createIfNeeded","unwrapRectangleInterval","wsen","wsenDegrees","toRadians","convertUnitSphericalToCartesian","unitSpherical","magnitude","clock","cone","fromSpherical","x","y","z","j","convertSphericalToCartesian","spherical","convertCartographicRadiansToCartesian","cartographicRadians","longitude","latitude","height","default","cartographicToCartesian","convertCartographicDegreesToCartesian","cartographicDegrees","unwrapCartesianInterval","cartesian","cartesianVelocity","unitCartesian","normalizePackedCartesianArray","array","startingIndex","normalize","unwrapUnitCartesianInterval","normalizePackedQuaternionArray","unwrapQuaternionInterval","unitQuaternion","getPropertyType","Boolean","Number","String","hasOwnProperty","Object","unwrapInterval","arcType","boundingRectangle","cartesian2","classificationType","colorBlendMode","cornerType","heightReference","horizontalOrigin","Image","fromIso8601","date","labelStyle","number","nearFarScalar","distanceDisplayCondition","object","value","portionToDisplay","shadowMode","shadows","string","stripeOrientation","verticalOrigin","interpolators","HERMITE","LAGRANGE","LINEAR","updateInterpolationSettings","interpolationAlgorithm","interpolationDegree","setInterpolationOptions","forwardExtrapolationType","forwardExtrapolationDuration","backwardExtrapolationType","backwardExtrapolationDuration","iso8601Scratch","iso8601","intervalFromString","intervalString","wrapPropertyInInfiniteInterval","interval","MAXIMUM_INTERVAL","clone","data","convertPropertyToComposite","composite","intervals","addInterval","convertPositionPropertyToComposite","referenceFrame","processProperty","propertyName","constrainedInterval","combinedInterval","intersect","unwrappedInterval","unwrappedIntervalLength","isValue","hasInterval","equals","delete","removePropertyData","isSampled","needsUnpacking","epoch","packetEpoch","addSamplesPackedArray","findInterval","removeSamples","removeInterval","intersection","get","isEmpty","processPacketData","isArray","len","processPositionProperty","numberOfDerivatives","removePositionPropertyData","FIXED","processPositionPacketData","processShapePacketData","references","processReferencesArrayPacketData","unpackArray","processMaterialProperty","existingMaterial","existingInterval","thisIntervals","start","stop","materialData","solidColor","color","grid","cellAlpha","lineCount","lineThickness","lineOffset","image","repeat","transparent","stripe","orientation","evenColor","oddColor","offset","polylineOutline","outlineColor","outlineWidth","polylineGlow","glowPower","taperPower","polylineArrow","polylineDash","gapColor","dashLength","dashPattern","checkerboard","processMaterialPacketData","processName","entity","packet","nameData","name","processDescription","descriptionData","description","processPosition","positionData","position","processViewFrom","viewFromData","viewFrom","processOrientation","orientationData","processProperties","propertiesData","properties","key","hasProperty","addProperty","propertyData","PropertyArrayType","CompositePropertyArrayType","map","processArrayPacketData","processArray","processPositionArrayPacketData","fromRadiansArrayHeights","fromDegreesArrayHeights","processPositionArray","unpackCartesianArray","unpackCartographicRadiansArray","unpackCartographicDegreesArray","processPositionArrayOfArraysPacketData","referenceArray","tempObj","positions","processPositionArrayOfArrays","processShape","processAvailability","availability","processAlignedAxis","billboard","processBillboard","billboardData","show","scale","pixelOffset","eyeOffset","rotation","alignedAxis","sizeInMeters","width","scaleByDistance","translucencyByDistance","pixelOffsetScaleByDistance","imageSubRegion","disableDepthTestDistance","processBox","boxData","box","dimensions","fill","material","outline","processCorridor","corridorData","corridor","extrudedHeight","extrudedHeightReference","granularity","zIndex","processCylinder","cylinderData","cylinder","topRadius","bottomRadius","numberOfVerticalLines","slices","processDocument","dataSource","version","tokens","split","_version","documentPacket","_documentPacket","clockPacket","currentTime","range","step","multiplier","processEllipse","ellipseData","ellipse","semiMajorAxis","semiMinorAxis","stRotation","processEllipsoid","ellipsoidData","ellipsoid","radii","innerRadii","minimumClock","maximumClock","minimumCone","maximumCone","stackPartitions","slicePartitions","subdivisions","processLabel","labelData","label","text","font","style","showBackground","backgroundColor","backgroundPadding","fillColor","processModel","modelData","model","gltf","minimumPixelSize","maximumScale","incrementallyLoadTextures","runAnimations","clampAnimations","silhouetteColor","silhouetteSize","colorBlendAmount","nodeTransformationsData","nodeTransformations","processNodeTransformations","articulationsData","articulations","processArticulations","nodeNames","keys","nodeName","nodeTransformationData","nodeTransformation","translation","articulationStageData","processPath","pathData","path","leadTime","trailTime","resolution","processPoint","pointData","point","pixelSize","PolygonHierarchyProperty","polygon","_definitionChanged","defineProperties","prototype","_positions","holes","_holes","definitionChanged","holePositions","other","processPolygon","polygonData","hierarchy","perPositionHeight","closeTop","closeBottom","adaptFollowSurfaceToArcType","followSurface","GEODESIC","NONE","processPolyline","polylineData","polyline","depthFailMaterial","clampToGround","processPolylineVolume","polylineVolumeData","polylineVolume","shape","processRectangle","rectangleData","rectangle","coordinates","processTileset","tilesetData","tileset","maximumScreenSpaceError","processWall","wallData","wall","minimumHeights","maximumHeights","processCzmlPacket","updaterFunctions","objectId","id","removeById","getOrCreateEntity","parentId","parent","updateClock","_clock","_entityCollection","computeAvailability","MINIMUM_VALUE","startTime","stopTime","totalSeconds","secondsDifference","Math","round","clockRange","LOOP_STOP","clockStep","SYSTEM_CLOCK_MULTIPLIER","MAXIMUM_VALUE","load","czml","options","clear","EMPTY_OBJECT","promise","credit","_credit","fetchJson","resourceCredits","_resourceCredits","credits","push","setLoading","Promise","resolve","then","loadCzml","catch","error","_error","raiseEvent","console","log","reject","DocumentPacket","removeAll","CzmlDataSource","_processCzml","raiseChangedEvent","_name","getUrlComponent","_changed","_isLoading","_loading","_entityCluster","entities","isLoading","changedEvent","errorEvent","loadingEvent","set","clustering","updaters","registerUpdater","updater","includes","unregisterUpdater","index","indexOf","splice","process","update"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,2FAA2F;AAC3F,4EAA4E;AAC5E,SAASA,kBAAkB;AAC3BA,eAAeC,YAAY,GAAG,gLAAU,CAACA,YAAY;AACrDD,eAAeE,MAAM,GAAG,gLAAU,CAACA,MAAM;AACzCF,eAAeG,IAAI,GAAG,gLAAU,CAACA,IAAI;AAErC,2FAA2F;AAE3F,IAAIC;AAEJ,SAASC,wBAAwBC,gBAAgB,EAAEC,eAAe;IAChE,IAAIA,eAAe,CAAC,EAAE,KAAK,KAAK;QAC9BA,kBAAkBH,YAAYG;IAChC;IACA,OAAO,8LAAiB,CAACC,UAAU,CAACF,kBAAkBC;AACxD;AAEA,SAASE,0BAA0BC,IAAI,EAAEJ,gBAAgB,EAAEK,UAAU;IACnE,IAAI,IAAA,6KAAO,EAACA,WAAWC,SAAS,GAAG;QACjC,OAAOP,wBAAwBC,kBAAkBK,WAAWC,SAAS;IACvE;IAEA,IAAI,IAAA,6KAAO,EAACD,WAAWE,iBAAiB,GAAG;QACzC,MAAMC,oBAAoBT,wBACxBC,kBACAK,WAAWE,iBAAiB;QAE9B,OAAQH;YACN,KAAK,gLAAU;YACf,KAAKV;gBACH,OAAO,IAAI,mMAAsB,CAC/Bc,m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","ignoreList":[0]}}]
}